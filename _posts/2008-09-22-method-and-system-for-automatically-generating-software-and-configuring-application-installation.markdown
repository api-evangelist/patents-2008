---

title: Method and system for automatically generating software and configuring application installation
abstract: Methods and apparatuses are disclosed for automatically generating software and configuring software application installation. Some embodiments may include a method of configuring one or more hardware resources within an enterprise, the method comprising the acts of installing at least one software application on the one or more hardware resources, orienting one or more logical areas within the one or more hardware resources, implementing one or more communication protocols between the one or more logical areas, and generating infrastructure for the at least one software application during the act of installing, wherein the infrastructure is based on predetermined choices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08438304&OS=08438304&RS=08438304
owner: Oracle America, Inc.
number: 08438304
owner_city: Redwood City
owner_country: US
publication_date: 20080922
---
Computers are ubiquitous in today s society. They come in all different varieties and can be found in places such as automobiles the grocery store banks personal digital assistants cell phones as well as in many companies. For each of these implementations computers may execute different types of computer software sometimes called applications where the application is custom suited to the particular implementation. In a corporate environment sometimes called an enterprise scenario the company may have hundreds or thousands of computers being used in different ways each with different software needs. These software needs include applications dedicated to the activities that end users operating the computer may need as well as activities dedicated to the infrastructure and or management responsibilities. For example a bank may implement a financial application that allows users to manage their finances from their home computer. In this example the financial application would include software functionality to actually perform the tasks desired by the user e.g. transferring money as well as functionality to manage the infrastructure of the application e.g. ensuring that the connection between the bank and the user is secure .

Creating this infrastructure software and subsequently installing it can be time consuming and error prone. Also creating this infrastructure software can delay a company s time to market for its products and reduce its overall profitability. In addition the problems associated with creating this infrastructure software are only exacerbated with each new software application to be implemented. Furthermore each customer may require different capabilities in their enterprise software. For example some customers may require different user interfaces command line vs. Web user interface . These requirements may rule out otherwise suitable software applications and or require product re engineering.

Thus automatic software generation and automatic system configuration are needed to address one or more of these problems.

Methods and apparatuses are disclosed for automatically generating software and configuring software application installation. Some embodiments may include a method of configuring one or more hardware resources within an enterprise the method comprising the acts of installing at least one software application on the one or more hardware resources orienting one or more logical areas within the one or more hardware resources implementing one or more communication protocols between the one or more logical areas and generating infrastructure for the at least one software application during the act of installing wherein the infrastructure is based on predetermined choices.

A method of automatically generating a software application comprising the acts of determining the logical orientation of one or more elements of a computer system to which the software will be installed consulting at least one parameter related to a communication protocol that is to be implemented between the one or more elements determining whether any of the one or more elements will be nested and in the event that one or more elements will be nested repeating the act of determining the logical orientation and the act of consulting the at least one parameter.

A computer system implemented within an enterprise the computer system comprising a processor and one or more storage devices the storage devices including executable code and one or more parameters wherein the executable code is capable of provisioning the computer system into a plurality of logical areas as the computer system is initially configured within the enterprise.

According to some embodiments a method and system are disclosed for automatically generating software and optionally configuring a computing system as the software is installed in enterprise environments using an automated software generation tool. An enterprise environment may include multiple client and server software applications. As part of the software generation process an automated software generation tool may utilize parameters provided by the enterprise and or the software vendor to generate infrastructure code that is then integrated by the software generation tool along with application code. Based on the decisions of software developers the automated software generation tool may create the required infrastructure to host the application code and also may generate the application programming interfaces APIs required to invoke key services in the support infrastructure.

In some embodiments the automated software generation tool may be capable of creating installation and configuration software for the application. The software installer may leverage existing operating system OS virtualization technologies to create and configure a virtualized hosting environment for the application software.

By creating and configuring a virtualized OS environment to host the enterprise application many of the errors that usually occur in software installations can be avoided thereby allowing enterprise customers to optimize resources in their datacenters. For example creating and configuring a virtualized OS environment as part of software installation may allocate an appropriate amount of disk space in the virtualized OS instance may set up appropriate local accounts and permissions and may ensure correct allocation of global CPU and memory resources.

As shown in the client applications communicate with the server applications via a network . Depending upon the specific configuration of the client server arrangement the network may be the Internet in some embodiments or a local intranet in other embodiments.

During operation the client applications may make requests from the server applications and await a response from the server applications . The particular response by the server applications depends upon the nature of the client and server applications. In some embodiments a user may operate a user interface to initiate interactions between the client applications and the server applications via the user interface . For example the client applications and the server applications may perform banking functions that allow the user to make requests through the user interface for balance information. This user interface may be a graphical user interface GUI or a command line interface CLI . In other embodiments interaction with the client applications may occur through an API where another application invokes functions of the client applications through the API . For example the application may request from the client applications through the API a group of balance information for hundreds of customers of the financial institution.

Communications between the client and the server application may be routed through one or more proxy servers . Implementing proxies in this manner may allow protocol changes from server to client may allow the support of more efficient network bandwidth consumption may allow a reduction in the overall load on the server and or may allow support for an intermediate cache of application data for asynchronous application processing or more efficient communication.

During operation the client application may connect to the one or more proxy servers and request service such as a file connection Web page or other resource available from the server application . The one or more proxy servers may provide the requested resource by connecting to the server application and requesting service on behalf of the client application . In some embodiments the proxy server optionally may alter the request from the client application or the response from the server application . In other embodiments the one or more proxy servers may fulfill the request without contacting the server application . Continuing with the financial institution example from above the user may request through the client application the most current interest rates from the financial institution. If the one or more proxy servers recently provided this same request to another user previously it may fulfill this request without burdening the server application and therefore the number of requests that the server application must fulfill may be reduced.

As shown in the client applications include non infrastructure portions or applications A supported by infrastructure portions B. Likewise the server applications include non infrastructure portions A and infrastructure portions or applications B. The infrastructure portions B and B may be code that runs supports hosts and or provides services for the application code A and A.

Software developers typically build the infrastructure portions B and B as well as the application code A and A for each of the applications in the client server arrangement . Notably the client server arrangement may implement multiple different client applications and or multiple different server applications . While the applications A and A may include code that is specific to the particular client server application the infrastructure portions B and B on the other hand may include code that is somewhat generic to the application.

In general infrastructure portions B and B may be made part of the hosting environment for the application. As such the infrastructure B and B may provide services for the application on an as needed basis. For example the application code may invoke infrastructure functions through one or more APIs such as communication protocols logging security a runtime framework to start stop and or manage the application software in a controlled way persistence management data storage and or retrieval support for a command line interface CLI and support for an API to name but a few.

For example one of the client applications may allow the user to request financial information from the server application with regard to the user s current bank account balances while another of the client applications may allow the user to determine the user s current stock holdings. These two applications may have non infrastructure portions A and A that are different while the infrastructure portions B and B may share some common functionality. Examples of common infrastructure functionality between the client and server applications include code that ensures secure communication between the client application and the server application. Examples of differing non infrastructure functionality A and A may include code that performs the actual business application code that provides the graphical user interface etc.

Referring to the software generation tool development initially the parameters and or options for the automatic software generation tool are determined in block . In some embodiments the automatic software tool developed in phase may be developed by companies such as Sun Microsystems Inc or IBM Inc. These automatic software tool developers may consult with one or more of their customers to determine the types of applications that the customer may need in block . In some embodiments the customer may be a financial institution such as a bank that desires to implement online banking software for its customers.

Next in blocks the automatic software generation tool is developed. In block a software developer may interact with a user interface to select certain code to incorporate APIs and or infrastructure code into the tool. As mentioned above this infrastructure code may include communication protocols logging security a runtime framework to start stop and or manage the application software in a controlled way persistence management data storage and or retrieval and support for a command line interface CLI to name but a few. In block the information from the user interface in block is parsed to establish what code will be created for the application development phase . In some embodiments this may include parsing the information from the user interface in block according to a set of predetermined rules.

The infrastructure code may be generated based on the predetermined framework of rules per block . In some embodiments the rules in block may include requests for software that may process define and or create rules within the software application being developed during the software development phase . For example a software development team may select an optional proxy in their UI. An embedded rules engine may generate code to represent the option and later the same rules may be used to create screens for a smart installer of the developed software application. Thus in some embodiments using a set of predetermined rules to develop software may provide an effective way to generate the installation choices and rules and subsequently use those rules to build a smart installer e.g. shown in .

In some embodiments the infrastructure code generated in block may be java code that is implemented on a java virtual machine JVM capable of being segmented into multiple logical areas referred to as application containers . Commercial examples of exemplary application containers include the type employed in the Java Platform Enterprise Edition JavaEE or the .NET framework.

Once the automated software generation tool development is complete the software generation tool may be used to create a framework for the enterprise application such as applications A and A and the application code to run in the framework may be developed. The application framework is generated in block and is shown in more detail in .

Referring to exemplary generation of the application framework per block is illustrated. In some embodiments this application framework may be based upon the infrastructure code generated in block . In block the application components and rules are defined. At this stage the application development team may establish the client server configuration shown in for example by making selections on a UI. Also at this stage the application development team may specify proxy configurations. This may include rules as to whether the proxies are nested and whether the proxies are optional. Further in block the application developers may allow optionally installed API and CLI components and also specify whether a rich Web UI will be supported by the application.

Once the application s components and rules are defined the communication model may be determined in block . At this stage the communication model may be determined for a variety of communication channels. Exemplary communication models include server proxy proxy proxy proxy agent and or server agent if no proxy is used. In some embodiments a communication channel may be a server proxy channel and this channel may comprise an HTTPS secured communication channel and or a TCP IP communication channel. In some embodiments the communication channel may comprise an Internet inter object request broker protocol IIOP where object request brokers ORBs may communicate. In object oriented languages the ORB may take the form of an object with methods enabling connection to the objects being served. After an object connects to the ORB the methods of that object may then be accessible for remote invocations over the defined channel. Also in block the server may be configured to allow optional notification using SNMP or e mail. In any case it should be noted that these protocols are merely exemplary and other such protocols may be used.

Next the enterprise runtime model may be defined in block . This may include providing methods that support transactional behavior rather than just a single use. For example in some embodiments the business methods may include banking transactions that involve transferring money between first and second financial institutions. A transfer of money between the financial institutions may involve a withdrawal from the first institution and a deposit in the second institution. If the withdrawal from the first institution fails for some reason e.g. insufficient funds the deposit should not proceed. In other words if the entire transfer withdrawal plus deposit is successful then the transfer will go forward or committed and will be reversed or rolled back otherwise.

In other embodiments the runtime model defined in block may include support for a transactional model parallel execution and lifecycle methods such as initializers and or destructors . For example in an online banking application the online banking application may use a global application level initalizer method to parse configuration files and start up global services for a new instance of the application. Such an exemplary method may configure the logging system of the exemplary banking application set up email notification for product support and may establish communication with a global lookup service. Such a method also may be used to set up global resource pools like connection pools for a database. An exemplary global destructor may be used to handle application clean up activities. Such an exemplary method may be used to close global resource pools close log files and or send email notifications to indicate that the application terminated operations normally.

In block the application developers may determine the support structure for the application s infrastructure. This may include establishing the logging and error models. The logging model may include support features such as allowing the proxy to independently log its status or allowing the proxy to consolidate logging into a server log file as well as designating the output format of the log file. Allowing the proxy to independently log its status may add complexity to the proxy configuration whereas allowing the proxy to consolidate logging into a server log file may add network traffic. Thus the application developer may chose between proxy complexity and network traffic with the automated software development tool.

Also in block the application developer may establish the error reporting model for the application. This may include implementing the error handling in the application code e.g. with logging . The error handling configuration also may include enabling the various system components proxy agent server to escalate errors between them.

Next in block the application developer may designate additional APIs and or frameworks to incorporate into the application. For example this may include determining whether the application will support a rich Web UI such as ZK Framework which may enable a rich UI for Web applications with less direct coding on the part of the application developers.

Referring momentarily back to once the application framework and code have been generated per block the software generation tool may create an application installer per block . This may allow the application being developed to be installed with one or more preconfigured options that may be configured at the time of application development by the application developers. The creation of the application installer per block is shown in more detail in . In some embodiments the application installer shown in may be used just before the application is released to the enterprise.

Referring to the application code and enterprise infrastructure framework from block may be imported into the application installer in block . Next in block the application parameters or rules may be imported into the application installer. This may include identifying rules for software components such as server proxy client Web UI in the embodiments that include a Web server as well as installation rules for APIs and or CLIs. The imported rules also may include establishing OS support capabilities for the application being installed which may be based on either explicit or implied constraints. Furthermore as part of importing the framework per block the configuration options of the application may be determined such as allowing optional SNMP and or email notification or allowing proxies to be nested.

Next in block the OS support for the application may be designated in the application installer. This may include identifying OSs and or versions of OSs that are supported by the application being installed. In some embodiments checking the OSs in this manner may be selectively enabled and disabled which may be useful for applications intended for java platforms. In other embodiments block may include virtualizing certain hardware and or software resources. The term virtualization refers to abstracting hardware and or software resources within an enterprise to allow efficient allocation of computing resources.

Once the OS support is designated in block the platform installation parameters may be determined in block . This may include determining parameters that relate to installation rules for each component of the application to be installed. For example if the application is installed on a Solaris 10 SPARC platform then the application may have a certain storage space requirement e.g. 2 GB and scripting support requirements e.g. PERL 5.8 that are different from other platforms. Furthermore the platform installation parameters may be different for the server proxy and client components.

In block the applications registration and licensing install parameters may be configured. This may include configuring the application installer to prompt the systems integrator for a license key to run the application. This also may include designating a URL during installation from which the systems integrator can access a Web page to register the application and obtain a license key.

Once the registration and licensing installation parameters are provided in block advanced installation capabilities optionally may be provided for in block . For example the installer may auto configure logical areas or containers for the server and or proxy during installation. Furthermore in some embodiments systems integrators may be allowed to remotely install proxies during server install. In other embodiments systems integrators may be able to import lightweight directory access protocol LDAP users and groups during installation and setup.

Once the application installer has been configured the systems integrator may execute the application installer and decide what installation options to utilize as shown in at block and depicted in further detail in .

The virtual installation options shown in are configured independent of the virtual options specified for other logical areas within the computer . More importantly computers other than the computer that are also within the enterprise such as computers may be custom configured as they are physically installed within the enterprise and configured with software applications.

In some embodiments the computer manufacturer may deliver the computers to the enterprise where the computers have already been virtualized by the computer manufacturer at the request of the enterprise . If the enterprise has hundreds or even thousands of computers then delivering the computers in a virtualized state is advantageous because it may reduce and or eliminate errors that occur if a systems administrator manually virtualized each of the hundreds or thousands of computers within the enterprise . By reducing and or eliminating the errors that may occur when virtualizing the computers the enterprise now may purchase the optimum amount of computing resources rather than additional and physically separate computers that execute the applications.

An exemplary computer system akin to the type implemented in the enterprise is shown in . The computer system may be virtualized in many different ways. For example the computer system may execute both the client applications and the server applications where the client applications and the server applications are virtualized as described above. In this virtualized operational state one or more of the components within the computer system may be assigned to the client applications as well as to the server applications .

Referring to computer system shown in a keyboard and mouse are coupled to a system bus . Keyboard and mouse in one example introduce user input to computer system and communicate that user input to a processor . Other suitable input devices may be used in addition to or in place of mouse and keyboard . An input output unit I O coupled to system bus represents such I O elements as a printer audio video A V I O etc.

Computer may also include a video memory a main memory and a mass storage all coupled to system bus along with keyboard mouse and processor . Mass storage may include both fixed and removable media such as magnetic optical or magnetic optical storage systems or any other available mass storage technology. Bus may contain for example address lines for addressing video memory or main memory . System bus also includes for example a data bus for transferring data between and among the components such as processor main memory video memory and mass storage .

In some embodiments processor is a SPARC microprocessor from Sun Microsystems Inc. or a microprocessor manufactured by Motorola such as the 680XX0 processor or a microprocessor manufactured by Intel such as the 80X86 or Pentium processor. Any other suitable microprocessor or microcomputer may be utilized however. Main memory may include dynamic random access memory DRAM static random access memory SRAM magnetic random access memory MRAM or the like. Video memory may be a dual ported video random access memory. One port of video memory in one example is coupled to video amplifier which is used to drive a monitor . Monitor may be any type of monitor suitable for displaying graphic images such as a cathode ray tube monitor CRT flat panel or liquid crystal display LCD monitor or any other suitable data presentation device.

Computer also may include a communication interface coupled to bus . Communication interface provides a two way data communication coupling via a network link such as network . For example communication interface may be an integrated services digital network ISDN card or a modem a local area network LAN card or a cable modem or wireless interface. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals which carry digital data streams representing various types of information.

The client applications and the server applications may be executed by processor or in some embodiments they may be stored in mass storage or other non volatile storage for later execution. In this manner computer may obtain application code in a variety of forms. Application code may be embodied in any form of computer program product such as a medium configured to store or transport computer readable code or data or in which computer readable code or data may be embedded. Examples of computer program products include CD ROM discs ROM cards floppy disks magnetic tapes computer hard drives servers on a network and solid state memory devices.

The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent once the above disclosure is fully appreciated. In addition the above description has broad application and the discussion of any embodiment is meant only to be exemplary and is not intended to intimate that the scope of the disclosure including the claims is limited to these embodiments.

