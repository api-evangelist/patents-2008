---

title: System and method for virtualization of networking system software via emulation
abstract: A network application may be run on a host computer using a target protocol stack by launching a network application on the host computer, opening a target protocol stack library on the host computer before opening a host computer system library and using the target protocol stack library to divert interface calls associated with the network application to a target protocol stack, whereby the network application runs on the host computer as if it were running directly on a computer on which the target protocol stack is available. A network environment may be simulated including wireless communication between a plurality of mobile devices. Multiple instances of the target protocol stack library may be opened to divert interface calls associated with the network application to the target protocol stack. A hardware test bed may be emulated to which the network application may be applied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08793117&OS=08793117&RS=08793117
owner: Scalable Network Technologies, Inc.
number: 08793117
owner_city: Culver City
owner_country: US
publication_date: 20080905
---
This application claims the benefit of the filing of provisional application Ser. No. 61 045 520 filed Apr. 16 2008.

The present invention is related to techniques for operating software networks and in particular to techniques for running software networks for software applications which require services not provided by the network operating system.

Many different network software operating systems have been developed most of which are not completely compatible with each other making it difficult to operate network software and hardware devices designed for a first network operating system on a computer network utilizing a second different network operating system.

What is needed are improved techniques for operating such network hardware and software design for use on the first network operating system on a computer network using the second operating system.

In a first aspect a method of running a network application on a host computer using a target protocol stack may include launching a network application on a host computer opening a target protocol stack library on the host computer before opening a host computer system library and using the target protocol stack library to divert interface calls associated with the network application to a target protocol stack whereby the network application runs on the host computer as if it were running directly on a computer on which the target protocol stack is available.

The method may include using the target protocol stack library to divert data and control interface calls associated with the network application. The method may also include launching an additional network application on the host computer opening a second target protocol stack library on the host computer before opening a host computer system library if any and using the second target protocol stack library to divert interface calls associated with the additional network application to a second target protocol stack whereby the additional network application also runs on the host computer as if it were running directly on a computer on which the second target protocol stack is available.

The host computer stack may include a host computer network operating system and host computer network system hardware and the target protocol stack may include a target computer network operating system and target computer network system hardware wherein at least one of the target computer network operating system or the target computer network system hardware is different than the corresponding host computer network operating system or system hardware.

The method may also include simulating a network environment including wireless communication between a plurality of mobile devices and applying the network application to the simulated network environment. Simulating the network environment may include simulating the network environment including wireless communication between a plurality of mobile devices on a remote computer in network communication with the network application on the host computer. The network application may be not compatible with the host computer protocol stack.

The method may also include opening multiple instances of the target protocol stack library on the host computer and using the multiple instances of the target protocol stack library to divert interface calls associated with the network application to the target protocol stack. The method may include opening multiple instances of the target protocol stack library on the host computer and using the multiple instances of the target protocol stack library to divert interface calls associated with the network application to multiple target protocol stacks.

The method may also include opening the target protocol stack library on an additional host computer and using the target protocol stack library on the additional host computer to divert interface calls associated with the network application to the protocol stack. The target protocol stack may be emulated on the host computer or on a computer networked with the host computer.

The method may further include emulating a hardware test bed and applying the network application to the emulated hardware test bed. The method may further include emulating a first hardware test bed node requiring the target protocol stack emulating additional hardware test bed nodes and applying the network application in real time to the combined first and additional emulated hardware test bed nodes. The network application may be in a binary form unmodified from a binary form executable on a computer having only the target protocol stack.

The method may include monitoring operation of the target protocol stack to evaluate operation of the network application for example to evaluate a user s experience. The method may include evaluating operation of the network application during interaction between a human operator and the target protocol stack.

Further the method may include using an Internet Protocol network communication service in the target protocol stack to provide communication between the network application and other computers communicating by Internet Protocol communication services. The method may also include using the network application to operate hardware networked to the host computer via the target protocol stack. The network application on the host computer may use the target protocol stack in an application level proxy operation.

The method may include using a socket application programming interface to simultaneously control system data and system control communications between the network application and the protocol stack library. The method may further include copying application data to socket buffers to exchange data between the network application and the target protocol stack and using function calls to separately communicate control calls from the network application to the target protocol stack. The protocol stack library to divert data and control interface calls by converting the IP address and port numbers for data and control interface calls between the IP address and port numbers of the host computer and IP address and port numbers of the target protocol stack.

Further the method may include emulating the target protocol stack on a remote computer networked with the host computer and executing an emulation stub on the remote computer for converting packets received from the target protocol stack to a format recognizable by the target protocol stack on a remote computer. Still further the method may include emulating the target protocol stack on the host computer and using a modified socket in the target protocol library for system data and control communication between the target protocol stack and services provided on the host computer.

In general a network system refers to software running on two or more machines that can communicate with each other over a wired or wireless medium. Within each such machine in a network system communication is typically enabled via three key components the networking application software that generate the traffic either as directed by an end user or automatically on behalf of users the networking system software that provides the communication functionality and the networking system hardware or devices that actually transmit or receive the data. The networking system software together with the networking system hardware is typically referred to as the protocol stack.

Networking applications may allow the end users to communicate with remote machines. Examples of networking applications include web browsers file transfers streaming media players telephony messaging and so on. The applications can be developed by the end user or provided by any third party vendor different from the end user and OS vendor .

The network system software is typically that component of the operating system that mediates interactions between the applications and the networking system hardware. The protocol stack typically includes at least the following key components transport protocol for de multiplexing traffic between network applications networking protocol for end to end communication route management for discovering network connectivity and medium access control for link communication . Given the variety of the protocol stacks currently available a networking application must typically specify explicitly which protocol stack it intends to use. The networking system software is usually provided by the operating system vendor since this system is tightly coupled with the core operating system.

Networking system hardware typically refers to network interface cards such as radio transceivers analog to digital signal converters digital signal processing and so on. Associated with these hardware components are usually software modules available either as firmware or device drivers. The networking system hardware and the associated driver software are typically provided by the respective hardware manufacturers vendors and are therefore easily changed.

Computer simulation may be provided by a computer program that simulates an abstract model of a particular system. A simulation is typically concerned with an abstract model of the system typically the internal state of the system and the primary purpose of using a computer simulation is to gain insight into the operations of the system.

Emulation typically refers to duplication of the functions of one system by a different system so that the second system behaves like and appears to be the first system. An emulator may replace live physical components of a complex system with counterpart representations that can be deployed rapidly at a fraction of cost. True emulation is typically considered to be achieved when any player in the system hardware software or even humans can not discern any difference between a real system component and its emulation replacement.

Network emulation may be a technique where the properties of an existing planned and or non ideal network may be modeled with high fidelity operating in real time in order to assess performance predict the impact of change or otherwise optimize technology decision making.

Network emulation may be said to differ from network simulation in that a network emulator appears to be a network end systems such as computers can be attached to the emulator and will behave as if they are attached to a network. Network simulators are typically programs which run on a single computer take an abstract description of the network traffic such as a flow arrival process and yield performance statistics such as buffer occupancy as a function of time .

Emulation may be a viable alternative to physical test beds that can provide an evaluation framework that is simultaneously accurate scalable repeatable and flexible. The greatest advantage of an emulation may be reduced equipment and labor costs all the while the fidelity of the test data between a physical test and an emulated test remains constant. Emulation test beds are typically flexible in the sense that changing configurations can be easily done which would otherwise be very difficult if not impossible in physical test beds. Moreover the experiments performed in emulation are typically repeatable with controlled parameters to support fair comparison among different system optimization techniques.

Improvements in networking systems may be provided by the use of a Universal Protocol Adaptor UPA and or the use of a Universal Device Interface Adaptor UDIA . The implementation of one or more embodiments of a UPA will first be described below with regard to . The implementation of one of more embodiments of a UDIA with then be described below with regard to . Thereafter the use of both UPA and UDIA techniques in networking systems will be described.

With regard to the utilization of UPAs applications typically have to explicitly request which protocol stack they intend to use. As an example consider an application A that requires the protocol stack PS 1. Any other stack PS 2 may be compatible with PS 1 if the application A can compile and execute correctly with PS 2 albeit with a possibility of different performance. PS 2 may be application level incompatible with PS 1 if the application A fail to compile and or execute correctly. This can happen for example when PS 1 provides some features that are essential for the application A that are not implemented or implemented differently by PS 2.

Referring now generally to methods and systems are disclosed which provide for replacing the networking system software that is typically bundled in the operating system or OS provided by the OS vendor and the networking system hardware provided by their respective vendors with counterpart representations of the same as an emulation. The original system be referred to as the original networking system or ONS and the emulated networking system may be referred to as the ENS. The ENS may replace on demand and in a functionally transparent manner the ONS with a single or multiple instances of the ENS in a manner that does not compromise the application programming interfaces or APIs and the binary level compatibility of the applications. Functional transparency may be said to be achieved when the end users or the applications cannot discern any differences in the operational details the capabilities or the performance between the ONS and ENS. It is important to note that is the disclosed techniques may not only replace an ONS with an emulated networking system but may do so without requiring any modifications to the application.

The problem addressed by the use of a UPA may be formulated as follows On a given platform P a networking application A such as Web Browsers Streaming Media players Interactive telecommunication File Sharing and so on may require the protocol stack PSnot available on the network computer on which application A is to be run. The goals may be to evaluate the performance of an existing application A even if it is available conveniently only in binary form with the stack PS or to implement a new application A with the stack PSon the platform P.

The problem may be encountered if an implementation of stack PSis not available on the platform P for example because PSrepresents an emerging technology and no implementation is currently available 

implementations for PStarget are available for platform P but are difficult or costly to procure and install or otherwise unattractive. The problem may be encountered because the desired platform has a different stack PShost or an emulation of PStarget or E PStarget may be available. E PStarget may run in an emulation environment either on the same platform P or a remote platform.

Appropriate solutions may include executing application A which may be in binary form with the emulated stack E PS. For example existing application A may only be available in binary format and solutions that require source code modifications to application A may be impractical. Similarly any new application A that is targeted for stack PS can be developed verified and validated with emulated protocol stack E PS . It is also desirable that the functional interface e.g. the semantics of the communication between the application A and E PSshould be the same as that between A and PS. It may also be preferable that any application developed and or verified for the E PS using the UPA should display identical behavior as running on the real PS.

Application Programming Interface API Compatibility Any application developed for the ENS should be able to use the same APIs that are exported by the ONS. In order words it should not be visible to the application developer if the underlying networking system is the original one or emulated.

Application Binary Interface ABI Compatibility Any existing application that was developed for the ONS should work seamlessly with the ENS. That is there should be no need for access to the source code of the applications for modifications recompilations and or relinking into the ENS. In other words the same application binary should work for both ONS and ENS.

Multiple Instances of ENS The system should provide the ability to run multiple instances of the emulated networking system software. The implementation itself may be either by running multiple processes for each instance or running single instance that de multiplexing different calls within this instance.

Perceptual Transparency The end users of the applications should not be able to perceive any difference in the operation of the applications when using ENS versus using ONS.

Operating System Transparency No additional support or feature from the Operating System should be required for development installation and usage of the ENS more than what exists in the standard distribution versions. As an example for commercial closed source OS there should be no requirements for the access to the source code.

Operating System Independence The development customization and evaluation environment in ENS should not require any domain knowledge of any specific operating system. That is the framework should be portable to all the platforms that it supports.

Hot Pluggable The ENS system should not require recompiling the operating system kernel and or restarting the machine in order to be installed uninstalled or used.

Co existence with ONS It should be possible that both ONS and ENS exist simultaneously. That is some applications may choose to communicate using ENS while others use ONS.

Support Cross Layer Interactions CLI The ENS should support cross layer interactions between the applications and networking system software and between applications and network devices in ways more advanced and flexible than what is possible with ONS.

Flexible Execution Environment 1 The ENS can run in the operating system s user address space or kernel address space or a combination thereof. The actual design should be guided by the requirements of the user and not limited by the design of the system itself.

Flexible Execution Environment 2 The ENS can run on the same machine in which the application is running or alternatively on a remote server.

Flexible Execution Environment 3 In a preferred embodiment the ENS would not use undocumented hidden or otherwise non standard features that are not advised by the OS vendor that may lead to compromising the security or stability of the OS.

Network applications make use of the communication capability in an operating system through a set of well defined APIs. These interfaces typically BSD sockets or WinSock may be used by the applications directly or via higher level abstraction APIs RPC CORBA AJAX etc . In addition the application must be able to access other functionalities provided by the system such as memory disk space graphical user interface and so on.

The use case in this section refers to the capability that the applications can be developed utilizing the same communication APIs libraries of their higher level abstraction and the non communication based libraries as are available in any development platform except that the networking system software itself is implemented as an emulation.

 a Applications can be developed and tested on wide variety on protocols stacks without the need for installing the latter in the development platform or migrating the application itself to a different platform that support those protocol stacks. For example a cellular protocol stack based application can be developed on a machine that does not have this stack once the application is developed debugged and evaluated it can be migrated as it is even in binary format to any platform that supports the stack. Another example is that applications written for WiFi IEEE 802.11 based networks can be tested on the same evaluation machine for other kinds of networks such as GSM CDMA WiMAX and so on.

 b The disclosed techniques can be used to develop and test applications for futuristic protocol stacks the physical implementations of which are not currently available. Hence innovations in application development and the protocol stack development can proceed in parallel. This concept of isolation of dependencies has been the founding principle of the layered architecture in the Internet and believed to have played an important role in its success.

 c Applications can be developed that require cross layer interactions with other layers of the protocol stack. Achieving this goal in a real operating system requires extensive domain knowledge is extremely limited in capabilities or even impossible in some cases.

 d Because the applications can be prototyped using the same APIs and libraries as a real development system the applications developed with this approach can be seamlessly migrated to deployment without requiring substantial modifications. The conventional approach of prototyping applications in a simulator environment does not provide the same APIs and the complete set of libraries as the disclosed approach making it difficult to directly use the applications outside of the simulation environment.

In recent years there has been an increased emphasis on evaluating system performance at the application layer. Performance of wireless systems has traditionally been evaluated using network layer statistics but as these systems mature and become available to consumers there needs to be a greater emphasis on the evaluation of such systems from the perspective of the end users. In other words whereas in the past performance optimization techniques may be evaluated with respect to their impact on improving corresponding network layer statistics it is more beneficial to evaluate advances in networking concepts with respect to their impact on improving application performance. The disclosed techniques may provide the following benefits for the application centric evaluations 

The conventional approach is to model the applications within the simulation environment wherein the traffic generated by the application models is used to drive the network and subsequently the statistics are collected for the performance of the applications. While this approach is possible for simplistic applications such as constant or variable rate data streams HTTP etc it becomes difficult or infeasible for more complex applications such as media players telephony web browsers etc. Modeling these applications within simulation is difficult and requires substantial effort. The disclosed approach avoids this step of modeling and allow native applications unmodified and in their binary format to be used within a simulation study to drive the traffic. The performance of applications as affected by the network conditions can be directly observed.

The advantage of including real applications also offers human in the loop capability in network evaluations. The analyst in real time can both observe the performance of the application as well as interact with the applications.

Since applications instances can be multiplexed on a protocol stack present in the simulator it may also be possible to conduct application scalability evaluation with user interaction enabled. In this approach the user may be to configure multiple instances of applications running on one machine to associate with different nodes in the simulation and scale up with the number of applications instances. This is in contrast to the conventional approach of running a single emulated node per physical machine. The resources required to model a network with say thousands of applications conventionally would typically require as many physical machines with the disclosed approach this can be achieved with a single or a small set of physical machines.

This use case refers to the networking system software analysts who use simulation methodology for prototyping validation testing and evaluation. The disclosed approach has the following benefits for this community 

 a To generate traffic for evaluating the protocol stack the developers and analysis would conventionally either use stochastic models of traffic or custom build these within the simulation environment. However as mentioned earlier the effort in modeling complex applications can be substantial. The disclosed approach eliminates this effort by allowing existing applications to be used directly with the evaluation environment. Thus if the implementation of an application is available there may be no need to model it again.

 b The prototypes of the networking system software can be tested and evaluated in an operational network. The developers can create or customize exiting protocol stack and insert it within an operational network.

Further the architecture can be extended beyond the objective of interfacing a real world application to a stack scenario present in a simulation. The same architecture can be employed to interface an application running on one machine to a protocol stack running on another machine as in an application level proxy operation. Also applications running on devices which do not have a protocol stack or have a non IP protocol stack can borrow a IP based protocol stack running on another machine to communicate with other nodes on the IP network.

Referring now to host platform 1 10 may include application API including PSAPI and PSAPI as well as host protocol stack or PS. The protocol stack required for application by PSAPI flows directly to PS. The protocol stack needed for application via PSAPI may be emulated protocol stack or PS and may be present on host system 1 10 or a remote platform. Effective operation as shown in requires that protocol stacks PS and PS be compatible. However even if they are identical the traffic from application first traverses through PS before reaching E PS. Protocol stack PS may thereby modify the traffic to or from PSAPI e.g. the data itself the rate of data transfer or any other property of the traffic. As a result E PS receives modified traffic rather than the raw traffic from application via PSAPI which may be the result of what can be called the extra stack effect which can significantly affect an evaluation analysis of application .

Referring now to host system 2 10 may include application API including PSAPI and PSAPI and UPA layer . Application which may be in communication with PS via PSAPI and or emulated or physical PS via PSAPI . PS which may be on host system 2 10 or emulated on a remote host. UPA may pretend to application that the protocol stack PSphysically available on host platform 2 10.

UPA may thereby provide an apparently direct interface between application and PS which avoids a requirement for or a connection through a physical protocol stack PSsuch as physical protocol stack .

Referring now to host platform 3 10 includes networking application networking socket programming interface having both data and control interfaces networking system software including protocol stack PS and networking device . These components may be included in conventional off the shelf software.

In general networking application such as a web browser streaming media player messaging and so on makes use of socket application programming interface for communicating with applications on a remote machine. APIs such as socket programming interface are typically standardized for different classes of operating systems for example the Unix based platforms provide the Single Unix Specification API while the Windows based platforms provide the WinSock API. Beneath interface different platforms provide their own native implementations of protocol stack PS. The actual implementation of the stack varies across different platforms as well as with the networking technologies for example IP version 4 IP version 6 GSM and so on . Among the responsibilities of PS is to transmit or receive the data packets across the network using networking device .

Host platform 3 10 may also include emulated protocol stack PS which may be used to replace protocol stack PS which is typically provided by the OS vendor. Applications such as network applications may then be made to believe that they are running directly on top of emulated protocol stack PS. PS may be implemented in a discrete event network simulator or as some other process either on the host platform 3 10 or a remote platform.

UPA library is a set of files or library located between socket programming interface and the host system s native protocol stack PS which diverts all networking communication related calls by network application to PStarget bypassing the host protocol stack PS. UPA may be implemented as a dynamically loaded and shared library i.e. an .so file in Unix based systems or a .dll file for Windows based systems.

When networking application is launched various system libraries are loaded that application intends to use. UPA library is preferably loaded before any other library is loaded. Once UPA library has been loaded into applications UPA intercepts data and control calls directing them to the emulated protocol stack PS. UPA library may use inter process communication techniques such as pipes or shared memory if for example if PS is emulated on host system 3 10. UPA library may also use network communications e.g. raw sockets to communicate via network device if PS is emulated on a remote platform. In this manner application traffic between application and PS is not processed by PS before processing by PS.

Referring now to in a preferred implementation of a UPA layer networking application accesses remote services through one or more application sockets . Application sockets may include or have access to system data interface for transmission and reception of data and system control interface for other non data transfer operations. Applications sockets may access system data interface by copying application data to socket buffers and may access system control interface via function calls . A list of these functions for both data and control interfaces and is described below in greater detail with regard to .

UPA library is preferably attached to networking application before any other library such as PS shown in above whereby UPA library can interact with the emulated PS either by local inter process communication or over the network. In the more general case UPA library may communicate with PS emulated on a remote host by sending and receiving data via network device .

UPA library includes data call diverter data interface handler data control call diverter control call diverter control interface handle emulation communication agent and UPA socket on system host 4 10 as well as emulation stub process which may reside on remote platform 4 12. Data and control diverters and capture data and control calls from application socket via system data and control interfaces and respectively and apply them to UPA library so that data and control calls are not applied to the host protocol stack not shown in this figure.

For each application socket UPA library may open a new UPA socket which may be considered to be a raw socket that is a socket which does not use the host system s protocol stack. Emulator communication agent handles bookkeeping tasks such as storing the IP address and port number of emulation process PS assigning and storing port numbers for applications sockets and maintaining a mapping between the addresses and port numbers across the emulated network and the physical network.

Emulation stub executes along with emulated PS for receiving packets from UPA library and converting such packets to a format that is recognizable by emulated PS. Emulation stub also receives information from PS and converts such information to a format compatible with UPA library .

When PS is located on host system 4 10 modifications to UPA socket and emulation stub may be required. Modifications to UPA socket component may replace the raw socket as discussed above with inter process communication primitives such as Unix Domain sockets INET socket connected to loop back addresses pipes shared memory etc. Unix Domain sockets are preferably used for Unix based platforms and INET sockets with loop back addresses are preferably used for Windows based platforms.

Data and control interface diverters and divert socket related calls from the applications away from the native protocol stack of host system 4 10 into UPA library where they can subsequently be delivered to emulated protocol stack PS for example on remote platform 4 12 which may be implemented for a Unix based system utilizing the environment variable LD PRELOAD .

Data and control interface handlers and provide the correct attributes of PS to application on host system 4 10 where PS may not actually be available. In particular data interface handler may handle application data transfer and conversion of addresses.

Referring now to operation of data interface handler 5 10 is described for the remote emulation case where the applications are running on local host platform and emulation process is running on remote platform . Two generalized applications are illustrated on the host data sender application and corresponding data receiver application .

UPA Data interface handler handles the differences in addressing schemes between the actual physical machines such as host and the emulated network such as emulation process which may be running on remote platform . In particular system host may have physical IP address of PHY IPwhile emulation process may be running on remote platform with address PHY IPat the port number PHY PORT. Sender application may have the virtual address Virtual IPat port Virtual Portand receiver application may have the address Virtual IPat port Virtual Port. Sender application sends out a packet with these virtual addresses in packet header which are captured by data interface diverter shown above in and handed to the data interface handler .

UPA data interface handler looks up the specified port number in mapping table and transforms the incoming packet as shown at packet transform block the original data packet with the payload and the headers are encapsulated into the payload section of the new packet and new headers are created with physical address and port number that correspond to those required by emulation process . This packet is then handed off to UPA socket for delivery to emulation process on host .

At the other end of the communication channel when packet is received from emulation process at UPA socket UPA data interface handler strips off the header section of this packet and creates a new header from the information that was encapsulated in the payload section. This new transformed packet is then delivered to receiver application .

As a result applications such as sender and receiver can communicate with each other conveniently and efficiently even though the emulated protocol stack PS shown in is emulated in emulation process on remote host platform and is not actually available on local platform host . Further advantageously multiple applications can run on single platform but connect to different emulated protocol stacks. That is while few applications connect to emulation stack 1 others can connect to emulated stack 2 and so on. This is described in greater detail below with regard to .

Referring now to and again to control interface handler handles the non communication related aspects for application socket . Application socket accesses system control interface via function calls . Control interface handler creates a data packet corresponding to each function call for delivery to emulation process which is applied to the emulated protocol stack PS.

In particular emulation communication agent provides similar book keeping tasks as performed by emulation communication agent for UPA library . When UPA library is the loaded for the first time UPA library acquires the information via environmental variables regarding the host address and the port number on which emulation process is running. This information may be stored locally within emulator IP address and process port number block .

After UPA library has been loaded but before any other library or application is loaded UPA library identifies a virtual node in emulation process to be represented by this particular instance of UPA library . This task may be performed by Set Virtual Node command and may be implemented via environmental variables. The specified currently emulated or virtual node may be stored in table . For example if the virtual node is set to node 5 then all the applications that are launched subsequently will be assumed to be executing on the node number 5 in emulation process . Note that this node address can be changed at any point in time and any application launched after that will execute on the new node. The prior applications will continue to execute on the node on which they were launched first.

Here the virtual node is first set to node number 1 and a server application is started on this node. Subsequently the virtualization is changed to node number 2. The client application that is launched after that will run on node 2. However the server application will continue to run on node 1. In this way multiple applications the multiple instances as described above for an ENS can be running on different virtual emulated nodes on a single physical platform. Further the multiple applications can be run with potentially different kinds of protocol stacks e.g. different protocol stack PSon a single physical platform.

Emulation communication agent 6 10 creates and maintains port number mapping table when a new socket is requested by an application. When the application creates a new socket for a given protocol stack type as shown for example by create new socket for protocol stack X command by the socket call it is routed via control call diverter and control interface handler to emulation communication agent 6 10. Emulation communication agent 6 10 provides create new raw socket request to the host operating system to create a new raw UPA socket . Upon successful creation of socket get port number command retrieves the port number such as PHY Port via UPA socket . Emulation communication agent 6 10 then assigns a virtual port number to the application socket via assign port number command by consulting currently emulated node table . This virtual port number can be different from the physical port number in fact there can be multiple applications that have the same virtual port numbers. Emulation communication agent 6 10 stores a mapping between the physical and virtual port numbers via store mapping between UPA and application port numbers in mapping table . Send new socket information agent command to the emulator command informs emulation communication agent of the new socket and its attributes.

Referring now to examples of the various tasks for the UPA architecture and its implementations are illustrated in use case 8 10. A virtual network may include three nodes such as emulated node 1 emulated node 2 and emulated node 3. The IP addresses of these virtual nodes may also be virtual in that there may not exist any physical machine in the set up that are assigned these as real addresses. These virtual addresses may be identified as 192.168.0.1 192.168.0.2 and 192.168.0.3 using the IP version 4 based addressing scheme although the UPA architecture can may support various types of addressing scheming including IP version 6 cellular WiMAX sensor based and others.

Four applications such as App 1 App 2 App 3 and App 4 may be run on these three virtual emulated nodes. For example App 1 and App 2 may run on emulated node 1 while App 3 runs on emulated node 2 and App 4 runs on emulated node 3. Furthermore App 1 may have two open sockets while the remaining applications have only one open socket. The aforementioned mapping between applications and sockets with the emulated node implies that the two sockets from App 1 and the socket from App 2 should have 192.168.0.1 as the local address the socket of App 2 should have 192.168.0.2 as local address and the socket of App 3 should have 192.168.0.3 as the local address.

The next concern is the port numbers for these sockets. Port numbers are integer values that uniquely identify different sockets within a computing host such as a desktop laptop PDA etc. That is to say all the sockets for all the applications on an emulated node typically have different port numbers. However it is possible that applications that run on different computing hosts may have the same port number. In the example the three sockets in App 1 and App 2 have different port numbers as they run on the same emulated host. The first socket of App 1 and the sockets from App 3 and App 4 have same port number which is correct as these three applications run on different nodes.

A further concern is the host machines or platforms on which the emulation server and these UPA enabled applications are running. In use case 8 10 there are three physical platforms physical host A physical host B and physical host C. Platform C hosts the emulation server as a user level process. Platforms A and B hosts the applications. Whereas App 1 App 2 and App 3 run on platform A the App 4 runs on platform B. That is it is possible that applications that correspond to different emulated nodes can run on different physical machines. Also note the differences in the configuration of these physical machines. First machine A is running Windows operating system and machine B is running Linux. That is the UPA architecture is portable to multiple operating systems even within a single setup. Second the physical addresses of these machines 10.0.0.1 10.0.0.2 and 10.0.0.3 respectively may be different from the virtual IP addresses that were assigned for the applications.

Finally all the applications may be third party applications and no modifications may be required for them for the source code for binaries for configuration files or even the usage of applications.

Having described this example use case 8 10 the following table reviews the various challenges of the UPA architecture relate them to use case 8 10 and list at least some of the mechanisms and approaches adopted in a preferred embodiment to address them.

Referring now to UPA may combine elements shown above in . The system shown in includes networking application socket interface UPA library network device and emulated networking system . Currently emulated node Id and IP address and port number of emulation process as also shown. The user of the system first sets the IP address and port number through environmental variables and subsequently sets emulated node Id to direct UPA to communicate with that node Id. The user may now launch any networking application that may use sockets to communicate with the outside world.

The sockets in networking application communicate with socket interface via the control interface or the data interface. As mentioned above UPA intercepts both these interfaces and directs them to UPA library. The data calls are directed to data call diverter while the control calls are directed to control call diverter . For each socket that is created by the application UPA library creates a raw socket to communicate with emulation process . If emulation process resides on the same machine as the UPA UPA socket can be replaced with any local inter process communication mechanism. Data call diverter passes along the packet to data interface handler . Data interface handler modifies packet and sends it to UPA socket .

On the control interface side control call diverter sends the control message from application either to emulation communication agent if the control message is a request to create a new socket or to control interface handler for all other control messages. Emulation communication agent creates a new UPA socket and connects to the emulation process using the address stored in IP address and port number . Emulation communication agent provides information to emulation process which may include currently emulated node id and the port number from IP address and port number . A mapping of the physical address of UPA socket and the virtual socket at the application is kept in port number mapping table . For all other control messages control interface diverter passes the control message to control interface handler . Control interface handler creates a new packet that will store all the necessary information related to this control message and sends packet to emulation process using UPA socket . Emulation process may also send any data or information to the UPA socket as required.

Referring now to the UPA library may use the following steps for achieving the various tasks discussed above.

The feasibility and flexibility for development customization testing and evaluation of applications and network hardware devices may also be rather restricted or constrained by the network devices.

Any user such as the protocol stack or the applications of a networking device typically accesses the device via a data interface for sending and receiving data packets and a control interface for accessing and changing the characteristics or the parameters of the device. Whereas almost all kinds of network device offer similar data interfaces they typically differ distinctly in the control interfaces provided. This arises from the fact that each kind of network device typically has different device characteristics or attributes which in turn depends on the specific network technology implemented by the network device. As an example the attributes of a wireless network device e.g. WiFi differ from that of a wired network device e.g. Ethernet and relate to changing the transmit power wireless channel etc. Such are typically therefore relevant only for WiFi networking devices and not Ethernet networking devices. Thus different kinds of networking devices typically offer access to network attributes via type specific control interfaces. The actual implementations of these interfaces may be provided.

As noted above computer simulation is a typically provided by a computer program that simulates an abstract model of a particular system. The simulation is concerned with the abstract model of the system typically the internal state of the system and the primary purpose is typically to gain insight into the operations of the system.

Emulation refers to duplication of the functions of one system with a different system so that the second system behaves like and appears to other computer components to be the first system. An emulator may replaces live physical components of a complex system with counterpart representations that can be deployed rapidly at a fraction of cost. True emulation may be said to be achieved when any player in the system hardware software or even humans can not discern any difference between a real system component and its emulation replacement.

Network emulation is typically a technique where the properties of an existing planned and or non ideal network are modeled with high fidelity operating in real time in order to assess performance predict the impact of change or otherwise optimize technology decision making.

Network emulation typically differs from network simulation in that a network emulator appears to be a network end systems such as computers can be attached to the emulator and will behave as if they are attached to a network. Network simulators are typically programs which run on a single computer take an abstract description of the network traffic such as a flow arrival process and yield performance statistics such as buffer occupancy as a function of time .

Emulation is a viable alternative to physical testbeds that can provide an evaluation framework that is simultaneously accurate scalable repeatable and flexible. The greatest advantage of an emulation may be reduced equipment and labor costs while the fidelity of the test data between a physical test and an emulated test remains constant. Emulation testbeds are flexible in the sense that changing configurations can be easily done which would otherwise be very difficult if not impossible in physical testbeds. Moreover the experiments are repeatable with controlled parameters to support fair comparison among different system optimization techniques.

Hardware in the loop typically refers to capability of attaching a real hardware platform such as a physical machine with an operating system network devices and real applications with an emulated network. The benefit for this approach is for the testing and evaluation of an actual deployment system or physical prototypes in an emulated environment. The boundary line between real and simulation is typically drawn between the networking system software NSS and the network device. The NSS and applications are real whereas the network devices are realized via simulation.

Hardware in the loop emulations are particularly useful for providing the correct simulated network device attributes to the NSS and applications on a real platform.

The problem addressed by the use of a UDIA may be formulated as follows On a given platform P aspects of a networking system NS such as applications or the protocol stack may requires access to a network device such as D. The techniques disclosed herein are particularly useful in networking systems that require access to both the data as well as the control interfaces of the network device. In such networking systems it may be desirable to evaluate the performance of the networking system with the device Dand or to develop a component of the networking system for use with the device Don the platform P.

The device D however may not be available on the platform P for various reasons. For example the device Dmay be under development and no implementations are yet available the device Dmay be available but not supported for the platform P the device is available for the platform P but is difficult or costly to procure and install or the purpose of the evaluation is to customize the device properties and achieving that is difficult or costly on the given platform P.

Other constraints may be that simulation models for the device D Sim D may be available within a real time simulation environment or that the physical networking device Dis available on the platform P. Similarly the networking system might only be available in binary form should be evaluated with the device Sim D. That is source code modification may not be possible or desirable. In a preferred embodiment networking system should have access to both data as well as control interfaces as defined above that is all of the attributes of the device Dshould be accessible by the networking system.

Referring first to the conventional architectures and concepts of a hardware in the loop emulation may be illustrated in that application and the protocol stack PS are part of the hardware in the loop emulation that connects physical platform with an simulated network .

The emulation of a network device requires that the protocol stack and the application use a simulation model of a target device D. However in conventional approaches the physical network device D PS may be used for communication with the simulator network . However physical D and simulated D are different and may be incompatible. As a result even if the data interfaces of a simulated network device D are correctly provided to the physical host platform the device attributes that are made available to protocol stack and applications are however those of D instead of those of D which are the requited attributes.

A conventional system would therefore not support the control interfaces for device D. That is networking system would not have access to the device specific capabilities or attributes available in Sim D. Even if the control interfaces for D and D are identical attempts to control the configuration or attributes on device D would typically modify device D and would not likely be reflected at Sim D.

Similarly when the capabilities differ the correct attributes of Dmay not be provided at all. While it is possible in some situations to create a custom interface to tunnel the device control calls to the simulator this approach would require modifications to the source code of the application and would not be acceptable in situations where such modifications to the source code were not desirable or possible. As a result off the shelf networking systems could not be used.

Referring now generally to a Universal Device Interface Adaptor UDIA is disclosed which provides both data and control interfaces between a networking system on one end and a simulated network device at the other. In a hardware in the loop configuration in which access to the control attributes of a simulated networking are desirable or necessary communications with the simulated network device are performed by using a virtual counterpart of the simulated networking device on the physical platform.

The UDIA provides the capability for supporting the device attributes e.g. via the control interface for any kind of networking device. It is in essence a universal adaptor that can be fitted with attributes of any device. In the example shown in the figure the UDIA provides the control interface that is the properties and attributes of the Ddevice. For some other scenario that requires a different emulated device the control interface can be suitably replaced for that specific device.

The actual implementation of the emulated device is available as a simulation model on a networked platform which hosts the simulation process. Thus even though the communication is happening on the physical Ddevice the protocol stack and applications will only be aware that they are using the Ddevice. The virtual device can be easily configured to provide the capabilities that is the control interfaces of any desired network device.

In particular techniques are provided for emulating a networking device e.g. a WiFi device using a perhaps completely different real networking device e.g. Ethernet device . The virtual or emulated networking device UDIA interfaces the networking system and applications in a physical system with the simulation models of that device in a simulated environment for channel and mobility. This interface is provided for both the data channels transfer of data and data related APIs and the control channels setting the properties or attributes of the device itself . Any change in the emulated device status by any component in the physical system is effectively reflected in the simulation process and similarly any effect within the simulation is reflected to the physical components that use the emulated device.

The result therefore provides on demand and dynamically single or multiple instances of a UDIA on a physical device in a manner that does not compromise the programming interfaces APIs and application binary interface ABI compatibility of the entire system is transparent and independent of the underlying OS and provides functional transparency to the users of the UDIA. The following desirable objectives may be achieved in one or more preferred embodiments.

Application Programming Interface API Compatibility The emulated device should export the same APIs as that of a real device. Any application service or protocol developed for a real network device should work seamlessly with the emulated devices. That is the UDIA should masquerade as a real device to the users the applications and the protocol stack.

Application Binary Interface ABI Compatibility Any existing application or protocol that was developed for a physical device should work seamlessly with the UDIA. That is there should be no need for access to the source code for modifications recompilations and or relinking into the END. In other words the same binary application or library should work for both physical and emulated devices.

Perceptual Transparency The end users the applications as well as the protocol stack should not be able to perceive any differences in performance between a real device and an emulated one.

Multiple Instances of UDIA The system should provide the ability to run multiple instances of the networking system software. The implementation itself may be either by running multiple processes for each instance or running single instance that de multiplexing different calls within this instance.

Operating System Transparency No additional support or feature from the Operating System should be required for development installation and usage of the UDIA more than what exists in the standard distribution versions. As an example for commercial closed source OS there should be no requirements for the access to the source code.

Operating System Independence The development and customization environment in UDIA should not require any domain knowledge of any specific operating system. That is the framework should be portable to all the platforms that it supports.

Hot Pluggable The UDIA system should not require recompiling the kernel and or restarting the machine in order to be installed uninstalled or used.

Co existence with Physical Device It should be possible that both the physical and the emulated devices exist simultaneously. That is some applications may chose to communicate using emulated device while others use the physical one.

Support Cross Layer Interactions CLI The UDIA should support cross layer interactions between the applications and networking system software and between applications and network devices in ways more advanced and flexible than what is possible with a physical.

Flexible Execution Environment The simulation models for the UDIA should be able to run on the same machine in which the application is running or alternatively on a remote server.

Some or all of the following desirable benefits may be provided in one or more preferred embodiments. Any machine with an emulated device for the target network should appear to the users the applications and the protocol stack as if it is deployed in the target network. This platform can be used for purposes of development validation test evaluation training etc. This emulated platform may be useful for those components of the network under test that are either difficult or costly to deploy e.g. airborne networks the technology for which is not currently available e.g. JTRS or the intended channel environments cannot be produced easily e.g. channel conditions in rain .

The virtual network device for simulation presents a real networking stack with an interface to a scenario existing in a simulation. It allows the user the flexibility to test real world applications and transport and routing layers first on a simulation scenario through the virtual network device for simulation and then swap the virtual network device with a real network device once the performance of the applications and the protocol stack is deemed satisfactory. This provides an efficient mechanism for protocol stack validation and testing.

The radio drivers Medium access layer etc can be implemented within a simulator framework which provide an easy and platform independent environment for such development or evaluation. Testbeds with real devices typically require extensive domain knowledge creation and modification of kernel device drivers and firmware programming to implement radio drivers.

The radio hardware as well as the communication channel can be modeled as simulations. This allows scalability repeatability controllability and ease in analysis.

Low cost test beds Physical testbeds are expensive and difficult to set up and maintain. Configurations such as mobility in a freeway for a vehicular network are not only difficult to realize but also nearly impossible to repeat. These testbeds cannot be as rich as simulation in creating diverse scenarios or providing varied input conditions. Emulation offers a viable alternative to the preceding shortcoming. A cluster of devices can be connected with each other via the emulated network devices and the radio and channel can be configured easily within the simulation environment in a repeatable and controllable fashion.

Futuristic technologies A physical test bed or a development environment cannot typically accommodate futuristic designs of networking hardware especially if the implementations of which are either not currently available or difficult to procure e.g. JTRS technology Cognitive radio UWB and so on .

A small scale test bed can be extended by components of the same technologies to addresses the scalability limitations of the physical test beds.

Scripts and applications that are used to set up and configure a physical wireless network will typically work seamlessly in this emulated network. For example the emulated virtual device will typically allow setting up a network in infrastructure ad hoc mode setting the SSID Tx power level data rate adaptation methods etc.

Recent advances in protocol stack design have led to a new concept of stack design cross layer protocol stacks where control information is shared across layers so that performance of the stack on the whole can be optimized based on individual layer performance a feature which was denied in the conventional OSI Layer approach for stack design. These cross layered stacks allow the layers to get as well as set other layer parameters for achieving optimized performance. The virtual network device for simulation may provides an ideal environment for the development of cross layered protocol stacks by allowing the real world protocol layers to get and set parameters for the virtual network device which in turn are reflected in the simulation scenario. An example is power aware routing protocols that change the transmit power of the radio to improve performance metrics. With the virtual device the routing protocols do not need to be modified they will work seamlessly with a real or virtual network device.

Protocols or applications that monitor the network device need not be modified. Examples include tcpdump for packet capture along with enabling disabling promiscuous mode etc ethereal airopeek etc applications that monitor the channel signal strength as well as other network diagnosis applications.

Referring now to a hardware in the loop network may include physical hosts and a network simulator . The physical host may include applications protocol stack Ddevice interface and the physical device . The simulator may include simulation models of the device D. It is intended that the application and the protocol stack operate over the Ddevice .

In operation as shown the application and protocol stack want to use the D but have access to the device interface for D only. This may be a particular problem if the two devices and are not mutually compatible. The application and protocol stack in this case would not be able to access and use the attributes of the device D. Even if devices and are compatible with each other the application and protocol stack may access the device attributes through the interface but these attributes will belong to the Ddevice and not the correct device D. Similarly the application and protocol stack may change a device attribute through the interface but these attributes will be changed for the device D and not to the correct device D. Such problems could either lead to inapplicability of the hardware in the loop network for many use cases or to incorrect analysis of the application or protocol stack .

Referring now to an improved the hardware in the loop network may include physical hosts and a network simulator . The physical host may include application protocol stack device Dinterface UDIA device Dinterface and the physical networking device D. The simulated network may include simulation models of the device D. In this hardware in the loop network the UDIA pretends to the application and the protocol stack that the attributes of the device Dare available on the physical host through the Dinterface .

Thus application and protocol stack may access correctly the device D in simulator even if the devices D and D are mutually incompatible. Furthermore application and protocol stack may access the device attributes of D via the Dinterface . The UDIA retrieves the correct attributes of the simulated device D from the simulator and thus is able to pretend that the device Dis available on the physical host . Similarly application and protocol stack may modify the device attributes of the device Dvia the Dinterface . The UDIA communicates this information to the simulated device D in the simulator and thus is able to pretend that the device Dis available on the physical host .

In a preferred implementation of the UDIA the UDIA may be implemented as a network device driver module that operates as a layer between the protocol stack and the device D. The operating systems that supports network communications provide mechanisms for developing installing and using device drivers for the communication hardware Network interface cards such as Ethernet controllers or wireless radios . The upper half of the driver is configured to communicates with the protocol stack while the lower half is configured to communicates with the actual hardware.

The UDIA may be implemented as a module that can be loaded into the operating system in the standard Software Development Kit SDK environment available in the specific platform in case of Linux the UDIA may be implemented as kernel modules in case of Windows as NDIS drivers . The upper half of the UDIA therefore provides the same interface as a real device by virtue of which it is able to masquerade as a real device. The egress traffic from the applications and the protocol stack will reach UDIA .

The lower half of the UDIA however deviates from the conventional driver implementation as there is no actual hardware that is used for communication. The lower half of UDIA is configured to communicate with another driver of a physical device D.

When the UDIA is loaded in the host system it will unregister the protocol stack handler from the physical device driver and announce itself as the handler. In this way the packets that arrive on this host and received by the physical device driver will be handed off to the UDIA before they can be fed into the protocol stack .

Referring now to the physical host may consist of application protocol stack UDIA and the physical device D. A simulator consisting of the device D is running at some other machine.

The UDIA provides two kinds of interfaces to the protocol stack and application Data Interface Handler and Control Interface Handler . The data interface is responsible for transfer of data between the application and simulated device while the control interface is responsible for providing access to read and set the simulated device attributes and parameters that is interfaces not related with data transfer.

The Data Interface handler provides two key interfaces sending packets and receiving packets . Applications send out data assuming that the device underneath is the D and the data handler transforms this packet into a format that is compatible with the D. Similarly data arriving from the D is modified to a format such that applications believe that it is arriving from the Dtarget device .

The Control Interface hander also provides two key functionalities Get Device attributes and Set Device attributes . The application or protocol stack may read the current device status of the device via function calls or set those to new values again via function calls.

UDIA is only a front end for these interfaces all data calls and functions are ultimately delivered to the simulation device within the simulator .

As noted earlier the actual implementation of the device Dis available within a real time simulator that executes as a user level process on a remote machine. After the UDIA is loaded it need to register itself with the remote server . The simulation server may periodically announce itself via a broadcast message of its availability and announce the port number for the simulation process . Alternatively the IP address of the machine and the port number of the simulation process can be configured in the UDIA manually. In either case the UDIA will create a UDP packet and send its information to the simulation process . This packet will contain the IP address of the emulated device Dand send it over the physical device . The simulator upon receiving the packet will know the emulated IP address as well as the IP address of the physical device and it will maintain a mapping of these two addresses in a lookup table.

Referring now to as well as the data interface handler must satisfy the following requirements for correct operation of the hardware in the loop network .

There are no actual hardware associated with the D hence there will be no link layer addresses as those are defined by the hardware . This will create issues among other things with regard to the ARP module that maintains a mapping between the IP addresses and the link layer addresses.

When two physical hosts are on the same LAN these two nodes should not be able to communicate with each other directly. All communications between these nodes should go through another machine that is running the simulation process .

Both the considerations made above must be hidden from the applications and the protocol stack . That is the application and protocol stack should be able to use the IP addresses of the emulated device just as they would for a real device. This requires that between the application and the upper half of the UDIA the IP address of the physical device must not be visible and at the same time between the lower half of the UDIA and the physical device the IP address of the emulated interface should not be visible.

Referring now to the operation of the data interface in is described in greater detail. The hardware in the loop network may include two physical hosts and and also a third machine that is running a real time simulator as a user level process. The emulated devices on the two machines have IP addresses of V1 and V2 and respectively . These emulated devices will actually use the physical network devices D and for communication and the IP address of these are P1 and P2 respectively. The IP address of the simulation machine is P0. The corresponding link layer addresses are M1 M2 and M0.

The sender application on the physical host will generate data and request the protocol stack to send to the IP address V2. Note that that application communicates assuming that the address V2 is a real one. The protocol stack will add the transport and IP layer headers to the data. The IP header of the packet will contain V1 as the source address and V2 as the destination address. Again note that the protocol stack still operates assuming that the addresses V1 and V2 are real. The protocol stack will finally deliver the packet to the UDIA .

UDIA upon receiving the packet from the protocol stack will remove the transport and IP headers and place them in the data segment of the packet . It will subsequently create new transport and IP headers. The transport header will be a UDP header that will contain the port number of the simulation process as the destination port number. The IP header will have P1 as the source address and P0 the simulation machine as the destination address. UDIA will handoff this modified packet to the driver of the physical device .

The physical device will look at the IP header of the packet and assume that the protocol stack wants to send data to the simulation machine . The device will invoke the ARP protocol to find the link layer address of the P0 or look up from the ARP table if the protocol has already been invoked. Note that this ARP communication happens for the physical devices for which link layer addresses exist. The physical device will then transmit this packet to the simulation server .

At the host running simulation the packet will appear to be coming from the physical interface . That is the protocol stack in the simulation machine will not be aware of the virtual interfaces. When the data reaches the simulation process the latter will parse through the data segment to read the original IP and transport header. The IP address information is used to model the communication between the two nodes in the simulation environment .

When the simulation process decides that the node that has the virtual IP address V2 should receive a packet it will encapsulate the data as well as the original headers in the data segment and ask the protocol stack to deliver to P2 . Recall at time of installation of the UDIA and UDIA an entry was added at the simulation process that maps the virtual address to the physical address. The packet will be delivered over the physical address to the destination machine .

When the driver of the physical interface receives the packet it will deliver the packet that to the UDIA since the latter has announced itself as the default handler of all IP packets. UDIA will strip out the IP and transport headers in the packet and move the original headers contained in the data segment into the respective place and deliver this new packet to the protocol stack . In this way the protocol stack will see the packet as if it is coming from the emulated network device. The actual data can then be delivered to the receiver application .

Referring now to and the operation of control interface handler described. As mentioned earlier the interface handler is required to provide two key interfaces Setting the device attributes and reading those attributes . When the device attributes are set by any user two copies of the new values are made one value is store locally in the Network Device Attributes Table while the second copy is sent to the Emulation process where the characteristics of the simulated device can be suitably modified.

When any application wants to read the current value of any device attribute the control interface handler first decides at decision block whether the request can be answered from the local Device Attributes Table . The rules for making this decision depend on the nature of the device and as such are configurable by the implementer of the device Dinterface within UDIA . If the request can be answered locally the function call returns immediately with the values from the table . In case the request cannot be answered locally the control interface handler blocks the requesting application and forwards the request to the simulated device . The simulated device then provides response with the current values of the device attributes which are returned to the requester of the information as well as stored in the local device attributes table . The simulated device can also chose to inform the control interface handler regarding any change in the device attributes even if it is not explicitly requested to do so. These information are stored directly in the table and help in keeping it up to date.

The following paragraphs review some of the mechanisms and approaches adopted in a preferred embodiment of a hardware in the loop network simulation.

The UDIA module is implemented as a network device module such as a loadable kernel module in Linux NDIS driver in Windows or Kernel Extensions in Mac OSX. The operating system and applications will therefore think that there is a physical networking device available to be used and that it can be accessed via the UDIA driver.

The UDIA driver module exports the attributes that is the interfaces of the Dtarget Therefore the OS and the applications will think that the networking device accessed via UDIA is actually the device of type D.

After the UDIA module is loaded and assigned a virtual network address the UDIA will register itself with the emulation server process. This registration message will contain both the virtual address and physical addresses. The emulation server will therefore having a mapping between the virtual and physical mapping which will be used later on to direct the outgoing packets from the emulation server to the correct physical host.

When the UDIA is requested to transmit a data packet it will send the packet using the driver of the device D. However before doing that the UDIA driver will convert the packet if necessary to a format that is compatible with the device D. Therefore even though Dis utilized for transmission of packets it remains absolutely opaque to the users of the UDIA e.g. the OS and applications.

The UDIA module upon loading will unregister the protocol stack from the Ddevice driver. That is the UDIA driver will inform that the part of operating system such as the protocol stack that previously used to handle all incoming packets is no longer available. Instead the UDIA announces itself to be the default handler for all incoming packets. As a result the Ddriver upon receiving packets will deliver them to the UDIA driver. This is necessary since the UDIA driver does not operate over a hardware over which it can receive packets. However by following the list of steps as outlined the UDIA driver is able to receive all incoming packets that are destined for this particular node.

When the UDIA driver is requested to send out a packet it will modify the structure of the packet headers and the payload. Recall that the headers in these packets will contain virtual addresses and that there are no physical machines in the local subnet that have these addresses. To ensure seamless communication the UDIA driver moves the actual packet header in the packet payload and creates new headers. These new headers will contain the physical addresses of the local machine the Ddevice and the machine that hosts the emulation server.

When the UDIA driver receives a packet it will again modify the structure of the packet headers and the payload. Recall that the headers in these packets will contain the physical addresses. The UDIA driver removes these headers and moves the virtual headers that were stored in the packet payload as the header for the packet. This way any piece of software applications or protocol stack that use the virtual Ddevice will think that the packet is coming from the virtual address.

When any application or a component of the operating system accesses the device attribute interface of the D either to set a value or to get the value the UDIA driver will be responsible for handling such requests. When setting a value the UDIA will create a packet that will contain the attributes whose value is set and the new value and send this packet to the emulation server. When a value of an attribute is requested the UDIA driver will create a packet that will contain the name of the attribute and send it to the emulation server. The UDIA driver will then wait for a response from the emulation server. This response will contain the value of the attribute which will be returned to the requesting process.

The above steps can be optimized by maintaining a cache at the UDIA driver. When a value of an attribute is requested the UDIA will first consult the cache and identify if the request can be satisfied locally from the cache. If this is the case then the UDIA driver will reply immediately from the cache otherwise it will follow the steps as outlined above. The cache is populated by three events when a value of an attribute is set then this value is stored in the cache when a value of an attribute is requested from the emulation server the reply is stored in the cache and when the emulation server send a gratuitous message to inform a change in value of some attribute the value is also stored in the cache.

It periodically broadcasts in the local subnet the IP address and the port number of the emulation server process. This is beneficial for newly loaded UDIA drivers to identify the location and address of the emulation server without the need for explicitly configured by the user.

The emulation server will continuously listen for incoming data packets. Upon reception of data packets the server will extract the virtual header from the packet payload and feed it into the emulation process.

The emulation server will continuously listen for attribute value requests. Upon reception of such requests the server will consult the emulation process to retrieve the value and send it back to the originating requestor via a data packet.

The emulation server will send an outgoing packet to an UDIA driver. This packet will contain the virtual headers as the packet payload.

The emulation server will continuously monitor if any attribute of the emulated device is changed. If they do then the server will create a gratuitous packet and send this information to the relevant UDIA driver so that this new value can be updated in the cache.

Referring now to the emulation server may use the following steps for achieving the various tasks discussed above.

The UPA approach discussed above may be used for virtualization of the networking system software e.g. the protocol stack and the UDIA approach discussed above may be used for virtualization of the networking device. These two techniques however may be combined to run in conjunction to virtualize the entire networking subsystem. Users may then launch networking applications that will operate on a virtual networking system provided by a real time simulation process e.g. as an emulation. Any operation that is related with the protocol stack will be handled by the UPA while any operated related to the networking device will be handled by the UDIA. In both cases the applications will be able to transparently interact with the counterpart virtualized protocol stack and networking device respectively with UPA and UDIA within the emulation process.

One benefit of this combined use case is to develop test and evaluate application for different combinations of networking system software and networking devices. Currently there exists a large spectrum of networking software and hardware. Executing applications on each possible combination is costly in terms of hardware resources and system administration. With the combined UPA and UDIA approach the users can conveniently change either the protocol stack using the UPA while keeping the same virtual device or change the virtual device using UDIA while keeping the same virtual protocol stack or change both using UPA and UDIA techniques.

Referring now again to and a combined UPA and UDIA system and method may be described. The UPA library will bypass the host protocol and connect to the Dinterface . The Dinterface will in turn use the UDIA to connect to the emulation process .

Referring now also to . and a more detailed description of the combined use case is provided. Data interface handler will send packet to UPA socket which will forward the packet to UDIA data interface handler . Similarly on the return path UDIA data interface handler will handoff a received packet to data interface handler in the UPA library . Control interface handler will create packet and request UPA socket for transmission. Packet will reach UDIA data interface handler and subsequently transmitted to emulation process .

Application may also use the UDIA interface handler directly to set via simulated device D and get via simulated network device attributes and the operation will happen the same way as described above.

 a the data interface of the socket interface to send and receive data packets which will be handled by UPA library through the data call diverter 

 b the control interface of socket interface to set or get the properties of the protocol stack which will be handled by the control interface diverter in the UPA library and or

 c the control interface of the protocol stack to set or get device attributes which will be handled by UDIA control interface handler .

Referring now to in a combined operation of UPA and UDIA host 17 10 may have an application that may use simulated network device D as well as simulated protocol stack PS. Note that in contrast to the descriptions in section A and section B above where only one of D or PS were simulated in this case application may make use of both D and PS concurrently. Application may use system interface to send data receive data modify the protocol stack or device attributes and or access attributes .

As discussed above UPA should be loaded after system interface but before the host protocol stack not shown in this figure . illustrates the usage of UPA in conjunction with UDIA indicating how system interfaces through are mapped to simulated device D and or simulated protocol stack PS.

Data call diverter in UPA diverts data send and data receive calls to data interface handler . Diverter and handler may be similar to devices described above with regard to and . Data interface handler may communicate with UDIA data interface handler in UDIA module . UDIA data interface handler in turn delivers the calls to the host device D.

Control call diverter may be responsible for handling set attribute and get attribute calls from application . Control call diverter may determine if the control messages are intended for the protocol stack or the networking device. If the control messages are intended for protocol stack PS control call diverter may pass the message to control interface handler . The details of similar devices to control call diverter and control interface handler are described earlier with reference to and . Control interface handler will pass the message to UDIA data interface handler . If control messages or are intended for simulated device D control interface diverter will pass these messages to UDIA control interface handler . The details of devices similar to both UDIA data interface handler and control interface handler are described above with regard to .

Referring now to the right side of the the real time simulation process may use simulated device D and simulated protocol stack . All messages that are received from UDIA data interface handler may be delivered to the PS whereas all messages received from UDIA control interface may be delivered to the D. Therefore in the system and method described in application in host 17 10 may send or receive data as well as set or get attributes for both the protocol stack PS and device D through a combined use of UPA and UDIA .

