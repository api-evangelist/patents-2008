---

title: Utilizing speech grammar rules written in a markup language
abstract: The present invention provides a method and apparatus that utilize a context-free grammar written in a markup language format. The markup language format provides a hierarchical format in which grammar structures are delimited within and defined by a set of tags. The markup language format also provides grammar switch tags that indicate a transitions from the context-free grammar to a dictation grammar or a text buffer grammar. In addition, the markup language format provides for the designation of code to be executed when particular grammar structures are recognized from a speech signal.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07996225&OS=07996225&RS=07996225
owner: Microsoft Corporation
number: 07996225
owner_city: Redmond
owner_country: US
publication_date: 20080521
---
This application is a Divisional of and claims priority from U.S. patent application Ser. No. 09 759 474 filed Jan. 12 2001 now U.S. Pat. No. 7 389 234 issued Jun. 17 2008 which claims priority from a U.S. Provisional Application having Ser. No. 60 219 861 filed on Jul. 20 2000 and entitled MICROSOFT SPEECH SDK SAPI 5.0 .

The present invention relates to grammars used in speech recognition. In particular the invention relates to context free grammars.

In speech recognition systems a computer system attempts to identify a sequence of words from a speech signal. One way to improve the accuracy of the recognition is to limit the recognition to a set of selected phrases. This is typically done by limiting valid recognition hypothesis to phrases that are found in a context free grammar CFG .

In prior art speech recognition systems context free grammars were specified using the Bakus Nauer Form BNF which identifies valid phrases using a two part format. The left part of the Bakus Nauer Form contains a non terminal reference to the phrase and the right part of the Bakus Nauer Form contains a sequence of terminal and non terminal nodes that represent the phrase. In this context a terminal node is a generally a word and a non terminal node is a reference to an additional phrase or word.

Although the Bakus Nauer Form does allow indirect reference to a phrase thereby eliminating the need to repeat phrases in the context free grammar it is still somewhat limited. In particular the Bakus Nauer Form does not provide an easy means for providing alternative words optional words transitional probabilities semantic properties or executable code in a phrase.

In the past some attempts have been made to modify the Bakus Nauer Form to allow for some of these items. In particular some prior art systems have added diacritics to the Bakus Nauer Form to indicate that some words are alternative others are optional or the weight that is to be attributed to the words. The use of diacritics however is less than ideal since their meaning is not readily apparent and their scope is difficult to determine. In addition diacritics do not allow for the inclusion of code or semantic properties in the context free grammar.

Because of these factors context free grammars are difficult to author and have limited abilities. As such a speech recognition system is needed that can take advantage of a different context free grammar format.

The present invention provides a method and apparatus that utilize a context free grammar written in a markup language format. The markup language format provides a hierarchical format in which grammar structures are delimited within and defined by a set of tags. The markup language format also provides grammar switch tags that indicate a transitions from the context free grammar to a dictation grammar or a text buffer grammar. In addition the markup language format provides for the designation of code to be executed when particular grammar structures are recognized from a speech signal.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in FIG. provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Binary grammar defines a limited set of binary formatted grammar structures that that can be recognized from an input speech signal. Binary grammar is produced by compiler based on a text formatted grammar . Under the present invention the text formatted grammar is formatted using a markup language. Example tags for one embodiment of this markup language are discussed further below.

During recognition speech recognition engine is limited to recognizing grammar structures in binary formatted grammar . When it recognizes a grammar structure from a speech signal or recognizes a grammar structure as one hypothesis for a speech signal speech recognition engine identifies the grammar structure to context free grammar engine .

Based on the information received from speech recognition engine context free grammar engine generates a parse tree that indicates the words that have been recognized and a semantic parse tree that indicates the semantic meaning associated with the grammar structure. As discussed further below while generating the semantic parse tree context free grammar engine may cause a section of code identified as a rule interpreter to execute if one of the identified grammar structures returned by speech recognition has a rule interpreter associated with it.

The semantic tree structure and the word tree structure are then returned by context free grammar engine to application .

In one embodiment compiler and context free grammar engine together form a speech recognition interface. This interface acts as a front end between an application that has an associated text formatted grammar or binary formatted grammar and a speech recognition engine.

In one embodiment binary grammar is the binary version of a state diagram formed by compiler from text formatted grammar . provides an example of a state diagram showing three top level grammar structures derived from text formatted grammar . In the three grammar structures are and which begin at nodes and respectively.

The newgame grammar structure has a transition from starting node to node that is associated with the word new . From state to state this structure has a second word transition associated with the word game . After state there are two parallel transitions and to a final state . Transition is an epsilon transition indicating that word transition which is associated with the word please is optional.

During speech recognition speech recognition engine traverses the state diagram to determine whether speech signal corresponds to any of the grammar structures. For example speech recognition engine will identify the structure as corresponding to speech signal if the word new is found at the beginning of the speech signal followed by the word game . Note that since the word please is optional in the structure speech recognition will identify the newgame structure even if the word please is not found in the speech signal.

The grammar structure which starts at node is more complex than the structure. From starting node the structure has an epsilon transition and a word transition that both end at state . Epsilon transition indicates that the please associated with word transition is optional. From state there are two consecutive word transitions leading respectively to state and state . These word transitions are associated with the words play and the respectively.

From state to state the structure has a wildcard transition . During this transition speech recognition engine will ignore any input provided by the user after the word the and before words associated with a grammar structure which is found at transition from state to state . Thus no matter what the user says during transition speech recognition engine can still identify the structure as being recognized for the speech signal.

Transition of the structure is a grammar structure transition. When speech recognition encounters this transition it substitutes the entire state diagram of the referenced grammar structure in place of the grammar structure transition. For example speech recognition engine would replace transition with the state diagram of which represents the grammar structure. It would then determine if speech signal could be represented by part of the complete grammar structure including the portion of that structure provided by the grammar structure.

From state to end state of the structure there is an epsilon transition and a word transition associated with the word please . Epsilon transition indicates that the word please is optional in the structure.

The structure associate with start node begins with an epsilon transition to state . Epsilon transition is in parallel with a word transition associated with the word please . As such the word please is optional.

From state to state the structure provides two parallel transitions and associated with the words put and move respectively. Thus if the user says either put or move the speech recognition engine will identify these portions of the speech signal with the structure.

From state to state there is a single word transition associated with the word the . From state to state the structure provides a grammar structure transition associated with the grammar structure.

From state to state there are two parallel word transitions and associated with the words on and to respectively. A word transition for the word the extends from state to state which is followed by a grammar structure transition to state for the grammar structure.

An epsilon transition extends from state to state . This epsilon transition indicates that the transitions between states and are all optional. As such the words associated with these transitions do not need to be present in the speech signal in order for speech recognition engine to identify the structure from the speech signal.

From state to end state there is epsilon transition in parallel with a word transition . Epsilon transition indicates that the word please associated with transition is optional.

As can be seen from the description of above the state diagram used by the speech recognition engine is quite complicated. Because of this it is often difficult to use the Bakus Nauer Format to specify a context free grammar. However under the present invention a markup language format is provided that greatly simplifies the task of specifying a context free grammar.

Below one embodiment of a markup language that can be used to represent a context free grammar under the present invention is described. In particular a set of markup tags is described that can be used to specify a context free grammar. Those skilled in the art will recognize that the present invention is not limited to the particular tags described below and that other markup language tags can be used in place of or in conjunction with the tags described below.

The description of the tags below makes reference to and which show the grammar structures of described in a markup language of the present invention.

Under this embodiment of the invention the markup language is specified using the extensible markup language XML standard formalism. Every XML element consists of a start tag and an end tag that contain a case sensitive tag name and that delimit a set of elements. If there are no elements the start tag and end tag can be combined to form a single tag .

Each XML element can also be defined as having one or more attributes. Attributes of an XML element appear inside the start tag. Each attribute is in the form of name followed by an equal sign and a string which must be surrounded by either single or double quotation marks. An attribute of a given name may only appear once in a start tag.

The tag is the outermost tag and delimits an entire context free grammar. The tag has global grammar attributes including a LANGID attribute that identifies the language associated with the grammar. The language identifier is specified as a hex decimal value. For example the LANGID for English U.S. is expressed in hexadecimal form as 409.

The tag has two direct children the tag and the tag. Other tags and text are only allowed if they appear within a pair of tags or a pair of tags.

The tag specifies a group of tags which are used to associate a property ID name with a property ID value and to associate a Rule ID name with a Rule ID value. This allows the grammar author to use a character based name instead of a number for a property ID or Rule ID so that the property ID or Rule ID is more intuitive when reading the text formatted grammar.

The tags typically do not have elements and as such a single start end tag is typically used. For example tag is a single start end tag. Each tag can have two attributes of NAME and VAL. The NAME attribute provides a name string that will be used in the remainder of the grammar. This string appears between single or double quotes. The VAL attribute is an integer value associated with the name and can have any 32 bit value. During compiling the integer value found for the VAL attribute is replaced for the name string of the NAME attribute throughout the grammar.

The tag delimits a grammar structure and provides a NAME attribute that allows the structure to be referenced by name both internally and externally to the grammar. The grammar structure may be alternatively referenced by the tag s ID attribute which is a constant value or variant type.

Another attribute of the tag is the TOPLEVEL attribute which indicates whether this is a top level grammar structure. TOPLEVEL structures can be examined by the speech recognition engine at any time and do not require that the engine to be in a particular state. Rules that are not top level cannot be accessed by the speech recognition engine unless it encounters a grammar structure transition that makes reference to the rule.

The possible values for the TOPLEVEL attribute are active or inactive. When rules are initially loaded into the speech recognition engine they are inactive. To activate a rule the application passes an instruction through the context free engine to the speech recognition engine to activate the rule. The value of the TOPLEVEL attribute is used to simplify this process. Instead of sending a separate instruction to activate each individual rule the application can send a single instruction to activate all rules that have a TOPLEVEL attribute set to active . If the TOPLEVEL attribute has a value of inactive the rule remains inactive until the context free grammar engine receives a specific instruction from the application to activate that particular rule. Note that as long as the TOPLEVEL attribute is listed the rule will be considered a top level rule regardless of whether the value is active or inactive.

A further attribute that can be found in the rule tag is the EXPORT attribute. This tag specifies whether the rule can be imported or referenced by another grammar structure. The attribute may have values of 0 or 1 where 1 enables other grammar structures to import the rule and 0 prevents other grammar structures from importing the rule. In some embodiments other values such as true false or yes no will be treated the same as 1 0 

The tag also includes an INTERPRETER attribute that indicates whether a section of computer executable code is to be invoked when the grammar structure delimited by the tags is identified from the speech signal. When the INTERPRETER attribute is set to 1 code is executed. When the grammar structure is identified from the speech signal when the INTERPRETER attribute is set to 0 code is not executed when the grammar structure is identified.

As will be shown in more detail below the code associated with the INTERPRETER attribute receives the semantic values assigned within the grammar structure delimited by the tags. The code can also return one or more semantic property strings that are associated with particular semantic properties.

A grammar structure may also be identified as being dynamic by setting a DYNAMIC attribute in the tag. When the DYNAMIC attribute is set to 1 the context free grammar engine will allow the application to change the rule after it has been loaded into the grammar engine. If the DYNAMIC attribute is set to 0 the grammar structure is not considered dynamic by the context free grammar engine.

The last attribute of the tag is the TEMPLATE attribute. The TEMPLATE attribute allows the author to specify that values of certain semantic properties are to be returned to the application in place of the words of the grammar structure when the grammar structure is identified from the speech signal. In addition the TEMPLATE attribute allows the author to specify an appearance for these property values. For example if the grammar structure contained semantic properties of MONTH DAY and YEAR the TEMPLATE attribute could be set to TEMPLATE MONTH DAY YEAR . This would cause the returned recognition for the grammar structure between the tags to be replaced by the month day and year separated by slashes. For example if MONTH had a value of 10 DAY had a value of 2 and YEAR had a value of 98 the output for the rule would be 10 2 98.

In several tags are shown. For example start tag and end tag delimit the grammar structure found in . In start rule tag the name of the rule is set to playcard by the NAME attribute and the rule is indicated as being a top level rule by the existence of the TOPLEVEL attribute. Since the TOPLEVEL attribute is set to active this rule will be activated by a single instruction to activate all rules that have the TOPLEVEL attribute set to active. The rule is also capable of being exported as indicated by the fact that the EXPORT attribute is set to 1.

 tags are used to identify a loaded object a local file or a remote file located on an attached network that can be used during recognition or by a rule interpreter. The different resources are distinguished from each other by a NAME attribute which identifies the resource.

To obtain the string value that indicates the location of the resource the interpreter s code or the speech recognition engine can query the context free grammar engine for the string value associated with a resource name. Once the interpreter or recognition engine has retrieved the string value it can locate and open the resource directly.

Under one embodiment the resource can be a file name for scripting code to be used by an interpreter. In such embodiments the interpreter is a script interpreter which merely executes the scripted code.

The tag is used to delimit script code that is to be interpreted when a grammar structure within a pair of tags is identified from a speech signal. This script code is executed after the rule it is located in is completely parsed. Thus after a particular path through the rule has been identified and the properties along that path have been set the scripting code within the tags is executed. This allows the script code to utilize the values of the properties defined within the grammar structure. The code within the tags can be used in place of or in conjunction with an external interpreter.

The tag is used to reference a rule from within an existing grammar structure. Since a tag has no contents it typically appears as a single start stop tag.

The primary attribute of the tag is the name attribute which specifies the name of the rule that is being referenced. Under one embodiment of the invention a rule may be referenced in a grammar before it has been declared in the grammar. The referenced rule may be identified by its ID instead of its name by using the REFID attribute in the tag.

The tag may be used to reference a rule that has yet to be loaded into the context free grammar engine. To identify such a rule either an OBJECT attribute or a URL attribute is used to specify the location from which the rule should be loaded. The OBJECT attribute is used to specify a class identifier or programmatic identifier that indicates the location of the grammar object that contains the rule. The URL attribute is used to identify a stored file file directory name sum file name.xml a resource res directory name sum resource.dll or an internet location stp www.microsfot.com sum resource.dll that contains the rule.

If the rule being referenced includes an interpreter that is to be executed the OBJECT attribute of the tag is set to the class identifier or program identifier for the interpreter.

The tag also has a PROPNAME attribute and a PROPID attribute that identify a semantic property to be associated with this rule reference as well as a VAL attribute which indicates a value for the property. If the VAL attribute is set within the start tag the property identified by the PROPNAME attribute is set to the value of the VAL attribute. If the VAL attribute is not included in the tag the text recognized by the referenced rule becomes the property value for the property specified by the PROPNAME attribute. The value for the semantic property identified by the PROPNAME attribute may also be identified indirectly using the VALSTR attribute which contains a string identifier of the VAL element.

Lastly the tag includes a WEIGHT attribute that specifies the relative list position of the rule referenced by the tag. This WEIGHT attribute is expressed as a float value and is provided to the speech recognition engine to bias the engine toward recognizing one item in a list over other items.

The tag which has an alternative short form of just is used to delimit a grammar sub structure that begins from a single state and ends at another single state. Between the two states the elements of the phrase tag can be one or more words or a combination of words and tags that define multiple paths and multiple intermediate states between the two end states.

Example of the different uses for the tag can be found in . Specifically phrase tags and define the start and the end of a phrase. Within these phrase tags a set of list tags and define two alternative paths each of which are defined by additional phrase tags and . After list tag additional phrase tags and provide an additional word element.

The structure represented between phrase tags and of is shown in as extending from state of to state . The phrase tags found within list tags and define put transition and move transition of . Phrase tags and define the word transition for the word the in from state to state .

The tag has several optional attributes including PROPNAME and PROPID attribute that are used to designating the name and id respectively of a property associated with the recognition of the grammar sub structure between the tags. A VAL attribute or a VALSTR attribute can optionally be set in the start tag to designate the value or a string containing a value identifier for the property specified by the PROPNAME attribute. Thus if the speech recognizer identifies the grammar sub structure within the tags the name associated with the PROPNAME attribute will be set to the value associated with the VAL attribute or the value identified by the VALSTR attribute. If there is no VAL or VALSTR attribute the property identified by the PROPNAME attribute will be set to null.

The author of the context free grammar can also designate a pronunciation for a single word between tags. This is done by setting the PRON attribute of the phrase tag equal to a phoneme description of the pronunciation. Table 1 below provides example phoneme descriptions that can be used under one embodiment of the present invention.

The author of the context free grammar may also specify the display form for the text elements between the tags. This is done by assigning a string representing the display form to the DISP attribute.

In one embodiment the context free grammar author may also specify the display format and the pronunciation without using the PRON attribute or the DISP attribute. To do this the author uses an alternative format when designating a word within the tags. Specifically the author designates the words as display form lexical form pronunciation 

In this format the beginning slash after the first tag indicates that this is the alternative format for specifying a word. The display format is then specified followed by another forward slash. The lexical form of the word that is the form in which the word appears in the lexicon is then provided followed by a third forward slash. The phoneme description of the word s pronunciation is then provided in a space delimited format followed by a semicolon indicating the end of the pronunciation. Note that any of these elements may be omitted as long as the forward slashes remain.

The tag also provides a set of attributes to make it easier to identify repeated occurrences of the same word or phrase. The MIN attribute designates the minimum number of repetitions that the speech recognition engine must identify in order to identify this phrase structure and the MAX attribute indicates the maximum number of times the contents between the tags may be repeatedly recognized. Note that the MAX attribute may be set to INF indicating that an infinite number of repetitions of the text between the tags may be recognized as part of this phrase.

As with the tag the tag includes a WEIGHT attribute that can be used to bias the speech recognition engine toward or away from this particular phrase when considering the likelihood of the phrase in the context of one or more possible options in a list.

The grammar author can also indicate to the speech recognition engine the level of confidence that is required of the recognition in order for this word to be identified. In one embodiment this is done by placing a plus or a minus before the word as shown in for words and . Word is the word game which is preceded by a plus sign. This indicates to the speech recognition engine that it needs to have a high confidence level for identifying the word game before it can identify the grammar structure. Word is the word please which is preceded by a minus indicating to the speech recognition engine that even if it has low confidence that user actually said please it may still identify the grammar structure.

The tag which has a short form of is used to designate a list of alternate phrase elements. For example list tags and of designate the word move as an alternate for the word put . Each sub element provided within the tags represents a possible separate recognition that could be attributed to the tag.

The tag has PROPNAME and PROPID attributes that designate the name and ID respectively of a semantic property to be associated with the recognition of at least one of the alternate phrases in the list. The value for the semantic property identified by the PROPNAME attribute can be set using the VAL attribute or the VALSTR attribute in one of the tags in the list. When the phrase is identified by the speech recognition engine its corresponding value for the VAL attribute will be assigned to the property identified by the PROPNAME attribute in the list tag. If there are no VAL attributes in the list of alternatives the property for the list will be set to null.

In one embodiment the tag has an alternate form designated as in which the alternates within the tags are each listed between specialized phrase tags .

An example of this format is shown in where tags and define a list of alternate phrase elements that are each identified between two tags such as element . The semantic property associated with the list is identified as rank by PROPNAME attribute in starting tag . The value of the rank property is set based on which of the alternates is selected. This is done using the VAL attribute in the specialized tag. For example the VAL attribute is set to 2 for element . Thus when the word two is recognized the rank will be set equal to the number 2 .

The tag which as a alternative short form of is similar to the tag except that the tag indicates that the element between the tags is optional. Like the tag the tag has attributes of PROPNAME PROPOID VAL VALSTR MAX and MIN. The property identified by the PROPNAME attribute will only be set equal to the value identified by the VAL attribute if the elements between the tags are actually recognized.

The tag may span a single word as found in for the word please which is between tags and . Alternatively the tags may enclose a larger grammar sub structure. For example in tags and enclose a phrase designated by tags and and a list designated by tags and . Thus the whole structure between tags and is optional. In other words even if the user does not say any of the phrases of clubs of hearts of diamonds or of spades the rule can still be identified if the other elements within the rule are recognized.

The tag corresponds to the epsilon transitions designated in . Thus because of the nesting nature of the markup language it is easy for authors to designate a set of optional transitions for the state diagram.

One embodiment of the invention provides an alternative format for designating a word as optional. Under this alternative format the word is preceded by a question mark to indicate that the word itself is optional.

The tag is a grammar switch tag that instructs the speech recognition engine to switch from the context free grammar to a dictation grammar during the recognition of one or more words. Thus when the speech recognition engine encounters a tag it transitions to a separate usually less restrictive dictation grammar to perform its speech recognition.

By default each tag is used to represent the identification of a single word from the speech signal. To retrieve the word that has been dictated the author can use the PROPNAME attribute of the tag to set a property name that will receive the dictated text. As with a tag the tag has a MIN attribute and a MAX attribute that can be used to repetitively recognize the same word.

One embodiment of the present invention provides an alternative markup to using the dictation tag. In this alternative mark up the star symbol is used between tags to indicate that the speech recognition system should transition to the dictation grammar during this phrase. A is used to indicate that the dictation crosses more than one word.

Instead of transitioning to a dictation grammar the present invention also provides a means for transitioning to a grammar constructed from a null terminated string. This is done using the tag which is another switch grammar tag.

Each composite grammar created by the context free grammar engine includes a text buffer that can be populated by the application. In one embodiment this text buffer is populated using an Application Programming Interface call named SETWORDSEQUENCEDATA.

When the speech recognition engine reaches a tag it searches through the text buffer for any sub sequence in the text buffer that matches the speech signal. Thus if the text buffer included a list of names such as Bill Smith Judy Jones and Phil Connors the speech recognition engine would return the word Judy if the user just said Judy and would return the words Judy Jones if the user said the entire phrase Judy Jones .

The text identified from the text buffer is returned and set equal to the name identified in the PROPNAME attribute unless the VAL attribute has been set in the tag.

Like the tag the tag also has a WEIGHT attribute which can be used to indicate to the speech recognition engine the relative weighting to be assigned to this element if it appears in a list.

The tag indicates to the speech recognition engine that it should ignore words occurring between phrases preceding the tag and phrases coming after the tag. Thus the tag can be used to indicate a transition in which it does not matter what the user says during the transition as long as they speak the remaining phrases in the rule. This tag is represented in the state diagram of by transition .

One embodiment of the present invention provides an alternative markup to using the tag itself. This alternative markup uses . . . between tags to indicate the wild card.

As discussed above a rule can designate that an interpreter be invoked when the grammar structure delimited by the tags is identified by the speech recognition engine. The interaction of rules that use interpreters and especially their effects on semantic properties are described below in connection with an example grammar depicted in and a semantic parse tree depicted in .

The alternative paths from state to state are represented by tags and of . The list tags are associated with a property identified by the property name over . The over property can have values of one or zero depending on whether the word more or the word less is identified as represented by the VAL attributes of tags and .

The transition from state to state in is represented by the phrase element between tags and of . The transition from state to is represented by tag of . This tag makes reference to a rule entitled and provides a property name of givennumber to receive the results produced within the rule.

A state diagram for the rule is shown in . The state diagram consists of three parallel transitions from an initial state to an ending state . Each of the alternate transitions is a rule transition corresponding to rules and .

The rule is defined in between tags and . In starting tag the INTERPRETER attribute has been said equal to 1. This indicates that the rule has an associated interpreter that will be invoked when the rule has been fully parsed. The alternative paths between states and of are shown by tags and . The alternates provided within tags and are each rule references making references to separate rules. In particular rule reference refers to the rule rule reference refers to the rule and rule reference refers to the rule.

A state diagram for the rule is shown in . The state diagram consists of ten alternatives each representing a separate single digit number. The rule is defined in between tags and . As can be seen in starting tag this rule is not associated with an interpreter.

The alternatives from state to state of are represented between tags and of . These list tags include a property name of ones that is associated with a value based on which of the digits the user speaks. For example if the user says three the ones property will be set to a value of 3 as indicated by the VAL attribute in tag .

The rule from is represented in a state diagram in and is described in a markup language in . As can be seen in the rule has three states and . In there is a set of alternative transitions from state to state . Each of these transitions is associated with a tens number such as twenty thirty forty and so forth up to ninety. From state to state there is an optional rules transition that references the rule. This optional transition is indicated by epsilon transition . Thus if the user says forty two the speech recognizer will identify the path from to across the word forty and from state to state across the rule for the word two.

The state diagram of also includes a set of alternate transitions from state directly to state . These alternate transitions are word transitions representing the words from ten to nineteen.

In the rule appears between tags and . The alternative pathways for transitioning between state to state is represented by an outer set of tags and . The structures within these outer list tags represent both the transitions from state through state to state as well as the transitions from to state directly.

The transitions from state through state and then to state are found within tags and . The alternate transitions from state to state are found within tags and within tags and . List tag has an associated property identified by the property name tens . This property name is set equal to a value between two and nine depending on the word recognized by the speech recognition engine. For example if the recognition engine recognizes the word sixty the value for the tens property will be set equal to 6 as indicated by the VAL attribute of tag .

The optional transition from state to state is indicated by tags and . Between these tags is a single tag that that refers to the rule.

The alternative pathways from state directly to state are represented within tags and . tag includes a property named tensandones which is set to a value depending on the word recognized by the recognition engine. For example if the recognition engine recognizes the word seventeen the tensandones property is set to a value of 17 as indicated by the VAL attribute of tag .

The rule is shown in state diagram form in and in markup language form in . In the rule starts in state and proceeds to state across a rules transition that references the rule. From state a word transition extends to state for the word hundreds . An optional rules transition that references the rule then extends from state to state . A second optional transition extends from state to state and references the rule.

In the rule is defined between tags and . In the rule the transition from state to state of is made indirectly through a rule reference represented by which references a rule named . The rule is shown in between tags and . As shown by the INTERPRETER attribute of tag the rule is associated with an interpreter. The rule includes a single element which is a tag that references the rule. The reason for this indirect call to the rule is that the rule is later referenced in the rule. Since the rule could be active twice within the rule its ones property would be set twice before the rule could convert the ones property to a hundreds property. By making an indirect reference the ones property from rule reference can be converted into a hundreds property in rule reference of the rule.

The transition from state to is shown in by the word hundred between tags and . The optional transition from state to state is shown between tags and which delimit a tag that references the rule. Similarly tags and represent the optional transition from state to state of . Options tags and delimit a single tag which references the rule.

In operation the rule will be identified if the user states the words more or less followed by the word than and a number between 0 and 999. Within the rule the rule will be identified if the user states a number between 0 and 9 the rule will be identified if the user states a number between 10 and 99 and the rule will be identified if the user states a number between 100 and 999.

Under the present invention the grammar of is supplemented with semantic names and values that reduce the processing time that the application will need to convert the text numbers to digits. Under one embodiment the semantic values are returned to the application through a semantic tree. show the evolution of the semantic tree as the context free grammar engine constructs the tree based on the grammar of .

Rule reference makes reference to the rule which further makes reference to the rule the rule and the rule. The rule includes a property name of ones . As such this property name appears as a child node of givennumber node .

The rule includes a property name of tens which appears as child node under givennumber node . The rule also includes and a property name of tensandones which appears as child node under givennumber node . The rule includes a rule reference to the rule and as such includes an additional child node for the ones property of the rule. This property name appears as node under tens node .

The rule defines a property name of hundreds which appears as child node in . The rule makes reference to the rule which in turns makes reference to the rule. As such the ones property appears as a child node under the hundreds property node .

During this expansion the context free grammar engine generates containers to hold the property names found within rules that are associated with an interpreter. These containers prevent rules outside of the container from seeing the semantic values listed within the container. For example the context free grammar engine generates a container for the rule that contains the ones tens tensandones and hundreds property names found below givennumber node . Likewise the context free grammar engine generates a container for the ones property name defined within the rule. Thus only the rule has access to the value of the ones property that has been defined within the rule.

Note that the expansion of does not represent an actual expansion of the semantic tree. Instead it represents all possible expansions for the tree. In an actual expansion only those leaf nodes associated with a recognized grammar structure would be expanded. Thus if the user said a number between zero and nine the only property beneath givennumber node would be ones node . For a number such as 180 tens node hundreds node and ones node would appear below givennumber node .

After the expansion the context free grammar engine attempts to set the values of the various properties beginning with the leaf nodes and working upward. If the user said one hundred eighty the first leaf node that would be addressed is the ones property node found within the rule. To set the value for this property the context free grammar engine determines what number the user said before saying the word hundreds . The ones property is then set equal to the digit that represents that number through the VAL attributes found in the tags between tags and of . For example if the user said one hundred eighty the ones property would be set to 1 .

Next the context free grammar engine sets the value for the hundreds property. As noted above a property that is named in a rule reference through the PROPNAME attribute is set equal to the output of the rule. If the rule does not have an interpreter the output of the rule is the words recognized by the speech recognition engine. However if the rule has an interpreter the output of the rules is the output of the interpreter.

Thus because the hundreds property is named in a rule reference to the rule determining the value of the hundreds property involves invoking the interpreter that has been associated with the rule. Under the example above the interpreter for the rule receives the value assigned to the ones property and returns this value as its output. Thus the hundreds property is set equal to the value of the ones property. In the specific example where the user says one hundred eighty the hundreds property is set to 1 .

The context free grammar engine then continues to attempt to set values for the properties in the tree. For the example where the user says one hundred eighty this involves setting the tens property to 8 based on the VAL attribute found in the tag for eighty in the rule.

Moving up to the next level of nodes in the semantic tree the context free grammar engine first sets the value for the over property based on whether the user said more or less . As shown by tags and if the user says more the over value is set to 1 and if the user says less the over value is set to 0 . In the present example the user has said more so the over property is set to 1 as shown in .

To resolve the givennumber property the context free grammar engine invokes the interpreter associated with the rule because the givennumber property name is found in a rule reference to the rule. This interpreter receives all of the property names and their values found within container . Note that none of the property names or values within container are available outside of the container. Using these property names and values the number interpreter constructs a three digit number representing the number spoken by the user. In particular this interpreter identifies which properties have not had their values set indicated by a null value for the property changes each null value to a 0 and then calculates a number using number hundreds 100 tens 10 ones tensandones EQ. 1 The interpreter for the number rule also generates a property identified as half given number by dividing the number calculated in Equation 1 by two. Further the interpreter determines whether this is a valid value by comparing the number to a set of valid values stored in a registry or file. If it is a valid value the interpreter sets a valid value property to true otherwise the valid value property is set to false.

The number interpreter returns the number as its output and this number is set as the value of the givennumber property. In addition the number interpreter returns a list of additional property value pairs that it has determined. Such additional property value pairs can be returned to the application or used by rules higher in the hierarchy. Thus using the example of the givennumber property is set to a value of 180 in . Furthermore the tree is expanded to include children nodes of node that each designate a property provided by the number interpreter. In particular node includes the half given number property and value and node includes the valid value property and value. The structure of is the final semantic structure for the rule and is returned to the application.

Although the present invention has been described with reference to particular embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

