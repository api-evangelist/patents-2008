---

title: System and methods for side-channel attack prevention
abstract: A side channel attack utilizes information gained from the physical implementation of a cryptosystem. Software and hardware-based systems and methods for preventing side channel attacks are presented. Cryptographic hardware may introduce dummy operations to compensate for conditional math operations in certain functions such as modular exponentiation. Cryptographic hardware may also introduce random stalls of the data path to introduce alterations in the power profile for the operation. A cryptographic function may be mapped to a micro code sequence having a plurality of instructions. Firmware in the cryptosystem may alter the micro code sequence by altering the order of instructions, add dummy operations in the micro code sequence, break the micro code sequence into multiple sub micro code sequences and/or change the register location for source and destination operands used in the sequence. These alterations are designed to randomly change the timing and power profile of the requested function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08781111&OS=08781111&RS=08781111
owner: Broadcom Corporation
number: 08781111
owner_city: Irvine
owner_country: US
publication_date: 20080331
---
This application claims benefit of U.S. Provisional Application No. 60 929 597 entitled Methods and Systems for Hardware Based Side Channel Attack Prevention file Jul. 5 2007 which is incorporated by reference herein in its entirety.

The present invention relates generally to information security and specifically to cryptographic systems.

Many applications and devices rely on embedded cryptosystems to provide security for an application and its associated data. These cryptosystems are often targets of individuals attempting to gain access to the applications or devices themselves or attempting to gather information being used by the application e.g. credit card numbers cryptographic keys etc. . Early attacks on cryptosystems focused on the weaknesses of cryptographic algorithms. For example in plaintext attacks attackers feed known plaintext into a cryptosystem and analyze the generated ciphertext to gather information about the cryptographic algorithm being used.

As the industry developed countermeasures against these algorithm attacks a different style of attacks emerged that focused on the physical implementation of the cryptosystem. Referred to as side channel attacks these attacks attempt to derive sensitive information e.g. cryptographic key by monitoring physical characteristics of the cryptosystem such as timing information or power consumption by the system.

A timing attack measures the amount of time it takes for a cryptographic system to perform certain operations. These measurements may be analyzed to derive information about the secret keys used in the operations. For example Diffie Hellman and RSA operations consist of computing R ymod n where n is publicly available and y can be obtained or even provided by the attacker. The goal of a timing attack is to determine x or information that can lead to determining x the secret key. Because the secret key remains constant the attack varies the input y and monitors how long the cryptosystem takes to respond to y.

Power attacks monitor the power consumption e.g. current draw of the system while performing cryptographic operations. The amount of power consumed by a cryptosystem varies depending on the operations being performed. Additionally an operation or sequence of operations may have a characteristic current or power profile. For example power analysis may be used identify multiplication and squaring operations used in RSA and permutations and shifts used in DES each of which have a known power signature. Thus even a simple power attack can reveal the sequence of instructions being executed. Systems in which the execution path depends on the data being processed are particularly vulnerable to these types of attacks.

Differential power analysis DPA attacks are much more sophisticated and harder to prevent. These attacks combine the power measurements of basic power analysis attacks with statistical analysis to obtain information about secret keys being used in operations. In a DPA attack a large number of test vectors e.g. thousands of vectors may be run through the cryptosystem. A statistical tool is then used to correlate potential values with the collected power consumption measurements. Algorithms utilizing modular exponentiation operations are particularly vulnerable to DPA attacks.

What is therefore needed are systems and methods for preventing these sophistical forms of side channel attacks.

The present invention will now be described with reference to the accompanying drawings. In the drawings like reference numbers can indicate identical or functionally similar elements. Additionally the left most digit s of a reference number may identify the drawing in which the reference number first appears.

In PKA engine the public key cryptographic operations are broken down into multiple layers. The higher layer non computation intensive operations are implemented in firmware. The lower layer computation intensive operations are implemented in hardware. Additionally a portion of the firmware is configured to prepare a micro code instruction sequence to be carried out by the hardware. In an embodiment this portion of the firmware is dedicated to the function of generating the required micro code instruction sequences.

PKA engine includes a microprocessor coupled to PKA hardware module via a connection . In an embodiment connection is a bus. Firmware runs on target microprocessor . PKA engine also includes a platform independent firmware library . Platform independent firmware library may be targeted to a generic microprocessor or microcontroller for handling top level sequencing.

In general firmware decomposes a cryptographic function e.g. RSA into a sequence of operations. Firmware is configured to schedule the performance of the sequence of operations by PKA hardware module by software or by a combination of both hardware and software. For example firmware may decompose RSA encryption into a series of exponentiation operations followed by a modular multiplications and modular additions. By using micro code sequences generated in firmware to direct hardware operations sophisticated counters to side channel attacks can be implemented.

Firmware may include a side channel protection module . Side channel protection module is configured to introduce randomness into the micro code sequence generated by the firmware. As described above firmware is configured to develop a micro code sequence for a requested cryptographic operation. The micro code sequence determines the nature of the computation to be performed as well as an order of the computational steps to be carried out by the hardware. Side channel protection module may introduce randomness into the micro code sequence by a variety of techniques. For example side channel protection module may re order instructions in a random sequence may add dummy operations to a sequence in a random manner may break a sequence into multiple mini sequences to change the communication pattern between the hardware and software and or may change register locations of source operands and or target operands. The use of one or more of these techniques makes the prediction of hardware behavior extremely difficult.

In an embodiment data transfers between microprocessor or host processor and PKA module are handled through a memory mapped input output IO and possibly a DMA controller. In an alternate embodiment the PKA hardware module interfaces with the coprocessor bus of a specific microprocessor. In this embodiment data transfer between the firmware and hardware is more efficient than memory mapped IO embodiment. However this embodiment makes the firmware and hardware platform dependent and limits the ability of connecting the hardware to a DMA or another hardware module.

PKA hardware module provides a hardware core that supports basic computationally intensive operations. PKA hardware module is described in further detail in below. Wrapper provides an interface for the PKA hardware module to bridge into different architectures. Wrapper may support multiple IO interfaces e.g. a register access interface and or a streaming interface . In an embodiment microprocessor and PKA hardware module are on the same chip. In alternative embodiments microprocessor is on a separate chip from PKA module .

PKA hardware module includes a hardware based side channel protection module . Hardware based side channel protection module is configured to perform hardware based techniques for preventing side channel attacks. For example hardware based side channel protection module is configured to convert unconditional operations to conditional operations and or to introduce random stalls during operation of the hardware. These hardware operations are described in further detail in Section 2.

Application is an application that requires a cryptographic operation such as a public key cryptography function. A public key cryptographic function is typically deconstructed into a specific public key operation such as elliptical curve Diffie Hellman and RSA. These operations are handled by firmware .

High level functions are top level application programming interface API compiled to implement the high level public key operations such as Diffie Hellman DSA RSA Elliptical Curve Diffie Hellman ECDH or Elliptical Curve DSA ECDSA . These high level functions are further decomposed by other components of the firmware to carry out the necessary operations. For example Diffie Hellman DSA and RSA may be completely mapped to hardware and ECDH and ECDSA are partially mapped to hardware. Therefore DH DSA and RSA can be represented by single micro code sequences that are prepared and sent to hardware in one operation. Whereas ECDH and ECDSA are represented by multiple micro code sequences that are sent to hardware in a software loop.

Hardware primitives are routines that perform the hardware calls to implement the primitive functions. The hardware primitive is configured to decompose a higher level function to specific operation and to drive PKA hardware module to carry out the decomposed operations. The hardware primitives are firmware code that generate the microcode sequences sent to hardware module for computation.

Firmware primitives are performance optimized firmware routines intended for software implementation or for performance comparison. These routines may be coded with platform dependent assembly language to handle CARRY propagation or SIMD which are hard to deal with using high level programming languages like C.

Model primitives are optional. When present model primitives provide a mechanism to model math operations using off the shelf proven libraries such as GMP and OpenSSL Crypto libraries. When present model primitives allow for rapid prototyping and modeling.

Supporting functions performs low level functions such as memory management functions or error reporting functions. The code at this level does not have knowledge of math functions firmware is trying to implement.

In PKA hardware module each command represents a microcode sequence that allows multiple primitive operations to be mixed. The length of the command is limited by the internal memory size of the PKA module and the size of the operands embedded in the command sequence.

The PKA microcodes can be divided into two general categories data transfer microcodes and data processing microcodes. A data transfer microcode transfers data from a host processor to the LIRs or reads the value of a LIR back to the host processor. Example data transfer opcodes include move to opcodes e.g. MTLIR MTLIRI that move data to a LIR move from opcodes e.g MFLIR MFLIRI that move data from a LIR a clear opcode e.g. CLIR that clears a LIR and a SLIR that sets a LIR value to a small immediate value. The data transfer opcodes may be represented by a single 32 bit instruction followed by an optional immediate operand.

A data processing microcode performs data processing using the internal registers. In an embodiment data processing microcodes are two 32 bit instructions that can carry up to five operands per instruction. Typically the data processing opcodes do not have associated immediate operands in the microcode sequence.

An opcode is specified in the most significant octet of an instruction. The most significant bit MSB of the opcode indicates whether additional opcodes remain in the command sequence. For example the MSB is set to indicate that the opcode is the last opcode of the command sequence. Module uses this bit to perform housekeeping tasks such as de allocating LIRs or clearing memory. The remaining seven bits of the most significant octet is encoded with the opcode.

The instruction also includes a destination operand. In an embodiment the first operand following the opcode is the destination operand. The destination operand may be a 12 bit operand. For data transfer opcodes the last operand is an immediate operand that contains the size of the data operand embedded or the size of the operation. In an embodiment PKA module may track the size of data stored in LIR for performance optimization. The size of data in the last operand is specified in a number of octets. For data processing opcodes the next four operands are source operands. In an embodiment the first three operands are 12 bit operands and the last operand is an 8 bit operand.

PKA module includes one or more Input Output IO interfaces . A host processor not shown communicates a command sequence to PKA module via an IO interface . For example microprocessor may communicate a prepared microcode sequence to PKA module . If the PKA module includes multiple IO interfaces the host processor communicates the command sequence via one of the IO interfaces. Multiple IO interfaces are typically not used concurrently.

PKA module may include a register access interface . Register access interface is coupled to a register block . Register block includes a set of registers from which a host processor can read or write. Register access interface may write a sequence of operations to perform into the opcode FIFO queue . The register access interface may also initialize data in large integer register LIR memory .

A host processor may request a command to be sent through register access interface . In an embodiment the host processor may write a field e.g. PKA LOCK to an access control register not shown to request a resource lock and to monitor the locked status. The PKA hardware grants the host access if the streaming interface is idle. The host then owns the PKA hardware unless the host explicitly releases the lock by clearing the locked status. If the host is the only entity accessing the PKA module the lock can be set once when the system in initiated e.g. at boot up . A host may send a command sequence to PKA module by writing the sequence to a DATA IN register in register block one command word at a time. When the host is transferring data to the PKA memory the target register must be free.

PKA module may also include a streaming interface . Streaming interface is used to stream a command into PKA module and stream out the result after the command has completed. Streaming interface is typically used with a DMA controller not shown .

Although depicts PKA module as having both a register access interface and a streaming interface a module may include only one of these IO interfaces.

Large Integer Register LIR memory is coupled to register block streaming interface and datapath . Although LIR is referred to as a register in an embodiment LIR is implemented with a memory. In an embodiment the internal memory of PKA is mapped to a special set of large integer registers LIRs that can be indexed in the microcode. This mapping allows the reuse of data that is already in the PKA memory and avoids unnecessary data loading and unloading. A microcode command such as described above may include a register operand. A host processor sources data to LIR and pulls data from LIR memory e.g. through register access interface using these register operands. In an embodiment the LIR registers used by cryptographic operations can be re ordered and re named. The re ordering and re naming of LIR registers complicates the analysis of local memory access patterns by attackers.

Opcode FIFO queue holds the sequence of opcodes received via one of the IO interfaces . Opcode FIFO queue may store all the opcodes except for certain immediate opcodes such as move to opcodes. In an embodiment opcode FIFO queue implemented with a dual ported memory.

Opcode parser is coupled to opcode FIFO queue register block and micro sequencer . Opcode parser is configured to control the flow of the opcode sequence from opcode FIFO queue . The opcode parser reads one opcode from opcode FIFO queue at a time. The opcode parser checks the incoming opcode stream for the immediate opcodes e.g. the move to opcodes and stores the immediate data in the command to LIR memory. As described above these immediate opcodes are not placed into the opcode queue . The opcode parser also controls the queuing of the remaining opcodes and schedules opcode dispatch to micro sequencer . That is the opcode parser interprets the requested operation and passes the operation to the micro sequencer . Upon completion of the opcode opcode parser retires the opcode from queue . The opcode parser also controls the return of data to the host.

Micro Sequencer is coupled to opcode parser and data path block . In an embodiment micro sequencer is a finite state machine that controls the execution of a single opcode. The micro sequencer controls operand fetch pipeline operation and result write back. The micro sequencer controls memory access of the data path to LIR memory and coordinates computational units within the data path . The micro sequencer generates a control signal to the data path .

Data path includes one or more math computational units. Data path may include a Booth encode module a 16 partial produce reduction tree a carry save adder CSA and a carry look ahead CLA adder . As would be appreciated by persons of skill in the art data path may include additional or alternative units as required by a specific application.

In addition to timing and power analysis attacks some side channel attacks focus on monitoring memory activity such as cache misses. As discussed above PKA hardware module includes local memory for storing operands and data. An attacker cannot observe the internal memory operations of the PKA hardware module because the PKA hardware module memory is isolated from the system memory. Furthermore as discussed above the LIR registers used by the operations may be re ordered and re named. These architectures and techniques add a further level of protection against side channel attacks which rely on the analysis of local memory access patterns.

PKA engine supports a multi level approach for the prevention of side channel attacks. The following section describes methods for prevention of timing and power analysis attacks.

Certain cryptographic computations such as modular exponentiation include conditional math operations. In many cryptographic implementations these conditional math operations are not performed. Thus the amount of time required to do a math operation is a function of both the input size and the input value. This timing dependency on the input value provides an attacker with critical information.

Modular exponentiation is susceptible to such timing attacks. Modular exponentiation is the predominant computation in public key algorithms. Modular exponentiation is typically done through iterations of modular multiplications based on the value of the exponent. A conventional approach for modulo exponentiation M mod n is to perform a binary scan of the exponent and raise the power of the base repeatedly accumulatively multiplying the number when the corresponding exponent bit is a 1. Thus when the current bit in the exponent is 1 a modular multiplication is performed. If the current bit in the exponent is 0 a modular multiplication is not required. An attacker can therefore derive the number of ones in the exponent by monitoring how long a modular exponentiation lasts and also by how much power is consumed by the cryptosystem during the operation.

In step a request for a cryptographic function having conditional math operations is received. For example the PKA engine may receive a request requiring modular exponentiation.

In step a determination is made whether unconditional operation processing is enabled. In an embodiment unconditional operation processing may be enabled or disabled on a system level an application level or on an operation by operation basis. For example depending on the application a user may opt to have increased system performance at the risk of vulnerability to timing side channel attacks. In this situation the user would not enable unconditional operation processing for the application. If unconditional operation processing is enabled operation proceeds to step . If unconditional operation processing is not enabled operation proceeds to step . When unconditional operation processing is enabled the computation e.g. modular exponentiation may take approximately 33 longer.

In step the value of the current bit in the input is determined. If the input bit value is 0 operation proceeds to step . If the input bit value is 1 operation proceeds to step .

In step an unconditional operation or dummy operation is performed. For example in modular exponentiation the modular multiplication is performed. In alternate embodiments a dummy operation similar to a modular multiplication may be performed. Operation then proceeds to step .

In step a determination is made whether additional input values remain to be processed. If additional input values remain operation returns to step . If no additional input values remain operation proceeds to step .

In step any unnecessary results are discarded. For example the result write back to LIR memory may be conditioned on the value of the current bit in the exponent.

The method of flowchart increases the difficulty of timing attacks because the amount of time required to perform a math operation is only a function of the input size and is no longer tied to the value of the input. Power profiling is also made more difficult as the computation becomes regular.

Another level of protection against side channel attacks introduces random stalls into computational activities. In this protection technique random gaps are inserted between any two operations to randomize the timing delay or power profile. Alternatively a random stall can be introduced to force the data path to remain idle during an operation such as modular exponentiation or modular addition. By introducing a random delay an attacker cannot accurately predict when an operation starts or ends or derive any information from the power profile e.g. current draw . The random stall technique is opcode independent.

In the embodiment depicted in micro sequencer is coupled to linear feedback shift register . Linear feedback shift register generates a pseudo random or very close to random stall pattern. In an embodiment linear feedback shift register is free running in every clock cycle. Micro sequencer receives the randomized stall pattern from linear feedback shift register via input . Alternatively micro sequencer is coupled to the random number generator. The output of the random number generator can then be used as the stall pattern. The received stall pattern is then used by micro sequencer to stall data path .

Linear feedback shift register is also coupled to a random number generator . Random number generator provides an initial seed value to linear feedback shift register . A new seed value is generated each time linear feedback shift register is called. Random number generator may be a true hardware based non deterministic random number generator. In an embodiment random number generator utilizes free running oscillators to capture thermal noise as the source of randomness.

In step the stall frequency for the system is initialized. This step is optional. In an embodiment the stall frequency may be configurable by a user. The system may provide multiple stall frequencies up until a maximum value e.g. 50 for a user to select. As frequency of stall decreases the security of the system against side channel attacks is also increased. For example as a default the data path may be stalled 50 of the time. While maximizing security this stall frequency reduces the performance of the cryptosystem by a factor of 2. A user may not want to sacrifice that level of performance. Instead a user may opt to reduce the stall frequency to a lower level e.g. to 25 . A user may alternatively disable this feature.

In an embodiment the stall frequency may be set on an operation by operation basis. For example a higher level of security may be set for a Diffie Hellman operation e.g. 50 stall frequency whereas a lower level of security may be set for an RSA operation e.g. 10 stall frequency . The randomized stall feature may also be enabled or disabled on an operation by operation basis.

In step a determination is made whether the randomized stall processing is enabled. If randomized stall processing is not enabled operation proceeds to step . If randomized stall processing is enabled operation proceeds to step .

In step an initial seed value is generated. Note that step can occur any time prior to a high level API function being called. In an embodiment the firmware seeds linear feedback shift register from random number generator . The seed value may be XORed with the internal value of the linear feedback shift register .

In step a pseudo random stall pattern is generated by linear feedback shift register and provided to micro sequencer . In an embodiment the pseudo random stall pattern is generated from a 64 bit linear feedback shift register of the polynomial x 64 x 4 x 3 x 1 .

In step the data path is stalled according to the received pseudo random stall pattern. Random stalls may be implemented via idling the data path freezing the data path pipeline or by clock gating. The circuits in the data path typically run off the same clock. In an embodiment the data path is stalled by disabling the clock for the data path. When the clock is disabled the data path stops operating. In an alternate embodiment the micro sequencer can withhold input data form the data path.

The random stall process is also effective against DPA attacks. As discussed above in a DPA attack the attacker relies upon the correlation of a large number of samples to derive a secret key. The random nature of the stall process prevents an attacker from collecting correlating samples.

In step a request for a cryptographic operation is received by firmware . For example firmware may receive a request for a Diffie Hellman DSA RSA elliptical curve Diffie Hellman ECDH or elliptical curve DSA ECDSA function.

In step the requested function is mapped to hardware and or software operations. For example Diffie Hellman DSA and RSA are mapped completely to hardware and ECDH and ECDSA are partially mapped to hardware.

In step firmware prepares a micro code sequence for the hardware operations required to process the requested function.

In step a determination is made whether software based side channel protection is enabled. In an embodiment software based side channel protection may be enabled or disabled on a system level an application level or on an operation by operation basis. For example depending on the application a user may opt to have increased system performance at the risk of vulnerability to timing side channel attacks. In this situation the user would not enable unconditional operation processing for the application. If software based side channel protection processing is enabled operation proceeds to step . If software based side channel protection processing is not enabled operation proceeds to step .

In step side channel protection module alters the prepared micro code sequence. A variety of techniques may be used to alter the micro code sequence. For example the order of instruction in the micro code sequence may be changed. Side channel protection module may also add dummy operations into the sequence in a random or pseudo random manner. Side channel protection module may also break a micro code sequence into multiple mini sequences to change the communication pattern between the software and hardware. In a further example the LIR register locations used for the source and destination operands may be changed. Side channel protection module may use one or more of these techniques depending upon the level of security desired. These techniques alone or in combination make the prediction of hardware behavior extremely difficult for an attacker.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art that various changes in form and detail can be made therein without departing from the spirit and scope of the invention. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

