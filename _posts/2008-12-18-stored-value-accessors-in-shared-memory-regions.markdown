---

title: Stored value accessors in shared memory regions
abstract: Instruction sets in computing environments may execute within one of several domains, such as a natively executing domain, an interpretively executing domain, and a debugging executing domain. These domains may store values in a shared region of memory in different ways. It may be difficult to perform operations on such values, particularly if a domain that generated a particular value cannot be identified or no longer exist, which may obstruct shared accessing of values and evaluative tasks such as stack walks. Instead, accessors may be associated with a stored value that perform various operations (such as low-level assembly instructions like Load, Store, and Compare) according to the standards of the value-generating domain, and domains may be configured to operate on the value through the accessors. This configuration may promote consistent accessing of values without having to identify or consult the value-generating domain or reconfiguring the instruction sets.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08171232&OS=08171232&RS=08171232
owner: Microsoft Corporation
number: 08171232
owner_city: Redmond
owner_country: US
publication_date: 20081218
---
Within the field of computing many scenarios involve the execution of an instruction set such as a program in one of several domains that may differ in certain properties. For example a native execution domain may execute fully compiled instructions directly on the processor an interpretive executing domain may interpret partially compiled or uncompiled instructions just before execution on the processor a virtual execution domain may define a virtual machine in which the instructions are executed on a virtual processor and a debugging execution domain may attach various monitoring aspects to the executing instructions.

The code executed within such domains often involves the storing of values in a region of memory of the computer. The value may represent a primitive type such as an integer or a string a plurality of several values such as an array a composite of several values such as a structure or a class instance or a reference to a memory location such as a pointer. The memory allocated for storing these values may also take many forms such as a region of randomly accessible memory a stack a queue and a heap. Moreover a region may store values generated in several domains such as in a shared memory region that is accessible to multiple processes. The values may even be shared among code executed in several domains e.g. a value may be written to memory by instructions executing in a first domain and read from memory by instructions executing in a second domain.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Where various domains may store and use values in a shared memory region problems may arise where the domains are configured to use memory and access such values in different ways. As a first example a primitive type such as an integer may vary in length among various domains e.g. a natively executing domain may store a 64 bit integer generated by a 64 bit processor while an interpretively executing domain may store a 32 bit integer generated for compatibility with interpreted code and a 16 bit integer may be generated by a simulated virtual machine. A problem may arise where a first domain endeavors to read or utilize an integer written to a shared memory space by a second domain because the length used by each domain may differ and it may be difficult to identify the length based on a simple examination of the memory. As a second example even a similarly defined class instance may be stored in the region of the memory in different ways by different domains e.g. a debugging domain may store with the class instance some debugging information such as a symbol name or a list of references to the class instance that may not be stored by a non debugging domain. When a domain endeavors to access a class instance written to the shared memory region by another domain it may be difficult to determine the structure contents and order of values comprising the class instance stored in memory. These factors may result in inter domain compatibility and communication problems and incorrect or inaccurate data reads.

One technique for reducing these problems involves allowing each domain to specify how the values stored in the region of memory are to be accessed. This may be achieved by allowing each domain to associate a set of accessors with a stored value where each accessor performs a comparatively low level operation on the value such as a load or store an arithmetic or logical operation or comparison or a memory dereferencing. Each domain may therefore provide a set of accessors that are configured to perform the operation according to the characteristics of the value type such as the nature organization format and range of acceptable values as defined by the domain. For example if the domain generally defines integers according to a 16 bit little Endian format then the domain may upon storing an integer in the region of memory associate with the value a set of accessors that perform low level operations such as load store increment and compare to zero on the value as a 16 bit integer. When another domain executes an instruction that references the value is executed instead of directly accessing the value the domain may select and invoke the corresponding accessor that is associated with the value in the region of memory. This technique may promote the consistent accessing of the value in the region of memory even among domains that represent the value in different ways. Moreover this technique may promote the appropriate handling of a value in the region of memory even if the domain that generated the value cannot be identified or no longer exists.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

In the field of computing the execution of an instruction set such as a program may occur within a particular domain which may define many aspects of the execution. Respective domains may therefore execute the instruction set differently in furtherance of particular advantages such as performance safety and inspection capabilities. For example a first domain may be configured for interpretively executing a set of partially compiled or uncompiled instructions on the processor such as by examining respective instructions and choosing corresponding fully compiled instructions for execution. This first domain might be helpful e.g. for examining the code for errors or vulnerabilities such as bad pointer references and for configuring the code for the particular computing environment such as the available hardware of the computing environment however the on the fly interpreting may impact the performance of the executing code. A second domain may be configured for natively executing a set of fully compiled instructions on the processor which may provide high performance but may not be amenable to oversight and may be less able to adapt to the available hardware. A third domain may be configured for executing the instructions in a virtual machine having a set of emulated hardware components and a separate memory store which may permit execution of untrusted code without jeopardizing the local computing environment. A fourth domain may be configured for executing the instructions in a debugging context where the executing is states of particular data objects may be monitored the occurrence of particular events may be logged and effects may be simulated without perturbing the state of the debuggee.

Instruction sets often involve the storing of values in a region of memory. For example a process executing an instruction set within a particular domain may be provided a stack whereupon working values may be stored such as parameters passed to invoked functions and the return address of the instruction that invoked the function. Such instruction sets may also generate and store values involved in the logical processing of the instructions such as primitive types e.g. integers strings and Boolean values data structures e.g. one or more instances of a class and memory references e.g. pointers to primitive types data structures and functions. The stored values may also be organized in many ways such as an array or linked list a tree structure a hashtable a stack etc.

In some scenarios a region of memory may be accessible to and shared by several or many instruction sets each of which may store in the region of memory many values of many types and organized in many manners. Although such sharing may raise issues with regard to security and concurrency the sharing may be advantageous in many aspects such as economizing resources e.g. by reducing unnecessary and performance consuming isolation boundaries improving performance e.g. a performance improving memory cache may be devised to cache similar data items used by various instruction sets and interprocess communication e.g. by allowing several instruction sets to share access to one or more shared values. 

The instruction sets that share access to a region of memory may execute within different domains each of which may define different ways of generating and storing such values. illustrates an exemplary scenario wherein various instruction sets operating within various domains may share a memory region wherein an instruction set may store integers for access by other instruction sets. While the shared integers may be generated for a common purpose and may even be generated by logically equivalent instruction sets such as several executing instances of the same instruction set the different domains in which the instruction sets are executing may differently format and organize the integers stored in the shared memory region . For example a first instruction set and a second instruction set may execute within a native execution domain which upon executing an instruction in an instruction set that generates and stores an integer may store in the memory region a 64 bit integer. Thus a first instruction set may generate a first integer that the native execution domain stores as a 64 bit integer and a second instruction set may generate a second integer that the native execution domain stores as a 64 bit integer. However a third instruction set may execute in an interpreted execution domain which may fulfill a request by the third instruction set to store a third integer in the shared memory region according to a 32 bit format. A fourth instruction set may execute within a debugging execution domain which may be configured to store integers generated by executed instruction sets such as a fourth integer generated by the fourth instruction set as 32 bit values but may also store with the integers a set of debugging information e.g. symbol names owning processes and lists of references to the respective integer that may be useful in debugging code associated with the integers. The stored integers may also vary in other ways e.g. signed vs. unsigned signed one s complement values vs. signed two s complement values little Endian ordering vs. big Endian ordering and boxed vs. unboxed values. 

However the variance in storing integers according to the standards of various domains may cause problems. As a first example when an instruction set accesses an integer stored in the memory region it may not receive the type of integer that is anticipated by the instruction set. This discrepancy may occur even for integers shared between two instances of the same instruction set such as two threads running the same code if the instances are executing within different domains. An instruction set may not even depend on an integer that it has generated and stored in the shared memory region as retaining the same format during a subsequent access because another instruction set may have accessed the integer in the interim and modified its formatting e.g. while performing an increment operation. Moreover it might not be possible to extrapolate the formatting of the integer according to the domain that created a particular integer in the memory region because may be difficult to identify the value generating domain which in some cases may no longer exist. Thus a particular instruction set may be unable to determine the types of values stored in the memory region even if the integers were generated by a single codebase that has executed in several domains. If the generating domain may be identified a significant performance penalty may be incurred if accessing the value involves identifying the value generating domain identifying the particular manner in which the domain stores values and adjusting the accessing according to the standards of the domain however these additional tasks may impose a significant performance penalty in accessing the value. Such incapabilities may particularly impact tasks that are likely to operate on regions of memory shared among instruction sets executing in various domains such as stack traces that attempt to analyze the values stored on a stack shared among instruction sets executing in multiple domains.

One technique for reducing or avoiding these problems involves associating a set of accessors for performing various comparatively low level operations on the value. illustrates an exemplary scenario wherein the domains are configured upon storing a value such as an integer in the memory region to associate with the value a set of accessors where respective accessors are configured to perform a particular operation on the value such as a load a store a mathematical or logical comparison or operation or a memory dereferencing. When an instruction in an executing instruction set attempts to access a value in the memory region the domain within which the instruction set executes may again perform the accessing but instead of directly accessing the value stored in the memory region the domain may select and invoke the accessor corresponding to the type of instruction. For example the first integer stored in the memory region may be associated with among others not shown a store accessor a load accessor and a compare accessor that perform respectively a storing of a new integer value for the first integer a loading of the current value of the first integer and a comparing of the value of the first integer with a specified value such as another integer stored in the memory region a constant value such as zero etc. The accessors may correspond to particular low level operations e.g. accessors may be provided for respective opcodes in the compiled language such as Load Store and Compare assembly instructions and may perform the operations on the value stored in the memory region in a standardized manner e.g. the load accessor may be configured to reformat the integer in a particular manner requested by or identified with the domain that hosts the accessing instruction set. By configuring the memory region to associate accessors with respective stored values and by configuring the domains to access stored values through the accessors rather than directly accessing the memory region in a potentially inconsistent way this technique may promote the consistent treatment of the stored values may facilitate inspection of the memory region and values contained therein such as stack tracing and may improve the logical consistency and robustness of instruction sets independently of the nature of the requesting domain and the domain that last accessed the value. Moreover this independence may be achieved without having to reconfigure the instruction sets that generate or access the values e.g. the instruction sets may declaratively or imperatively specify operations such as low level assembly instructions like Load Store and Compare on the value as if it were directly accessible in the memory but the domains and runtime components may be configured to handle such requests through the accessors associated with the value according to the techniques discussed herein.

An exemplary scenario in which this problem and solution may arise involves the debugging of a particular instruction set the debuggee executing in a first domain by a set of debugging tools the debugger executing in a second domain. The debugger may wish to invoke a particular function defined in the debuggee to get the results but wish to avoid any side effects of the function. This invocation could normally cause the debuggee to alter the state of one or more values of the debuggee in a way that may compromise its logical flow or not even be physically possible if the debuggee is immuatable such as when inspecting a memory dump file post mortem . In order to avoid creating side effects in the debuggee the debugger may access the values of the debuggee in the region of memory through accessors that are configured to simulate an operation. For example a store accessor may store the new value in some auxiliary storage without modifying the debuggee. Then future read accessors will fetch the value from the auxiliary storage. This simulates a store operation to the debuggee without ever actually modifying the debuggee. In this manner the debugger executing in the second domain may freely access and even simulate altering the values of the debuggee executing in the first domain without compromising the state of the debuggee.

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary system of and the exemplary method of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments of these techniques relates to the types of values and the types of accessors that may apply various operations to such values . As a first example the values may comprise many types of data produced by the instruction sets such as primitive values e.g. integers floating point numbers characters and strings. The values may also comprise data structures that aggregate several primitive values and or other data structures such as instances of a class having many class members or a data container such as an array a linked list a tree a stack a queue a heap a hashtable etc. The values may also comprise a memory reference to a portion of memory containing another value such as a pointer referencing a class instance. As a second example the accessors associated with such values may be configured to apply many types of operations to the values . For example a particular value may be associated with one or more of a store accessor configured to store the value in the region of the memory a load accessor configured to load the value from the region of the memory a mathematical accessor configured to apply a mathematical operation e.g. an increment or addition operation to the value a Boolean accessor configured to apply a Boolean operation to the value e.g. a NOT operation configured to invert a bit series or to flip a Boolean value and a comparison accessor configured to apply a comparison operation to the value e.g. by comparing whether or not an integer is equal to zero or whether a stored Boolean value equals TRUE. It may be advantageous to choose accessors that correspond to particular instructions such as the set of assembly level instructions that access the value e.g. a load accessor corresponding to an assembly LD instruction an addition mathematical accessor corresponding to an assembly ADD instruction etc. This selection may facilitate the selection of an accessor corresponding to a value accessing operation in the instruction set by providing a direct mapping of value accessing assembly instructions to accessors.

In some scenarios a value stored in the region of memory may represent a reference to another value in memory which may be created by the same domain that created the reference value or even a different domain. In such scenarios embodiments of these techniques may be configured to associate with the reference value at least one accessor which may be associated with the second value and configured to operate on the first value. presents an exemplary scenario wherein a memory contains a first value associated with the symbol name a created by a first domain wherein the first value comprises a reference to a second value c generated by a second domain and stored at a particular memory address contained by the first value. As discussed herein respective values are associated with one or more accessors each of which may be configured to apply a particular type of operation to the value. For example the first value is associated with a memory referencing accessor configured to store the first value as a reference to the third value e.g. configured to store the memory address where the third value is stored and a memory dereferencing accessor configured to dereference the first value e.g. by retrieving from the memory a load accessor stored in the region and associated with the value and by invoking the load accessor to retrieve the third value. In this exemplary scenario an instruction set involves an operation b a that sets a third value to the second value referenced by the first value.

In order to fulfill the operations specified in the instruction set of an embodiment may be configured to select and invoke accessors for various values that perform the elements of the operation with respect to the referenced values. For example the embodiment may perform a first invoking of a dereferencing accessor associated with the first value which may translate the invoking by retrieving an appropriate accessor associated with the referenced value in this case the load accessor associated with the third value c . The embodiment may then perform a second invoking of the provided accessor to perform the operation specified in the instruction set in this case the load operation. The load accessor may therefore return the current value associated stored for the referenced third value in this case the integer . Finally the embodiment may perform a third retrieving and invoking of an appropriate accessor for the third value in this case a store accessor to complete the operation in this case writing the integer over the integer that was previously stored for the third value. In this manner the embodiment may complete the operation in the instruction set despite the generation of the values by different domains potentially having different properties and even involving an appropriate dereferencing.

In other scenarios the use of accessors may permit the application of an operation to a value in a different manner than may be achieved by directly accessing the value to perform the operation. For example a value may induce an effect when an operation is performed on it e.g. a request to perform a function on a value such as may be invoked in a debugging domain may actually and undesirably alter the value. An accessor may be configured to perform these operations in a different manner that avoids the undesired effects such as simulating the operation instead of actually performing the operation and providing the result. For example rather than invoking a computing environment function to access a value which may induce one or more effects such as altering the stored value a debugging domain may associate with a value an accessor that simulates the computing environment function without inducing the effects e.g. by temporarily storing the original value elsewhere in memory invoking the function that alters the value and then re storing the original value to replace the altered value. In this manner the debugging domain may perform debugging functions such as the evaluation of functions and values without jeopardizing the safety and consistency of the stored value and the instruction set operating thereupon. Those of ordinary skill in the art may devise many types of values and many operations that may be applied thereto by a set of accessors associated with the respective values in accordance with the techniques discussed herein.

A second aspect that may vary among embodiments of these techniques relates to the associating of accessors with a particular value. As a first example respective accessors may comprise a set of instructions for performing an operation such as a set of lambda expressions and when a value is stored in the region of the memory by a domain the instruction sets may be stored along with the value e.g. a stack slot holding an object may contain a set of instructions for performing each type of operation. Alternatively a set of function pointers such as delegated functions that perform various operations may be stored with the value in the region. As a second alternative a proxy accessor object may be stored with the value in the region that is configured to perform various operations on the value. A second variation of this second aspect involves the manner of associating the accessors with the value. For example the accessors may be stored with the value in the region of memory e.g. stored in the memory addresses following the value. Alternatively the accessors may be stored in a particular region of memory and the stored value may include a reference to the accessors. This configuration may be helpful for promoting reuse of accessors for similar value types e.g. all integers generated by a particular domain may be stored in the region of the memory with a pointer to a set of accessors that may be used to operate on any such integer. A third variation of this second aspect involves the manner in which accessors are selected by embodiments of these techniques for association with a particular value. For example the embodiment may upon receiving the request to store a particular value attempt to identify its type and select corresponding accessors from a set of available accessors e.g. a first set of accessors for 16 bit signed integers a second set of accessors for 32 bit unsigned integers etc. Alternatively a domain may provide or specify a set of accessors with the request to store the value and the embodiment may be configured to receive the accessors from the domain store the accessors in the region e.g. as instruction sets lambda expressions pointers proxy objects etc. and associate the accessors with the value. Those of ordinary skill in the art may devise many techniques for selecting and associating accessors for particular stored values while implementing the techniques discussed herein.

A third aspect that may vary among embodiments of these techniques relates to the manner of storing the value in the region of memory. As a first variation embodiments of these techniques may simply store the value specified in the request e.g. as a boxed or unboxed primitive value as an instance of an object etc. Alternatively embodiments may wrap the provided value in an interface such as a proxy object that regulates the application of operations to the value by retrieving and invoking accessors corresponding to the operations.

As a second variation the stored values may be formatted in many ways. As a first example the memory comprising the values may have certain properties that may result in a preferential storing in a particular format e.g. a 64 bit word size memory may promote the storing of 64 bit integers and 64 bit memory pointers over similar values of other sizes and fragmented memory may promote the storing of large arrays as linked lists instead of offset indexable blocks of memory. As a second example a target instruction set may declare and use values such as integers in one format while other instruction sets that access the value may wish to access it in another format such as may be defined e.g. by a protocol standard whereby the instruction sets share values. In these and other scenarios the stored value originally generated in a source format may be reformatted according to a target format e.g. reformatting 32 bit integer as a 64 bit integer reformatting a variable length null terminated ASCII string to a fixed length Unicode string or boxing or unboxing a primitive type. 

In order to implement this second variation the formatting of the value according to the target format may be performed in many ways. As a first example an accessor may be configured upon receiving a value to be stored to format the value according to the target format prior to storing the reformatted value. As a second example an accessor may be configured upon receiving a request to retrieve a value stored in memory to format the retrieved value according to the target format prior to providing the reformatted value in fulfillment of the request. This formatting may occur automatically e.g. the accessor may silently reformat the value based on a particular target format while fulfilling any request to load the value or upon request e.g. the accessor may allow a request to specify a target format according to which the value is reformatted. In some scenarios the formatting may encounter difficulties if an accessor is requested to format a 64 bit value as a 32 bit value it may attempt to fulfill the request by truncating or rounding the value or may notify the requester of the problem by returning an error or throwing an exception etc. Those of ordinary skill in the art may devise many types of accessors that format values according to target formats while implementing the techniques discussed herein.

As a third variation the value may be stored with various types of descriptors that facilitate the performing of these techniques. This example may be particularly useful for references e.g. a reference value may specify a memory address as an integer of a second value. It may be permissible to cast the memory address to an integer type which may be helpful for examining object identity etc. however it may be additionally helpful to store with the reference and with the integer some information as to the type of value stored at the memory address specified by the reference or integer. Embodiments of these techniques may then use such descriptors to verify the validity of such operations and such verifications may even be built into one or more accessors. For example a referencing accessor for a first value may reference a memory address containing a second value of a particular value type. It may be valid both according to the grammar of the instruction set and to the safety of the operating environment to permit a reassigning of the first value to a memory address containing a third value of the same value type e.g. an integer pointer may be reassigned from referencing a first integer at a memory address to referencing a second integer at a different memory address. However it may be logically invalid to even if grammatically valid to reassign the first value to a memory address containing a value of a different value type e.g. attempting to reassign an integer pointer to reference a non integer value. In order to reduce such problems by storing with the value e.g. upon receiving a request to store an integer pointer generate by a domain a descriptor indicating the type of value stored at the address of the reference. Subsequently upon receiving a request to operate on the value e.g. to assign a new the memory address to an integer pointer the descriptor can be used to verify the validity of the operation e.g. by verifying that the value stored at the specified memory address matches the value type referenced by the reference value. Those of ordinary skill in the art may devise many uses for such descriptors and for such other variable properties of associated accessors and stored values while implementing the techniques discussed herein.

A fourth aspect that may vary among embodiments of these techniques relates to the types of domains defined in the memory and with which these techniques may be utilized. As a first variation a domain may be configured to store values in a shared region of memory and to utilize accessors associated with the stored values to perform operations on the value. As a second variation a domain may comprise a local region of memory that is predominantly accessible only by instruction sets executing within the domain and in this local region of memory one or more local values may be stored. However the local domain may store in a shared region of memory a value referencing a local value e.g. a pointer to a locally stored value and may associate with the value in the shared region of memory one or more accessors configured to operate on the local value. For example the local domain may permit other domains to access the locally stored value only through accessors provided in a proxy object that is stored with the reference value in the shared region of memory. The accessors may therefore validate the requested operations on the locally stored value thereby extending access to the local value to other domains while preserving the security of the value through the validating accessors. This configuration may also be useful e.g. where a local domain includes an interpreter that interpretively executes instruction sets that may comprise one or more static values. For example references to the value may be generated and removed from the shared region of memory as the static variable transitions from in scope to out of scope but the local domain may preserve the static value as a local value throughout the lifetime of the static value. As a fourth variation these techniques may be utilized to manage the accessing of values in the region of memory by a set of domains that may vary in many aspects. As a first example the domains may differ in the manner of accessing the region of memory and of storing even similar values in the region e.g. a first domain may store integers in little Endian format while a second domain may store integers in big Endian format. As a second example the domains may differ in the executing of instruction sets such as a natively executing domain an interpretively executing domain a virtually executing domain and a debugging executing domain. As a third example the domains that access a particular value may execute the same instruction set in different contexts or may execute different instruction sets e.g. a first domain may execute a first instruction set written in a first language while a second domain may execute a second instruction set written in a second language. Even such language differences may be resolved by utilizing the techniques discussed herein to regulate the accessing of the values stored in the region e.g. a load accessor may be configured to load a value stored according to the standards of the generating domain and may either provide the value represented according to those standards or to another set of standards supported by the requesting domain. Those of ordinary skill in the art may devise many types of domains that may access such stored values and many embodiments of these techniques that support such varied domains while implementing the techniques discussed herein.

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to apply the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a system configured to store values generated by at least two domains in a region of a memory of a computer having a processor such as the exemplary system of . In another such embodiment the processor executable instructions may be configured to implement a method of storing values generated by at least two domains in a region of a memory such as the exemplary method of . Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

