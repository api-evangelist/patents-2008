---

title: Meta-scheduler with meta-contexts
abstract: A process in a computer system creates and uses a meta-scheduler with meta-contexts that execute on meta-virtual processors. The meta-scheduler includes a set of schedulers with scheduler-contexts that execute on virtual processors. The meta-scheduler schedules the scheduler-contexts on the meta-contexts and schedules the meta-contexts on the meta-virtual processors which execute on execution contexts associated with hardware threads.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367350&OS=09367350&RS=09367350
owner: Microsoft Technology Licensing, LLC
number: 09367350
owner_city: Redmond
owner_country: US
publication_date: 20081003
---
Processes executed in a computer system may include schedulers that schedule tasks of processes for execution in the computer system. A scheduler may access operating system OS execution contexts e.g. threads fibers or child processes in order to execute tasks on processing resources allocated to the scheduler.

A process may create any number of schedulers where each scheduler operates with any number of execution contexts. As the number of schedulers increases the overall number of execution contexts used by the schedulers may become difficult to manage. In addition an excess number of overall execution contexts may have an undesirable impact on the execution of the process by the computer system.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A process in a computer system creates and uses a meta scheduler with meta contexts that execute on meta virtual processors. The meta scheduler includes a set of schedulers with scheduler contexts that execute on virtual processors. The meta scheduler schedules the scheduler contexts on the meta contexts and schedules the meta contexts on the meta virtual processors which execute on execution contexts associated with hardware threads.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard directional terminology such as top bottom front back leading trailing etc. is used with reference to the orientation of the Figure s being described. Because components of embodiments can be positioned in a number of different orientations the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

In runtime environment represents a runtime mode of operation in a computer system such as a computer system shown in and described in additional detail below where the computer system is executing instructions. The computer system generates runtime environment from a runtime platform such as a runtime platform shown in and described in additional detail below.

Runtime environment includes an least one invoked process a resource management layer and a set of hardware threads M where M is an integer that is greater than or equal to one and denotes the Mth hardware thread M . Runtime environment allows tasks from process to be executed along with tasks from any other processes that co exist with process not shown using an operating system OS such as an OS shown in and described in additional detail below resource management layer and hardware threads M . Runtime environment operates in conjunction with the OS and or resource management layer to allow process to obtain processor and other resources of the computer system e.g. hardware threads M .

Runtime environment includes a meta scheduler function that generates meta scheduler with meta virtual processors and meta contexts and a scheduler function that generates schedulers for inclusion in meta scheduler . In one embodiment the meta scheduler and scheduler functions are implemented as application programming interfaces APIs . In other embodiments one or more of the functions may be implemented using other suitable programming constructs. When invoked the meta scheduler function creates meta scheduler to manage one or more schedulers in meta scheduler . The meta scheduler function also creates a set of meta virtual processors P where each meta virtual processor manages a corresponding set of virtual processors across the schedulers in meta scheduler . The meta scheduler function further creates a set of meta contexts P where each meta context executes a corresponding set of scheduler contexts across the schedulers in meta scheduler on a corresponding meta virtual processor . The scheduler function creates a scheduler in meta scheduler where each scheduler operates to schedule scheduler contexts of process for execution on virtual processors of the scheduler . The scheduler contexts execute on meta contexts which in turn execute on execution contexts on hardware threads . Runtime environment may exploit fine grained concurrency that application or library developers express in their programs e.g. process using accompanying tools that are aware of the facilities that the meta scheduler meta context and scheduler functions provide.

Process includes an allocation of processing and other resources that hosts execution contexts e.g. threads fibers or child processes . Process obtains access to the processing and other resources in the computer system e.g. hardware threads M from the OS and or resource management layer . Process causes tasks to be executed using the processing and other resources.

Process generates work in tasks of variable length where each task is associated with a scheduler context in scheduler . Each task includes a sequence of instructions that perform a unit of work when executed by the computer system. Each scheduler context includes program state and machine state information that is saved when the scheduler context blocks yields or is otherwise interrupted. Scheduler contexts may terminate or enter an idle or sleep state when there are no more tasks left to execute. For each task runtime environment and or process either assign the task to scheduler to be scheduled for execution or otherwise cause the task to be executed without using scheduler .

Process may be configured to operate in a computer system based on any suitable execution model such as a stack model or an interpreter model and may represent any suitable type of code such as an application a library function or an operating system service. Process has a program state and machine state associated with a set of allocated resources that include a defined memory address space. Process executes autonomously or substantially autonomously from any co existing processes in runtime environment . Accordingly process does not adversely alter the program state of co existing processes or the machine state of any resources allocated to co existing processes. Similarly co existing processes do not adversely alter the program state of process or the machine state of any resources allocated to process .

Resource management layer allocates processing resources to process by assigning one or more hardware threads to process . Resource management layer also includes the meta scheduler function in one embodiment and thus creates and manages meta scheduler meta virtual processors and meta contexts . Resource management layer causes meta contexts on corresponding meta virtual processors to be executed on underlying execution contexts obtained from the OS on hardware threads . Resource management layer exists separately from the OS in the embodiments of . In other embodiments resource management layer or some or all of the functions thereof may be included in the OS or runtime environment .

Hardware threads reside in execution cores of a set or one or more processor packages e.g. processor packages shown in and described in additional detail below of the computer system. Each hardware thread is configured to execute instructions independently or substantially independently from the other execution cores and includes a machine state. Hardware threads may be included in a single processor package or may be distributed across multiple processor packages. Each processor package may include hardware threads with the same or different architectures and or instruction sets. For example hardware threads may include any suitable combination of in order cores superscalar cores and general purpose graphical processing unit GPGPU cores. Each execution core in a processor package may include one or more hardware threads .

Process implicitly or explicitly causes meta scheduler meta virtual processors P meta contexts P and schedulers N to be created via the corresponding functions provided by runtime environment and or resource management layer . Meta scheduler meta virtual processors meta contexts and schedulers may be implicitly created when process uses APIs available in the computer system or programming language features. In response to the API or programming language features runtime environment creates meta scheduler meta virtual processors meta contexts and schedulers that inherit the policies of meta scheduler . To explicitly create meta scheduler meta virtual processors meta contexts and schedulers process may invoke the meta scheduler and scheduler functions provided by runtime environment and specify one or more policies for meta scheduler meta virtual processors meta contexts and schedulers .

Meta scheduler manages meta virtual processors and corresponding meta contexts to share meta virtual processors and meta contexts among all schedulers N in meta scheduler . Meta scheduler may share meta virtual processors and meta contexts among schedulers N cooperatively preemptively or with another suitable type of time slicing. As part of creating meta scheduler resource management layer allocates meta virtual processors and meta contexts to meta scheduler based on supply and demand and any policies of meta scheduler . In one embodiment meta scheduler creates each scheduler N . In other embodiments one or more of scheduler N that are external to meta scheduler may invoke a programming API or other suitable programming construct to attach to meta scheduler .

In one embodiment process adds each scheduler N to meta scheduler with the same set of scheduler policies. In another embodiment process adds each scheduler N to meta scheduler with a different set of scheduler policies. Each scheduler receives virtual processors P where each virtual processor forms an abstraction of underlying meta virtual processors and hardware threads . Each scheduler also receives information that maps virtual processors P of a scheduler to corresponding meta virtual processors P . As shown in virtual processors N from respective schedulers N map to meta virtual processor virtual processors N from respective schedulers N map to meta virtual processor and so on.

Meta scheduler allows meta virtual processors and meta contexts to be shared among scheduler contexts of schedulers N cooperatively preemptively or with another suitable time slicing. Each meta virtual processor forms an abstraction of a hardware thread and executes a corresponding meta context . Each meta context forms an abstraction of a scheduler context and executes the scheduler context on a corresponding meta virtual processor . Resource management layer multiplexes meta virtual processors onto hardware threads by mapping each meta virtual processor to a hardware thread . Resource management layer may map more than one meta virtual processor onto a particular hardware thread but maps only one hardware thread to each meta virtual processor . In other embodiments resource management layer manages processing resources in other suitable ways to cause meta contexts to be executed by hardware threads .

Meta scheduler schedules the scheduler contexts on meta contexts and schedules meta contexts on meta virtual processors which execute on execution contexts associated with hardware threads . Each meta context switches between execution of scheduler contexts on virtual processors on the corresponding meta virtual processor . Each meta context causes a single scheduler context to be executed at any given time but periodically performs context switches between execution of scheduler contexts to execute each of the set of scheduler contexts on virtual processors that correspond to the meta virtual processor of the meta context . Each meta context provides a quantum of execution upon dispatching a scheduler context of a scheduler . The quantum of execution may be expressed in time e.g. 50 ms by a number of tasks to be executed or by any other suitable metric. The quantum of execution may be the same or different for each dispatched scheduler context .

As shown in meta context switches between execution of scheduler contexts N from respective schedulers N meta context switches between execution of scheduler contexts N from respective schedulers N and so on. As shown by an arrow for example meta context dispatches scheduler context for a quantum of execution on meta virtual processor and once scheduler context detects that quantum has expired and yields back to meta context meta context dispatches scheduler context for a quantum of execution on meta virtual processor . Meta context continues the process of dispatching a next one of the set of scheduler contexts N each time a current one of the set of scheduler context N yields back to meta context .

Referring back to scheduler executes scheduler contexts on virtual processors which are in turn executed by meta contexts on meta virtual processors . The set of scheduler contexts in each scheduler includes a set of scheduler contexts with respective associated tasks that are being executed by virtual processors and at any point during the execution of process a set of zero or more runnable scheduler contexts and a set of zero or more blocked i.e. wait dependent scheduler contexts . Each scheduler context and includes state information that indicates whether a scheduler context or is executing runnable e.g. in response to becoming unblocked or added to a scheduler or blocked. Scheduler contexts that are executing have been attached to a virtual processor and are currently executing. Scheduler contexts that are runnable include an associated task and are ready to be executed by an available virtual processor . Scheduler contexts that are blocked also include an associated task and are waiting for data a message or an event that is being generated by another scheduler context or will be generated by another scheduler context or .

Each scheduler context executing on a virtual processor may generate in the course of its execution additional tasks which are organized in any suitable way e.g. added to work queues not shown in . Work may be created by using either application programming interfaces APIs provided by runtime environment or programming language features and corresponding tools in one embodiment. When processing resources are available in a scheduler tasks are assigned to scheduler contexts or that execute them to completion on virtual processors before picking up new tasks. A scheduler context executing on a virtual processor may also unblock other scheduler contexts by generating data a message or an event that will be used by other scheduler contexts .

Each task in each scheduler may be realized e.g. realized tasks and which indicates that a scheduler context or has been or will be attached to the task and the task is ready to execute. Realized tasks typically include light weight tasks and agents and may be associated with a scheduler context or just before executing or in advance of execution. A task that is not realized is termed unrealized. Unrealized tasks e.g. tasks may be created as child tasks generated by the execution of parent tasks and may be generated by parallel constructs e.g. parallel or parallel for . Each scheduler may be organized into a synchronized collection e.g. a stack and or a queue for logically independent tasks with scheduler contexts i.e. realized tasks along with a list of workstealing queues for dependent tasks i.e. unrealized tasks as illustrated in the embodiment of described below.

Prior to executing tasks scheduler creates scheduler contexts and for execution on meta contexts . Available virtual processors locate and execute scheduler contexts to begin executing tasks. Virtual processors become available again in response to a scheduler context completing blocking or otherwise being interrupted e.g. explicit yielding or forced preemption . When virtual processors become available the available virtual processor may switch to a runnable scheduler context to execute an associated task . The available virtual processor may also execute a next task or as a continuation on a current execution context if the previous task executed by the current execution context completed.

Each scheduler searches for a runnable execution context a realized task or an unrealized task to attach to the available virtual processor for execution in any suitable way. For example a scheduler may search for a runnable execution context to execute before searching for a realized task or an unrealized task to execute. Each scheduler continues attaching scheduler contexts to available virtual processors for execution until all tasks and scheduler contexts of each scheduler have been executed. In other embodiments runnable execution contexts and realized tasks may be merged into single concept from the perspective of schedulers .

The operation of meta scheduler meta virtual processors meta contexts and schedulers in executing process will now be described with reference to . are flow charts illustrating embodiments of methods for executing meta contexts in meta scheduler and are block diagrams illustrating embodiments of meta contexts and in meta scheduler during the execution of process .

In each meta context identifies a corresponding set of scheduler contexts across a set of schedulers N as indicated in a block . Each meta context in meta scheduler maintains a dispatch aggregate e.g. dispatch aggregate shown in . Each dispatch aggregate is a data structure that identifies the scheduler contexts attached to the virtual processors corresponding to the meta virtual processor of the meta context . As shown in the example of dispatch aggregate of meta context identifies scheduler contexts N attached to virtual processors N that correspond to meta virtual processor .

Scheduler adds virtual processors to one or more meta virtual processors when a scheduler is added to meta scheduler and removes virtual processors from one or more meta virtual processors when a scheduler is removed from meta scheduler . In addition schedulers may also remove virtual processors from one or more meta virtual processors when virtual processors enter an idle or sleep state and add virtual processors to one or more meta virtual processors when virtual processors return from an idle or sleep state.

For each meta virtual processor with an added virtual processor a corresponding meta context modifies a corresponding dispatch aggregate to identify a scheduler context attached to the virtual processor added to the meta virtual processor . For each meta virtual processor with a removed virtual processor a corresponding meta context modifies a corresponding dispatch aggregate to remove the identification of the scheduler context attached to the virtual processor removed from the meta virtual processor . When a virtual processor enters an idle or sleep state in a scheduler the scheduler notifies the corresponding meta virtual processor and meta context . Because the virtual processor is removed from the corresponding dispatch aggregate meta context does not provide the virtual processor with a quantum of execution until notified that the virtual processor is awake and has tasks to execute.

Meta contexts use dispatch aggregates to identify scheduler contexts to dispatch for execution. In one embodiment each meta context switches between scheduler contexts of schedulers in a corresponding dispatch aggregate in a round robin order. In other embodiments each meta context switches between scheduler contexts of schedulers in a corresponding dispatch aggregate in other suitable orders.

Each meta context dispatches a scheduler context of next scheduler as determined from a corresponding dispatch aggregate as indicated in a block . In the example of meta context may dispatch a scheduler context of next scheduler .

Each meta context provides a quantum of execution upon dispatching a scheduler context of a scheduler . Each scheduler that receives a quantum of execution causes a scheduler context to be executed on the corresponding virtual processor via the corresponding meta context and corresponding meta virtual processor for the allotted quantum.

Each scheduler detects when a quantum has expired and prevents the corresponding scheduler context from scheduling another task for execution. Each scheduler also notifies the corresponding meta context when a quantum has expired to return execution to meta context e.g. by the scheduler context function exiting and returning control to meta context . In one embodiment each scheduler may determine if a quantum has expired each time that a task completes blocks or is otherwise interrupted on a corresponding scheduler context . If so then scheduler returns control of execution to meta context . If not then scheduler allows scheduler context to schedule another task for execution. In other embodiments each scheduler and or scheduler context may determine if a quantum has expired in other suitable ways.

During each quantum allotted to a scheduler i.e. during execution of a scheduler context by the scheduler the meta context detects when a scheduler switches to a next scheduler context on the corresponding virtual processor as indicated in a block and when the scheduler yields as indicated in a block . Scheduler notifies the meta context when a switch to a next scheduler context is desired and when scheduler yields i.e. the quantum has expired .

If scheduler does not switch to a next scheduler context on the corresponding virtual processor then scheduler executes a realized task if found on the current scheduler context as indicated in a block or an unrealized task on the current scheduler context if a realized task is not found and the unrealized task is found as indicated in a block . If neither a realized task or an unrealized task is found then scheduler may pause before again searching for another task or scheduler context to execute as indicated in blocks and or yield as indicated in block .

When a scheduler yields without switching to a next scheduler context the meta context identifies a scheduler context of a next scheduler using the dispatch aggregate and dispatches the identified scheduler context as indicated in a block . In the example of meta context may identify a scheduler context of a next scheduler using the dispatch aggregate and dispatch scheduler context with a quantum to scheduler .

During execution of a scheduler context by the scheduler scheduler may desire to switch to a next scheduler context or on the virtual processor . The scheduler context on virtual processor may block complete or otherwise be interrupted for example to prompt scheduler to desire to make the context switch. If a scheduler notifies meta context that a switch to a next scheduler context or i.e. a scheduler context or that differs from the scheduler context dispatched by meta context is desired then meta context blocks as indicated in a block .

Any time that a meta context blocks the corresponding meta virtual processor switches to another meta context as illustrated in . In response to detecting that a meta context blocks runtime environment determines whether the next scheduler context or in the scheduler performing the context switch is already bound to a meta context as indicated in a block .

If the next scheduler context or is not bound to a meta context then runtime environment creates a new meta context for the next scheduler context as indicated in a block . Otherwise the meta context which is already bound to the next scheduler context will be used. In both cases runtime environment binds the previous scheduler context i.e. the scheduler context being switched out by the scheduler to the blocked meta context as indicated in a block . Runtime environment updates the dispatch aggregate of the next meta context as indicated in a block . To do so runtime environment moves all of the dispatch aggregate of the blocked meta context except the previous scheduler context into the dispatch aggregate of the next meta context . Runtime environment then adds the next scheduler context or and scheduler into the dispatch aggregate of the next meta context . Runtime environment associates the next meta context with the corresponding meta virtual processor as indicated in a block .

At some later point scheduler may decide to switch back to scheduler context on virtual processor . illustrates an example of the resumption of meta context and the blocking of meta context P 1 on meta virtual processor . In scheduler notifies meta context P 1 of a context switch to scheduler context . Runtime environment binds scheduler context to the blocked meta context P 1 and blocks meta context P 1 . Because scheduler context is already bound to meta context runtime environment updates dispatch aggregate by moving all of the dispatch aggregate P 1 except scheduler context into dispatch aggregate P 1 to join scheduler context and scheduler . Runtime environment re associates meta context with meta virtual processor .

In the above embodiments each meta context executes to process information received from schedulers between dispatches of scheduler contexts . Accordingly each meta context maintains its own state to prevent races between schedulers .

Although each scheduler is shown as including P virtual processors one or more of schedulers may include fewer than or greater than P virtual processors in other embodiments. As a result each meta virtual processor may have different numbers of corresponding virtual processors at various times. In addition each meta virtual processor may have different numbers of corresponding virtual processors at various times in response to virtual processors in schedulers entering into and resuming from idle and sleep states.

As described above each dispatch aggregate includes only those scheduler contexts presently attached to a virtual processor that corresponds to a meta virtual processor . Accordingly a dispatch aggregate may at various times identify a single scheduler context . When this occurs a meta context may provide an extended or infinite quantum of execution to the corresponding scheduler to allow the scheduler to execute the scheduler context for an extended period without cooperatively yielding to the meta context .

The above embodiments allow a desired number of meta contexts and corresponding execution contexts e.g. OS threads to service a large number of schedulers . By managing the number of meta contexts runtime environment may prevent an excessive number of execution contexts from being created in process and prevent the number of contexts from adversely impacting the execution of process .

In one embodiment process shown in organizes tasks into one or more schedule groups shown in and presents each schedule group to one of schedulers N as shown in . In other embodiments process organizes tasks into collections for each virtual processor of each scheduler or in other suitable ways.

Using the embodiment of the scheduler may first search for unblocked scheduler contexts in the runnables collection of each schedule group in the scheduler . The scheduler may then search for realized tasks in the realized task collection of all schedule groups in the scheduler before searching for unrealized tasks in the workstealing queues of the schedule groups .

In one embodiment a virtual processor that becomes available may attempt to locate a runnable scheduler context in the runnables collection in the schedule group from which the available virtual processor most recently obtained a runnable scheduler context i.e. the current schedule group . The available virtual processor may then attempt to locate a runnable scheduler context in the runnables collections in the remaining schedule groups of the scheduler in a round robin or other suitable order. If no runnable scheduler context is found then the available virtual processor may then attempt to locate an unrealized task in the workstealing queues of the current schedule group before searching the workstealing queues in the remaining schedule groups of the scheduler in a round robin or other suitable order.

In other embodiments schedule groups contain other suitable numbers types and or configurations of task collections.

Computer system includes one or more processor packages a memory system zero or more input output devices zero or more display devices zero or more peripheral devices and zero or more network devices . Processor packages memory system input output devices display devices peripheral devices and network devices communicate using a set of interconnections that includes any suitable type number and configuration of controllers buses interfaces and or other wired or wireless connections.

Computer system represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system include a server a personal computer a laptop computer a tablet computer a personal digital assistant PDA a mobile telephone and an audio video device. The components of computer system i.e. processor packages memory system input output devices display devices peripheral devices network devices and interconnections may be contained in a common housing not shown or in any suitable number of separate housings not shown .

Processor packages include hardware threads M . Each processor package may include hardware threads with the same or different architectures and or instruction sets. For example hardware threads may include any combination of in order execution cores superscalar execution cores and GPGPU execution cores. Each hardware thread in processor packages is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system BIOS or firmware not shown OS a runtime platform applications and resource management layer also shown in . Each hardware thread may execute the instructions in conjunction with or in response to information received from input output devices display devices peripheral devices and or network devices .

Computer system boots and executes OS . OS includes instructions executable by hardware threads to manage the components of computer system and provide a set of functions that allow applications to access and use the components. In one embodiment OS is the Windows operating system. In other embodiments OS is another operating system suitable for use with computer system .

Resource management layer includes instructions that are executable in conjunction with OS to allocate resources of computer system including hardware threads as described above with reference to . Resource management layer may be included in computer system as a library of functions available to one or more applications or as an integrated part of OS .

Runtime platform includes instructions that are executable in conjunction with OS and resource management layer to generate runtime environment and provide runtime functions to applications . These runtime functions include a meta scheduler function and a scheduler function as described in additional detail above with reference to . The runtime functions may be included in computer system as part of an application as a library of functions available to one or more applications or as an integrated part of OS and or resource management layer .

Each application includes instructions that are executable in conjunction with OS resource management layer and or runtime platform to cause desired operations to be performed by computer system . Each application represents one or more processes such as process as described above that may execute with meta scheduler as provided by runtime platform .

Memory system includes any suitable type number and configuration of volatile or non volatile storage devices configured to store instructions and data. Memory system may include any suitable cache hierarchy be configured as a shared or distributed memory system and may embody a locality scheme such as a non uniform memory access NUMA scheme. In addition memory system may be configured as a single instruction stream multiple different memory store SIMD system a multiple instruction stream multiple different memory store MIMD system or a computer cluster coupled through a messaging protocol such as concurrent read concurrent write CRCW concurrent read exclusive write CREW or parallel random access machine PRAM .

The storage devices of memory system represent computer readable storage media that store computer executable instructions including OS resource management layer runtime platform and applications . The instructions are executable by computer system to perform the functions and methods of OS resource management layer runtime platform and applications described herein. Examples of storage devices in memory system include hard disk drives random access memory RAM read only memory ROM flash memory drives and cards and magnetic and optical disks.

Memory system stores instructions and data received from processor packages input output devices display devices peripheral devices and network devices . Memory system provides stored instructions and data to processor packages input output devices display devices peripheral devices and network devices .

Input output devices include any suitable type number and configuration of input output devices configured to input instructions or data from a user to computer system and output instructions or data from computer system to the user. Examples of input output devices include a keyboard a mouse a touchpad a touchscreen buttons dials knobs and switches.

Display devices include any suitable type number and configuration of display devices configured to output textual and or graphical information to a user of computer system . Examples of display devices include a monitor a display screen and a projector.

Peripheral devices include any suitable type number and configuration of peripheral devices configured to operate with one or more other components in computer system to perform general or specific processing functions.

Network devices include any suitable type number and configuration of network devices configured to allow computer system to communicate across one or more networks not shown . Network devices may operate according to any suitable networking protocol and or configuration to allow information to be transmitted by computer system to a network or received by computer system from a network.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

