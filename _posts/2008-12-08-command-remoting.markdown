---

title: Command remoting
abstract: Various techniques for remoting graphics are described in the claims, drawings, and text forming a part of the present disclosure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08654134&OS=08654134&RS=08654134
owner: Microsoft Corporation
number: 08654134
owner_city: Redmond
owner_country: US
publication_date: 20081208
---
Terminal services provide techniques for allowing access to applications and data stored on a server. User input is send over a network to the server and audio and graphics are sent from the server to the client. Over the years different techniques have been developed to remote graphics such as command level remoting and bitmap level remoting.

Bitmap level remoting is generally considered to be the easier of the two techniques to implement. In bitmap remoting the graphics processing is performed on the terminal server and the final image e.g. an array of pixel values that forms a bitmap is compressed and sent over the network to the client. This technique requires a server that has enough computational power to render images for one or more clients.

Command level remoting on the other hand offloads the graphics rendering to the client. Primitives e.g. vertices that can be processed by a driver and executed by a graphics processor can be captured and sent to the client. This reduces the processing power required to remote graphics however more bandwidth is needed to send data representing 3D graphics such as those of a videogame or user interface require than bitmaps.

Those having skill in the art thus far have attempted to perform command level remoting by capturing commands that generate primitives e.g. vertices and constants output by application program interfaces. Generally as different types of applications were developed over the years e.g. new user interfaces that use 3D hardware videogames etc. the trend has been to capture the commands output by each application using custom remoting components optimized to capture specific API constructs output by specific APIs. This has lead to an architecture where the capture of data occurs at a multitude of places in the computer and this architecture requires an system that is becoming increasingly complex. Also as commands from more and more applications are remoted it has become difficult to synchronize the rendering operations across different remoting components. For example a GUI box may be generated using one technique and the text that populates icons may be drawn with another. If the commands are not synchronized the text may appear in the wrong portion of the GUI box or at the wrong time. Accordingly techniques for synchronizing commands are desirable.

An example embodiment of the present disclosure describes a method. In this example the method includes but is not limited to synchronizing by at least one kernel mode process vertices for graphics primitives the vertices stored in vertex buffers and sending the synchronized vertices for the graphics primitives to a terminal server client. In addition to the foregoing other aspects are described in the claims drawings and text forming a part of the present disclosure.

An example embodiment of the present disclosure describes a method. In this example the method includes but is not limited to receiving from a user space process information associated with the vertices for graphics primitives receiving from a graphics device interface information associated with bit block transfer commands synchronizing by at least one kernel mode process the vertices for the graphics primitives with the bit block transfer commands and sending the synchronized vertices for the graphics primitives and commands across a machine boundary. In addition to the foregoing other aspects are described in the claims drawings and text forming a part of the present disclosure.

An example embodiment of the present disclosure describes a method. In this example the method includes but is not limited to generating by a user mode driver vertices for primitives synchronizing the vertices for primitives and sending the synchronized vertices for primitives to a terminal server client. In addition to the foregoing other aspects are described in the claims drawings and text forming a part of the present disclosure.

It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and or programming for effecting the herein referenced aspects of the present disclosure the circuitry and or programming can be virtually any combination of hardware software and or firmware configured to effect the herein referenced aspects depending upon the design choices of the system designer.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail. Those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting.

Embodiments may execute on one or more computers. and the following discussion is intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that the computer system of can in some embodiments effectuate the computer and client of and . In these example embodiments the computer and client can include some or all of the components described in and circuitry configured to instantiate specific aspects of the present disclosure.

The term circuitry used through the disclosure can include hardware components such as hardware interrupt controllers hard drives network adaptors graphics processors hardware based video audio codecs and the firmware software used to operate the hardware for example. In the same or other embodiments circuitry can include microprocessors configured to perform function s by firmware or by set switches. In the same or other example embodiments circuitry can include one or more logical processors e.g. one or more cores of a multi core general processing unit. The logical processor s in this example can be configured by software instructions embodying logic operable to perform function s that are loaded from memory e.g. RAM ROM firmware and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be processed by the logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware software or a combination of hardware software the selection of hardware versus software to effectuate specific functions is a design choice. More specifically one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process. Thus the selection of a hardware implementation versus a software implementation is one of design choice and left to the implementer.

Referring now to an exemplary general purpose computing system is depicted. The general purpose computing system can include a conventional computer or the like including a general purpose processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM . The computer may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. In some example embodiments computer executable instructions embodying aspects of the present disclosure may be stored in ROM hard disk not shown RAM removable magnetic disk optical disk and or a cache of general purpose processing unit . The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the general purpose processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computer a server a router a network PC a peer device or other common network node and typically can include many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer can be connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer can typically include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external can be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the present disclosure are particularly well suited for computerized systems nothing in this document is intended to limit the disclosure to such embodiments.

Referring now to they depict high level overviews of computer systems including circuitry for virtualizing resources that can be used in aspects of the present disclosure. As shown by the figure server can include physical hardware devices such as storage device e.g. a hard drive a network interface controller NIC a graphics card at least one logical processor and random access memory RAM . One skilled in the art can appreciate that while one logical processor is illustrated in other embodiments computer may have multiple logical processors e.g. multiple execution cores and or multiple processors. In these embodiments multiple threads can be executed at the same time e.g. one or more threads per logical processor. Continuing with the description of depicted is a hypervisor that may also be referred to as a virtual machine monitor. The hypervisor in the depicted embodiment includes executable instructions for controlling and arbitrating access to the hardware of server . The hypervisor can generate execution environments called partitions such as partition l and partition N where N is an integer greater than 1 . In embodiments a partition can be considered the basic unit of isolation supported by the hypervisor that is each partition can be mapped to a set of hardware resources e.g. memory devices logical processor cycles etc. that is under control of the hypervisor . In an embodiment the hypervisor can be a stand alone software produce a part of an operating system embedded within firmware of the motherboard or a portion of the hypervisor can be effectuated by specialized integrated circuits.

Continuing with the description of the computer can include a root partition that may include a virtualization service provider VSP . In this example architecture the root partition can access the underlying hardware via device drivers . The VSP in this example can effectuate interfaces in partitions know as children and these children can be considered virtual machines. The virtualization service provider effectuates virtual machines and by instantiating different classes of devices as software and exposes interfaces to the devices within the partitions. Each virtual machine can include a virtual processor such as virtual processors and that guest operating systems and can manage and schedule threads to execute thereon. As is illustrated guest operating systems and can execute terminal servers TS and . Generally the virtual processors and are executable instructions and associated state information that provide a representation of a physical processor with a specific architecture. For example one virtual machine may have a virtual processor having characteristics of an Intel x86 processor whereas another virtual processor may have the characteristics of a Power PC processor. The virtual processors in this example can be mapped to logical cores of the computer system such that the instructions that effectuate the virtual processors will be backed by logical processors. Thus in these example embodiments multiple virtual processors can be simultaneously executing while for example another logical processor is executing hypervisor instructions.

Referring now to it illustrates an alternative architecture that can be used to practice embodiments of the present disclosure. depicts similar components to those of however in this example embodiment the hypervisor can include the virtualization service provider and device drivers and the root can contain configuration utilities . In this architecture the hypervisor can perform the same or similar functions as the hypervisor of . The hypervisor of can be a stand alone software produce a part of an operating system embedded within firmware of the motherboard or a portion of the hypervisor can be effectuated by specialized integrated circuits. In this implementation the hypervisor can be thought of as instructions that execute directly on the bare metal of the hardware. In this example the root partition may have instructions that can be used to configure the hypervisor however hardware access requests may be handled by the hypervisor instead of being passed to the root partition .

Referring now to it generally illustrates an example operating system including an terminal service session that can be used in embodiments of the present disclosure. One skilled in the art can appreciate that the example operating system can be effectuated by a computer such as computer of or could be a host operating system executing within root partition . In another implementation operating system could be a guest operating system or that is effectuated by a virtual machine such as VM or VM . In reference to the figure underlying hardware and is indicated in dashed lines which indicates that in an embodiment the hardware can be virtualized.

Terminal services can be provided to at least one client such as client while one client is depicted terminal services can be provided to more clients in embodiments. The example client can include a computer terminal that is effectuated by hardware configured to direct user input to the terminal server session and display user interface information generated by the session. In another embodiment client can be effectuated by a computer that includes similar elements as those of computer . In this embodiment client can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals e.g. a remote desktop client application that can be executed by one or more logical processors . One skilled in the art can appreciate that the circuitry configured to effectuate the operating system can also include circuitry configured to emulate a terminal.

Operating system can include instructions that can configure a processor to generate sessions. Briefly a session can generally include user mode processes such as videogames word processing programs web browsers user interfaces windows dialog boxes desktop etc. media players and the like. The processes can be effectuated by various subsystems e.g. executing processes that can provide a platform for execution of applications and interact with a kernel . One such subsystem is environment subsystem and a graphics kernel that will be explained in more detail below. A session can include a shell and a user interface rendered by a user interface process the subsystems that track mouse movement within the desktop the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program etc.

Generally a session can be generated on a user by user basis when for example the operating system receives a connection request over a network connection from a client such as client . Generally a connection request can first be handled by the transport stack e.g. a remote desktop protocol stack RDP . The transport stack code can configure the processor to listen for connection messages on a certain port and forward them to engine . When sessions are generated the transport logic can be executed and can instantiate remote desktop protocol stack instances for each session such as stack instance . Generally each remote desktop protocol stack instance can be configured to route output to an associated client and route client input to an environment subsystem for the appropriate session.

During the session creation process a session manager can be executed by a logical processor and the processor can initialize and manage each session by for example generating a session identifier for a session space adding the session identifier to a table assigning memory to the session space and generating system environment variables and instances of subsystem processes in memory assigned to the session space.

As shown by the figure in an embodiment processes can execute within user mode of the session and can use two distinct rendering techniques such as bitmaps generated by a graphics display interface GDI 3D graphics or a combination of both. The GDI is useful for generating D images such as text and windows. The GDI can be associated with a display driver that can generate bitmap images in response to receiving an array of bits from processes . For example an application may emit an array that can be processed by the display driver and used to render pixels representing color values.

Processes may additionally take advantage of 3D graphics and 2D graphics rendered by 3D hardware. Such graphics can be generated using a 3D graphics card made by one of a plurality of hardware vendors. Since different hardware vendors use different architectures and commands a graphics driver architecture can be made that abstracts the hardware so that developers can write a single application that works with any graphics card. In this example the application may access the features of the graphics processing unit of the client by sending API constructs to an application programming interface API such as Direct3D from Microsoft . The API in turn can generate primitives that can be sent to the client translated by a driver of the client into commands that can be executed by the GPU of the client and executed by the GPU of the client. Generally the API can include various commands for generating primitives e.g. the fundamental geometric shapes used in computer graphics as building blocks for other shapes represented as vertices and constants.

Vertices can be generated and stored in a plurality of vertex buffers e.g. pages of memory. When an application executes it can declare how it is going to use the buffer e.g. what type of data it is going to store in the buffer. An application such as a videogame may use a dynamic vertex buffer to store primitives for an avatar and a static buffer for storing data that will not change often such as building data. As vertices are written to the vertex buffers identification information for the primitives in the buffers can be sent to the graphics kernel where identifiers for the primitives for example can be stored in an execution queue. In addition the queue can include information about various bitmap images generated by the GDI . In this example the queue can be used to synchronize the rendering using 3D hardware and the displaying of bitmap images.

When rendering the primitives stored in various buffers the graphics kernel can send execute commands to the kernel mode driver . The kernel mode driver can receive the commands and send for example signals to the stack instance to send the specified commands to the client .

The following are a series of flowcharts depicting implementations of processes. For ease of understanding the flowcharts are organized such that the initial flowcharts present implementations via an overall big picture viewpoint and subsequent flowcharts provide further additions and or details.

Referring now to it depicts an operational procedure for practicing aspects of the present disclosure including the operations and . As shown by the figure operation begins the operational procedure and operation shows synchronizing by at least one kernel mode process vertices for graphics primitives the vertices stored in vertex buffers. For example at least one kernel mode process can be executed by at least one logical processor and the at least one logical processor can synchronize the execution of vertices by a graphics processing unit in order to render primitives. For example vertices for primitives can be stored in vertex buffers e.g. pages or memory and a kernel mode process such as for example a operating system scheduler an environment subsystem a graphics kernel or any other kernel mode subsystem or process can synchronize the execution of the primitives. In a specific example such as the example depicted by a graphics processing scheduler that can operate similarly to an operating system scheduler can schedule GPU operations. More specifically in this example the GPU scheduler can merge separate streams of vertices into the correct execution order such that the graphics processing unit of the client executes the commands in the correct order.

For example one or more threads of a process such as a videogame may map vertex buffers and issue draw commands. Identification information for the vertices e.g. information generated per buffer per vertex or per batch of vertices in a buffer can be sent to the GPU scheduler . The information can be stored in a table along with identification information associated with vertices from the same or other processes. The GPU scheduler can schedule the execution of the vertices based on the identification information such that the commands are correctly ordered and then the GPU scheduler can send execute commands to the kernel mode driver .

In another specific example a word processing program could execute and declare two buffers for example one for storing vertices for generating 3D menus and the other one storing commands for generating letters that will populate the menus. The application can map the buffers issue draw commands and the GPU scheduler can determine the order for executing the two buffers such that the menus are rendered along with the letters in a way that it would be pleasing to a user. For example other processes may issue draw commands at the same or a substantially similar time and if the vertices were not synchronized vertices from different threads of different processes could be rendered asynchronously on the client thereby making the final image seem chaotic or jumbled.

Continuing with the description of operation shows sending the synchronized vertices for the graphics primitives to a terminal server client. Continuing with the description of the kernel mode driver in this example can send a signal to the stack instance associated with the session directing the stack instance to send the vertices in a specific order and the stack instance can send the commands in the vertex buffers to client via network interface card .

Referring now to it illustrates an alternative embodiment of the operational procedure of including the additional operations indicated in dashed lines which is indicative of the fact that they are considered optional. Operation illustrates receiving by a user mode driver application program interface constructs for generating the graphics primitives from an application programming interface and generating by the user mode driver the vertices for the graphics primitives. For example and referring to an application program interface can receive API constructs from a process and can generate commands for generating graphics primitives. For example the API can include interfaces that can be exposed to processes such as a user interface of the operating system . The process can send constructs for primitives such as Point Lists Line Lists Line Strips Triangle Lists Triangle Strips or Triangle Fans to the API . Or put another way the process can send high level API commands to the API . The API can receive these commands generate vertices and pass them to a user mode driver . In an embodiment a user mode driver can translate them and store them in one or more vertex buffers. As one skilled in the art can appreciate the vertices generated by the API and translated by the user mode driver are substantially larger in terms of bytes than the API constructs because the API is located at a lower logical level in the computer system. That is the number of bytes representing a construct for generating a triangle at the API level may end up being a number of primitives that takes up 5 to 10 times as many bytes to store.

Continuing with the description of operation depicts generating by an application program interface the vertices for the graphics primitives. For example the application program interface can receive constructs from various executing processes and can generate vertices that can be stored in one or more vertex buffers e.g. one or more pages of memory in RAM and or memory of the graphics processor . In an embodiment the vertex data can be generated by for example the API in response to receiving API constructs from an application such as for example a videogame media player CAD program user interface etc. That is an application could pass the API one or more constructs and the API could generate thousands of primitives and store them in one or more vertex buffers.

Continuing with the description of operation shows receiving by the kernel mode process information associated with bitmaps rendered by a display driver and synchronizing by the kernel mode process the bitmaps with the vertices for the graphics primitives. For example and referring to a process may emit instructions to render bitmaps to a graphics device interface subsystem . The graphics device interface subsystem can render the bitmaps and these bitmaps can be synchronized with vertices for the primitives. For example there are situations where processes such as user interfaces and or applications may emit bitmaps and use 3D API s to generate 3D graphics. That is certain applications may use the API generate bitmaps or both depending on how the applications were developed. Others for example may have a proprietary command stream such that they may only emit a bitmap. The terminal server in this instance would not have an opportunity to intercept API constructs or vertices. In these cases the operating system merely receives instructions to render the final image.

In these example instances the kernel mode process can synchronize vertices and bitmaps such that bitmaps and 3D graphics can be merged into a final stream of execution that is rendered correctly. For example the kernel mode process in this example can receive information that associates the vertices with the bitmap and the kernel mode process can determine to send the vertices and the bitmap in the same stream to the client . In this example the client can receive the merged stream execute the commands and render the bitmap along with the image generated by the primitives.

Continuing with the description of operation shows compressing the synchronized vertices for the graphics primitives. For example a bulk compressor can be used to compress the commands for the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor can be a user mode not shown or kernel mode component of the stack instance and can be configured to look for similar patterns within the stream of data that is being sent to the client . In this embodiment since the bulk compressor receives a stream of vertices instead of receiving multiple API constructs of different type from multiple applications the bulk compressor has a larger data set of vertices to sift through in order to compress. That is since the vertices for a plurality of processes are being remoted instead of diverse API calls there is a larger chance that the bulk compressor will be able to find similar patterns in a run.

In the same or other embodiments the commands and or bitmaps can be compressed using lossy compressors move to front encoders mesh compressors and the like. These techniques are described in U.S. patent application Ser. No. 12 330330 entitled Improved Command Remoting Techniques filed on Dec. 8 2008 the contents of which is fully incorporated by reference.

Referring now to it illustrates an alternative embodiment of the operational procedure of including the additional operation that shows receiving by the kernel mode process information associated with commands from the graphics device interface subsystem. For example the graphics device interface subsystem can generate commands in addition to rendering bitmaps for processes . For example and stated above the operating system may not have access to a stream of commands for generating primitives from a processes and instead the environment subsystem may merely receive requests to render the bitmaps. In this example instead of merely rendering bitmaps the GDI can additionally generate certain commands. By providing the GDI with the ability to generate commands the amount of data that has to be compressed and sent to the client can be reduced. For example some example commands that the GDI can generate can include but are not limited to a screen to screen blit e.g. a copy from one part of the screen to another a pattern blit e.g. a solid fill etc. In a specific example instead of repainting the entire screen when a user moves a window from one portion of the screen to another the GDI can generate a screen to screen blit command. The kernel mode process can receive information that identifies the screen to screen blit and can synchronize the command with other commands and or bitmaps and send the screen to screen blit command to the client via the stack instance .

Referring now to it illustrates an alternative embodiment of the operational procedure of including the additional operation that shows preconditioning the synchronized the vertices for the graphics primitives. For example in an embodiment of the present disclosure a preconditioner can be included. The preconditioner can be configured to parse the stream of commands for generating the graphics primitives and place them in a format that will allow the bulk compressor to more easily find patterns and compress the data. Generally speaking a move to front coder delta preconditioning at the like can be used. These techniques are described in U.S. patent application Ser. No. 12 330330 entitled Improved Command Remoting Techniques filed on Dec. 8 2008.

Turning now to it depicts an operational procedure for practicing aspects of the present disclosure including the operations and . As shown by the figure operation begins the operational procedure and operation shows receiving from a user space process information associated with the vertices for graphics primitives. Referring to in an embodiment of the present disclosure information associated with vertices for primitives can be received from a user space process e.g. an API a user mode driver etc. Similar to that described above the vertices can be used by a graphics processing unit of the client to render one or more triangles or lines. For example in certain terminal service embodiments the user mode driver API can facilitate the translation from higher level API constructs to vertices. These vertices can then be stored in one or more vertex buffers of for example the user mode driver the transport stack the stack instance the graphics kernel or one or more pages of memory assigned to the session . One or more packets of information identifying the commands stored in the vertex buffers can be sent to a kernel mode process such as for example the GPU scheduler or the OS kernel etc.

Continuing with the description of operation depicts receiving from a graphics device interface information associated with bit block transfer commands. As shown by the operation commands associated with performing a bit block transfer can be received from for example a graphics display subsystem . In this example a bit block transfer command can include an operation in which several bitmaps are combined into one using a raster operation. For example the commands can be used to combine two bitmaps such as a source and a destination. The source and destination bitmaps can be combined according to a specified Raster OPeration ROP and the result is then written on to the destination bitmap. A basic ROP merely overwrites the destination rectangle with the source rectangle or uses an operation such as AND OR XOR and NOT. In specific examples the bit block transfer commands can include but are not limited to a screen to screen blit e.g. a copy from one part of the screen to another a pattern blit e.g. a solid fill etc.

Continuing with the description of operation shows synchronizing by at least one kernel mode process the vertices for the graphics primitives with the bit block transfer commands. For example and referring to operation illustrates that at least one kernel mode process e.g. the graphics kernel environment subsystem operating system kernel or a combination can synchronize the vertices stored in one or more vertex buffers with the bit block transfer commands. In this example the at least one kernel mode process can merge the vertices and bitmap s into a stream of execution.

As shown by operation of in an embodiment the operational procedure can include sending the synchronized vertices for the graphics primitives and commands across a machine boundary. For example one the commands and vertices have been synchronized and merged into a stream it can be sent across a machine boundary e.g. sent from the terminal server session to another operating system. In an embodiment the stream of commands and vertices can be comprised of vertices stored in various vertex buffers. In this example the kernel mode driver can execute the vertices bit block transfer commands in a specific order.

Referring now to it depicts an alternative embodiment of the operational procedure of including operations . Operation shows sending the synchronized vertices for the graphics primitives and commands to a virtual machine. For example and referring to and in an embodiment of the present disclosure the synchronized vertices and commands can be sent across a machine boundary to a virtual machine e.g. sent from virtual machine to virtual machine of for example. In this embodiment a partition bus can be used to transfer the commands across the machine boundary using techniques described in commonly assigned application Ser. No. 11 128 647 entitled Partition Bus the contents of which are hereby incorporated by reference in its entirety. For example in this embodiment the stream of commands can be sent to a virtual machine that includes virtual desktop techniques.

Continuing with the description of operation shows sending the synchronized vertices for the graphics primitives and commands to a terminal server client. Continuing with the description of the kernel mode driver in this example can send a signal to the stack instance associated with the session directing the stack instance to send the contents of the vertex buffers and the commands in a specific order. The stack instance can then send the commands in the vertex buffers to client via network interface card .

Referring now to operation of it depicts receiving information associated with a bitmap generated by a display driver and synchronizing the bitmap generated by the display driver with the vertices for the graphics primitives and the bit block transfer commands. For example and referring to in an embodiment of the present disclosure a process may emit instructions to render bitmaps to a graphics device interface subsystem . A display driver of the graphics device interface subsystem can render the bitmaps and these bitmaps can be interleaved with the vertices. In this example embodiment the at least one kernel mode process can synchronize vertices bitmaps and bit block transfer commands into an ordered command stream. The client can receive the merged stream execute the stream and display the final image.

Continuing with the description of operation shows receiving from a user space process application program interface constructs and generating by the user mode driver the vertices for the graphics primitives. For example a user mode process such as a user interface can make API calls. In this example a user mode driver can generate vertices for primitives. For example API can include one or a set of application program interfaces that can allow for a software developer to develop applications that can access the hardware of a computer system without knowing the exact hardware.

Referring to operation it shows preconditioning the vertices for the graphics primitives. For example in an embodiment of the present disclosure a preconditioner can be included. The preconditioner can be configured to parse the stream of commands for generating the graphics primitives and place them in a format that will allow the bulk compressor to more easily find patterns and compress the data. Generally speaking a move to front coder delta preconditioning at the like can be used.

Referring now to it illustrates an alternative embodiment of the operational procedure of including the operation that shows compressing the preconditioned vertices for the graphics primitives. For example a bulk compressor can be used to compress the commands for the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor can be a user mode not shown or kernel mode component of the stack instance and can be configured to look for similar patterns within the stream of data that is being sent to the client .

In the same or other embodiments the commands and or bitmaps can be compressed using lossy compressors move to front encoders mesh compressors and the like. These techniques are described in U.S. patent application Ser. No. 12 330330 entitled Improved Command Remoting Techniques filed on Dec. 8 2008 the contents of which is fully incorporated by reference.

Referring now to it illustrates an operational procedure for practicing aspects of the present disclosure including operations . As shown by the figure operation begins the operational procedure and operation shows generating by a user mode driver vertices for primitives. Referring to in an embodiment of the present disclosure a user mode driver can generate vertices that can be processed by a GPU and information associated with vertices can be received from the user mode driver . Similar to that described above vertices for primitives can be stored in vertex buffers e.g. pages or memory and a kernel mode process such as for example a operating system scheduler an environment subsystem a graphics kernel or any other kernel mode subsystem or process.

Continuing with the description of operation depicts synchronizing the vertices for primitives. For example and referring to at least one kernel mode process e.g. the graphics kernel environment subsystem operating system kernel or a combination can synchronize the device level commands. For example the commands can be put in a queue for execution. The vertices can then be synchronized e.g. an order of execution for the vertices can be determined. In a specific example such as the example depicted by a graphics processing scheduler that can operate similarly to an operating system scheduler can schedule GPU operations.

Referring now to operation it illustrates sending the synchronized vertices for primitives to a terminal server client. Continuing with the description of the kernel mode driver instead of sending the commands to the GPU of the computer the kernel mode driver can send execution commands to the stack instance . The stack instance can then send the primitives to a terminal server client for execution on the client s GPU.

Referring to it shows an alternative embodiment of the operational procedure including operations and . Operation shows receiving by the user mode driver application program interface constructs from a user mode process. For example and referring to a user mode driver can receive API calls from for example an executing process such as a videogame. The process can send commands for primitives such as Point Lists Line Lists Line Strips Triangle Lists Triangle Strips or Triangle Fans to the API . Or put another way the process can send high level API constructs to the API which in turn can generate one or more vertices.

Continuing with the description of operation shows synchronizing the vertices for primitives with a bitmap. For example and referring to a bitmaps can be rendered by a display driver of the graphics device interface subsystem and in this example embodiment the bitmap can be interleaved with the commands for generating the graphics primitives. In this example embodiment the at least one kernel mode process can merge the 3 D graphics commands and the bitmaps into an ordered command stream. For example the at least kernel mode process in this example can receive information that associates the commands for generating the primitives with the bitmap and the kernel mode process can determine to send the commands and the bitmap in the same stream to the client so that the client can receive the merged stream execute the commands and render the bitmap along with the image generated by the primitives.

Continuing with the description of operation illustrates synchronizing the vertices for primitives with bit block transfer commands. As shown by the operation commands associated with performing a bit block transfer can be received from for example a graphics display subsystem . In this example a bit block transfer command can include an operation in which several bitmaps are combined into one using a raster operation. For example the commands can be used to combine two bitmaps such as a source and a destination. In specific examples the bit block transfer commands can include but are not limited to a screen to screen blit e.g. a copy from one part of the screen to another a pattern blit e.g. a solid fill etc.

Referring again to operation shows preconditioning the synchronized vertices for primitives. For example in an embodiment of the present disclosure a preconditioner can be included. The preconditioner can be configured to parse the stream of commands for generating the graphics primitives and place them in a format that will allow the bulk compressor to more easily find patterns and compress the data. Generally speaking a move to front coder delta preconditioning at the like can be used.

Continuing with the description of operation shows compressing the synchronized vertices for primitives. For example the stream of vertices can be compressed using the bulk compressor . In an embodiment the bulk compressor can be a component of the stack instance and the bulk compressor can be configured to look for similar patterns within the stream of data that is being sent to the client .

The foregoing detailed description has set forth various embodiments of the systems and or processes via examples and or operational diagrams. Insofar as such block diagrams and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof.

While particular aspects of the present subject matter described herein have been shown and described it will be apparent to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from the subject matter described herein and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of the subject matter described herein.

