---

title: Managing the release of electronic content using a template without version logic
abstract: A facility for rendering a dynamic electronic document is described. The dynamic electronic document has both a current and a future edition. The current edition incorporates a current version of a content item, while the future edition incorporates a future version of the content item. The facility receives a request to return the dynamic electronic document. In response to the request, the facility retrieves a template for the electronic document that contains a single identifier that identifies a group of content item versions containing both the current version of the content item and the future version of the content item. The facility uses the single identifier contained in the template, together with an indication of whether the current edition of the dynamic electronic document or the future version is being requested by the received request, to incorporate the appropriate version of the content item in the rendered dynamic electronic document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268534&OS=09268534&RS=09268534
owner: Amazon Technologies, Inc.
number: 09268534
owner_city: Reno
owner_country: US
publication_date: 20080306
---
This application is a divisional of U.S. patent application Ser. No. 10 427 709 entitled MANAGING THE RELEASE OF ELECTRONIC CONTENT USING A TEMPLATE WITHOUT VERSION LOGIC filed on Apr. 20 2003 which application is hereby incorporated by reference in its entirety.

The present invention is directed to the field of generating electronic content and to managing changes to such content.

The Internet comprises a large number of computers and computer networks that are interconnected through communication channels. Because it facilitates electronic communications between vendors and purchasers the Internet is increasingly being used to conduct electronic commerce. Electronic commerce refers generally to commercial transactions that are at least partially conducted using the computer systems of the parties to the transactions. For example a purchaser can use a personal computer to connect via the Internet to a vendor s computer. The purchaser can then interact with the vendor s computer to conduct the transaction. Although many of the commercial transactions that are performed today could be performed via electronic commerce the acceptance and widespread use of electronic commerce depends in large part upon the ease of use of conducting such electronic commerce. If electronic commerce can be easily conducted more vendors and purchasers will choose to engage in electronic commerce.

One of the fundamental aspects of electronic commerce is the creation and maintenance of a useful web site through which vendors and buyers can carry out transactions. Typically an e commerce site allows vendors to display product information e.g. product descriptions price information product images and allows customers to browse for products and place and confirm orders. Initially creating this type of site can be complicated costly and time consuming. As with the display of physical products in a store it is important that product information on a web site be well organized and attractively displayed so customers can easily find what they are looking for. Likewise it is desirable to provide a system for obtaining purchase information from customers in a simple and efficient way. Once the site is initially created it is important to update the site as new products are offered for sale and old products are sold out or discontinued. Special sales or promotions may also call for changes to the site as may reorganizations of the site to further optimize its usability.

The version of a web site that is currently being presented to customers is termed the live version of that web site. When a merchant s designers commence to make changes that will update the merchant s web site it is desirable to continue to display the unchanged live version of the web site to customers until the designers changes are completed approved and otherwise ready for release. At that point the changed version of the web site becomes the new live version and as such is presented to customers. A group of changes that is applied together to a web site in this manner is termed a release. 

One way of continuing to present the live version of the web site while simultaneously making changes to the web site that will be reflected in a future version is to make a copy of all of the data that comprises the live web site including the scripted templates that represent each web page in the web site all of the other digital content that is incorporated in pages of the web site and various other data. The changes are then made to the copy. This approach has the advantage that the copy can be used to preview the changed version of the web site. In the case of large web sites however this approach can have a substantial impact on the data storage requirements for operating the web site.

In cases where the designers need to be able to simultaneously work on changes for multiple future releases of the web site additional disadvantages appear for this approach. First the need to have a separate full copy of the web site for each future release being worked on further increases data storage requirements. Further when using this approach a change must be applied to every release scheduled later than every release in which it is to be effective. For example if at a particular point in time five different future releases exist and a change is to be made to the second of these five the change must be applied not only to the second but also to the third fourth and fifth.

An alternative approach is make use of a differential rendering approach in which there is only a single copy of the web site but the pages of the web site can either be rendered in their live version or rendered in accordance with a future release. This may be accomplished by for each page of the web site that is changed introducing tests into the script that is executed to transform the template representing the page into the page. These tests determine whether the page is to be rendered in its live version for presentation to customers or in accordance with a future release for presentation to developers previewing that release. The script incorporates the content that is appropriate for the determined version based on the test results.

For example a developer that wanted to change a particular page that in the live version of the web site includes a picture of an orange leaf to instead include a picture of a snowflake in a future release would modify the script in the template for that page. In the script the developer would change an unconditional command to incorporate the orange leaf picture to a conditional structure that 1 determines the version of the page being rendered 2 if the version of the page being rendered is the live version incorporates the orange leaf picture and 3 if the version of the page being rendered is the future release version incorporates the snowflake picture. In order to make the future release of the web site live the scripts must again be modified to contain unconditional commands to incorporate the content as changed by the release e.g. to replace the above described conditional structure with an unconditional command to incorporate the snowflake picture.

This approach also has significant disadvantages. First each changed page must be revised in the manner described often manually. This requires substantial amounts of manual effort. Further this manual process makes it difficult to use automated tools to specify changes for a release. Also each time a page is changed in this manner it is possible for the changes to introduce error. Additionally introducing additional code paths by adding conditional structures makes the templates more complex to test. Furthermore where more than one future release exists the conditional structures become more complex and correspondingly more difficult to test.

In view of the foregoing those skilled in the art will appreciate that an improved mechanism for managing future releases would have significant utility.

In some cases it may be desirable to operate a single web site on behalf of multiple merchants. Such a multiple merchant web site can in some cases provide economies of scale as well as marketing synergies that cause a customer to make more purchases on the combined web site than that customer would have otherwise made on individual single merchant web sites.

Multiple merchant web sites can raise difficult security issues however. If developers for each merchant are granted authorization to change any page on the web site one merchant s developer can carelessly or maliciously change a page of another merchant. If on the other hand the ability to change the pages of all of the merchants is restricted to employees of an organization that is responsible for operating the web site as a whole an extra layer of delegation is imposed on the designers of each merchant who have to communicate their changes to employees of the organization and the organization incurs the extra cost of allocating designers to this task.

For these reasons those skilled in the art will appreciate that an improved mechanism for managing modification permissions in a multiple merchant web site would have significant utility.

A software facility for managing the release of electronic content such as contents of a web site the facility is provided. The facility may be used for example to mange the release of contents of an electronic commerce web site. In some embodiments the release of content constitutes modifying resources incorporated in pages of a web site such as images or browse nodes that define the order in which different groups of items may be browsed by replacing earlier instances or versions of the resources with new versions of the resources. For example a new image may be substituted for an existing image or a browse node could be changed to be the child of a different parent browse node. Each such change is assigned to a group of changes to be released simultaneously at a specified time. Such a group is called a release. 

In some embodiments a resource is incorporated in a particular page of a web site by including an instruction to retrieve the resource in a script. The script executes to transform a template representing the page into the actual page. The instruction contains an identifier called a resource identifier that refers to the resource and all of its versions. When the script is executed in response to a request to serve the page the resource retrieval instruction is passed to a resource versioning service together with the resource identifier. The resource versioning service determines the version of the web site for which the page is being rendered called the release to render. The release to render is typically either a live release that is currently being presented to customers or other consumers of the web site or a future release that is scheduled to be presented to customers at a future time. The resource versioning service typically makes this determination based on the identity and current preferences of the user requesting the page discerned either by receiving this information along with the resource identifier from the template s script or by accessing context information associated with the user and or the user s web browsing session. The resource versioning service uses the determined release to render together with the version of the release incorporated in the live release and changes earlier specified for the determined release to render and earlier scheduled releases to identify then retrieve or construct the appropriate version of the resource identified by the resource identifier. The resource versioning service returns this version of the requested resource to the template s script for inclusion in the web page that is generated from the template. In these embodiments it is possible to serve different versions of pages of the web site without ever modifying the contents of the template that represents the page and without including in the template s script any logic such as tests and multiple code paths for determining the proper version of the page to render.

In some embodiments one or more user interface tools are available for specifying that resources be modified in particular ways in particular releases. For example an image tool may be used to replace one image with another in a designated future release by in that release replacing the current version of an image resource with a new version of the image resource. Each time a tool is used to specify a change for a release the tool calls the resource versioning service which stores the specified change in connection with the designated release. Such tools are described in greater detail in U.S. patent application Ser. No. 10 335 222 whose contents are hereby incorporated by reference in their entirety.

In some embodiments the resource versioning service responds to a set of commands such as an application programming interface API for releasing a future release by substituting it for the current live release making it the new live release. In some embodiments these commands include commands for optimizing for the retrieval of the versions of resources associated with the new live release changing the future release to be the new live release reversing this change if attempts to make the change fail and discarding resource versions needed for the previous live release. These commands are typically issued by a release manager component in response either to user instructions or a predetermined schedule.

In some embodiments the facility provides different resource versioning services and or different user interface tools for different types of resources. For example an image tool may call an image resource versioning service to store changes to images specified for a release by a user which is called by scripts that need to retrieve versions of image resources while a separate browse tool may call a browse resource versioning service to store changes to browse nodes specified for a release by a user which is called by scripts that need to retrieve versions of browse node resources. Such specialization permits both tools and resource versioning services to be more fully tailored to specific types of resources. For tools this means that they can be more intuitively and efficiently used to specify changes to particular kinds of content while for resource versioning services this means that resource versions and changes thereto can be stored and manipulated more efficiently. The ability to use multiple resource versioning services helps to make extensible the set of different resources managed by the facility. Where multiple resource versioning services are used each typically implements the API described above.

In some embodiments the facility is used to manage changes to a web site containing content for a number of different publishers such as a number of different merchants. In some such embodiments in order to grant the permissions needed by each publisher to specify changes to their own content without being able to specify changes to or otherwise access content of other publishers the facility provides publisher access controls that enforce a publisher access model. The publisher access model typically classifies content data for the web site as being visible and modifiable to either zero or one publishers. For example a first piece of content data published by publisher A may be visible and modifiable to publisher A and its users a second piece of content data published by publisher B may be visible and modifiable to publisher B and its users and a third piece of content data relating to the web site as a whole but not to any individual publisher may be visible and modifiable to no publishers. In some cases part or all of the access model is defined in terms of a content data tree representing some or all of the content data stored for the web site. A subtree of the content data tree is specified for access by a particular publisher by associating that publisher s identity with the node of the content data tree that is the root of the subtree. Such subtrees are typically selected in such a way so that they do not intersect such as by having some or all of the subtrees have their root at nodes at the same depth in the content data tree. In some embodiments the publisher access model enforced by the facility s publisher access controls also controls the set of actions users associated with a particular publisher may take such as which kinds of modifications the publisher and its users can make to the content e.g. by restricting which of the facility s API functions a publisher and its users may invoke.

The web server computer systems typically each contain a web server program for receiving and responding to web browsing requests page templates each corresponding to a different web page and being used by the web server program to generate that web page in response to web browsing requests for that web page and a script engine program that executes scripts occurring on page templates that are being used to generate pages for response to web browsing requests. For example a script in a page template may instruct the script engine to retrieve a particular resource or other piece of content. Where a script instructs the script engine to retrieve a resource that may have different versions for different releases the script engine program typically calls a resource versioning service program to retrieve a version of the resource that is appropriate for the intended release.

In some embodiments there is a specialized resource versioning service program for each different type of resource. For instance image resource versioning service program responds to requests for versions of image resources while browse node resource versioning service program responds to requests for versions of browse node resources. In some embodiments each resource versioning service program executes on a different computer system connected to the web server computer systems by a network . For example the image resource versioning service program executes on an image resource versioning service computer system . Each resource versioning service computer system typically also contains specialized resource version data for the corresponding resource type. For example the image resource versioning service computer system contains image resource versioning data used by the image resource versioning service program to identify and generate the appropriate version of the requested resource. Also connected to network is a release manager computer system upon which executes a release manager program . The release manager program typically manages the process of creating and scheduling new releases and correspondingly maintains a release schedule . The release manager computer system typically also contains a list of resource versioning services such as image resource versioning service program and browse node resource versioning service program as well as the last known status of each such service. The release manager program is responsible for releasing a future release by substituting it for the current live release which typically involves calling the release manager API implemented by each of the release versioning service programs. In some embodiments the release manager program also may be used to poll the release versioning service programs for all the changes under their control that are scheduled for a particular release in order to generate a report of all the changes of all types included in a particular future release.

While various functionalities and data are shown in as residing on particular computer systems that are arranged in a particular way those skilled in the art will appreciate that such functionalities and data may be distributed in various other ways across one or more computer systems in different arrangements.

The image resource version change table is used by the resource versioning service to respond to resource version requests for future releases. The image resource version change table is made up of rows . . . each corresponding to a change to an image resource that has been specified for a particular future release. Each row is divided into the following columns a release identifier column identifying the release for which the change is specified a resource identifier column that identifies the resource for which the change is specified a change action column that indicates a type of change to be made to the resource and a change object column that contains information used to complete the change in this case the resource version identifier with which the existing resource version identifier for the resource is to be replaced.

When the image resource versioning service receives a resource retrieval request where the release to render is a future release the image resource versioning service begins at the last row of the image resource version change table for the release to render and searches upward for the first occurrence of the resource identifier of the requested resource. If the change action of that row renders moot any changes to the resource in earlier releases then the resource versioning service uses the information in the change object column of the row to identify the resource version to be retrieved and returned. For example completely replacing an earlier version of a resource with a new version obviates any other changes to that resource in earlier releases. Otherwise the resource versioning service program continues to search upward in the image resource version change table for additional rows containing the resource identifier in question.

For example where the resource versioning service receives a request for the resource having resource identifier 3764 for release to render 4 the facility begins in row the last row containing release identifier 4 and searches upward in the image resource version change table for the first occurrence of resource identifier 3764 which occurs on row . The release versioning service determines that the change action specified in row replace resource version obviates any earlier changes specified for this resource and uses the image resource version identifier 915362 appearing in the change object column of this row to retrieve the content constituting this image resource version. Had the requested resource identifier not been found in the upward search of the image resource version change table the resource versioning service would revert to the live image resource session table using the resource version identifier 864173 specified for the current live version and appearing in the resource version identifier column of row to retrieve the resource version content for the resource version being used in the current live release. Had the change action in row not obviated further searching in the image resource version change table the resource versioning service would have continued to search upward in that table selecting rows containing the same requesting resource identifier until either a change action was found that obviated further searching or the top of the table was reached. If a change action obviating further searching is found all the selected rows of the image resource version change table are applied together to generate the requested resource version. Otherwise all of the selected rows of the image resource version change table are applied to the resource version identified in the live image resource version table to construct the requested resource version.

While and other figures that follow show tables whose contents and organization are designed to make them more readily understood by a human reader those skilled in the art will appreciate that actual data structures used by the facility to store this information may differ from the tables shown and that they for example may be organized in a different manner may contain more or less information than shown may be compressed and or encrypted may be indexed or otherwise instrumented etc.

As discussed above each resource versioning service typically implements an API that permits it to be controlled by the release manager. The functions constituting this API are discussed in more detail here.

The release manager invokes a GetReleaseChanges function to retrieve from the resource versioning service an enumeration of all changes in the possession of the resource versioning service that are associated with a particular future release. The function takes as a parameter the release identifier for this release and returns the requested set of changes. In some embodiments this function can take as its parameter a range of release identifiers in which case the function returns the changes in the possession of the resource versioning service that are associated with any release identifier within the range.

The release manager invokes a BuildRelease function against each of the resource versioning services as the first step in transitioning from the current live release to a new live release. The function takes one or more parameters specifying a group of one or more future releases to build that is construct a more efficient to access representation of all of the resource versions used in the new live release. As one example when this function is invoked for the image resource versioning service it might construct a new copy of the live image resource version table by applying the changes specified for the selected releases in the image resource version change table. This function returns when the build process is completed.

The release manager invokes a FlipRelease function for each resource versioning service as the next step of transitioning to a new live release after all of the resource versioning services have completed their BuildRelease invocations. When this function is invoked the resource versioning service changes its state to use the new version of the efficient to access representation of the resource versions used by the new live release to be used when responding to requests for resources where the release to render is the live release. For example when this function is invoked for the image resource versioning service it would replace the original live image resource version table with the new image resource version table constructed during the BuildRelease invocation. The FlipRelease function is typically a fast operation that is largely synchronized across the site whereas the preceding Build Release function is a more time intensive operation.

The release manager invokes an UnflipRelease function for one or more resource versioning services where a problem has occurred such as a new release has not worked properly after being flipped by invoking the FlipRelease function. The function restores the state of the resource versioning service to resume using the older efficient to access representation of resource versions used in the current live release. The UnflipRelease thereby returns the resource versioning service to its previously operational state in order to allow the new build to be corrected.

The release manager invokes a CleanupRelease function for each of the resource versioning services as the next step of transitioning to a new live release once all of the resource versioning services have completed their FlipRelease invocations. When this function is invoked the resource versioning service archives or destroys the replaced efficient to access representation of the resource versions used in the current live release which is no longer needed.

The release manager invokes a GetReleaseStatus function for a particular resource versioning service in order to determine its current status. These statuses can include a BuildComplete status where a BuildRelease invocation has successfully completed a ReleaseFlipped status where a FlipRelease invocation has successfully completed a ReleaseUnflipped status where an UnflippedRelease invocation has successfully completed and a CleanupComplete status where a CleanupRelease invocation has successfully completed.

It will be appreciated by those skilled in the art that the above described facility may be straightforwardly adapted or extended in various ways. For example the release manager API described above may be modified in various ways such as by adding additional functions deleting existing functions modifying parameters return values or behaviors etc. The resource retrieval mechanism may be implemented in a variety of different forms. Different data structures may be used to store merchant access information. The facility may be straightforwardly adapted to virtually any context in which resources are related via data dependencies that require synchronization. The facility may be operated in a variety of different kinds of environments and its functionalities and data distributed in different ways within those environments. While the foregoing description makes reference to preferred embodiments the scope of the invention is defined solely by the claims that follow and the elements recited therein.

