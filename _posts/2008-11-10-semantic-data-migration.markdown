---

title: Semantic data migration
abstract: Migrating data within a storage area network is disclosed. A migration plan is created, the migration plan to move data stored in the storage area network, wherein each element of data is to be moved from a source location to a destination location according to a mapping therebetween. A virtual identifier is assigned to each mapping according to the migration plan. The migration plan is executed. Upon completion of the movement of an element of data, the virtual identifier for the mapping of that element of data is assigned to a resultant location to which that element of data is moved. Upon completion of the execution of the migration plan, the movement of the data is verified by comparing, for each element of data, the virtual identifier of the mapping and the virtual identifier of the resultant location.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08275748&OS=08275748&RS=08275748
owner: EMC Corporation
number: 08275748
owner_city: Hopkinton
owner_country: US
publication_date: 20081110
---
The present application claims the benefit of International Patent Application No. PCT US2008 078344 filed on Sep. 30 2008 which is incorporated herein by reference in its entirety.

The rapid expansion of information service and data processing industries has resulted in a need for computer systems to manage and store large amounts of data. As an example financial service industry businesses such as banks mutual fund companies or the like often operate large and complex data processing systems that require access to many hundreds of gigabytes or even terabytes of data. Data storage system developers have responded to these types of data storage requirements by integrating large capacity data storage systems data communications devices and computer systems into networks called storage networks or storage area networks SANs. A storage area network is a collection of data storage systems that are networked with a number of host computer systems that operate as servers to access data stored in the data storage systems.

Elements of a typical conventional storage area network implementation include one or more connectivity devices such as high speed data switches or routers that interconnect the various data storage systems to each other and to one or more host or server computer systems servers that require access to e.g. read and or write the data in the data storage systems on behalf of client software applications and or client computer systems.

A developer or administrator of such a storage area network environment may install one or more distributed storage area network management software applications within the storage area network to manage or administer the various elements i.e. devices computer systems storage systems etc. that operate within the storage area network. A network manager i.e. a user responsible for management of the storage area network operates the network management software application to perform management tasks such as performance monitoring network analysis and remote configuration and administration of the various components operating within the storage area network.

A typical conventional storage area network management software application may have several different software components that execute independently of each other on different computer systems but that collectively interoperate together to perform network management. As an example conventional designs of storage area network management applications can include console server agent and storage software components.

Generally the server component operates as a central control process within the storage area network management application and coordinates communication between the console storage and agent components. The console component often executes within a dedicated storage area network management workstation to allow the network administrator to visualize and remotely control and manage the various elements within the storage area network that are graphically represented within the console. Certain console applications include Graphical User Interface GUI software programs that enable network managers to graphically manage control and configure various types of hardware and software resources or managed entities associated with a corresponding managed network. In one conventional storage area network management application rendering the graphical user interface enables the network manager to graphically select interact with and manage local or remote devices and associated software processes operating in the network. More specifically based on use of the graphical user interface in combination with an input device such as a hand operated keyboard and or mouse and corresponding pointer displayed on a viewing screen a network manager is able to manage hardware and software entities such as storage devices peripherals network data communications devices and so forth associated with the network. Typically in such network management applications a network manager may select a displayed icon representing a corresponding resource in the storage area network and apply a management command in order to display corresponding management information.

Enterprise Storage Networks are large and complex environments that include various elements such as storage arrays switches hosts and databases all inter networked. These elements occur in several hundreds in such environments. These elements in turn may consist of several hundred thousands of manageable elements such as storage devices storage and switch ports database instances host devices and file systems and the like. Management of such environments is a daunting task and typically requires Storage Resource Management solutions such as EMC s Control Center ECC family of products available from EMC Corporation of Hopkinton Mass. ECC includes agents that are deployed on storage elements for the purpose of gathering data about these elements components that process and persist data applications that use persisted information to enable the management of these environments. ECC identifies the entire process of retrieving the collected data from agents to data persistence as a transaction.

Conventional methods of data migration suffer from a variety of deficiencies. Namely especially as a network environment becomes more complex the costs associated with data migration computing resources time and so on increase substantially. In a typical large scale storage area network there are hundreds if not thousands of components all interconnected in a variety of ways. To move i.e. migrate a single element of data across such a network environment is a non trivial operation. To migrate large amounts of data is even more complex. The various elements of data must be tracked throughout the process in case the migration of any portion of the data later needs to be undone.

Embodiments disclosed below overcome these and other issues by providing for a semantic data migration process incorporating various schema driven solutions. The semantic data migration process includes a migration manager that leverages the existing capabilities of Control Center a leading storage resource management product. The semantic data migration process covers the three major phases of data migration planning execution and verification. It implements all these phases in a multi stage way and it supports midway correction and rollback features. Embodiments of the semantic data migration process described herein are based on identifying the elements of a storage area network environment such as devices hosts file systems databases arrays and the like. The details of these elements or objects are captured in a repository such as the Control Center repository. The relational state of an object is defined as the other objects related to the object. This relational state may be defined in terms of the object s subcomponents and attributes those objects it refers to and other objects referring to it. The span of the state is limited by the objects supported in the repository. This definition of the relational state of the object forms the basis of the semantic data migration process. It captures the integrity of the configuration of a storage area network and the objects representing the data contained therein. It provides a framework for tracking the relation between objects during the course of data migration.

More particularly in an embodiment there is provided a method of migrating data within a storage area network. The method includes creating a migration plan the migration plan to move data stored in the storage area network wherein each element of data is to be moved from a source location to a destination location according to a mapping therebetween assigning a virtual identifier to each mapping according to the migration plan executing the migration plan wherein upon completion of the movement of an element of data the virtual identifier for the mapping of that element of data is assigned to a resultant location to which that element of data is moved and verifying upon completion of the execution of the migration plan the movement of the data by comparing for each element of data the virtual identifier of the mapping and the virtual identifier of the resultant location.

In a related embodiment creating may include receiving a selection of the data to be moved within the storage area network identifying operations required to perform the movement of each element of the selected data wherein the operations required to move a particular element of the selected data are grouped as a task and creating an operational order for all operations within each task and all tasks. In a further related embodiment identifying may include identifying operations required to perform the movement of the selected data by accessing a relational mapping of the storage area network and its components stored within a repository.

In another related embodiment the method may include tracking movement of data during the execution of the migration plan by referring to the virtual identifiers associated with data being moved and storing the tracked movement in a track record. In a further related embodiment the method may include detecting an error during execution of the migration plan halting execution of the migration plan undoing any actions that resulted in the error by consulting the track record refining the migration plan to avoid the detected error and resuming execution of the migration plan as refined. In a further related embodiment detecting may include detecting an error during execution of the migration plan wherein the error includes movement of an element of data to a location that is not the destination location for that element of data and undoing may include undoing any actions that resulted in the error by consulting the track record and identifying differences between the destination location for an element of data and the resultant location for that element of data by examining the related virtual identifiers.

In still another related embodiment creating and assigning may be performed through use of a migration and task schema executing may be performed through use of an operational schema and verifying may be performed through use of a verification schema.

In another embodiment there is provided a computer system including a memory a processor a display and an interconnection mechanism coupling the memory the processor and the display allowing communication there between. The memory of the computer system is encoded with a semantic data migration application that when executed in the processor provides a semantic data migration process that migrates data within a storage area network by causing the computer system to perform operations of creating a migration plan the migration plan to move data stored in the storage area network wherein each element of data is to be moved from a source location to a destination location according to a mapping therebetween assigning a virtual identifier to each mapping according to the migration plan executing the migration plan wherein upon completion of the movement of an element of data the virtual identifier for the mapping of that element of data is assigned to a resultant location to which that element of data is moved and verifying upon completion of the execution of the migration plan the movement of the data by comparing for each element of data the virtual identifier of the mapping and the virtual identifier of the resultant location.

In yet another embodiment there is provided a computer program product stored on computer readable medium to migrate data within a storage area network. The computer program product includes computer program code for creating a migration plan the migration plan to move data stored in the storage area network wherein each element of data is to be moved from a source location to a destination location according to a mapping therebetween assigning a virtual identifier to each mapping according to the migration plan executing the migration plan wherein upon completion of the movement of an element of data the virtual identifier for the mapping of that element of data is assigned to a resultant location to which that element of data is moved and verifying upon completion of the execution of the migration plan the movement of the data by comparing for each element of data the virtual identifier of the mapping and the virtual identifier of the resultant location.

It is to be understood that the embodiments of the invention can be embodied strictly as a software program as software and hardware or as hardware and or circuitry alone such as within a data communications device. The features of the invention as explained herein may be employed in data communications devices and or software systems for such devices such as those manufactured by EMC Inc. of Hopkinton Mass.

Note that each of the different features techniques configurations etc. discussed in this disclosure may be executed independently or in combination. Accordingly the present invention may be embodied and viewed in many different ways. Also note that this summary section herein does not specify every embodiment and or incrementally novel aspect of the present disclosure or claimed invention. Instead this summary only provides a preliminary discussion of different embodiments and corresponding points of novelty over conventional techniques. For additional details elements and or possible perspectives permutations of the invention the reader is directed to the Detailed Description section and corresponding figures of the present disclosure as further discussed below.

Generally embodiments disclosed and described herein provide for semantic data migration within a storage area network SAN though the principles described herein may be applied to any type of network. As used throughout a session may be a migration session involving selected elements of the SAN a schema may be a relational schema which is a subset of the Control Center CC repository that is custom created based on the specific actions it is modeling like a migration activity a task may be an individual homogeneous operations within a migration session and SANRefresh may refer to the operation of a new discovery of a SAN and populating the details in the CC repository.

More particularly is a block diagram illustrating example architecture of a computer system that executes runs interprets operates or otherwise performs a semantic data migration application and a semantic data migration process suitable for use in explaining example configurations disclosed herein. The computer system may be any type of computerized device such as a personal computer workstation portable computing device console laptop network terminal or the like. As shown in this example the computer system includes an interconnection mechanism such as a data bus or other circuitry that couples a memory system a processor an input output interface and a communications interface . An input device e.g. one or more user developer controlled devices such as a keyboard mouse touchpad trackball etc. couples to the processor through the I O interface and enables a user such as a system administrator of a network to provide input commands and generally administer the network through for example a graphical user interface that may be provided on a display . The communications interface enables the computer system to communicate with other devices on the network .

The memory system is any type of computer readable medium and in this example is encoded with a semantic data migration application that includes semantic data migration process . The semantic data migration application may be embodied as software code such as data and or logic instructions e.g. code stored in the memory system or on another computer readable medium such as a removable disk that supports processing functionality according to different embodiments described herein. During operation of the computer system the processor accesses the memory system via the interconnection mechanism in order to launch run execute interpret or otherwise perform the logic instructions of the semantic data migration application . Execution of the semantic data migration application in this manner produces processing functionality in a semantic data migration process . In other words the semantic data migration process represents one or more portions or runtime instances of the semantic data migration application performing or executing within or upon the processor in the computer system at runtime.

It is noted that example configurations disclosed herein include the semantic data migration application itself including the semantic data migration process i.e. in the form of un executed or non performing logic instructions and or data . The semantic data migration application may be stored on a computer readable medium such as a floppy disk hard disk electronic magnetic optical or other computer readable medium. The semantic data migration application may also be stored in a memory system such as in firmware read only memory ROM or as in this example as executable code in for example Random Access Memory RAM . In addition to these embodiments it should also be noted that other embodiments herein include the execution of the semantic data migration application in the processor as the semantic data migration process . Those skilled in the art will understand that the computer system may include other processes and or software and hardware components such as an operating system not shown in this example.

In the semantic data migration process described above with regards to results in the migration of data within a storage area network. The semantic migration process includes in some embodiments such as a system the following components to deal with the three phases of migration planning execution and verification a Migration Task Planner a Migration Controller and a SchemaVerifier . The Migration Task Planner helps in planning the migration in terms of simple tasks to be executed. An initial task plan may be received from a planning unit or may otherwise be received as user input . From this initial task plan as described in greater detail below migration schema and migration task schema develop a task plan. The task plan may be modified according to rules stored within domain rules and according to transactions within data dependency based migration transaction . The task plan may then be stored in task schema repository and is also sent to the Schema Verifier and the Migration Controller . The Migration Controller executes the tasks received from the Migration Task Planner with the help of application programming interfaces indicated in by arrows to storage and replication pool to storage and area pool and to host bus adaptor and host pool which may in some embodiments include an OpenReplication API and other native APIs. The SchemaVerifier tracks the migration execution against the original task plan as formulated by the Migration Task Planner and communicated from the migration task schema and enables performance of a loop based multi staged data migration. The semantic migration process makes use of the Control Center CC Repository or other similar repositories of data describing the components of a SAN for the various schemas it uses. The CC repository may be updated by means of SANRefresh which does a discovery of the SAN environment.

The semantic migration process first creates a migration plan step . The migration plan is to move data stored in the storage area network. Each element of data is to be moved from a source location to a destination location according to a mapping therebetween. In some embodiments the semantic migration process may create a plan by first receiving a selection of the data to be moved within the storage area network step . The semantic migration process then identifies operations required to perform the movement of each element of the selected data wherein the operations required to move a particular element of the selected data are grouped as a task step and creates an operational order for all operations within each task and all tasks step . In some embodiments the semantic migration process identifies operations required to perform the movement of the selected data by accessing a relational mapping of the storage area network and its components stored within a repository step .

The semantic migration process then assigns a virtual identifier to each mapping according to the migration plan step . Next the semantic migration process executes the migration plan step . Upon completion of the movement of an element of data the virtual identifier for the mapping of that element of data is assigned to a resultant location to which that element of data is moved. Finally the semantic migration process verifies upon completion of the execution of the migration plan the movement of the data by comparing for each element of data the virtual identifier of the mapping and the virtual identifier of the resultant location step .

In some embodiments the semantic migration process may track movement of data during the execution of the migration plan by referring to the virtual identifiers associated with data being moved step and stores the tracked movement in a track record step . The semantic migration process may then detect an error during execution of the migration plan step . An error may be but is not limited to an element of data being moved to an incorrect location or a destination location being unavailable due to a change in the physical structure of the SAN and or the failure of the component of the SAN including the destination location. The semantic migration process then halts execution of the migration plan step . The semantic migration process may undo any actions that resulted in the error by consulting the track record step and then refines the migration plan to avoid the detected error step . The refinements may be automatically determined by the semantic migration process may be based upon user input or may be a combination of both. Finally the semantic migration process resumes execution of the migration plan as refined step .

In some embodiments the semantic migration process detects an error during execution of the migration plan wherein the error includes movement of an element of data to a location that is not the destination location for that element of data step and then undoes any actions that resulted in the error by consulting the track record and identifying differences between the destination location for an element of data and the resultant location for that element of data by examining the related virtual identifier step .

Thus a user selects a mapping between source storage and destination storage at the higher level. Based on user input selection the migration session is configured. Each migration session has a migration schema based on the relational attributes of the selection from Control Center Repository latest discovery snapshot. The migration schema is a subset of CC Repository. Selection is now performed based on lower level objects like individual devices port interfaces within the migration session. At this step of the migration session we create what is know as a well defined task. The task is part of the session. There can be multiple independent tasks within a session.

Note that in some embodiments creating and assigning are performed through use of a migration and task schema wherein executing is performed through use of an operational schema and wherein verifying is performed through use of a verification schema step . The migration schema may be considered as the way of capturing the state of the migration environment. Based on which we can derive the next state of how the environment will look after the migration operation. Task Planner will show the differences of the tasks performed and the expected state. The actions whether it is performed by semantic migration process or other tools is always tracked with the expected state. Of course a user may do a change of expected state by reconfiguration SANRefresh and initiating a new session. All the tasks executed for a session can be stored in a task repository. The migration schema and task schema can be stored in the form of snapshots.

Again the user selects the individual objects. The task planner collects the state information associated with the selected object through a relational search of the migration schema and creates the migration task and its associated task schema. Each migration session has tasks within it. Each of them has their schemas. The task may be considered as a transaction which means all the operations are logically related to an object. Many such tasks exist. These tasks are independent of each other but belong to the same migration session.

To create the execution plan the planner makes use of the migration transaction scheduler. It takes care of two factors the order in which the operations in a transaction are executed and identifies operations that may be executed in parallel with a task and across tasks in a migration session. Thus the transaction scheduler may be said to use task domain rules and optimizations based on parameters like replication type and contiguity.

In execution planning for migration there are some other factors that are taken into account. When the plan is implemented based on the schema two cases arise may arise capabilities to implement that part of the plan an exception could be a hardware or a wiring change and the decision of the user to enforce that change. Nevertheless the implementation plan for the data migration session identifies the tasks to be implemented for that success migration. During the migration session the plan of execution can change by the following ways. An operation is performed either through semantic migration process or other tools or manual and a SANRefresh is done. After this the migration operation schema changes. Alternatively the initial user inputs are changed which results in the creation of a new migration session and schema.

When the task schema for a task is created there is a special identifiers added known as placeholders for verification. It is based on the user selection mappings. It makes use of virtual identifier assigned in a way the source objects and destination objects can be compared against the actual tasks performed during migration execution. The Virtual IDs are the placeholders for verification done by the SchemaVerifier. They identify the user mappings. These mappings and the virtual IDs are sent to the migration controller the abstraction layer before the execution. Once the task is executed the destination object IDs and the tagged virtual IDs are populated in the operation schema. This forms the basis for the SchemaVerifier component. At the end of this stage we have a plan that is ready to be executed.

The actual migration execution takes place based on an abstraction layer called the Migration Controller MC . The role of the MC is to implement the migration execution plan. It should be done in an optimal way by pooling replication connections and keeping track of them react to user interruptions on migration actions and support the recording of the migration state in the operation schema based on migration execution and virtual IDs.

The MC performs the following operations translate the execution plan into specific operations which may be based on a opcode table that defines the operation codes for the standard set of operation and the parameters that are needed for a specific opcode interface through an API such as the OpenReplication API and control the connections and interface with other APIs such as Host Management Fabric API and Array API for the respective operations depending on the demands of the transaction.

The OpenReplication API is an open and standard set of interfaces for semantic migration process to communicate with the various native replication applications. The API can be classified into connection state methods data structures of replication related data that is to be shared between replicators and controller. The OpenReplication API is a wrapper over the individual replication APIs so that it can support features like session management connection pooling virtual IDs.

The methods supported include connection related methods session methods like start session terminate session pause session resume session some of which may be user initiated. The OpenReplication API is a wrapper over the existing APIs for performing replication operations. The wrapper will provide support for things like state details and virtual IDs. Host management Fabric API and Array API are already supported. A few of the replications are already supported in CC. The native replicators need to support this API interface but it should be relatively easy as they are internal replication solutions.

The SchemaVerifier performs the operation of comparing the schemas based on the virtual identifiers. It is basic use is to give a difference of the dependencies i.e. the pending actions for the migration task. This with respect to what is accomplished till now for the given migration task. The SchemaVerifier component may include Operation Schema which are the latest discovery subset of migration schema updated after the execution of the migration task. The SchemaVerifier works on the basis of comparison of schemas. There are a number of tools available for schema comparison which makes the task simpler. The criteria for comparison in the verifier will depend on parameters such as but not limited to capacity calculation and a comparison mapping of object sets.

Apart from the schema verifier the verification process may be performed using the host array APIs and read only operations. It will be based on the actions captured in the operation schema. Due to the schema driven process at any stage the data migration can be restarted from midway after doing a SANRefresh. Thus the SchemaVerifier may be invoked after a SANRefresh and the operation schema is updated. The changes in the SAN environment could be by semantic migration process hardware or other means. The SchemaVerifier model can track the changes. This is possible due to the level of detail present in the CC Repository.

The loop based model is useful for correcting any mistakes or errors midway correction of mistakes or errors the rollback of certain actions and allows the migration plan to be changed midway.

The methods and systems described herein are not limited to a particular hardware or software configuration and may find applicability in many computing or processing environments. The methods and systems may be implemented in hardware or software or a combination of hardware and software. The methods and systems may be implemented in one or more computer programs where a computer program may be understood to include one or more processor executable instructions. The computer program s may execute on one or more programmable processors and may be stored on one or more storage medium readable by the processor including volatile and non volatile memory and or storage elements one or more input devices and or one or more output devices. The processor thus may access one or more input devices to obtain input data and may access one or more output devices to communicate output data. The input and or output devices may include one or more of the following Random Access Memory RAM Redundant Array of Independent Disks RAID floppy drive CD DVD magnetic disk internal hard drive external hard drive memory stick or other storage device capable of being accessed by a processor as provided herein where such aforementioned examples are not exhaustive and are for illustration and not limitation.

The computer program s may be implemented using one or more high level procedural or object oriented programming languages to communicate with a computer system however the program s may be implemented in assembly or machine language if desired. The language may be compiled or interpreted.

As provided herein the processor s may thus be embedded in one or more devices that may be operated independently or together in a networked environment where the network may include for example a Local Area Network LAN wide area network WAN and or may include an intranet and or the internet and or another network. The network s may be wired or wireless or a combination thereof and may use one or more communications protocols to facilitate communications between the different processors. The processors may be configured for distributed processing and may utilize in some embodiments a client server model as needed. Accordingly the methods and systems may utilize multiple processors and or processor devices and the processor instructions may be divided amongst such single or multiple processor devices.

The device s or computer systems that integrate with the processor s may include for example a personal computer s workstation s e.g. Sun HP personal digital assistant s PDA s handheld device s such as cellular telephone s laptop s handheld computer s or another device s capable of being integrated with a processor s that may operate as provided herein. Accordingly the devices provided herein are not exhaustive and are provided for illustration and not limitation.

References to a microprocessor and a processor or the microprocessor and the processor may be understood to include one or more microprocessors that may communicate in a stand alone and or a distributed environment s and may thus be configured to communicate via wired or wireless communications with other processors where such one or more processor may be configured to operate on one or more processor controlled devices that may be similar or different devices. Use of such microprocessor or processor terminology may thus also be understood to include a central processing unit an arithmetic logic unit an application specific integrated circuit IC and or a task engine with such examples provided for illustration and not limitation.

Furthermore references to memory unless otherwise specified may include one or more processor readable and accessible memory elements and or components that may be internal to the processor controlled device external to the processor controlled device and or may be accessed via a wired or wireless network using a variety of communications protocols and unless otherwise specified may be arranged to include a combination of external and internal memory devices where such memory may be contiguous and or partitioned based on the application. Accordingly references to a database may be understood to include one or more memory associations where such references may include commercially available database products e.g. SQL Informix Oracle and also proprietary databases and may also include other structures for associating memory such as links queues graphs trees with such structures provided for illustration and not limitation.

References to a network unless provided otherwise may include one or more intranets and or the internet. References herein to microprocessor instructions or microprocessor executable instructions in accordance with the above may be understood to include programmable hardware.

Unless otherwise stated use of the word substantially may be construed to include a precise relationship condition arrangement orientation and or other characteristic and deviations thereof as understood by one of ordinary skill in the art to the extent that such deviations do not materially affect the disclosed methods and systems.

Throughout the entirety of the present disclosure use of the articles a or an to modify a noun may be understood to be used for convenience and to include one or more than one of the modified noun unless otherwise specifically stated.

Elements components modules and or parts thereof that are described and or otherwise portrayed through the figures to communicate with be associated with and or be based on something else may be understood to so communicate be associated with and or be based on in a direct and or indirect manner unless otherwise stipulated herein.

Although the methods and systems have been described relative to a specific embodiment thereof they are not so limited. Obviously many modifications and variations may become apparent in light of the above teachings. Many additional changes in the details materials and arrangement of parts herein described and illustrated may be made by those skilled in the art.

