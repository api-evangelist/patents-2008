---

title: Configurable enablement of operations associated with state enabled systems in a graphical environment
abstract: Exemplary embodiments allow configurable execution of operations associated with a state enabled system in a graphical modeling or graphical programming environment. In an embodiment, a state enabled system may be identified in a graphical model, or a graphical program, or both. The state enabled system may be associated with a first operation and a second operation, and may include instructions to execute the first and second operations. The state enabled system may be configured to always execute the first operation regardless of an enabling condition. The state enabled system may also be configured to prevent an execution of the second operation unless the enabling condition is satisfied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08768658&OS=08768658&RS=08768658
owner: The Mathworks, Inc.
number: 08768658
owner_city: Natick
owner_country: US
publication_date: 20081031
---
The present application claims priority to U.S. Provisional Application No. 61 009 497 filed on Dec. 28 2007 the entire content of which is incorporated by reference.

Graphical modeling and graphical programming environments allow users to design simulate and analyze graphical structures that represent systems such as dynamic systems. A graphical structure representing a system may implement time dependent or event dependent mathematical relationships among its inputs states and outputs. Blocks described in more detail below are one type of graphical structure. The blocks may describe computations performed on application specific computational hardware such as a computer microcontroller Field Programmable Gate Array FPGA or custom hardware. The blocks may be used to produce deployable software systems or to produce descriptions of hardware systems that can mimic the behavior of either the entire model or portions of the model referred to herein as code generation . The term block will hereafter be used generally to refer to graphical structures.

Graphical structures may be part of a block diagram model which may contain blocks and lines. The lines in a block diagram model may carry information describe dependencies or define relationships between the blocks. The lines may also have operations or mathematics associated with them. The blocks in a block diagram model may be dynamic system elements that define operations generally referred to as block methods represent mathematical equations and or contain state information. Methods defined by a block may include output operations and update operations. Output operations may calculate an output of a block and update operations may update a state of a block.

A block in a block diagram model may be enabled when an enabling condition is satisfied or disabled when the enabling condition is not satisfied. Conventionally when a block is enabled both the output and update operations associated with the block are executed to produce an output and to update a state of the block respectively. In contrast when a block is disabled neither the output operation nor the update operation associated with the block is executed.

In one aspect one or more computer readable media holding executable instructions are disclosed. The instructions include instructions for identifying an executable state enabled system including instructions for a first operation and a second operation. The instructions also include instructions for configuring the state enabled system to always execute the first operation regardless of an enabling condition and to prevent an execution of the second operation unless the enabling condition is satisfied. The instructions further include instructions for executing the first and second operations.

In another aspect a computer implemented method is disclosed. The method includes identifying an executable state enabled system including instructions for a first operation and a second operation. The method also includes configuring the state enabled system to always execute the first operation regardless of an enabling condition and to prevent an execution of the second operation unless the enabling condition is satisfied. The method further includes executing the first and second operations.

In yet another aspect a computer system is disclosed for configuring operations associated with an executable state enabled system. The computer system includes a processor configured to implement a first user interface and a second user interface. The first user interface renders the state enabled system on a display and executes operations the state enabled system holding instructions for the operations. The second user configures at least one of the operations for conditional execution and identifies a condition to be satisfied before the at least one of the operations is executed. The computer system also includes a storage for storing the first and second user interfaces.

In still another aspect one or more computer readable media storing executable instructions is disclosed. The instructions include instructions for identifying an executable state enabled system including instructions for an output operation and a state update operation. The instructions also include instructions for conditioning the state enabled system to always execute the output operation regardless of an occurrence of a condition and to prevent an execution of the state update operation unless the condition occurs. The instructions further include instructions for executing the output and state update operations.

Exemplary embodiments allow configuration of the execution of operations associated with a graphical structure so that the execution of operations may be controlled during an execution of the graphical structure. A graphical structure as used herein may be an entity in a program or model such as an element multiple elements a subsystem or a system. Graphical structures may be part of different types of programs or models such as block diagram models data flow models or state charts.

An exemplary embodiment of a configurable graphical structure is referred to herein as a state enabled system. A state enabled system is a graphical structure that may be configured so that its output operations are executed independent of whether the graphical structure is active or enabled while its update operations are executed only when the graphical structure is active or enabled. The active or enabled state of a graphical structure may be based on the on status of an enabling condition or an enabling signal.

The behavior of a state enabled system differs from that of a conventional enabled system which is described in more detail below in that the output operations of a state enabled system continue to execute when the system itself is not executing. As a result a state enabled system accurately captures system behavior and allows efficient generation of hardware description language HDL code from the graphical representation of the system.

Exemplary embodiments enable execution of operations associated with blocks implemented in a graphical modeling or programming environment. Exemplary embodiments also allow configuring execution of the operations based on the active or inactive status of the associated blocks.

A block may have one or more associated signals and or one or more associated states. A state e.g. state x t may represent internal data associated with a block. In some embodiments a state may be an internal notion of blocks. Signals e.g. the input signal to the block u t and the output signal of the block y t may be thought of as persistent values that are updated when a block is executed. Signals in a time based block diagram represent time vary quantities and while they are a function of states in general they are not block states themselves. The same is true in other graphical modeling environments. For example signals in data flow models can represent flow of information and data dependencies the signals being equivalent to variables in a textual programming language. In addition the blocks in data flow models can have internal states that persist between block invocations.

A block in a block diagram model may implement one or more operations during its execution. These operations may include one or more output operations update operations and or derivative operations. An output operation may generate an output of the block updating the output signal y t . An update operation may update a state of the block x t which represents internal data associated with the block. A derivative operation may compute the derivative of a state of the block dot over x t . A block may execute any number of additional operations in addition to the aforementioned exemplary operations e.g. an initialize operation that may initialize a state of the block a Jacobian operation for linearization etc.

Blocks operations may be implemented in the model as methods or functions and may receive any number of parameters as arguments. More formally mathematical representations of the exemplary block operations in a time based block diagram modeling environment such as Simulink are set forth as follows 

A block may be executed when it has a sample hit. Execution of a block may involve executing the block operations by solving the equations defined by the operations. An output operation is executed to generate an output of the block which updates the block s output signals y t while an update operation is executed to update a state of the block.

Such block execution is exemplified by a block modeling a unit delay of a scalar signal. This unit delay block is executed upon each sample hit to delay a scalar signal by one time step. The block has a state representing the prior value of the input signal. At the beginning of execution of the block the state of the block is initialized with an initial condition parameter obtained from a dialog box. During execution of the block its output operation copies the state to the output signal. The update operation then copies the input signal value to the current state.

In one embodiment a block diagram model may be simulated by sorting the blocks in the model creating block method execution lists i.e. sorted lists of block methods that identify the order in which the block methods are to execute and running the execution lists in a simulation or execution loop. The simulation loop may execute the operations associated with the blocks in the block diagram model e.g. the output update and derivative operations discussed above.

A simulation loop may be performed in a single iteration or in multiple iterations. If the loop is performed in multiple iterations time t representing the current time as time advances in the simulation or execution of the model t may be incremented by a step size h in iteration of the simulation or execution loop.

The above representation of a simulation loop is reflective of the semantics of a time based block diagram. At the end of each iteration of the simulation loop time t is incremented by a step size h . In addition to the output update and derivative operations an integration operation may be provided in the simulation loop to compute the states x of the blocks from the derivatives dot over x . The number of calls to the output and derivative operations during integration is dependent on the type of solver being used. Additional run time operations may be placed in the simulation loop to ensure the block diagram model executes as expected. For example Jacobian operations may be added to aid in the integration or to perform linearization.

Exemplary embodiments may allow the execution of the operations associated with a block to be configurable. Execution of all some or none of the operations may be controlled during an execution of a graphical model or graphical program that contains the block. In some instances execution of an operation may be configured so that the operation executes only when a condition is satisfied. In other instances execution of the operation may be configured so that the operation executes only when a condition is not satisfied. In yet other instances the execution of the operation may be configured to occur independently of a condition.

In one embodiment referred to as a state enabled system the operations of a block may be configured so that an output operation is executed independent of a condition while an update operation only executes when a condition is satisfied. That is output operations in a state enabled system continue to execute when the system itself is not executing. State enabled systems are useful in accurately modeling multi purpose processors and microcontrollers because such conditional execution is closely aligned with the behavior of multi purpose processors and the teachings of system theory e.g. control system and signal processing fields .

The semantics of state enabled systems are defined by the following scheme implemented in a simulation loop 

Exemplary embodiments may allow configurable enablement of operations in hierarchical or non hierarchical systems. Exemplary embodiments may be implemented in different graphical modeling domains each domain providing domain specific semantics that dictate what the models mean and how the models can be executed or translated to an execution environment. Some graphical modeling domains may support the notion of hierarchy. For example the Simulink modeling environment version 6.6 from The MathWorks Inc. supports several forms of hierarchy e.g. Atomic Subsystems Enabled Subsystems Triggered Subsystems Trigger and Enabled Subsystems Function Call Subsystems Action Subsystems and hierarchy through the notion of Model Reference. In one embodiment all the hierarchical systems may be conditionally executed. In another embodiment only a subset of these hierarchical systems may be conditionally executed.

A hierarchical system may contain layers of blocks to facilitate containment separation and or nesting. The context of each layer of hierarchy may be defined so that each layer has its own execution context. For example a state enabled system S may be contained within a larger state enabled system L. According to the execution scheme of state enabled systems the output operations may be left running for all layers of the hierarchy regardless of the enabled status of the layers i.e. for both state enabled systems S and L. If the larger state enabled system L is disabled then the state update operations of both systems S and L may not be performed. On the other hand if the larger state enabled system L is enabled then the state update operation of system L may be performed but the state update operation of system S may be performed only if the state enabled system S is also enabled.

Exemplary embodiments may provide one or more user interfaces to allow a user to configure blocks to act as state enabled systems. To this end a user may establish conditions that must be satisfied before the operations associated with the blocks may execute.

Exemplary embodiments may also provide one or more visual identifiers associated with a block. A visual identifier may identify to a user that the block is configured to control the execution of one or more operations. For example the visual identifier may identify that the block is configured to execute the output operation independent of a condition and to prevent the update operation from executing unless the condition is satisfied. However in some embodiments the visual identifiers may be excluded from the model.

Exemplary embodiments may generate code using for example a hardware description language HDL from a graphical model or graphical program or a portion thereof that includes a block configured to conditionally execute operations associated with the block. The block may provide semantics that correspond directly to an implementation of the generated code so code may be generated more efficiently e.g. using fewer steps to translate the block into the generated code.

In contrast to the state enabled system of exemplary embodiments a conventional enabled system is generally configured such that its associated operations e.g. both output and update operations execute only when the system is enabled. Such conventional enabled systems may capture system output behavior inaccurately because in some applications the output operations should be executed regardless of the enable status of the system. In addition direct translation of such systems to custom hardware results in inefficiencies due to the system semantics.

Conventional ways of improving the accuracy of system output behavior include holding the output of the system using a storage component. When the model is translated to hardware this necessitates adding storage elements to the generated hardware e.g. HDL for the enabled system which reduces the efficiency with which the system is executed or simulated. The extra storage elements also tend to increase the amount of chip area used in the hardware hardware production costs etc. Furthermore the additional storage elements tend to introduce delays in the hardware by increasing the time it takes for signals to pass through the system.

The subsystem includes input ports and an output port and a visual identifier . The input ports and may receive information e.g. in the form of input signals from blocks that may be connected to the subsystem . Signals e.g. the signals at input ports and can be thought of as persistent values that have values at all points in time and are updated when the source blocks of the signals executes. In this example the input port source signal is from a sine wave generator block modeling a sine wave generator and the input port source signal is from a biased signal from a pulse generator block modeling a pulse generator. The input port source signal specifies an enable condition e.g. in the form of an enable signal relating to a condition from another pulse generator block. The condition may control an execution of operations associated with the subsystem .

The output of the subsystem may generate a signal e.g. in the form of an output signal for display on a scope block modeling a signal scope e.g. an oscilloscope.

The visual identifier may identify to a user that an execution of operations associated with the subsystem may be conditioned based on a specified configuration.

In this example the subsystem represents has a hierarchical structure of graphical structures. The visualization of the subsystem in may represent the root or top level of the subsystem or the contents of another system. A user may descend into the hierarchy of the subsystem to view its contents. depicts such a sublevel view of the contents of the subsystem upon descending into the hierarchical structure of the subsystem prior art .

The sublevel of the subsystem illustrated in includes a Product block modeling a multiplication function and a Unit Delay block modeling a storage element that delays its input one time step by holding the input in a state. The blocks and each perform one or more operations when executed. During execution the Product block performs an output operation by computing the product of two inputs and the Unit Delay block performs an output operation wherein it copies its state to the output y t x t . This output of the Unit Delay block is used as the second input of the Product block . The Unit Delay block also performs an update operation which consists of copying its input to its internal state x t h . The sublevel of the subsystem also includes an Enable Port block of which provides the visual identifier of on or about the subsystem .

The connections and operations associated with the blocks in subsystem will now be described in more detail. The Product block has an input port an input port and an output port . The input port of the Product block is connected to the output port of an Inport block which provides the Sine Wave signal. The other input port of the Product block is connected to an output port of the Unit Delay block via a signal line . The Product block thus has a sine wave signal and the output of the Unit Delay block as its two inputs. The output port of the Product block is connected to the input port of an Outport block via the output signal line . The output generated by the Product block at the Outport block may be displayed in a scope block shown in external to the subsystem .

The input port of the Unit Delay block is connected to the output port of an Inport block which provides the agc gain signal. The Unit Delay block thus has the agc gain signal as its input. The output port of the Unit Delay block is connected to the input port of the Product block via a signal line .

The Product block executes an output operation to generate an output signal y t at the output port which is the product of an input signal u t at the input port and an input signal at input port . The Unit Delay block executes an output operation in which the Unit Delay state x t is copied to its output at the output port . The Unit Delay block also executes an update operation which copies the input signal from the Inport block to the Unit Delay state x t h . These operations may be executed within a simulation loop.

The signals in the subsystem may be of any type. In the specific example illustrated in the enable signal is a periodic rectangular function with a maximum value above 1 and a minimum value of 0. The input signal u t at the input port of the subsystem block is a sine wave. The agc gain input signal at the input port is a periodic rectangular function with a maximum of 2 and a minimum value of 1.

The subsystem is executed in a simulation loop wherein the execution time t is incremented by a step size h at the end of each iteration of the loop. The execution of the output operations of the Product block and the Unit Delay block result in the overall output operation 1 of the subsystem . Execution of the state update operation of the Unit Delay block results in the update operation 2 of the subsystem .

The processing of time based block diagrams for simulation or execution involves collecting the run time methods i.e. equations of each set of blocks into model equations. In this example of a conventional enabled system the model equations for the state update operation and the output operation are executed only when the enable signal at the input port is greater than zero i.e. when the subsystem is active or enabled.

In a conventional enabled system when the subsystem is not active or enabled the contents of the subsystem do not execute and the subsystem output is set to some value e.g. reset to a default value like zero or to the previous output. As depicted in the y output view of the y output signal is equal to a sine wave input signal multiplied by the agc gain input signal when the subsystem is enabled i.e. when the enable signal is greater than zero. The y output signal is set to zero when the subsystem is not enabled i.e. the enable signal is zero because the y output signal is set to zero when the enabled subsystem is disabled.

For applications such as models that are to be realized in hardware e.g. using a hardware description language HDL such a conventional enabled system may not accurately capture the behavior of the system output. In addition synthesizing HDL code from these model abstractions may result in inefficiencies due to the semantics of conventional enabled and conditionally executed subsystems.

In the previous example of a conventional subsystem the processing of the Product block of only occurred when the system was enabled. For this AGC example to improve correctness of the system output and hardware efficiency the enable signal should apply only to the state update operation and not to the output operation of the subsystem. Conventional ways of applying the enable signal only to the state update operation include reorganizing a graphical structure so that an enabled subsystem in the graphical structure only includes components performing update operations i.e. excludes components performing output operations. Components performing output operations are provided outside the enabled system.

As a result of this modification of the AGC model the unit delay output and update operations are executed only when the Enabled Subsystem is enabled i.e. the enable signal connected at input port is greater than zero. In contrast the output operation of the Product block is executed every time step such that the output is calculated even when the Enabled Subsystem is disabled and for an automatic gain controller i.e. even when the enable signal is less than or equal to zero. The resulting output behavior is shown in corresponding to the Scope block of . The output y t continues to change i.e. the output operation continues to execute when the enabled subsystem is disabled.

The output of the AGC model of in contrast to the output of shown in is desirable from an application standpoint for accurate modeling of an AGC controller. In particular the gain controller executes as shown by the signal y when the Enabled Subsystem performing gain adaption is disabled.

Hardware implementation of the conventional modification of subsystem will now be described. Hardware can include combinatorial logic circuits and or sequential logic circuits. illustrate a combinatorial logic circuit and a sequential logic circuit respectively. In combinatorial logic circuits the outputs at any instant of time can be dependent upon the inputs present at that time. In sequential logic circuits the outputs are both a function of the inputs and the state of the storage memory elements. The state of the storage elements is in turn a function of previous inputs.

A simulation environment such as the Simulink modeling environment version 6.6 may provides a memory location for each signal. The memory locations represent time varying quantities that are read or written by the blocks connected to the signals. The simulator is responsible for updating the values of the signals by solving the equations defined by the blocks. The equations may be solved by running the output update derivative etc. run time methods associated with the blocks. A sample time dictates when in time the run time methods should be executed.

In an actual hardware base system such as an ASIC or FPGA or discrete logic only the storage elements e.g. registers or flip flops or more formally storage elements hold their values and the value of an interconnecting signal depends on what is driving that signal. If the signal is driven directly by a storage element then its value is held until the storage element is updated i.e. clocked by a rising or falling edge of a clock signal . If the signal is not driven directly by a storage element then the circuit element that drives that signal typically performs continuous calculations of new results whenever the inputs to it change. For example an adder with two inputs and one output produces an updated output value when any of its inputs change after a circuit delay.

In an exemplary embodiment a sequential circuit may be constructed to map a conditionally executed subsystem with states to hardware. This can be viewed as taking the output and state update equations of the system and realizing the equations using combinatorial logic and storage elements a sequential circuit . A sequential logic circuit generally includes a clock pulse or other enabling signal for the storage elements. There may be no such signal for the combinatorial logic circuits. As such additional logic is needed to ensure that the semantics of the conditionally executed subsystem are met.

The hardware circuit includes a storage element e.g. an n bit register an AND gate a multiplier and an second storage element . In this hardware circuit the second storage element is introduced to match the hold behavior of the Enabled Subsystem of as shown in . In general a hold element would need to be added to every output signal of a conventional Enabled Subsystem. This includes outputs connected to the Outport blocks such as y and any other form of outputs such as Simulink s Goto From outputs or Simulink s monitored test pointed signals.

However additional storage elements at the Enabled Subsystem outputs like the storage element of introduce inefficiencies in the system. These storage elements will increase the amount of chip area needed and hardware production costs. The storage elements also tend to introduce delays in the hardware by increasing the time it takes for signals to pass through the system. This can affect the clock rate at which the system will run or prevent the design from meeting its goals.

One means of matching the semantics of traditional enabled systems is using the enable clock signal to clock the register to hold the output is one means by which one can match the semantics of conventional enabled systems. Another means is to use a hardware mux to switch between the multiplier output and the latched multiplier output saved in a register . Thus there are several different means by which one can realize hardware to match the traditional enabled systems by adding additional circuitry to the hardware. However regardless of the specific realization the additional circuitry is not desired because it increases cost and or prevents the system from meeting its design goals.

In contrast to the models depicted in which do not necessarily match desired system behavior the modified AGC controller of meets the desired system output behavior. The model of however requires storage elements or extra hardware at the output of the Enabled System. The corresponding hardware circuit for the Enabled Subsystem of would be similar to hardware circuit of except the product multiplier circuitry would not be present.

Furthermore the modified conventional graphical structure of suffers from a lack of modularity. It is desirable to group the Product and Unit Delay blocks into one subsystem so that the Enabled Subsystem can be treated as a single entity e.g. copied to other models. Moreover some complicated graphical structures e.g. the least mean square LMS filter block in the Signal Processing Blockset from The MathWorks Inc. perform both the computation of outputs and the update of internal storage elements states . Graphical separating the output from the update aspects of the model is technically challenging and leads to loss of model readability.

To address the above deficiencies in the conventional modification technique of exemplary embodiments provide state enabled systems in which an enable signal is applied only to the state update operations and not to the output operations of the systems.

In contrast to conventional methods of adding extra storage elements to the hardware to improve system output behavior exemplary embodiments provide a state enabled system in which the enable condition or signal is applied only to the state update operations and not to the output operations. Update operations are executed when the system is enabled or active i.e. when an enable signal is greater than zero. In contrast output operations are executed continuously so that the output is calculated even when the system is disabled or inactive i.e. independent of the enable signal value.

This allows exemplary embodiments to capture the correct behavior of the subsystem and to preserve system modularity by grouping the blocks of the state enabled system into one subsystem. To make the generated HDL code more efficient exemplary embodiments allow mapping of the subsystem onto sequential logic circuits without the need for additional logic to enable disable the combinatorial logic circuit.

The input port may receive information e.g. in the form of an enable signal relating to a condition. The condition may control the execution of the state update operations that are associated with the state enabled system . As one example the update operation associated with the unit delay block may be configured to execute when the enable signal received by the input port is greater than zero.

It is expressly noted that state enabled systems can be applied to other forms of subsystems within time based block diagrams such as Simulink. For example state enabled versions of the Triggered Subsystems or Triggered and Enabled Subsystem found within Simulink 6.6 can be created. A State Triggered Subsystem created using the techniques disclosed herein is a form of a state enabled system wherein the state update methods are executed only when the trigger condition is true e.g. on a rising falling or either edge of the trigger signal connected to the subsystem. Similarly a State Triggered and Enabled Subsystem created using the techniques disclosed herein is a form a state enabled system wherein the state updated methods are executed only when the trigger condition is true and the enabling signal is greater than zero. Other forms of system preconditions are possible the enable condition may be value based or execution based for example a function call or action signal in the Simulink modeling environment is action based where the caller invokes the state enabled system represented as a state enabled Function Call or Action Subsystem . When the caller invokes a State Enabled Function Call or State Enabled Action Subsystem the caller is responsible for indicating if the output methods are to execute or if both the output and update methods are to execute.

It is expressly noted that state enabled systems can be applied to other modeling domains. For example in data flow models blocks generally execute upon the arrival of data. In this modeling domain the state enabled systems update methods would execute when data was received at an enabling condition port. Another example of a modeling domain where the state enabled systems can be applied is to State Chart Models where in an enabling condition determines whether or not the chart transitions states while the output methods generally chart actions continue to execute regardless of the enabling condition.

The output of the state enabled system may transmit information e.g. in the form of a signal to a scope block that is connected to the output port of the state enabled system .

The Enable block may identify to a user that an execution of operations associated with the state enabled system may be conditioned based on a specified configuration. This may be done by selecting an option in a dialog box associated with the Enable Port block .

In this example the state enabled system represents a subsystem that has a hierarchical structure of graphical structures. The visualization of the state enabled system may represent the root or top level of the subsystem. A user may descend into the hierarchy of the state enabled system to view its contents.

The Product block has an input port an input port and an output port . The input port of the Product block is connected to the output port of an Inport block which corresponds to the sine wave signal of . The input port of the Product block is connected to an output port of the Unit Delay block via a signal line . The Product block computes the product of the sine wave signal connected to the input port and the delayed latched agc gain signal at the input port . The output port of the Product block is connected to the input port of the Outport block via signal line so that outputs computed using Product block are displayed via a scope block external to the graphical structure . The output port of the Unit Delay block is connected to the input port of the Product block via signal line to provide a delayed latched agc gain signal used by the Product block .

The Product block may execute output operations in which the product block receives an input signal u at the input port and a delayed latched agc gain signal at the input port and generates an output signal y at the output port . The Unit Delay block may execute output update operations in which it receives an input signal agc gain and generates an updated state x. The output method of the unit delay copies the state to the block s output.

In the specific example illustrated in the enable signal at the input port of the state enabled system is a periodic rectangular function with a maximum value above 1 and a minimum value of 0. The input signal u at the input port of the product block is a sine wave. The input signal at the input port is a periodic rectangular function a maximum of 2 and a minimum value of 1.

The subsystem is executed in a simulation loop wherein the execution time t is incremented by a step size h at the end of each iteration of the loop. The execution of the output operations of the Product block and the Unit Delay block result in the overall output operation 3 of the subsystem . Execution of the state update operation of the Unit Delay block results in the update operation 4 of the subsystem .

Output Operation Output Method of the Enabled Subsystem delay delay 3 Update Operation Update Method of the Enabled Subsystem  gain 4 where the output method can be simplified to y t u t x t .

The state enabled system may be configured to control when the operations associated with the state enabled system are executed. For example the user may configure the state enabled system so that the update operation associated with the unit delay block does not execute until a condition is satisfied while the output operation associated with the product block executes independent of any condition. Alternatively or in addition the blocks and may be independently configured to control when operations associated with the blocks are executed. As previously discussed the behavior of a state enabled system differs from that of traditional conditionally executed systems in that its output operations continue to execute when the system is not executing.

Configuration of when an execution of operations occurs provides the user with flexibility when modeling systems. For example allowing a user to configure the execution of operations associated with the state enabled system results in a more accurate modeling of the output behavior of systems which is depicted in .

The y output signal is displayed in y output view . Unlike in a conventional enabled system exemplary embodiments apply the enable signal only to the state update operation and not to the output operation performed by the system. The output operation is performed regardless of the active or enable status of the system i.e. when the enable signal is on and also when it is off. As such the y output signal is equal to the sine wave input signal multiplied by the agc gain input signal when the subsystem is enabled and also when it is not enabled i.e. when the enable signal is on and also when it is off .

In some exemplary embodiments the graphical model or a portion thereof that includes the graphical structure may be used to generate code that describes a hardware implementation of the graphical structure. The code may be generated in a hardware description language such as Verilog or Very High Speed Integrated Circuit Description Language VHDL . After the code is generated it may be implemented in a hardware device such as a Field Programmable Gate Array FPGA . The improved semantics of the modeling environment may allow for direct and efficient translation of models containing conditionally executed systems to custom hardware since the models may accurately reflect the actual behavior of a system being modeled.

It should be appreciated that exemplary embodiments may be applied to different types of graphical models in a graphical modeling environment e.g. block diagram models data flow block diagrams etc. Block diagrams models are signal based models in which blocks in the model are connected through signals that connect the outputs and inputs of blocks. Data flow block diagrams are diagrams of entities nodes with connections lines between them that describe a graphical programming paradigm where the availability of data is used to initiate the execution of blocks where a block represents an operation and a line represents execution dependency describing the direction of data flowing between blocks.

Synthesizing hardware for state enabled system is efficient because there is no need for extra storage elements to hold the output of the system. In addition there is no need for extra logic to control the enabling of the output operations because they are never disabled. Furthermore the state enabled system achieves modularity i.e. the constituent blocks can be logically grouped together into subsystems in a meaningful manner. For example state enabled system allows grouping of the Unit Delay block and the Product block into one subsystem.

Exemplary embodiments may provide one or more user interfaces to allow a user to configure a state enabled system for conditional execution of its operation e.g. through a dialog box. A user may also configure a state enabled system with the use of an XML file a textual user interface a command line interface and Application Programming Interface API etc.

Alternatively a state enabled system may be configured without the aid of a user e.g. by configuration specifications supplied by the model or the modeling environment itself. In some embodiments the configuration specifications may be based on default settings. In other embodiments the configuration specifications may be determined from the structure semantics and or parameters of the model or the state enabled system.

Because the adaptive filter is a state enabled system the enable signal Adapt only controls the state update equations and thus only affects the update of the state for the Coef1 Unit Delay block containing the tap weights. This behavior closely matches the behavior of hardware designs e.g. FPGAs and ASICs. By making the enable input active or inactive control over the adaptation of the filters is achieved while the rest of the adaptive filter system continues to operate as if there were no enable signal.

In contrast in a conventional enabled subsystem the outputs equations associated with the blocks in AdaptiveSubsystem would not be evaluated when the enable signal was inactive and the system would not match the expectations of a hardware based system.

The tapped delay line leading to the input port of AdaptiveSubsystem must remain external to AdaptiveSubsystem in order to obtain the desired update operation. In this situation building a model where only the storage elements are in conventional enabled subsystems would not produce a desired behavior because some portions of the model include both computations of outputs and updates of internal storage elements. For example a problem encountered when using a conventional enabled subsystem is that many more complicated blocks such as the LMS filter block in the Signal Processing Blockset from the MathWorks have both the computation of outputs and the update of internal storage elements. It is not practical or desirable in general to separate the two different aspects in the model because of the loss of model readability and the technical challenge of separation for non trivial blocks such as the LMS filter block. Creating a state enabled subsystem according to exemplary embodiments that only enables the update of states or storage elements cures the above deficiencies.

The models illustrated in are discrete models with only output and update equations. Exemplary embodiments are however not limited to discrete models and may apply to any system that includes multiple forms of state updates. One such system is a continuous time system like the Proportional Integral PI Controller illustrated in . The PI Controller is configured to function as a state enabled system. depicts a sublevel view of the contents of the PI Controller State Enabled Subsystem .

Placing the PI Controller in a state enabled system allows the system designer to freeze an integration operation when the PI Controller State Enabled Subsystem is disabled. Freezing the integration may be desirable upon certain conditions e.g. when the input signal is in a particular region. In this case it is desirable to use merely a proportional control with the last integration added in. This state enabled system can be realized in hardware using either analog integration or a circuit performing numerical integration such as Euler integration. In simulations numerical integration is typically used.

The simulation loop for the model illustrated in containing the PI Controller State Enabled Subsystem using Euler integration is set forth as follows 

Exemplary embodiments may also be used to apply the concept of state enabled systems to state charts. State charts may enable graphical representation of states and transitions between them such as the state charts enabled by Stateflow modeling environment from The MathWorks Inc. A state chart may belong to one of several classes e.g. Mealy Moore etc as described in U.S. Pat. No. 7 840 913. In Mealy charts the output is a function of states and inputs. In Moore charts the output is a function of only states. For more elaborate forms of state charts e.g. Stateflow charts with events exemplary embodiments may be applied if it is possible to separate outputs from state updates. It should be appreciated that a graphical model in one modeling domain may include entities that are based on other modeling domains within the graphical model. A common characteristic among these various forms of graphical models is that they define semantics on how to execute them.

The visualization of the state enabled system may represent the root or top level of the state enabled system . A user may descend into the hierarchy of the state enabled system to view its contents. depicts such a sublevel view of the contents of the state enabled system which shows its constituent state chart . The input of the state chart u t is the constant signal . An output operation of the state chart generates an output y t based on the input u t and the state x t of the state chart .

The state of the state chart x t is initialized to state A by an initialize operation. The state x t is then updated by a state update operation based on the current state. If the current state is state A then the new state is set to state B. However if the current state is state B then the new state is set to state A. The initialize and state update operations are represented formally below.

Since the state chart is included in a state enabled system exemplary embodiments allow the output operation of the state chart to continue to execute even when the state enabled system is inactive or disabled e.g. when the enable signal is zero or lower than zero. In addition exemplary embodiments execute the state update operation of the state chart only when the state enabled system is active or enabled e.g. only when the enable signal is greater than zero.

Since the state chart is a state enabled system exemplary embodiments allow the output operation of the state chart to continue to execute even when the state chart is inactive or disabled e.g. when the enable signal is zero or lower than zero. In addition exemplary embodiments execute the state update operation of the state chart only when the state chart is active or enabled e.g. only when the enable signal is greater than zero.

Thus far the concept of state enabled systems has been illustrated using state enabled subsystems in which an enable signal determines when the contents of the state chart are enabled. However there are other forms of hierarchy in block diagram models that also fall into the class of state enabled systems. For example the Simulink modeling environment includes the notion of action signals and function call signals that do not carry data but control when a hierarchical node subsystem executes. The caller of these nodes determines if the called systems are enabled.

A hierarchical node representing an encapsulated model saved in a separate file may also be configured to function as a state enabled system. Such nodes may be extended to have a property or block which allows one to specify that the nodes should execute according to state enabled semantics i.e. outputs should run continually but state updates should run only when the nodes are enabled.

The above examples depict a modeling environment for implementing block diagram system models such as the Simulink modeling environment from The MathWorks Inc. The Simulink modeling environment provides tools for modeling and simulating a variety of dynamic systems in one integrated graphical environment. The Simulink modeling environment enables users to design a block diagram for a dynamic system simulate the system s behavior analyze the performance of the system and refine the design of the system. The Simulink modeling environment allows users to design models of systems through a user interface that allows drafting of block diagrams representing systems. All of the blocks in a block library provided by the Simulink modeling environment and other programs are available to users when the users are building the block diagram.

Individual users may be able to customize this model block to a reorganize blocks in some custom format b delete blocks they do not use and c add custom blocks they have designed. The blocks may be dragged through some human machine interface such as a mouse or keyboard from the block library on to the window i.e. model canvas . The Simulink modeling environment also allows users to simulate the models to determine the behavior of the systems. The Simulink modeling environment includes a block diagram editor that allows users to perform such actions as draw edit annotate save and print out block diagram representations of systems. The block diagram editor is a graphical user interface GUI component that allows drafting of block diagram models by users. In the Simulink modeling environment there is also a textual interface with a set of commands that allow interaction with the graphical editor such as the textual interface provided in the MATLAB software application. Using this textual interface users may write special scripts that perform automatic editing operations on the block diagram. The Simulink modeling environment also allows users to simulate the models to determine the behavior of the systems. The Simulink modeling environment includes a block diagram execution engine that carries out the task of compiling and linking the block diagram to produce an in memory executable version of the model that is used for generating code and or simulating a block diagram model.

Configurable conditionally executed operations in exemplary embodiments may be implemented in an environment like the Simulink modeling environment. Other environments suitable for implementing configurable conditionally executed operations include an event based environment provided by the SimEvents software application from The MathWorks Inc. data flow diagrams or the like. Some other environments that may be suitable for implementing configurable conditionally executed subsystems include any graphical modeling or graphical programming using software products such as LabVIEW or MATRIXx from National Instruments Inc. Mathematica from Wolfram Research Inc. Maple from Maplesoft Dymola from Dynasim AB Extend from Imagine That Inc. Scilab and Scicos from The French National Institution for Research in Computer Science and Control INRIA SCADE from Esterel Technologies Inc. among others. Furthermore one ordinarily skilled in the art will appreciate that exemplary embodiments may apply to other environments such a Unified Modeling Language UML modeling environment a SysML modeling environment or environments for modeling of physics domains.

The environment may include a modeling interface a simulation engine a textual interface and a code generating tool . The environment allows a user to develop models in the modeling interface . Using the modeling interface a user can create a model that includes for example the state enabled systems and or . The state enabled systems and or may be provided to model a system such as a dynamic system. The user may use predefined state enabled systems or custom state enabled systems to develop a model.

Some examples of state enabled systems that may be configured for conditional execution may include elements subsystems that include a hierarchy of elements or the like. Elements may represent but are not limited to continuous and or discrete dynamics elements such as integration elements unit delay elements etc. algorithmic elements such as sum product lookup tables etc. and or structural elements such as multiplexers switches signal or bus selectors etc. Elements may be used in a graphical model to develop a model of a system such as a dynamic system.

The textual interface may allow a user to develop a user defined element with a sequence of commands in a textual language. The textual interface can also facilitate debugging and or profiling of a model. Alternatively implementations of the environment may include a separate debugger and profiler.

The simulation engine may communicate with the modeling interface . The simulation engine may receive a model such as for example a block diagram model an event based model a UML model etc. that is generated using the modeling interface . The simulation engine may convert the model created in the modeling interface to an executable form referred to as a compiled model. The simulation engine may repetitively execute the compiled model e.g. via successive time steps from a simulation start time to a stop time specified by the user or until the simulation is interrupted. Alternatively the simulation engine may enable interpretive simulation of the model.

The code generating tool may be used to generate code such as source code object code a compiled executable or library for forming an executable of a model provided by the modeling interface . The code generating tool may also be used to generate a hardware description language representation of the model. The code generating tool may use implementations of code for portions of a model to generate executable code instructions etc. in a programming language such as Java Javascript C or C or a hardware description language such as Verilog or VHDL. To generate code the code generating tool may convert a source model language representation of a model to a target language. The code generating tool may comprise an extended version of a code building tool such as Real Time Workshop from The MathWorks Inc. of Natick Mass. or any portion thereof or may be substantially any software component for generating executable code instructions etc. in a programming language such as Java or C or in a hardware description language HDL such as Verilog VHDL SystemC etc. In one embodiment a block diagram model may be translated to generated code by sorting the blocks within the model generating code based on the sorted blocks and storing the code in a source file. The source file may then be compiled linked and executed.

The code generating tool may generate source code for the execution of a model that is provided by the modeling interface and may compile the source code into object code and build an executable program library or substantially any other form of executable instructions. In one embodiment a piece of logic different from the code generating tool may compile the source code. The code may be designed to run on any processor microprocessor dual core processor multi core processor cluster of processors operating system computational hardware device component of a computational hardware device etc. In one embodiment the code may comprise embedded code targeted to run on an embedded system. Additionally the code may be customized to run on a specific target hardware platform. For example the code generated may include fixed point code to run a fixed point processor or code may be generated to emulate fixed point behavior on a floating point processor.

The environment may be provided on a single computing device as described below with reference to on multiple computing devices e.g. in a distributed configuration and or in other configurations e.g. a multi core implementation operating on one or more platforms .

The computing device may take many forms including but not limited to a personal computer workstation server network computer quantum computer optical computer bio computer Internet appliance mobile device a pager a tablet computer a smart sensor application specific processing device etc.

The computing device may be electronic and may include a Central Processing Unit CPU memory storage an input control a modem a network interface a display and a processor . The CPU may control components of the computing device to provide the environment or some of the components of the environment . The memory may store instructions and data and may provide the instructions and data to the CPU . CPU may operate the computing device and may run the environment or some of the components of the environment based on the stored instructions.

Optionally the computing device may include multiple CPUs for executing software loaded in the memory and other programs for controlling system hardware. Each of the CPUs may be a single or a multiple core processor . The code loaded in the memory may run in a virtualized environment such as in a Virtual Machine VM . Multiple VMs may be resident on a single processor. Also part of the application may run in processor which may include for example a field programmable gate array FPGA programmable logic controller PLC an application specific integrated circuit ASIC an application specific instruction set processor ASIP a Fast Fourier Transform FFT processing device etc. Further part of the applications may be run on analog electronic devices that may be included in the computing device . Other resources such as for example graphics processing unit GPU may also be used to run part of the applications.

The storage may contain software tools for applications. The storage may include code for the operating system OS of the computing device code for applications running on the operation system including the applications for the environment or some of the components of the environment and data generated from the environment or some of the components of the environment and or other code. Portions of applications may be stored in the CPU cache memory and or elsewhere such as on a remote storage device connected to computing device via a network a bus a dedicated link etc.

The input control may interface with a data entry device such as a keyboard a pointing indexing device such as a mouse a microphone a camera such as a web camera and or other input devices. The computing device may receive through the input control input data such as the input data for developing the model. The computing device may display on the display user interfaces for displaying the data generated from the environment or some of the components of the environment .

Exemplary embodiments may be provided as one or more computer readable programs or instructions embodied on or in one or more mediums. The mediums may be but are not limited to a hard disk a compact disc a digital versatile disc a flash memory card a Programmable Read Only Memory PROM a Random Access Memory RAM a Read Only Memory ROM Magnetoresistive Random Access Memory MRAM or a magnetic tape. In general the computer readable programs may be implemented in any programming language. Some examples of languages that may be used include Python C C C Java Javascript etc. Further the computer readable programs may be implemented in a hardware description language or any other language that allows prescribing computation such as for example Deoxyribonucleic acid DNA . The software programs may be stored on or in one or more mediums as object code.

Network may transport data from a source to a destination. Embodiments of network may use network devices such as routers switches firewalls and or servers not shown and connections e.g. links to transport data. Data as used herein may refer to any type of machine readable information having substantially any format that may be adapted for use in one or more networks and or with one or more devices e.g. computer service provider etc. . Data may include digital information or analog information. Data may further be packetized and or non packetized.

Network may be a hardwired network using wired conductors and or optical fibers and or may be a wireless network using free space optical radio frequency RF and or acoustic transmission paths. In one implementation network may be a substantially open public network such as the Internet. In another implementation network may be a more restricted network such as a corporate virtual network. The network may include Internet intranet Local Area Network LAN Wide Area Network WAN Metropolitan Area Network MAN wireless network e.g. using IEEE 802.11 Bluetooth etc. etc. The communication network may use middleware such as Common Object Request Broker Architecture CORBA or Distributed Component Object Model DCOM . Implementations of networks and or devices operating on networks described herein are not limited to any particular data type protocol architecture configuration etc.

Service provider may include a device that makes a service available to another device. For example service provider may include an entity e.g. an individual a corporation an educational institution a government agency etc. that provides one or more services to a destination using a server and or other devices. Services may include instructions that are executed by a destination to perform an operation e.g. an optimization operation . Alternatively a service may include instructions that are executed on behalf of a destination to perform an operation on the destination s behalf.

Target environment may include a device that receives information over network . For example target environment may be a device that receives user input from computer for configuring execution of output and update operations for state enabled systems.

Cluster may include a number of units of execution UEs and may perform processing on behalf of computer and or another device such as service provider . For example in one embodiment cluster may perform parallel processing on an operation received from computer . Cluster may include UEs that reside on a single device or chip or that reside on a number of devices or chips.

Units of execution UEs may include processing devices that perform operations on behalf of a device such as a requesting device. In one embodiment a UE can be a microprocessor field programmable gate array FPGA and or another type of processing device. Embodiments of UE may include code such as code for an operating environment. For example a UE may run a portion of an operating environment that pertains to parallel processing activities.

Units of Execution UEs provide remote distributed processing capabilities for our products such as MATLAB . A hardware unit of execution may include a device e.g. a hardware resource that performs and or participates in parallel programming activities. For example a hardware unit of execution may perform and or participate in parallel programming activities in response to a request and or a task it has received e.g. received directly or via a proxy . A hardware unit of execution may perform and or participate in substantially any type of parallel programming e.g. task data stream processing etc. using one or more devices. For example in one implementation a hardware unit of execution may include a single processing device that includes multiple cores and in another implementation the hardware unit of execution may include a number of processors. A hardware unit of execution may also be a programmable device such as a field programmable gate array FPGA an application specific integrated circuit ASIC a digital signal processor DSP etc. Devices used in a hardware unit of execution may be arranged in substantially any configuration or topology such as a grid ring star etc. A hardware unit of execution may support one or more threads or processes when performing processing operations.

A software unit of execution may include a software resource e.g. a technical computing environment a worker a lab etc. that performs and or participates in parallel programming activities. For example a software unit of execution may perform and or participate in parallel programming activities in response to a receipt of a program and or one or more portions of the program. A software unit of execution may perform and or participate in substantially any type of parallel programming using one or more hardware units of execution. Embodiments of a software unit of execution may support one or more threads and or processes when performing processing operations.

The term parallel programming may be understood to include multiple types of parallel programming e.g. task parallel programming data parallel programming and stream parallel programming. Parallel programming may include any type of processing that can be distributed across two or more resources e.g. software units of execution hardware units of execution processors microprocessors clusters labs etc. and be performed at substantially the same time. For example in one implementation parallel programming may refer to task parallel programming where a number of tasks are processed at substantially the same time on a number of software units of execution. In task parallel programming each task may be processed independently of other tasks executing at the same time e.g. a first software unit of execution executing a first task may not communicate with a second software unit of execution executing a second task . In another implementation parallel programming may refer to data parallel programming where data e.g. a data set is parsed into a number of portions that are executed in parallel using two or more software units of execution. In data parallel programming the software units of execution and or the data portions may communicate with each other as processing progresses. In still another implementation parallel programming may refer to stream parallel programming also referred to as pipeline parallel programming . Stream parallel programming may use a number of software units of execution arranged in series e.g. a line where a first software unit of execution produces a first result that is fed to a second software unit of execution that produces a second result. Stream parallel programming may also include a state where task allocation may be expressed in a directed acyclic graph DAG or a cyclic graph with delays . Other implementations may combine two or more of task data or stream parallel programming techniques alone or with other types of processing techniques to form hybrid parallel programming techniques.

Implementations may provide devices and techniques for state enabled systems in a graphical environment that may be configured to control execution of one or more operations associated with the state enabled systems. For example in an embodiment referred to as a state enabled system a state enabled system may be configured so that output operations are executed independent of whether the state enabled system is active or enabled while update operations are executed only when the state enabled system is active or enabled. 

The foregoing description of exemplary embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example while a series of acts has been described with regard to the order of the acts may be modified in other implementations consistent with the principles of the invention. Further non dependent acts may be performed in parallel.

In addition implementations consistent with principles of the invention can be implemented using devices and configurations other than those illustrated in the figures and described in the specification without departing from the spirit of the invention. Devices and or components may be added and or removed from the implementations of the figures depending on specific deployments and or applications. Also disclosed implementations may not be limited to any specific combination of hardware.

Furthermore certain portions of the invention may be implemented as logic that performs one or more functions. This logic may include hardware such as hardwired logic an application specific integrated circuit a field programmable gate array a microprocessor software or a combination of hardware and software.

No element act or instruction used in the description of the invention should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on as used herein is intended to mean based at least in part on unless explicitly stated otherwise.

