---

title: Ruggedized memory device
abstract: A non-volatile storage device with built-in ruggedized features is disclosed. The device processes a write command to a logical block address by writing the data from the command to a non-volatile memory within the non-volatile storage device and conditionally associating the data received from the command with its corresponding logical block address. Two or more received write commands define a set of commands associated with an atomic transaction. When an end of set command is received, the device unconditionally associates the received data with each write command with its corresponding logical block address. If a power loss interrupts the reception of a set of commands, the non-volatile storage device may recover the last consistent data state before the atomic transaction was started. A write command transaction identifier allows the device to associate the command with a thread of commands that define an atomic transaction in a multithreaded system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266365&OS=08266365&RS=08266365
owner: SanDisk IL Ltd.
number: 08266365
owner_city: Kfar Saba
owner_country: IL
publication_date: 20081217
---
This application relates generally to the operation of non volatile flash memory systems and more specifically to ruggedized memory devices.

There are many commercially successful non volatile memory products being used today particularly in the form of small form factor cards which employ flash EEPROM Electrically Erasable and Programmable Read Only Memory cells formed on one or more integrated circuit devices. Some of the commercially available card formats include CompactFlash CF cards MultiMedia cards MMC Secure Digital SD cards and personnel tags P Tag . Hosts that may incorporate or access non volatile small form factor cards include personal computers notebook computers personal digital assistants PDAs various data communication devices digital cameras cellular telephones portable audio players automobile sound systems and similar types of equipment. Control of the memory may be achieved by software on a controller in the card. Besides a memory card implementation this type of memory can alternatively be embedded into various types of host systems. In both removable and embedded applications host data may be stored in the memory according to a storage scheme implemented by memory controller software and or hardware. The data stored within a card is accessed via an interface that is controlled by a program and in some cases security hardware or software.

The increase in storage density of non volatile memory cards allows an ever growing number of host applications to make use of the additional storage space. For example the additional space may be utilized for storage of MP3 audio files high resolution images files video files and documents. In cellular telephone applications the non volatile storage space may store a variety of data for advanced cellular telephone services such as storing Multimedia Messaging Service MMS object attachments. The storage space may also facilitate full personal information management PIM functionality by allowing the storage of e mail contact lists and calendars. The files may be organized in the card according to a file system stored on the card and at least partially maintained by the host accessing the card.

Certain file system operations such as writing a file to a non volatile storage device or memory card can be thought of as transitioning the device from one consistent data state to another consistent data state. A sequence of separate transactions between the storage device and the host device may be required in order to cause the transition between consistent data states. A loss of power to the card possibly caused by removing the card or because of a loss of power to the host device in the middle of this sequence of transactions may easily destroy the consistency of the file system.

For example the host may direct the host device driver to overwrite a block of data in a non volatile storage device. The process of overwriting a block in a non volatile storage device with new data may not be atomic. The term atomicity refers to an operation that is guaranteed to proceed to completion or have no effect at all.

An atomic transaction refers to a set of operations that from the perspective of the host caller appears as a single operation that either succeeds or fails to execute. Overwriting a block may not be atomic because a host device driver may need to issue several separate commands to the non volatile storage device in order to complete this operation. If a power loss occurs during the middle of the sequence of commands the block may be left half written with part of the block containing old data and part of the block containing new data. Consistent data states include the block with fully old data before any overwriting occurs or the block once fully overwritten with new data. However when the block contains a mixture of old and new data it is in an inconsistent data state as it leaves the storage device or card file system in a state which is not the old state before the write operation or the new one after a successful write operation .

In another example a host application may issue a command to the file system to write a new file to the non volatile storage device. To complete this task the file system may issue a sequence of several device driver commands. It is possible that a power loss within the sequence of commands will allow only a few of them to be completed while others will not take place. For example the file might actually be written into the device but its directory entry may not be written so that it might now be impossible to locate the file. A more severe danger occurs when overwriting an existing file with new contents where it might happen that the previous contents are already lost while the new contents have not yet been written a situation which is highly undesirable. An even more severe danger occurs when the integrity of the file system structures themselves are damaged by interrupting a sequence of non atomic operations as the whole device contents may be lost if the file system is not designed to accommodate a power loss scenario during the update of a file allocation table.

Different techniques exist for handling a power loss scenario by providing a ruggedized file system for the non volatile storage device. A ruggedized file system has the capability of staying in or being recovered to a certain known consistent data state until a sequence of operations is completed and a new known consistent data state is reached. Any interruption such as a sudden power loss before reaching the new consistent data state will cause a roll back of the operations which occurred after the previous consistent data state leaving the component in this first state. In other words a sequence of file system operations may end in a new consistent data state or in a previous consistent data state but never in between. Thus a ruggedized file system can survive any sudden power loss without losing its consistency and can be recovered to a consistent data state.

Some techniques to ruggedize a file system have involved periodically copying all or a portion of the file system to another media such as a backup tape. If a failure occurs the file system can be retrieved from the backup copy to recover a consistent data state. This method usually requires manual intervention and or bringing the whole storage system offline when making the backup or restoring from it. Another technique implemented by some file systems does not backup the whole device contents but rather only the metadata of the file system. The backup data copy is stored on the protected device. Yet another technique involves duplicating only a portion of the file system metadata in order to create a backup for ruggedization purposes thus reducing the performance and storage penalty associated with creating the backup.

These methods for achieving file system ruggedness are based on implementing special data structures and algorithms at the file system level. For example these prior methods require the implementation of special snapshot bits for each block entry in the file system allocation table and also require changing how file deletion works to avoid erasing blocks that may still be needed for a previous snapshot of the file system. Using special data structures and algorithms at the file system level has several disadvantages. First if the ruggedized file system is a specially designed one with unique algorithms and data structures utilizing another file system more suitable for a particular application requires giving up the ruggedized features or porting the ruggedized features to the other file system. Second a ruggedized file system using special data structures may be incompatible with other file systems. If a storage device is moved from a system with a ruggedized file system into a system with a non ruggedized file system or vice versa the device contents might be interpreted differently or may even not be readable at all. Third if ruggedized file systems typically employ special algorithms all the time a storage space and performance penalty is incurred even when some operations to the non volatile storage device do not require ruggedness protection.

Another known technique for addressing file system ruggedness includes providing the ruggedness feature to the non volatile storage device not inside the file system itself but rather in the block device driver servicing file system commands. In order to provide ruggedness features the block device driver exports commands that allow the file system to define the current state of the non volatile storage device as a consistent data state and mark the beginning and end of a sequence of commands that may be required in order to cause the transition between consistent data states. In doing so the block device driver may perform a sequence to recover a consistent data state in the event of a power loss. This technique involves modification to the block device driver of the host in communication with a non volatile storage device as the block device driver maintains the requisite data structures to provide ruggedness and recover the non volatile storage device to a consistent data state in the event of a power loss. Further if a power loss event occurs because the non volatile storage device is removed from one host during a transition between consistent data states and the non volatile storage device is subsequently reconnected to another host without a ruggedized block device driver recovery of a consistent data state in the non volatile storage device may not be possible.

In order to address these issues there is a need for an improved technique for file system ruggedness. Described herein is a method and system for file system ruggedness where support is provided within a controller of the non volatile storage device itself instead of within the file system code or block device driver of the host. In one embodiment a non volatile storage device includes an internal memory controller where the controller executes flash management code. The memory controller exports to the host a few special commands to allow the host to execute rugged operations to the non volatile memory by inserting calls of these special commands between calls of the regular device commands. The flash management code running on the controller implements the support for those special commands. The host file system and block device driver simply make use of these special commands and are otherwise relieved of the data structure management required to provide ruggedized operation. For example an exemplary sequence may use one special command to tell the non volatile memory device that the current state is a fallback state or a consistent data state into which the non volatile storage device should recover to if interrupted prior to completion of the sequence. After sending this command the host may perform any operations required by the file system such as deleting writing or overwriting blocks. Finally a second special command may be utilized to tell the non volatile storage device that the atomic sequence is complete and hence a new consistent data state has been reached.

In response to the special commands the controller on the non volatile storage device creates and manages the requisite data structure or flags to mark the memory transactions that have occurred since the last consistent memory state. If the non volatile storage device experiences a power interruption while the host is transitioning between consistent data states the device can recover a consistent data state without the assistance of the host when power is restored to the device. The concept s presented herein can be implemented in various embodiments and this summary includes a number of exemplary embodiments.

In one embodiment there is a method of processing an atomic transaction in a non volatile storage device. A set of commands is received at the non volatile storage device where the set of commands includes two or more write commands and each write command is associated with a corresponding logical block address and includes data. The non volatile storage device processes each of the write commands by writing the data from each write command to a non volatile memory within the non volatile storage device and conditionally associating the data received from each write command with its corresponding logical block address. A command is received at the non volatile storage device indicating the end of a set of commands. In response to this and without moving the data within the non volatile storage device for each logical block address that is associated with a write command in the set of commands the non volatile storage device unconditionally associates with the logical block address the data of the last command of the set of commands conditionally associated with the logical block address. In one implementation a command may also be received that indicates the start of the set of commands prior to receiving the first command in the set of commands.

In another embodiment a method of processing an atomic transaction in a non volatile storage device is provided. The non volatile storage device receives a set of commands where the set of commands contains two or more write commands and each write command is associated with a corresponding logical block address and contains data and a transaction identifier. The transaction identifier can permit the non volatile storage device to associate a received write command with a set of commands where a multi threaded host in communication with the non volatile storage device may interleave other commands between the write commands that are part of the set of commands sent to the non volatile storage device. The non volatile storage device processes each of the write commands by writing the data from each write command to a non volatile memory within the non volatile storage device and conditionally associating the data received from each write command with its corresponding logical block address. When an end of set command is received indicating an end of the set of commands associated with the transaction identifier conditionally received data associated with that transaction identifier is unconditionally associated with the corresponding logical block address. Specifically for each logical block address that is associated with data from a write command in the set of commands the logical block address is unconditionally associated with the data of the last command of the set of commands conditionally associated with that logical block address.

In yet another embodiment there is a method of writing data to a non volatile storage device in a multi threaded system. A transaction identifier is requested and received from the non volatile storage device. A set of commands is transmitted to the non volatile storage device where the set of commands includes two or more commands associated with the transaction identifier and at least one command in the set includes data. An end of set command is transmitted to the non volatile storage device indicating an end of the set of commands associated with the transaction identifier.

In another embodiment there is a method of processing a read command in a non volatile storage device. A read command specifying the requested data is received at a non volatile storage device. In response to the read command data is retrieved according to one of two read procedures. In the first procedure a most recently written version of the requested data not associated with an open transaction is selected. In a second procedure a most recently written version of the requested data is selected. In one embodiment the procedure to be used is defined by a configurable parameter. The selected data is then returned.

Other embodiments and features and advantages thereof are possible and will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. Hence it is intended that the scope of the claimed invention as recited in the claims below will not be limited to the embodiments shown and described herein.

Non volatile storage devices such as removable media cards may be utilized in a variety of host systems including personal computers notebook computers personal digital assistants PDAs various data communication devices digital cameras cellular telephones portable audio players automobile sound systems and similar types of equipment. New host applications are continually being developed to take advantage of the increasing storage capacity of non volatile storage devices. For example individual host applications may read or write MP3 audio files high resolution images files video files documents Multimedia Messaging Service MMS object attachments e mail messages address books and calendars.

In portable systems with removable media cards there is a risk of losing the files stored on the card. Specifically interruption of power to the card during a file operation may leave the file system of the storage device in an unstable or inconsistent data state. For example a power failure of a battery powered device during a write operation to the memory card may leave the file data file system directory structure or both in an inconsistent data state. Similarly if a user removes a non volatile memory card from a host device in the middle of a file write or erase operation the file system of the memory card may become corrupted.

The present embodiments are directed to an improved non volatile storage device that supports a ruggedized file system. Specifically the non volatile storage device provides ruggedness to the file system within the card. A controller in the non volatile storage device supports specialized commands that a host can use to define a consistent data state. The controller supports specialized data structures maintained within the card to track the changes to the data in the storage system that have occurred since the host last established a consistent data state. If a power interruption occurs the controller in the non volatile memory card rolls back the changes to recover the last consistent data state defined by the host. The controller can recover a consistent data state even when reconnected to host devices that are otherwise incapable of utilizing the specialized ruggedization commands for defining a consistent data state because the controller only relies on the host device to define a consistent data state and the controller builds its own data structures to allow it to recover the storage device to a consistent data state without assistance from the host as explained further below. Stated another way a host has the option to utilize specialized commands supported by the memory card to take advantage of the ruggedness features of the card. However the card can recover a consistent data state without receiving any commands or direction from the host. Thus recovery to a last consistent data state is not dependent on any capability or attribute of the host such as host software that advantageously utilizes the ruggedized features of the card.

In the forthcoming explanations it is first assumed that a block is the unit of storage that can be used for all physical media operations read write erase delete allocate and is the data exchange unit between the host computer and the storage device. In addition there is also presented below a more general case where this assumption is not necessarily true for erasing or allocation. As will be explained in more detail below care must be taken to avoid confusion regarding the term block which is used in flash memory literature to indicate the smallest chunk of storage space that can be erased in one operation. This concept is called herein a unit and the term block as used herein refers to the basic chunk of data exchanged between host and storage or its corresponding physical allocated space.

The non volatile storage device may comprise a controller that processes commands from the host over the communication interface a CPU that may store its own data and perform other computational tasks and a non volatile memory that stores data at the direction of the controller and ultimately the host . The controller may be implemented as any combination of hardware or software. In one embodiment the controller is primarily software code executing on the CPU .

The host may comprise one or more applications that may store or access data in the non volatile storage device . In one embodiment one or more users may store or access data in the non volatile storage device using one or more applications . Further applications running on a processor within the non volatile storage device may store or access data therein. From the perspective of the non volatile storage device some or all of these access attempts may appear as coming from two or more separate entities.

The application may rely on an application programming interface API provided by a host file system to perform file level accesses to the non volatile storage device . As each storage device may have its own unique interface and peculiarities which make it very inconvenient to work with it is the common practice to have a software device driver included in the operating system running on the host or running on the bare hardware if no operating system is used with this device driver providing a simplified and standardized interface for other software components wishing to access the non volatile storage device such as the file system . For storage devices used for storing files i.e. disks diskettes etc. but not only for them the interface provided by their device drivers is usually of the type known as block device driver . Such device drivers interact with their clients using blocks of data rather than single bytes. This applies to both input and output operations that is to both reading and writing data to the non volatile storage device . The most common example for a block device is the magnetic disk whose hardware interface is commonly configured for transferring only complete blocks usually called sectors in this context such as 512 bytes or more. It should be emphasized that it is not necessary for the physical storage device to be physically limited to block operations in order to have a device driver presenting a block device interface. For example a battery backed RAM disk is not physically limited to blocks and may physically read and write each of its memory bytes. Still typically its device driver presents a block device interface to the rest of the system so as to be compatible and interchangeable with magnetic disks. Therefore for the purpose of the present embodiments a block device is any device whose driver presents a block device interface regardless of its actual physical structure.

A block device such as the non volatile storage device appears to the host as a linear array of blocks of a certain fixed size. In one embodiment a block comprises 512 bytes of data. Each one of the blocks can be read or written independently of the other blocks using its index or address in the array as shown in . As shown in the figure one practice is to number the blocks from block number 0 to block number N 1 where N is the number of blocks exported by the device driver. The linear array structure depicted in does not necessarily exist at the physical device level. For example a flash disk block device driver also presents this linear array image but internally the physical blocks in the non volatile memory are usually scattered in a random order such that block number 0 may physically be located in the middle or the end due to the writing limitations in flash memory and the possible existence of bad blocks where the controller remaps this linear or logical array image into actual physical blocks on the media . It should also be understood that the block device driver has no knowledge of the contents put into its blocks by the upper software layers.

Referring back to a file system FS software layer may exist on top of the device driver . A file system is a software component which provides further abstraction from the physical device by enabling the application programs to interact with the storage device using only the concept of files a concept which is much more natural and convenient to the typical programmer or user. The file system achieves this abstraction by organizing the user data on the block device into some logical structure and associating the blocks containing a file s data with the file s attributes i.e. file name creation time access permissions etc. . For that purpose the file system stores metadata in the non volatile memory which is not directly visible to the user. The metadata contains the file system internal bookkeeping information with which it is able to trace and access the user files stored in the non volatile memory . For example the Microsoft DOS FAT12 file system which is one of the simplest file systems commercially available stores on the storage device a boot sector containing some basic parameters allowing the location of the other metadata structures within the first device block one or more copies of the File Allocation Table FAT which is the allocation map of the device and a root directory structure for locating files by name. The application programs interact with the file system on the file level by issuing commands such as open file delete file write file etc. being completely ignorant of the underlying block structure. There are many file systems in use today greatly differing in their internal structures and characteristics. In many cases such as with the Linux operating system an operating system even provides several file systems to its users and they may choose the one most suitable for their needs.

The embodiments rely on the common concepts of logical blocks physical blocks and chains of blocks . shows an exemplary non volatile memory storage organization and address mapping maintained by the controller in the non volatile storage device . The device driver interacts with logical blocks and the host perceives the storage device as having a certain number of them N in the case of . The logical blocks are not actual storage but rather are associated with actual physical block storage. Internally the memory contains a larger number of physical blocks P in the case of . When the host commands a write or read operation to logical block the controller remaps the logical block specified via a logical block address to a physical block within the non volatile memory . This distinction between logical and physical blocks is quite well known in the prior art. Many flash memory disk management systems are based on such an arrangement. However in flash disks the need for such an arrangement is the result of the unique features of flash memory such as the inability to write over an already written block without first erasing it or the existence of bad blocks in the physical media. The embodiments disclosed below may require such an arrangement and thus a controller implemented in accordance with the one of the embodiments employs this structure even if it does not need it for other reasons.

In the embodiments it must always be the case that P the number of physical blocks is greater than N the number of logical blocks. In a non ruggedized non volatile storage device one physical block may be allocated per logical block. In contrast this is theoretically impossible in a ruggedized non volatile storage device as more than one physical block may be conditionally associated with a logical block to allow the recovery of a consistent data state in the event of a power loss to the non volatile storage device . Once the controller is told via a command received from the host that a certain state is the current fall back state or consistent data state when subsequent commands are received for overwriting logical block addresses with new data the controller must keep both the old data in case a recovery to the previous state is required and the new data in case the command set sequence completes successfully and a transition to a new consistent data state occurs on the non volatiles storage device . This means that some physical blocks must be set aside to contain these alternative copies of conditionally stored data associated with a logical block address written during the command set sequence. Hence there must be more physical blocks than logical ones. The number of extra physical blocks available in excess of the number of exported logical blocks can be fixed at the time that the file system is created i.e. when formatting the device or can be dynamically changed during operation. Setting the number to a large value has the advantage of allowing a large amount of new data to be written to the non volatile storage device before transitioning from one consistent data state to the next but has the disadvantage of reducing the number of logical blocks that can be exported for use by the host thus reducing the logical size of the storage device . Setting the number to a small value increases the logical storage size but limits the amount of write operations that can occur before a new consistent data state is established by the host .

While there is a requirement that the number of physical blocks is greater than the number of logical blocks for ruggedization many types of mapping between logical and physical blocks are possible. For example the controller may assign the first N physical blocks to match the N logical blocks with a straight forward one to one mapping with the last P N physical blocks serving as extra blocks for the alternative copies of data stored while transitioning between consistent data states. Another implementation may create a partial or full random mapping where any physical block may be assigned to any logical block. Information on the mapping of logical to physical blocks may be stored within the controller or in the non volatile memory accessible to the controller .

As briefly mentioned above ruggedization may require the controller to map one logical block address to more than one physical block. The group of physical blocks corresponding to the same logical block is called a chain of blocks or simply chain in the current description. A chain is an ordered set of blocks meaning that it is possible to determine the order in which the individual blocks were put into the chain. A variety of implementations are possible that satisfy the above requirement. For example the chain may be constructed using forward pointers backward pointers or any other data structures. Many flash memory disk management systems are based on such a block chaining arrangement. The operations required for updating a chain such as inserting a new block at the end of a chain or removing the oldest block from the beginning of a chain can be done safely and atomically using methods known in the prior art. Additionally depending on the embodiment a chain may have a predetermined maximum length or may be unlimited in length. In one embodiment explained in further detail below the controller may map a logical block address to no more than two physical blocks which is the absolute minimum required for supporting ruggedization In another embodiment also explained below the controller may allow mapping of a logical block to larger groups of physical blocks. In other words chains may be limited to length of no more than two physical blocks or longer sequences of physical blocks may be allowed.

According to a first embodiment the built in ruggedized features of a non volatile storage device can have practically no extra storage requirements on the non volatile memory for overhead data above what is required for maintaining the chains. are diagrams illustrating an exemplary sequence of logical to physical mapping of memory in the non volatile storage device when transitioning between two consistent data states.

The non volatile storage device may receive a request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after the first write request to the logical block address associated with logical block i following a consistent data state is processed. As can be seen in the figure the original data is not overwritten as the original data may be needed if a power loss requires the controller to recover the consistent data state shown in . Instead the controller writes the data to a free physical block and then adds the newly written physical block to the set of physical blocks associated with the logical block address corresponding to the logical block that is to the physical blocks chain of the logical block .

The non volatile storage device may receive additional write commands from the host . As shown in the controller processes additional commands to write data to logical block addresses associated with blocks i and k . The controller assigns logical blocks j and k a second physical block containing the new data specified in the received write command. The three newly written blocks reflected in may define a useful sequence of commands. For example the sequence of commands or the command set may be for the creation of a new file the resulting update of a directory structure and the resulting update of a File Allocation Table. These three operations are typically combined together by a file system in response to a command received at the file system from an application running on the host . As stated before all of these commands in this set can be thought of as an atomic transaction from the perspective of the host all of the commands in the set of commands need to execute or none of them should execute. A situation where only some of these commands are executed and reflected in the non volatile memory after a power loss is highly undesirable as it may cause a corruption of the file system state. Providing support for atomic transactions may require the capability to roll back or undo some of the commands of the set when a power loss or other event prevents all of the commands in the set from executing.

The non volatile storage device may receive a subsequent request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after an additional write request is received this time a second command to write the logical block address associated with logical block i with new data. This second write operation occurs before the host informs the controller that a new consistent data state has been reached. In this case the controller does not allocate a third physical block to the chain associated with logical block i to accommodate the new data. Rather because alternative physical block already exists in other words because the chain length for logical block i is already two the contents of the alternative physical block is overwritten with the newly received data shown in the figure as New Data 2 . There is no need to store the overwritten data either the non volatile storage device is transitioned to the next consistent data state where New Data 2 is the value of data stored at logical block address i or the controller recovers the previous consistent data state where Original Data as shown in the figure is the value of data stored at logical block address i .

The host may inform the non volatile storage device that all of the write commands associated with a set of commands have been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached. In response to this command the controller examines each logical block address for the existence of a physical blocks chain with a length of two. For each such chain the controller drops the first physical block removing the association between it and the logical block address and keeps only the second one. Thus the conditional association between the second physical block in the chain and the logical block address becomes an unconditional association. After all of the logical block addresses are examined a new consistent data state is established reflecting all of the write command operations performed in transitioning between the old consistent data state and the new consistent data state. By comparing and it is evident that the logical to physical mapping of blocks has completed a full cycle transitioned from one consistent data state to the next where a consistent data state has one physical block associated with a logical block address . The whole sequence of accumulating changes through write commands in a set of commands until the host sends an end of set command to define a consistent data state can be repeated again.

If the non volatile storage device suffered a power loss during the sequence shown in the controller when supplied with power again may recover the consistent data state shown in . When the controller initially starts from a state of being powered off or disconnected from an operating voltage supply it scans the state of mappings from logical block addresses to physical blocks. In one embodiment this scanning is performed without receiving any special command or direction from the host . Stated another way the controller performs the scanning operation automatically upon restoration of power to the card. This mapping structure may be stored in non volatile storage in the controller or in the non volatile memory . Each logical block address is examined for the existence of a physical blocks chain with a length of two. In the case where such a situation is detected the controller drops the last block in the chain and keeps only the first one. This operation is exactly the opposite of the one described above for creating a next consistent data state. As a result of the recovery procedure the mapping of logical addresses to physical blocks is recovered to the mapping shown in the last consistent data state. If a power loss occurs anywhere in time between the states of not inclusive this wake up procedure will bring the system back to the state of . However if the power loss occurs after the state of is reached there is no need to go back to the data state shown in . Any recovery following this point will be to the consistent data state shown in state until another consistent data state is created.

If a read operation occurs during the sequence shown in one of two read procedures can be followed. Referring to if the host sends a read command to the non volatile storage device to read data at an address associated with logical block j the controller may return the data shown as Original Data associated with the last consistent data state or may return the most recently written data to that address shown as New Data in the figure. In one embodiment which data the controller returns may be set by a parameter in the controller configurable by the host . Once a consistent data state is reached through recovery back to the last consistent data state shown in or to the new consistent data state shown in there is no choice of data to return as only one physical block is associated with the logical block address.

According to a second embodiment the built in ruggedized features of a non volatile storage device can have minimal extra storage requirements on the non volatile memory for overhead data above what is required for maintaining the chains. In this embodiment the controller allocates one bit of storage hereinafter called the ruggedness bit or the R bit of the block also referred to as the flag value for each physical block in the non volatile storage device . In many memory architectures this is easily implemented. For example in a flash memory disk based on NAND type flash devices each block has a spare or extra storage space attached to it which may be used for storing this bit. In such memories each block is contained in a page that is the basic unit for writing or reading where a page contains either one or more physical blocks. An extra area is physically associated with each page and a portion of this extra area may be allocated to each of the physical blocks in the page thus providing the space for the R bit. In other types of storage media which do not provide such built in extra storage the driver may set aside some portion of the physical storage space for storing the R bits of all P of the physical blocks that can be mapped to the N logical block addresses.

The non volatile storage device may receive a request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after the first write request to the logical block address associated with logical block i after a consistent data state is processed. In response to the write request the controller does not overwrite the original data in the physical block associated with logical block i as it may be needed if a power loss or other failure during the set of write commands requires the controller to recover the consistent data state shown in . Instead the controller maps a physical block to the list of physical blocks mapped to logical block i that is to the physical blocks chain of the logical block . Stated another way this newly added block is conditionally associated with the logical block address for logical block i because the association can be eliminated if a recovery to a prior consistent data state is needed. The controller then writes the new data from the received command into the newly added physical block. The R bit of the block containing the original data is read and the R bit or flag value of the newly added physical block is set to the toggled version of R bit or flag value of the physical block containing the original data. In the example of the original block has R 1 and therefore the new physical block is marked with a flag value R 0. In another example not shown in the figure the original block has R 0 and therefore the new physical block can be marked with a flag value R 1.

The non volatile storage device may receive additional write data commands from the host . As shown in the controller process additional commands to write data to logical block addresses associated with blocks i and k . The controller assigns logical blocks j and k a second physical block containing the new data specified in the received write command and again the R bits of the new blocks are the complements of the R bits of the physical blocks they are replacing if a new consistent data state is reached. In the R bit or flag values of the new blocks for logical blocks i and j are different. As was stated above the R bit value by itself is arbitrary its importance is in relation to the R bit value of the physical block it potentially replaces.

The non volatile storage device may receive a request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after an additional write request is received this time a second command to write the logical block address associated with logical block i with new data. At this point the host has not informed the non volatile storage device that a new consistent data state has been reached. In contrast with the first embodiment shown in with a new physical block is conditionally associated with the logical block address associated with logical block i . Thus three physical blocks are in the chain associated with logical block i . The controller then writes the data received in the command shown as New Data in the figure to the newly associated physical block. The controller sets the R bit of this newly allocated block to complement the R bit value of the block containing the initial data. In other words the new R bit is made equal to the R bit of the previous written physical block in its chain. This step in effect extends the chain of blocks mapped to the corresponding logical block while making sure all blocks in the chain containing data still not committed to a consistent data state have the same R value which is different than the R value of the first block in their chain.

The host may inform the non volatile storage device that all of the write commands associated with a set of commands have been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached. The controller examines each logical block for the existence of a physical blocks chain where the R bit value toggles or changes somewhere along the chain. In the case where such a situation is detected all physical blocks preceding the R value change to the left of the change point in are removed from their chains. The remaining physical blocks are unconditionally associated with the logical block address. In one embodiment the controller may unconditionally associate the physical blocks with the logical block address without moving the data received in the set of commands that is stored in the physical blocks. As a result a new consistent data state is established reflecting all operations performed before this new state. The state shown in is similar to that of and the sequence of accumulating changes through write commands in a set of commands continues until the host defines another consistent data state is defined can now be repeated.

One noticeable difference between is that in one logical block address has more than one physical block assigned to it even after a consistent data state has been established a condition that does not exist in . However as can readily be seen this has no effect on the process that the controller follows when processing write commands in a command set sequence the steps leading from to C D and E and the same methods are still applicable even if the data state shown in is the starting point. more accurately reflects the general case of a consistent data state in this embodiment where a logical block may have more than one physical block assigned to it even after a consistent data state has been established. Stated another way is a simplified example. In this embodiment the most general case of a chain of blocks is when the chain has a first group of one or more blocks all having the same R bit and all written prior to establishing the last consistent data state followed by zero or more blocks of a second group all having an R bit or flag value which is the complement of the first group R bit and all written after establishing the last consistent data state. The act of establishing a next consistent data state is achieved when there are such two groups of blocks by dropping the physical blocks of the first group and keeping the physical blocks of the second group.

In the event of a power loss from a power shutdown or an interruption of power to the non volatile storage device before a new consistent data state has been established the controller may recover a prior consistent data state when power is restored. When the non volatile storage device is powered again with an adequate supply voltage the controller scans the mapping state of logical blocks to physical blocks. In one embodiment this scanning is performed without receiving any special command or direction from the host . In this case the controller performs the scanning operation automatically upon restoration of power to the card. Each logical block address is examined for the existence of a physical block chain where the R bit value changes or toggles somewhere along the chain. The controller traverses a physical block chain in the order that the physical blocks were added to the chain from earliest in time to latest in time. If the controller detects this toggle situation the physical blocks following the R value change to the right of the change point in the are removed from the chain. This operation is exactly the opposite of the one described above for creating a next consistent data state. Once the controller has examined all logical block addresses all changes occurring after the last consistent data state will be removed. If a power loss occurred anywhere in time between the states of this power on procedure will restore the non volatile storage device back to the state of . As in the first embodiment if the power loss occurred after the state of has been reached there is no need to return to consistent data state shown in . Rather if the controller needs to recover a consistent data state it will recover to the state shown in until another consistent data state is established.

If the host sends a read command to the non volatile storage device during the sequence shown in one of two read procedures can be followed. Referring to if the host sends a read command to the non volatile storage device to read data at an address associated with logical block i the controller may return the data shown as Original Data associated with the last consistent data state or may return the most recently written data to that address shown as New Data 2 in the figure. In one embodiment which data the controller returns may be set by a parameter in the controller configurable by the host . Once a consistent data state is reached through recovery back to the last consistent data state shown in or to the new consistent data state shown in there is no choice of data to return as only the data associated with the consistent data state will be returned in response to a read from that the logical block address.

According to a third embodiment the built in ruggedized features of a non volatile storage device can have somewhat more storage requirements in the non volatile memory for overhead data above what is required for maintaining the chains but is more flexible than the other embodiments. In this embodiment the controller allocates storage for one numeric field for each physical block hereinafter called the version value or field or generation field or the gen field of the block for storing the consistent data state associated with the physical block. This field may be an 8 bit byte a 16 bit word or any other convenient size. The considerations of where to store these fields are similar to the ones mentioned for the R bits or flag values of the previous embodiment. For example the fields may be stored in the extra storage area of NAND flash blocks or in a specially set aside portion of the physical storage space. Additionally the controller maintains a version or generation field that contains a value associated with the current consistent data state of the non volatile storage device . This value may be stored in non volatile storage in the controller or in the non volatile memory .

In the controller logical to physical block address mapping state is shown after the first write request to the logical block address associated with logical block i following a consistent data state is processed. As in the other embodiments the original data associated with logical block address i is not overwritten as the value may be needed if the controller recovers a consistent data state in the event of a power loss during the transition between consistent data states. Instead the controller conditionally associates a free physical block to the logical block address by mapping the logical block to the newly associated physical block that is to the physical blocks chain of the logical block . The data received in the write request is written to the newly associated physical block and its generation field is set to the current value of the global generation which in this case is G 1. The global generation is not changed at this stage causing block i to have a generation value equal to the global generation counter value.

The non volatile storage device may receive additional write commands from the host . As shown in the controller process additional commands to write data to logical block addresses associated with blocks j and k . The controller assigns each logical block j and k a second physical block containing the new data specified in the received write command. The generation fields of the new conditionally associated physical blocks are set to the current value of the global generation counter.

The non volatile storage device may receive another request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after an additional write request is received this time a second command to write the logical block address associated with logical block i with new data. As in the second exemplary embodiment a new free physical block is added to the mapping of the logical block extending its chain to more than two blocks and the newest data shown as New Data 2 in the figure is written into it. The generation field of this newly allocated block is again set to the current value of the global generation counter. In other words the new generation field is made equal to the generation field of the previously written block in its chain. This step in effect extends the chain of blocks mapped to the corresponding logical block while making sure all blocks containing data still not committed to a consistent data state have the same generation value equal to the current global generation counter value but different than the generation of the first block in the chain.

The host may inform the non volatile storage device that all of the write commands associated with a set of commands have been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached. In response to the end of set command from the host the controller simply increments the controller s global generation value by one such that the global generation value will now equal G 2 as can be seen in the . The chain of blocks for each logical block address remains unchanged. As a result a new consistent data state is established that reflects all operations performed before this new state was reached. The data state shown in is similar to that of as again the relationship generation

If the an unexpected power loss occurs such as a shutdown or an interruption of power to the non volatile storage device in the middle of a sequence of write commands in a command set to transition the non volatile storage device between consistent data states the controller may subsequently recover the last consistent data state once power is restored to the non volatile storage device . The controller will do this by first reading the global generation value and then scanning each logical block address for the existence of physical block chains with at least one block having a generation value equal to the global generation value. If this situation is detected all conditionally associated physical blocks having that generation value are removed from the respective chains. When this process is completed for all logical block addresses a consistent data state has been recovered because the controller has removed all of the change data written to physical blocks after the last consistent data state by removing the conditional association between these physical blocks and the corresponding logical block address. If a power loss occurs anywhere in time between the states of not inclusive this procedure will recover the consistent data state of . However if the power loss occurred after the state of was reached there is no longer a need to return to the consistent data state shown in . Any recovery following this point will be to the consistent data state shown in until another consistent data state is created. In one embodiment this recovery process is initiated by the controller without receiving any special command or direction from the host . In other words the controller performs the scanning operation automatically upon restoration of power to the card.

As in the other embodiments if the host sends a read command to the non volatile storage device during the sequence shown in one of two read procedures can be followed. Referring to if the host sends a read command to the non volatile storage device to read data at an address associated with logical block i the controller may return the data shown as Original Data associated with the last consistent data state or may return the most recently written data to that address shown as New Data 2 in the figure. In one embodiment which data the controller returns may be set by a parameter in the controller configurable by the host . Once a consistent data state is reached through recovery back to the last consistent data state shown in or to the new consistent data state shown in there is no choice of data to return as only the data associated with the consistent data state will be returned in response to a read from that the logical block address.

This embodiment has a few characteristics that differentiate it from the previous embodiments. First as previously mentioned this embodiment requires the generation state the global generation value to be stored in non volatile memory in the non volatile storage device with updates to this state value taking place in an atomically safe way. Methods for accomplishing this update task in a safe atomic manner are well known in the prior art. For example information can be safely updated on the media by using two copies of the data to be protected plus checksum fields plus a field that is incremented per update. This method is fully safe against any possibility of power loss. While this method achieves ruggedness in a file system and not in variables maintained by the controller as is the case here it may be used by the controller to update the generation count value. Second in order for the embodiment to keep working correctly for long periods of time and long sequences of consistent data states it will eventually require a clean up operation. This will happen when the global generation value will no longer be able to be incremented without violating the arithmetic assumptions of the model. For example if an eight bit field is used to store the generation count value the global generation value might wrap around from 255 to zero making comparisons with the generation value stored in the physical blocks difficult if not impossible to perform correctly. As a result when the controller attempts to recover an inconsistent data state physical blocks may be removed from a chain because of an incorrect comparison result between a physical block generation value and a wrapped around global generation value. The clean up operation may be performed in many ways such as bringing all chains to the generation of the currently highest generation of any existing chain thus making the relation generation global generation 1 correct for all blocks. This can simply be achieved by extending each chain with a copy of its last block. In the example of an 8 bit counter such procedure will give the controller the freedom to run through 255 the maximal number of generations before having to perform another clean up. Obviously the more bits used to store the generation value globally and in each physical block the less frequent is the need for clean up.

It was mentioned above that the number of logical blocks N is less than the number of physical blocks P available in the storage device in order to provide storage space P N total physical blocks for data written to the non volatile storage device when transitioning between consistent data states. For the exemplary embodiments described thus far it may be possible to receive a write command that cannot be processed because all of the P N physical blocks available for transitioning between consistent data states are already in use. As the updating of physical blocks following the establishment of a consistent data state requires storage space for storing both the previous and new data it is possible that if the host sends too many write commands before sending a command establishing the next consistent data state the number of available physical blocks will be exhausted. There is a trade off for the controller design in deciding how many logical block addresses are exported compared to the amount of physical blocks in the non volatile memory . With fewer logical blocks N more space is set aside for chaining and the more operations can be accommodated when transitioning between consistent data states. On the other hand holding a large number of physical blocks P N in reserve for this purpose limits the logical space available to the host for actual storage of data. On the other hand if P N is a relatively small number of physical blocks hidden to the host the storage device will have more available storage capacity as viewed by the host but will be able to accommodate fewer write commands data when transitioning between consistent data states. If the controller detects that all P N physical blocks available for rugged write operations are in use and another write is received before a new consistent data state is established the controller may reject the write operation indicate an error condition to the host and recover the prior consistent data state. In response to receiving this error the host may reattempt the sequence of write commands but reduce the size of the set of commands proceeding in smaller steps between consistent data states possibly after making more room on the media by deleting unneeded data and initiating whatever compacting tools the system provides.

As mentioned above all explanations so far assume that a physical block can be read written erased or allocated independently of any other physical block. While this assumption is correct for magnetic disks it is not necessarily correct for all types of storage media. For example in NAND type flash memory the minimal size for an erase command is not a single block but a group of many adjacent ones hereinafter called a unit with typically 128 or 256 blocks in a single unit. As mentioned above care should be taken to avoid confusion in terms as in flash memory data sheets it is common to use the term page for what we call block here or for a group of a few of our blocks that are written and read together while the term block in those data sheets refers to what we call unit . Consequently in such devices it is not efficient to make storage allocations for single blocks but only for complete units. However any of the exemplary embodiments shown above are equally applicable to the case where allocation of blocks must be done in groups with simple adaptations that will be obvious to those skilled in the art. In the embodiment that follows the applicability of the second embodiment described above toggling an R bit value associated with a physical block to indicate the data changes during transitions between consistent data states is demonstrated for this type of storage device. Hereinafter such non volatile storage device in which erasing must be done in units rather than single blocks is called a unit based device.

The non volatile storage device may receive a request to write data to one logical block address. In the controller logical to physical block address mapping state is shown after the first write request to the logical block address associated with logical block k following a consistent data state is processed. In typical response to the write request the controller may add a physical block to the chain of physical blocks associated with logical block k and set the new physical block s R bit accordingly. However in this case there is no need to make additional physical block allocation as a free physical block is already available in the chain and can readily be used for the purpose. As shown in the figure the state of this physical block is changed from Free to In Use to indicate that now it contains valid data.

The non volatile storage device may receive another request to write data to a logical block address where all conditionally associated physical blocks are in use. In the controller logical to physical block address mapping state is shown after the second write request to the logical block address associated with logical block i following a consistent data state is processed. This is very similar to the mapping shown in except that a free physical block is not available for logical block i and a new physical unit shown in the figure as physical unit is conditionally associated by allocating the physical block and adding it to the chain. The physical blocks chain of logical block i gets its new physical block with its associated R bit and In Use state field but all other blocks sharing the same unit also get extra physical blocks marked as Free added to their chains.

The host may inform the non volatile storage device that all of the write commands associated with a set of commands have been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached. As previously explained the controller establishes a new consistent data state by looking for R bit value changes along the physical block chains and dropping the blocks left of those change points. shows how this is implemented in unit based media. In this case the action of dropping a physical block in a physical unit two blocks in chain i and one block in chain k involves setting the state of that physical block to Ignored . Such a state means the controller should ignore the existence of the block when traversing the chain for subsequent operations. After each logical block address is examined by the controller to perform this process a new consistent data state is established reflecting all operations performed in transitioning to the new consistent data state.

As in the previous embodiments the controller in a unit based non volatile storage device may be required to recover a consistent data state when a sudden power loss or other power interruption takes place during a sequence of write commands that transition the device between consistent data states. shows the controller logical to physical block address mapping state the controller recovers a consistent data state. As previously explained in the second exemplary embodiment controller recovers a consistent data state by looking for R value changes along the chains associated with each logical block address this time dropping the blocks to the right of the change points in the R value bits. As shown in the figure the physical blocks to be dropped one block in chain i and one block in chain k again are assigned to a state of Ignored . The end result is logically equivalent to the state of which is the previous consistent data state. Even though there is one more physical unit already allocated in from the point of view of the controller and the host the two figures represent identical data states.

As in the other embodiments if the host sends a read command to the non volatile storage device during the sequence shown in one of two read procedures can be followed. Referring to if the host sends a read command to the non volatile storage device to read data at an address associated with logical block i the controller may return the data contained in one of two physical blocks shown as In Use the one associated with the last consistent data state or the one containing most recently written data to that address. In one embodiment which data the controller returns may be set by a parameter in the controller configurable by the host . Once a consistent data state is reached through recovery back to the last consistent data state shown in or to the new consistent data state shown in there is no choice of data to return as only the data associated with the consistent data state will be returned in response to a read from that the logical block address. Stated another way there is only one physical block with the state In Use associated with a logical block address when a consistent data state is reached and all of the other physical blocks may be ignored by the controller because they are marked Free or Ignore. 

As illustrated in and the accompanying text the second embodiment toggling an R bit value associated with a physical block to indicate the data changes during transitions between consistent data states can be utilized in unit based non volatile storage devices. The first exemplary embodiment allocating only one extra physical block per logical block address written to during transitions between consistent data states and the third exemplary embodiment generation field for each physical block may be similarly adapted to unit based non volatile storage devices. Thus all adaptations to accommodate unit based media are considered to be within the scope of the embodiments.

a. Storage of logical control state information on the storage media The first two embodiments are effectively stateless in the sense that there is no global not block specific logical control state information written to the storage media when establishing a consistent data state and the controller does not rely on such information for restoring the media contents during start up. The third embodiment generation field for each physical block does not share this feature as it updates the global generation field for each subsequent consistent data state. The implementation of the controller supporting a stateless ruggedization may provide a simpler and safer solution as it is usually the case that the updating of control state information is a vulnerability point in any storage management system and special measures must be taken to avoid data corruption in case a power loss occurs when writing such information.

b. Amount of accumulated changes The first embodiment using one extra physical block per modified logical block address to store changes while transitioning between consistent data states allows the accumulation of an unlimited number of changes to the non volatile storage device when transitioning between consistent data states while retaining the ability to roll back to a previous consistent data state. This can be achieved by making the number of logical blocks N equal to half the number of the available physical blocks P. In such a case there are enough physical blocks to provide each logical block address with one physical block storing the current consistent data state and a conditionally associated physical block storing data received after the current consistent data state has been established. In the extreme case all logical block addresses in the non volatile storage device can be written after a consistent data state has been established and the full contents of the non volatile storage device may then still be rolled back to its previous state. In this configuration the controller can theoretically accommodate an unlimited sequence of commands and should never return a Not Enough Space error response because the number of physical blocks P N available for the storage of data during the transition between consistent data states has been exhausted. Achieving such a feature may be much more difficult in the other embodiments which allow for chains longer than two blocks.

c. Ability to overwrite in place The first embodiment using one extra physical block per modified logical block address to store changes while transitioning between consistent data states is applicable only to storage devices which support overwriting blocks in place. While this is acceptable in magnetic disks this is not the case in most solid state memory devices such as flash memory disks. The other embodiments have no such limitation.

d. Amount of effort in establishing a consistent data state The first two embodiments require the controller to clean up the block chains whenever a new consistent data state is defined. This is so because these embodiments require the removal of any trace of previous consistent data states before the new consistent data state is safe in the sense that controller will recover a consistent data state on the next power up. If many chains have accumulated changes the clean up operation may be a lengthy operation because they all accumulated changes since the previous consistent data state. The third embodiment generation field for each physical block on the other hand allows leaving older generation data on the non volatile storage device without clean up and therefore makes the establishment of a new consistent data state very fast. This advantage is especially useful when many consistent data states are created during a session without the time to take down and clean up the system when a new state is established a scenario that is very common in most file systems.

e. Support for more than one last consistent data state As mentioned above the third embodiment generation field for each physical block is unique in that it allows keeping older generation consistent data states. This makes it possible to do a roll back not just to the last consistent data state but to some older one. Therefore it is possible for the controller to provide the host with a command to roll back N generations from a current consistent data state after which the driver will decrement its global generation value by N and simulate a power up sequence which will delete all traces of the last N generations. The other embodiments do not support this functionality.

The non volatile storage device containing a controller implemented according to an exemplary embodiment can be accessed by applications on a host in several different ways 

1. A new file system may be implemented or an existing file system may be modified to take advantage of the special commands provided by the controller for rugged operation. This can easily be done inside the file system software by surrounding each sequence of non volatile storage device access operations that should be an atomic transaction i.e. creating a file adding its directory entry updating the file allocation tables with calls to the special commands supported by the non volatile storage device to establish a consistent data state. This will assure that all host command sequences will end with either all operations completed and thus a new consistent data state or none completed and thus a recovery to the existing consistent data state . This makes the file system commands into atomic transactions as seen by application programs making it a ruggedized file system.

2. A host software application can effectively achieve file system ruggedness even if the file system it is using does not support it and cannot be modified. This can be done by the application surrounding the calls to the file system i.e. create file by calls directing the device driver to send commands to the non volatile storage device to establish a consistent data state before and after the call to the file system or to indicate the start and end of a new set of commands that will transition the non volatile storage device to a new consistent data state. In this way even though the file system is not even aware of the ruggedness properties of the non volatile storage device its operations become atomic. This approach puts the burden on the application programs but it can advantageously be applied to any existing file system without modification. In this approach the host operating system must allow the application the ability to transfer its commands to the device driver but such mechanism is quite commonly available in many existing file systems. For example the Input Output Control IOCTL command is available in many host systems which enables the passing of driver specific commands through the file system to a device driver . It should be noted that some file systems employ buffering techniques in which case they might not immediately generate all device driver commands upon processing a file system command thus potentially jeopardizing the atomicity property achieved by the method described above. However this risk can be eliminated if the host application always issues a flush command to the file system to copy the contents of the host buffers to the non volatile storage device before sending the command to the device driver for establishing a consistent data state. All file systems that employ buffering also provide some support for a flushing command. Therefore it should be understood whenever a command for establishing a consistent data state is sent it may be preceded by a flush command if file system buffering is employed.

3. A software application can avoid utilizing a file system and instead interact directly with the device driver in order to utilize the ruggedness features of the controller exported through the interface to the non volatile storage device . This approach even though possible may be very inconvenient to use and thus will most probably be used very rarely if at all.

The ruggedization embodiments presented so far are mainly applicable to systems using a single thread of execution where during system operation the file system goes through a series of easily identified states. Some of those states are not consistent while others are fully consistent in the sense that no application level operation is partially complete. Such a model of software operation is quite common in simple system applications making the previous embodiments very useful. On the other hand the ruggedization embodiments described above may not be applicable to more advanced models of software operation such as to systems employing multi threading or multi tasking. As will be apparent from the explanation below in such systems the concept of a consistent data state is not as useful as before and the definition we used so far for a ruggedized system must be modified to fit the particular requirements of such systems.

An example of a multi tasking system with two independent tasks running concurrently is used to illustrate this each of them interacting with the device driver whether through the file system or directly . For the purpose of this example it is assumed that the controller employs the methods of the second embodiment toggling an R bit value associated with a physical block to indicate the data changes during transitions between consistent data states as shown in and the accompanying text but the conclusions from the example are applicable to all other embodiments presented above.

In the controller logical to physical block address mapping state is shown after task writes to logical block address k . Again this write command results in extending the physical block chain associated with logical block k with data that is conditionally associated with the logical block address.

The host may inform the non volatile storage device that all of the write commands associated with the set of commands from task has been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached because task has been completed. Upon receiving such command the driver removes all blocks that are to the left of an R value change point in their chain. In this example this will result in the original data being removed from physical block chains associated with logical block addresses i j and k leaving each of them with only the new data. While this operation is correct for task and its data blocks i and k the command incorrectly caused the controller to associate data written by commands in the unfinished set of commands from task by unconditionally associating the new data of logical block j and making it part of the newly defined consistent data state. This is an undesired effect that can readily be seen by considering what would happen if a power failure occurred before all of the write commands associated with task were received and before task reached a new consistent data state. The controller cannot recover logical block address j from the state in to the consistent data state in . The end result is an incorrect recovery to a consistent data state and an inconsistent data state for task .

One possible approach for avoiding the difficulties of the multithreaded example would be to allow only one task to be active at any point in time. This is equivalent to allowing only one task access to the device with all other tasks locked out until the current task completes its sequence of operations and releases the device. While such approach is common with other computer peripherals that cannot support multitasking such as modems and many types of I O devices it is totally unacceptable for a storage device that may be simultaneously accessed by multiple host applications as this would effectively lock out a software application from its data and files for extended periods of time as might happen when the current task has to complete a long transaction .

Thus a limitation of the previous embodiments is evident and must be addressed when the non volatile storage device is in communication with a multi threaded host system. While in a single threaded system ruggedness can be thought of in terms of consistent data states where it is assumed that a set of write commands moves the non volatile storage device contents from one consistent data state to another one. The example of shows the limitations of this model when multitasking systems are accessing the non volatile storage device . Even though each task considers itself as moving between consistent data states the non volatile storage device as a whole might not have consistent data states at all because at any point in time there might be one or more tasks which are not at a consistent data state and there is no guarantee that all tasks will define consistent data states at the same time.

Therefore another embodiment that operates in the more complex multitasking case must necessarily incorporate a different definition for ruggedness. In a multithreaded environment a transaction is a sequence of commands that are preferably logically grouped together into one atomic operation. There is no necessity for the operations of a transaction to be contiguous. In other words other operations that are not part of that same transaction may occur in the middle of the sequence between the operations that make up a transaction. These other operations may be parts of other transactions. Because of this possibility that the non volatile storage device may receive intermixed or interleaved commands associated with multiple transactions there is a need for a way for the controller to associate an operation such as a received write command with a specific transaction. This is preferably achieved by associating each transaction with a transaction handle or transaction identifier which may simply be a numeric value used by the controller for identifying the transaction. Thus a controller capable of ruggedized operation in a multithreaded environment can be defined as having the capability to execute sets of commands grouped into transactions and guaranteeing the atomicity of each transaction. Such a controller guarantees that any interruption such as a sudden power loss will cause a roll back of any transaction open at the time of interruption an open transaction is defined as a transaction which was started but was not yet declared completed by the host canceling the effects of each such open transaction. In other words a transaction may end up fully completed or fully cancelled but never in between. In still other words the controller can recover from a sudden power loss and never leave the storage contents of the non volatile storage device reflecting the product of a partially completed transaction.

The general concept of a transaction is well known in the prior art. For example transactions have been used to maintain data integrity in large and distributed databases. However all known prior art technologies use transactions that are at the higher software layers of database applications file systems or device drivers. In contrast the embodiments explained below employ transaction identifiers within the controller of the non volatile storage device thus achieving much better efficiency. Other methods of recovering from power failure and for backtracking in time to previous safe points disclose an application where there is an automatic software engine running in the background of a host software system which can roll back the state of a storage device in time with a blurred border line between the file system and the engine.

In the embodiments below a controller within a non volatile storage device receives a request from a host for a transaction identifier. In response the controller issues an unused transaction identifier. The host then uses this transaction identifier when sending write commands associated with a set of commands that define a transaction. The controller may utilize the transaction identifier to distinguish data received from different tasks or threads. At the end of a task or set of commands the host may transmit a command to the controller indicating that the set of commands associated with the transaction identifier are complete. In response the controller may unconditionally associate the data received in write commands having that transaction identifier with their corresponding logical block addresses. In the event of a power loss the controller may consult a list of unfinished transactions and remove conditionally associated data stored in physical blocks assigned to logical block addresses in unfinished transactions.

In another embodiment a controller may provide ruggedized operation when in communication with a host that allows multithreaded operation. The controller in this embodiment maintains one numeric field per physical block in the non volatile memory . This field is hereinafter called the transaction field of the block or the T field and stores the transaction handle or identifier with which the physical block is associated. This field may be of any convenient size as long as it is large enough for representing as many different transaction handles as it is desired to be able to be concurrently open. The considerations of where to store these fields are similar to the considerations for storing the control fields of the previous embodiments such as the R bit or generation field values. In one implementation the extra area of NAND flash blocks may be used to store the transaction identifier. Additionally the controller must maintain a global data structure which lists all currently open transactions.

In order to use the multitasking ruggedness capability of the non volatile storage device the host must perform several steps. First the host must ask the controller to open a new transaction. In response the controller adds the transaction identifier to the list of open transactions and returns the transaction identifier to the host . Second the host sends a series of commands to the non volatile storage device that may each change the contents of the non volatile memory . Each command is associated with the assigned transaction identifier. Finally the host sends a command to the controller to close the open transaction identifier. In response the controller unconditionally associates the data received in commands having that identifier with their corresponding logical addresses and removes the transaction identifier from the list of open transactions. In one embodiment the controller unconditionally associates the data by unconditionally associating the physical blocks storing the data with the logical block address. During this process the data received in the set of commands is not moved or copied between physical blocks. Following the above procedure guarantees that a storage device implemented according to the methods of the embodiment presented below provides multitasking ruggedized operation to the host .

In the controller logical to physical block address mapping state is shown after the host sends a request for a transaction identifier to the controller . In response to the request the controller assigns to the host transaction identifier and adds the transaction identifier to the list of open transactions. The transaction identifier number chosen is arbitrary except that it should be different from the value representing null shown in and the value chosen should be different from the transaction identifier of any other open transactions. The transaction identifier should be used by the host when sending subsequent write commands associated with this atomic transaction. As shown in the figure the only change caused by the start transaction command is the indication in the open transaction list that transaction is now open.

In the controller logical to physical block address mapping state is shown after the first write request to the logical block address associated with logical block i associated with transaction is processed. As the figure shows the original data associated with logical block address i is not overwritten as the controller may need this data to recover the state of the non volatile memory device before the changes introduced by transaction . Instead a free physical block is conditionally associated with the logical block address by adding the physical block to the chain. The newly received data is written in the conditionally associated physical block and its transaction identifier field is set to the transaction identifier which in this example is . Because the transaction is still open the open transaction list remains unchanged.

As shown in the controller processes additional commands associated with transaction identifier to write data to logical block addresses associated with blocks j and k . Now the logical block addresses j and k are also each assigned a second physical block containing the data received in the write commands and again the transaction fields of the new physical blocks are set to the transaction handle of . The open transaction list remains unchanged. In the controller logical to physical block address mapping state is shown after an additional write request associated with transaction is received this time a second command to write the logical block address associated with logical block i with new data. A new physical block is conditionally mapped to the logical block address associated with logical block i extending its chain to three blocks and the newest data shown as New Data 2 in the figure is written into it. The transaction identifier of this newly allocated block is again set to the transaction identifier and the open transaction list remains unchanged.

In the controller has processed a request from the host to close transaction . In response to the request the controller first nullifies the transaction identifier field of any physical block having a transaction field of 5. In one implementation it is sufficient to nullify only the latest such physical block transaction identifier field in each chain so that in the chain for logical block i there is no need to nullify the transaction block identifier field in the physical block containing the data marked New Data 1 . Second the controller removes transaction identifier from the open transactions list.

As a result the non volatile storage device is in a state in which all of the operations included in transaction are committed and the data written to the device in transaction is unconditionally associated with its corresponding logical block address. This state is similar to the state shown in where there are no open transactions. The sequence of events of opening a new transaction writing data associated with a transaction and closing a transaction can now be repeated.

At first glance do not appear similar because in some logical block addresses have more than one physical block associated with them a condition which does not exist in . However as can readily be seen this has no effect on the sequence of steps the controller takes in processing a set of commands for one transaction between . reflects the general case of an initial state no open transaction where a logical block may have more than one physical block assigned to it. is a simplification of the general case. Stated another way the most general case of a physical block chain is when it has zero or more blocks at its end having their transaction fields set to non null values preceded by a block with a null transaction field and possibly by additional blocks whose transaction fields are not important. The rightmost block with null transaction field contains the latest unconditionally associated data while all newer blocks contain still conditionally associated data that was written during transactions that are still open. The act of closing a transaction is achieved by nullifying the transaction fields of the newest physical blocks of the chains associated with that transaction thus unconditionally associating that data with its corresponding logical block addresses.

In the event of a sudden power loss or other interruption of power to the non volatile storage device such as if a storage card is suddenly disconnected from the host by the user the controller will have to recover a consistent data state by rolling back or removing physical blocks data associated with transactions that were open when the power was interrupted. When a power supply is restored to the non volatile storage device the controller will check the list of open transactions and then will scan the logical block addresses in the non volatile memory for the existence of physical blocks chains with a physical block at their end to the right of any block with a null transaction field having a transaction field which appears in the open transactions list. If such a physical block is detected it is removed from the chain. The removal may be implemented directly or may be effected by extending the chain with another physical block that overrides it. When the controller completes this scan for all logical block addresses the non volatile storage device is recovered to a state that reflects only the write operations of transactions that completed with all data changes occurring through partially completed transactions being removed. For example if a power loss occurred anywhere in time between the states shown in not inclusive the controller would restore the data state of the non volatile storage device to the state shown in . However if a power loss occurs after the state of is reached in other words after transaction is closed there is no longer a need to return to the state shown in as another atomic transaction has successfully completed. Thus any recovery following this point will be to the state shown in until another transaction successfully completes. In one embodiment this recovery process is initiated by the controller without receiving any special command or direction from the host . Stated another way the controller performs the scanning detection and removal operations automatically upon restoration of power to the card.

The above description presented the methods of this embodiment in the context of a single transaction. In the next example the use of transaction identifiers in a multi tasking case is illustrated by demonstrating how their use addresses the problem highlighted in . describe this sequence of events.

The host may inform the non volatile storage device that all of the write commands associated with the set of commands from task has been transmitted and processed and hence a new consistent data state can be established. The host may indicate this by transmitting an end of set command to the controller defining a new consistent data state. In the equivalent of the controller logical to physical block address mapping state is shown after the host informs the controller that a new consistent data state has been reached because task has been completed. As a result the controller removes transaction from the global open transactions list leaving only transaction in the list and the last physical blocks added to the chains of logical blocks i and k have their transaction fields set to null. In contrast to nothing is changed in logical block j as its transaction field is not the transaction being closed but . Therefore the new data in block j remains conditionally associated avoiding the problem that was illustrated in .

If a power failure occurs before the host directs the controller to close transaction associated with task the controller will recover the data state of the device by rolling back changes to the storage data done as part of transaction regardless of whether the change was done while transaction was still open or if the change occurred after transaction was closed. Thus the change to logical block j associated with transaction will correctly be rolled back during the recovery that the controller performs after the next power on. This is shown in which illustrates the controller s logical to physical block address mapping state after a recovery following a power loss occurring in the state shown in . Logical block j is rolled back to the data it had before starting transaction and the global transaction list is cleared.

The exemplary embodiment shown in demonstrate that the problem of multithreaded operation identified in have been addressed through the use of a transaction identifier. Thus the non volatile memory device may provide ruggedized operation when in communication with a host that supports multitasking or multithreaded data access operations.

There are several issues that are important for the optimization and usefulness of the multithreaded embodiment described in and and the accompanying text.

a. Intercrossing Transactions Even though the above examples did not demonstrate intercrossing transactions the methods of this embodiment are equally applicable to the cases where multiple transactions cross each other on the same sector. That is one transaction writes into a sector that contains conditionally associated data of another transaction. However while the controller can support such cases it is the responsibility of the host to guarantee that the order by which the calls are generated really reflects the desired final outcome. In other words the controller give preference to more recently written data over less recent data and thus the host has to make sure the data to be kept after the intercrossing transactions is the data written last.

b. Multiple Transactions by Same Task While the above examples focused on the case of two tasks concurrently accessing the storage device the methods of this embodiment are equally applicable to the case of one task initiating concurrently open multiple transactions. This is actually a special and simpler case of the more general multitasking case and may be useful for tasks operating on multiple files. For the purpose of the present embodiments multitasking should be interpreted to also include the case of a single task generating multiple transactions.

c. Where Multiple Transactions are not Required If it is known that the non volatile storage device does not ever need to support more than one open transaction at a time the interface to the non volatile storage device driver may be simplified. As there is only one open transaction there is no need for exchanging transaction identifiers between the host and the non volatile storage device . The interaction between the host and the non volatile storage device in this case is as follows 1 The host requests the non volatile storage device to open a new transaction. 2 The host sends commands to the non volatile storage device to carry out a sequence of operations that may each change the contents of the storage media where a transaction identifier is not specified in the command. The command may indicate that it is associated with the only open transaction. 3 The host requests the non volatile storage device to close the transaction where a transaction identifier is not specified in the command. This mode of operation is a simplification of the more general multiple transaction case where the transaction handle is automatically implied and the numeric transaction field in the physical blocks can be replaced by a Boolean transaction flag indicating whether the block is taking part in the only open transaction. For the purpose of the present embodiments transactions or transaction identifiers can be interpreted to also include this case of an implied transaction handle and a transaction Boolean flag.

d. Driver Commands not Associated with a Transaction It is an advantage of this embodiment that it inherently supports host commands that are not associated with a transaction. This may be useful for example when some commands do not require the extra reliability of power loss protection and it is not desired to pay the extra performance cost associated with ruggedized or multitasking ruggedized operation. In order to not associate a command or its data with a transaction identifier the host may simply transmit a command to the non volatile storage device with the transaction identifier field set to the null transaction identifier. This has the effect of automatically and immediately unconditionally associating the data with the consistent data state where the controller cannot roll back the data in a recovery operation. Alternatively the host may also send write commands to the controller that do not have support for a transaction identifier. When the controller processes these commands it will set the transaction identifier field of the physical block to the null transaction identifier value.

e. Read Operations Intermixing or interleaving read commands within transactions is permitted. Such commands do not change the media contents and therefore are not associated with any transaction. However care should be taken when a read is attempted to a logical block address which is being modified by an open transaction a transaction still in progress . There are two alternative approaches that a controller could take in responding to the read request.

The controller could return the latest data associated with the logical block address whether conditionally associated or unconditionally associated. While this may be acceptable in many cases a problem arises when two tasks are modifying data at the same address. For example consider the following scenario i. Task writes block A as part of transaction T. ii. Task reads block A and gets Task data. iii. Task makes a small modification to the data and writes it back into block A as part of transaction T. iv. Task closes transaction T. v. A power loss occurs. vi. On next power on the controller removes the effects of transaction T which was never closed . While at first glance it seems that the effects of the interrupted T transaction were correctly removed this is not so. The non committed T data of block A became unconditionally associated with the logical block address by the read modify write operation of Task .

Alternatively the controller could return the latest data unconditionally associated with the logical block address ignoring any non committed data that might be appended to the chain as part of an open transaction. While this may be acceptable in many cases a problem arises when two tasks are modifying data at the same address. For example consider the following scenario i. Task reads block A and gets the original data. ii. Task makes a small modification to the data and writes it back into block A as part of transaction T. iii. Task reads block A and gets the original data without task modification. iv. Task closes transaction T. v. Task makes a small modification to the data and writes it back into block A as part of transaction T. vi. Task closes transaction T. In this case the controller recovery problem discussed above has been avoided but another problem arises when there is no power loss. The data generated by Task is lost which would not happen if a host performed the same series of accesses to a non ruggedized non volatile storage device. Thus there is no one approach suitable for all cases as the optimal behavior depends on the host s pattern of use. Thus consequently it is advantageous to have the controller provide a configurable parameter that the host may set with a command that allows the host to select between the above two alternative multithreaded read behaviors.

f. Power Loss During Processing of a Command to Close a Transaction Care should be taken in the implementation of this embodiment because it is possible for a power loss to occur while the controller is in the middle of closing a transaction. If a power loss occurs in the middle of the unconditional associating process that is part of closing a transaction the controller may have already committed some of the blocks associated with the transaction by nullifying their transaction fields but not all of them. During the next power on the transaction the controller will find the transaction as open and will attempt to roll back its changes. But this roll back will only be able to remove those physical blocks not committed yet resulting in a half committed transaction and an inconsistent data state. One possible solution to this is that upon receiving a close transaction command the controller can mark the transaction with a closing in progress flag in the open transactions list. In doing so the controller will not roll back an open transaction with this flag set but will continue with the interrupted transaction closing operation for this transaction unconditionally associating the rest of the physical block data received in the transaction with the corresponding logical block addresses. This exemplary modification may provide full protection against power loss in the middle of transaction closing.

g. More Optimizations As it is readily apparent to any person skilled in the art there are numerous optimizations that can be applied to the methods of this embodiment without deviating from the essence of these methods. For example the controller may maintain in RAM tables that map each open transaction into the list of blocks associated with that transaction. This can speed up the processing of close transaction commands. As another example the controller may store in the non volatile memory tables that map each open transaction into the list of blocks associated with that transaction. This can speed up the process of recovery and clean up after a power loss by avoiding having to scan each logical block address in the non volatile storage device . All such optimizations are considered to be within the scope of the present embodiments.

Thus a controller may be adapted to support ruggedized write operations from hosts presenting single threaded or multithreaded write operations. shows exemplary steps for a controller in a non volatile storage device processing write requests from a host in a single threaded system. Control begins at step where the controller receives a command from the host to establish a consistent data state. If the controller subsequently needs to perform a roll back or recovery to a consistent data state the data in the device will be restored to this state using the methods described above. Stated another way the controller may assume that every command received after this point is part of a set of commands sent by the host to transition the storage device from one consistent data state to the next consistent data state. In one embodiment this command is unnecessary as the non volatile memory device uses a previously received end of set command shown in step as a command indicating the beginning of the next set of commands transitioning the device to the next consistent data state.

Control passes to step where a write command in a set of commands is received from the host . The command may comprise a logical block address and data to write. The controller responds to this command by allocating a physical block to store the data in step . The physical block is a storage element in the non volatile memory of the non volatile storage device . The controller writes the data received in the command to the physical block in step . Control then passes to step where the physical block is conditionally associated with the logical block address the write command directed the data to perhaps by adding the block to the end of a chain of physical blocks associated with the logical block address. Because the physical block and thus the data is only conditionally associated with the logical block address in the event of a power loss the association between this logical block address and the physical block and thus the data will be removed if the controller needs to recover the non volatile storage device to a consistent data state after a power loss.

In step the controller determines if an end of set command is received from the host . If not control passes back to step where the controller waits to receive another write command that is part of the set of commands. Assuming sufficient physical block storage space the loop shown in steps may be repeated for as many commands as are in the set of commands. When returning to step for subsequent loops through the steps the command received may be a continuation of the command received during the first time a command was received in step and thus may not contain all of the information already specified by the host. For example a write command may specify a starting address and some of the data to write. A subsequent write command containing the remainder of the data to write may not contain an address or other command information because it is assumed that the controller has saved the command information and can calculate the address information for the subsequent continuing write operation.

Returning to step if the host transmitted an end of set command control passes to where the controller establishes a consistent data state by unconditionally associating the data received in the commands processed in steps with their corresponding logical block addresses. In this way the data received in steps becomes part of the new consistent data state. Once this is complete the steps terminate. As mentioned above the controller may treat the command ending one set of commands as the start of a new set of commands so that any command received thereafter is treated as an attempt by the host to transition the non volatile storage device to yet another new consistent data state.

Control passes to step where the first write command in a set of commands associated with the transaction identifier is received from the host at the controller . In one implementation the command includes a logical block address and contains a transaction identifier to allow the controller to associate the command with an open transaction. At step the controller allocates a physical block to store the data. The controller stores the data in the physical block in step and the physical block and thus the data is tagged with the transaction identifier. At step the new physical block and thus the data is conditionally associated with the logical block address corresponding to the write command received in step . In one embodiment this conditional association includes adding the physical block to the chain of physical blocks mapped by the controller to the logical block address.

In step the controller determines if a close transaction command is received from the host applying to the currently open transaction. If not control passes back to step where the controller waits to receive another write command that is part of the set of commands in the open transaction. Assuming sufficient physical block storage space the loop of shown in steps may be repeated for as many commands as there are in the set of commands in the transaction. When returning to step for subsequent operations through the loop of steps in the command received may be a continuation of a previously received write command associated with the transaction. Thus the next write command may not contain all of the information already specified by the host in a previous command. For example if a first write command specifies a starting address and some of the data to write a subsequent command containing the remainder of the write data to write may not contain an address or other command information because it is assumed that the controller has saved the command information and can calculate the address information for the subsequent continuing write operation. However any command received at step must be identified with the transaction identifier to distinguish it from other commands that the controller might receive while the transaction is open.

Returning to step if the host transmitted a close transaction command having a matching transaction identifier control passes to . The close transaction command contains the identifier of the transaction to be closed. Because the host has told the controller that all of the data associated with a transaction has been received the controller must take action to prevent this data from being removed during a recovery if a power loss should occur. To do this the controller unconditionally associates the data received in the write commands having the transaction identifier that were processed in steps with their corresponding logical block addresses. In this way the data received in steps becomes part of the new consistent data state. In step the transaction identifier of the closed transaction is removed from the list of open transactions. Once this is complete the steps terminate.

A non volatile storage device with a controller implemented according to the methods of the present embodiments has several advantages. If power is interrupted to the non volatile storage device in the middle of a set of commands that transition the device between consistent data states or a during a set of commands that define an atomic transaction the non volatile storage device can recover itself to a consistent data state without any assistance from the host. The recovery process may not require any special commands or direction from the host and may be initiated automatically by the controller in the non volatile storage device when power is restored. The non volatile memory device exports a few additional commands to the host to allow the host to define a consistent data state the beginning and end of a set of commands that define an atomic transaction or to associate certain commands such as write or erase with a transaction. A host can choose to utilize this extended command set to take advantage of the ruggedized features of the non volatile storage device without having to maintain the internal data structures of the device required to support ruggedized operation. This simplification from the host s perspective allows the non volatile memory device to be used with hosts that advantageously utilize the ruggedized features of the non volatile memory device and those that do not. Further because the host does need to not maintain the data structures required for ruggedized operation and does not access the non volatile storage device in order to recover a consistent data state the available bandwidth on the communication interface between the host and the non volatile storage device is increased. Although the invention has been described with respect to various system and method embodiments it will be understood that the invention is entitled to protection within the full scope of the appended claims.

