---

title: Data storage for file updates
abstract: A storage system according to one embodiment for managing a first file includes a blob storage and a handler. The blob storage may be configured to store data related to the first file temporarily. The handler may be configured to store in the blob storage any data related to the first file and received from an application. The handler also may be configured to transfer at least a portion of the data from the blob storage to persistent storage in response to a commit instruction received from an application or generated by the handler. The handler also may be configured to retrieve any portion of the data stored in the blob storage and to send the same to a requesting application in response to an access request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08301588&OS=08301588&RS=08301588
owner: Microsoft Corporation
number: 08301588
owner_city: Redmond
owner_country: US
publication_date: 20080307
---
Data files e.g. word processing documents presentation documents spreadsheet documents pictures or other images sound files software applications executable code etc. may be stored in persistent storage locations on storage devices in particular file formats. Accessing one of these data files typically includes retrieval of the entire data file from the persistent storage location.

When the data files are stored in the persistent storage location the storage device may perform a number of pre storage processes before writing the data files to the storage location. For example the storage device may perform security checks on the data files such as searching for viruses and or corrupted files. The storage device also may perform property discovery on the data files. The aggregation of one or more of these pre storage processes may be referred to as a save pipeline. Implementing the save pipeline may be relatively expensive in terms of time and or resources.

Multiple users may wish to edit a document stored in persistent storage. For example users may wish to collaboratively author the document. Such multi user authoring may cause problems in scalability and or performance. For example storing changes from multiple users may require a potentially unbounded amount of computation by the save pipeline e.g. the save pipeline may be implemented for each set of changes for each user . Such a drain on resources may cripple the storage device s ability to handle very frequent file update requests.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended as an aid in determining the scope of the claimed subject matter.

File updates for a data file may be stored temporarily in a blob storage before being committed to persistent storage. According to aspects expensive pre storage processing is performed after coalescing the file updates with the data file to form an updated data file to be committed to the persistent storage. According to other aspects the file updates are accessible individually or as part of the data file before being committed. In one embodiment the file updates include incremental updates received from one or more applications. According to other aspects portions of the data file may be incrementally accessible after being committed to persistent storage.

These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of aspects as claimed.

In the following detailed description references are made to the accompanying drawings that form a part hereof and in which are shown by way of illustrations specific embodiments or examples. While the disclosure will be described in the general context of program modules that execute in conjunction with an application program that runs on an operating system on a computer system those skilled in the art will recognize that the disclosure also may be implemented in combination with other program modules. The embodiments described herein may be combined and other embodiments may be utilized without departing from the spirit or scope of the present disclosure. The following detailed description is therefore not to be taken in a limiting sense and the scope of the invention is defined by the appended claims and their equivalents.

Embodiments of the present disclosure provide an environment in which a storage device such as a server computing device may provide efficient processing and storage of data files. Data storage consistent with the principles of the present disclosure is generally provided in a two stage process. Firstly data is stored temporarily in a hot box or blob storage location. Secondly some or all of the data within the blob storage location may be transferred to a cold or persistent storage location.

As the term is used herein the hot box or blob storage location refers to a location e.g. a sandbox in which data and or metadata associated with a data file may be stored temporarily as a blob data e.g. an arbitrary length binary string of data . While stored in the blob storage location the blob data may be referred to as hot data. In one embodiment the hot data being stored in the blob storage location may include an entire data file or one or more portions e.g. content and or metadata of the data file. In another embodiment the hot data may include temporary data not intended for persistent storage e.g. thumbnail previews of the data file .

As the term is used herein the cold storage location refers to a persistent i.e. as opposed to temporary data storage location. Typically any expensive e.g. in time in resources etc. data processing is performed only when the hot data is being committed to the cold storage location. Transferring the hot data to the cold storage location may include arranging or integrating the hot data into a data file format recognizable to the storage device.

According to aspects of the disclosure the blob storage location provides an abstract data model that may be built onto existing infrastructure of the storage device to increase data storage efficiency. For example appropriate software such as a handler application program interface API disclosed in greater detail herein may be added to an existing storage device such as a server computer to intercept data to be stored persistently to gather the data in the blob storage location until a predetermined condition is satisfied and subsequently to transfer the data from the blob storage location to a preexisting cold storage location e.g. using a preexisting save pipeline .

According to other aspects of the disclosure the blob storage location may enable incremental storage of and access to data files stored on the storage device. The blob storage location can store data as unformatted blob data. Accordingly the data being stored in the blob storage location need not conform to an underlying file format of the cold storage location until committed to the cold storage location. Because the blob storage location is agnostic of the underlying file format of the data being stored portions of or changes to a data file may be stored in and accessed from the blob storage location instead of storing and accessing the entire data file. For example in one embodiment one or more data units e.g. paragraphs pictures text blocks objects etc. of a data file may be stored in the blob storage location. In another embodiment metadata indicating differences between two versions of a file may be stored in the blob storage location.

The data stored in the blob storage location may be coalesced into a proper file format if and when appropriate e.g. when being committed to the cold storage location . For example the data may be processed by a file format specific algorithm to arrange the data into an appropriate file format. In one embodiment after being coalesced the data may be accessed as a single data file. In another embodiment additional software may be provided to enable incremental access to the data files stored in the cold storage location as disclosed in greater detail herein.

Referring now to the drawings is a flowchart illustrating an operational flow for an example storage process by which data may be stored on a storage device. The storage process initializes and begins at a start module and proceeds to a batch operation . The batch operation stores data in a temporary blob storage location. For example the batch operation may store the data in a blob storage database on the storage device. In one embodiment the batch operation performs minimal processing of the data before storing the data in the temporary blob storage location. In general the batch operation may store partial or complete data files independent of any underlying file format.

A transfer determination module determines whether some or all of the data contained in the blob storage location should be transferred to a more persistent storage location or arranged in a more persistent storage format. For example the transfer determination module may determine whether the data stored in the temporary blob storage location includes data intended to replace or supplement data stored in a cold storage location.

If the transfer determination module determines none of the data should be transferred then the storage process proceeds to an empty operation which removes data from the temporary blob storage location without first committing the data to a cold storage location. For example the empty operation may delete metadata e.g. a thumbnail image associated temporarily with the file. The storage process completes and ends at a stop module .

If the transfer determination module determines at least some of the data should be stored in a more persistent manner however then a commit operation transfers at least some of the data from the blob storage location to a cold storage location. For example the commit operation may store the data from the blob storage location in a cold storage database. In one embodiment the commit operation performs data processing e.g. anti virus checking property discovery or any other expensive data processing operation on the data before storing the data at the cold storage location.

In one embodiment the commit operation stores only data obtained from the blob storage location into the cold storage location. In another embodiment the commit operation merges newly received data with data previously stored in the blob storage location e.g. by one or more executions of the batch operation before storing the merged data in the cold storage location. In another embodiment the commit operation merges data stored at the blob storage location with data already stored in the cold storage location.

The empty operation removes data from the temporary blob storage location. In one embodiment the empty operation removes all data contained in the temporary blob storage location. In another embodiment the empty operation may remove a set or range of data. For example the empty operation may remove any data saved in the cold storage location. The storage process completes and ends at a stop module as described above.

The storage device is communicatively coupled to at least a first cold storage and at least a first blob storage associated with the first cold storage . In one embodiment the aggregation of data stored in the first blob storage and the first cold storage represents the current state of a document stored on the storage device . In an embodiment additional blob storages may be associated with the first cold storage . In another embodiment the first blob storage may be associated with additional cold storages.

In general the first blob storage and the first cold storage each may be maintained on the storage device or at any desired location that is communicatively coupled to the storage device . For example the blob storage may be maintained locally on the storage device and the cold storage may be maintained at a remote location communicatively coupled to the storage device . In one embodiment one or more characteristics of the blob storage may be optimized for speed e.g. length of time to store and or access the data . In one embodiment one or more characteristics of the cold storage may be optimized for long term storage e.g. to emphasize reliability over speed .

The storage device e.g. a server computing device is configured to interact with at least a first user device e.g. a client computing device . For example the storage device may be configured to receive an access request from a first user device to store data from the first user device on the storage device . In one embodiment the first user device also may retrieve data from the storage device . As shown in the storage system may interact with multiple user devices e.g. see user devices configured to access the storage device .

The first user device of may include a computing device e.g. a personal computer a server computer a notebook computer a PDA a Smartphone or any other such computing device . In general the first user device is configured to execute one or more applications to author documents e.g. DOC or other data files that may be stored on the storage device . One non limiting example of an authoring application that may be executed on the first user device is MICROSOFT OFFICE WORD authoring software from MICROSOFT CORPORATION of Redmond Wash. Other non limiting examples of authoring applications include POWERPOINT presentation software and VISIO drawing and diagramming software both also from MICROSOFT CORPORATION of Redmond Wash.

In general the storage device includes a handler that is configured to communicate with applications executing on the storage device applications executing on the user device or with any other applications communicatively coupled to the storage device . In one embodiment the handler does not determine a file format of the data received from or sent to the applications. In such an embodiment the handler implements processes that execute independently of an underlying file format of the data.

The handler of the storage device may receive data from the application of the first user device and store the data in the first blob storage . For example the handler periodically may receive updates to the data file DOC e.g. incremental changes new versions of the document etc. being authored by the application and may store these updates in the first blob storage .

In some embodiments the handler may receive updates for the same data file from multiple user devices. For example multiple users may edit a data file simultaneously and attempt to share changes. If two or more of the received updates are associated with the same data file then the handler may store these received updates in the same blob storage location e.g. the first blob storage . Updates relating to different data files however are typically stored in different blob storages e.g. different database tables within one or more blob storage locations .

Subsequently the handler may transfer the updates from the first blob storage to the first cold storage . Embodiments of the handler may coalesce the data stored in the first blob storage with cold data already stored in first cold storage . In one embodiment coalescing the data may include arranging the data according to a particular file format. In such an embodiment the handler implements processes that execute in accordance with an underlying file format of the data being processed. Embodiments of the handler may refrain from executing the pre storage processes of the save pipeline on the data being stored into the first blob storage . Rather the pre storage processes may be performed on the coalesced data when the coalesced data is saved in the first cold storage .

The handler also may receive access requests for data from applications communicatively coupled to the storage device e.g. application on the first user device . Such applications may be agnostic of the architecture and storage environment of the storage device . Accordingly the requesting application need not know how the requested data is stored on the storage device e.g. in the first blob storage or in the first cold storage . Rather the handler of the storage device determines where the requested data is stored retrieves the requested data from the appropriate storage and sends the requested data to the requesting application. Accordingly in one embodiment a second application not shown may request and receive access to data provided by the application and stored in the first blob storage .

An add operation accesses a blob storage such as the first blob storage of and stores the received data to the temporary blob storage. For example the add operation may place the received data into a blob storage database maintained at the storage location. In one embodiment the add operation performs minimal or no processing on the received data before adding the received data to the blob storage. In general data stored in the blob storage is accessible e.g. read and or write access to applications communicatively coupled to the storage location.

In some embodiments the add operation may read data from the blob storage or a cold storage before adding data to the blob storage. For example in one embodiment the add operation may validate the data being added to the blob store is consistent with data stored in the cold store. In another embodiment the add operation also may be able to use some data from the cold storage to optimize the storage of the new data in the blob storage e.g. such that subsequent reads are faster .

A determination module determines whether to commit the data stored at the blob storage to a cold storage. In some embodiments the determination module checks whether instructions to commit the changes have been provided e.g. by the application of the first user device by the handler etc. . For example a user of the user device may trigger a transfer of data from the blob storage to the cold storage by selecting a save option when editing a data file. In other embodiments however the determination module may check other conditions to determine whether to commit the data. For example the determination module may elect to commit the blob storage data when the blob storage reaches a predetermined size or when a predetermined time limit elapses.

If the determination module determines the data in the blob storage should not yet be committed to the cold storage then the handling process may complete and end at a stop module . If the determination module determines the data in blob storage should be committed however then the handling process may proceed to a commit operation . The commit operation transfers the data previously stored in the blob storage into the cold storage.

In one embodiment the commit operation stores all data contained in the blob storage to the cold storage. In another embodiment the commit operation only commits to the cold storage a portion of the data contained in the blob storage e.g. all data added before or after a given date and time all data provided by a particular user application etc. . The handling process completes and ends at the stop module as described above.

Coalesce operation integrates the data that has been stored in the blob storage. In one embodiment the coalesce operation may integrate the data stored in the blob storage with any data stored in the cold storage. In one embodiment the coalesce operation retrieves the entire data file stored in the cold storage. In another embodiment however the coalesce operation retrieves one or more relevant portions of the data file to be coalesced with the data from the blob storage. For example the coalesce operation may accesses the data file in the cold storage incrementally using file format metadata as will be discussed in greater detail herein.

Optionally the coalesce operation may determine properties of the blob storage data such as the type of data the file format of the data or the relationship between the data stored in the blob storage and the data stored in the cold storage. The data may be integrated differently depending on the determined relationship. For example in one embodiment the coalesce operation may determine data obtained from the blob storage includes a new data file to replace the data file stored in the cold storage. In another embodiment the coalesce operation may determine the data obtained from the blob storage includes a series of incremental updates to be instantiated into the data file stored in the cold storage as will be discussed in greater details herein. In another embodiment the coalesce operation may determine the data obtained from the blob storage includes metadata to be associated with the data file stored in the cold storage e.g. via a metadata table auxiliary to the file .

A process operation analyzes the coalesced data and performs any desired type of data processing before the coalesced data in transferred to the cold storage. For example in one embodiment the process operation may perform security checks e.g. may check the coalesced data from viruses spy ware ad ware and or other issues . In another embodiment the process operation performs property discovery on the coalesced data. In other embodiments the process operation may perform hyperlink fix up firing events triggering of workflow and other such processes.

A store operation saves the coalesced and processed data into a cold storage such as cold storage see . After being added to cold storage the data is referred to as cold data. In an embodiment the store operation replaces the data file previously stored in the cold storage with the newly coalesced and processed data. In another embodiment the store operation may overwrite portions of the previously stored data file to update portions of the data file. For example if the coalesce operation determines the data obtained from the blob storage includes incremental updates to the data file stored in the cold storage then the store operation may access only relevant portions of the data file in the cold storage e.g. via file format metadata as discussed in greater detail herein and overwrite only those relevant portions. The commit process completes and ends at a stop module .

The data processing and storage system includes a communication module an access handler a blob storage and a cold storage . In general the communication module manages communication see arrows and between the access handler and one or more applications or processes e.g. an application on a computing device providing data to be stored or requesting stored data. The access handler stores data to and retrieves data from the blob storage and the cold storage .

In one embodiment the applications providing and requesting data are implemented on one or more remote computing devices coupled to the server . In another embodiment however the communication module is configured to communicate with an application executing on the server to send and receive data updates. For ease in understanding the remainder of this document will assume any application providing data to be stored or requesting stored data is executing on a separate computing device from the storage device.

In general the communication module communicates with the applications providing or requesting data using one or more communication protocols. In one embodiment the communication module may include one or more communication APIs . The applications may be agnostic to the architecture and processes of the server as long as the applications are familiar with the communication protocol used by the communication module . Similarly the server may be agnostic to the architecture of any computing devices communicatively coupled to the server e.g. the computing device and the processes of any applications executing thereon.

In the example shown in the communication module may receive data from an application on a client computing device for storage. For example in one embodiment the communication module may receive incremental edits to content and or metadata of a document being edited by the application for integration into a master copy of the document not shown stored on the server . In other embodiments the communication module may receive new data files to be stored on the server or modified data files to replace data files previously stored on the server . The communication module sends the received data to the access handler for storage.

The communication module also may receive requests from the application to access documents not shown stored on the server . In such embodiments the communication module forwards the requests to the access handler obtains the requested data from the access handler and transmits the requested data back to the client computing device . In one embodiment the communication module provides the requested data to the application client computing device without determining an underlying file format of the data.

In general the access handler includes an access module that manages access to the blob storage and the cold storage . In one embodiment the access module may include one or more access APIs not shown . In one embodiment the access module may abstract how data is stored and accessed on the server by accessing the blob storage and cold storage using preexisting storage APIs provided on the server see arrow . The storage APIs each may be tailored to the architecture of the server to provide efficient read and or write access to server memory implementing the blob and cold storages respectively.

In one embodiment different storage APIs may be provided for performing the same basic function e.g. reading from the blob storage writing to the blob storage or reading from the cold storage with different types of data e.g. data having different file formats . The access module may select which preexisting storage APIs to utilize based on the type of data being stored or accessed. In one embodiment the access module determines the type of data being stored based on information provided by the providing and or requesting application via the communication module .

The access handler also includes a commit module that transitions that data from the blob storage to the cold storage . In general the commit module retrieves data currently stored in the blob storage commits at least some of the data to the cold storage through a save pipeline and clears the committed data from the blob storage . In one embodiment the commit module may include one or more commit APIs not shown for committing different types and or formats of data to the cold storage .

In one embodiment the client computing device may trigger the commit module to begin the commit process. For example in the application on the user device may provide instructions to commit data in the blob storage when a user of the application instructs the application to save and share the data with the server e.g. for instantiation into a master copy of the data . In another embodiment a second application not shown may trigger the commit process. In such an embodiment the second client may trigger the transfer to cold storage of the data provided by the first application which was previously stored in the blob storage as well as the data provided by the second application.

In other embodiments however the commit module may trigger the commit process without interaction with a user application. For example in one embodiment the commit module may provide instructions to commit when the commit module determines the blob storage has reached a predetermined size or has filled a predetermined percent of its capacity. In another embodiment the commit module may provide instructions to commit when the commit module determines a predetermined length of time has elapsed since a previous implementation of the commit process. In other embodiments the commit module may trigger the commit process based on other such triggering criteria.

In some embodiments the data processing and storage system also may include file format metadata FFM storage in which file format metadata associated with a particular file may be stored. In general file format metadata enables the access handler or other applications on the storage device to access a data file stored in the cold storage incrementally based on the underlying file format of the stored data file. For example the file format metadata may include an index representing a general file structure indicating where data can be found within the stored data file. Accordingly the file format metadata may enable the access handler to retrieve one or more requested data units e.g. a paragraph of a data file e.g. a word processing document instead of retrieving the entire data file.

Incremental access may enhance the efficiency with which data is retrieved from the cold store and may minimize the resources utilized in the retrieval. For example in one embodiment the file format metadata may be stored on the storage device and the cold storage may be maintained at a remote location not shown . In such an embodiment accessing the file format metadata locally determining a relevant section of the data file and requesting the relevant section from the remote location may be cheaper e.g. in terms of processing time and or resources than retrieving the entire data file from the remote location. In other embodiments however the file format metadata may be stored as a data file in the cold storage or as data in the blob storage . Updates to the file format metadata also may be stored as data in the blob storage .

File format metadata may be generated or updated by the access handler or other module capable of identifying the structure and format of data when data from the blob storage is committed to the cold storage . In one embodiment the file format metadata includes indices and offsets which allow the access handler to perform the incremental access of the data file in the cold storage . For example the access handler may parse the data file to identify relevant data units within the data file and to determine the offset location of the data units for storage as metadata offsets. In one embodiment the file format metadata is stored as a database.

As noted above a data processing and storage environment having features that are examples of inventive aspects in accordance with the principles of the disclosure can be implemented on a computing device e.g. a server computer a personal computer a notebook computer a PDA a Smartphone or any other such storage device . A non limiting embodiment of a storage system configured to implement the data processing and storage environment of is described herein with reference to .

In the example storage system for implementing the principles of the disclosure includes a storage computing device such as computing device . For example the computing device may include a server computer executing the SHAREPOINT Server 2007 server program from MICROSOFT CORPORATION of Redmond Wash. In other embodiments however the computing device may include a network of server computers a user computer or any other device capable of performing data processing and storing data.

In a basic configuration the computing device typically includes at least one processing unit for executing applications and processing data stored in system memory . Depending on the exact configuration and type of computing device the system memory may include but is not limited to RAM ROM EEPROM flash memory CD ROM digital versatile disks DVD or other optical storage devices magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other memory technology.

System memory typically stores an operating system such as the WINDOWS operating systems from MICROSOFT CORPORATION of Redmond Wash. suitable for controlling the operation of the computing device . System memory also may include a handler application a blob storage and a cold storage . The handler application may include a communication application program interface COMMUN API an access API and a commit API . The system memory also may store one or more software applications such as document management applications for storing and providing access to documents or document authoring applications for generating and editing documents.

Server computing device also may include one or more input device s such as a keyboard mouse pen keypad D pad scroll wheel jog wheel voice input device touch input device etc. for entering and manipulating data. Output device s such as a display screen speakers printer etc. also may be included with server computing device . These input devices and output devices are well known in the art and need not be discussed at length herein.

The server computing device also may include communication device media that allow the device to communicate with other computing devices for example the user computing device of over a network in a distributed computing environment e.g. an intranet or the Internet . By way of example and not limitation communication device media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Referring to example embodiments of a blob storage are disclosed. is a schematic block diagram of an example blob storage . In the example shown the blob storage includes a blob database having at least two data fields per data entry. In the example shown each data field forms a column and each entry forms a row in the database . The first data field may contain a unique data key and the second data field may contain data to be saved. The data to be saved is accessible using the associated data key. In other embodiments however the blob storage may be implemented using a different scheme.

In one embodiment the unique data key is generated on a storage device implementing the blob storage . In an embodiment the unique data key is generated by a handler such as handler of when data to be stored is received by the handler. Some embodiments of the blob storage store the received data as an arbitrary length binary string or BLOB. Advantageously storing the data as a BLOB enables the blob storage to remain agnostic to the file format of the data. In other embodiments however the data may be stored in the blob storage in any suitable format.

As noted above a handler e.g. access handler of manages access to the blob storage using an access module e.g. access module of . One example of an access module for a blob storage is provided in at reference number . The access module includes a PutBlob module a GetBlob module and a Delete module . The access module uses the PubBlob module to add data to the blob storage database . The access module uses the GetBlob module to read data from the blob storage database . The delete module removes data from the blob storage database for example during a commit process.

The blob database also includes a third data field for storing a data tag. In general a data tag may include any information to be associated with the data blob in the second data field . For example a data tag may include metadata about the data blob to be stored e.g. a timestamp any data provided by the application requesting storage of the data blob metadata regarding the blob database or any other data that may be useful to associate with the data blob in the second data field . In one embodiment data tags enable an application e.g. application of to index data blobs within the blob storage with keys defined by the application as opposed to the unique data key stored in the first data field . For example an application may use data tags to identify a page number a paragraph number a cell number an object number etc. of data within a data file.

The add process initializes and begins at a start module and proceeds to a receive operation . The receive operation receives e.g. from an application on a remote computing device a request to add data to the blob data base . Typically the request includes the data to be stored.

A generate operation creates a unique data key and adds the unique data key to a first data field e.g. data field of in a new data entry. In one embodiment the generate operation generates a random number as the data key. In another embodiment the generate operation generates sequential data keys by which the order in which the data keys were generated may be determined. In other embodiments however the generate operation may create any desired type of unique data key.

A first put operation adds the data to be stored to a second data field e.g. data field of of the data entry. In one embodiment the first put operation writes the data to the second data field as a BLOB regardless of the actual file format of the data received from the application or the file format of the data being processed by the application.

An optional second put operation may add a tag to a third data field e.g. data field of to the database entry. In one embodiment the second put operation obtains from the request received by the receive operation a tag generated by the application requesting the storage of the data. In another embodiment the second put operation generates the tag based on the data to be stored. In other embodiments however the second put operation may otherwise obtain the tag.

A return operation returns the data key associated with the data. For example in one embodiment the return operation sends the data key to an access module e.g. access module of . In an embodiment the return operation also returns a blob storage identifier not shown . The access module uses the data key and optionally the blob storage identifier to subsequently access the data stored in the blob storage. The add process completes and ends at a stop module .

In one embodiment the access module enables requesting applications to remain agnostic of the blob storage database format. In another embodiment the access module forwards the data key to a communication module e.g. communication module of which forwards the data key to the requesting application for use in subsequently accessing the blob storage database .

The receive operation receives a request from an application to retrieve data from the blob storage. In one embodiment the receive operation also receives one or more data keys e.g. a range of data keys associated with the data to be retrieved. In another embodiment the receive operation receives one or more tags e.g. a range of tags associated with the data to be retrieved. In other embodiments the receive operation receives search conditions or other information by which the data to be retrieved may be identified.

A query operation searches the blob storage e.g. blob database using the received data key s the received tag s and or other received information to obtain the associated data. For example embodiments of the query operation may search the data entries in the blob storage for a particular data key a range of data keys or all data entries associated with a particular tag. In another embodiment the query operation may search the blob storage for data entries meeting certain conditions such as the most recent entry e.g. highest data key in sequence the oldest entry e.g. lowest data key in sequence the biggest entry e.g. occupying most memory resources or other such conditions.

A return operation sends the retrieved data to the requesting application. In some embodiments the return operation passes the retrieved data to an access module. In one embodiment the access module forwards the data to a communication module which forwards the data to the requesting application. In another embodiment the access module processes the data to satisfy an underlying file format and forwards the processed data to the requesting application. The retrieve process completes and ends at a stop module .

The delete process initializes and begins at a start module and proceeds to a receive operation . The receive operation receives a request to delete data from the blob storage e.g. blob storage of respectively . In one embodiment the receive operation also receives one or more data keys associated with the data to be deleted. In another embodiment the receive operation receives one or more tags associated with the data to be deleted. In another embodiment the receive operation receives one or more data units to be deleted. In other embodiments the receive operation may receive other information by which the data to be deleted may be identified.

A find operation accesses the blob storage database using the received data key s the received tag s the received data and or other received information to locate the data entries to be deleted. A remove operation removes the data associated with the data entries from the blob storage database. The delete process completes and ends at a stop module .

The principles of the present disclosure can be better understood by walking through an example application. is a schematic block diagram of a data storage system having features that are examples of inventive aspects configured in accordance with the principles of the present disclosure. The data storage system includes a handler configured to communicate with one or more applications. In the example shown the handler is configured to communicate with a first second and third application respectively. In other embodiments however the handler may communicate with any desired number of applications.

The handler enables the applications to access files stored on the data storage system . For example the handler may enable the applications to access e.g. retrieve save modify etc. File A and or File B stored in the cold storage of the data storage system . The handler also manages when modifications made to files such as File A and File B are stored in blob storage e.g. blob storages and when the modifications are coalesced and transferred to the cold storage .

In general each blob storage is associated with at least one data file stored in the cold storage . In one embodiment each blob storage may be associated with multiple cold data files. By associating a single blob storage with multiple cold data files data updates common to the cold data files may be stored and committed efficiently e.g. by tail merging the data . In other embodiments however each cold data file e.g. File A and File B may be associated with one or more unique blob storages e.g. each of which may have a unique identifier . For example each user editing a cold data file may have a unique blob storage or section of a blob storage for storing changes to the cold data file made by the user.

For ease in understanding in the example shown in File A is associated with a first blob storage shown as Blob Storage A and File B is associated with a second blob storage shown as Blob Storage B . In one embodiment each blob storage may be tied to its respective file A B. For example in one embodiment if File A is transferred to a different storage device then Blob Storage A also would be transferred. If File B is deleted then Blob Storage B also would be emptied and or deleted.

The following description will walk through some of the operational flows disclosed above to trace through a first example editing session in which the first and second applications edit File A and a second example editing session in which the third application edits File B. are schematic block diagrams illustrating the state of the first and second blob storages at different points during the first and second editing sessions.

In the first and second blob stores are empty. Accordingly at the beginning of the editing sessions all data associated with File A is saved on the data storage system in the cold storage as File A and all data associated with File B is saved on the data storage system in the cold storage as File B.

With respect to the first editing session of File A the handling process initializes and begins at a start module and proceeds to a receive operation . The receive operation obtains from the first application data to be stored and instructions to store the data at the storage system . In one embodiment the receive operation receives an incremental update for File A based on modifications made to File A by the first application . The incremental update may be a content update and or a metadata update.

An add operation accesses the first blob storage and stores the received data e.g. a delta file in the first blob storage see . One example process for implementing the add operation of is the add process disclosed above with reference to . The add process initializes and begins at a start module and proceeds to a receive operation . The receive operation receives a request to add the data to the blob storage .

A generate operation creates a new data key e.g. data key K and adds the new data key K to a first data field in a new data entry see . A first put operation adds the data to a second data field of the data entry see . In the example shown the first application did not send a tag to be associated with the data . Accordingly the second put operation of the add process is skipped.

A return operation returns the data key K associated with the data to the handler . In one embodiment the return operation also returns a blob storage identifier not shown . Subsequently the handler may use the returned data key K and optionally the blob storage identifier to access the data while the data is stored in the blob storage . The add process completes and ends at a stop module . The results of the add process with respect to the blob storage are shown in .

Referring again back to handling process a determination module determines whether to commit the data e.g. delta stored in the blob storage to the cold storage . In this example walkthrough the determination module determines the first application has not provided instructions to commit and no other commit criteria e.g. time elapsed size of blob storage etc. has been satisfied. Accordingly the handling process completes and ends at a stop module .

The handling process repeats each time new storage instructions and data for File A are received from one of the applications during the first editing session. For example when additional incremental changes are received from the second application the handling process initializes and begins again at the start module and proceeds to the receive operation . The receive operation obtains from the second application the data to be stored and instructions to store the data at the storage system .

The add operation accesses the first blob storage and stores the received data in the first blob storage see . For example the add operation may generate a new data key K and add the new data key K and the received data to a second data entry of the first blob storage using the add process as described above see . The new data key K may be returned to the handler . The results of the add operation with respect to the blob storage are shown in .

The determination module of handling process determines whether to commit the data stored in the blob storage to the cold storage . In this iteration of the walkthrough the determination module determines the instructions to commit the modifications to persistent storage have been received e.g. from the second application of . Accordingly the handling process proceeds to a commit operation . In other embodiments however the determination module may have determined not to commit the modifications and the handling process would have ended as described above.

The commit operation stores the data previously stored in the blob storage into the cold storage . In the example shown the blob storage is a global blob storage e.g. is common to all accessing applications . Accordingly the commit instructions provided by the second application result in the transfer of data provided by both the first and second applications to the cold storage . In other embodiments however each application may be associated with its own blob storage or partitioned section of the blob storage for a particular data file and accordingly may commit only its own instructions. The handling process completes and ends at the stop module .

One example process for implementing the commit operation of is the commit process disclosed above with reference to . The commit process initializes and begins at a start module and proceeds to a coalesce operation . The coalesce operation gathers and integrates data that has been stored in the blob storage .

In some embodiments the coalesce operation determines how the data stored in the blob storage relates to the data stored in the cold storage . For example the coalesce operation may determine the data stored in the blob storage see represent incremental changes e.g. of content and or metadata changes to File A. In such embodiments the coalesce operation instantiates the incremental changes into File A to form a modified File A not shown .

An optional process operation analyzes the data e.g. modified File A and determines whether any action should be taken before storing the data in the cold storage . For example security checks or property discovery may be performed. A store operation saves the data e.g. modified File A into the cold storage . In one embodiment the store operation replaces File A with modified File A. An empty operation removes the transferred data from the blob storage see . The commit process completes and ends at a stop module .

One example process for implementing the empty operation of the commit process is the delete process disclosed above with reference to . The delete process initializes and begins at a start module and proceeds to a receive operation . The receive operation receives a request to delete cold data i.e. data that has been saved to the cold storage from the blob storage of . In this iteration of the example walkthrough all data entries in the blob storage have been transferred to the cold storage . In one embodiment the receive operation receives instructions to delete all data entries of the blob storage .

A find operation accesses the blob storage and a delete operation removes the data associated with the data entries of the blob storage . In this example walkthrough the find operation does not need to search the blob storage for specific data entries but rather identifies all data entries containing data sets such as . The delete process completes and ends at a stop module . The results of the commit process with respect to the blob storage are shown in .

The disclosure will now walk through the second example editing session with respect to File B. The third application requests and receives content and metadata of File B from the handler which obtains File B from the cold storage . The third application modifies the content and or the metadata of File B to create a revised File B.

The third application then sends File B as a complete data file to the handler for storage on the storage system . When the handler receives the File B and the instructions to store the File B the handling process initializes and begins at the start module and proceeds to the receive operation . The receive operation obtains File B at the handler from the third application .

The add operation accesses the second blob storage associated with the File B and stores the received data File B in the second blob storage . For example the add operation may generate a new data key Y and add the new data key Y and the received data File B to a first data entry of the second blob storage using the add process as described above see . The new data key Y may be returned to the handler .

The determination module of handling process determines whether to commit the data e.g. File B stored in the blob storage to the cold storage . In this iteration of the example walkthrough the determination module determines no instructions to commit data to persistent storage have been received e.g. from any of the applications of . Accordingly the handling process completes and ends at a stop module . The results of the handling process with respect to the blob storage are shown in .

The handling process repeats each time new storage instructions and data for File B are received from one of the applications . For example when another revised copy File B of the document File B is sent from the third application the handling process initializes and begins again at the start module and proceeds to the receive operation . The receive operation obtains from the third application the data File B to be stored and instructions to store the data File B on the storage system .

The add operation accesses the second blob storage and stores the received data File B in the first blob storage . For example the add operation may generate a new data key Y and add the new data key Y and the received data File B to a second data entry of the second blob storage using the add process as described above. The new data key Y may be returned to the handler for use in subsequent access requests for File B. The results of the add operation with respect to the blob storage are shown in .

The determination module of handling process determines whether to commit the data File B File B stored in the blob storage to the cold storage . In this iteration of the example walkthrough the determination module determines instructions to commit the modifications represented by data File B and File B to persistent storage have been received. Accordingly the handling process completes and ends at a stop module .

On the third iteration of this example walkthrough for File B one of the applications subsequently provides metadata M e.g. a thumbnail image an abstract summary etc. associated with File B for storage without providing instructions to commit the updates to persistent storage. The metadata is added to the blob storage using the processes described above for adding File B and File B see . Accordingly none of the data entries e.g. File B File B M has been sent through the save pipeline yet. When the data File B File B M are finally committed they may be coalesced e.g. reorganized into a single data file before being processed and stored into cold storage thereby saving time and or system resources. In one embodiment some of the data e.g. metadata M may be deleted from the blob storage without being transferred to the cold storage .

At any point during the editing sessions one or more of the applications may access the data stored in the blob storages . For example if the first and second applications are simultaneously editing separate copies not shown of the document File A then the first and second applications may synchronize their respective copies by each periodically checking for changes to File A saved to the storage system by the other application. In one embodiment each application may send a timestamp e.g. as a tag of to the handler with instructions to provide all data entries made since the time indicated by the timestamp.

One example process by which the data entries may be retrieved from the storage system is the retrieve process of . The retrieve process initializes and begins at a start module and proceeds to a receive operation . The receive operation receives a request from one of the applications e.g. via the handler to retrieve data from a blob storage e.g. blob storage of . In one embodiment the receive operation receives a tag containing a timestamp associated with the most recent data entry known to the application.

A query operation searches the blob storage using the received timestamp to determine the data entry associated with the timestamp. The query operation also may determine which data entries were generated after the data entry associated with the timestamp and obtain the data from these data entries. A return operation sends the obtained data to the handler which may present the obtained data to the requesting application. In one embodiment the handler organizes the obtained data into a file format known to the requesting application. The retrieve process completes and ends at a stop module .

Embodiments of the disclosure may be implemented as a computer process method a computing system or as an article of manufacture such as a computer program product or computer readable media. The processes programs can be implemented in any number of ways including the structures described in this document. One such way is by machine operations of devices of the type described in this document. Another optional way is for one or more of the individual operations of the methods to be performed on a computing device in conjunction with one or more human operators performing some of the operations. These human operators need not be collocated with each other but each can be only with a machine that performs a portion of the program.

The computer program product may be a computer storage media readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process. The term computer readable media as used herein includes both storage media and communication media.

Those skilled in the art will appreciate that the disclosure may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The disclosure may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices. Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types.

