---

title: Method and apparatus for advanced interprocess communication
abstract: An interprocess memory controller is described that may be used to provide multiple processes within a multi-process device with access to a shared physical memory. The described interprocess memory controller may enforce access rights to shared memory that has been allocated to the respective processes, thereby guarding the multi-process device from instability due to the unauthorized overwriting and/or unauthorized freeing of allocated memory. The described interprocess memory controller approach may streamline interprocess communication by allowing data associated with an interprocess communication to be passed from a first process to a second process by passing a pointer as well as access rights to a buffer in shared memory that contains the message data. In this manner, the described interprocess memory controller approach may avoid the inefficiency of interprocess communication approaches that copy message data from a shared memory controlled by a first process to a shared memory controlled by a second process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08286188&OS=08286188&RS=08286188
owner: Marvell Israel (M.I.S.L.) Ltd.
number: 08286188
owner_city: Yokneam
owner_country: IL
publication_date: 20080428
---
This application claims the benefit of U.S. Provisional Application No. 60 914 530 Advanced Interprocess Communication filed by David Brief on Apr. 27 2007 which is hereby incorporated by reference in its entirety.

A multi process device may be described as a processing device that supports the concurrent execution of multiple computing processes. One example of a multi process device may have multiple semiconductor integrated circuit hardware processors each hardware processor capable of executing one or more physically concurrent computing processes. Another example of a multi process device may include only a single hardware processor but the single hardware processor may support the concurrent execution of multiple software firmware based computing processes e.g. using time sliced execution. Still other multi process devices may use multiple hardware processors that support the execution of multiple physically concurrent computing processes as well as the time sliced execution of multiple computing processes.

Multi process devices may be included in virtually any processor based digital electronic device. Such products may include but are not limited to computing devices such as computer servers desktop computers laptop computers and hand held computers communication devices such as cell phones digital radios and digital communication switches consumer entertainment products such as digital televisions digital versatile disc DVD players digital cameras and digital camcorders and control systems such as control systems used in automobiles aircraft HVAC environmental controls and security systems.

Each process executed by a multi process device requires the use of electronic memory to store one or more executable instructions control parameters input data for processing intermediate data values generated as a result of the process and or final output generated as a result of the process. However due to space constraints and or to reduce complexity and thereby increase reliability and manufacturing process yields semiconductor integrated circuit hardware processors one or more of which may be integrated within a multi process device typically include only a limited amount of memory storage. Typically a multi process device will include one or more memory controllers e.g. one or more direct memory access DMA controllers that allow the processes executed by the multi process device to use physical memory e.g. synchronous dynamic random access memory SDRAM double data rate synchronous dynamic random access memory DDR SDRAM static random access memory SRAM etc. that is located on an separately manufactured semiconductor integrated circuit. In this manner a multi process device may be configured with access to sufficient memory to meet the processing requirements of the multiple concurrently executing computing processes the multi process device will support.

Processes executed by a multi process device may communicate with each other by passing information and data between the respective processes. Such interprocess communication allows complex tasks performed by the multi process device to be divided into less complex subtasks that may be performed by separate processes executed by the multi process device. In such a configuration the respective processes executed by a multi processor device may communicate with each other to share status and or intermediate and or final processed results as needed to support the coordinated execution of a larger task.

Current techniques used for passing information and data between processes in a multi process device are inefficient. For example to support interprocess communication existing techniques require that data be copied from a memory area controlled by a first process or source process to a memory area controlled by a second process or destination process.

Such an interprocess communication approach is inefficient for several reasons including but not limited to the following. First such an interprocess communication approach increases the memory storage and bandwidth requirements of the multi process device by requiring that data passed in interprocess communications be stored more than once. Second the process of copying interprocess communication data from a first location to a second location requires processing and or bus clock cycles that could otherwise be used for other purposes. Increasing the memory size and bandwidth requirements of a multi process device increases the space and power requirements of the multi process device. Further increasing the processing cycles for the multi process device to perform a task requires that for time critical processes the clock speed of the multi process device must be increased thereby increasing the complexity and or the power requirements of the multi process device.

Further current interprocess communication techniques rely on the respective processes in a multi process device to self manage their respective shared memory usage and do not provide enforcement mechanisms that prevent one process from overwriting or freeing memory belonging to and in use by another process. As a result if one or more processes within a multi process device do not properly self manage their respective memory usage the entire multi process device may become unstable. In addition such problems are difficult to detect and isolate.

In accordance with a described interprocess communication approach a described interprocess memory controller may be used to provide multiple processes within a multi process device with access to a shared physical memory. Further the described interprocess memory controller may be used to provide efficient interprocess communication between the respective multiple processes. The processes serviced by the described interprocess memory controller may be executed by a single hardware processor or executed by multiple hardware processors within the multi process device.

The described interprocess memory controller may enforce access rights to shared memory that has been allocated to the respective processes thereby guarding the multi process device from instability due to the unauthorized overwriting and or unauthorized freeing of allocated memory.

The described interprocess memory controller approach may streamline interprocess communication by allowing data associated with an interprocess communication to be passed from a first process to a second process by passing a pointer to a buffer in shared memory that contains the message data. In this manner the described interprocess memory controller approach may avoid the inefficiency of interprocess communication approaches that copy message data from a shared memory controlled by a first process to a shared memory controlled by a second process.

The described interprocess memory controller may maintain a set of permissions for each buffer allocated from shared memory by the respective processes in a multi process device. For example when a process allocates a buffer from the shared memory the described interprocess memory controller may allocate permission to write to and to free the allocated buffer to the allocating process. Such allocated permissions may be stored by the described interprocess memory controller in association with the allocated buffer in physical memory. When a pointer to a buffer is passed or transferred from a first process i.e. the sending process to a second process i.e. the receiving process as part of an interprocess communication the described interprocess memory controller may reallocate permission to write to and to free the allocated buffer to the receiving process by updating the buffer s permission data stored in physical memory. In this manner the efficiency of interprocess communication is greatly increased and the integrity of the shared memory is maintained.

The described interprocess memory controller may enforce the permissions associated with the respective buffers allocated from shared memory. For example if the memory controller receives a request from a process to write to an identified location in memory or a request to free one or more buffers the memory controller may verify whether the requesting process is authorized to make such a request. If the permissions stored by the memory controller indicate that the process has authority for the request the request will be granted by the memory controller otherwise the request may be denied by the memory controller.

The described interprocess memory controller may be implemented in hardware and may communicate with one or more processes via an application programming interface. In one example of an embodiment of the described interprocess memory controller the application programming interface may include at least three commands. An ALLOCATE command may be used by a process to allocate control over one or more buffers from the shared memory. A TRANSFER command may be used by a first process with control over a buffer to transfer control of the buffer to a second process. A FREE command may be used by a process with control over one or more buffers to free the buffers for re allocation by any one of the processes executed by the multi process device.

The described interprocess memory controller may implement the above described application programming interface using a combination of registers and lists. For example a command register and a command list may be maintained to receive and control the execution of commands received from a process. Commands received from a process pertaining to a specific buffer may be held in the command list until processed by the described interprocess memory controller. Further a status register and a status list may be maintained to receive and control the transfer of status updates from the described interprocess memory controller to the process. Status updates generated by the described interprocess memory controller may be held in the status list until processed by the process to which the buffer is assigned.

As described in greater detail below the command status register list approach allows for efficient execution of the described interprocess memory controller application programming interface. The command status register list approach provides a store and forward structure that allows the respective processes and the described interprocess memory controller to operate efficiently. For example neither the described interprocess memory controller or the processes within a multi process device waste valuable processing cycles waiting for a command or a status update from each other respectively. In one example of the described interprocess memory controller when the memory controller is ready to process additional commands the memory controller may read multiple commands from a command list with a single read from shared memory thereby greatly reducing the overhead associated with the implementation of commands. Similarly when a process is ready to write additional status updates the process may write multiple status updates in a status list with a single burst write to shared memory thereby greatly reducing the overhead associated with the writing of status updates.

The described interprocess memory controller may allow processes to allocate virtual buffers. A virtual buffer may include one or more physical memory buffers or physical buffers allocated from a shared memory. For example if a physical buffer of size 256 bytes is used and eight physical buffers are included in a virtual buffer a virtual buffer of 2K bytes is achieved if a physical buffer of size 512 bytes is used and eight physical buffers are included in a virtual buffer a virtual buffer of 4K bytes is achieved if a physical buffer of size 1K bytes is used and eight physical buffers are included in a virtual buffer a virtual buffer of 8K bytes is achieved and if a physical buffer of size 2K bytes is used and eight physical buffers are included in a virtual buffer a virtual buffer of 16K bytes is achieved.

The use of virtual buffers provides the described interprocess memory controller with greater flexibility to meet the memory storage requirements of the respective processes executed by a multi process device. For example assuming that 16 bit virtual buffer pointers are used assuming the above constraints with respect to physical buffer sizes and the number of physical buffers included in a virtual buffer such a virtual buffer approach allows the described interprocess memory controller to manage up to 1 Gigabyte of shared physical memory for use in providing processes with enforced access controls and efficient interprocess communication services.

An example of a first embodiment may be a multi process device that includes at least one integrated circuit processor that supports concurrent execution of multiple computing processes a physical memory that is shared by the multiple computing processes and a memory controller that controls access by the multiple computing processes to the shared physical memory. The memory controller may include a memory allocation unit that allocates at least one physical buffer for use by a first computing process of the multiple computing processes and updates a portion of the at least one physical buffer to include an identifier that identifies the first computing process.

An example of a second embodiment may be a method of controlling access to portions of a physical memory shared among a plurality of computing processes executing on at least one integrated circuit processor. The method may include allocating at least one physical buffer for use by a first computing process of the plurality of computing processes updating a portion of the at least one physical buffer to store an identifier that identifies the first computing process and denying write access to the at least one physical buffer to any computing process with an identifier that does not match the identifier stored in the at least one physical buffer.

An example of a third embodiment may be a memory controller that includes a command list control unit that receives and stores commands received from a plurality of processes executing on one or more of a plurality of integrated circuit processors within a multi process device and a memory interface unit that retrieves and executes commands from the command list control unit to control allocation of a physical memory buffer from a physical memory execution of at least one of the commands resulting in a change of a status parameter portion of the physical memory buffer that controls access to the physical memory buffer by the plurality of processes.

Registration configuration unit may manage registers associated with an application programming interface between interprocess memory controller and the respective processes of a multi process device. For example as shown in at Pthrough P registration configuration unit may communicate with one or more processes executed by a multi process device via a predefined application programming interface. The application programming interface may be implemented using a combination of command status registers and command status lists. As the interface between memory controller and the respective processes of a multi process device registration configuration unit may maintain within the described interprocess memory controller a command list register and a status list register for a process executed by a multi process device. The command status registers maintained by registration configuration unit may be used to control access to the respective command status lists. Both the command status registers and command status lists are described in greater detail below with respect to and . Additional details related to an example of an embodiment of registration configuration unit are described below with respect to .

Command list status list control unit may manage command lists status lists associated with a process. For example interprocess memory controller may receive multiple commands from a process directed to an identified buffer controlled by the process. As described in greater detail with respect to below command list status list control unit may allocate command list buffers as needed to store commands received from the controlling process for transfer to memory interface unit . Further in response to the execution and or attempted execution of commands interprocess memory controller may generate status updates for transfer to a process. As described in greater detail with respect to below command list status list control unit may allocate status list buffers as needed to store status updates for transfer to the controlling process. Additional details related to an example of an embodiment of command list status list control unit are described below with respect to .

Interprocess memory controller may allow processes to allocate virtual buffers. A virtual buffer may include one or more physical memory buffers or physical buffers allocated from a shared memory. One example of a virtual buffer embodiment may be comprised of eight physical buffers as described below with respect to and . Address translation unit may receive read write update requests from a process and based on the nature of the buffer identified and or the memory addresses specified in the read write update request may perform a translation of a virtual memory address to one or more physical memory addresses. Once the memory addresses associated with a read write update request have been translated i.e. assuming such translation is required the read write update request may be passed to memory interface unit for execution. Additional details related to an example of an embodiment of address translation unit are described below with respect to .

Memory interface unit provides interprocess memory controller with an interface for communicating directly with a physical memory e.g. standard SDRAM DDR SDRAM SRAM etc. controller. Additional details related to an example of an embodiment of memory interface unit are described below with respect to .

Further registration configuration controller may maintain statistics related to the number and size of command status lists maintained. For example if the number and or size of the respective command status lists exceed one or more predetermined thresholds registration configuration controller may deny further allocation commands until the number and or size of the respective command status lists drops below the respective one or more predetermined thresholds. In addition example embodiments of registration configuration controller may maintain a unique buffer identifier and a unique process identifier in each control status register. If the process identifier of a process issuing a command that affects an identified buffer does not match the process identifier associated with the buffer identifier in the command status registers the command may be found invalid and registration configuration controller may request command list status list control unit to add a status update to the status list indicating that the received command was ignored and the status lists register may be updated to reflect entry of the new status update.

In one example of an embodiment of address translation unit virtual address translation unit may have access to a content addressable memory CAM that stores the translated physical address associated with the most recently accessed virtual addresses. If the virtual address translation unit locates a virtual address in CAM translation of the virtual address requires merely retrieving from CAM the physical address stored in association with the virtual address.

Such an embodiment may include a content addressable memory unit that continuously updates the CAM to drop least recently used virtual addresses from the CAM thereby retaining in CAM the most recently accessed and the most repeatedly accessed virtual memory addresses. For example in one such embodiment the CAM may retain for example 16 entries. When a new virtual address is translated the virtual address and its corresponding physical address may be added to the CAM and the least recently used virtual address may be dropped from the CAM. To determine which CAM element to drop content addressable memory unit may maintain a 4 bit counter for each CAM entry that is incremented on an access. Whenever a count gets to 0xF i.e. 15 all the respective counters may be divided by 2 i.e. shifted right insert 0. When inserting a new virtual address into the CAM content addressable memory unit may overwrite the CAM entry with the lowest counter. In the case of a tie content addressable memory unit may overwrite the lowest numbered entry in the CAM with the lowest counter. The size of the CAM should be large enough to hold the number of virtual buffers that may be accessed by active processes.

The above described CAM approach assumes that once a virtual address is used a first time there is a strong likelihood that the virtual address will again be used in the near future. Such an assumption is a good assumption for example in the case of a TRANSFER command in which a first process may write to a virtual address buffer and initiate an interprocess communication to another process using a TRANSFER command. Upon receiving a status update notifying the receiving process of the TRANSFER the receiving process is likely to attempt to read the buffer at the virtual address. Therefore by storing recently used virtual address translations in virtual memory the processing cycles required by virtual address translation unit to translate virtual addresses may be reduced. There is however no requirement that the shared memory appear in the same address space by different processors.

Memory allocation unit may allocate and maintain and or free stacks that contain pointers to physical buffers associated with an allocated virtual buffer in response to commands retrieved from a command list associated with a new or existing virtual buffer. Further memory allocation unit may allocate and or free buffers to hold command lists and or status lists in response to requests from command list management unit and status list management unit respectively.

In one example of an embodiment of memory allocation unit memory allocation unit may maintain a cache of pointers that may be emptied to populate a new virtual buffer stack e.g. in response to an ALLOCATE command and that may be loaded with pointers to buffers freed from a virtual buffer in response to a FREE command. Further memory allocation unit may in response to an ALLOCATE command allocate an initial command list buffer and an initial status list buffer that may be managed by command list management unit and status list management unit respectively. As described in greater detail with respect to and memory allocation unit may allocate additional buffers to command lists and or status lists e.g. at the request of command list management unit and status list management unit as the respective command lists status lists become full. Further memory allocation unit may free buffers from command lists and or status lists e.g. at the request of command list management unit and status list management unit as the respective command lists status lists become empty.

Memory access unit may provide an interface between memory interface unit and a physical memory e.g. standard SDRAM DDR SDRAM SRAM etc. controller. For example upon receipt of a read write update request from address translation unit containing for example an initial physical buffer pointer and range memory access unit may access the virtual buffer stacks maintained by memory allocation unit to formulate and submit to the physical memory controller appropriate read write update and free commands in accordance with the request from address translation unit .

Further upon retrieving a TRANSFER command from the command list maintained by command list management unit memory access unit may update the permission data stored for example in the virtual buffer header within buffer0 of the transferred virtual buffer to identify the receiving process as the process with control over the transferred virtual buffer. Header data that may be contained within the first bytes of buffer0 of a virtual buffer is addressed in greater detail with respect to . Further upon completion of all tasks associated with an ALLOCATE TRANSFER or FREE command by one of memory allocation unit and memory access unit memory interface controller may submit an appropriate status update to command list status list controller indicating the status of the respective task.

As described above with respect to a command list may be stored in a command list buffer allocated by memory allocation unit for use by command list management unit . The command list may be used to store commands from software to hardware such as commands related to the allocation transfer and or freeing of a virtual buffer prior to execution by memory interface unit . Should the number of received commands exceed the number of storage locations provided by a command list an additional command list buffer may be allocated and a pointer to the new command list buffer may be inserted at the last pointer storage location of the previous command list buffer i.e. position in that points to the start of the subsequent command list buffer.

For example in one example embodiment of interprocess memory controller registration configuration controller may monitor count of a number of remaining free command entries available in a command list. Upon detecting that the number of remaining free command list entries has dropped below a predetermined threshold registration configuration controller may inform command list status list controller of the condition. In response command list status list controller may instruct command list management unit to request an additional command list buffer via memory interface unit .

As described above with respect to a status list may be stored in a status list buffer allocated by memory allocation unit for use by status list management unit . The status list may be used to store status updates from hardware to software such as updates related to the allocation transfer and or freeing of a virtual buffer following execution and or attempted execution by memory interface unit . Should the number of received status updates exceed the number of storage locations provided by a status list an additional status list buffer may be allocated and a pointer to the new status list buffer may be inserted at the last pointer storage location of the previous status list buffer i.e. position in that points to the start of the subsequent status list buffer.

For example in one example embodiment of interprocess memory controller registration configuration controller may monitor count of a number of remaining free status entries available in a status list. Upon detecting that the number of remaining free status list entries has dropped below a predetermined threshold registration configuration controller may inform command list status list controller of the condition. In response command list status list controller may instruct status list management unit to request an additional status list buffer via memory interface unit .

For example if a physical buffer of size 256 bytes is used and virtual buffer stack stores eight buffer pointers a virtual buffer of 2K bytes is achieved if a physical buffer of size 512 bytes is used and virtual buffer stack stores eight buffer pointers a virtual buffer of 4K bytes is achieved if a physical buffer of size 1K bytes is used and virtual buffer stack stores eight buffer pointers a virtual buffer of 8K bytes is achieved and if a physical buffer of size 2K bytes is used and virtual buffer stack stores eight buffer pointers a virtual buffer of 16K bytes is achieved.

Hence the use of virtual buffers provides the interprocess memory controller with greater flexibility to meet the memory storage requirements of the respective processes executed by a multi process device. For example assuming that 16 bit virtual buffer pointers are used assuming the above constraints with respect to physical buffer sizes and the size of a virtual buffer stack such an approach allows interprocess memory controller to manage up to 1 Gigabyte of shared physical memory for using in providing processes with enforced access controls and efficient interprocess communication services.

In step S registration configuration unit may receive an ALLOCATE command from a processes executed by a multi process device and operation of the method continues to step S.

In step S registration configuration unit may initiate a new status list register and operation of the method continues to step S.

In step S command list status list control unit may allocate a new status list buffer and operation of the method continues to step S.

In step S registration configuration unit may store a pointer to the start of the status buffer list allocated in step S within the status list register initiated in step S and operation of the method continues to step S.

In step S registration configuration unit may initiate a new command list register and operation of the method continues to step S.

In step S command list status list control unit may allocate a new command list buffer and operation of the method continues to step S.

In step S registration configuration unit may store a pointer to the start of the command buffer list buffer allocated in step S within the command list register initiated in step S and operation of the method continues to step S.

In step S command list status list control unit may insert an ALLOCATE command into the command list and operation of the method continues to step S.

In step S registration configuration unit may update the command list register with an incremented command list buffer offset and may decrement the count of remaining free command list entries and operation of the method continues to step S.

In step S registration configuration controller may initiate an interrupt and operation of the method continues to step S.

In step S memory interface unit may retrieve the ALLOCATE command from the command list and operation of the method continues to step S.

In step S registration configuration unit may update the command list register with a decremented command list buffer offset and may increment the count of remaining free command list entries and operation of the method continues to step S.

In step S memory allocation unit may initiate a new virtual buffer stack and operation of the method continues to step S.

In step S memory allocation unit may assign buffer pointers to the virtual buffer stack initiated in step S and may set the state of the virtual buffer to include the identity of the process that allocated i.e. owns the virtual buffer and operation of the method continues to step S.

In step S memory allocation unit may insert a buffer allocated status update within the status list with a pointer to the first buffer of the allocated virtual buffer and operation of the method continues to step S.

In step S registration configuration unit may update the status list register an incremented status list offset and may decrement the number of remaining status list entries and operation of the method continues to step S.

In step S registration configuration controller may initiate an interrupt and operation of the method continues to step S and the process terminates.

In step S address translation unit may receive one of a read or write request from a process executed by a multi process device and operation of the method continues to step S.

If in step S address translation unit determines that the request includes virtual buffer addresses operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S address translation unit may translate received virtual buffer pointers to physical buffer pointers and operation of the method continues to step S.

In step S address translation unit may submit the read write request to memory interface unit and operation of the method continues to step S.

If in step S memory allocation unit determines that the request is a write request operation of the method continues to step S otherwise operation of the method proceeds to step S.

If in step S memory allocation unit determines that the requesting process controls the virtual buffer to be written to operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S memory access unit may write to the physical buffers of the virtual buffer with data provided in the request and operation of the method continues to step S.

If in step S memory allocation unit determines that the request is a read request operation of the method continues to step S otherwise operation of the method proceeds to step S and the process terminates.

In step S memory access unit may retrieve the contents of physical buffers of the virtual buffer identified by the read request and operation of the method continues to step S.

In step S registration configuration unit may receive a TRANSFER command from a process and may pass the TRANSFER command to command list status list control unit and operation of the method continues to step S.

In step S command list status list control unit may update the command list to include the TRANSFER command and operation of the method continues to step S.

In step S registration configuration unit may update the command list register with an incremented command list offset and may decrement the number of remaining command list entries and operation of the method continues to step S.

In step S registration configuration controller may initiate an interrupt and operation of the method continues to step S.

In step S memory interface unit may retrieve the transfer command from the command list and operation of the method continues to step S.

In step S memory interface unit may update the command list register with a decremented command list offset and may increment the number of remaining command list entries and operation of the method continues to step S.

If in step S memory allocation unit determines by checking the virtual buffer state that the process requesting the transfer owns the virtual buffer to be transferred operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S memory access unit may update the virtual buffer state to reflect the processes receiving the transfer as the owner of the virtual buffer and operation of the method continues to step S.

In step S memory access unit may insert a buffer transferred status update in the status list with a pointer to the first physical buffer in the transferred virtual buffer and operation of the method continues to step S.

If in step S memory allocation unit determines that the process requesting the transfer does not own the virtual buffer to be transferred operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S memory access unit may insert a transfer denied status update in the status list and operation of the method continues to step S.

In step S memory access unit may update the status list register with an incremented status list offset and may decrement the number of remaining status list entries and operation of the method continues to step S.

In step S the memory interface controller may initiate an interrupt and operation of the method continues to step S and the process terminates.

In step S registration configuration unit may receive a FREE command from a process and may pass the FREE command to command list status list control unit and operation of the method continues to step S.

In step S command list status list control unit may update the command list to include the FREE command and operation of the method continues to step S.

In step S registration configuration unit may update the command list register with an incremented command list offset and may decrement the number of remaining command list entries and operation of the method continues to step S.

In step S registration configuration controller may initiate an interrupt and operation of the method continues to step S.

In step S memory interface unit may retrieve the FREE command from the command list and operation of the method continues to step S.

In step S memory interface unit may update the command list register with a decremented command list offset and may increment the number of remaining command list entries and operation of the method continues to step S.

If in step S memory allocation unit determines that the process requesting the FREE owns the virtual buffer to be freed operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S memory access unit may return physical buffers in the freed virtual buffer to the cache of free physical buffers and operation of the method continues to step S.

In step S memory access unit may insert a buffer freed status update in the status list and operation of the method continues to step S.

If in step S memory allocation unit determines that the process requesting the FREE does not own the virtual buffer to be freed operation of the method continues to step S otherwise operation of the method proceeds to step S.

In step S memory access unit may insert a FREE denied status update in the status list and operation of the method continues to step S.

In step S memory access unit may update the status list register with an incremented status list offset and may decrement the number of remaining status list entries and operation of the method continues to step S.

In step S the memory interface controller may initiate an interrupt and operation of the method continues to step S and the process terminates.

From the foregoing description it will be appreciated that an approach for streamlining interprocess communication and for guarding a multi process device from instability is disclosed. The described interprocess memory controller may enforce access rights to shared memory that has been allocated to the respective processes thereby guarding a multi process device from instability due to the unauthorized overwriting and or unauthorized freeing of allocated memory. Further the described interprocess memory controller approach may streamline interprocess communication by allowing data associated with an interprocess communication to be passed from a first process to a second process by passing a pointer to a virtual buffer in shared memory that contains the message data. In this manner the described interprocess memory controller approach may avoid the inefficiency of interprocess communication approaches that copy message data from a shared memory controlled by a first process to a shared memory controlled by a second process.

For purposes of explanation in the above description numerous specific details are set forth in order to provide a thorough understanding of the described interprocess memory controller and the described approach for streamlining interprocess communication and the described approach for guarding a multi process device from instability. It will be apparent however to one skilled in the art that the described approach for implementing the described interprocess memory controller and described approaches may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid obscuring the features of the described interprocess memory controller and methods for implementing the described approach for streamlining interprocess communication and methods for implementing the described approach for guarding a multi process device from instability due to the unauthorized overwriting and or unauthorized freeing of allocated memory.

While the described approach for implementing the described interprocess memory controller and the described approach for streamlining interprocess communication and the described approach for guarding a multi process device from instability have been described in conjunction with the specific embodiments thereof it is evident that many alternatives modifications and variations will be apparent to those skilled in the art. Accordingly embodiments of the described interprocess memory controller and the described methods of use as set forth herein are intended to be illustrative not limiting. There are changes that may be made without departing from the spirit and scope of the invention.

