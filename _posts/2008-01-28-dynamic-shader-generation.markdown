---

title: Dynamic shader generation
abstract: Some embodiments provide a method of performing several shading operations for a graphic object in a scene that is displayed on a device. The device includes several processing units. The method receives a set of criteria that can define a set of parameters that relate to the shading operations. The method determines an allocation of the shading operations to the processing units based on the received criteria. The method allocates the shading operations to the processing units based on the determined allocations. The method renders the graphic object based on several instructions that comprise the shading operations. In some embodiments, the set of criteria is received during execution of the operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08203558&OS=08203558&RS=08203558
owner: Apple Inc.
number: 08203558
owner_city: Cupertino
owner_country: US
publication_date: 20080128
---
The present invention relates to computer graphics and in particular to performing rendering effects.

Shaders are software programs which are used by the rendering resources of a computer to calculate the color and shape of an object. Currently software libraries such as Open Graphics Library OpenGL and DirectX include shading functions in their Application Programming Interface API . These libraries enable programmers to write programs that access hardware graphics features of a computer without having detailed knowledge of the underlying graphics hardware.

Shading languages such as OpenGL Shading Language GLSL are developed which are based on a high level programming language such as C or C . These languages allow developers to avoid using assembly language or hardware specific languages. The high level OpenGL shading constructs are compiled to Graphical Processing Unit GPU machine language. Similarly the assembly language OpenGL Architecture Review Board ARB can be used from a high level programming language to develop shader programs as described further below.

There are different types of shaders such as vertex shaders geometry shaders and fragment or pixel shaders. Vertex shaders operate on datasets called vertices. Properties such as color and position of the vertices can be changed by the vertex shader. Geometry shaders operate on groups of individual vertices. Fragment or pixel shaders calculate the color value of individual pixels using the polygons produced by the vertex and geometry shaders. The set of vertices and or pixels define the shape color and other properties of a graphics object. Generally a shader includes all three or at least the vertex and fragment shaders. Code sections related to vertex shaders execute faster while code sections related to fragment shaders execute slower but produce finer results. In the following discussions the terms shader used alone or shader program refer to all different variety of shaders while individual shaders are identified by their specific prefixes vertex fragment geometry etc. .

Graphics application programmers write the application in a high level language such as C and write shaders in ARB or GLSL. The shader constructs are embedded as string constants in the high level language. illustrates an example of such a program written in C . As shown the program includes several string constants that include program statements in ARB. However when the application requires a large number of different variants of a shader then string constants become inconvenient because the shader variants have a lot of similar code that are copied and pasted from one to another.

The programmers also use macros to combine snippets of code. illustrates an example of using macros to create shader programs in ARB. Macros such as OZ GL FP MAGNIFIER are used to combine snippets of code. The resulting programs are however hard to debug understand or extend.

One alternative is to assemble shaders by programmatically concatenating strings. This approach results in C code that is complicated and hard to write or maintain because assembling shaders out of lots of small string snippets is hard to read. The C code has to manage what operations go into the vertex shader and what operations go into the fragment shader and which variables e.g. uniform attribute or varying are needed to support them. Complexity of that task limits the use of this alternative. Furthermore assembling strings at runtime requires making sure about all different ways that the strings may need to be combined to produce a valid program.

For instance when a shader application has a mask a blend mode and lighting it becomes too complex to include all three areas into one shader since each has its own issues to manage. Masking supports multiple inputs with different Boolean operators bending supports operations such as gamma correction and bilinear sampling and lighting supports multiple instances of several different kinds of light sources. It becomes too complex to take several components of an imaging operation and integrate them to make a dynamic shader.

When trying to combine different calculations together to make dynamic shaders one main challenge would be to determine which calculations should be done by the main CPU the vertex processor or the fragment processor. Decisions are to be made as how often to perform different parts of the shader e.g. once for every single pixel once per vertex or just once per object. Calculations should be done at a high frequency by a fragment shader if necessary but otherwise should be done at a low frequency by vertex shader or CPU for better performance. One example of an existing shader program is SH. SH allows the use of a high level program language constructs. However the instructions written in SH has to be specifically allocated to either vertex or fragment shaders with no flexibility to allocate instructions to each shader at runtime.

There is therefore a need in the art for a framework that can represent shading calculations and let a user manipulate them even if they come from different modules of the application. It is also desirable to be able to combine different shader pieces of code together automatically eliminating unnecessary steps and combining redundant steps. It is further desirable to have a framework to either figure out optimal frequencies automatically or allow manual control over what gets done by CPU vertex shader or fragment shader.

Some embodiments provide a method of performing several shading operations for a graphic object in a scene that is displayed on a device. The device includes several processing units. The method receives a set of criteria that can define a set of parameters that relate to the shading operations. The method determines an allocation of the shading operations to the processing units based on the received criteria. The method allocates the shading operations to the processing units based on the determined allocations. The method renders the graphic object based on several instructions that comprise the shading operations. In some embodiments the set of criteria is received during execution of the operations.

Some embodiments provide a method of shading a graphic object based on a set of shading instructions. The method determines a frequency of computation for each of the shading instructions based on a set of rendering criteria. The method allocates each of the shading instructions to one of several shader programs each of the shading programs utilize a different set of input data and a different frequency of computation for each input data. The method renders the graphic object by using the shader programs. In some embodiments the set of shading instructions are allocated to the shader programs during an execution of an object program the object program generated from a source program written in a high level programming language. In some embodiments the set of rendering criteria is received after the object program is generated.

In the following description numerous details are set forth for the purpose of explanation. However one of ordinary skill in the art will realize that the invention may be practiced without the use of these specific details. In other instances well known structures and devices are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail.

Some embodiments provide a method of performing several shading operations for a graphic object in a scene that is displayed on a device. The device includes several processing units. The method receives a set of criteria that can define a set of parameters that relate to the shading operations. The method determines an allocation of the shading operations to the processing units based on the received criteria. The method allocates the shading operations to the processing units based on the determined allocations. The method renders the graphic object based on several instructions that comprise the shading operations. In some embodiments the set of criteria is received during execution of the operations.

Some embodiments provide a method for hiding computational frequencies of a shader program data items. These embodiments utilize a meta compiler to automatically determine these computational frequencies. In these embodiments the computational frequency strategy can be varied at runtime based on what graphics hardware is available or based on different trade offs between performance and visual quality.

Some embodiments provide a method of shading a graphic object based on a set of shading instructions. The method determines a frequency of computation for each of the shading instructions based on a set of rendering criteria. The method allocates each of the shading instructions to one of several shader programs each of the shading programs utilize a different set of input data and a different frequency of computation for each input data. The method renders the graphic object by using the shader programs. In some embodiments the set of shading instructions are allocated to the shader programs during an execution of an object program the object program generated from a source program written in a high level programming language. In some embodiments the set of rendering criteria is received after the object program is generated.

Several more detailed embodiments of the invention are described in sections below. Specifically Section I describes dynamic shader generation techniques of some embodiments. Next Section II describes scheduling of computational frequencies in some embodiments. Finally Section III provides a description of a computer system with which some embodiments of the invention are implemented.

Shaders must be compact to run efficiently. Some embodiments provide a method that allows writing shader programs using a high level programming language. In some embodiments the high level programming language used supports the OpenGL API. These embodiments utilize the complexity management tools of the high level programming language to simplify shader programming. The shader functions are provided in a set of libraries. Each library includes a set of shader functions. Although several examples in the following sections are shown that are based on C language a person of ordinary skill in the art would realize that other high level programming languages such as C C Python Java etc. can be used without deviating from the teachings of the invention.

In some embodiments metaprogramming is used to convert shader functions to code suitable for execution on one or more graphics processing units GPUs . Metaprogramming is defined as dynamically generated code or code that writes code . Some embodiments utilize metaprogramming to use delayed evaluation to re target computation from the CPU to the GPU.

Next as the code is being executed on the CPU the process generates at graphs or structures for shader objects but postpones performing the actual computations until a shader is required to render a graphic object. When the shader is needed to draw an object the process allocates at code for different shader operations to the vertex geometry and fragment shaders. As described further below some operations may be assigned to the CPU.

Next for the code that is allocated to different shaders if necessary the process produces at a target code such as ARB that is suitable for execution on the GPU. Finally the shader code is sent at to the GPU for execution in order to render the graphic object. Each of the above steps is described in further detail below.

As shown in the process starts executing at the object code. As described above the object code is generated by compiling linking or interpreting a source code that is written in a high level host language. As shown in the source code utilizes a set of libraries and . While the libraries are the libraries of the high level language shader libraries include shader functions generated using the novel techniques described in the current disclosure.

Functions provided in shader libraries follow the same syntax of the host high level language. These functions can have names unique for a shader application or can have same name as functions of the host language overloaded to be distinguished as shader functions. Overloading is a technique used in some high level languages for reusing the same name for different functions or operators and relying on differences in the argument list to distinguish between them. The type and or the number of arguments have to be different.

Therefore the source code includes library calls or shader constructs such as functions structures classes operators etc. which follow the syntax of the host language. The source code is then compiled linked or interpreted to generate the object code. The object code is executed on the central processing unit CPU of the computer.

During the execution of the program if any shader related constructs are invoked at the values associated with these constructs are updated at without actually invoking the shader program. Although only shows one instant of executing such shader related constructs for simplicity many such construct can be included in the code and their execution can be mixed with the execution other code that are unrelated to shader program. Eventually the process reaches at to a point where the function to shade an object is invoked.

When the shader program is required to render an object the process uses at a set of criteria to allocate the shader code to vertex geometry or vertex shaders. The process also based on the set of criteria allocates portions of code to be executed by the CPU instead of the GPU .

For the Example for only the last part of the shader i.e. multiplying diffuseColor by illum must be evaluated in the fragment shader. The other multiplications and the dot product can be done in the vertex shader and the normalization can be done on the CPU because its input is a uniform. illustrates the code generated in some embodiments for different shaders based on the example shown in . The set of criteria to determine whether the code must be allocated to the fragment shader vertex shader or the CPU is described further below.

Data types such as Var and Program shown in are types defined in the shader libraries . Declaring lightDir as a type Var or program as a type Program will cause the host language in this case C to use definitions found in these libraries for lightDir and Program. Also as is described further below when a statement such as program.frag.fragColor diffuseColor illum is executed rather than immediate evaluation will cause a data structure associated with shader in the form of a tree or graph to be created and or updated. This graph is later on converted to shader language when the shader is used to render an object. In some embodiments in order to invoke the shader to draw an object an instruction such as program.use is placed in the source code written in the high level host language.

Referring back to the process executes at the portion of the shader code that is allocated to the CPU. The process then generates at shader code in a shader language such as GLSL. If necessary the code is then converted at to a format that is acceptable by the GPU . In some embodiments a high level shader code such as GLSL is generated at and is passed at to OpenGL compiler to generate ARB which is executable by the GPU . Next the process sends at the executable shader code to the GPU . The process then performs other non shader code if any and exits.

Although the shaders shown in would have been easy to write by hand if the application had to support a variety of types of light sources ambient directional point sopt area sky etc. interacting with a variety of reflectance functions lambert phong blinn phong etc. then defining light objects and surface objects that describe different parts of shader would have been much more complex.

Shaders must be compact to run efficiently. The use of a high level programming language allows some embodiments to utilize the complexity management tools of the high level programming language to simplify shader programming. In some embodiments the task of shader writing can be delegated to various objects via virtual methods.

In the example of the contribution of each light object is added to the color. As can be appreciated from the example of the complexities such as iterating over a set of lights are expressed in the high level language. However instead of performing the operations immediately as described in Section I the operations are remembered by saving the information in data structures and classes translated into a different language and retargeted to be executed on the GPU. Other examples include making a strategy object for tone mapping or traversing a tree of mask operations a composite pattern .

In some embodiments invoking a shader structure or program member during the execution of the high level language host program causes data structures to be created. Instead of immediately executing any instructions a data structure is created to represent the desired action. This data structure will then be translated to shader language upon the first request to use the shader for rendering an object.

On the other hand illustrates the result of delayed evaluation of the same statement in some embodiments. As shown the execution of the code results in creation of a data structure that will be stored and will be evaluated only when the shader is needed to render an object. Furthermore the data structure can be allocated to either execute on the CPU or to be allocated to either the vertex shader or the fragment shader and execute on the GPU. The delayed evaluation therefore results in creating the data structure shown in even when the values of a and b are still unknown.

It should be appreciated that shows a simple addition operation. A structure such as is only generated when the line of code is executed as a result of execution of a line of code that is identified as shader code e.g. during execution of an invocation of an entity defined in one of shader libraries shown in . On the other hand when the line of code is not a part of the shader program i.e. the line of code is executed in a portion of the high level language code which is unrelated to shader program the line of code is immediately executed.

Values related to shader programs require different computational frequencies. While some values are constant other values may require to be calculated once per pixel once per vertex or once per object. For instant values related to a fixed light source can be uniform per object and need to be computed only once per object. Such values can be computed by the CPU instead of the GPU . On the other hand some values may require computation per vertex or per pixel.

Since the fragment shader performs computations for more points than the vertex shader there are more pixels than vertices if calculations can be moved to the vertex shader and still produce acceptable results the resulting program will execute faster. In some embodiments the decision to allocate different operations to different shaders or the CPU is made by considering a set of criteria. These criteria can be pre determined and applied automatically and or can be based on a set of criteria set by a user.

It should be appreciated that the example of is just a simple example of an application with a user interface that uses the teachings of the current invention. The invention is however readily applicable to other applications. For instance the invention can be used in applications such as Motion that create and edit motion graphics titling for video and film production and two dimensional 2D and three dimensional 3D visual effects. When integrated in such an application a set of controls such as controls will be provided by the application. An artist designing or editing a scene or animation can for example use the provided controls to change certain shader parameters for one or more graphical objects in a scene. The artist can then examine the results for different selections of controls to choose a desired combination and to render the scene. Depending on the parameters selected by the artist different shader operations are allocated to different shaders during rendering of the scene.

Another example of the use of the invention is to integrate the invention in a product such as an interactive program such as a game or any other motion animation product. A user of such a product e.g. a person playing the game or watching the animation can be provided with a set of controls. The user can then change the controls e.g. based on the capabilities of the user s device or computer . For instance the user may elect to turn off some time consuming graphics features if the user equipment is too slow. The user may also change the settings for different aesthetic experience. The specific settings will then effect how different shader operations are allocated when the program is running e.g. when the game is being played .

Also a user of such a game or interactive application can change some parameters in real time by actually interacting with the application. For instance during playing of a game the user may decide that one of the game actors standing in a room shall open a door. Opening the door may result in an additional light source to illuminate the objects in the room. This additional light source might have the same effect on allocation of shader operations as changing one of the controls e.g. number of lights shown in box .

The examples of show several other user selectable controls. Specifically these controls are gamma correct per fragment specular metallic Phong and Fresnel. The gamma correct control determines whether or not lighting calculations are performed on linearized intensity values. When the gamma correction is off the program runs faster but the results are not accurate or aesthetically pleasant. illustrates an example of the code generated when the gamma correct control is set to on. As shown more code and is automatically generated for the vertex and fragment shaders respectively.

Setting the per fragment control on forces more code to be performed by the fragment shader. The result will be more accurate shading and slower program execution. illustrates an example in some embodiments where the per fragment control is set to on. When the metallic control is on it generates a metallic tone for the object. The Phong Fresnel and specular controls determine different reflection models for the object.

As shown in the inputs to the graph are conceptually shown as the leaves of the graph . Specifically the inputs are light intensity surface color light position object position surface normal and eye position . The graph also shows different operations performed on the inputs and on the intermediate results shown as arrows . The output of the graph is fragment color . For this example light intensity is assumed to be constant. Surface color light position and eye position are assumed to be uniform i.e. the same for the surface of the object that is being rendered . Object position and surface normal which is a vector that describes the orientation of a surface i.e. a unit vector that points perpendicular to the surface are assumed to be attributes i.e. vertex data .

Next the process conceptually labels at each node of these graphs with the frequency of update that is required for the particular node. illustrates examples of different type of data items that require different update frequencies in some embodiments. Specifically a constant data item is a data item that is known when the program is written and does not require any calculations throughout the execution of the program. A uniform data item is the same throughout the surface to which it is applied. Such a data item requires to be calculated once per surface being rendered. A vertex or per vertex data item requires one calculation per vertex data. A fragment or per fragment data item requires to be updated once per pixel. It should also be appreciated that in some embodiments per vertex and per fragment data items must also be updated once per each frame of a video sequence being rendered.

Referring back to the process next enumerates at the necessary nodes and drops the unused nodes. illustrates the results of applying the labeling to other nodes of the graph . In this specific example each intermediate node and the output node is labeled according to the inputs that the node receives. In some embodiments each node is labeled with a frequency that is as high as the highest frequency of all its inputs or higher if necessary for accurate calculation. As shown node is labeled as uniform nodes and are labeled as per vertex and nodes and are labeled as per fragment shown as F . illustrates the results of dropping some nodes. As shown in since eye position and the results of subtract operation are not used in computing the value of fragment color the nodes and of the graphs are dropped shown with dashed lines .

Next as shown in the manual per vertex functions are processed at by substituting nodes. These functions are functions that are specified in the code hence the term manual to be performed by the vertex shader. For instance some embodiments provide a function called perVertex that can be used by a programmer to force the computations to be done by the vertex shader even if the computations would otherwise be allocated to the fragment shader. Therefore in step all nodes currently labeled as per fragment nodes which are specified in the code to be forced to vertex shader are re labeled i.e. substituted as per vertex.

Next the process identifies at uniform input and varying inputs. In some embodiments varying inputs are used to communicate between fragment and vertex shaders. In some embodiments the uniform and varying inputs are identified by examining the edges in the graph where the output is vertex or fragment but the input is not the same frequency. In some embodiments the uniform inputs are identified by finding connections in the graph between uniform nodes and per vertex or per fragment nodes. Similarly varying data is a junction from a per vertex node to a per fragment node. The edges shown as arrows in the graph where the nodes on either side are not labeled the same are identified. The process does not apply to attributes because the attributes are declared as such and their values are always specified directly in the code. illustrates the results of identifying uniform attribute and varying inputs for the current example.

Next as shown in the process builds at vertex and fragment shader text. In some embodiments the vertex shader code is generated from nodes labeled as vertex shown as V . illustrates the code allocated to the vertex shader in the current example. As shown in only the subtract operation is labeled as V and is allocated to the vertex shader.

In some embodiments the fragment shader code is generated from nodes labeled as fragment shown as F . illustrates the code allocated to the fragment shader in the current example. As shown in the normalize dot multiply and fragment color operations are labeled as F and are allocated to the fragment shader.

Next the process computes at the values for uniform inputs. In some embodiments the uniform calculations are performed by the CPU. illustrates the portion of the code allocated to the CPU for the current example. As shown the multiply operation is allocated to the CPU for execution. Finally the portions of the graph that are allocated to the fragment and vertex shader are translated to a shader language such as GLSL or ARB which can be passed at to OpenGL.

In some embodiments OpenGL converts the fragment and vertex codes in form suitable for the GPU to execute and sends them to the GPU for execution. In some embodiments an override can cause all shader code to be executed on the CPU at a cost of running the shader program slower .

The bus collectively represents all system peripheral and chipset buses that support communication among internal devices of the computer system . For instance the bus communicatively connects the processor with the read only memory the system memory and the permanent storage device .

From these various memory units the processor also referred to as central processing unit or CPU retrieves instructions to execute and data to process in order to execute the processes of the invention. The read only memory ROM stores static data and instructions that are needed by the processor and other modules of the computer system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instruction and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device . Other embodiments use a removable storage device such as a floppy disk or Zip disk and its corresponding disk drive as the permanent storage device.

Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such as a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime.

Instructions and or data needed to perform processes of some embodiments are stored in the system memory the permanent storage device the read only memory or any combination of the three. For example the various memory units may contain instructions for processing multimedia items in accordance with some embodiments. From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards touch panels and cursor controllers. The input devices also include scanners through which an image can be input to the computer system. The output devices display images generated by the computer system. For instance these devices display IC design layouts. The output devices include printers pen plotters laser printers ink jet plotters film recorders and display devices such as cathode ray tubes CRT liquid crystal displays LCD or electroluminescent displays.

Also as shown in bus also couples computer to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet . Finally as shown in the computer system also includes a graphics processing unit GPU . A GPU also referred to as a visual processing unit or a display processor is a dedicated graphics rendering device which is very efficient in manipulating and displaying computer graphics. The GPU can be included in a video card not shown or can be integrated into the mother board of the computer system along with the processor . Also the computer system may be used as a personal computer a workstation a game console or the like. Any or all of the components of computer system may be used in conjunction with the invention. However one of ordinary skill in the art will appreciate that any other system configuration may also be used in conjunction with the invention.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. In other places various changes may be made and equivalents may be substituted for elements described without departing from the true scope of the present invention. For instance although several examples are described using C as the host language a person of ordinary skill in the art would realize that other high level programming languages such as C C Python Java etc. can be used without deviating from the teachings of the invention. Also some examples are given in which portions of the shader program are allocated to vertex shader fragment shader and CPU. A person of ordinary skill in the art would realize that the same approach can be easily expended to allocating portion of the shader program to a geometry shader or any other specific shader that may be used in the art.

Furthermore GLSL and ARB are used as examples of a high level and an assembly shader programming language. Other shader programming languages can be readily used to practice the teaching of the invention. It should also be appreciated that although the vertex and fragment codes in the examples given above are sent to the GPU for execution in some embodiment all or portion of this code can be executed on the CPU at cost of running the shader program slower. Similarly performing uniform calculations can be done by the GPU at a possible cost of slower GPU execution . Thus one of ordinary skill in the art would understand that the invention is not limited by the foregoing illustrative details but rather is to be defined by the appended claims.

