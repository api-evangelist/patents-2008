---

title: Methods and systems for generating availability management framework (AMF) configurations
abstract: Techniques for generating a system model for use by and availability management framework (AMF) are described. Inputs are received, processed and mapped into outputs which are further processed into a configuration file in an Information Model Management (IMM) Service eXternal Markup Language (XML) format which can be used as a system model by an AMF.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08006130&OS=08006130&RS=08006130
owner: Telefonaktiebolaget L M Ericsson (Publ)
number: 08006130
owner_city: Stockholm
owner_country: SE
publication_date: 20080930
---
This application is a continuation in part of U.S. patent application Ser. No. 11 961 849 filed on Dec. 20 2007 and entitled Methods and Systems for Generating Availability Management Framework AMF Configurations the disclosure of which is expressly incorporated here by reference. This application is also related to and claims priority from U.S. Provisional Patent Application Ser. No. 61 085 583 filed on Aug. 1 2008 entitled Automatic Generation of AMF Compliant Configuration Top Down Approach the disclosure of which is also expressly incorporated here by reference.

The present invention generally relates to high availability HA systems hardware and software and more particularly to HA systems managed by an Availability Management Framework AMF .

High availability systems also known as HA systems are systems that are implemented primarily for the purpose of improving the availability of services which the systems provide. Availability can be expressed as a percentage of time during which a system or service is up . For example a system designed for 99.999 availability so called five nines availability refers to a system or service which has a downtime of only about 0.44 minutes month or 5.26 minutes year.

High availability systems provide for a designed level of availability by employing redundant nodes which are used to provide service when system components fail. For example if a server running a particular application crashes an HA system will detect the crash and restart the application on another redundant node. Various redundancy models can be used in HA systems. For example an N 1 redundancy model provides a single extra node associated with a number of primary nodes that is brought online to take over the role of a node which has failed. However in situations where a single HA system is managing many services a single dedicated node for handling failures may not provide sufficient redundancy. In such situations an N M redundancy model for example can be used wherein more than one M standby nodes are included and available.

As HA systems become more commonplace for the support of important services such as file sharing internet customer portals databases and the like it has become desirable to provide standardized models and methodologies for the design of such systems. For example the Service Availability Forum SAF has standardized application programming interfaces APIs to aid in the development of portable highly available applications. As shown in the conceptual architecture stack of the AIS is intended to provide a standardized interface for the HA middleware to support HA applications . As described below each set of AIS functionality is associated with an operating system and a hardware platform . The reader interested in more information relating to the AIS standard specification is referred to Application Interface Specifications AIS Release 5 which is available at www.saforum.org the disclosure of which is incorporated here by reference.

Of particular interest for the present application is the Availability Management Framework AMF which is a software entity defined within the AIS specification. According to the AIS specification the AMF is a standardized mechanism for providing service availability by coordinating redundant resources within a cluster to deliver a system with no single point of failure. The AMF provides a set of application program interface API functions which are used among other things to set the states of components within a cluster and to determine the health of those components. The components are also provided with the capability to query the AMF for information about their state. An application which is developed using the AMF APIs and following the AMF system model leaves the burden of managing the availability of its services to the AMF. Thus such an application does not need to deal with dynamic reconfiguration issues related to component failures maintenance etc.

The AIS standard also defines the information model IM for applications to be controlled by AMF. According to this IM a service unit SU as a logical entity that aggregates a set of components thereby combining their individual functionalities to provide a higher level service. A service unit can contain any number of components but a particular component can be configured in only one service unit. Since each component is always enclosed in a service unit from the AMF s perspective the service unit can be considered the incremental unit of redundancy in the sense that it is the smallest logical entity that can be organized into groups in a redundant manner to provide and protect the service instances.

A service group SG is defined within the AMF information model as a logical entity that groups one or more SUs in order to provide service availability for a particular set of service instances according to a particular redundancy model. The AMF information model also defines an application as being a logical entity that contains one or more SGs. An application combines the individual functionalities of the constituent service groups to provide a higher level of service. From a software administration point of view this grouping into an application reflects the set of SUs and contained components that are delivered as a consistent set of software packages to the AMF environment. Within this environment by introducing the software management framework SMF the AMF information model was extended with types that allow the characterization of software developed for SAF systems e.g. software which is used to provide HA services managed by the AMF.

This software can typically be deployed in different configurations depending on for example the characteristics of the system it is deployed on the number of nodes and their characteristics the capabilities of the AMF implementation and the requirements put on the provided services. Thus a software vendor can describe their software such that it would allow for the widest possible usage by describing various AMF related characteristics of the software. Based on this a system integrator has to produce a particular configuration for the system the software is deployed on. However none of the current SAF specifications define how to generate the information model i.e. the configuration to be used by an AMF implementation in a particular system for a particular application. Therefore one option for creating an information model would be to create it manually. Considering the potential for an AMF configuration file to have hundreds if not thousands of lines of code to be properly defined creating a configuration file in a manual manner will be time consuming and prone to errors.

Accordingly it would be desirable to provide systems and methods automating the generation of configurations for an AMF system or process.

Systems and methods according to the present invention address this need and others by automating the generation of configurations for an AMF system or process.

According to an exemplary embodiment a method for generating a configuration for an Availability Management Framework AMF includes the steps of selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file generating entities associated with the selected entity types and distributing at least some of the generated entities on nodes of a cluster.

According to another exemplary embodiment a system includes a processor for generating a configuration for an Availability Management Framework AMF including performing the functions of selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file generating entities associated with the selected entity types and distributing at least some of the generated entities on nodes of a cluster.

According to another exemplary embodiment a computer readable medium contains instructions stored thereon which when executed by a computer or a processor perform the steps of selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file generating entities associated with the selected entity types and distributing at least some of the generated entities on nodes of a cluster.

The following description of the exemplary embodiments of the present invention refers to the accompanying drawings. The same reference numbers in different drawings identify the same or similar elements. The following detailed description does not limit the invention instead the scope of the invention is defined by the appended claims.

To provide some additional context for this discussion consider an exemplary Availability Management Framework AMF controlled High Availability HA system as shown in . Therein four nodes A B C and D are associated with two service groups SG and SG . A service group is a group of service units SUs which provide service availability for one or more service instances SIs of particular services. For example SG includes SU and SU which in this example support an instance of an e mail service hardware and software and SG includes SU SU and SU which support two instances of a fax service hardware and software . At runtime for the email service instance SIA supported by SG AMF may select to assign SU the active state and SU the standby state.

Each of the exemplary service units in SG has two components associated therewith. A component is the smallest logical entity on which the AMF performs error detection and isolation recovery and repair. Thus a component typically includes all of the functions which cannot be clearly separated for error containment or isolation purposes. The component is also the logical entity that a portion of a workload is assigned within the provisioning of a service instance e.g. the email service. Such a portion of the workload is called a component service instance CSI . The email service instance SI A is composed of two component service instances CSI A and CSI A. Each of these can be assigned to a component within a service unit. Components can further be grouped into protection groups which reflect the redundancy associated with provisioning of the component service instances. For example components C and C can form a first protection group for CSI A and components C and C can form a second protection group for CSI A both of which are associated with the email service instance SI A. Thus if component C fails while being assigned active for CSI A and C assigned as standby the AMF could fail over CSI A to component C the active state and similarly if component C fails while being active for CSI A then the AMF could fail over CSI A to component C the active state. At the time of the fail over of CSI A AMF will switch over or will fail over CSI A as well so the entire service unit SU becomes assigned active for the entire service instance SI A.

Service group SG illustrates a slightly different configuration wherein two instances of a fax service are supported by three service units SU SU and SU. For example SU and SU could each be assigned by AMF the active state such that each supports one instance of the fax service while SU could be assigned the standby state and operate as their redundant backup. In this case components C and C would form one protection group associated with one of the two fax service instances SI B and within that protect component service instance CSI B. Components C and C could form a second protection group to protect CSI C associated with the other SI C of the two fax service instances.

In the above described examples service groups service units and components can all considered to be logical entities associated with physical entities that perform work. These logical entities are assigned workloads in order to render the service e.g. email or fax service. A component service instance CSI represents the workload that the AMF can dynamically assign to a single component. Component service instances are grouped into a logical entity called a service instance SI . A service instance aggregates all component service instances to be assigned to the individual components of the service unit in order for the service unit to provide that particular service instance e.g. email or fax service. A service instance represents a single workload assigned to the entire service unit. As shown in service instances are shown as well as their relationship with the components service units and service groups on the four nodes. More specifically for SIA SU is assigned the active HA state and SU is assigned the standby HA state as shown by the dashed connecting line . For SIA two CSIs A and A are assigned to components C and C and to C and C respectively. Regarding SIB SU is assigned the active HA state and SU is assigned the standby state as shown by the dashed connecting line . Similar comments apply towards SIC .

For an AMF software entity to operate in the above described exemplary manner the AMF software entity needs to receive from a configuration repository an input file or system model which describes what is to be managed. In a Service Availability Forum SAF cluster the Information Model Management Service IMM typically serves as the configuration repository . According to one exemplary embodiment such configuration information can take the form of an XML eXternal Markup Language file however it will be appreciated that the particular form or format of the configuration input is not critical. According to exemplary embodiments a high level method for generating the configuration input an AMF application will now be described with respect to . Initially an AMF Configuration Generator receives inputs of entity types e.g. as entity types files ETFs and services set user input to perform a mapping function which creates a system model for future use. This system model is output by the AMF Configuration Generator in the form for example an XML file according to the SAF Information Model Management IMM Service XML schema . This output code in an IMM XML file is then stored in the configuration repository in step . These various inputs and steps will be described in more detail below.

The first exemplary input is entity types which describe for example various AMF related characteristics associated with application software to be controlled by the AMF system. These entity types are AMF entity types described in XML entity types files as described by the SAF Software Management Framework SMF specification SAI AIS SMF A.01.01 which is available at www.saforum.org the disclosure of which is incorporated here by reference. From the SAF specifications there are currently two mandatory AMF entity types that need to accompany any application software intended for such systems. These two entity types are the component types CompType and their respective component service types CST . Other entity types may also be provided as inputs however they do not have to be present in an entity types file if the software implementation has no restrictions related to them.

The second exemplary type of input is the services set user input . The services set user input typically includes information related to the services the site provides for which the AMF configuration is being created. In the AMF environment the services set user input is a set of service instances in which each service instance is described by a set of component service instances as well as other desired user inputs e.g. a number of nodes provided with the system providing the service or services and the desired redundancy model to protect them. The services set user input is typically site specific. This exemplary method involves using SI templates each of which describe a set of SIs that shall be protected by SGs of the same type. Within each SI template the CSIs are also defined via CSI templates. The SI templates are typically based on the service types SvcType provided as service set user input or by the entity types files. The service type determines the composing CS types CST and any limits for the number of component service instances that an SI of the service type may contain. Accordingly the CSI templates are based on the CS types provided with the software and the user input needs to indicate which CS types are used from these and how many instances of them are desired for the composition of an SI of the particular SI template. An SI template also defines the number of SIs to be configured based on this template and their grouping to SGs. Additionally the desired redundancy model is typically input by a user and included in the SI template. Another input typically received by the AMF Configuration Generator from the services set user input is the number of nodes. The number of nodes input is used to assign the service units of the configuration to nodes according to different criteria e.g. implement hardware redundancy load balancing among cluster nodes etc. if necessary. This information may be provided as a user input to the AMF Configuration Generator or collected from the target system by other SAF services.

These exemplary input entity types and services set user input are received at the AMF Configuration Generator where the inputs are processed to generate a system model for a specific AMF configuration. A general discussion of the configuration generation will now be provided followed by a detailed but purely exemplary pseudo code implementation. References to the pseudo code implementation are priced in the text below in parentheses.

Initially the exemplary configuration generation method generateConf method begins by matching each received SI template with the entity types provided. A suitable SU type is selected from among those in the received input set findSUType method . This selection method checks the SU types for the capability of providing the desired service type that the SI template refers to. If there are such SU types available then one is selected by matching the capabilities of the component types of the SU type for each of the component service types with the capabilities required for providing the specified component service type by the CSI templates findCompType method in the required redundancy mode required by the enclosing SI template. According to one exemplary embodiment the selection method finds the SU type s that provide the CSI s with the minimum number of components i.e. the selection criterion results in maximizing the utilization of each component in the configuration. However other selection criterion can be used as desired.

For the case where the selection criterion results in no SU types found that provide the desired composition of CSIs this exemplary configuration generator can determine whether the available component types can be grouped in another manner to construct a new desired SU type. This can occur as part of the findSUType and findCompType pseudo code functions described below i.e. the findCompType method adds an appropriate component type from the complete set of component types to the newly constructed SU type for each set of CSIs that needs to be protected. This determination as to whether new SU types may be constructed is typically based upon a user input e.g. a yes or no input regarding whether the AMF Configuration Generator is permitted to perform new SU type construction. If a no is submitted then only the submitted types will be used. If a yes is submitted then the submitted SU types will preferably be used however if the submitted SU types are found to be insufficient the AMF Configuration Generator will have the option to attempt to create an appropriate SU type. Once an SU type is found or constructed this exemplary method chooses an appropriate SG type from the available set of SG types based on the features defined by the user for the desired redundancy model in the SI template. If no such appropriate SG type is available a new SG type is created using input parameters found within the SI template.

Upon completion of finding the appropriate entity types the AMF Configuration Generator generates the entities i.e. instances of these types generateConf method that can provide the desired services createSis method . The configuration is populated so that both the active and the standby assignments of each SI protected by each SG can be satisfied. This is done by creating one SU with the required number of components so that the SU provides the required active and standby capabilities for all of the SIs as necessary and within them for all CSIs. Once all of the components of the first SU have been added other SUs required by the redundancy model are copied from this first SU as desired for the HA environment to create a first SG. This procedure is then repeated for each SG necessary to protect all the service instances generated from an SI template in the configuration that is currently being created. Additionally one exemplary method for creating this configuration uses equal ranking and equal load between all SUs. Alternatively other exemplary methods can be used.

For example according to one exemplary embodiment instead of using equal ranking and load different ranks can be assigned to the different SUs within an SG. A global rank can be assigned as well as a per SI rank. If only the global rank is specified then for SIs this is the rank that would be used. According to another exemplary embodiment other factors can be used in assigning rank such as for example SI load based upon different resource needs e.g. a database application would be storage memory intensive. Also a collaboration of different applications or the opposite could be considered. According to one exemplary embodiment populating this configuration can be complemented by using a method that generates based on the previously generated SI and CSI templates all or a desired portion of the SI and CSIs respective attributes.

The exemplary processing described above with respect to the AMF Configuration Generator will now be summarized as shown in the exemplary flowchart of . Initially each received SI template is matched with the received entity types in step . Matching also occurs in the follow on steps as needed. Processing then continues by finding a component type by selecting the component type within an SU type or among all component types provided it is permitted to construct a new SU type such that the component type provides a highest utilization for a specified redundancy model in step . Calculating required active capabilities for an SU type within an SG with respect to an SI template wherein an SU of the SU type provides a group of SIs from a single template occurs in step . Similarly calculating required standby capabilities for an SU type with respect to an SI template wherein an SU of the SU type protects a group of SIs from a single template occurs in step . The Configuration Generator then searches for a first SU type that can provide SIs based on one of the templates in step . This leads to searching for a first SG type that can provide SIs using a requested. SU type according to a specified redundancy model in step . Once the necessary entity types have been identified the configuration generation proceeds with populating the configuration with the entities of these types. This begins with generating all of the SIs and their respective CSIs to be protected by an SG based upon the templates in step . A first SU is created for the SG and then others are copied to create the complete SG. A next set of SIs and CSIs can then be generated for the next SG. If the SIs belong to the same SI template the SG is just copied until all the SIs required by the template have been assigned to an SG. For the next SI template the process can be repeated starting with the creation of a first SU. The process ends when all the SGs have been created for all SI templates.

The configuration e.g. a file generated by this exemplary process can for example be in an IMM XML format for use by an AMF via IMM. As mentioned above the elements of this configuration can be generated by a type matching process which loops on the SI templates for each SI template the SG type the SU type and the component types are selected. Exemplary pseudocode illustrating this process in more detail is provided below. For the instance generation described above there are additional loops as multiple entities are created for each selected type. The configuration e.g. IMM XML contains both the entity types and all the generated entities. During configuration generation SUs can be assigned to nodes by setting the appropriate attributes. This is an optional attribute so the AMF can use this attribute when it is provided otherwise the AMF distributes the SUs in an implementation specific way. Note also that it may not always be desirable to assign an SU to a node e.g. when the SU is assigned to a node it cannot be instantiated by AMF anywhere else in which case if the node is faulty that SU would be lost with the node. If no node is specified AMF will pick a node from among those available.

Using the above described exemplary embodiments the AMF Configuration Generator generates a configuration which becomes an output of code in for example an IMM XML file . This output of an IMM XML file is preferably provided in an acceptable format for use by an AMF system as described in for example SAF Information Model Management IMM specification SAI AIS IMM A.02.01. This exemplary code is then stored in a Configuration Repository or other desirable computer readable medium or memory storage unit in step for future use by an AMF.

An additional process that occurs at the end of the exemplary generation of an AMF configuration is the method for distribution of the SUs on the cluster nodes. The AMF specification does not currently describe performance characteristics for entities therefore an exemplary method for distribution of SUs can assume that each SU of the configuration produces equal workloads with respect to each other and with or without assignment. It is at this point that the number of nodes to be used needs to be known by the system as either a received user input or by the system knowing what is available e.g. information provided by another SAF service. Based on this assumption this exemplary method distributes the SUs among the nodes of the cluster by selecting for each SU the node that has the smallest load and that has no or the fewest number of SUs of the same SG that the current SU belongs to. These conditions can be provided by using a global round robin distribution of the SUs as the SUs are being created during the configuration process. Alternatively this exemplary distribution method can be modified by assuming based on performance characteristics of the system different capacities for the different nodes and different load for the different SUs. Also another exemplary alternative embodiment for configuration could be based upon the assumption of different failure scenarios desiring to avoid or minimize overload situations when one or more SUs nodes fail in the system.

To further illustrate the above described exemplary embodiments for generating an AMF configuration a purely illustrative exemplary embodiment will now be described with respect to . In this exemplary system the goal is to support file transfer protocol FTP services simple mail transfer protocol SMTP services and hyper text transfer protocol HTTP services in an HA environment by creating a configuration file for use by an AMF to manage these services in an HA environment. For the input entity types there are both component types and component service types. As can be seen in there are two component types labeled CompType A named Surge FTP and CompType B named Apache. CompType A can provide up to three active or six standby assignments for CST A for FTP and CompType A can also provide up to one active or one standby assignments for CST B for SMTP. Regarding CompType B it is capable of providing up to three active and six standby assignments for CST C for HTTP.

These various CSTs can have a number of different attributes associated with them as shown in . For example CST A for FTP is shown with two attributes and associated therewith. Attribute could for example deal with IP ranges and attribute could for example be associated with security levels. More or fewer attributes can be associated with a CST as well as the other CSTs as shown by CST B for SMTP having three attributes and CST C having just one attribute. These attributes associated with the CSTs are typically submitted as part of the input entity types as they are determined by the way the software is implemented.

CSTs are also associated with service types. For example as shown in two service types are shown SvcType A representing the file transfers and email service and SvcType B which represents the web page display service. Accordingly SvcType A is associated with CST. B and CST A representing the FTP and SMTP component service types. SvcType B is solely associated with CST C with HTTP. These service types can be submitted as either entity types inputs or as part of the services set user input . This then leads to the various templates submitted as part of the services set user input .

According to exemplary embodiments the services set user input includes templates. Continuing with the current example SI templates CSI templates and a node template are illustrated in . An SI template includes the following a name e.g. SI temp a a redundancy model e.g. N M a service type e.g. File Transfer and Mail the preferred number of active and standby assignments per SI e.g. 1 Active 1 Standby the values for N and M SUs as appropriate for the redundancy model e.g. 3 1 SUs and the desired number of SIs e.g. 3 SIs. Associated with each SI template are one or more CSI Templates and . CSI template includes a name e.g. CSI temp A a CST e.g. FTP and the number of CSIs in this case one . The other template is a node template which includes a name and the number of nodes in the cluster. They are to be used for the distribution of the generated service units.

At some point after filling in the desired templates these desired templates as well as the entity types are processed by the AMF Configuration Generator . For example as shown in SI template is being processed by the AMF Configuration Generator . Using the received inputs as well as other known information such as specified constraints for an AMF outputs are generated by the AMF Configuration Generator . In this case populated SIs and are generated. Additionally in this example a first SU is created of a new SU type to meet the desired needs associated with the SIs and of the SI template . A new SU type was created if there was no acceptable available SU type and the orphan types allowed for the creation of new SU type as needed. Also the Configuration Generator determined that the best CompType for CST A and CST B is CompType A which allows the SU to only use three components to support each of the SIs and which have three CSIs associated with them. To meet another need as specified by the SI template e.g. the provision of three active SUs and one standby SU four SUs are created and deployed as shown in as part of the new SG .

According to exemplary embodiments illustrative pseudo code used for generating an AMF configuration is shown below. This illustrative pseudo code is broken down into three sections Inputs Outputs and Configuration Generation for ease of understanding. The Inputs section of pseudo code corresponds to the various inputs that may be received by the AMF Configuration Generator . Some of them are mandatory e.g. component type component service type SI templates others may be generated by the configuration generator e.g. SU type . The Outputs are building blocks of the final configuration created from the Inputs by the Configuration Generation. The Outputs together with some of the Inputs presented to an AMF implementation via IMM in an XML file providing this way the complete AMF information model.

The first group of inputs described are from the entity types subset. A component service type is a set as described by

A second type of inputs may belong either to the entity types or to the services set user input subset.

A third type of inputs may belong either to the entity types or to the services set user input subset or completely omitted as an input. In this latter case the configuration generation is creating these types.

A fourth type of inputs is the services set user input which as described according to exemplary embodiments above includes Service Instance templates for the service instances and Component Service Instance templates for their component service instances that need to be protected by Service Groups. Pseudo code for a variety of services set user input is shown below.

The final type of input is the number of nodes. Number of nodes can be an optional separate input or defined elsewhere e.g. read from the system for which the configuration is being generated. The number of nodes can be described using pseudo code as a node template as follows. Each node template characterizes a distinct set of nodes that share characteristics. Currently only one template is used that represents all the nodes of the cluster.

Outputs are a result of processing by the AMF Configuration Generator to be used in the final configuration file. The pseudo code used to describe and generate these Outputs is described below.

The find CompType method selects the component type within the service unit type or among all component types that can provide the highest utilization for the given redundancy model.

validCompTypes is the set of component types that can provide a required component service type cst within the service unit type sut or among all the component types 

The required SU active capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil is used to round up to the nearest integer.

The required SU standby capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil is used to round up to the nearest integer.

This function searches for the first SU type that can provide the SIs of the given template siTemp. Optimization may be added depending on other requirements.

validSuTypes is the set of service unit types that can provide the required service type siTemp.st among all the service unit types 

This function searches for the first SG type that can protect the SIs using the requested service unit type sut according to the requested redundancy model redMod. Optimization may be added depending on other requirements.

Based on the provided SI template this method generates all the service instances and their component service instances that shall be protected by a service group Currently this function does not include the generation of CSI attributes.

This is the main function which after determining the required entity types using the findSUType and findSGType methods populates the configuration with all the instances listed as outputs. It also distributes the generated service units on the nodes.

The exemplary embodiments described above provide methods and systems for generating an output of code for an IMM XML file by an AMF Configuration Generator for use by an AMF via IMM typically in a HA environment. An exemplary node which can act as an AMF Configuration Generator will now be described with respect to . Node can contain a processor or multiple processor cores memory one or more secondary storage devices and an interface unit to facilitate communications between node and the rest of the network i.e. sources of input and receiver of the output. Additionally the node can contain control instructions for automating the generation of the system model based upon received inputs. The memory or the secondary storage can be used for storage of exemplary inputs such as user inputs or known required entity types as defined by current AMF standards. Thus a node according to an exemplary embodiment may include a processor for generating a system model according to the format of an IMM XML schema for future or current use by an AMF.

Utilizing the above described exemplary systems according to exemplary embodiments a method for generating a configuration file is shown in the flowchart of . Initially a node receives inputs associated with at least one service to be managed by the AMF and software used to provide the at least one service in step . The node then processes the inputs to support the at least one service in step . The node then generates a configuration using the processed inputs in step if possible. It will be appreciated that it is possible that no configuration can be generated if for example the required services cannot be provided by the system or software with the desired level of protection redundancy .

It will be appreciated that the foregoing exemplary embodiments are merely illustrative and that numerous variations and permutations thereof are within the scope of this document. For example although the configuration generated by these exemplary embodiments is described as an IMM XML it will be appreciated by those skilled in the art that this is the input format for IMM and not necessarily that which is provided directly to an AMF implementation. An AMF implementation may instead have other non standard input formats. The configuration which is generated by these exemplary embodiments may be presented in such format s .

The foregoing exemplary embodiments describe systems methods devices and software for generating an AMF configuration based on for example user requirements and entity types provided by the vendor. Some of these exemplary embodiments employ a bottom up approach for selecting an SU type and component type as part of the AMF configuration generation process. That is some of these exemplary embodiments search for a suitable SU type and component type set in an entities type file based on the inputs which are provided to the configuration process and then generate compatible higher level type s e.g. an SG type as part of the AMF configuration generation process. However according to another exemplary embodiment described below it may first be useful to look at the constraints if any associated with the higher level types in the input entity types file as part of the search for a suitable SU type and component type in order to avoid generating unnecessary higher level types and or higher level types which are inconsistent with such constraints.

Consider for example the conceptual view of an entity types file illustrated as which has been input to an AMF configuration generation process according to this exemplary embodiment. Therein the entity types file from e.g. a vendor has specified one complete group of types e.g. an app type an SG type an SU type and a component type represented by column each of which may have several instances associated therewith . The remaining types e.g. represented by columns and are incompletely specified in the entity types file . The circled types in these columns are referred to herein as orphaned types because they are not supported by higher level types in the entity types file .

According to this exemplary embodiment searching for a service unit type and a component type to support a service can be performed in an order which involves first evaluating those groups of types which are more fully specified and then evaluating those groups of types which are less fully specified. This enables for example such a search to consider the constraints which may be provided by the vendor for the higher level types and or to avoid creating higher level types when a service may be supported by a service unit type and component type which are already supported by higher level types. In this context such restrictions or constraints may include for example one or more of relations between types limitations capabilities dependencies or other constraints. An example of such a constraint is a redundancy type associated with the SG type. An example of a search process for selecting a service unit type and component type in support of a service according to an exemplary embodiment is illustrated in the flowchart of .

For a given set of service instance template requirements the process first evaluates an application type in an entity types file at step to determine whether that application type has a constraint which conflicts with one of the inputs to the configuration generation process e.g. a user input requirement associated with redundancy. Stated differently step evaluates the existing application type to determine whether it satisfies the requirements associated with this service instance template. Using as an exemplary reference the entity types file shown in the application type in column could for example be evaluated initially at step . If a conflict exists then the flow follows the No path from block to select another application type from the entity types file at step . Alternatively if the first selected application type satisfies the requirements for this service instance template then the flow moves on to step wherein a service group type associated with the first selected application type in column is checked to see if it meets the requirements. If so then the flow moves down to the next lower level at step wherein a service unit type associated with that service group type is checked to see if it satisfies the requirements for this service. If so then that SU type SG type and application type are selected for this service instance template at step . If however a conflict is detected at the service group type level or the service unit type level then another entity type at the same level can be evaluated if one exists in the entity types file by following the No path from the respective decision blocks or and looping back through blocks or .

If the AMF configuration generator according to this exemplary embodiment cannot find a set of SU type SG type and application type among those in the entity types file which satisfy the requirements for this service template then the flow exits the Yes path from block to consider the orphaned service group type s if any in the entity types file. For example if the types associated with the application type in the column did not provide a suitable set of types for the service instance template of interest then the process could move on to column which includes an orphan service group type. This orphan service group type is then evaluated at step to determine if it has a conflict with the requirements e.g. related to redundancy. If not then the flow moves on to step wherein one or more service unit types associated with this service group type are checked to see if they can satisfy the requirements. If a set of SU type and an orphan SG type from the entity types file satisfy the requirements for this service instance template then those entity types are selected and an application type can be created at step to support the SU type and SG type.

If the orphan service group type satisfies the requirements for this service instance template but the first checked service unit type does not then other service unit types associated with this service group type if any exist may be evaluated by looping back to step through step . If none of the service unit types associated with this orphan service group type satisfy the requirements then the flow can follow the Yes path from decision block wherein other orphan service group types can then be evaluated if any exist in this entity types file. Otherwise if this is the last orphan service group type in this entity type file then the flow can follow the Yes path from block to block wherein orphan service unit types are evaluated e.g. the orphan service unit type shown in column of . If this or another via the loop including step orphan service unit type fulfills the requirements associated with the service instance template then that orphan service unit type is selected in step and an SG type and application type are created to support that SU type.

Otherwise if no orphan service unit types satisfy the requirements imposed by the service instance template then the flow follows the Yes branch from step to step . Therein it can be checked to see whether a suitable service unit type can be constructed from orphan component types. If so then a supporting SU type SG type and application type are created at step . If not then the service instance template cannot be satisfied at step and the process terminates. Note that in steps and new types may be created or existing types can be checked to see if they satisfy the SI requirements in which case they can adopt the orphaned type which is being selected.

It should be appreciated that the particular order of search is not critical to these exemplary embodiments and therefore the SU types found in an entity types file may be evaluated in any desired order as part of the AMF configuration process. However according to some exemplary embodiments the AMF configuration generator tool may not be permitted to generate new instances of higher level types e.g. App types and SG types unless the SU type under consideration is an orphan i.e. is not supported by the higher level types in an entities file. Thus using again the exemplary entity types file conceptually illustrated in an AMF configuration tool according to one exemplary embodiment would be permitted to create the types illustrated above the circled orphaned types in but would not be permitted to create e.g. another SG type in column .

This latter possibility is exemplified in wherein an AMF configuration generator or a type finder portion thereof according to this exemplary embodiment first searches for an appropriate SU type among the type groups which have higher level types in the entities file e.g. as represented by rows and and the overlaid arrows therein in the manner discussed above with respect to . The search is as described above based on the calculated parameters returned from calculator portion e.g. in a manner similar to that described above and in the exemplary pseudocode below. Having not found a suitable SU type in these type groups the type finder then evaluates SU type and finds it to be suitable for supporting the service of interest. To support a new SU type the type creator portion of the AMF configuration generator then creates an App type and SG type in column e.g. in the manner described above with respect to the bottom up embodiments. All of these processes are described in more detail below.

Thus an overall method for generating an AMF configuration according to this exemplary embodiment is illustrated in the flow diagram of . Each of these steps will be described in some detail. Therein at step the data to be used in the configuration process is collected. Generally speaking such inputs include two different parts e.g. the entity types describing the software applications and the set of services that the particular system should provide using this software. Regarding the entity types these are typically provided by the software vendor as an XML entity types file. The XML schema for an entity types file is specified by the SAF SMF specification as described above. Accordingly there are two mandatory entity types that the entity types file must contain for the software i.e. the component types and the component service types they provide. Other entity types may also be provided however these types do not have to be present in an entity types file if there are no restrictions or constraints related to them. On the other hand an AMF configuration contains all of the entity types defined by AMF therefore these higher level types are also one of the expected outputs of these exemplary embodiments. The entity types in the entity types file can be classified to find those types that are not referenced by any other type i.e. the orphan types described above. More specifically the orphan component types are not referenced by any service unit type the orphan service unit types are not referenced by any service group type and the orphan service group types are not referenced by any application type. As mentioned earlier according to some exemplary embodiments orphaned types have no limitations on how they are used with respect to other higher level types whereas unorphaned types may be not be permitted to have higher level types created therefor.

The second part of the inputs which are collected at step are the services that the site will provide for which the AMF configuration is being created. As mentioned above the AMF specification defines the services as a set of service instances in which each service instance is described by a set of component service instances. This is site specific information and will be entered into the AMF configuration generation tool according to exemplary embodiments by a user e.g. a site designer. To ease this task this exemplary embodiment provides for service instance SI templates that characterize sets of service instances which are similar and that shall be protected in a similar manner. Therefore each template specifies a set of SIs that are protected by service groups SG of the same type. Within each service instance template the participating component service instances CSI are also defined via templates. These CSIs are based on the component service types provided by the software and indicate how many instances are necessary for the composition of a service instance. An SI template also defines for example to which service type it belongs the desired redundancy model the number of service instances based on this template and their grouping of SIs to service groups. Based on the set of the SI templates the corresponding set of service instances and their component service instances is generated by this exemplary embodiment. This can be complemented according to some exemplary embodiments by a procedure which generates all of the service and component service instances with their exact attribute settings.

The configuration generator e.g. the generateConf method in the pseudocode below loops through the SI templates specified by the user. Returning to for each SI template the entity types that can provide the service instances are selected at step e.g. by finding them among the existing types and or creating new types. The type selection step starts with matching an SI template with the entity types provided as input. According to this exemplary embodiment first the service group types of the existing application types are checked e.g. to determine if the redundancy model of the service group type matches the one required by the SI template. If it does then the service unit types of this service group type are checked e.g. using the findSut method in the pseudocode below to determine if they can a provide the required service type and b support the load of SIs expected to be assigned to them. If both of these conditions are met then according to this exemplary embodiment the service unit type the service group type and the parent application are chosen for the service instances of the SI template.

On the other hand if none of service group types of any application type can provide the service then the orphan service group types are checked in the same way as described above. However since these service group types are not referenced by any application type when a suitable service unit type is found an application type needs to be created. To perform application type creation the already created application types are checked to determine whether any of them has the service group type as a member or can be extended with that service group type e.g. using the findAppt method in the pseudocode below . If not a new application type is created e.g. using the createAppType method in the pseudocode below and added to the set of created application types createdAPPTs . If none of the orphan service group types can provide the service then the orphan service unit types are checked in a similar way. Again when a service unit type is found a service group type is either created e.g. using the createSgType method in the pseudocode below or found e.g. using the findSgt method in the pseudocode below to search the set of createdSGTs among the already existing created service group types to adopt the orphan service unit type. If a new service group type needs be created it is added to the set of created service group types createdSGTs then the appropriate application type also needs to be found or created. If none of the orphan service unit types can provide the service then a service unit type is created e.g. using the createSuType in the pseudocode below and then adopted by a found created service group type that in turn will be adopted by a found created application type.

Once all of the appropriate entity types have been found for an SI template this exemplary embodiment then generates the entities of these types e.g. within the generateConf in the pseudocode below that would provide the service instances needed to support the requested services at step . That is the AMF configuration is populated so it can provide for both the active and the standby assignments of each service instance protected by each service group. This can be accomplished by creating one service unit with the required number of components so that it provides the required active and standby capabilities for all the component service instances. Once all of the components of the first SU have been added other SUs required by the redundancy model are copied from this first SU. If more than one service group is required for the SI template the first service group is copied until all service instances can be served. This exemplary embodiment assumes equal ranking for all of the service units within each service group. However the present invention is not so limited and for example a ranking procedure can be added to dictate an ordered handling of service units within the service groups. Additionally the entity types may be refined or optimized by tailoring the parameters of the type instances to their use based on the created entity instances.

Since the AMF specification does not currently cover performance characteristics for entities this exemplary embodiment assumes that each service unit of the configuration produces equal load and that each cluster node provides the same capacity although it will be appreciated by those skilled in the art that the present invention is not so limited. As a result this exemplary embodiment distributes the SUs among the nodes at step in of the cluster by selecting for each SU the node that has the smallest load in terms of number of service units assigned and that has no SU or a smallest number of associated with the same SG that the current SU belongs to. These conditions can be implemented by for example performing a global round robin distribution of the SUs as they are being created. Moreover this exemplary distribution method can be further optimized or enhanced e.g. based on performance characteristics of the system by assuming different capacities for the different nodes and different load for the different service units and or service instances and or based on the assumption of different failure scenarios to avoid overload situations when one or more SUs nodes fail in the system. These additional conditions will result in a non round robin distribution of the SUs on the nodes. The process associated with steps and continues until all of the SI templates are processed and the configuration is populated with entities to provide their service instances in the SAF system.

As a result of applying the method illustrated in and described above to the inputs an AMF configuration is generated by this exemplary embodiment that specifies all of the instances for all of the entity types and their entities. The result can then be stored or saved e.g. in a memory device or recordable medium in any desired format as indicated by step . For example this output can be presented and or stored in accordance with the AIS specifications as an XML file created according to the IMM schema which contains the description of the instances as specified in the UML model of AMF. In this way an SAF compliant AMF implementation can be provided with the information model of all of the entities which it needs to manage as an input. Due to the potential complexity of AMF managed systems this provides an automated approach to a complex and error prone task.

The following pseudo code describes at a high level an exemplary implementation of the afore described exemplary embodiment. Other implementations are also possible.

The required SU active capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil is used to round up to the nearest integer.

The required SU standby capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil is used to round up to the nearest integer.

This function creates a service group type that supports a given service unit type and sets the redundancy model of this service group to same one of the SI template

This function searches for the first created application type that can support the given SG type. This function is NOT used for finding application types that are not created Modifications to this function are possible based of preferences regarding the extensibility of created application types

This function searches for the first created SG type that can support the given SU type. This function is NOT used for finding SG types that are not created.

This function searches for the first SU type that can support the SIs of the given template siTemp. Optimization may be added depending on other requirements.

This function searches for the first component type that can support the CSIs of the given template csiTemp. Optimization may be added depending on other requirements.

This function searches for the first component type in orphanCTS that can support the CSIs of the given template csiTemp. Optimization may be added depending on other requirements.

This function calculates the number of components of a given component type that need to be created inside a particular service unit

This function will assign the given service unit to a node that have the smallest number of service units assigned to it.

This is the main function that is responsible for creating all the entities in AMF configuration and populate their attributes.

Note that although the foregoing exemplary pseudo code performs evaluations between SI requirements and type capabilities in a strict sense i.e. checking to see if each value in type s capabilities tuple or set is equal to a corresponding value in the SI requirements tuple or set to determine if a type supports those requirements other evaluation metrics can be used to determine the suitability of a type. For example for created application types an AMF configuration generator according to exemplary embodiments may decide that it is sufficient that the required set of SG Type is present as a subset. This allows for the extension of existing created types. As a result the configuration will have different numbers of application types and therefore different number of applications which reflects different strategies of grouping e.g. grouping by functionality. Strict equivalence results in a 1 1 relation between created SU types created SG types and created application types. Allowing subsets without other strategies results in a single APPT as it was done in the bottom up approach.

The foregoing description of exemplary embodiments of the present invention provides illustration and description but it is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The following claims and their equivalents define the scope of the invention.

