---

title: Metadata driven API development
abstract: The described method and system synchronizes source code with byproducts or artifacts of an application creation process. In one embodiment, a generation tool may be used to produce source code header files based on a design specification, where the source code header files are compiled with a current version of source code. Compilation errors may direct a developer to modify either the specification or the source code to eliminate the errors. The described method and system may be integrated into a development platform that is adapted to direct the user to perform particular revisions or updates to bring the source code in line with the artifacts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117589&OS=08117589&RS=08117589
owner: Microsoft Corporation
number: 08117589
owner_city: Redmond
owner_country: US
publication_date: 20080626
---
During a software application development process a plurality of artifacts may be produced when an application developer is building an application program interface API . These artifacts may include a design document outlining a plan for building the API documentation on the functionality of the API header files definition files error messages tracing information security notes example source code etc. Because a design for the program source code usually changes during the course of the build process these artifacts may become unsynchronized during the build out of the source code. However it may be important to keep the artifacts synchronized with source code to prevent a misdirected build out based on outdated or conflicting artifacts. This synchronization may be complicated by a number of factors. Generally artifacts may be produced at different times during the design and build process and keeping the artifacts consistent with each other may become increasingly difficult the more artifacts produced and the more complicated the API is designed.

The described method and system synchronizes source code with byproducts or artifacts of an application creation process. The artifacts may include a design document header files definition files error messages tracing information security notes etc. The described method and system may be integrated into a development platform that is adapted to direct the user to perform particular revisions or updates to bring the source code in line with the artifacts.

Although the following text sets forth a detailed description of numerous different embodiments it should be understood that the legal scope of the description is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment since describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments could be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

It should also be understood that unless a term is expressly defined in this patent using the sentence As used herein the term is hereby defined to mean . . . or a similar sentence there is no intent to limit the meaning of that term either expressly or by implication beyond its plain or ordinary meaning and such term should not be interpreted to be limited in scope based on any statement made in any section of this patent other than the language of the claims . To the extent that any term recited in the claims at the end of this patent is referred to in this patent in a manner consistent with a single meaning that is done for sake of clarity only so as to not confuse the reader and it is not intended that such claim term be limited by implication or otherwise to that single meaning. Finally unless a claim element is defined by reciting the word means and a function without the recital of any structure it is not intended that the scope of any claim element be interpreted based on the application of 35 U.S.C. 112 sixth paragraph.

With reference to an exemplary system for implementing the blocks of the claimed method and apparatus includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer via a local area network LAN and or a wide area network WAN via a modem or other network interface .

Computer typically includes a variety of computer readable media that may be any available media that may be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . The ROM may include a basic input output system BIOS . RAM typically contains data and or program modules that include operating system application programs other program modules and program data . The computer may also include other removable non removable volatile nonvolatile computer storage media such as a hard disk drive a magnetic disk drive that reads from or writes to a magnetic disk and an optical disk drive that reads from or writes to a optical disk . The hard disk drive and may interface with system bus via interfaces .

A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not illustrated may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device may also be connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

Generally a design document embodying the design specification may be continually modified to reflect different e.g. improved ways of providing the functionality defined by the goals of the software application. For example after an iteration of the design document the design document may be reviewed to determine whether a current design meets the intended goals of the API or set of APIs . Alternatively the design document may be reviewed based on changes to software goals. If the design document does not meet the design goals at block the design document may be revised with new functional descriptions at block . Developers may agree at some point that the design document is adequate enough to initiate source code implementation or in other words the developers may agree that a source code writing process may begin based on the design reflected by the specification. In computer science source code commonly just source or code is any sequence of statements or declarations written in some human readable computer programming language. The source code which constitutes a program may be held in one or more text files.

Generally source code is written in parts based on the design document. As each part is written errors in the design may be discovered at block prompting revisions in the code . These design changes however are rarely reflected back in the design document or specification. In other words fixes changes modifications may be made to source code without a corresponding update of the design document. It should be noted that these errors in the source code may be detected during writing of the code before any compilation is executed. For example methods may be written only to realize that the operations are not useful or may be best incorporated in a manner different than what is outlined in the design document.

After the source code is written a build phase may commence in which the source code is compiled . Compilation is the translation usually using a compiler program of source code into another computer language a target language . The original sequence is usually called the source code and the output called object code. Compilation and build may be used interchangeably. Errors may be detected during compilation which may prompt revisions to the source code . The compilation of a portion of code may be independent of other parts of the application e.g. other APIs . Revisions to the source code during a compilation stage may prompt alteration in the operation of some of the functions described in the original specification document. For example while existing design goals of the specification are met by a current version of source code different structures or functions may be implemented from those in the design document causing a disconnect between the source code and specification.

Eventually a satisfactory build and design may be created and delivered at block . A problem with this existing application creation process is that because each process block is iterative and each process block may rely or depend on the results of previous process blocks e.g. artifacts unsynchronized artifacts of the build process may magnify even small coding errors or deviations. For example given that a portion of an API does not compile a developer may look to correct the source code in a number of places. The developer may rely on other portions of written source code or artifacts such as the specification. If the specification is not synchronized the developer may write bad code in one portion of code that negatively impacts other portions of code e.g. causing other code to produce errors . For example if the developer relies on a second portion of source code based on one version of the specification to write a first portion of source code and the second portion is not synchronized then the first portion may be written incorrectly thereby causing debugging to be complicated.

Maintaining the correspondence between source code and artifacts may not be an easy task. Because of the large number of artifacts that may be produced and the ever increasing complexity of the APIs synchronizing source code with artifacts may be arduous and time consuming. Moreover developers working against a tight deadline may not be motivated to update artifacts that are not immediately pertinent to their area of the source code e.g. a current portion of the source code which a developer is writing . In these situations once a non source code artifact e.g. the design document is created updates are rarely performed to that artifact.

To further complicate synchronization of artifacts certain artifacts such as header files error handling methods tracing methods etc. may be created at different times during a build out process. It may be easy to leave some artifacts unaccounted for during synchronization. Unfortunately since the artifacts may generally rely on or be dependent on one or more other artifacts one out of synch artifact can lead to a very complicated debugging process. In other words reliance on one or more inconsistent artifacts during the application building or creation process may promote errors in the write and build process that may waste developer time.

It should be noted that this general listing of artifacts is not exhaustive. Other artifacts known to those skilled in the art may also be produced by the generation tool based on a specification that contains the grammar to describe the other artifacts. Moreover some or all of the artifacts may be produced for a particular iteration based on various conditions or parameters. For example the set of artifacts may be selected for generation by a user of the generation tool.

The generated source code headers and other source code artifacts may be inputted into a general compiler after they are produced at block . In computer programming particularly in the C and C programming languages a header file or include file is a file usually in the form of source code that is automatically included in another source file by the compiler. After the compiler is executed on the source code compiler errors may be detected at block . If there are no compile errors then the source code and specification may be synched and the compiled source code may be saved . If there are compile errors detected at this may indicate that the source code and specification may not be synchronized. This indication may be displayed to a user at block .

The described process may ensure that source code and documentation are synchronized by requiring that header files be generated based on the specification and that these header files be used in the compilation and build of the source code. Any inconsistencies between the specification and source code may result in an error of the compiler that may specifically point to the header file and or function implementation that is causing the error. The compiler error and or indication may prompt or direct the user to fix the specification to bring the specification in line with the code. This direction of fixing the specification may be a general process where the source code is assumed to represent a more current or correct version of the application design. In alternative embodiments the source code may be modified or aligned to the specification at block .

The newly generated header files and existing source code may then be compiled . If no errors are detected from the compilation at block the source code may be successfully built and compiled . Assuming that a previous version of the source code was compilable any errors detected at block from the build using the newly generated headers may indicate a unsynchronized specification . This indication may prompt the developer to modify the specification at block . New headers may be generated for a second iteration of the process. In an alternative embodiment the compilation errors may be eliminated by modifying the source code instead of the specification to synchronize the code with the specification. The particular fix may be based on a particular programming situation. For example when the design is considered primary to the source code the latter embodiment may be used. In situations in which the source code is primary e.g. the source represents an improved design and better functionality the former embodiment may be applied.

In one embodiment the generation tool may be adapted to synchronize all other artifacts based on the header files. In other words the header files may be the base artifact which is used to detect determine synchronization with current source code and all other artifacts may be written based on the header files. In other embodiments a different artifact may be used as a base for artifact synchronization.

In alternative embodiments a development platform may integrate one or more of the above described processes to direct a development process. illustrates that a development platform may be adapted to lock the source code against modification during a testing process thereby ensuring synchronization in a particular direction e.g. towards modifying the specification . In particular source code may be locked against developer modification at block . This source code may represent the most recent version of the source code that was successfully compiled or that is compilable. A current version of the specification may be retrieved at block and the generation tool may be executed on the specification to produce a set of header files based on the inputted specification . In this embodiment the generation tool may be implemented as part of the development platform that may replace existing headers of source code with the newly generated headers based on the current specification . The development platform may unlock the code as necessary to perform this replacement not illustrated . After replacing the header files the source code including the new header files may be run through a compiler . If no errors are detected at block an indication of a successful build may be displayed . This may indicate that the source code is currently synchronized with the specification and the source code may then be unlocked . If errors are detected at this may indicate that that specification is not synched with the source code . Because the source code is locked by the development platform the developer may be directed to modify or update the specification and repeat the process at block until the compilation process is successful. There may be times in which the source code is more desirable than the version of the design described by the specification. The development platform may provide an override for removing the source code lock for these situations.

A function signature for the function WsCreateChannel is described by a name of the function a function result type a function group e.g. a set of APIs function parameters . A function prototype or signature is a declaration of a function that omits the function body but does specify the function s name arity argument types and return type s . In one embodiment the grammar may include an end user friendly name and or description of the parameter in addition to a parameter type . The end user description may be considered a translation of the parameter. The grammar may also include parameters providing a description of different parts of the function. For example the grammar may include parameters designating the type of a parameter as input type or result out type see . The grammar may include a summary of the nature and general operation of the function . The grammar may also include remarks on the function . In some embodiments the grammar may require a specific sequence for the set of parameters or designations.

Appendix A illustrates an HTML file showing documentation for the function WsCreateChannel which may be automatically generated from the specification of using a particular document format. The HTML file may be formatted to be easy to read by an end user. For example all the parameter values in the specification may be used to construct an easily recognizable function signature as illustrated in Appendix A. The format may be tailored based on user preference. The format may be based on the grammar of the specification. For example the grammar may provide indicators describing how the HTML file is constructed and formatted.

The HTML documentation may be include a plurality of pages that are linked by hyperlinks and the documentation may include linked descriptions of the functions and its characteristics. For example the documentation may be organized so that there is a page per function type etc. with hyperlinks between the types of fields parameters etc. An embodiment of a html documentation that may be generated by the generation tool. In one embodiment the generation tool may also generate summary pages that may list all the functions and list functions by group . The listed functions may reference independent HTML pages.

In one embodiment an error reporting implementation may be automatically provided by the generation tool for each function. For example the generation tool may automatically generate the error reporting implementation as source code for each function. illustrates a portion of specification that describes error handling for the function WsCreateChannel. Automatic generation of error handling source code may save a programmer time in having to implement the code. In particular the grammar allows a developer to designate a set of error messages for a particular function where the generation tool will generate a wrapper to include error reporting functions that identify and display the error messages.

In one embodiment a single wrapper may be used to implement both the tracing code and error handling code. In some embodiments different wrappers may be used where the wrappers may reference each other and may be sequenced in a particular manner depending on the type of tracing and error handling. In one embodiment only certain error handling and tracing may be used in combination and in a particular sequence. This may help to simplify the build of the generation tool.

Among the artifacts that the generation tool may produce is a source code file or a portion of a source code file used to provide or allocate typed values for dynamically replacing parameters with a typed set e.g. strings from the resources section of the DLL. In particular a class is generated with a method that retrieves a resource string. Appendix B illustrates an example error string file that is reference by a class to retrieve strings for error functions. The class may be implemented as a private method. The methods of the class may correspond to resource string names. Each method may return typed parameter values which correspond to the replacement parameters. Calling the method may load the string and replace the supplied parameters in placeholders with values from the resources.

This may be used for example with the error message designations when the error messages depend on parameter values external to the message handling routine or function for which the error handling routine is being implemented for.

As discussed above the function signatures of the actual function implementation in the source code may be automatically replaced by the generation tool when it operates on the specification. In embodiments where the developer has not written any defining code for a function i.e. the function has not been implemented the specification grammar may allow an implemented parameter to designate that the function has not been implemented as illustrated in . When the function has been written e.g. when the developer has written source code into the body of a function then an implemented parameter may have a value indicating this. This parameter may be checked in some embodiments to determine whether the function signature may be automatically replaced during an execution of the generation tool. For example in one embodiment when the developer has implemented a function and the implemented parameter is true then the generation tool may not replace the header. This may be used to prevent the possibility of erasing or deleting an implementation of the function. This may be the case in embodiments in which the generation tool is programmed to replace an entire function with a function shell e.g. consisting of just a function signature and an empty function body Alternatively as discussed above the generation tool may be programmed to only replace the function signature without altering or deleting the function body in which case the implemented parameter may not be needed.

Due to the fact that many of the files are generated during the build out process the following constraints may be enforced by the described system. The source code which may be used to generate the header and source files e.g. in C language may need to be in synch or a compile error may result. This means that an implicit contract synchronization between the public API source code and documentation may need to be enforced or the code may not compile or build. If a new replacement parameter is added for a particular resource string or a resource string has been accidentally deleted even though some source code still references the resource string then a compile time error may result.

