---

title: Data storage structure
abstract: Efficient data storage and retrieval (e.g., in terms of time and space requirements) is facilitated by implementing an indexing structure comprising an indexing array. That is, a functional relationship between elements of a source set and elements of a query result set can be stored in the indexing structure. This allows, for example, a query regarding whether an element is a member of a set (e.g., whether a particular website or Uniform Resource Locator (URL)) has been visited before) as well as a relationship between the member set and the query (e.g., the number of hyperlinks in the website the last time it was visited) to be resolved efficiently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08028000&OS=08028000&RS=08028000
owner: Microsoft Corporation
number: 08028000
owner_city: Redmond
owner_country: US
publication_date: 20080228
---
In computing environments data storage and retrieval take many forms and utilize varied methods. Utility space efficiency and speed are common goals for those creating and using data structures. Data storage can involve vast computer warehouses storing large volumes of varied information banks storing account information or business databases collecting information related to operating their business. While these types of systems are common there are many situations that require quick responses to specific questions using a small amount of storage resources.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description.

In a computing environment when one wants to find out whether a particular item is a member of a set a Bloom Filter can be used to store and retrieve this information. For example an online library could use a Bloom filter to determine whether a requested book is in the set of books that happen to be carried by the library and made available to the public. However if one wants to determine not only membership within a set but also another characteristic about an item a Bloom Filter is insufficient so traditional database systems are used. For example if one wanted to determine whether a particular person was a registered voter in the State of Ohio a Bloom Filter could handle this information. However if they also wanted to know in what zip code the voter resided a traditional database system would typically be needed.

As provided herein an indexed storage structure or indexing structure is designed to quickly and efficiently retrieve queried information. Furthermore this indexing structure is designed to be created more quickly and in a more compact manner than its predecessors needing a bit array merely twice the size of the number of elements in the membership set. For example this indexing structure could quickly and efficiently store the residential zip code information for all registered voters in Ohio and when queried return whether an individual was a registered voter and in which zip code they reside.

Two hash functions are implemented to map variables to an indexing array to create the indexing structure. The variables are created by an algorithm that utilizes linear algebra to back solve for unknown variables from those that are known such as the zip code information which is known at creation of the indexing structure. Furthermore an acyclic graphical representation of the indexing array is presumed by choosing an array size larger than twice the number of elements in the membership set. This acyclic graph gives us another variable in the algorithm as the primary variable can be set to zero at the initiation of the algorithm for respective sets of vertices in an acyclic graphical tree. Additionally a parity hash function is used in the algorithm to allow us to later determine the elements membership.

Once the array is populated querying the array is accomplished by again using the two hash functions. The variables stored in the array at the positions identified by the hash functions are entered into the query algorithm which is the same one used at creation of the indexing structure and then combined with the parity hash function. The output will be the answer to the query which will also indicate whether the item is a member of the set or an indication that the item is not a member of the set.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

In a computing environment to determine whether a particular item is a member of a set one can among other things create a traditional database and perform a string match search against the database or create and query a Bloom Filter. If one wanted to determine whether a particular item was a member of a certain set of elements they could perform a string search comparing the queried item against respective elements stored in the database or they could create a Bloom Filter and query to get a yes or no concerning membership. Each of these has its limitations however. For example the database string search takes a very long time compared with the Bloom Filter and the database itself takes up a lot of memory resources compared with the Bloom Filter. However the Bloom Filter has the possibility of returning false positives . That is it may return a yes to a query e.g. yes the queried item is an element of this set when in fact the answer should have been no. Further querying for membership is the only query one can perform against a Bloom Filter. Also once created the elements of a Bloom Filter cannot be changed or deleted without recreating the entire Bloom Filter.

Often in computing a database search will not only involve a membership query but some other relationship between the member set and the query as well. As one example a system that manages URL data generated by a web crawler may need to be able to determine whether URLs gathered by the crawler have been previously visited. Further one factor in deciding whether the crawler needs to revisit a particular URL may be a change in the number of links to other URLs found in a particular URL or any one of many other particular features of a URL . Therefore the URL management system needs to know how many links are currently listed for that particular URL in the database to compare with the newly generated data. Not only does the system have to perform a membership query for each URL but also query the relationship how many URL links are in this URL. The system will have to determine membership and retrieve the number of linked URLs by checking against the historical database. A system that manages URL data generated by a web crawler may contain millions or even billions of retrieved URLs. Storing the URLs and checking against the stored data using a string search lookup could be very resource intensive and time consuming increasing with each added URL and each particular feature queried. While Bloom Filters have very compact storage capabilities and the lookup time is constant regardless of the size they can only be used to query membership e.g. whether the URL has been previously visited not a second function e.g. the number of links in the URL or some other feature .

One technique for storing a function relationship between a source set and a query is creating a particular indexing structure a generalization of a Bloom Filter often referred to as a Bloomier Filter. This technique is devised to encode a function into a data structure. This encoded data structure allows one to resolve a query against the data structure to determine membership in a set along with a relationship between the source set and the queried item. Therefore as illustrated in a data structure can be devised to store the function S R that supports queries to the function value resulting in either an output r R the result of the query which also means the queried item x S or a symbol representing that the queried item x S .

Similarly in the example illustrated in data structure may store the function the index of the 12through the 19prime numbers such that a number queried to the data structure would return an output of either the index value if the queried number was one of the 12through the 19prime numbers or if the queried number was not one of the 12through the 19prime numbers .

In one example in order to populate the indexing array with appropriate variables the g positions are mapped in an acyclic manner such that as illustrated in in an exemplary graphical representation of the mapping positions g none of the edges of an individual graph tree form a closed loop. In contrast illustrates an exemplary graphical representation of a cyclic graph. Here the edges form a closed loop in the individual graph tree . Acyclic mapping is further illustrated in showing an exemplary method of mapping positions in an indexing array . Each set of 2 hash functions for each element of the source set maps to 2 positions in the indexing array . Following the mapping paths from a g position in the indexing array to the hash function then back to g position in the indexing array for the paired hash function then to the connected pair of hash functions for that g position in the indexing array e.g. connected by sharing a common g position the path will ultimately end with no more connections for each set of connected hash functions if the array map is acyclic. In contrast illustrates an exemplary method of cyclic mapping positions in an indexing array . In the exemplary method following the mapping paths from a g position in the indexing array to the hash function then back to g position in the indexing array for the paired hash function then to the connected pair of hash functions for that g position in the indexing array e.g. connected by sharing a common g position the path continues in a loop for each set of connected hash functions if the array map is cyclic.

In another aspect during the creation of the data structure the algorithm for generating the variables which populate the indexing array uses the equation x g h x g h x h x mod m to solve for the variables g h x and g h x . The variable x is known before creating the data structure as shown in the exemplary data structure of . The exemplary data structure illustrates that x r r is the query result which is known before creating the data structure. The variable h x is generated by the parity hash function in the process of exemplary method of . Therefore the remaining variables g h x and g h x are unknown and can be solved for during process of exemplary method of for example. illustrates an exemplary table which displays the two known variables h x and the query result x r for each element of the source set . The exemplary table also shows the mapped positions in the indexing array for each element of the source set .

Therefore 12 0 8 mod 30 4. In exemplary method of the value 4 is placed in position g of the indexing array . Exemplary method continues to generate variables the value of variable g h x is known to be 4 as the position g of the indexing array also corresponds to the position to which h mapped element x. Therefore the unknown variable g h x can be solved as follows mod 13 4 20 mod In exemplary method the value 11 is placed in position g of the indexing array . The exemplary method is continued for respective mapped positions in the indexing array for respective sets of positions connected by hash functions graph trees until all of the variables are generated and populated into the respective positions of the indexing array . illustrates an exemplary table showing the values stored at respective positions of the indexing array after the variables have been determined by the equations generated by the data structure creation algorithm. Notably exemplary table displays 0 values corresponding to positions and . These positions were not mapped by hash functions during the mapping process of exemplary data structure creation method in and as such the data structure creation algorithm populates these positions with a 0 value.

In another aspect once a data structure is created that stores a function e.g. relationship between a source set and a query result set in order to be useful the data structure allows queries to be resolved against it such that the output of the query informs the reader of the queried item s membership status along with the result of the function applied to the queried item. In an example of a web crawler URL manager if the queried item to the data structure is a URL that has been retrieved by the crawler the output of the query should inform the reader whether or not the queried URL is a member of the set of URLs previously visited by the web crawler and if it is a member how many URL links were previously found in the queried URL. The web crawler system can then use this information to help determine whether it needs to visit this URL for the first time e.g. not a member of the previously visited URLs or revisit this URL e.g. based on whether additional links have been added since the last visit to the URL .

In contrast in the exemplary method a query input 20 is processed by the hash functions hand h which map to g positions g and g of the indexing array . The exemplary method next retrieves the corresponding values g h 0 and g h 17 stored in positions g and g of the indexing array . The values are used to process the exemplary query equation g h g h h mod m. The exemplary query method retrieves the remaining variables for the equation h and m 30. The query function produces the following result 0 17 22 mod 30 39 mod 30 9. The exemplary query process then checks the value generated by the query equation 9 against the cardinal set of values for valid query results e.g. is 9 a member of the query set R of exemplary data structure in . 9 is not a member of the cardinal set therefore the exemplary method outputs which tells the reader that the inputted value 20 is not a prime number that we have information about.

In yet another aspect once a data structure is created that stores a function e.g. relationship between a source set and a query result set the data structure may allow the stored function to be updated for one or more of the elements of the source set. For example if an element of the source set no longer corresponds with the result outputted by the function stored in the data structure but instead corresponds to a new value the current function stored for that element can be updated to make the result outputted by the function equivalent to the new value. In an example of a web crawler URL manager if the web crawler retrieves a URL that is determined to be one previously visited by the crawler but the retrieved URL has more links than previously listed in the data structure the new number of links can be stored in the data structure. Therefore the value outputted by the query for this URL will have to reflect the new number of links instead of what was previously outputted by this URL query. For this to take place the function stored by the data structure will have to be updated for this particular URL as an element of the set of URLs previously visited by the web crawler.

Another embodiment which may include one or more of the variations described above involves a computer readable medium comprising processor executable instructions configured to apply one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method of creating a data structure such as the exemplary method of . In another such embodiment the processor executable instructions may be configured to perform a method for resolving a query against a data structure such as the exemplary system of . In another such embodiment the processor executable instructions may be configured to perform a method for updating a function stored in a data structure such as the exemplary system of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are merely disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

