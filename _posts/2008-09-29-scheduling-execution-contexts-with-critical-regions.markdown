---

title: Scheduling execution contexts with critical regions
abstract: A scheduler in a process of a computer system detects an execution context that blocked from outside of the scheduler while in a critical region. The scheduler ensures that the execution context resumes execution on the processing resource of the scheduler on which the execution context blocked when the execution context becomes unblocked. The scheduler also prevents another execution context from entering a critical region on the processing resource prior to the blocked execution context becoming unblocked and exiting the critical region.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09304831&OS=09304831&RS=09304831
owner: Microsoft Technology Licensing, LLC
number: 09304831
owner_city: Redmond
owner_country: US
publication_date: 20080929
---
Processes executed in a computer system may include execution context schedulers that schedule tasks of processes for execution in the computer system. A scheduler may create execution contexts e.g. threads fibers or child processes in order to execute tasks. During execution the scheduler maintains control over these execution contexts and maintains control of the processing resources allocated to the scheduler.

At times an execution context may be blocked by an entity other than the scheduler while executing on a processing resource of the scheduler. If the scheduler is not notified of the block the processing resource that was executing the block execution context may become idle. In addition the scheduler may undesirably attempt to schedule the execution context on a different processing resource when the execution context becomes unblocked.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A scheduler in a process of a computer system detects an execution context that blocked from outside of the scheduler while in a critical region. The scheduler ensures that the execution context resumes execution on the processing resource of the scheduler on which the execution context blocked when the execution context becomes unblocked. The scheduler also prevents another execution context from entering a critical region on the processing resource prior to the blocked execution context becoming unblocked and exiting the critical region.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard directional terminology such as top bottom front back leading trailing etc. is used with reference to the orientation of the Figure s being described. Because components of embodiments can be positioned in a number of different orientations the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

Runtime environment represents a runtime mode of operation in a computer system such as a computer system shown in and described in additional detail below where the computer system is executing instructions. The computer system generates runtime environment from a runtime platform such as a runtime platform shown in and described in additional detail below.

Runtime environment includes an least one invoked process a resource management layer and a set of hardware threads M where M is an integer that is greater than or equal to one and denotes the Mth hardware thread M . Runtime environment allows tasks from process to be executed along with tasks from any other processes that co exist with process not shown using an operating system OS such as an OS shown in and described in additional detail below resource management layer and hardware threads M . Runtime environment operates in conjunction with the OS and or resource management layer to allow process to obtain processor and other resources of the computer system e.g. hardware threads M .

Runtime environment includes a scheduler function that generates scheduler . In one embodiment the scheduler function is implemented as a scheduler application programming interface API . In other embodiments the scheduler function may be implemented using other suitable programming constructs. When invoked the scheduler function creates scheduler in process where scheduler operates to schedule tasks of process for execution by one or more hardware threads M . Runtime environment may exploit fine grained concurrency that application or library developers express in their programs e.g. process using accompanying tools that are aware of the facilities that the scheduler function provides.

Process includes an allocation of processing and other resources that hosts one or more execution contexts viz. threads . Process obtains access to the processing and other resources in the computer system e.g. hardware threads M from the OS and or resource management layer . Process causes tasks to be executed using the processing and other resources.

Process generates work in tasks of variable length where each task is associated with an execution context in scheduler . Each task includes a sequence of instructions that perform a unit of work when executed by the computer system. Each execution context forms a thread that executes associated tasks on allocated processing resources. Each execution context includes program state and machine state information. Execution contexts may terminate when there are no more tasks left to execute. For each task runtime environment and or process either assign the task to scheduler to be scheduled for execution or otherwise cause the task to be executed without using scheduler .

Process may be configured to operate in a computer system based on any suitable execution model such as a stack model or an interpreter model and may represent any suitable type of code such as an application a library function or an operating system service. Process has a program state and machine state associated with a set of allocated resources that include a defined memory address space. Process executes autonomously or substantially autonomously from any co existing processes in runtime environment . Accordingly process does not adversely alter the program state of co existing processes or the machine state of any resources allocated to co existing processes. Similarly co existing processes do not adversely alter the program state of process or the machine state of any resources allocated to process .

Resource management layer allocates processing resources to process by assigning one or more hardware threads to process . Resource management layer exists separately from the OS in the embodiment of . In other embodiments resource management layer or some or all of the functions thereof may be included in the OS.

Hardware threads reside in execution cores of a set or one or more processor packages e.g. processor packages shown in and described in additional detail below of the computer system. Each hardware thread is configured to execute instructions independently or substantially independently from the other execution cores and includes a machine state. Hardware threads may be included in a single processor package or may be distributed across multiple processor packages. Each execution core in a processor package may include one or more hardware threads .

Process implicitly or explicitly causes scheduler to be created via the scheduler function provided by runtime environment . Scheduler instance may be implicitly created when process uses APIs available in the computer system or programming language features. In response to the API or programming language features runtime environment creates scheduler with a default policy. To explicitly create a scheduler process may invoke the scheduler function provided by runtime environment and specify one or more policies for scheduler .

Scheduler interacts with resource management layer to negotiate processing and other resources of the computer system in a manner that is transparent to process . Resource management layer allocates hardware threads to scheduler based on supply and demand and any policies of scheduler .

In the embodiment shown in scheduler manages the processing resources by creating virtual processors that form an abstraction of underlying hardware threads . Scheduler includes a set of virtual processors N where N is an integer greater than or equal to one and denotes the Nth virtual processor N . Scheduler multiplexes virtual processors onto hardware threads by mapping each virtual processor to a hardware thread . Scheduler may map more than one virtual processor onto a particular hardware thread but maps only one hardware thread to each virtual processor . In other embodiments scheduler manages processing resources in other suitable ways to cause instructions of process to be executed by hardware threads .

The set of execution contexts in scheduler includes a set of execution contexts N with respective associated tasks N that are being executed by respective virtual processors N and at any point during the execution of process a set of zero or more execution contexts . Each execution context and includes state information that indicates whether an execution context or is executing runnable e.g. in response to becoming unblocked or added to scheduler or blocked. Execution contexts that are executing have been attached to a virtual processor and are currently executing. Execution contexts that are runnable include an associated task and are ready to be executed by an available virtual processor . Execution contexts that are blocked also include an associated task and are waiting for data a message or an event that is being generated by another execution context or will be generated by another execution context .

Each execution context executing on a virtual processor may generate in the course of its execution additional tasks which are organized in any suitable way e.g. added to work queues not shown in . Work may be created by using either application programming interfaces APIs provided by runtime environment or programming language features and corresponding tools in one embodiment. When processing resources are available to scheduler tasks are assigned to execution contexts or that execute them to completion on virtual processors before picking up new tasks. An execution context executing on a virtual processor may also unblock other execution contexts by generating data a message or an event that will be used by other execution contexts .

Each task in scheduler may be realized e.g. realized tasks and which indicates that an execution context or has been or will be attached to the task and the task is ready to execute. Realized tasks typically include unblocked execution contexts and scheduled agents. A task that is not realized is termed unrealized. Unrealized tasks e.g. tasks may be created as child tasks generated by the execution of parent tasks and may be generated by parallel constructs e.g. parallel or parallel for . Scheduler may be organized into a synchronized collection e.g. a stack and or a queue for logically independent tasks with execution contexts i.e. realized tasks along with a list of workstealing queues for dependent tasks i.e. unrealized tasks as illustrated in the embodiment of described below.

Prior to executing tasks scheduler obtains execution contexts and from runtime environment or the operating system. Available virtual processors locate and execute execution contexts to begin executing tasks. Virtual processors become available again in response to an execution context completing blocking or otherwise being interrupted e.g. explicit yielding or forced preemption . When virtual processors become available the available virtual processor may switch to a runnable execution context to execute an associated task . The available virtual processor may also execute a next task or as a continuation on a current execution context if the previous task executed by the current execution context completed.

Scheduler searches for a runnable execution context or an unrealized task to attach to the available virtual processor for execution in any suitable way. For example scheduler may search for a runnable execution context to execute before searching for an unrealized task to execute. Scheduler continues attaching execution contexts to available virtual processors for execution until all tasks and execution contexts of scheduler have been executed.

At times an execution context may be blocked by an entity other than scheduler . The entity may be the OS or a runtime platform such as a runtime platform shown in and described in additional detail below and may preempt an execution context without notifying scheduler . Such preemption may occur for example if execution context performs a memory access that triggers a page fault in a system where the OS supports demand paged virtual memory. If an execution context page faults in such a system the OS may preempt and block the execution context and service the page fault as a hard fault that requires input output I O to a device such as a hard disk drive in memory system.

In some circumstances an execution context that is blocked from outside of scheduler may simply be rescheduled by scheduler when scheduler detects that the execution context has become unblocked. Scheduler may rescheduled the execution context by attaching the execution context to a virtual processor that may or may not be the same virtual processor that was executing the execution context when the execution context was blocked.

In other circumstances however an execution context that is blocked from outside of scheduler may be accessing data corresponding to a particular processing resource. For example the execution context may hold locks or other synchronization mechanisms e.g. scheduling locks or may be otherwise accessing data corresponding to a particular processing resource when the execution context is blocked. As a result a subsequent execution context that is scheduled on the virtual processor that was executing the blocked execution context may not be able to execute because of the locks held by the blocked execution context . In addition data accessed by the blocked execution context may have relevance only on the virtual processor that was executing the blocked execution context . As a result the execution of the blocked execution context may become confused if scheduler reschedules the blocked execution context on another virtual processor when the execution context becomes unblocked.

Scheduler operates to detect each execution context that is blocked from outside of scheduler while in a critical region e.g. critical region A in of the execution context . A critical region is a set of instructions in an execution context whose execution becomes contingent on data corresponding to a particular processing resource e.g. a particular virtual processor . When scheduler detects such an execution context scheduler ensures that the execution context resumes execution on the processing resource e.g. the virtual processor on which the execution context blocked when the execution context becomes unblocked. Scheduler also prevents another execution context or from entering a critical region on the same processing resource e.g. the same virtual processor prior to the blocked execution context becoming unblocked and exiting the critical region .

In one embodiment a critical region may encompass code that is responsible for making a scheduling decision for a virtual processor . The scheduling decision may involve identifying an execution context with accompanying task or a task to be picked up for execution by the virtual processor . In making the scheduling decision the code in the critical region may take locks or initiate other synchronization mechanisms that are local to the virtual processor . In other embodiments a critical region may encompass code that performs other functions where it is desirable to ensure that the code if blocked from outside of scheduler resumes on the same virtual processor .

When an execution context enters or otherwise begins execution of a critical region the execution context sets a critical region indicator e.g. critical region indicator A in corresponding to the execution context . The execution context clears the critical region indicator when the execution context exits or otherwise finishes execution of the critical region . In addition an execution context stores a virtual processor indicator e.g. virtual processor indicator A in that identifies the virtual processor on which the critical region is executing.

In one embodiment each critical region indicator forms a counter that is incremented when a corresponding execution context enters each critical region and is decremented when the corresponding execution context exits each critical region . In other embodiments each critical region indicator forms another suitable indicator that identifies when a corresponding execution context is executing a critical region or is blocked during execution of a critical region .

Scheduler identifies each execution context that blocked in a critical region using a corresponding critical region indicator and a corresponding virtual processor indicator as illustrated by the method of . is a flow chart illustrating an embodiment of a method for executing an execution context with a critical region . The method of will be described with reference to which are block diagrams illustrating embodiments of a processing resource i.e. virtual processor that executes execution contexts A and B.

In a determination is made as to whether critical region A of execution context A is to be entered as indicated in a block . The determination may be made explicitly in response to executing construct A in one embodiment or implicitly in other embodiments. Critical region A may for example include code that allows virtual processor to make a scheduling decision as to which execution context or task to execute next.

When an entry to critical region A is detected a determination is made as to whether the virtual processor that is executing the execution context A is available to execute the critical region A as indicated in a block . Scheduler prevents the execution context A from entering critical region A if another execution context or is currently blocked and the execution context or blocked in a critical region while executing on the same virtual processor that is executing execution context A. In such a scenario the virtual processor is not available to execute critical region A of execution context A and scheduler prevents critical region A from executing on the virtual processor as indicated in a block . To do so scheduler may block execution context A prior to entering critical region A or may move execution context A to another virtual processor prior to entering critical region A.

If no other execution context or is currently blocked while executing a critical region on the virtual processor execution context A enters critical region A and sets critical region indicator A as indicated in block . In one embodiment execution context A increments critical region indicator A to set critical region indicator A. In other embodiments execution context A sets critical region indicator A in other suitable ways.

A determination is made as to whether execution context A is blocked from outside of scheduler prior to exiting critical region A as indicated blocks and . If execution context A exits critical region A prior to being blocked then execution context A clears critical region indicator A as indicated in a block . The determination that execution context A exited critical region A may be made explicitly in response to executing construct A in one embodiment or implicitly in other embodiments. In one embodiment execution context A decrements critical region indicator A to clear critical region indicator A. In other embodiments execution context A clears critical region indicator A in other suitable ways.

If execution context A is blocked from outside scheduler prior to exiting critical region A then execution context A blocks and stores a virtual processor indicator A that identifies the virtual processor on which the critical region A is executing as indicated in block . Critical region A may invoke a page fault for example which causes the OS to block critical region A so that the page fault can be serviced. Execution context A remains in the blocked state until the entity that causes the block provides a signal to scheduler that indicates that execution context A has become unblocked as indicated in a block .

When execution context A becomes unblocked scheduler examines critical region indicator A to detects that execution context A was blocked while in critical region A. Scheduler also examines virtual processor indicator A to identify the virtual processor that was executing critical region A when execution context A was blocked. Scheduler causes the virtual processor to switch to execution context A to continue executing critical region A as indicated in a block . When the virtual processor becomes available scheduler may switch to the unblocked execution context A before switching to other execution contexts or tasks .

Subsequent to execution context A blocking and prior to resuming execution context A on the virtual processor scheduler may cause virtual processor to switch to an execution context B as shown in and perform the method of separately for execution context B. In virtual processor is executing execution context B while execution context A is blocked. If execution context B executes to completion without attempting to enter a critical region B then virtual processor may switch to and execute other execution contexts prior to resuming execution context A. If however execution context B attempts to enter a critical region B scheduler prevents critical region B from executing on the virtual processor as described above in blocks and because execution context A blocked on the same virtual processor in critical region A. Scheduler may block execution context B prior to entering critical region B or may move execution context B to another virtual processor prior to entering critical region B.

Once the execution of critical region A of execution context A is resumed execution context A maintains the state of critical region indicator A until critical region A is exited. In virtual processor resumes the execution of critical region A. Execution context B is shown as blocked in where the blocking may have occurred because execution context B attempted to enter critical region B. Upon exit of critical region A execution context A clears critical region indicator A as indicated in block .

With the method of scheduler allows execution context A to be resumed subsequent to being preempted by an entity other than scheduler and without providing any knowledge of the preemption to execution context A.

In embodiments of runtime environment that include garbage collection scheduler may operate to suspend execution contexts and at a safe point in response to garbage collection being invoked. To get each execution context and to a safe point scheduler round robins through execution contexts or to allow each execution context and to reach a safe point. As shown in the embodiment of any execution context or that attempts to enter a critical region while trying to reach a safe point ensures that the virtual processor that is executing the execution context or is available to enter the critical region . If not then the execution context or cooperatively blocks prior to entering the critical region to reach the safe point.

The above embodiments may allow a cooperative scheduler to operate in a runtime environment where preemptive blocking of an execution of an execution context of the scheduler can occur without knowledge of the scheduler. When such blocking occurs in a critical region of the execution context the scheduler invokes mechanisms that ensure the desired execution of the execution context when the execution context is unblocked. In addition the execution contexts may be structured to operate with a cooperative scheduler without regard for the possibility of preemptive blocking.

In one embodiment process shown in organizes tasks into one or more schedule groups and presents schedule groups to scheduler as shown in . is a block diagram illustrating an embodiment of a schedule group for use in scheduler .

Schedule group includes a runnables collection a realized task collection a work collection and a set of zero or more workstealing queues . Runnables collection contains a list of unblocked execution contexts . Scheduler adds an execution context to runnables collection when an execution context becomes unblocked. Realized task collection contains a list of realized tasks e.g. unstarted agents that may or may not have associated execution contexts . Scheduler adds a realized task to realized task collection when a new runnable task is presented to scheduler by process . Work collection contains a list of workstealing queues as indicated by an arrow and tracks the execution contexts that are executing tasks from the workstealing queues . Each workstealing queue includes one or more unrealized tasks .

Using the embodiment of scheduler may first search for unblocked execution contexts in the runnables collection of each schedule group in scheduler . Scheduler may then search for realized tasks in the realized task collection of all schedule groups in scheduler before searching for unrealized tasks in the workstealing queues of the schedule groups .

In one embodiment a virtual processor that becomes available may attempt to locate a runnable execution context in the runnables collection in the schedule group from which the available virtual processor most recently obtained a runnable execution context i.e. the current schedule group . The available virtual processor may then attempt to locate a runnable execution context in the runnables collections in the remaining schedule groups of scheduler in a round robin or other suitable order. If no runnable execution context is found then the available virtual processor may then attempt to locate an unrealized task in the workstealing queues of the current schedule group before searching the workstealing queues in the remaining schedule groups of scheduler in a round robin or other suitable order.

Computer system includes one or more processor packages a memory system zero or more input output devices zero or more display devices zero or more peripheral devices and zero or more network devices . Processor packages memory system input output devices display devices peripheral devices and network devices communicate using a set of interconnections that includes any suitable type number and configuration of controllers buses interfaces and or other wired or wireless connections.

Computer system represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system include a server a personal computer a laptop computer a tablet computer a personal digital assistant PDA a mobile telephone and an audio video device. The components of computer system i.e. processor packages memory system input output devices display devices peripheral devices network devices and interconnections may be contained in a common housing not shown or in any suitable number of separate housings not shown .

Processor packages include hardware threads M . Each hardware thread in processor packages is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system BIOS or firmware not shown OS a runtime platform applications and resource management layer also shown in . Each hardware thread may execute the instructions in conjunction with or in response to information received from input output devices display devices peripheral devices and or network devices .

Computer system boots and executes OS . OS includes instructions executable by hardware threads to manage the components of computer system and provide a set of functions that allow applications to access and use the components. In one embodiment OS is the Windows operating system. In other embodiments OS is another operating system suitable for use with computer system .

Resource management layer includes instructions that are executable in conjunction with OS to allocate resources of computer system including hardware threads as described above with reference to . Resource management layer may be included in computer system as a library of functions available to one or more applications or as an integrated part of OS .

Runtime platform includes instructions that are executable in conjunction with OS and resource management layer to generate runtime environment and provide runtime functions to applications . These runtime functions include a scheduler function as described in additional detail above with reference to . The runtime functions may be included in computer system as part of an application as a library of functions available to one or more applications or as an integrated part of OS and or resource management layer .

Each application includes instructions that are executable in conjunction with OS resource management layer and or runtime platform to cause desired operations to be performed by computer system . Each application represents one or more processes such as process as described above that may execute with scheduler as provided by runtime platform .

Memory system includes any suitable type number and configuration of volatile or non volatile storage devices configured to store instructions and data. The storage devices of memory system represent computer readable storage media that store computer executable instructions including OS resource management layer runtime platform and applications . The instructions are executable by computer system to perform the functions and methods of OS resource management layer runtime platform and applications described herein. Examples of storage devices in memory system include hard disk drives random access memory RAM read only memory ROM flash memory drives and cards and magnetic and optical disks.

Memory system stores instructions and data received from processor packages input output devices display devices peripheral devices and network devices . Memory system provides stored instructions and data to processor packages input output devices display devices peripheral devices and network devices .

Input output devices include any suitable type number and configuration of input output devices configured to input instructions or data from a user to computer system and output instructions or data from computer system to the user. Examples of input output devices include a keyboard a mouse a touchpad a touchscreen buttons dials knobs and switches.

Display devices include any suitable type number and configuration of display devices configured to output textual and or graphical information to a user of computer system . Examples of display devices include a monitor a display screen and a projector.

Peripheral devices include any suitable type number and configuration of peripheral devices configured to operate with one or more other components in computer system to perform general or specific processing functions.

Network devices include any suitable type number and configuration of network devices configured to allow computer system to communicate across one or more networks not shown . Network devices may operate according to any suitable networking protocol and or configuration to allow information to be transmitted by computer system to a network or received by computer system from a network.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

