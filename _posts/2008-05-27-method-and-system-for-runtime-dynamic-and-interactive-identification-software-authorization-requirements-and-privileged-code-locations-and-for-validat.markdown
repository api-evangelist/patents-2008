---

title: Method and system for run-time dynamic and interactive identification software authorization requirements and privileged code locations, and for validation of other software program analysis results
abstract: A system, method and computer program product for identifying security authorizations and privileged-code requirements; for validating analyses performed using static analyses; for automatically evaluating existing security policies; for detecting problems in code; in a run-time execution environment in which a software program is executing. The method comprises: implementing reflection objects for identifying program points in the executing program where authorization failures have occurred in response to the program's attempted access of resources requiring authorization; displaying instances of identified program points via a user interface, the identified instances being user selectable; for a selected program point, determining authorization and privileged-code requirements for the access restricted resources in real-time; and, enabling a user to select, via the user interface, whether a required authorization should be granted, wherein local system, fine-grained access of resources requiring authorizations is provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449190&OS=09449190&RS=09449190
owner: International Business Machines Corporation
number: 09449190
owner_city: Armonk
owner_country: US
publication_date: 20080527
---
This application is a continuation of U.S. application Ser. No. 11 416 839 filed May 3 2006 the entire contents of which are incorporated herein by reference.

This invention relates generally to the field of data and operation security and authorizing access to software programs and particularly to a system and method for automating the dynamic identification of authorization requirements of software programs in a manner that protects the integrity of the system on which the identification is performed. Furthermore this invention describes how to dynamically determine locations of library code that are candidates to become privileged. Additionally this invention can be used to validate the results obtained by performing other analysis on code including static analysis and code inspection.

Modern computer run time environments providing a fundamental set of services that all programs can use such as Java Standard Edition Java SE and Microsoft .NET Common Language Runtime CLR have adopted a form of access control based on stack inspection. When security is enabled all security sensitive resources are by default access restricted. Such resources include the file system network operating system printers etc. When access to a restricted resource is attempted a particular security function is invoked by the underlying security system. For example in Java SE this function is called checkPermission and in CLR Demand . Both these functions take an object as a parameter that represents the access being attempted. For example in Java SE this object is of type Permission of one of its subclasses and in CLR this object is of type IPermission. The purpose of the functions is to traverse the stack of execution and verify that all the classes of all the methods on the stack have been granted the necessary authorization. If just one of the callers on the stack cannot exhibit the appropriate authorization an Exception is thrown and access to the requested resource is denied to all the callers on the stack.

This architecture guarantees that if access to a protected resource succeeds no untrusted code can be on the stack. This is particularly useful in systems where programs are collections of components such as libraries plug ins etc. for example Java Archive JAR files in Java SE or assembly files in CLR . In such systems different components with different levels of trust may be assembled together so it is important to ensure that untrusted components do not get unintended privileges.

Typically permissions are fine grained. For example for a Java SE FilePermission it is possible to specify the name of the file s and the mode s of access read write execute and delete . Permissions are granted declaratively in an external policy file so that a computer programmer is not required to hardcode access control in a program.

Sometimes trusted library code may need to perform certain operations that its callers did not explicitly request. For example a library may exhibit a method createSocket responsible for constructing Sockets and returning them to its client programs. It makes sense to expect those client programs to be authorized with a SocketPermission. However for auditing purposes the library developer may have chosen to embed code in createSocket that logs the Socket creation operation to a file. In this case the library s client programs will need a FilePermission too. Since the purpose of createSocket is to create a Socket granting client programs the FilePermission to write to the log file would be a violation of the so called Principle of Least Privilege see Jerome H. Saltzer and Michael D. Schroeder The Protection of Information in Computer Systems in Proceedings of the IEEE Volume 63 Pages 1278 1308 September 1975 . To prevent system administrators from needing to authorize client programs when a permission requirement is caused by a library the portion of library code responsible for performing the operation not explicitly requested by the client can be made privileged. For example in Java SE making code privileged requires wrapping it into a call to doPrivileged see in CLR it requires wrapping that code into a call to Assert . When authorization checks are performed privileged code causes the stack inspection mechanism to interrupt at the library level. The end result is that client programs invoking that library will not be required to possess the permission to perform the operation executed in the library s privileged code.

This is particularly depicted in which illustrates how client code Client.main invokes LibraryCode.createSocket for the purpose of getting a socket connection to a remote system. When LibraryCode.createSocket constructs the Socket a stack is generated that causes an authorization check. All the callers will need to prove possession of the necessary SocketPermission. However in the example depicted this library code has been programmed so that as soon as the Socket has been created the Socket creation is logged to a file. A new stack is generated and all the callers on the stack will now have to prove possession of the necessary FilePermission. Fortunately the developer has added a call to doPrivileged which stops the stack inspection at the frame just above doPrivileged . This way the client code is exempted from proving possession of the FilePermission and consequently the client code will not have to be granted any FilePermission to write to the log file log.txt. If the client had to be granted such permission the client could misuse it and overwrite the log file. Since the library calls doPrivileged it is not necessary for the client to have that FilePermission and the client will not be able to misuse that permission.

Another form of access control adopted by modern computing systems is Role Based Access Control RBAC . For example Java Enterprise Edition Java EE and CLR have adopted RBAC to restrict access to security sensitive resources. In RBAC restrictions are enforced on the operations performed by the code rather than the data manipulated by the code. A role is a semantic grouping of rights to access rights. Users of a RBAC system are assigned roles. When a user attempts to perform a restricted operation on an RBAC system that user must have been authenticated and must show possessions of the roles necessary to perform that operation. Typically the roles assigned to a user are propagated throughout the execution of the code. Therefore stack inspection in these systems is not strictly necessary since the roles granted to the executing user are immediately available to the underlying for verification and there is no need to traverse the stack backwards. When access to a restricted operation is attempted the underlying system verifies that the roles granted to the user are sufficient to perform that operation. Roles are typically granted declaratively in an external deployment descriptor file. This way system administrators can configure access control of applications without the need for hardcoded access control.

Even though access control based on stack inspection and or roles is very sophisticated it is also very difficult to configure. Given a large and complex program it becomes almost impossible to understand what permissions and or roles are required before run time. Similarly it is also very difficult to understand what portions of library code should be made privileged. The three approaches commonly used are 

1 Manual code inspection. This approach is extremely expensive and error prone. For large programs this approach is discouraged. Additionally the source code of the program may not be available the compiled code could have been purchased from a third party or it could have been machine generated so this approach may not even be feasible 

2 Dynamic analysis or testing. This approach consists of writing or generating test cases that make calls into the target program. During testing the system component responsible for enforcing security must be active. For example in Java SE there must be an active SecurityManager which can be installed by specifying the Djava.security.manager flag on the command line or by calling System.setSecurityManager new SecurityManager from within the program . The untrusted libraries or components should be granted no permissions. The trusted libraries should be granted AllPermission. At this point executing a test case will generate security Exceptions every time access to a protected resource is attempted while untrusted code is on the stack. The tester is supposed to log each of these Exceptions understand what permission is missing decide whether it is appropriate to grant that permission and if yes manually add that permission to the policy file which is also a difficult operation since policy files have a complicated syntax and a simple typo can make the entire policy not valid . If the code being tested is library code it is also necessary to decide for each missing permission whether it is appropriate to require that client programs invoking that library be granted that permission or if it is more appropriate to make the portion of library code generating the permission requirement privileged. After a decision has been made a new test case must be written and the same sequence of operations repeated until no security Exceptions are discovered. However this process is tedious time consuming and error prone due to the following 

Typically each security Exception generated during testing can terminate the program. It is therefore necessary to restart the program every time and for complex program it may be quite time consuming to bring them to a certain desired state where the testing can continue.

Additionally dynamic analysis is potentially unsound meaning that it may miss some authorization or privileged code requirements because there may be paths of execution that may remain undiscovered during testing. For example a particular path of execution for an application may become feasible only upon passing a certain parameter to one of the application s entry points. If that parameter is not passed to the application during testing the corresponding path of execution may remain undiscovered until run time. Other errors might be performed while editing the policy file.

Static analysis. This approach consists of using a tool that models the execution of a program without running the program itself. From the model it is possible to infer the program s authorization requirements see Koved Pistoia Kershenbaum. . OOPSLA 2002 Seattle November 2002 and the privileged code requirements see Pistoia Flynn Koved and Sreedhar. Interprocedural Analysis for Privileged Code Placement and Tainted Variable Detection. ECOOP 2005 Glasgow Scotland UK July 2005 . However this approach too has some limitations 

It is clear that none of these solutions alone is sufficient to completely determine the authorization requirements of a program.

It would be highly desirable to provide a system and method that performs automatic run time discovery of authorization requirements.

The present invention is directed to a run time dynamic automated interactive and secure authorization requirement and privileged code placement discovery system method and apparatus that allows users to automatically a discover the security sensitive actions attempted by a program b detect the program s authorization requirements c identify portions of library code that should be made privileged and d configure and inspect the security policy of the program. The run time authorization requirement and privileged code placement discovery operations are performed without having to write or generate test cases manually edit the policy database compromise the integrity of the underlying computer or restart the application at every security Exception permission requirement finding privileged code placement finding or policy change.

Particularly a system method and computer program product for automatic identification of authorization requirements of software programs and for validation of other analysis results such as results obtained from static analysis code inspection etc. is provided with functionality such as 1 executing the program in a restricted environment by default which guarantees that the program will not harm the underlying computer software or hardware in any way 2 allowing the user to select which methods in the program should be executed without the need for writing or generating test cases 3 automatically configuring access control if the user has a level of trust in the program the user can choose which authorizations should be granted to the program and which should not based on the authorization requirements progressively discovered by the system 4 enabling interactive authorization requirement discovery and configuration 5 detecting authorization requirements that may be generated by side effects of method invocations 6 enabling a user to inspect the security configuration of the program at any time 7 supporting component based programs with each component potentially being granted different permissions 8 permitting automatic modification of the program s security policy no manual editing is required 9 permitting user inspection of the program s code origin for example the network location from which the code is coming as well as the certificate of the code providers if those code providers digitally signed that code and the access rights already granted to the program 10 precisely identifying the program points component name class name method name file name and line number where a permission is missing and or a privileged code instruction should be inserted 11 precisely identifying what other permissions have already been granted to the program s code 12 enabling inspecting the entire stack trace in a GUI and displays where in the stack trace the permission is missing 13 obviating the need to stop the program when a permission is missing 14 preventing denial of service attacks which can cause a system to stop working from happening 15 providing a non conservative system if the system reports that a permission or a piece of privileged code is required that permission or piece of privileged code is really required 16 updating and reapplying the security policy at any change performed by the user without the need of restarting the program 17 facilitating the security configuration by providing a graphical user interface 18 performing immediate detecting of a missing permission 19 displaying the security history of the program under analysis important for methods that take parameters since it allows inspecting the different authorization and privileged code requirements based on the different values passed 20 allowing detection of the different permission requirements that can arise when invoking methods with different parameters 21 allowing for the automatic discovery of the security sensitive actions attempted by a program 22 allowing automatic inspection of the stack trace every time a problem occurs in the program and an Exception is raised not just security Exceptions and 23 validating results obtained by executing other analyses such as static analysis and code inspection on the program.

It is understood that the system and method of the invention does not depend on the particular security subsystem. If the security subsystem configuration changes for example as a result of having installed a different implementation of the access control enforcer checkPermission in Java SE or Demand in CLR authorization requirements will changes accordingly but no change is required to this invention to detect the new authorization requirements.

It is also understood that the present invention is not limited by the mechanism in systems that enforce access control. For example the present invention can detect authorization and privileged code requirements in systems that enforce access control regardless of whether or not the authorization mechanism is based stack inspection RBAC or a different mechanism. Conversely static analysis tools for authorization and privileged code requirements need to be built based on the specific run time authorization mechanism.

Moreover it is understood that this invention has a scope broader than just authorization and privileged code requirement detection. In fact it can be used to automatically identify general problems in code such as NullPointerExceptions and to validate results obtained by executing static analysis on that code. For example this invention can be used to identify the false alarms reported by a static analyzer and more in general this invention can be used as a debugging tool.

Thus according to the invention there is provided a system method and computer program product for detecting security permission security role and privileged code requirements in a run time execution environment in which a software program is executing the system comprising 

There is further provided a mechanism for identifying problems in code such as Exceptions raised by code.

Preferably the method of this invention is provided independent of the particular security subsystem implemented.

In further aspects of the invention a program point includes one or more of a program component a class a method a file name and a line number.

Moreover the reflection mechanism performs functions including but not limited to enabling instantiation of selected objects of the program and enabling determination of all methods and constructors capable of being invoked for objects and classes of the program. These determined methods are displayed for user selection via the user interface.

In another embodiment of the invention there is provided a run time authorization requirement discovery tool for a computing device executing software programs requiring security permissions or roles the tool comprising 

In accordance with this aspect of the invention the system allows the user to select which methods in the program should be executed without the need for writing or generating test cases.

In a further aspect of the invention there is provided a system and method for providing real time software authorization access to restricted resources by a computer program the system comprising 

Further to these aspects of the invention the system and methods of the invention generates for display information about the code having the missing authorization the information comprising the fully qualified characterization of the permission or role requirement a URL from which the code requiring the permission is originated the certificates of entities that signed that code the specific code location requiring the authorization the security sensitive operation being attempted and the program permissions already granted to the code component.

Moreover further to the system and method of the invention there is provided a means for automatically updating a security policy in response to a user granting a particular authorization without the need for restarting execution of the program.

In a further aspect of the invention there is provided a system method and computer program product for detecting problems in an executing software program comprising 

Moreover there is further provided a system method and computer program product for verifying analysis results of software programs the analysis results being obtained as a result of a previously performed software analysis technique the method comprising 

Further to this aspect of the invention the previously performed software analysis technique comprises a static analysis performed by a static analysis tool for detecting problems in the program or an analysis performed by a user inspecting said software for detecting a problem in the program.

Advantageously the present invention can be applied to any software security system enforcing access control particularly software security systems based on stack inspection Role Based Access Control RBAC systems software security systems enforcing access control restrictions on data and software security systems enforcing access on operations.

The invention is directed to a run time authorization requirement discovery tool that allows users to automatically a discover the security sensitive actions attempted by a program b detect the program s authorization requirements c detect a program s privileged code requirements and d configure and inspect the security policy of the program.

The automated run time authorization and privileged code requirement discovery tool is enabled by using reflection a technology that allows automatically inspecting compiled code creating objects and invoking methods on objects and classes. The program components being analyzed are isolated from the rest of the invention implementation code as well as from the trusted libraries. This allows customizing the level of trust of the program under analysis without having to change the security configuration of other components.

Aspects of the invention will be described with reference to which illustrates the computing system in which the system security tool of the present invention operates. Included in the system e.g. a personal computer a mobile computing device a server e.g. a Web Server is an Operating System memory and processor for executing a Java Virtual Machine JVM or like platform independent computing system that implements a JVM that provides a Java Runtime Environment JRE . The JVM provides the Java Run Time environment in which a Security Manager object is instantiated by the system security tool of the invention that performs run time access controls on attempts to perform any security sensitive operation such as file I O network I O creation of a new ClassLoader manipulation of Threads ThreadGroups starting processes on the underlying operating system terminating the JVM loading non Java libraries native code into the JVM performing certain types of windowing system operations changing the configuration of the JVM or of the underlying Operating System and loading certain types of classes into the JVM. For example the Java applet sandbox a function of the SecurityManager severely constrains untrusted applets to a limited set of functions that are considered to be safe. Particularly in an example implementation of the invention as will be described in greater detail herein a security manager instance sm obtained by calling the constructor of the SecurityManager class or one of its subclasses and by then making it the active security manager of the system by calling System.setSecurityManager sm is invoked by the system security tool to enforce the run time authorization requirement and privileged code requirement discovery for local or remote programs or libraries . Security tool of the invention enforces the system s active security manager object yet operates independently of the underlying security system implemented. It is understood that any SecurityManager implementation will work with this invention regardless of which resources that SecurityManager implementation restricts access to and the way access is restricted.

As shown in the system security tool allows fine grained access control configuration via a display interface . The security manager object by default denies access to all the system resources it protects. However it is possible to specify in detail what the code is allowed to do based on one or more of the following the URL location from which the code is coming the signers of the code and the identity of the user running the code using Java Authentication and Authorization Service JAAS . Permissions are granted declaratively in a storage media capable of storing the policy. By default a policy is stored in a flat file based policy database called the policy file . With respect to the signers of the code it is understood that multiple signers are allowed and the JVM verifies the signatures transparently. The policy code includes one or more protection domains each protection domain encapsulating a code source a permission collection and a possibly empty array of Principal objects. The code source inside each protection domain encloses a URL object representing the network location from which the code is coming and an array of Certificate objects each Certificate object representing the identity of a code digital signer. The permission collection encapsulated in the protection domain represents all the access rights already granted to the code based on the code source. The array of Principal objects correspond to the authentication information of the user or service executing the code assuming that the user or service has authenticated . Class loader instances are designed to associate a protection domain with each loaded class.

Thus it is seen from how the present invention is implemented within the Java SE access control model.

The system security tool of the invention implements reflection a technology that allows users to automatically inspect compiled code create objects and invoke methods on objects and classes. The system implements reflection techniques enabling it to instantiate any new object. More particularly using the CLASS FACTORY object an object s class is loaded using reflection to detect that class constructors and reflection is again used to invoke any of those constructors as selected by the user. Thus users are enabled to create objects. Therefore using the CLASS FACTORY object a user is enabled to create those objects that may be needed to be passed as parameters to method invocations.

According to the invention the program components being analyzed are isolated from the rest of the invention implementation code as well as from the underlying libraries. This allows customizing the level of trust of the program under analysis without having to change the security configuration of other components. Thus returning to there is depicted the further step of implementing reflection method invoke which enables the invocation of the selected method highlighted via the display interface shown in . The system of this invention allows invoking methods of the program under analysis executed in a sandbox environment the program is not allowed to perform security sensitive operations unless it is explicitly granted the necessary permissions . As known a sandboxing tool may be implemented that allows a user to control and isolate parts of the execution of a running process with each isolated portion given the illusion that it is interacting with a full system while in fact it is confined to a restricted environment where only limited resources can be accessed. If any of the methods being invoked attempts to perform an operation that requires a permission or a role in a RBAC system that has not been granted a SecurityException is generated. Thus returning to step after invoking the selected method via reflection a determination is made as to whether an access control exception is thrown i.e. a required permission is missing. As will be explained in greater detail herein and referring to the system catches the Exception and either displays the result if no access control exception is thrown at step or displays the access control exception that is thrown at step . When a thrown exception is caught the system reports via the interface 1 What operation was attempted 2 All the callers on the stack 3 Which stack frames do not have the required permission and 4 Precise information about the code that has not been granted the permission component name class name method name line number code origin and permissions already granted .

As a result of selecting a method from the interface of a resulting display is shown via the example GUI depicted in . particularly depicts the interactive nature of the invention whereby a user is enabled to select a detected method of interest e.g. a writeLogFile method and invoke it . Thus as shown in the system allows the user to select which methods in the program should be executed and invoke the method in a user friendly GUI environment obviating the need to write or generate test cases. Further the tool of the invention implements upon selection by the user utilities for displaying the context arguments and return values of the invoked method which are user selectable. In the exemplary display provided in reflection is used to execute the selected method procedure of a class e.g. writeLogFile on the object SecurityLibrary xxxxxxxx . The reflection technique used is by calling the method invoke as shown at step .

Referring back to it should be understood that selection of one or more boxes associated with the methods of interest for analysis according to the invention will cause for display the selected methods as children of the given object SecurityLibrary for example and permit the user to invoke them after specifying the parameters if necessary. depicts an exemplary display showing all of the methods selected via the boxes in as children shown in . For a selected method the system enables further drill down to obtain context and arguments and return values as shown in for the writeLogFile method invocation . As further shown in the user is permitted to view the Parameter Types in fields the Available Values in fields and additionally enter any Parameter Values for the selected method in entry fields associated with the method of interest. The Available Values are those that have been already created by invoking some methods previously. Available Values compatible with the Parameter Types can be chosen from a scroll down list or can be dragged and dropped in a user friendly GUI. If the values are of primitive types scalars or String objects they can be edited and entered . Values that are not available can be explicitly constructed via the CLASS FACTORY object .

Via the interface as depicted in the process of permission identification and permission granting is all mediated. As shown in the tool permits a user to immediately understand what are the permissions needed at run time as depicted by an example icon s representing a needed permission s . Continuing with the example thread for the writeLogFile method invocation it is seen that the needed permission is ajava.io.FilePermission C log.txt write . That is an AccesControlException is raised as the permission java.io.FilePermssion C log.txt.write is required to be able to run the application. The system thus allows for automatic discovery of the security sensitive actions attempted by a program. It is understood that in no case is it necessary or required to stop the program when AccessControlExceptions are raised when permissions have not been granted.

Returning back to the system tool of the invention allows the user to choose whether the permission should be granted. Thus after an AccessControlException is raised and displayed at step a printStackTrace method is invoked at step to perform a trace of the thread stack from which the raised exception had been determined. Details regarding thread stack inspection are described herein with respect to . Then invoking the getPermission method on the AccessControlException the system generates for display the missing permission as indicated at step . Continuing further the user determines at step whether the code is trusted code and it is appropriate to grant it the missing permission. If the code is determined untrustworthy the permission will not be granted and the system will return such notice and keep the AccessControlException status in the interface at step . Otherwise a Policy Update is automatically performed by the method of this invention and accordingly the addition of the required permission into the policy file is automatically performed as depicted at step . The system automatically refreshed the policy. It is understood that in no case is it necessary or required to stop and restart the program for the updated policy to take effect. That is when an AccessControlException is raised the permission that is required is either not granted or added to the policy file or more in general the policy database . Preferably according to the invention the user can inspect the security configuration of the program at any time in addition to allowing for automatic modification of the program s security policy. Furthermore it is not necessary to manually change or refresh the policy. As each invocation is executed in a separate thread if the invocation causes a denial of service attack its thread can be stopped without harming the execution of other methods or the execution of the system itself. The results of previous invocations can be cached so that a security history can be seen at any time or automatically updated depending on a user s preference. Automatic updating of invocations allows immediate displaying of side effects caused by other invocations. Thus if a method invocation causes the permission requirements of another method invocation to change and the new permissions required by that other method invocation have not been granted yet an AccessControlException will be raised in place of the previously displayed return value for that other method invocation as long as that other method invocation was configured for automatic updating.

Referring to via an example display interface there is depicted in response to the thrown AccessControlException the confirmation by the current security policy that the required permission is missing the policy is initially empty by default as indicated by the empty displayed dialog box .

Referring to there is depicted an example display interface . As mentioned in connection with inspecting the stack trace if a permission requirement is detected the system of the invention causes for display the stack trace for user inspection. The stack inspection process for Java SE has been described herein with respect to . Via the example GUI displayed in the system displays all the stack frames in the trace including the stack frames where the required permission is missing. By looking at the stack trace the user can infer where the required permission is missing. As seen via interface the highlighted line depicts where the user has identified the program point where a permission is missing. As shown in the program point includes the class name method name and line number. However there may be cases where the user cannot identify and highlight the precise stack frame where the permission is missing.

It is seen from the foregoing description and exemplary that the process of permission identification and permission granting is all mediated by the GUI. Thus what is presented is a run time authorization requirement discovery tool that allows users to automatically 1 discover the security sensitive actions attempted by a program 2 detect the program s authorization requirements 3 detect the program s privileged code requirements and 4 configure and inspect the security policy of the program. Preferably these actions are performed without having to write or generate test cases manually edit the policy compromise the integrity of the underlying computer and without having to restart the application at every permission requirement finding or policy change. Thus the level of trust of a program under analysis may be customized without having to change the security configuration of other components. Moreover in view of the description and exemplary a user can automatically not manually enable and disable the system security which allows the execution of the program in a restricted environment sandbox independent of the particular security subsystem. If the security subsystem configuration changes authorization requirements will change accordingly. This invention is flexible and adapts itself to different security policies and it detects the new authorization requirements automatically.

The system method and computer program product of the invention thus allows for automatic discovery of the security sensitive actions attempted by a program. In addition the system allows detecting the different permission and privileged code requirements that can arise when invoking methods with different parameters. As shown here detecting a missing permission or a privileged code requirement is immediate. The authorization requirement for the discovery and configuration is interactive. Also as opposed to a static analysis approach the system of the invention is not conservative since the system does dynamic analysis. That is if a permission requirement is reported that permission is really needed. Furthermore as opposed to a static analysis approach the system of this invention is not limited by the presence of native methods and reflection which when not modeled make a static analysis unsound.

The system of this invention allows invoking methods of the program under analysis in a sandbox environment the program is not allowed to perform security sensitive operations unless it is explicitly granted the necessary permissions . If any of the methods being invoked attempts to perform an operation that requires a permission that has not been granted a SecurityException is generated. The system catches the exception and reports it via the user interface as described herein.

Advantageously the system of the invention may be integrated within and operate in conjunction with a static analysis permission finder such as IBM s Security Workbench Development Environment for Java SWORD4J tool e.g. released version 1.0.45 of IBM s SWORD4J .

The system of this invention can be used also for non security related problem finding and in conjunction with other non security related analyses. For example shows an exemplary display in which the code being tested generates a NullPointerException . The system of this invention can be used to identify that the code has a problem causing the NullPointerException inspect the stack trace associated with the NullPointerException and identify the reason for the NullPointerException.

The system of this invention can be used in conjunction with other analyses such as code inspection. For example a code reviewer may suspect that a NullPointerException or an AccessControlException will be generated at run time and can use the system of this invention to verify if the Exception will actually be raised.

The present invention has been described with reference to diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each diagram can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer embedded processor or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions specified herein.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the functions specified herein.

The computer program instructions may also be loaded onto a computer readable or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions specified herein.

While the invention has been particularly shown and described with respect to illustrative and preformed embodiments thereof it will be understood by those skilled in the art that the foregoing and other changes in form and details may be made therein without departing from the spirit and scope of the invention which should be limited only by the scope of the appended claims.

