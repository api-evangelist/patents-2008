---

title: Memory order tester for multi-threaded programs
abstract: One method of testing multi-threaded code involves accessing a first set of instructions which are configured to be executed, in execution order, as a thread of a multi-threaded process. A memory space is modified, based upon the first set of instructions. The modified memory space represents one or more values that are generated by executing the first set of program instructions in a different order than execution order. The memory space is processed by a second set of program instructions, which is configured to be executed as a second thread of the multi-threaded process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930683&OS=08930683&RS=08930683
owner: Symantec Operating Corporation
number: 08930683
owner_city: Mountain View
owner_country: US
publication_date: 20080603
---
This invention relates to multi threading and more particularly to testing multi threaded programs for memory order errors.

Multi threading involves supporting multiple threads of execution. The threads can execute simultaneously e.g. in environments that provide multiple microprocessors and or multiple processing cores per microprocessor or in an interleaved fashion e.g. in environments in which independent hardware is not available to execute each thread . Threads within the same multi threaded program execute as part of the same process and share the same resources including memory i.e. the threads share the same address space .

Many popular programming languages like C and C were designed prior to the rise in popularity of multi threading. Accordingly these languages do not feature built in support for multi threading. Instead libraries have been developed to provide primitives that can be used to support multiple threads.

Applications written in languages that provide support for multiple threads of execution via library based primitives are susceptible to certain types of memory ordering errors when operating according to a weak memory model. Weak memory models effectively allow different threads to each have a different view of the shared memory space. For example a thread executing on one processor will access its own address space e.g. provided in a memory that is associated with the processor on which that thread is executing . The thread s address space represents the shared memory e.g. it is updated in response to the execution of other threads however at any point in time the thread s address space may significantly differ from the address space used by another thread despite the fact that the threads are technically sharing memory. For example at time T1 one thread s address space may reflect that the value of variable A is 20 while another thread s address space may reflect that the value of variable A is 0 despite that fact that both threads are part of the same process. Each thread s address space evolves over time e.g. as values are written to and read from that address space however with a weak memory model there are few constraints on when the different addresses spaces evolve relative to each other.

As an example of a situation in which a memory order error can arise one thread can include a first instruction that produces a value that is consumed by a second instruction in another thread yet there may not be any restriction either in the program or in the memory model on when the first and second instructions execute relative to each other and when the results of such execution will be reflected in the shared memory space as seen by all threads. Accordingly depending upon when the two instructions execute or when the shared memory space as viewed by each thread is updated based upon the execution of those instructions the value consumed by the second instruction may or may not depend upon the value produced by the first instruction. If the program s author intended for a dependency to exist but the instructions can execute in an order that does not reflect that dependency or vice versa a memory order error may arise during execution. Memory ordering errors like this are often extremely difficult to detect since different execution environments and or compilers can lead to instructions executing or appearing to execute from the perspective of each thread in different orders such that the memory order error may only arise in certain situations. Accordingly techniques that facilitate the detection of memory order errors in such environments are desirable.

Various techniques for testing multi threaded code for memory order errors are disclosed. One method of testing multi threaded code involves accessing a first set of program instructions. The program instructions in the first set are configured to be executed in execution order as a thread of a multi threaded process. The method then modifies a memory space based upon the first set of instructions. The modified memory space represents one or more values that are generated by executing the first set of program instructions in a different order than the execution order. The memory space is processed by a second set of program instructions which is configured to be executed as a second thread of the multi threaded process. Based upon the second set of program instructions and the modified memory snapshot and particularly whether allowing the second set of instructions to process the values in the modified memory space causes any memory order errors memory order errors within the multi threaded code can be detected.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail consequently those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects inventive features and advantages of the present invention as defined solely by the claims will become apparent in the non limiting detailed description set forth below.

While the invention is susceptible to various modifications and alternative forms specific embodiments of the invention are provided as examples in the drawings and detailed description. It should be understood that the drawings and detailed description are not intended to limit the invention to the particular form disclosed. Instead the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

A memory order tester tests multi threaded code by first modifying a memory space such that at a particular point in time the modified memory space represents results that would be generated if the program instructions in a particular thread or multiple such threads were executed in an order other than their configured execution order. The modified memory space is processed e.g. through simulation or execution by one or more other threads. The memory order tester detects whether allowing the modified memory space to be processed by another thread within the multi threaded code will result in memory order errors.

Throughout this disclosure terms like first and second are used to identify specific threads snapshots and or sets of instructions. These terms are simply used for clarity in order to differentiate between two similar items and are not meant to imply any other relationship especially temporal between the items. Thus a first thread can execute at the same time as a second thread and the second thread may even begin executing prior to execution of a first thread being initiated.

For the thread shown in a coherent memory snapshot representing the results of executing the two instructions in the thread will include information indicating that the current value of A is one and that the current value of B is one. The coherent memory snapshot represents a point in time snapshot of these values as seen in the thread s address space.

A memory order tester determines a set of results that would be generated if the instructions in the thread were executed in a different order than their configured execution order. In general the instructions are executed in a different order than the configured execution order if the instructions are reordered and or if fewer than all of the instructions are executed. These incoherent results are applied to a memory space other than the thread s memory space. illustrates a point in time snapshot referred to as an incoherent snapshot of such a memory space.

As shown in an incoherent memory snapshot indicates that the value of A is zero 0 while the value of B is one 1 . This snapshot represents the results that would occur if the second instruction B 1 were executed before the first instruction A 1 and or if the first instruction were not executed at all.

As the example of shows the instructions that are executed in a different order e.g. by reordering and or selectively executing the instructions for purposes of generating the incoherent memory snapshot are the instructions that generate results and cause those results to be stored to a memory location. Accordingly only these types of instructions are shown in these examples.

Accordingly if the initial values of x and y are zero 0 a coherent memory snapshot representing the results generated by this thread should indicate that y still equals zero 0 after execution of the instructions. In other words if x does not equal one 1 y should not remain incremented i.e. the first instruction will increment y but since x does not equal one 1 the second instruction will decrement y. This result is also consistent with the original source code instruction.

To generate an incoherent memory snapshot a memory order tester can reorder the two instructions and or select to not execute one of the instructions. Here the second instruction is not executed so that y has a value of one 1 even though x has a value of zero 0 . An alternative incoherent memory snapshot can indicate that y has a value of negative one 1 as would arise if the second instruction was executed and the first instruction was not executed.

The method of begins at where user input specifying a multi threaded program under test is received. The user input can specify the multi threaded program under test by specifying a path name and or file name that identifies the location of the program under test within a file system. The user input can be entered as text a set of one or more user selections from a menu in a graphical user interface or the like.

The specified program can include a variety of different types of information. For example in one embodiment the specified program may include one or more files each containing source code. Alternatively the specified program may include a compiled executable.

In addition to user input specifying the program under test user input specifying when testing should begin can also be received not shown . For example if user input selecting a Begin Test option is received it indicates that testing should begin immediately. In some embodiments testing is delayed until such user input is received.

In some embodiments a single memory order tester can implement more than one testing environment and or methodology examples of such environments and methodologies are described below . In such embodiments user input specifying which environment and or methodology to use can also be received not shown . This user input is then used to configure the memory order tester such that the testing will be performed using the selected methodologies. For example if the memory order tester supports both instrumentation based testing and write protection based testing environments user input can specify which type of testing environment to use.

At the memory order tester accesses a first set of program instructions within the program under test. The instructions in this first set are configured to execute as a first thread of execution. Accessing the first set of program instructions can involve reading the instructions e.g. from a persistent storage device into memory and in some embodiments processing the instructions. For example in some embodiments accessing the first set of program instructions involves instrumenting the first set of program instructions such that when executed those instrumented instructions will modify another thread s memory space in an incoherent manner. Alternatively accessing the first set of instructions can involve accessing one or more instructions within a particular thread in order to simulate execution of those instructions.

At the memory order tester modifies a memory space in order to create an incoherent view with respect to the first thread of shared memory. This modified memory space is used by a thread or multiple other threads other than the first thread. The modified memory space is incoherent because the modified memory space at some point in time during the testing process represents results that would be generated by at least some of the first set of program instructions if those instructions were executed in an order other than their configured execution order. This memory space can be modified in a variety of different ways as described in more detail below.

The modified memory space produced by is then processed by a second set of program instructions which is configured to execute as a separate thread of execution or several such sets of program instructions each set being configured to execute as a separate thread as shown at . The ways in which the memory space is processed can vary e.g. based upon the technique used to modify the memory space . For example if the modified memory space was created by simulating the first thread the second thread can process the modified memory space via simulation as well.

It is noted that operations and can be performed at substantially the same time during memory order testing. For example operation can be repeated multiple times as the first thread is being simulated or executed. While operation is being performed operation can also be performed since simulation and or execution of the second thread can be taking place at the same time as execution and simulation of the first thread e.g. by switching back and forth between threads through the use of thread switching and or by executing or simulating threads in parallel on independent cores or processors .

Furthermore in many embodiments the memory order tester can perform operations and for multiple different threads at the same time during testing. For example the memory order tester can simulate and or execute the first thread based on the first thread s view of memory referred to as the first thread s memory space which is then used to modify a second memory space being processed by the second thread. While this is taking place the memory order tester can cause the first thread s memory space to be modified based upon the memory order tester s execution or simulation of another thread. In other words the first thread s own memory space can also be modified e.g. according to operation in an incoherent manner based upon one or more other threads at the same time as the first thread is being used to modify a memory space that will be or is being processed by other threads.

In some embodiments as noted above the first set of program instructions is instrumented by the memory order tester creating an instrumented set of program instructions. In such embodiments another thread s memory space can be modified by executing the instrumented set of program instructions. For example the instrumented set of program instructions can include instructions that track the results generated by executing a portion of the first set of program instructions. After that portion of the first set of program instructions is executed selected portions of the results identified by the instrumentation instructions can be applied to another thread s memory space e.g. upon detection of a thread switch by the memory order tester effectively delaying from the other thread s perspective certain instructions within the thread.

In one embodiment instrumentation is done using software such as Purify available from IBM Corporation of Armonk N.Y. The instrumentation software such as Purify can instrument a set of instructions by modifying existing instructions rearranging existing instructions and or inserting new instructions into the set. Instrumentation using such software can also involve recalculating offsets or similar information used to refer to different portions of the program under test which may be changed by the instrumentation process and updating other code possibly including code outside of the particular set of instructions being instrumented based upon those recalculated offsets or other information. The memory order tester can incorporate all or part of the functionality of Purify or other appropriate instrumentation software . Alternatively the memory order tester can be configured to interact with e.g. via an application programming interface API such software in order to invoke the appropriate functionality of the software on the portion of the program under test to be instrumented.

Similarly another instrumentation technique can involve using a dynamic binary instrumentation DBI framework such as Valgrind which is an open source DBI framework available for Linux. Valgrind produces shadow values which are values that shadow all memory values generated by a program under test with information describing those memory values. The memory order tester can include or be configured to interact with a dynamic binary analysis tool that is based upon Valgrind or a similar DBI framework. The dynamic binary analysis tool is configured to dynamically instrument and simulate a portion of a program under test in order to create shadow values for each memory value generated by that portion of the program under test. Such shadow values can include the results generated by execution of certain instructions information e.g. timestamps indicating when various results were generated relative to each other and the like.

These shadow values can then be used by the memory order tester to modify another thread s memory space based on the actual results generated by the thread e.g. by applying some but not all of the results to the other thread s memory space and or by delaying application of selected ones but not all of the results to the other thread s memory space . For example at a particular time e.g. when a thread switch is detected the shadow values can be used to select certain results to be applied to another thread s memory space and other results to be delayed or omitted from modifying the other thread s memory space based upon when each result was generated e.g. some earlier results can be omitted such that preexisting values of the variable s included in the results are included in the incoherent memory snapshot . Alternatively the dynamic binary analysis tool can be configured to generate shadow values that will themselves be applied to the other thread s memory space.

In other embodiments instead of using instrumentation execution of the first set of program instructions is simulated in a manner that causes operation to be performed. For example the memory order tester can access individual instructions within the thread and simulate the results that would be generated if the instructions executed in an order other than their configured execution order. Looking back at for example the memory order tester could identify the two instructions that write values to memory and then generate an incoherent memory snapshot representing results that would be generated if the second instruction executed before the first instruction and the first instruction had not yet been executed. Once the memory order tester has used simulation to generate an incoherent memory snapshot based upon instructions in one thread the memory order tester can then simulate the execution of one or more other threads based upon the values in the incoherent memory snapshot. The memory order tester can switch back and forth between threads generating new incoherent snapshots each time.

In yet other embodiments the memory order tester virtualizes the memory space for each thread such that each thread explicitly sees a unique and independent virtual memory space e.g. a different page of virtual memory can be assigned to each thread . In one embodiment the memory virtualization is implemented by executing the program under test in a virtual non uniform memory architecture vNUMA such that each thread sees an at least somewhat independent memory space.

When testing using virtualized memory space the memory order tester can execute or simulate execution of instructions in a thread and cause that thread to store results in its associated virtual memory space. As a thread is being executed or simulated the memory order tester can modify the results in a manner that reflects what would have happened if the instructions in the thread had executed in a different order e.g. if some of the instructions had not been executed and or if the order of the instructions had been rearranged and store the modified results in another virtual memory space. The memory order tester can cause this other virtual memory space to be processed by another thread.

To effect this the memory order tester can for example create the second virtual memory space on the fly e.g. by applying some but not all of the first thread s writes to the second virtual memory space as those writes occur while also delaying at least some of the first thread s writes from being applied to the second virtual memory space . When a thread switch from the first thread to a second thread is detected the memory order tester can cause a memory manager to switch from pointing to the first virtual memory space storing the results that are coherent with respect to the first thread to the second virtual memory space which is the modified memory space such that the second thread will use the second virtual memory space during execution.

In other alternative embodiments the other thread s memory space is modified by write protecting all or part of the first thread s memory space. For example in some embodiments the first thread s memory space is write protected such that results generated by the thread cannot be written to the memory space without invoking a fault handler. The fault handler logs all of the writes and tracks the order in which they occurred and ultimately applies those writes in order to the first thread s memory space. The memory order tester can access the information in the fault handler s log and use that information to modify another thread s memory space e.g. by delaying some logged writes applying writes in a different order than which those writes were logged and the like 

In one embodiment the memory order tester can include these fault handlers e.g. for use if the memory order tester is simulating execution of the program under test . In other embodiments these fault handlers are independent of the memory order tester. In those embodiments the memory order tester can access the fault handlers log information via an API or other interface.

A determination as to whether the multi threaded program is operating correctly can be made as shown at . In particular if the program operates correctly even when one or more thread is simulated or executed dependent upon the modified memory space generated at no memory order error is detected as shown at . If instead some of the threads generate incorrect results or otherwise perform in an undesirable manner a potential memory order error is detected as shown at .

In some embodiments operation may not be performed by the memory order tester instead a user e.g. a person or other application may independently analyze the results generated by the program under test during the testing process to make this determination. Performing this operation can involve comparing expected results or simulated results e.g. generated by simulating or executing the program under test in a normal manner without performing operation to the results that are generated during the testing process when operation is performed . If differences are detected between the two sets of results a potential memory order error can be detected.

The operations of may in some situations be combined or reordered. For example in some embodiments that generate the incoherent memory snapshot using a DBI framework operations and may be significantly combined.

Additional operations can also be performed instead of and or in addition to those shown in . For example the memory order tester also save information identifying how another thread s memory space was modified based upon the execution or simulation of the first thread. For example the memory order tester can track which instructions were effectively delayed e.g. by delaying application of results generated by those instructions to the other thread s memory space by storing information identifying those instructions. Similarly the memory order tester can track the relative order of certain instructions based on when results written by those instructions were applied to another thread s memory space. The memory order tester can also track when certain results were applied to a thread s memory space e.g. in response to performance of operation relative to the order in which instructions within that thread read from the thread s memory space. If the order of certain instructions is effectively rearranged relative to the configured execution order details of the rearrangement can be stored e.g. indicating that one particular instruction was executed before another in contrast to the configured execution order of those instructions . Information such as this can be used to pinpoint misbehaving code if a memory order error is detected.

Executing the program instructions or modified program instructions can be done in an environment e.g. having multiple processors or multiple cores in each of one or more processors that supports simultaneous threads of execution. In such environments the memory order tester may be configured to control testing e.g. through the insertion of instrumentation instructions such that certain threads are occasionally paused or halted at a certain point e.g. to allow the memory order tester to modify another thread s memory space based upon the results generated by the thread prior to being paused and or to delay execution of a certain set of instructions within a thread until the memory order tester has modified that thread s memory space according to operation .

Other environments may emulate an environment that supports multiple simultaneous threads of execution through the use of thread switches. For example multiple threads can execute on a processor having a single core or a simulated processor such as that provided by a Valgrind based dynamic binary analysis tool . At various points during the execution of a particular thread some of which may be selected by the memory order tester and controlled using instrumentation control can switch to another thread. As described above in some such embodiments the memory order tester can redirect a memory manager at each such thread switch such that each thread processes a memory space that is incoherent with respect to at least one other thread.

In order to test multiple threads the memory order tester may be configured to perform several tests either in parallel or in series. For example in one embodiment the memory order tester is configured to perform operations and for all threads in the same test case.

In alternative embodiments in a given test case the memory order tester performs operations and for fewer than the total number of threads in the program under test. As an example the memory order tester may only perform operations and for one thread per test case.

Interface can include a network interface to various networks and or interfaces to various peripheral buses. Interface can also include an interface to one or more storage devices e.g. storage device user I O devices e.g. such as monitors or displays keyboards and the like and the like.

In this example program instructions and data executable to implement all or part of memory order tester including user interface access module and snapshot generator are stored in memory . In general memory order tester is configured to test a multi threaded program such as program under test in a manner that reveals memory order errors within the program such revealed errors can be detected by the memory order tester or by a user of the memory order tester . Program under test includes a first program instruction set and a second program instruction set . Each program instruction set includes instructions that are configured to execute in a single thread. Additional program instruction sets not shown can also be included in the program under test.

User interface of memory order tester can provide a command line interface CLI application programming interface API e.g. if memory order tester is configured to provide add on functionality to a preexisting testing application and or graphical user interface GUI . User interface is configured to provide an interface that allows a user e.g. a person or application to select a program under test initiate testing and or configure testing in embodiments in which multiple testing configurations and or methodologies are provided . Information representing the user selected configuration if any can be stored as part of test results and configuration on a persistent storage media such as storage device . User interface can also return test results e.g. stored on a persistent storage media such as storage device to the user e.g. via a display device .

In response to user selection of a program under test and a user initiating testing of the selected program under test access module obtains a copy of the selected program. For example access module can obtain a copy of all or part of program under test from a storage device such as storage device and load that copy into memory .

Memory space modifier is configured to generate an incoherent view of shared memory space for at least one thread during the testing process. This incoherent view of shared memory space is stored in a memory space that is processed by one thread and is incoherent with respect to another thread. The incoherent view of shared memory space at some point in time during performance of the test case represents results that would be generated if the other thread were executed in an order other than its configured execution order. If the program under test is a compiled executable the configured execution order can be the order generated by a compiler for example which may reorder certain instructions relative to the order in which those instructions appear in the original source code. Alternatively if the program under test is contains source code the configured execution order can be the order in which the instructions appear in the source code. Memory space modifier can use a variety of different techniques such as those described above to modify one thread s memory space based upon another thread. It is noted that there may be significantly more than two threads in the program under test and thus a single modified memory space can be processed by and or modified based upon more than one other thread.

In one embodiment memory order tester performs testing by simulating execution of the program under test. For example memory space modifier and or all or part of access module can be implemented using a DBI framework such that accessing the program under test involves dynamically instrumenting the program under test and modifying the memory space involves simulating execution of the instrumented program under test. In such an embodiment memory space modifier controls the simulation in a manner that will modify one thread s memory space in an incoherent manner based upon the simulation of instructions in another thread.

In alternative embodiments memory order tester performs testing by monitoring execution of the program under test. The program being executed may be a modified e.g. instrumented version of the original program under test.

Memory space modifier can store information identifying the order in which various instructions within the program under test effectively execute relative to each other e.g. as part of test results and configuration . For example memory space modifier can delay applying a result generated by instruction 1 in thread 1 to thread 2 s memory space such that instruction 1 s result is applied to thread 2 s memory space subsequent to execution of instruction 2 in thread 2. In this situation instruction 1 effectively executes after instruction 2. Memory space modifier can store information identifying instructions as well as information e.g. timestamps indicating when those instructions were effectively executed relative to each other.

Memory space modifier can in some embodiments interact with a memory manager in order to redirect the memory manager access a memory fault handler s log and or write protect certain regions of memory space as described above. Such functionality can be included in both embodiments that execute the program under test or an instrumented version of the program under test and embodiments that simulate execution of the program under test or an instrumented version of the program under test .

Memory order tester can also monitor the results generated by one or more of the threads through either monitoring simulation or execution of those threads when those threads are tested and store that information e.g. as part of test results and configuration for later use in analyzing the program under test. These results can also or alternatively be presented to a user allowing the user to determine whether memory order errors have occurred. Alternatively memory order tester can compare the results generated during testing to known good results e.g. as stored in a file and specified by user input received via user interface or as determined by executing or simulating the program under test without using memory space modifier to create incoherent views of the shared memory space . Based upon whether the results generated during testing match the known good results memory order tester can determine whether potential memory order errors have occurred.

The program instructions and data implementing memory order tester can be stored on various computer readable storage media such as memory . In some embodiments such software is stored on a computer readable storage medium such as a Compact Disc CD Digital Versatile Disc DVD hard disk optical disk tape device floppy disk and the like. In order to be executed by processor the instructions and data implementing memory order tester can be loaded into memory from the other computer readable storage medium. The instructions and or data implementing memory order tester can also be transferred to computing device for storage in memory via a network such as the Internet or upon a carrier medium.

Although the present invention has been described in connection with several embodiments the invention is not intended to be limited to the specific forms set forth herein. On the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims.

