---

title: Executable template
abstract: Systems, methods, and other embodiments associated with executable templates are described. One example method includes generating an executable template from a set of template data. When an executable template is executed, the executable template creates one or more instantiated entities. These instantiated entities may then be combined with entities created from portions of the original template that were not compilable into the executable format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321846&OS=08321846&RS=08321846
owner: Oracle International Corporation
number: 08321846
owner_city: Redwood Shores
owner_country: US
publication_date: 20081113
---
A template is a blueprint for creating a new entity. A template captures a frequently used pattern facilitating uniformity and best practice enforcement across entities created using the template. For example a template may allow a user to quickly generate a new document file data structure web page and so on without having to rebuild commonly used elements from scratch. In another example best practice solution patterns designed by an expert may be captured in templates and reused in projects aiding in best practice enforcement and making the expert s knowledge available to multiple projects in the expert s domain of specialization.

The process of creating a new entity using a given template is called template instantiation. Conventional approaches to instantiation include template interpretation approaches that include retrieving a serialized representation of the template parsing the serialized representation and traversing the in memory intermediate representation while calling appropriate high level system specific middle tier APIs to generate the required entities. As a result template interpretation approaches may incur repeated template retrieval and parsing costs for each instantiation operation because the template is loaded to the middle tier and parsed each time the template is instantiated. Additionally as the middle tier may make multiple database calls and service calls multiple round trips and cycles of processing may be required to complete a request. Therefore memory and processing requirements for template instantiation may be high and response time may be degraded due to the number of operations performed by the middle tier when a template is instantiated in the conventional manner.

Referring first to a prior art technique for template instantiation is illustrated that uses an interpretation process. Typically when a template is instantiated in response to a request a serialized representation of the template e.g. an XML document is fetched from a template data store to a middle tier between the data store and an entity requesting the instantiation. The serialized representation may then be parsed by a parser into an in memory intermediate representation e.g. a Java Content Tree . This intermediate representation is used to determine which if any services are needed to instantiate the template. The intermediate representation is also used to determine what if any data from a database is required to complete the instantiation request. The middle tier traverses the intermediate representation and makes the required service calls and database calls to create entities specified in the template. These calls may include calls to a time management service TMS a user directory service UDS and other services. This interpretation process is performed each time instantiation of the template is requested resulting in significant overhead in terms of memory and processing requirements and response time degradation.

Systems and methods associated with executable templates are described. In one example embodiment a template is compiled a single time into an executable template by a middle tier server when it is initially created. In one example embodiment the template is compiled into a PL SQL procedural language structured query language procedure. The executable template is stored to a template data store on a data server. The data server may also have access to multiple local databases and request resources from multiple local services.

When a middle tier server attempts to instantiate on behalf of an entity a template for which an executable template exists the executable template makes calls to local databases and services to create the requested instantiated entities. The instantiated entities are provided back to the middle tier server. The middle tier server may then be able to provide the instantiated entities back to the entity that requested the template instantiation without further requests to the data server or other system resources. Invoking an executable template in this manner on a data server may free up network resources as fewer middle tier to database requests are made. Further if the template is constructed locally on the data server this may free up resources on middle tier servers. In network architectures where bandwidth and middle tier processing resources are scarce freeing up network and middle tier resources in this manner may improve performance.

In another example embodiment it may not be possible to compile some portions of the template into an executable template. This may occur when a service required to instantiate an entity specified in the template is not available via an application programming interface API in the target language in which the executable template is generated e.g. if the target language is PL SQL and there is no PL SQL API for creating the specified entity . In this example embodiment the compilable portions of the template are separated from portions of the template that are non compilable. This separation process may include identifying a non compilable portion of a template as well as any descendants of the identified portion as non compilable. An executable template containing compilable portions of the template and a serialized representation containing non compilable portions of the template are created.

When the middle tier server requests instantiation of a template containing both a non compilable portion and a compilable portion the middle tier server invokes an executable template as described above. The middle tier server also loads a serialized representation into memory and performs actions and or makes requests associated with the non compilable portion of the template. The middle tier server then combines the results of the actions and requests e.g. instantiated entities associated with the non compilable portion with the instantiated entities that resulted from the execution of the executable template. The middle tier then returns a handle to the instantiated entities to a requesting entity. Thus the compilable portions of the template are processed in the improved manner providing the benefit of lower processing overhead and improved response time to the extent possible.

The following includes definitions of selected terms employed herein. The definitions include various examples and or forms of components that fall within the scope of a term and that may be used for implementation. The examples are not intended to be limiting. Both singular and plural forms of terms may be within the definitions.

References to one embodiment an embodiment one example an example and so on indicate that the embodiment s or example s so described may include a particular feature structure characteristic property element or limitation but that not every embodiment or example necessarily includes that particular feature structure characteristic property element or limitation. Furthermore repeated use of the phrase in one embodiment does not necessarily refer to the same embodiment though it may.

 Computer component as used herein refers to a computer related entity e.g. hardware firmware software in execution combinations thereof . Computer components may include for example a process running on a processor a processor an object an executable a thread of execution and a computer. A computer component s may reside within a process and or thread. A computer component may be localized on one computer and or may be distributed between multiple computers.

 Computer communication as used herein refers to a communication between computing devices e.g. computer personal digital assistant cellular telephone and can be for example a network transfer a file transfer an applet transfer an email an HTTP transfer and so on. A computer communication can occur across for example a wireless system e.g. IEEE 802.11 an Ethernet system e.g. IEEE 802.3 a token ring system e.g. IEEE 802.5 a LAN a WAN a point to point system a circuit switching system a packet switching system and so on.

 Computer readable medium as used herein refers to a medium that stores signals instructions and or data. A computer readable medium may take forms including but not limited to non volatile media and volatile media. Non volatile media may include for example optical disks magnetic disks and so on. Volatile media may include for example semiconductor memories dynamic memory and so on. Common forms of a computer readable medium may include but are not limited to a floppy disk a flexible disk a hard disk a magnetic tape other magnetic medium an ASIC a CD other optical medium a RAM a ROM a memory chip or card a memory stick and other media from which a computer a processor or other electronic device can read.

In some examples database is used to refer to a table. In other examples database may be used to refer to a set of tables. In still other examples database may refer to a set of data stores and methods for accessing and or manipulating those data stores.

 Data store as used herein refers to a physical and or logical entity that can store data. A data store may be for example a database a table a file a data structure e.g. a list a queue a heap a tree a memory a register and so on. In different examples a data store may reside in one logical and or physical entity and or may be distributed between two or more logical and or physical entities.

 Logic as used herein includes but is not limited to hardware firmware software in execution on a machine and or combinations of each to perform a function s or an action s and or to cause a function or action from another logic method and or system. Logic may include a software controlled microprocessor a discrete logic e.g. ASIC an analog circuit a digital circuit a programmed logic device a memory device containing instructions and so on. Logic may include one or more gates combinations of gates or other circuit components. Where multiple logical logics are described it may be possible to incorporate the multiple logical logics into one physical logic. Similarly where a single logical logic is described it may be possible to distribute that single logical logic between multiple physical logics.

An operable connection or a connection by which entities are operably connected is one in which signals physical communications and or logical communications may be sent and or received. An operable connection may include a physical interface an electrical interface and or a data interface. An operable connection may include differing combinations of interfaces and or connections sufficient to allow operable control. For example two entities can be operably connected to communicate signals to each other directly or through one or more intermediate entities e.g. processor operating system logic software . Logical and or physical communication channels can be used to create an operable connection.

 Query as used herein refers to a semantic construction that facilitates gathering and processing information. A query may be formulated in a database query language e.g. SQL an OQL a natural language and so on.

 Signal as used herein includes but is not limited to electrical signals optical signals analog signals digital signals data computer instructions processor instructions messages a bit a bit stream and so on that can be received transmitted and or detected.

 Software as used herein includes but is not limited to one or more executable instruction that cause a computer processor or other electronic device to perform functions actions and or behave in a desired manner. Software does not refer to stored instructions being claimed as stored instructions per se e.g. a program listing . The instructions may be embodied in various forms including routines algorithms modules methods threads and or programs including separate applications or code from dynamically linked libraries.

 User as used herein includes but is not limited to one or more persons software logics computers or other devices or combinations of these.

To the extent that the terms contain store and so on are employed herein e.g. a data store to store a value a signal containing a datum it is intended to mean that a portion of memory associated with the storing element either holds the stored element or that a value in a portion of memory associated with the storing element identifies memory holding the stored element. Further in the latter example the portion of memory associated with the storing element may hold an identifier e.g. a pointer directly indicating a portion of memory containing the stored element or the portion of memory associated with the storing element may hold an identifier indicating a data structure that holds the stored element.

Some portions of the detailed descriptions that follow are presented in terms of algorithms and symbolic representations of operations on data bits within a memory. These algorithmic descriptions and representations are used by those skilled in the art to convey the substance of their work to others. An algorithm here and generally is conceived to be a sequence of operations that produce a result. The operations may include physical manipulations of physical quantities. Usually though not necessarily the physical quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a logic and so on. The physical manipulations create a concrete tangible useful real world result.

It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers and so on. It should be borne in mind however that these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise it is to be appreciated that throughout the description terms including processing computing determining and so on refer to actions and processes of a computer system logic processor or similar electronic device that manipulates and transforms data represented as physical electronic quantities.

Example methods may be better appreciated with reference to flow diagrams. For purposes of simplicity of explanation the illustrated methodologies are shown and described as a series of blocks. However it is to be appreciated that the methodologies are not limited by the order of the blocks as some blocks can occur in different orders and or concurrently with other blocks from that shown and described. Moreover less than all the illustrated blocks may be required to implement an example methodology. Blocks may be combined or separated into multiple components. Furthermore additional and or alternative methodologies can employ additional not illustrated blocks.

Referring now to a method associated with executable templates is illustrated. Method includes at receiving a set of template data. In one example embodiment the template data may be received upon creation of the template from a user and or a logic. The template data may be for example a web page template a project management workspace template a document template a new product launch template and so on. Thus the template data specifies parameterized information about the structure and content of the entities that are created when the template is instantiated. The template may also contain template variables whose values are passed at the time of template instantiation.

Method also includes at compiling the set of template data into an executable template. The executable template may be for example compiled into a procedural language structured query language PL SQL procedure. However a person having ordinary skill in the art can see how a different executable format may be appropriate. Method also includes at storing the executable template in a data store. The data store may be associated with a data server containing multiple data stores. One of the data stores may be a relational database. Further services referenced by the template data may operate on the data server. Thus in one example embodiment an executable template may be configured to execute on the data server. In this example embodiment the executable template is configured to call local services and may make local database queries. The executable template may also be configured to combine results of these service requests and database queries to create the instantiated entities that the executable template generates.

While illustrates various actions occurring in serial it is to be appreciated that various actions illustrated in could occur substantially in parallel. By way of illustration a first process could receive template data a second process could compile an executable template and a third process could store the executable template. While three processes are described it is to be appreciated that a greater and or lesser number of processes could be employed and that lightweight processes regular processes threads and other approaches could be employed.

In one example a method may be implemented as computer executable instructions. Thus in one example a computer readable medium may store computer executable instructions that if executed by a machine e.g. processor cause the machine to perform a method. While executable instructions associated with the above method are described as being stored on a computer readable medium it is to be appreciated that executable instructions associated with other example methods described herein may also be stored on a computer readable medium.

Method includes at determining whether the template data references a non compilable action. A non compilable action may include a service call that is not available via an application programming interface API in the target language in which the executable template is generated.

In the event that no non compilable actions are found the template data may be compiled into an executable template at as in method see . However if it is determined that the template data specifies a non compilable action method may proceed by generating a serialized representation at . In one example a serialized representation may be an extensible markup language XML document. However a person having ordinary skill in the art can see how other formats may be used for storing a serialized representation. Generating a serialized representation may include separating portions of the template data into compilable portions and non compilable portions. In one example embodiment a first portion of the template data that depends on a second non compilable portion of the template data may be treated as a non compilable portion even if the first portion may include elements that would otherwise be considered compilable. Thus non compilable portions of the template data and their descendants may be included in the serialized representation generated at and compilable portions of the template data may be compiled into an executable template at . Method also includes at storing the serialized representation and at storing the executable template.

Method also includes at providing an execution request signal for the executable template. The execution request signal may be provided to a data server on which the executable template is stored. The execution request signal controls the data server to execute the executable template. The executable template creates instantiated entities while the executable template is running. In one example embodiment the execution request signal may include the input received in the template instantiation request signal thereby facilitating the provision of the input to the executable template. Method also includes at receiving the instantiated entities. The instantiated entities may be for example a workspace that includes a folder and a task list. The instantiated entities are generated by execution of the executable template by the data server. Method also includes at providing the instantiated entities. For example a handle to the instantiated entities may be provided to for example a user and or a logic that initially requested execution of the executable template.

Method includes at determining whether the template instantiation request signal identifies a serialized representation in addition to an executable template. In the event that the template instantiation request signal does not identify a serialized representation method may proceed to providing the instantiated entities at as described in method see . However if method determines that the template instantiation request signal does identify a serialized representation method may proceed at by loading the serialized representation. In one example the serialized representation may be loaded by a middle tier template construction logic that may not be co located with a data server. The serialized representation may be for example an XML document.

Method also includes at initiating an action identified by the serialized representation. The action may be related to a service and or a resource that is not available via an application programming interface API in the target language in which the executable template is generated. Method also includes at adding a result of the action to the instantiated entities. While adding a result of the action to the instantiated entities is described one with ordinary skill in the art can see how adding a portion of the instantiated entities to the result may be advantageous in some situations.

Thus method and method relate to the construction of an executable template based on a set of template data. Method and method relate to the processing of requests for the instantiation of fully and partially executable templates respectively. Finally method relates to the conditions under which an executable template itself operates.

System also includes a compilation logic . In one example embodiment the compilation logic generates the executable template. The compilation logic may also store the executable template in the data store . The compilation logic generates the executable template in response to receiving a set of template data. The template data may include a non compilable portion and a compilable portion of data. Thus the compilation logic compiles the compilable portion into an executable template. The compilation logic may also generate a serialized representation of the non compilable portion.

System also includes an execution logic . The execution logic may request instantiated entities be created by execution of the executable template. The instantiated entities may be requested in response to a signal from a user and or a logic. In one example embodiment the execution logic may also load a serialized representation. The serialized representation may be loaded when the execution logic determines that a requested template requires information from both an executable template and the serialized representation to be complete. Thus the execution logic may also initiate an action identified by the serialized representation. Further the execution logic may add a result of the action to the instantiated entities generated by the executable template. The execution logic may then provide the instantiated entities. The instantiated entities may be provided as a handle to the instantiated entities to for example a user and or a logic that requested the execution of the executable template.

The example computing device may be a computer that includes a processor a memory and input output ports operably connected by a bus . In one example the computer may include a template logic configured to facilitate generating an executable template. In different examples the logic may be implemented in hardware software firmware and or combinations thereof. While the logic is illustrated as a hardware component attached to the bus it is to be appreciated that in one example the logic could be implemented in the processor .

Thus logic may provide means e.g. hardware software firmware for generating an executable template. Logic may also provide means e.g. hardware software firmware for executing an executable template. Logic may also provide means e.g. hardware software firmware for providing any instantiated entities that result from execution of an executable template. The means associated with logic may be implemented for example as an ASIC. The means may also be implemented as computer executable instructions that are presented to computer as data that are temporarily stored in memory and then executed by processor .

Generally describing an example configuration of the computer the processor may be a variety of various processors including dual microprocessor and other multi processor architectures. A memory may include volatile memory and or non volatile memory. Non volatile memory may include for example ROM PROM and so on. Volatile memory may include for example RAM SRAM DRAM and so on.

A disk may be operably connected to the computer via for example an input output interface e.g. card device and an input output port . The disk may be for example a magnetic disk drive a solid state disk drive a floppy disk drive a tape drive a Zip drive a flash memory card a memory stick and so on. Furthermore the disk may be a CD ROM drive a CD R drive a CD RW drive a DVD ROM drive a Blu Ray drive an HD DVD drive and so on. The memory can store a process and or a data for example. The disk and or the memory can store an operating system that controls and allocates resources of the computer .

The bus may be a single internal bus interconnect architecture and or other bus or mesh architectures. While a single bus is illustrated it is to be appreciated that the computer may communicate with various devices logics and peripherals using other busses e.g. PCIE 1394 USB Ethernet . The bus can be types including for example a memory bus a memory controller a peripheral bus an external bus a crossbar switch and or a local bus.

The computer may interact with input output devices via the i o interfaces and the input output ports . Input output devices may be for example a keyboard a microphone a pointing and selection device cameras video cards displays the disk the network devices and so on. The input output ports may include for example serial ports parallel ports and USB ports.

The computer can operate in a network environment and thus may be connected to the network devices via the i o interfaces and or the i o ports . Through the network devices the computer may interact with a network. Through the network the computer may be logically connected to remote computers. Networks with which the computer may interact include but are not limited to a LAN a WAN and other networks.

While example systems methods and so on have been illustrated by describing examples and while the examples have been described in considerable detail it is not the intention of the applicants to restrict or in any way limit the scope of the appended claims to such detail. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the systems methods and so on described herein. Therefore the invention is not limited to the specific details the representative apparatus and illustrative examples shown and described. Thus this application is intended to embrace alterations modifications and variations that fall within the scope of the appended claims.

To the extent that the term includes or including is employed in the detailed description or the claims it is intended to be inclusive in a manner similar to the term comprising as that term is interpreted when employed as a transitional word in a claim.

To the extent that the term or is employed in the detailed description or claims e.g. A or B it is intended to mean A or B or both . When the applicants intend to indicate only A or B but not both then the term only A or B but not both will be employed. Thus use of the term or herein is the inclusive and not the exclusive use. See Bryan A. Garner A Dictionary of Modern Legal Usage 624 2d. Ed. 1995 .

