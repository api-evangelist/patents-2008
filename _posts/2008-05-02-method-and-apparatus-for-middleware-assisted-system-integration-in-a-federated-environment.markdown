---

title: Method and apparatus for middleware assisted system integration in a federated environment
abstract: A computer implemented method, data processing system, and computer usable program code are provided for instantiating a service on a network. A service infrastructure manager determines whether a service is available at a requested quality of service in response to receiving a request for the service that specifies the quality of service. The service infrastructure manager performs an analysis of components associated with the service to identify resources needed to create the service in response to the service being unavailable at the requested quality of service. Based on the analysis, the service infrastructure manager allocates resources to support the service and instantiates the service at the requested quality of service after the resources have been allocated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945671&OS=07945671&RS=07945671
owner: International Business Machines Corporation
number: 07945671
owner_city: Armonk
owner_country: US
publication_date: 20080502
---
This application is a continuation of application Ser. No. 11 453 507 filed Jun. 15 2006 now U.S. Pat. No. 7 519 711.

The present application relates generally to networked computer systems. More particularly the present application relates to software and systems management in networked computer environments.

Enterprises are increasingly moving towards a grid based computing environment as they strive to contain information technology costs and streamline their businesses through outsourcing of non core business processes and sharing of distributed resources. The grid infrastructure is emerging to be a common platform for realizing such changes. The grid infrastructure provides middleware services for discovery naming messaging monitoring and resource brokering.

While grid based systems can facilitate resource sharing across multiple administrative domains grid based systems are much harder to manage from a system administration point of view. One reason for this is that the current state of the art in system management technology has not kept pace with the advances in middleware. Most of the progress has been in managing single or cluster based systems. Even for such systems system administrators face a much higher level of complexity when they have to configure and deploy a new service on an existing infrastructure or manage the lifecycle of the existing service and software stack. The situation is much worse in a complex application environment for example an environment involving orchestration of a workflow formed by multiple business processes. In such cases deployment and life cycle management solutions need to take an integrated view of the multiple tiers involved and current system management technologies do not provide the necessary means to build such solutions.

In a federated environment component services and resources belonging to multiple administrative domains cooperate and coordinate their activities so as to deliver a composite higher level service without violating policies corresponding to individual administrative domains. These federated systems are sometimes referred to as virtual organizations collective services on demand clusters agreement based cooperating systems and so on. A key characteristic of such systems is that individual components are not dedicated to provide their services to the organization for its entire lifetime but their commitment to provide the service is limited to a well defined period of time. Components are constituent elements that form the organizational grid. For example a component could be a physical box hardware an application server instance software or a firewall network .

Often times the individual components have the liberty to leave the virtual organization with or without prior notice. As a result the composite federated system must always be prepared to deal with the changes in the service levels offered by individual components as well as asynchronous availability and unavailability of the component services. Traditional system management controls that are designed for dedicated and static cluster based systems are not geared towards handling such dynamic and continuously evolving systems.

The ability to configure and manage large installations of systems has been an active area of research within the information technology community. The Local Configuration LCFG system is a script based system that dynamically configures machines based upon configuration information stored in a central database Anderson P. Towards a High Level Machine Configuration System LISA 1994 . The information pertains to network system and services that need to be configured on the system. Smart Framework for Object Groups SmartFrog is a system for specifying the configuration and deployment of distributed applications Goldsack P Guijarro J Mecheneau G Murray P Toft P SmartFrog Configuration and Automatic Ignition of Distributed Applications HP OVUA 2003 . SmartFrog provides a language to specify the configuration of applications and dependencies between them. SmartFrog provides an infrastructure for processing and deploying applications on the distributed systems. The GridWeaver project is exploring the notion of combining LCFG and SmartFrog technologies for configuration management of large systems. The Organization for the Advancement of Structured Information Standards OASIS effort is looking at managing distributed resources using Web services. The Grid Forum is attempting to standardize the specification language as part of the Configuration Description Deployment and Lifecycle Management CDDLM activity.

Some technologies provide means to monitor individual J2EE components that are participating in providing a service. The technology helps system administrators to monitor performance identify failures and check performance bottlenecks.

The different aspects of the illustrative embodiments provide a computer implemented method data processing system and computer usable program code for instantiating a service on a network. The illustrative embodiments receiving a request for the service at a quality of service and responsive to the request determine whether the service is available at the requested quality of service. Responsive to the service being unavailable at the requested quality of service the illustrative embodiments perform an analysis of components associated with the service to identify resources needed to create the service. Based on the analysis the illustrative embodiments allocate resources to support the service. Finally the illustrative embodiments instantiate the service at the requested quality of service after the resources have been allocated.

The illustrative embodiments provide middleware that monitors the state of the individual services and automatically triggers the redeployment of components and services to other systems. Service is a unit of activity performed by a compute element. For example a service could be one that adds two numbers or one that processes a mortgage loan application. A service is typically exposed as a Web service or a remote procedure call for others to invoke and use. With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which aspects or embodiments may be implemented. Many modifications to the depicted environments may be made without departing from the spirit and scope of the illustrative embodiments.

With reference now to the figures depicts a pictorial representation of a network of data processing systems in which aspects of the illustrative embodiments may be implemented. Network data processing system is a network of computers in which embodiments may be implemented. Network data processing system contains network which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . These clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for different embodiments.

With reference now to a block diagram of a data processing system is shown in which aspects of the illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable code or instructions implementing the processes for embodiments may be located.

In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub MCH and a south bridge and input output I O controller hub ICH . Processor main memory and graphics processor are coupled to north bridge and memory controller hub . Graphics processor may be coupled to the MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter is coupled to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB ports and other communications ports and PCI PCIe devices are coupled to south bridge and I O controller hub through bus and hard disk drive HDD and CD ROM drive are coupled to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be coupled to south bridge and I O controller hub .

An operating system runs on processor and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both .

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor . The processes of the illustrative embodiments may be performed by processor using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

The hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is generally configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors or CPUs. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

The aspects of the illustrative embodiments provide for a computer implemented method apparatus and computer usable program code for compiling source code. The methods of the illustrative embodiments may be performed in a data processing system such as data processing system shown in or data processing system shown in .

The illustrative embodiments instantiate a service on a network. A request is received that requests service at a particular quality of service. Analysis is performed of the components associated with the service to identify resources needed to create the service in response to the service being unavailable at the requested quality of service. Using this analysis resources are allocated to support the service and the service is instantiated at the requested quality of service after the resources have been allocated.

Data center may provide raw resources operating system stack and common middleware services to run applications and application specific middleware services. Data center may provide resources and services that can be configured according to requirements of the higher level services and applications used in enterprises and . Data center is typically used when an enterprise or runs out of resources to handle peak load. During these times enterprise or may request additional resources from data center and divert some of enterprise or s workload to data center . Data center may also host the applications and provide the necessary supporting services and resources. The illustrative embodiments use the term supporting services to illustrate service components on which one or more other components may depend upon to deliver their service.

Service infrastructure manager embodies the illustrative embodiments. Service infrastructure manager is responsible for determining if the requested service is running in the grid environment at the capacity level desired by the client request. If the service is not running at all or running at a sub par level then the mechanisms within service infrastructure manager initiate steps leading to configuration allocations deployments and testing unit and integration tests of components that together compose the necessary service to process the requested service at a desired performance level before the request is passed by mediation service to target service .

The functions performed by service infrastructure manager ensure that by the time the requested service is processed by mediation service and arrives at target service target service is ready and capable of providing service at the desired performance level for the client request. Also the functions performed by service infrastructure manager ensure that 1 client requests are not dropped due to the absence of a service and 2 adequate capacity is provisioned before the client request is processed. The request is then forwarded via mediation service to target service on outbound port . Outbound port is connected through port destination to Web service implementation that processes the request. The reply to the request is returned through the reverse path as it was received.

Service state and configuration repository is a core component of service infrastructure manager . Each deployable and deployed service is represented as an object in service state and configuration repository . In these examples each object has four parts 

When a new service component is to be deployed and enabled a new service instance object is instantiated in service state and configuration repository . The service instance represents the actual service instance to be configured and deployed in the system. Additionally when a new functionality is to be enabled in an already enabled service the corresponding service instance object is updated to reflect this new functionality to be enabled. Similarly if the delivered level of service performance is to be modified the existing service instance object is modified to reflect this desired level of performance. In all cases the corresponding service instance objects are assigned a state called a desired state. The state is desired in the actual service instance represented by this object to achieve the desired effect. Also represented in this object is the current observed state of the service instance. If the observed state of the service instance does not match with the desired state then the object is flagged for additional processing within service infrastructure manager .

A flagged object in service state and configuration repository is first processed by analysis and planning engine . Analysis and planning engine performs dependency analysis and generates a dependency graph. Using this dependency graph analysis and planning engine may enable the service instance to its desired state. Analysis and planning engine then examines service state and configuration repository to determine if any of the existing components may be used to realize the dependency graph. When components do not exist new instance objects are created in service state and configuration repository . The desired state of the existing and newly created instance objects is set to reflect the new demand placed in the said dependency graph. The demands are then recursively analyzed and planned for by analysis and planning engine .

Analysis and planning engine first evaluates the dependency graph in a top down manner to determine the actual instances associated with the objects in service state and configuration repository . After the dependency graph is evaluated analysis and planning engine performs a bottom up evaluation to configure and deploy each component to its desired state.

In the first phase components in the dependency graph are evaluated in a top down manner. For each component with unfulfilled supporting resources requests are sent to resource and service broker engine with description of the type of service or resource requested along with the desired and necessary attributes. The requests include both functional and performance attributes.

Resource and service broker engine analyzes multiple requests for component resources and services and comes up with a decision to fulfill the requests taking into account existing resource and service specific and system wide policies priorities and preferences. The solution provided by analysis and planning engine consists of lower level components from which a service configuration graph may be constructed. Analysis and planning engine constructs a dependency graph that is written into a service configuration section of the object being restored. The allocation and matching decisions provided by analysis and planning engine meet the criteria specified in the received request. When a request cannot be fulfilled analysis and planning engine holds on to the request until necessary resources and services become available or until the request is cancelled by the requestor. Depending on the nature of the dependency graph and the components returned by resource and service broker engine additional requests may be sent to resource and service broker engine so that each component in the dependency graph has a physical resource or service instance associated with the component.

The dependency graph is then evaluated in a bottom up manner to configure and deploy each component to its desired state. Configuration engine examines the allocated services and instances in a bottom up manner along with the dependencies and the associated state information both observed and desired. Using this information configuration engine generates the configuration description for each service instance in the dependency graph. It takes into account the configuration and level of service to be provided by the lower level service instances in the dependency graph and the level of service to be provided to the supported services at the next level up in the dependency graph. Configuration engine generates a configuration dependency graph that describes the order in which the component services and resources are to be deployed and configured. The configuration dependency graph is also stored in the configuration and deployment section part of the corresponding object and is used by deployment engine .

Next deployment engine uses the configuration dependency graph and the allocated resource service instances to actually configure and deploy the service instance so the dependency graph can be realized using resources and . Deployment engine uses the information provided in the service objects and the configuration dependency graph to create and execute workflows to provision resources and service instances to their desired state. Deployment engine also performs unit and integrity tests on the provisioned and configured services. For each resource deployment engine uses the configuration dependency graph to initiate the installation and configuration of services and on the designated resources. Services and running on resources and constitute the Web service implementation such as Web service implementation of .

The progress of the installation and configuration is continuously monitored by monitoring engine . Monitoring engine is responsible for updating the status of each representative object in service state and configuration repository . If a failure is encountered during unit or integrity testing then the workflow restarts by performing recovery actions which may include acquiring a new set of resources. In the case of a high level service after all the resources have been configured deployment engine notifies service infrastructure manager to enable the service.

A configuration engine determines configuration steps for each allocated and brokered component so they can provide the necessary supporting service at the desired performance level step . The deployment engine determines installation and deployment steps and executes those steps step . After the dependency graph is realized in a bottom up manner and after performing a functional verification test FVT on the service requested by the end user deployment engine sends back the confirmation to a mediation service to indicate the availability of the service step with the operation ending thereafter.

The deployment engine then retrieves the installation workflow for the dependent components that are yet to be installed and prepares for installation step . The installation workflow for each component is stored as a Business Process Execution Language BPEL workflow in the service state and configuration repository. The deployment engine then executes the actual installation steps for the service component to be deployed step . If any exceptions are notified the exceptions are caught and when possible corrective actions are taken or alternative deployment actions are applied. If a corrective action is not possible then the deployment process is aborted and the exception is recorded in the service state and configuration repository associated with the service object that gave rise to the exception.

After the installation of the components is successfully completed the service infrastructure manager retrieves the configuration information from the object dependency graph for each component and initiates configuration operation for each component step . For example the configuration operation for the WebSphere server includes installation of the enterprise archive EAR files for the service and setting up any runtime parameters associated with the corresponding Enterprise Javabeans EJB . Similarly the DB2 client is configured to bind to the data source that stores information about the payment transactions. The deployment engine may perform installation of all supporting components followed by their configuration as described above. In another embodiment it may install and configure one component and then move to the next component. In another embodiment it may install and configure several components simultaneously and then move to the next group of components.

After the installation and deployment of all components in the object dependency graph is complete step the deployment engine starts a loop process of performing functional verification tests on the components step . The deployment engine performs a unit test of each installed component step . The scripts for the unit test are stored in the object dependency graph for each component. As an example the unit test for WebSphere application server is to check if the application server hosting the service is up. For a HyperText Transfer Protocol HTTP server one unit test is to check if the request sent to port returns successfully. With a DB2 client one unit test is to check the connectivity of the client with the data source server.

After successful completion of the unit tests the unit testing ends step deployment engine performs one or more incremental functional verification tests on the deployed service components step . This includes testing successful interactions among components forming sub trees in the object dependency graph. The scripts for the functional verification test are stored with each object in the service state and configuration repository representing a service component in the object dependency graph. After successful completion of the functional verification tests in step the deployment engine marks the service as enabled step with the operation ending thereafter.

In the embodiments described within unit tests are performed on all deployed and configured components and this is followed by a suite of functional verification tests. In another embodiment deployment configuration and unit tests of one component may be performed before the next component is installed. In another embodiment some of these activities may be performed in parallel and other actions may be pipelined. These actions include functional verification tests on sub trees of the object dependency graph.

Thus the illustrative embodiments provide for instantiating a service on a network. Upon receiving a request for a service at a particular quality of service a determination is made as to whether the service is available at the requested quality of service. In response to the service being unavailable at the requested quality of service an analysis is performed of components associated with the service to identify resources needed to create the service and based on the analysis resources are allocated to support the service. Then the service is instantiated at the requested quality of service.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

