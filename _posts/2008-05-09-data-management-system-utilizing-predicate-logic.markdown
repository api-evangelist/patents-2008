---

title: Data management system utilizing predicate logic
abstract: A predicate logic corpus can be generated from any number of data sources or data stores. The creation of a predicate logic corpus for information such as metadata allows ascendancy, descendancy, relationship, hierarchical, contextual, and knowledge information to be stored for predicate logic facts generated from information in the data sources. The predicate logic corpus allows for queries to be executed against corpus logic facts in the corpus and in results sets of the corpus, allowing for iterative and complex natural language queries to be submitted and executed without a substantial drain on resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08180758&OS=08180758&RS=08180758
owner: Amazon Technologies, Inc.
number: 08180758
owner_city: Reno
owner_country: US
publication_date: 20080509
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present disclosure relates generally to among other things the generation maintenance and use of data metadata and or various data structures. As the amount of such information stored electronically continues to increase dramatically approaches for managing this increasing amount of data become evermore important. Data typically is stored in a data storage using a two dimensional approach with each item of data corresponding to a row in at least one table that includes entries in respective columns of information. The mapping or other linking between tables provides the ability for the data to be linked to various other data organizations classifications etc. The linking of various tables at different levels can thus produce a hierarchy of information relating to each stored data item. In order to attempt to provide some context for the data metadata can be stored that provides additional information for each stored data item. For example metadata might be used to associate a data item with one or more categories of data as well as to provide information about those categories.

In an environment such as an electronic marketplace for example a data store might contain an enormous amount of metadata about items offered through the marketplace including metadata for the types of items offered attributes of those items etc. Knowledge of that metadata typically is locked away into a fairly complex data store such that even though an extensive tool set can provide access to this metadata the view of the metadata is limited to a database orientation. In one example JAVA application programming interfaces APIs provide only a limited view of the system s knowledge of metadata as standard database queries are relatively limited and represent only unit level steps of the end user s query JAVA is a general purpose concurrent class based object oriented language . A user is able to navigate through the data hierarchy to find particular information such as item type and attributes for that item type. The user can view and update this information in a transactional fashion. The process does not obtain knowledge or context for the information being searched and only satisfies a series of queries by getting and setting various attributes. Further the process has to step through each transaction to obtain information about metadata and there is no way to otherwise execute a multi transactional query without stepping through each individual transaction. For example there is no simple way to obtain information for all item types under directly or indirectly a consumer electronics category which have a particular attribute set to a particular value.

Further the cost to develop and maintain these tools is high and most significantly the tools can only give brief glimpses into the data. Existing data stores can be huge unwieldy time and computationally expensive and still only provide a rather limited way to represent or express knowledge about the metadata itself without any way to prove the knowledge about the metadata.

Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more the aforementioned and other deficiencies experienced in conventional approaches to managing information in an electronic environment. The information can include or relate to any appropriate content desired to be stored electronically. As used herein the term content can refer to anything that can be displayed stored manipulated reported on analyzed or otherwise conveyed to a user such as through a graphical user interface GUI or programmatic interface in response to a request from the user or other entity. A request relating to the content can include any appropriate request sent through an appropriate system or network such as a request sent to an Enterprise server over a local area network LAN a request submitted via a Web page over the Internet or a message sent via a messaging system to a content provider for example.

The illustrative environment includes at least one application server and a data store . As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HTML for at least one Web page using hypertext transfer protocols. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein. Further the environment can be architected in such a way that a test automation framework can be provided as a service to which a user or application can subscribe. A test automation framework can be provided as an implementation of any of the various testing patterns discussed herein although various other implementations can be used as well as discussed or suggested herein.

The environment also includes a development and or testing side which includes a user device allowing a user such as a developer data administrator or tester to access the system. The user device can be any appropriate device or machine such as is described above with respect to the client device . The environment also includes a development server which functions similar to the application server but typically runs code during development and testing before the code is deployed and executed on the production side and is accessible to outside users for example. In some embodiments an application server can function as a development server and separate production and testing storage may not be used.

The data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data store illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing testing data which can be used with the user information for the testing side. It should be understood that there can be many other aspects that may need to be stored in the data store such as for page image information and access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server or development server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server can include an operating system that provides executable program instructions for the general administration and operation of that server and includes a computer readable medium storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

Aspects of the various embodiments can be utilized on the production side or the development side. These aspects also can be used in other environments where there may not be such a separation or where there may be other portions such as a dedicated test server not shown or other such devices. Arrangements for testing development and production code are known in the art and will not be discussed herein in detail.

A user in such an environment might want to obtain information from at least one data store that satisfies a complex question from a query standpoint. For example a user might want to submit a mental query or complex query in natural language such as 

A user interface to an application such as a metadata editor running on a client device would typically be the main tool for the end user to resolve this complex query. The query is not actually handled directly by the editor however as the editor instead executes a set of editor based transactions none of which are aware of any previous transactions as there is no persistence between individual transaction queries. A metadata management system for example thus cannot know what the end user is really attempting to discover but can only analyze the individual transaction queries as those queries are submitted by the editor. While such a metadata management system can effectively organize the data that is stored there is no way to obtain additional knowledge about the metadata. Although the arrangement of items into a hierarchy of product types for example provides some interrelation between the data this still provides only a rather limited way to represent or express knowledge about the metadata itself.

Various technologies exist that provide the mechanisms needed to derive and maintain knowledge about data and to prove facts and knowledge determined from the data. One such technology takes a predicate logic based approach using an artificial intelligence AI language such as Prolog Mandarax or LISP. For purposes of simplicity of explanation Prolog will be used in various examples presented herein but it should be understood that any other appropriate predicate logic or similar approach can be used as would be apparent to one of ordinary skill in the art in light of the teachings and suggestions contained herein.

A predicate logic approach can be used to define logic about a particular item and then ask for the probability of the logical conclusion. A predicate logic notation can be used that describes in an example for a data store including data and metadata for products in an electronic marketplace information such as product types and their properties product type hierarchies attributes and properties components valid values etc. Such notation can be used to create a predicate query which can be used with system counterparts such as application programming interface API calls and Structured Query Language SQL queries to obtain the knowledge in the system. In order to take advantage of predicate logic in various situations however it can be desirable to provide a way to build upon this knowledge beyond the atomic level concepts described above. In such cases it can be desirable to for example be able to save useful queries and transform these queries into building blocks allowing for higher level concepts that can then be used by other users.

The following provides a basic example of a knowledge base comprised of elemental facts representing family relationships. Each of the predicates below represents a fact known to the system 

In order to build such a predicate logic style knowledge base for metadata the facts about metadata are in some embodiments extracted from the tables of the data store and stored as discoverable facts. For example information such as product types attributes of product types and similar information can be queried from the data store and stored as facts according to a predicate logic inference engine to build a corpus or body of knowledge about metadata that then can be queried using a predicate style approach. A user interface also can be provided that allows for the evolution of a predicate logic based language about metadata. Users can create result sets of various metadata concepts such as may include product types product attributes components valid values and enumerated values. Users can compound knowledge beyond the elements of existing metadata concepts into more complex constructs and can utilize a notation to express complex queries against this knowledge. A set of predicate logic constraints then can be transformed into SQL database queries and result sets can be constructed that unify the query variables against the SQL results. In one embodiment a technology such as JAVA Server Faces JSF can be used to provide a user interface able to capture complex user queries and present both interim and final result sets. In other embodiments an open source framework such as Struts available from the Apache Software Foundation or a JAVA API such as Swing available from Sun Microsystems Inc. of Santa Clara Calif. can be used to create the user interface as part of a JAVA web application.

In order to better understand an implementation of such an approach the following notation and base axioms will be used to describe a knowledge base in accordance with one embodiment. An exclamation mark is a used to cut the search space following the previous unification. For example to unify Elemental X against Elemental attribute Y if X unifies attribute Y there is no need to attempt to unify X against productType component or any other yet to be determined elemental 

Once the existence of elementals is defined the knowledge of these elementals can be expanded by defining the properties that any of the elementals may possess. Thus 

The knowledge base thus derives the productTypeDescendant rule based on the productTypeRelation facts. So 

Using this basic set of logical components queries can be fashioned against the knowledge base. A sample query to find all shared attributes between typewriter and descendants of camera for example might turn into the following query where Attribute is the input parameter and Set is the query result 

Thus a rule mf camera rule set can be formalized to find all the shared attributes between typewriter and descendants of camera . Facts can be discovered by querying the data store and a result set can be obtained using rules such as productTypeDescendant described above. Users also are able to create and fashion their own rules which further can be saved and shared. Thus a very large scale language begins to take shape regarding how to describe and find data. A GUI front end can be provided that is built upon this predicate knowledge so that the users do not have to learn predicate logic but can instead build save and otherwise manipulate queries through a natural language interface.

Such an approach provides a representation that is expanded beyond the elemental database views of knowledge and enables users to formulate logical queries against the knowledge of metadata. Such knowledge queries can be differentiated from standard database queries in one aspect through the use of result sets. These result sets are collections of related data across various metadata entities such as product types attributes components valid values and every new construct introduced into the metadata environment.

The predicate logic inference engine which can be a JAVA program for example can be automated to generate the necessary inferences and mappings between standard data such as SQL tables and columns and predicate logic facts. The engine then can be used to extract the desired information from any appropriate data source and generate a predicate logic fact corpus. Further the inference engine can be used to determine updates or deltas to the data store for example and automatically update that information in the fact corpus in order to ensure synchronization therebetween. Methods for determining and scheduling update synchronization are known in the art and will not be discussed herein in detail.

As discussed one potential advantage of using a fact corpus is that users are able to query against the fact corpus using user defined rules. Further users are able to further query or write rules against given result sets from the corpus. This can be advantageous in many situations as it often is the case that the need for specific data happens incrementally. By being able to apply additional rules to existing result sets there is no need to re write a rule and re run the entire query process. Such an approach thus potentially saves time and resources. A user is able to refine the results as necessary by applying additional rules which can be quite powerful and can work within the predicate logic realm. A user also can search for existing rules or result sets to further refine results as needed.

In one embodiment the predicate logic inference engine is a JAVA program that queries the SQL to describe a table in the data store . The inference engine then builds the predicate logic facts using the returned column names. Such an approach is one possible way to generate a corpus but most data in the data store will not be of interest. Another inference engine can include a meta interpreter than can extract particular columns from particular tables and use those to generate specific facts. Such an approach can thereby extract only a meaningful subset of the data. This is not trivial as data stores typically manage data in a two dimensional approach e.g. columns within the rows . Metadata is often hierarchical in nature such that different rows corresponding to different product types might have a common parent. Obtaining such relationship information out of the data store can be difficult or at least very expensive as each relationship in the data store would need to be analyzed individually. Further instead of just a list of data or metadata having a common parent in a data table for example a user may prefer to obtain the entire hierarchy of relationships and to be able to store that hierarchy as a tree of information. To do this for a general table using conventional approaches can be very difficult.

The user interface UI component can also be used as a discovery tool to discover information about the data. For example in an electronic marketplace the catalog of items can be quite large and difficult to navigate. It often is the case that it is far easier to create new data than to locate existing but related data that already exists in the data store. Consequently there often are entries categories items etc. created in the data store that are essentially duplicates but are different in name for example and are not linked to each other in the data store. Since there is no easy way to determine context in the existing data store it can be difficult to locate and determine these duplicates. It can also be difficult to determine other relationships between the data such as attributes that are shared between books and other printed media. Using a predicate logic based approach as described herein can potentially allow such determinations to be executed much more quickly and can eliminate many of the duplicates unused attributes etc. that would otherwise exist. Technologies such as SQL do not provide tree traversal ability at any subsequent time. Relationship information can be determined but SQL does not provide a hierarchical or tree structure that can be used in a useful way. By generating a fact corpus a user can instead query the corpus which provides the ascendancy and descendancy information. For example simple queries can be written that find all common grandchildren which might enormously computationally expensive using a technology such as SQL as SQL arranges the data in a matrix and not in a tree.

Such approaches can be used with other data sources as well. For example data stored in the form of extensible markup language XML documents can be retrieved and parsed to generate predicate logic facts. Information from various XML documents can then be related in this way in the corpus. Data can also come from multiple data sources such as disparate databases and can be merged into the corpus. For example two databases might store different information about people where the people included in the databases overlap. Such an approach allows information to be merged in an intelligent way from any appropriate data source.

As discussed above the various embodiments can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and APPLETALK . The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers JAVA servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as JAVA C C or C or any scripting language such as Peri Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers are remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

