---

title: Administering devices in dependence upon user metric vectors with multiple users
abstract: Methods for administering devices, including creating a user metric vector including a plurality of disparate user metrics, creating a user metric space including a plurality of metric ranges, determining whether the user metric vector is outside the user metric space, creating, in dependence upon the user metric vector, a dynamic action list, if the user metric vector is outside a user metric space, identifying at least one action in the dynamic action list, and executing the action.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865909&OS=07865909&RS=07865909
owner: International Business Machines Corporation
number: 07865909
owner_city: Armonk
owner_country: US
publication_date: 20080303
---
This application is a continuation application of and claims priority from U.S. patent application Ser. No. 10 607 485 filed on Jun. 26 2003 now U.S. Pat. No. 7 386 863.

The field of the invention is data processing or more specifically methods systems and products for administering devices.

Conventional networks contain various devices. A user often uses the various devices or adjusts the particular settings of the devices in dependence upon the user s current condition. That is a user s current condition often motivates the user to change the settings of devices so that the devices operate in a manner that more positively benefits the user s current condition. For example a user with a headache may be disturbed by a powerful light. The user may dim the light or turn the light off so that the light no longer disturbs the user. Conventional networked devices however require user intervention to individually administer the specific device in response to user condition. It would be advantageous if there were a method of administering devices in dependence upon user condition that did not require user intervention.

Exemplary embodiments of the invention include methods for administering devices. Exemplary embodiments include receiving a plurality of disparate metrics for a plurality of users creating a first user metric vector including a plurality of disparate metrics for a first user and creating a second user metric vector including a plurality of disparate metrics for a second user. Such embodiments include creating a first user metric space including a plurality of first user metric ranges creating a second user metric space including a plurality of second user metric ranges and creating a mutual metric space in dependence upon the first user metric space and the second user metric space. Typical embodiments include determining whether the first user vector is outside the mutual metric space. If the first user metric vector is outside the mutual metric space exemplary embodiments include identifying an action and executing the identified action.

In exemplary embodiments of the invention creating a mutual metric space in dependence upon a first user metric space and a second user metric space includes determining an intersection of a first user metric range and a second user metric range creating a mutual metric range in dependence upon the intersection of the first user metric range and the second user metric range and associating the mutual metric range with the mutual metric space. In typical embodiments creating a mutual metric space in dependence upon a first user metric space and a second user metric space includes determining a union of a first user metric range and a second user metric range. Such embodiments also include creating a mutual metric range in dependence upon the union of the first user metric range and the second user metric range and associating the mutual metric range with the mutual metric space.

In exemplary embodiments of the invention creating a first user metric vector including a plurality of disparate metrics for a first user includes filtering the received disparate metrics for the first user. Such embodiments include determining whether the second user metric vector is outside the mutual metric space. In typical embodiments identifying an action includes creating a dynamic action list in dependence upon first user metric vector and the second user metric vector.

The foregoing and other objects features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.

The present invention is described to a large extent in this specification in terms of methods for administering devices. Persons skilled in the art however will recognize that any computer system that includes suitable programming means for operating in accordance with the disclosed methods also falls well within the scope of the present invention.

Suitable programming means include any means for directing a computer system to execute the steps of the method of the invention including for example systems comprised of processing units and arithmetic logic circuits coupled to computer memory which systems have the capability of storing in computer memory which computer memory includes electronic circuits configured to store data and program instructions programmed steps of the method of the invention for execution by a processing unit. The invention also may be embodied in a computer program product such as a diskette or other recording medium for use with any suitable data processing system.

Embodiments of a computer program product may be implemented by use of any recording medium for machine readable information including magnetic media optical media or other suitable media. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a program product. Persons skilled in the art will recognize immediately that although most of the exemplary embodiments described in this specification are oriented to software installed and executing on computer hardware nevertheless alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention.

 802.11 refers to a family of specifications developed by the IEEE for wireless LAN technology. 802.11 specifies an over the air interface between a wireless client and a base station or between two wireless clients.

 API is an abbreviation for application programming interface. An API is a set of routines protocols and tools for building software applications.

 Bluetooth refers to an industrial specification for a short range radio technology for RF couplings among client devices and between client devices and resources on a LAN or other network. An administrative body called the Bluetooth Special Interest Group tests and qualifies devices as Bluetooth compliant. The Bluetooth specification consists of a Foundation Core which provides design specifications and a Foundation Profile which provides interoperability guidelines.

 Coupled for data communications means any form of data communications wireless 802.11b Bluetooth infrared radio internet protocols HTTP protocols email protocols networked direct connections dedicated phone lines dial ups serial connections with RS 232 EIA232 or Universal Serial Buses hard wired parallel port connections network connections according to the Power Line Protocol and other forms of connection for data communications as will occur to those of skill in the art. Couplings for data communications include networked couplings for data communications. Examples of networks useful with various embodiments of the invention include cable networks intranets extranets internets local area networks wide area networks and other network arrangements as will occur to those of skill in the art. The use of any networked coupling among television channels cable channels video providers telecommunications sources and the like is well within the scope of the present invention.

 Driver means a program that controls a device. A device printer disk drive keyboard typically has a driver. A driver acts as translator between the device and software programs that use the device. Each device has a set of specialized commands that its driver knows. Software programs generally access devices by using generic commands. The driver therefore accepts generic commands from a program and then translates them into specialized commands for the device.

 DTMF is an abbreviation for Dual Tone Multi Frequency. DTMF systems transmit signals across existing power lines telephone lines or wirelessly by assigning a tone of a particular frequency to each key of a touch tone key pad at the signal s origin and converting the tone to a value at the signal s destination. Many such DTMF systems include a DTMF encoder at the origin that creates the predetermined tone when a particular key of the DTMF keypad is invoked and a DTMF decoder that converts the tone to a value at the destination.

The signal generated by a DTMF encoder is a summation of the amplitudes of two sine waves of different frequencies. In typical DTMF systems each row of keys on a key pad is assigned a low tone. The first row of a key pad keys 1 2 and 3 is typically assigned a low tone of 697 Hz. The second row of a key pad keys 4 5 and 6 is typically assigned a low tone of 770 Hz. The third row of a key pad keys 7 8 and 9 is typically assigned a low tone of 852 Hz. The fourth row of a key pad keys 0 and is typically assigned a low tone of 491 Hz.

Each column of keys on the keypad is assigned a high tone. The first column of a key pad keys 1 4 7 and is typically assigned a high tone of 1209 Hz. The second column of a key pad keys 2 5 8 and 0 is typically assigned a high tone of 1336 Hz. The third column of a key pad keys 3 6 9 and is typically assigned a high tone of 1477 Hz.

Pressing a key of a DTMF system s key pad results in the summation of the particular key s low tone assigned by the row in which the key resides with the particular key s high tone assigned by the column in which the key resides . For example pressing 1 on a typical DTMF keypad results in a tone created by adding 1209 Hz and 697 Hz. The particular frequencies of the low tones and high tones have been chosen to reduce harmonics when the high tones and the low tones are added.

Many DTMF systems are currently available. For example off the shelf DTMF systems are available from Silicon Systems Inc. Arkady Horak Systems and Mitel Corp. All such DTMF systems can be advantageously used with various embodiments of the methods for administering devices in accordance with the present invention.

 ESN is an abbreviation for Electronic Serial Number. An ESN is a serial number programmed into a device such as for example a coffeepot to uniquely identify the device.

 Field In this specification the terms field and data element unless the context indicates otherwise generally are used as synonyms referring to individual elements of digital data. Aggregates of data elements are referred to as records or data structures. Aggregates of records are referred to as tables or files. Aggregates of files or tables are referred to as databases. Complex data structures that include member methods functions or software routines as well as data elements are referred to as classes. Instances of classes are referred to as objects or class objects. 

 HAVi stands for Home Audio Video interoperability the name of a vendor neutral audio video standard particularly for home entertainment environments. HAVi allows different home entertainment and communication devices such as VCRs televisions stereos security systems and video monitors to be networked together and controlled from one primary device such as a services gateway PC or television. Using IEEE 1394 the Firewire specification as the interconnection medium HAVi allows products from different vendors to comply with one another based on defined connection and communication protocols and APIs. Services provided by HAVi s distributed application system include an addressing scheme and message transfer lookup for discovering resources posting and receiving local or remote events and streaming and controlling isochronous data streams.

 HomePlug stands for The HomePlug Powerline Alliance. HomePlug is a not for profit corporation formed to provide a forum for the creation of open specifications for high speed home powerline networking products and services. The HomePlug specification is designed for delivery of Internet communications and multimedia to homes through the home power outlet using powerline networking standards.

The HomePlug protocol allows HomePlug enabled devices to communicate across powerlines using Radio Frequency signals RF . The HomePlug protocol uses Orthogonal Frequency Division Multiplexing OFDM to split the RF signal into multiple smaller sub signals that are then transmitted from one HomePlug enabled device to another HomePlug enabled device at different frequencies across the powerline.

 HTTP stands for HyperText Transport Protocol the standard data communications protocol of the World Wide Web.

 ID abbreviates identification as used by convention in this specification with nouns represented in data elements so that user ID refers to a user identification and userID is the name of a data element in which is stored a user identification. For a further example of the use of ID metric ID refers to a metric identification and metricID is the name of a data element in which is stored a metric identification.

 IEEE 1394 is an external bus standard that supports data transfer rates of up to 400 Mbps 400 million bits per second . Apple which originally developed IEEE 1394 uses the trademarked name FireWire. Other companies use other names such as i.link and Lynx to describe their 1394 products.

A single 1394 port can be used to connect up to 63 external devices. In addition to high speed 1394 also supports isochronous data transfer delivering data at a guaranteed rate. This makes it ideal for devices that need to transfer high levels of data in real time such as video.

 The Internet is a global network connecting millions of computers utilizing the internet protocol or IP as the network layer of their networking protocol stacks. The Internet is decentralized by design. Each computer on the Internet is independent. Operators for each computer on the Internet can choose which Internet services to use and which local services to make available to the global Internet community. There are a variety of ways to access the Internet. Many online services such as America Online offer access to some Internet services. It is also possible to gain access through a commercial Internet Service Provider ISP . An internet uncapitalized is any network using IP as the network layer in its network protocol stack.

 JAR is an abbreviation for Java archives JAR is a file format used to bundle components used by a Java application. JAR files simplify downloading applets because many components .class files images sounds etc. can be packaged into a single file. JAR also supports data compression which further decreases download times. By convention JAR files end with a jar extension.

 JES stands for Java Embedded Server. JES is a commercial implementation of OSGi that provides a framework for development deployment and installation of applications and services to embedded devices.

 LAN is an abbreviation for local area network. A LAN is a computer network that spans a relatively small area. Many LANs are confined to a single building or group of buildings. However one LAN can be connected to other LANs over any distance via telephone lines and radio waves. A system of LANs connected in this way is called a wide area network WAN . The Internet is an example of a WAN.

 LonWorks is a networking platform available from Echelon . Lon Works is currently used in various network applications such as appliance control and lighting control. The LonWorks networking platform uses a protocol called LonTalk that is embedded within a Neuron Chip installed within Lon Works enabled devices.

The Neuron Chip is a system on a chip with multiple processors read write and read only memory RAM and ROM and communication and I O subsystems. The read only memory contains an operating system the LonTalk protocol and an I O function library. The chip has non volatile memory for configuration data and for application programs which can be downloaded over a LonWorks network to the device. The Neuron Chip provides the first 6 layers of the standard OSI network model. That is the Neuron Chip provides the physical layer the data link layer the network layer the transport layer the mutual metric layer and the presentation layer.

The Neuron Chip does not provide the application layer programming. Applications for LonWorks networks are written in a programming language called Neuron C. Applications written in Neuron C are typically event driven and therefore result in reduced traffic on the network.

 OSGI refers to the Open Services Gateway Initiative an industry organization developing specifications for services gateways including specifications for delivery of service bundles software middleware providing compliant data communications and services through services gateways. The Open Services Gateway specification is a java based application layer framework that gives service providers network operator device makers and appliance manufacturer s vendor neutral application and device layer APIs and functions.

The OSI Model or Open System Interconnection model defines a networking framework for implementing protocols in seven layers. Control is passed from one layer to the next starting at the application layer in one network station proceeding to the bottom layer over the channel to the next network station and back up the hierarchy.

The seventh layer of the OSI model is the application layer. The application layer supports application and end user processes. The application layer provides application services for file transfers email and other network software services.

The sixth layer of the OSI model is the presentation layer. The presentation layer provides independence from differences in data representation. The presentation layer translates from application data format to network data format and vice versa. The presentation layer is sometimes called the syntax layer. 

The fifth layer of the OSI model is the mutual metric layer. The mutual metric layer establishes manages and terminates connections between networked applications. The mutual metric layer sets up coordinates and terminates conversations exchanges and dialogues between networked applications.

The fourth layer of the OSI model is the transport layer. The transport layer provides transparent transfer of data between networked systems or hosts. The transport layer is also responsible for flow control and ensures complete data transfer.

The third layer of the OSI model is the network layer. The network layer creates logical paths known as virtual circuits for transmitting data from one network node to another network node. Routing forwarding addressing and packet sequencing are functions of the network layer.

The second layer of the OSI model is the data link layer. The data link layer decodes data packets into bits and codes bits into data packets. The data link layer provides a transmission protocol and manages data flow transmission in the in the physical layer.

The data link layer is divided into two sublayers. The first sublayer of the data link layer is the Media Access Control MAC layer. The MAC sublayer controls access and permission for a computer on a network to transmit data.

The second sublayer of the data link layer is the Logical Link Control LLC layer. The LLC layer controls data flow transmission in the physical layer.

The first layer of the OSI model is the physical layer. The physical layer transmits the bit stream electrical impulse light or radio signal through the physical network at the electrical and mechanical level. The physical layer provides the hardware for sending and receiving data.

 SMF stands for Service Management Framework available from IBM . SMF is a commercial implementation of OSGi for management of network delivered applications on services gateways.

 USB is an abbreviation for universal serial bus. USB is an external bus standard that supports data transfer rates of 12 Mbps. A single USB port can be used to connect up to 127 peripheral devices such as mice modems and keyboards. USB also supports Plug and Play installation and hot plugging.

 WAP refers to the Wireless Application Protocol a protocol for use with handheld wireless devices. Examples of wireless devices useful with WAP include mobile phones pagers two way radios and hand held computers. WAP supports many wireless networks and WAP is supported by many operating systems. Operating systems specifically engineered for handheld devices include PalmOS EPOC Windows CE FLEXOS OS 9 and JavaOS. WAP devices that use displays and access the Internet run microbrowsers. The microbrowsers use small file sizes that can accommodate the low memory constraints of handheld devices and the low bandwidth constraints of wireless networks.

The X 10 means the X 10 protocol. Typical X 10 enabled devices communicate across AC powerline wiring such as existing AC wiring in a home using an X 10 transmitter and an X 10 receiver. The X 10 transmitter and the X 10 receiver use Radio Frequency RF signals to exchange digital information. The X 10 transmitter and the X 10 receiver communicate with short RF bursts which represent digital information. A Binary 1 is represented by a 1 millisecond burst of 120 KHz and a Binary 0 by the absence of 120 KHz burst followed by the presence of a burst.

In the X 10 protocol data is sent in data strings called frames. The frame begins with a 4 bit start code designated as 1110. Following the start code the frame identifies a particular domain such as house with a 4 bit house code and identifies a device within that domain with a 4 bit devices code. The frame also includes a command string of 8 bits identifying a particular preset command such as on off dim bright status on status off and status request. 

 XML stands for eXtensible Markup Language a language that support user defined markup including user defined elements tags and attributes. XML s extensibility contrasts with most web related markup languages such as HTML which are not extensible but which instead use a standard defined set of elements tags and attributes. XML s extensibility makes it a good foundation for defining other languages. WML the Wireless Markup Language for example is a markup language based on XML. Modern browsers and other communications clients tend to support markup languages other than HTML including for example XML.

The domain of includes a services gateway . A services gateway is in some exemplary architectures an OSGi compatible services gateway . While exemplary embodiments of methods for administering devices are described in this specification using OSGi many other applications and frameworks will work to implement the methods of administering devices according to the present invention and are therefore also well within the scope of the present invention. Commercial implementations of OSGi such as JES and SMF are also useful in implementing methods for administering devices.

In the exemplary architecture of the services gateway includes a services framework . The services framework of is a hosting platform for running services. Services are the main building blocks for creating applications in the OSGi. An OSGi services framework is written in Java and therefore typically runs on a Java Virtual Machine JVM .

The exemplary architecture of includes a DML . DML is an abbreviation for Domain Mediation Layer. In many embodiments of the architecture of the DML is application software useful in implementing methods of administering devices in accordance with the present invention. In some embodiments of the present invention the DML is OSGi compliant application software and is therefore implemented as a service or a group of services packaged as a bundle installed on the services framework . In this specification DMLs are often discussed in the context of OSGi. However the discussion of OSGI is for explanation and not for limitation. In fact DMLs according to various embodiments of the present invention can be implemented in any programming language C C COBOL FORTRAN BASIC and so on as will occur to those of skill in the art and DMLs developed in languages other than Java are installed directly upon an operating system or operating environment rather than a JVM.

In the exemplary architecture of the services gateway is coupled for data communications with a metric sensor . A metric sensor is a device that reads an indication of a user s condition and creates a user metric in response to the indication of the user s condition. An indication of a user s condition is a quantifiable aspect of a user s condition and a quantity measuring the aspect. For example a quantifiable aspect of a user s condition is a body temperature of 99.2 degrees Fahrenheit. Examples of quantifiable aspects of a user s condition include body temperature heart rate blood pressure location galvanic skin response and others as will occur to those of skill in the art.

A user metric is a data structure representing an indication of user condition. In many examples of methods for administering devices in accordance with the present invention a user metric is implemented as a data structure class or object that includes a userID field a metricID field and a metric value field. A typical userID field identifies the user whose indication of condition is represented by the metric. A typical metricID field identifies the quantifiable aspect of user condition the metric represents such as for example blood pressure heart rate location or galvanic skin response. A typical metric value field stores a quantity measuring the aspect of a user s condition.

Wearable and wireless heart rate monitors galvanic skin response monitors eye response monitors and breathing monitors useful as or easily adaptable for use as metric sensors are currently available from Quibit Systems Inc. The Polar series of heart rate monitors from Body Trends Inc. and the magnetoelastic gastric pH sensors from Sentec Corporation are other examples of readily available biomedical sensors useful as or easily adaptable for use as metric sensors.

In order for a conventional sensor such as a biomedical sensor to be useful as a metric sensor that transmits multiple metric types in a domain containing multiple users the sensor advantageously transmits not only a value of the each aspect it measures but also transmits a user ID and a metricID. The user ID is useful because typical embodiments of the present invention include a DML capable of administering devices on behalf of many users simultaneously. The metricID is useful because a single user may employ more than one metric sensor at the same time or employ a metric sensor capable of monitoring and transmitting data regarding more than one aspect of user condition. All wireless sensors at least transmit a metric value according to some wireless data communications protocol. To the extent that any particular sensor off the shelf does not also transmit user ID or metricID such a sensor is easily adapted merely by small modifications of its controlling software also to include in its transmissions user IDs and metricID.

Although it is expected that most DMLs will support metric IDs and user IDs it is possible under some circumstances within the scope of the present invention to use an off the shelf sensor as a metric sensor even if the sensor does not provide metric ID and user ID in its output telemetry. Consider an example in which only a single person inhabits a domain having device controlled or administered by a DML tracking only a single metric such as for example heart rate. A DML tracking only one metric for only one user could function without requiring a metric type code in telemetry received from the metric sensor because of course only one type of metric is received. In this example strictly speaking it would be possible for an off the shelf Bluetooth enabled heart rate sensor such as a Polar sensor from Body Trends to function as a metric sensor. This example is presented only for explanation because as a practical matter it is expected that most DMLs according to embodiments of the present invention will usefully and advantageously administer more than one type of metric therefore needing a metric ID code in their telemetry on behalf of more than one user therefore needing a user ID in their telemetry .

In many embodiments of the present invention the metric sensor is advantageously wirelessly coupled for data communications with the services gateway . In many alternative embodiments the metric sensor transmits the user metric to the DML through a services gateway using various protocols such as Bluetooth 802.11 HTTP WAP or any other protocol that will occur to those of skill in the art.

In the exemplary architecture of the domain includes a device coupled for data communications with the services gateway across a LAN . In many embodiments of the present invention a domain will include many devices. A home domain for example may include a home network having a television numerous lights a refrigerator a freezer a coffee pot a dishwasher a dryer a CD player a DVD player a personal video recorder or any other networkable device that will occur to those of skill in the art. For ease of explanation the exemplary architecture of illustrates only three devices but the use of any number of devices is well within the scope of the present invention.

To administer the device the DML must have the device class for the device containing accessor methods that get and set attributes on the device and in some cases a communication class that provides the protocols needed to communicate with the device. In some examples of the architecture of a DML has pre installed upon it device classes and communications classes for many devices that the DML supports.

To the extent the DML does not have a preinstalled device class and communications class for a particular device the DML can obtain the device class and communications class in a number of ways. One way the DML obtains the device class and communications class for the device is by reading the device class and the communications class from the device. This requires the device have enough installed memory to store the device class and communications class. The DML can also obtain the device class and communications class from devices that do not contain the device class or communications class installed upon them. One way the DML obtains the device class and communications class is by reading a device ID from the device searching the Internet for the device class and communications class and downloading them. Another way the DML obtains the device class and communications class is by reading a network location from the device downloading from the network location the device class and communications class. Three ways have been described for obtaining the device classes and communications classes needed to administer devices in accordance with the present invention. Other methods will also occur to those of skill in the art.

The exemplary architecture of includes a non domain entity that is coupled for data communications with the services gateway across a WAN . A non domain entity is any computing device or network location coupled for data communications to the domain but not within the domain. The phrase non domain entity is broad and its inclusion in the architecture of acknowledges that in many embodiments of architecture useful in implementing methods of administering devices in accordance with the present invention a given domain is coupled for data communications with outside non domain entities.

An example of a non domain entity is a web server outside the domain of a manufacturer of the device installed within the domain. The manufacturer may operate a website that makes available for download drivers for the device updates for the device or any other information or software for the device. Drivers updates information or software for the device are downloadable to the device across a WAN and through the services gateway.

OSGi Stands for Open Services Gateway Initiative. The OSGi specification is a Java based application layer framework that provides vendor neutral application and device layer APIs and functions for various devices using arbitrary communication protocols operating in networks in homes cars and other environments. OSGi works with a variety of networking technologies like Ethernet Bluetooth the Home Audio and Video Interoperability standard HAVi IEEE 1394 Universal Serial Bus USB WAP X 10 Lon Works HomePlug and various other networking technologies. The OSGi specification is available for free download from the OSGi website at www.osgi.org.

The services gateway of includes a service framework . In many example embodiments the service framework is an OSGi service framework . An OSGi service framework is written in Java and therefore typically runs on a Java Virtual Machine JVM . In OSGi the service framework of is a hosting platform for running services . The term service or services in this disclosure depending on context generally refers to OSGi compliant services.

Services are the main building blocks for creating applications according to the OSGi. A service is a group of Java classes and interfaces that implement a certain feature. The OSGi specification provides a number of standard services. For example OSGi provides a standard HTTP service that creates a web server that can respond to requests from HTTP clients.

OSGi also provides a set of standard services called the Device Access Specification. The Device Access Specification DAS provides services to identify a device connected to the services gateway search for a driver for that device and install the driver for the device.

Services in OSGi are packaged in bundles with other files images and resources that the services need for execution. A bundle is a Java archive or JAR file including one or more service implementations an activator class and a manifest file . An activator class is a Java class that the service framework uses to start and stop a bundle. A manifest file is a standard text file that describes the contents of the bundle .

In the exemplary architecture of includes a DML . In many embodiments of the present invention the DML is an OSGi service that carries out methods of administering devices. The DML of is packaged within a bundle and installed on the services framework .

The services framework in OSGi also includes a service registry . The service registry includes a service registration including the service s name and an instance of a class that implements the service for each bundle installed on the framework and registered with the service registry . A bundle may request services that are not included in the bundle but are registered on the framework service registry . To find a service a bundle performs a query on the framework s service registry .

The class diagram of includes an exemplary DML class . An instance of the exemplary DML class of provides member methods that carry out the steps useful in administering devices in accordance with the present invention. The exemplary DML class of is shown with an Activator.start method so that the DML can be started as a service in an OSGi framework. Although only one member method is shown for this DML DMLs in fact will often have more member methods as needed for a particular embodiment. The DML class of also includes member data elements for storing references to services classes often created by the DML s constructor. In this example the DML provides storage fields for references to a metric service a metric range service a communication service an action service a device service a metric vector service a metric space service dynamic action list service a metric vector administrator service and a mutual metric space service .

The metric service class of provides member methods that receive user metrics from a DML and create in response to receiving the user metrics from the DML an instance of a metric class. The metric service class of includes a createMetric UserID MetricID MetricValue member method . The createMetric member method is in some embodiments a factory method parameterized with a metric ID that creates and returns a metric object in dependence upon the metric ID. In response to getting a user metric from the DML the exemplary instance of the metric service class of creates an instance of a metric class and returns to the DML a reference to the new metric object.

Strictly speaking there is nothing in the limitations of the present invention that requires the DML to create metric object through a factory method. The DML can for example proceed as illustrated in the following pseudocode segment 

This example creates a metric object and uses accessor methods to load its member data. This approach provides exactly the same class of metric object for each metric however and there are circumstances when metrics advantageously utilize different concrete class structures. In the case of metrics for heart rate and blood pressure for example both metric values may be encoded as integers where a metric value for polar coordinates on the surface of the earth from a GPS transceiver for example may advantageously be encoded in a more complex data structure even having its own Location class for example. Using a factory method eases the use of more than one metric class. A DML using a factory method to create metric objects can proceed as illustrated in the following exemplary pseudocode segment 

This example relies on the factory method createMetric to set the parameter values into the new metric object. A metric service and a factory method for metric object can be implemented as illustrated in the following pseudocode segment 

MetricService in this example implements a so called parameterized factory design pattern including a factory method. In this example the factory method is a member method named createMetricObject . CreateMetricObject accepts three parameters a user ID a metric ID and a metric value. CreateMetricObject implements a switch statement in dependence upon the metric ID to select and instantiate a particular concrete metric class. The concrete metric classes in this example are HeartRateMetric BloodPressureMetric and GPSMetric each of which extends a Metric base class. CreateMetricObject returns to the calling DML a reference to a new metric object. The call from the DML 

is polymorphic utilizing a reference to the base class Metric so that the calling DML neither knows nor cares which class of metric object is actually instantiated and returned. The following is an example of extending a Metric base class to define a concrete metric class representing a user s location on the surface of the earth extending a Metric base class 

The example concrete class GPSMetric provides storage for latitude and longitude. GPSMetric provides a constructor GPSMetric that takes integer arguments to set userID and metricID but expects its metricValue argument to be a reference to a GPSLocation object which in turn provides member data storage for latitude and longitude.

The class diagram of includes an exemplary metric class . The exemplary metric class of represents a user metric. A user metric comprises data describing an indication of user condition. An indication of a user s condition is a quantifiable aspect of a user s condition and a quantity measuring the aspect. Examples of quantifiable aspects of a user s condition include body temperature heart rate blood pressure location galvanic skin response or any other aspect of user condition as will occur to those of skill in the art.

The exemplary metric class of includes a user ID field a metric ID field a value field . The user ID field identifies the user. The metric ID field identifies the user metric that an instance of the metric class represents. That is the kind of user metric. The value field includes a value of the user metric.

The exemplary metric class of also includes data storage for a metric action list . A metric action list is a data structure containing action IDs identifying actions that when executed administer devices. Typically action IDs in the metric action list are designed to affect the value of the metric. A metric for body temperature for example may have an associated metric action list including an action ID that when executed results in turning on a ceiling fan.

This exemplary metric class is an example of a class that can in various embodiments be used in various embodiments as a generic class instances of which can be used to store or represent more than one type of metric having identical or similar member data elements as discussed above. Alternatively in other embodiments a class such as this example metric class can be used as a base class to be extended by concrete derived classes each of which can have widely disparate member data type also described above.

The class diagram of includes a metric vector service . The metric vector service class of provides member methods that create in response to receiving the user metrics from the metric service an instance of a metric vector class. In many example embodiments the createMetricVectorObject member method identifies from a metric vector list a metric vector ID for the user metric vector in dependence upon the user ID and the metric ID. If there is not a metric vector for the user and for that metric ID in the metric vector service s metric vector list the metric vector service instantiates one and stores its metric vector ID in a metric vector table indexed by the associated user ID and metric ID. Creating a metric vector object can be implemented as illustrated in the following pseudocode segment 

In the pseudocode example above if the metric vector service receives a metric having a userID for which it has no metric vector identified in the metric vector service s metric vector table the metric vector service creates a new metric vector having a new metric vector ID for the user and adds the metric vector to the metric vector list.

The class diagram of includes a metric vector class . Objects of the metric vector class represent a complex indication of user condition. A user metric vector typically includes a collection of a user metrics each representing a single quantifiable aspect of a user s condition and a quantity measuring the aspect. A user metric vector comprised of a plurality of disparate user metrics therefore represents a complex indication of user condition having multiple quantifiable aspects of a user s condition and multiple quantities measuring the aspects. The metric vector class includes data elements for storing a user ID identifying the user and a metric list for storing references to a plurality of disparate metric objects.

The exemplary metric vector of also includes data storage for a dynamic action list . A dynamic action list is a list of action IDs created in dependence upon metric action lists that are associated with the particular metrics of the user metric vector that are outside their corresponding metric ranges of the user metric space. That is each metric of the metric vector that is outside its corresponding metric range has an associated metric action list. A dynamic action list includes action IDs identified in dependence upon those metric action lists associated with the particular metrics of a user metric vector outside their corresponding metric ranges of the user metric space. A dynamic action list advantageously provides a list of action IDs tailored to the user s current condition.

The exemplary metric vector of also includes data storage for a negative action list . A negative action list includes action IDs that are not to be executed for the user. In many embodiments a user selects action IDs for inclusion in the negative action list. In some examples the action IDs included in the negative action list identify actions that are ineffective in affecting the user s condition. In other examples the action IDs of the negative action list include action IDs that may be effective in affecting user condition but for one reason or another the user does not want the action executed.

This exemplary metric vector class is an example of a class that can in various embodiments be used as a generic class instances of which can be used to store or represent more than one type of vector having identical or similar member data elements. Alternatively in other embodiments a class such as this example metric vector class can be used as a base class to be extended by concrete derived classes each of which can have disparate member data types.

The class diagram of includes metric range service class . The metric range service class provides member methods that instantiate an instance of a metric range class. The metric range service class of includes a createRangeObject UserID MetricID member method . The createRangeObject member method is a factory method parameterized with a userID and a metric ID that creates a metric range object in dependence upon the userID and metric ID. The createRangeObject factory method returns a reference to the metric range object to the metric object. The createRangeObject is a parameterized factory method that can be implemented using the same design patterns outlined by the exemplary pseudocode provided in the description of the createMetricObject factory method.

The class diagram of includes an exemplary metric range class . An instance of the exemplary metric range class represents a predefined metric range for a user for a metric. A maximum value and minimum value in a metric range object are compared with a metric value to determine whether the metric value of the metric object is outside a predefined metric range. The exemplary metric range class of includes range ID field identifying the metric range and a metric ID field identifying the user metric. The exemplary metric range class of includes a user ID field identifying the user. The metric range class also includes a Max field and a Min field containing a maximum value and a minimum value defining a metric range.

The exemplary metric range class of is an example of a so called data object that is a class that serves only as a container for data with little or no processing done on that data by the member methods of the class. In this example objects of the metric range class are used primarily to transfer among other objects the minimum and maximum values of a metric range. The metric range class of includes a default constructor not shown but strictly speaking would need no other member methods. If the metric range class were provided with no other member methods cooperating object could access its member data elements directly by coding such as for example someMetricRange.max or someMetricRange.min. The particular example in this case however is illustrated as containing accessor methods for the minimum and maximum values of its range a practice not required by the invention but consistent with programming in the object oriented paradigm.

The class diagram of includes a metric space service class . The metric space service class includes a member method createMetricSpace that searches a metric space list or other data structure to identify a metric space for a user. If no such metric space exists createMetricSpace instantiates one and stores the metric space ID in the metric space list. Creating a metric space object can be implemented by way of the following exemplary pseudocode 

In the pseudo code example above the metric space service searches a metric space list for a metric space. If the list contains no metric space for the userID and metric vector ID then MetricSpaceService.createMetricSpace userID MetricVectorID creates a new metric space with a new metric space ID.

The class diagram of includes a metric space class. The user metric space is comprised of a plurality of user metric ranges for disparate metrics. The exemplary metric space includes data elements for storing a user ID identifying the user and a space ID identifying the metric space. The metric space of also includes data storage for a list of references to disparate metric ranges for a user. The disparate metric ranges of the metric space correspond in kind to the metrics in the user metric vector. That is in typical embodiments the user metric vector includes a set of disparate current metrics and the user metric space includes a set of corresponding metric ranges for the user.

The class diagram of includes a mutual metric space . A mutual metric space is a single metric space for a given domain created in dependence upon the metric spaces of the individual users within in the domain. That is a mutual metric space is a single metric space used by multiple users created in dependence upon the individual ranges of each users metric space. The mutual metric space of includes a mutual metric range list . The mutual metric range list includes references to a plurality of mutual metric range objects each containing maximum and minimum values for a particular metric.

The class diagram of includes a metric vector administrator service . The metric vector administrator service includes a createMetricVectorAdmin member method that creates a metric vector administrator. A metric vector administrator administers multiple metric vectors for various users. In some examples when a DML receives metrics for multiple users and the metric vector service instantiates a second metric vector for a second user member methods in the metric vector service call createMetricVectorAdmin . createMetricVectorAdmin creates a metric vector administrator object with references to each metric vector for each user.

The class diagram of includes a metric vector administrator class . Objects of the metric vector administrator class are instantiated when more user is within a single domain. The metric vector administrator of includes data storage for a vector list including references to the current metric vector for each user. The metric vector administrator includes a member method compareVector . CompareVector determines whether each metric vector for each user is outside a mutual metric space for the domain.

The class diagram of includes an action service class . The action service class includes member methods that instantiate a metric action list for a metric instantiate action objects store references to the action objects in the metric action list and return to a calling metric a reference to the action list all of which can be implemented as illustrated by the following exemplary pseudocode ActionService class 

The createMetricActionList method in ActionService class instantiates a metric action list for a user metric with MetricActionList aMetricActionList new MetricActionList . CreateActionList then searches an action record table in a database for records having user IDs and metric IDs matching its call parameters. For each matching record in the table createMetricActionList instantiates an action object through its switch statement. The switch statement selects a particular concrete derived action class for each action ID retrieved from the action record table. CreateMetricActionList stores a references to each action object in the action list with aMetricActionList.add . CreateMetricActionList returns a reference to the action list with return aMetricActionList. 

The class diagram of includes an exemplary action class . An instance of the action class represents an action that when executed results in the administration of a device. The exemplary action class of includes an action ID field . The doAction method in the exemplary action class is programmed to obtain a device list from for example a call to DeviceService.createDeviceList . Action.doAction typically then also is programmed to call interface methods in each device in its device list to carry out the device controlling action.

The class diagram of includes a dynamic action list service. The dynamic action list service of includes a member method createDynamicList . In many embodiments createDynamicList is called by member methods within a user vector administrator parameterized with action IDs retrieved from metric action lists associated with the particular metrics of each user s metric vector that are outside their corresponding mutual metric ranges of the mutual metric space. CreateDynamicList creates a dynamic action list including action IDs identified in dependence upon the metric IDs and returns to its caller a reference to the dynamic action list.

The class diagram of includes a device service class . The device service class provides a factory method named createDeviceList actionID that creates a list of devices and returns a reference to the list. In this example createDeviceList operates in a fashion similar to ActionService.createMetricActionList described above by instantiating a device list searching through a device table for device IDs from device records having matching action ID entries instantiating a device object of a concrete derived device class for each adding to the device list a reference to each new device object and returning to a calling action object a reference to the device list. In this example however the factory method createDeviceList not only retrieves a device ID from its supporting data table but also retrieves a network address or communications location for the physical device to be controlled by each device object instantiated as illustrated by the following exemplary pseudocode 

The createDeviceList method in DeviceService class instantiates a device list for a metric with DeviceList aDeviceList new DeviceList . CreateDeviceList then searches a device record table in a database for records having action IDs matching its call parameter. For each matching record in the table createDeviceList instantiates a device object through its switch statement passing three parameters CommsService deviceAddress and deviceID. CommsService is a reference to a communications service from which a device object can obtain a reference to a communications object for use in communicating with the physical device controlled by a device object. DeviceAddress is the network address obtained from the device table as described above of the physical device to be controlled by a particular device object. The switch statement selects a particular concrete derived device class for each device ID retrieved from the device table. CreateDeviceList stores references to each device object in the device list with aDeviceList.add . CreateDeviceList returns a reference to the device list with return aDeviceList. 

The class diagram of includes an exemplary device class . The exemplary device class of includes a deviceID field uniquely identifying the physical device to be administered by the execution of the action. The exemplary device class of includes an address field identifying a location of a physical device on a data communications network. The exemplary device class of provides a communications field for a reference to an instance of a communications class that implements a data communications protocol to effect communications between an instance of a device class and a physical device.

The device class of includes an attribute field containing a value of current attribute of the device. An example of a current attribute of a device is an indication that the device is on or off. Other examples of current attributes include values indicating a particular setting of a device. The device class of also includes accessor methods for getting and setting attributes of a physical device. While the exemplary device class of includes only one attribute field and accessor methods for getting and setting that attribute many device classes useful in implementing methods of the present invention can support more than one attribute. Such classes can also include an attribute ID field and accessor methods for getting and setting each attribute the device class supports.

The exemplary class diagram of includes a communications service class . The communications service class provides a factory method named createCommsObject deviceID networkAddress that instantiates a communications object that implements a data communications protocol to effect communications between an instance of a device class and a physical device. The createCommsObject method finds a communications class ID in a communications class record in a communication class table having a device ID that matches its call parameter. In many embodiments the createCommsObject method then instantiates a particular concrete derived communications class identified through a switch statement as described above passing to the constructor the networkAddress from its parameter list so that the new communications object knows the address on the network to which the new object is to conduct data communications. Each concrete derived communications class is designed to implement data communications according to a particular data communications protocol Bluetooth 802.11b Lonworks X 10 and so on.

Class diagram of includes an exemplary communications base class . In typical embodiments at least one concrete communications class is derived from the base class for each data communications protocol to be supported by a particular DML. Each concrete communications class implements a particular data communications protocol for communications device objects and physical devices. Each concrete communications class implements a particular data communications protocol by overriding interface methods to implement actual data communications according to a protocol.

Communications classes allow device classes to operate independently with respect to specific protocols required for communications with various physical devices. For example one light in a user s home may communicate using the LonWorks protocol while another light in the user s home may communicate using the X 10 protocol. Both lights can be controlled by device objects of the same device class using communications objects of different communications classes one implementing LonWorks the other implementing X 10. Both device objects control the lights through calls to the same communications class interface methods send and receive neither knowing nor caring that in fact their communications objects use different protocols.

The exemplary class relationship diagram of includes a DML class . A DML object of the DML class instantiates an object of the metric service class an object of the metric vector service class and an object of the metric vector administrator service class .

As shown in the class relationship diagram of a metric vector service instantiates an object of the metric vector class . In many embodiments the metric vector service class receives a reference to a metric object and using a parameterized factory method such as createMetricVectorObject instantiates a metric vector object. As shown in the class relationship diagram of an object of the metric vector class contains a reference to an object of the metric class .

As shown in the class relationship diagram of an object of the metric vector administrator service class instantiates an object of the metric vector administrator class . In many embodiments the metric vector administrator service class receives a reference to each metric vector from a metric vector service and using a member method such as createMetricVectorAdmin instantiates a metric vector administrator object. The metric vector administrator possesses a reference to each user metric vector for each user in the domain.

As shown in the class relationship diagram of an object of the metric range service class instantiates an object of the metric range class . In many examples embodiments of the present invention the metric range service uses a parameterized factory method such as createRangeObject to instantiate the metric range . The metric range service passes to the metric space service a reference to the metric range .

As shown in the exemplary class relationship diagram of a metric space service instantiates an object of the metric space class . In many example embodiments a metric space service uses a parameterized factory method such as createMetricSpace to instantiate a metric space object. In many embodiments createMetricSpace returns to its caller in a metric vector a reference to the metric space object to the metric vector object. The metric space object contains a reference to objects of the metric range class .

As shown in the exemplary class relationship diagram of a mutual metric space service class instantiates an object of the mutual metric space class . In many embodiments the mutual metric space class uses a member method such as createMutualMetricSpace to create a mutual metric space for a domain in dependence upon the metric ranges of each metric space associated with each user in the domain. In many exemplary embodiments createMutualMetricSpace returns to its caller in a metric vector administrator a reference to the mutual metric space .

As shown in the class relationship diagram of an action service instantiates a metric action list and objects of action classes . The metric action list is instantiated with references to each of the instantiated actions . Each action is instantiated with a reference to the device service . In typical examples of methods according to the present invention the action service uses a parameterized factory method such as createMetricActionList to instantiate a metric action list and instantiate actions . The action service passes to a caller in the metric a reference to the metric action list .

As shown in the dynamic action list service instantiates a dynamic action list and passes a reference to the dynamic action list to calling methods in the metric vector administrator . In typical examples of methods according to the present invention the dynamic action list service uses a method such as createDynamicActionList to instantiate a dynamic action list. In many embodiments createDynamicActionList is parameterized with action IDs of metric action lists associated with user metrics that are outside their corresponding metric ranges of a mutual metric space. The dynamic action list possesses references to objects of the action class .

In the example of the device service instantiates a device list of the device list class and instantiates a device object of the device class . The device list is instantiated with references to the device objects . Each device object is instantiated with a reference to the communications service . In typical examples of methods according to the present invention the device service uses a parameterized factory method such as createDeviceList to instantiate a device list and instantiate a device object . The device service passes to the action a reference to the device list 

In the example of the communications service instantiates a communications object of the communications class . In typical examples of the methods according to the present invention the communications service uses a parameterized factory method such as createCommsObject to instantiate a communications object . The communications service passes to the device object a reference to the communications object .

In typical embodiments of the present invention a user metric is implemented as a user metric data structure or record such as the exemplary user metric of . The user metric of includes a userID field identifying the user whose indication of condition is represented by the metric. The user metric of also includes a metric ID field identifying the aspect of user condition the metric represents such as for example blood pressure heart rate location or galvanic skin response. The user metric also includes a value field containing the value of the aspect of the user s condition that the metric represents. An example of a value of a metric is a body temperature of 100 Fahrenheit.

In many embodiments of the method of receiving a user metric includes receiving a user metric from a metric sensor . In some examples of the method of the metric sensor reads an indication of a user s condition creates a user metric in dependence upon the indication of a user s condition and transmits the user metric to a DML. In many embodiments the metric sensor transmits the user metric to the DML in a predefined data structure such as the metric of to the DML using for example protocols such as Bluetooth 802.11 HTTP WAP or any other protocol that will occur to those of skill in the art.

In the method of receiving a user metric includes receiving a user metric into metric cache memory . That is a user metric is received by a DML and then stored in cache. In many embodiments of the method of metric cache memory is cache memory available to a DML to facilitate carrying out steps of administering devices in accordance with the present invention.

The method of includes determining whether a value of the user metric is outside of a predefined metric range. A predefined metric range includes a predetermined range of values for a given metric ID for a particular user. In many embodiments of the method of the predefined metric range is designed as a range of typical or normal metrics values for a user. One example of a predefined metric range is a range of metric values representing a resting heart rate of 65 85 beats per minute.

In many examples of the method of a predefined metric range for a user is implemented as a data structure or record such as the metric range of . The metric range of includes a metric ID field identifying the kind of user metrics. The metric range of includes a user ID field identifying the user for whom the metric range represents a range of metric values. The metric range of for example includes a Max field representing the maximum metric value of the metric range and a Min field representing the minimum metric value of the metric range. That is in typical embodiments it is a maximum and minimum metric value in a range that defines a value range for the metric.

In many embodiments determining that the value of the user metric is outside of a predefined metric range includes comparing the metric value of a user metric with the maximum and minimum values from a metric range for that metric and for the same user. In many examples of the method of determining that a user metric is outside a predefined metric range also includes determining that the metric value of the user metric is either greater than the maximum value of the metric range or below the minimum value of the range in the metric range . A user metric of metric ID identifying the metric as heart rate having for example a metric value of 100 beats per minute is outside the exemplary metric range for resting heart rate of 65 85 beats per minute.

If the value of the user metric is outside the metric range the method of includes identifying an action in dependence upon the user metric. An action includes one or more computer programs subroutines or member methods that when executed control one or more devices. Actions are typically implemented as object oriented classes and manipulated as objects or references to objects. In fact in this specification unless context indicates otherwise the terms action action object and reference to an action object are treated more or less as synonyms. In many embodiments of the method of an action object calls member methods in a device class to affect current attributes of the physical device. In many embodiments of the method of action classes or action objects are deployed in OSGi bundles to a DML on a services gateway.

In the method of identifying an action includes retrieving an action ID from a metric action list organized by user ID and metric ID. In the method of retrieving an action ID from a metric action list includes retrieving from a list the identification of the action the action ID to be executed when a value of a metric of a particular metric ID and for a particular user is outside the user s predetermined metric range. The action list can be implemented for example as a Java list container as a table in random access memory as a SQL database table with storage on a hard drive or CD ROM and in other ways as will occur to those of skill in the art.

As mentioned above the actions themselves comprise software and so can be implemented as concrete action classes embodied for example in a Java package imported into the DML at compile time and therefore always available during DML run time. Executing an action therefore is often carried out in such embodiments by use of a switch statement in the DML. Such a switch statement can be operated in dependence upon the action ID and implemented for example as illustrated by the following segment of pseudocode 

The exemplary switch statement selects a particular device controlling object for execution depending on the action ID. The device controlling objects administered by the switch in this example are concrete action classes named actionNumber1 actionNumber2 and so on each having an executable member method named take action which carries out the actual work implemented by each action class.

Executing an action also is often carried out in such embodiments by use of a hash table in the DML. Such a hash table can store references to action object keyed by action ID as shown in the following pseudocode example. This example begins by an action service s creating a hashtable of actions references to objects of concrete action classes associated with a particular metric ID using action IDs as keys. In many embodiments it is an action service that creates such a hashtable fills it with references to action objects pertinent to a particular metric ID and returns a reference to the hashtable to a calling metric object.

Many examples in this specification are described as implemented with lists often with lists of actions for example returned with a reference to a list from an action service for example. Lists often function in fashion similar to hashtables. Executing a particular action for example can be carried out according to the following pseudocode 

The three examples just above use switch statements hash tables and list objects to explain executing actions according to embodiments of the present invention. The use of switch statements hash tables and list objects in these examples are for explanation not for limitation. In fact there are many ways of executing actions according to embodiments of the present invention as will occur to those of skill in the art and all such ways are well within the scope of the present invention.

In the method of executing an action includes identifying a communication class for the physical device . To communicate the member methods of the device class to the physical device a communications class implements a protocol for communicating with a physical device. Typical communications classes include member methods that construct transmit and receive data communications messages in accordance with the protocol implemented by a communication class. The member methods in a communication class transmit and receive data communications messages to and from a physical device. A communications class advantageously separates the protocols used to communicate with the physical device from the actions to be effected on the device so that a device class interface comprising get and set methods for example can usefully communicate with a physical device by use of any data communications protocol with no need to reprogram the device class and no need to provide one device class for each combination of physical device and protocol.

For further explanation consider the following brief use case. A user s metric sensor reads the user s heart rate at 100 beats per minute and creates a metric for the user having a user ID identifying the user a metric ID identifying the metric as heart rate and a metric value of 100. The metric sensor transmits the user metric to the DML through a services gateway. The DML receives the user metric and compares the user metric with the user metric range for resting heart rates having a range of 65 85. The DML determines that the user metric is outside the predefined metric range. The DML uses the user ID and the metric ID to retrieve from a list an action ID for a predefined action to be executed in response to the determination that the value of the user s heart rate metric value is outside the user s metric range for heart rate. The DML finds a device controlling action ID identifying an action object having a class name of someAction for example and also having an interface member method known to the DML such as the take action method described above in the switch statement.

In this example the DML effects the action so identified by calling someAction.take action . The take action method in this example is programmed to call a device service for a list of references to device objects representing physical devices whose attributes are to be affected by the action. The device service is programmed with a switch statement to create in dependence upon the action ID a list of references to device objects and return the device list to the calling action object or rather to the calling take action method in the action object.

In creating the device list the device service is programmed to instantiate each device having a reference entered in the list passing as a constructor parameter a reference to a communications service. Each device so instantiated has a constructor programmed to call a parameterized factory method in the communications service passing as a parameter an identification of the calling device object. The communications service then instantiates and returns to the device a reference to a communication object for the communications protocol needed for that device object to communicate with its corresponding physical device.

The principal control logic for carrying out an action typically in embodiments of the present invention resides in the principal interface method of an action class and objects instantiated from it. In this example the take action method is programmed to carry out a sequence of controlling method calls to carry out the changes on the physical devices that this action class was developed to do in the first place. The take action method carries out this work with a series of calls to accessor methods set and get methods in the device objects in its device list.

In the example of a predefined metric range for a metric is represented in data as a metric range such as the metric range of . The exemplary metric range sets forth a maximum range value and a minimum range value for a particular user for a particular metric. The particular user and the particular metric for the exemplary range are identified respectively in a user ID field and a metric ID field .

In the method of determining that value of the user metric is outside of a predefined metric range includes measuring a degree to which the user metric is outside the predefined metric range . In many embodiments of the present invention measuring the degree to which the user metric is outside the metric range includes identifying the magnitude by which the value of the user metric is greater than the maximum metric value the metric range or the magnitude by which the value of the user metric value is less than the minimum value of the predefined metric range. To the extent that measuring the degree to which a metric is out of range includes identifying a measure as greater than a maximum range value or less than a minimum range value the measurement often advantageously includes both a magnitude and an indication of direction such as for example a sign or an enumerated indication such as for example UP or DOWN or a Boolean indication such as true for high and false for low.

In the method of identifying an action in dependence upon the user metric includes identifying an action in dependence upon the degree to which the value of the user metric is outside the metric range and also often in dependence upon the direction in which the metric is out of range. In many embodiments of the method of identifying the action in dependence upon the degree to which the user metric is outside the predefined metric range includes retrieving an action ID from a metric action list organized by metric ID user ID degree and direction.

In many DMLs according to the present invention are preinstalled device classes for all of the devices the DML supports. Newly acquired physical devices identify themselves as being on the network and the DML associates the device ID with the device class already installed on the DML. In such an example embodiment the DML identifies the device by associating the device ID with the pre installed device class.

In many examples of the method of receiving a plurality of disparate metrics for a plurality of users includes receiving disparate user metrics from one or more metric sensors . In some examples of the method of a first metric sensor reads an indication of a first user s condition creates a first user metric in dependence upon the indication of a user s condition and transmits the user metric to a DML. In many embodiments the metric sensor transmits the user metric to the DML in a predefined data structure such as the metric of to the DML using for example protocols such as Bluetooth 802.11 HTTP WAP or any other protocol that will occur to those of skill in the art. Similarly in the method of a second metric sensor reads an indication of a second user s condition creates a second user metric in dependence upon the indication of a user s condition and transmits metric for the second user to a DML. Although the example of includes only two users there is no such limitation in the number of users of the method of present invention.

In the example of receiving a plurality of disparate metrics for a plurality of users is carried out by a DML . The DML receives the disparate metrics from the first user s metric sensor and the second user s metric sensor and stores the disparate metrics in cache memory as unfiltered metrics . The metrics are unfiltered because they are metrics of disparate types received from different metric sensors for different users. In many examples the unfiltered metrics are implemented as data structures transmitted with a metric ID a metric value and a user ID ESN of the metric sensor or other ID uniquely identifying the user.

The method of includes creating a first user metric vector comprising a plurality of disparate metrics for a first user . A first user metric vector comprised of a plurality of disparate user metrics represents a complex indication of the first user s condition having multiple quantifiable aspects of the first user s condition and multiple quantities measuring the aspects. That is a first user metric vector is a collection of metrics for the first user each metric representing a single quantifiable aspect of the first user s condition and a quantity measuring the aspect.

The term disparate user metrics means user metrics of different kinds. A first user metric vector being comprised of a plurality of disparate metrics is therefore a complex indication of a user s condition comprising a plurality of different kinds of aspects of user condition and plurality of quantities measuring those aspects. In many examples of the method of the first user metric vector comprises references to current metric objects for the first user instantiated by a metric service.

In typical embodiments of the present invention a first user metric vector is implemented as a data structure or record similar to the exemplary user metric vector discussed above with reference to . The user metric vector includes a user ID on identifying the user and a metric vector ID on uniquely identifying the user metric vector. The user metric vector also includes data storage for a metric list on containing references to disparate user metrics.

The method of includes creating a second user metric vector comprising a plurality of disparate metrics for a second user . As is the case with the first user metric vector a second user metric vector comprised of a plurality of disparate metrics represents a complex indication of the second user s condition having multiple quantifiable aspects of the second user s condition and multiple quantities measuring the aspects. That is a second user metric vector is a collection of metrics for a second user each representing a single quantifiable aspect of the second user s condition and a quantity measuring the aspect.

The method of includes creating a first user metric space comprising a plurality of first user metric ranges. A first user metric space is comprised of a plurality of disparate metric ranges for a first user. That is a first user metric space is defined by a plurality of disparate metric ranges for a plurality of disparate metric IDs for the first user. In many examples of the method of the metric ranges of the user metric space are comfortable or acceptable metric ranges for the first user. The metric space therefore is a collection of those comfortable or acceptable metric ranges. In many exemplary embodiments of the present invention a first user metric space is implemented as a metric space data structure similar to the exemplary metric space of including a user ID and data storage for a list of references to disparate metric ranges.

In many examples of the method of creating a first user metric space includes calling member methods in a metric space service such as createMetricSpace . CreateMetricSpace is in many examples of the method of parameterized with a metric vector ID and the user ID. CreateMetricSpace searches a metric space list for a metric space in dependence upon the user ID and metric vector ID. If the list contains no metric space for the user and metric vector ID then createMetricSpace creates a new metric space with a new metric space ID. CreateMetricSpace returns to its caller a first user metric space including acceptable metric ranges corresponding to the metrics included in the user metric vector.

The method of includes creating a second user metric space comprising a plurality of second user metric ranges. As is the case with the first user metric space a second user metric space is comprised of a plurality of disparate metric ranges for a second user. That is a second user metric space is defined by a plurality of disparate metric ranges for a plurality of disparate metric IDs for the second user. In many examples of the method of the metric ranges of the user metric space are comfortable or acceptable metric ranges for the second user. The metric space therefore is a collection of those comfortable or acceptable metric ranges. In many exemplary embodiments of the present invention a second user metric space is implemented as a metric space data structure similar to the exemplary metric space of including a user ID and data storage for a list of references to disparate metric ranges.

The method of includes creating a mutual metric space in dependence upon the first user metric space and the second user metric space . In many examples of the method of a mutual metric space is a single metric space for the domain. That is in many examples a mutual metric space is a single metric space for multiple users. In typical examples of the method of the mutual metric space is comprised of a plurality of mutual metric ranges each individually determined in dependence upon the metric ranges of the first user metric space and the metric ranges of the second user metric space. In some examples of the method of a mutual metric space includes mutual metric ranges that are the intersection of the metric ranges of the first user metric space and the second user metric space. In some other examples the mutual metric ranges of the mutual metric space are the union of the metric ranges of the first user metric space and the second user metric space.

In some examples of the method of creating a mutual metric space in dependence upon the first user metric space and the second user metric space includes calling member methods in a mutual metric space service such as createMutualMetricSpace . In many such examples createMutualMetricSpace is parameterized with the metric range IDs of the individual metric ranges of the first user metric space and the metric range IDs of the second user metric space and the maximum and minimum values of the metric ranges. createMutualMetricSpace returns to its caller a mutual metric space.

The method of includes determining whether the first user vector is outside the mutual metric space . In various alternative examples of the method of determining whether the first user metric vector is outside the mutual metric space metric space is carried out using different methods. Methods of determining whether the first user metric vector is outside the mutual metric space range in complexity from relatively straightforward comparison of the user metrics of the first user metric vector with their corresponding metric ranges of the mutual metric space to more complex algorithms. Some exemplary methods of determining whether the first user metric vector is outside the mutual metric space are described below with reference to .

If the first user metric vector is outside the mutual metric space the method of includes identifying an action . An action typically includes one or more computer programs subroutines or member methods that when executed control one or more devices. Actions are typically implemented as object oriented classes and manipulated as objects or references to objects. In fact in this specification unless context indicates otherwise the terms action action object and reference to an action object are treated more or less as synonyms. In many examples of the method of an action object calls member methods in a device class to affect current attributes of the physical device. In some examples of the method of action classes or action objects are deployed in OSGi bundles to a DML on a services gateway.

In many examples of the method of an action is designed to administer devices to affect a particular user metric. That is an action administers one or more devices in a manner designed to change the value of a particular metric. In many examples an action is designed to change the value of a user metric of a particular user metric vector that is outside its metric range of the mutual metric space causing the value to be inside its corresponding metric range after executing the action. In other examples the action is designed to react to a user metric. One example of an action designed to react to a user metric is an action that administers devices to call emergency services identified in response to user s heart rate metric being outside the mutual metric space to a large degree.

In many examples of the method of identifying an action includes creating a dynamic action list in dependence upon the first user metric vector. In many examples of the method of a dynamic action list includes action IDs dynamically identified in dependence upon metric action lists associated with particular metrics of the first user metric vector. Associated generally in this disclosure and subject to context means associated by reference. That is saying that an object of one class is associated with another object generally means that the second object possesses a reference to the first. The objects can be mutually associated each possessing a reference to the other. Other relations among objects aggregation composition and so on are usually types of association and the use of any of them as well as others as will occur to those of skill in the art is well within the scope of the present invention. In many examples of the method of each user metric of the first user metric vector has at least one associated metric action list.

In many examples of the method of creating a dynamic action list in dependence upon a first user metric vector includes identifying a metric having a value outside its corresponding metric range of the mutual metric space and retrieving a metric action list associated with that metric. In some examples creating a dynamic action list in dependence upon a first user metric vector includes retrieving at least one action ID from the metric action list and identifying an action for inclusion in the dynamic action list in dependence upon the retrieved action ID of the metric action list.

In some examples of the method of creating a dynamic action list includes calling member methods in a dynamic action service object such as createDynamicActionList parameterized with action IDs retrieved from the metric action lists associated with the metrics of the first user metric vector that are outside of their corresponding mutual metric ranges of the mutual metric space. In many examples of the method of createDynamicActionList returns to its caller a dynamic action list including action IDs identified in dependence upon the action IDs included in the metric action lists. In various alternative examples of the method of a dynamic action list is implemented for example as a hashtable Java list container as a table in random access memory as a SQL database table with storage on a hard drive or CD ROM and in other ways as will occur to those of skill in the art.

The method of includes executing the identified action . Executing the identified action is often carried out in such embodiments by use of a switch statement in the DML. Such a switch statement can be operated in dependence upon the action ID and implemented for example as illustrated by the following segment of pseudocode 

The exemplary switch statement selects a particular device controlling object for execution depending on the action ID. The device controlling objects administered by the switch in this example are concrete action classes named actionNumber1 actionNumber2 and so on each having an executable member method named take action which carries out the actual work implemented by each action class.

In many examples of the method of executing an action is carried out by use of a hash table in a DML. Such a hash table stores references to action object keyed by action ID as shown in the following pseudocode example. This example begins by a dynamic action list service s creating a hashtable of actions references to objects of concrete action classes associated with a particular metric ID using action IDs as keys. In many embodiments it is a dynamic action list service that creates such a hashtable fills it with references to action objects pertinent to a particular metric ID of the first user metric vector outside its corresponding metric range of the mutual metric space and returns a reference to the hashtable to a calling vector object.

Many examples of the method of are also implemented through the use of lists. Lists often function in fashion similar to hashtables. Building such a list can be carried out according to the following pseudocode 

The three examples just above use switch statements hash tables and list objects to explain executing actions according to embodiments of the present invention. The use of switch statements hash tables and list objects in these examples are for explanation not for limitation. In fact there are many ways of executing actions according to embodiments of the present invention as will occur to those of skill in the art and all such ways are well within the scope of the present invention.

In some examples of the method of executing an action includes identifying a device class for the device. Typical device classes include member methods for administering the device. Typical member methods for administering the device include member methods for getting and setting values of device attributes in physical devices. In the case of a lamp supporting multiple settings for light intensity for example a member method get in a device class can gets from the lamp a value for light intensity and a member method set in a device class sets the light intensity for the lamp.

In many examples of the method of executing an action includes identifying a communications class for the device. To communicate the member methods of the device class to the physical device a communications class implements a protocol for communicating with a physical device. Typical communications classes include member methods that construct transmit and receive data communications messages in accordance with the protocol implemented by a communication class. The member methods in a communication class transmit and receive data communications messages to and from a physical device. A communications class advantageously separates the protocols used to communicate with the physical device from the actions effecting the device so that a device class interface comprising get and set methods for example can usefully communicate with a physical device by use of any data communications protocol with no need to reprogram the device class and no need to provide one device class for each combination of physical device and protocol.

In the method of creating a first user metric vector comprising a plurality of disparate metrics for a first user includes filtering the received disparate metrics for the first user. In some examples of the method of filtering the received disparate metrics for the first user includes identifying unfiltered metrics associated with the first user. That is filtering the received disparate metrics for the first user includes identifying unfiltered metrics each representing an indication of the first user s condition. In some examples identifying unfiltered metrics associated with the first user includes reading a user ID from each unfiltered metric or reading an ESN of the metric sensor uniquely identifying the first user from each unfiltered metric.

In many examples filtering the received disparate metrics for the first user includes instantiating a first user metric for each identified unfiltered metric associated with the first user. In many examples of the method of the instantiated first user metrics are objects of a metric class each including a user ID identifying the first user. In many examples of the method of the first user metrics also include a metric ID and a metric value. In many examples of the method of instantiating a first user metric for each identified unfiltered metric associated with the first user includes calling a member method in a metric service object such as createMetricObject parameterized with the user ID a metric ID and metric value of each identified unfiltered metric associated with the first user.

In the method of creating a first user metric vector includes associating a plurality of disparate first user metrics with the first user metric vector . As discusses above associated generally in this disclosure and subject to context means associated by reference. In some examples of the method of associating the plurality of disparate first user metrics with the first user metric vector includes creating a metric list hashtable or other data structure in the first user metric vector that includes references to a plurality of disparate metric objects.

In the method of creating a first user metric vector comprising a plurality of disparate first user metrics includes associating at least one first user metric action list with each disparate first user metric . The action IDs included in a metric action list associated with a particular first user metric identify actions designed to administer devices in accordance with the particular aspect of user condition represented by that first user metric. That is a metric action list is often tailored to affect the user condition represented by the metric. For example a metric list associated with a body temperature metric may include actions that administer devices such as an air conditioner a fan a heater automated window shades an the like.

In many examples of the method of creating a first user metric vector includes associating a plurality of first user metric action lists with a single metric. Some such examples of the method of include associating one metric action list with the first user metric including action IDs identified when the value of the first user metric is above corresponding metric range in a mutual metric space and another first user metric action list including action IDs identified when the value of the first user metric is below its corresponding metric range in a mutual metric space.

Although the method of is illustrated and described as a method for creating a first user metric vector the method is equally well suited to create a user metric vector for each user in the domain. That is in many examples of the present invention a metric vector for a second user in the domain is created using the same method used to create the metric vector for the first user.

In many examples of the method of identifying a plurality of first user metric ranges and associating the plurality of first user metric ranges with the first user metric space is carried out by a metric space service that is instantiated by a DML. The metric space service receives from calling methods in a first user metric vector a user metric vector ID and searches a metric space list identified by metric vector ID for a first user metric space. The metric space service returns to its caller a reference to a first user metric space. If there is no metric space for the metric vector ID the metric space service instantiates one stores the metric space ID in the metric space table and passes to its caller a reference to the newly instantiated first user metric space.

Although the method of is illustrated and described as a method for creating a first user metric space the method is equally well suited to create a metric space for each user in the domain. That is in many examples of the present invention a metric space for a second user in the domain is created using the same method used to create the metric space for the first user.

In many examples of the method of determining an intersection of a first user metric range and a second user metric range includes comparing the maximum value of the first user metric range and the maximum value of the second user metric range and determining which is a lesser value. In typical examples of the method of determining an intersection of a first user metric range and a second user metric range also includes comparing the minimum value of the first user metric range with the minimum value of the second user metric range and determining which is greater.

The method of includes creating a mutual metric range in dependence upon the intersection of the first user metric range and the second user metric range . In many examples of the present invention creating a mutual metric range includes storing as a maximum value of the mutual metric range the lesser value of the maximum value of the first user metric range and the maximum value of the second user metric range. In many examples of the method of creating a mutual metric range also includes storing as a minimum value of the mutual metric range the greater value of the minimum value of the first user metric range and the minimum value of the second user metric range.

The method of includes associating the mutual metric range with the mutual metric space . In many examples of the method of associated the mutual metric range with the metric space includes providing a reference to a mutual metric range object within a mutual metric space object. In many such examples a metric space object includes a data structure such as a list hashtable or any other data structure including references to each mutual metric range object.

In many examples of the method of determining a union of a first user metric range and a second user metric range includes identifying the maximum value and the minimum of the first user metric range and the second user metric range. Determining the union of the first user metric range and the second user metric range includes comparing the maximum value of the first user metric range to the maximum value of the second user metric range and determining which value is a greater value. Determining the union of the first user metric range and the second user metric range includes comparing the minimum value of the first user metric range to the minimum value of the second user metric range and determining which value is a lesser value.

The method of includes creating a mutual metric range in dependence upon the union of the first user metric range and the second user metric range . In many examples of the method of creating a mutual metric range in dependence upon the union of the first user metric range and the second user metric range includes storing as a maximum value of the mutual metric range the greater value between the maximum value of the first user metric range and the maximum value of the second user metric range. In many examples of the method of creating a mutual metric range in dependence upon the union of the first user metric range and the second user metric range also includes storing as a minimum value of the mutual metric range the lesser value between the minimum value of the first user metric range and the minimum value of the second user metric range.

The method of includes associating the mutual metric range with the mutual metric space . In many examples of the method of associating the mutual metric range with the metric space includes providing a reference to a mutual metric range object within a metric space object. In many such examples a metric space object includes a data structure such as a list hashtable or any other data structure including references to each mutual metric range object.

In some examples of the first illustrated method of determining whether the first user metric vector is outside the mutual metric space is a function of multiple individual comparisons between first user metric values and mutual metric ranges. In various alternative examples different criteria are used to identify the number of first user metric values that must be outside their corresponding mutual metric ranges or the degree to which any first user metric value is outside its corresponding mutual metric range to determine that the first user metric vector is outside the mutual metric space. In some examples of the illustrated method using a strict criteria for determining whether a first user metric vector is outside a mutual metric space if only one first user metric value is outside its corresponding mutual metric range then the first user metric vector is determined to be outside the mutual metric space. In other examples using less strict criteria for determining if a first user metric vector is outside a mutual metric space a first user metric vector is determined to be outside the mutual metric space if all of the metric values of the first user metric vector are outside their corresponding mutual metric ranges by a certain degree. In various embodiments the number of metric values that must be outside their corresponding metric ranges or the degree to which a metric must be outside its corresponding metric range to make a determination that the user metric vector is outside the mutual metric space will vary all such methods of determining whether a first user metric vector is outside a mutual metric space are well within the scope of the present invention.

The second method of determining whether the first user metric vector is outside the mutual metric space illustrated in includes calculating a metric vector value and calculating a mutual metric space value and comparing the metric vector value to the metric space value . One way of calculating a metric vector value is by using a predetermined formula to identify a single value that is a function of the metric values of the first user metric vector. In one such example calculating a metric vector value includes averaging the metric values of the first user metric vector. In another example calculating a metric vector value includes prioritizing certain kinds of metrics and using a weighted average based on the priority of the metric to calculate a metric vector value.

In some examples of the second illustrated method of calculating a mutual metric space value includes using a predetermined formula to determine a mutual metric space value that is a function of the minimum and maximum values of each mutual metric range of the mutual metric space. In one example calculating a mutual metric space value includes finding the center point of the minimum and maximum values of the each mutual metric range and then averaging the center points.

The second illustrated method of includes comparing the metric space value and the mutual metric vector value . In various examples how the metric vector value and the mutual metric space value are compared to determine whether the first user metric vector is outside the mutual metric space will vary. In one example the metric vector value is subtracted from the mutual metric space value. If the result of the subtraction is within a predetermined range then the first user metric vector is determined to be within the mutual metric space. In the same example if the result of the subtraction is not within the predetermined range then the first user metric value is not determined to be within the mutual metric space.

The illustrated methods of are provided for explanation and not for limitation. There are many other ways mutual metric ranges and metric values can be compared combined manipulated or otherwise used to make a determination that a first user metric vector is outside a mutual metric space. All such ways of comparing combining manipulating or otherwise using metric values and mutual metric ranges to make a determination that a first user metric vector is outside a mutual metric space are included within the scope of the present invention.

In the method of creating a dynamic action list in dependence upon the first user metric vector includes identifying each first user metric having a value outside of its corresponding a mutual metric range of the mutual metric space and identifying a first user metric action list associated with each of those first user metrics. The first user metrics outside their mutual metric ranges are in many examples identified when the first user metrics are compared with their corresponding mutual metric ranges to determine if the first user metric vector is outside the mutual metric space. In many examples of the method of identifying a first user action list includes retrieving a reference to the first user action list from a first user metric object .

In many examples of the method of a first user metric has a plurality of associated first user action lists. Each associated first user action list includes a set of action IDs identified in dependence upon the degree and direction that the value of the first user metric is outside the mutual metric range. In some examples of the method of therefore identifying a first user action list includes identifying a first user action list in dependence upon a degree to which the value of a first user metric of the first user metric vector is outside a mutual metric range of the user mutual metric space. In another example of the method of identifying a first user action list for a first user metric of the user metric vector having a value that is outside a mutual metric range of the mutual metric space includes identifying a first user action list in dependence upon a direction that the value of the first user metric of the first user metric vector is outside a mutual metric range of the mutual metric space.

In the method of creating a dynamic action list includes retrieving at least one action ID from each first user action list . Some first user action lists include a plurality of action IDs and therefore many examples of the method of include retrieving a plurality of action IDs from the first user action lists.

In the method of creating a dynamic action list includes identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists . In many examples of the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes identifying an action ID retrieved directly from the first user action lists themselves for inclusion in the dynamic action list. That is in some examples of the method of the same action ID retrieved from a first user action list is included in the dynamic action list.

In the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes comparing the action IDs of the first user action lists and omitting repetitious actions. In some examples of the method of omitting repetitious actions includes determining that the same action ID is included in more than one first user action list. In such examples creating a dynamic action list includes identifying first user action lists having the same action IDs and including the action ID only once in the dynamic action list.

In the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes retrieving an action ID from a dynamic action table in dependence upon at least one action ID of the first user action lists and storing the action ID in the dynamic action list . In many examples of the method of a dynamic action table is a data structure including action IDs indexed by other action IDs. That is the dynamic action table is a data structure designed to index predetermined action IDs for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists.

In many examples of the method of a dynamic action table is designed to identify conflicting actions retrieved from the first user action lists identify superseding actions retrieved from the first user action lists as well as identify further actions not included in any of the first user action lists. In some examples of the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes omitting conflicting actions. In many examples of the method of a dynamic action table is used to identify action IDs that have been predetermined to conflict. For example an action ID included in one first user action list that identifies a device controlling action to turn on a ceiling fan conflicts with an action ID identifying a device controlling action to turn off the same ceiling fan. Such conflicting action IDs are omitted from the dynamic action list.

In some examples of the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes omitting superseded actions. A superseded action is an action that when executed administers the same device in the same direction as another action but administers the device to a lesser degree than the other action. That is an action is superseded when another action administers the same device to a greater degree such that the execution of superseded action is cloaked by execution of the superseding action. For example the execution of an action ID that results in changing the value of a current attribute of a ceiling fan from 5 to 4 is superseded by the execution of an action ID that results in changing the same ceiling fan attribute from 5 to 2. In many examples of the method of a dynamic action table is used to identify action IDs that have been predetermined to supersede other actions IDs. Many examples of the method of include omitting the superseded action IDs from the dynamic action list and including the superseding action ID.

In the method of identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user action lists includes identifying an action ID for inclusion in the dynamic action list that is not included in any of the identified first user action lists . In many examples of the method of an action ID identified by a lookup in the dynamic action table is not included in any of the identified first user action lists. In some of these examples the dynamic action table is populated with action IDs that have been predetermined to affect the same user condition when executed as other action IDs. Such a dynamic action table is indexed to identify an action ID for execution when one or more other action IDs are retrieved from the first user action lists. In this way dynamic action tables advantageously provide a vehicle for identifying and executing more actions to affect the user s current condition.

For further explanation of identifying action IDs that are not included in any first user action list associated with a user metric outside its corresponding range the following example is provided. Two user metrics of a first user metric vector are above their corresponding mutual metric ranges of the mutual metric space. The first user metric is above a mutual metric range for body temperature. The body temperature metric has an associated first user action list including an action ID that when executed results in turning on a ceiling fan. The first user vector also has a heart rate metric above its corresponding mutual metric range. The first user s heart rate metric has an associated first user action list including an action ID that when executed turns on an air conditioner.

A lookup in a dynamic action table in dependence upon the action ID associated with the body temperature metric and the action ID associated with the heart rate metric retrieves a third action ID that is not included in either first user action list associated with either the first user s body temperature metric or the first user s heart rate metric. Executing the third action ID results in turning on the ceiling fan turning on the air conditioner and drawing automated window curtains. The added action of drawing automated window curtains is predetermined to affect the same metrics as turning on the air conditioner and the ceiling fan. A lookup on the dynamic action table identifies the third action ID for inclusion in the dynamic action list in dependence upon the action ID associated with the body temperature metric and the action ID associated with the heart rate metric.

In many cases more than one user may be outside a mutual metric space. is a dataflow diagram illustrating an exemplary method of determining whether a second user metric vector is outside the mutual metric space . is a data flow diagram illustrating two exemplary methods of determining whether the second user metric vector is outside the user mutual metric space . The first illustrated method of determining whether the second user metric vector is outside the mutual metric space includes comparing a metric value of the second user metric of the second user metric vector with a mutual metric range of the mutual metric space . In some examples of the illustrated method comparing a metric value of a second user metric vector with its corresponding metric range includes measuring a degree to which the value of a user metric is outside a predefined metric range and identifying if the value of the user metric is above the mutual metric range or below the mutual metric range.

In some examples of the first illustrated method of determining whether the second user metric vector is outside the mutual metric space is a function of multiple individual comparisons between second user metric values and mutual metric ranges. In various alternative examples different criteria are used to identify the number of the second user s metric values that must be outside their corresponding mutual metric ranges or the degree to which any second user s metric value is outside its corresponding mutual metric range to determine that the second user metric vector is outside the mutual metric space. In some examples of the illustrated method using a strict criteria for determining whether a second user metric vector is outside a mutual metric space if only one metric value is outside its corresponding metric range then the second user metric vector is determined to be outside the mutual metric space. In other examples using less strict criteria for determining if a second user metric vector is outside a user mutual metric space a second user metric vector is determined to be outside the mutual metric space if all of the metric values of the second user metric vector are outside their corresponding mutual metric ranges by a certain degree. In various embodiments the number of metric values that must be outside their corresponding mutual metric ranges or the degree to which the value of a second user s metric must be outside its corresponding mutual metric range to make a determination that the second user metric vector is outside the mutual metric space will vary all such methods of determining whether a second user metric vector is outside a mutual metric space are well within the scope of the present invention.

The second method of determining that the second user metric vector is outside the mutual metric space illustrated in includes calculating a second user metric vector value and calculating a mutual metric space value and comparing the second user metric vector value to the mutual metric space value . One way of calculating a second user metric vector value is by using a predetermined formula to identify a single value that is a function of the metric values of the second user metric vector. In one such example calculating a second user metric vector value includes averaging the metric values of the second user metric vector. In another example calculating a second user metric vector value includes prioritizing certain kinds of metrics and using a weighted average based on the priority of the metric to calculate a second user metric vector value.

In some examples of the second illustrated method of calculating a mutual metric space value includes using a predetermined formula to determine a mutual metric space value that is a function of the minimum and maximum values of each mutual metric range of the user mutual metric space. In one example embodiment calculating a mutual metric space value includes finding the center point of the minimum and maximum values of the each metric range and then averaging the center points.

The second illustrated method of includes comparing the mutual metric space value and the second user metric vector value . In various examples how the second user metric vector value and the mutual metric space value are compared to determine whether the second user metric vector is outside the mutual metric space will vary. In one example the second user metric vector value is subtracted from the mutual metric space value. If the result of the subtraction is within a predetermined range then the second user metric vector is determined to be within the mutual metric space. In the same example if the result of the subtraction is not within the predetermined range then the second user metric vector value is not determined to be within the mutual metric space.

The illustrated methods of are provided for explanation and not for limitation. There are many other ways mutual metric ranges and a second user s metric values can be compared combined manipulated or otherwise used to make a determination that a second user metric vector is outside a mutual metric space. All such ways of comparing combining manipulating or otherwise using metric values and metric ranges to make a determination that a second user metric vector is outside a mutual metric space are included within the scope of the present invention.

As discussed above often multiple metric vectors for multiple user s are simultaneously outside the mutual metric space. Often when multiple metric vectors for multiple users are outside the mutual metric space device controlling actions are identified in dependence upon each metric vector outside the mutual metric space. is a data flow diagram illustrating an exemplary method of identifying an action . In the method of identifying an action includes creating a dynamic action list in dependence upon first user metric vector and the second user vector . In many such examples dynamic action lists include action IDs identified dynamically in dependence upon the action IDs included within the metric action lists associated with the particular user metrics outside their corresponding mutual metric ranges.

In the method of creating a dynamic action list in dependence upon the first user metric vector and the second user metric vector includes identifying a first user metric action list for each user metric of the first user metric vector having a value that is outside a mutual metric range of the mutual metric space. In many examples of the method of identifying a first user metric action list for each user metric of the first user metric vector that is outside its corresponding a mutual metric range of the mutual metric space includes retrieving a reference to the first user metric action list from a first user metric object previously identified as being outside its corresponding metric range when the first user metric vector was determined to be outside the mutual metric space. The metric objects outside their metric ranges are in many examples identified when the metric objects are compared with their metric ranges to determine if the first user metric vector is outside the mutual metric space.

In many examples of the method of a metric of the first user metric vector may have a plurality of associated first user metric action lists. In some examples of the method of therefore identifying a first user metric action list for each user metric of the user metric vector having a value that is outside a mutual metric range of the mutual metric space includes identifying a fist user metric action list in dependence upon a degree to which the value of each metric of the first user metric vector is outside a mutual metric range of the mutual metric space or in dependence upon a direction that the value of each metric of the first user metric vector is outside a mutual metric range of the mutual metric space.

In the method of creating a dynamic action list in dependence upon the first user metric vector and the second user metric space includes identifying a second user metric of the second user metric vector that is outside its corresponding mutual metric range and identifying a second user metric action list associated with that second user metric . In many examples of the method of identifying a second user metric action list associated with the identified second user metric retrieving a reference to the second user metric action list from a second user metric object.

In many examples of the method of a second user metric may have a plurality of associated second user metric action lists. In some examples of the method of therefore identifying a second user metric action list includes identifying a second user metric action list in dependence upon a degree to which the value of the second user metric is outside the mutual metric range or in dependence upon a direction that the value of the user metric is outside the mutual metric range.

In the method of creating in dependence upon the first user metric vector and the second user metric vector dynamic action list includes retrieving at least one action ID from each identified first user metric action list and each identified second user metric action list . Some first user metric action lists and second user metric action lists include a plurality of action IDs and therefore many examples of the method of include retrieving a plurality of action IDs from the first user metric action lists and retrieving a plurality of action IDs from the second user metric action lists.

In the method of creating a dynamic action list in dependence upon the first user metric vector and the second user metric vector includes identifying at least one action ID for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user metric action lists and the action IDs retrieved from the second user action lists . In many examples of the method of identifying at least one action ID for inclusion in the dynamic action list includes identifying an action ID retrieved directly from the first user metric action lists and second user metric action lists themselves for inclusion in the dynamic action list. That is in some examples of the method of the same action ID retrieved from a first user metric action list or a second user metric action list is included in the dynamic action list.

In the method of identifying at least one action ID for inclusion in the dynamic action list includes comparing the action IDs of the first user metric action lists and the second user metric action lists and omitting repetitious actions. In some examples of the method of omitting repetitious actions includes determining that the same action ID is included in more than one first user metric action list or second user metric action list. In such examples creating a dynamic action list includes identifying first user metric action lists and second user metric action lists having the same action IDs and including the action ID only once in the dynamic action list.

In the method of identifying at least one action ID for inclusion in the dynamic action list includes comparing the action IDs of the first user metric action lists and the second user metric action lists with a first user negative action list associated with the first user metric vector and omitting any actions included in the first user negative action list. A first user negative action is a list of action IDs previously designated by the first user as action IDs that are not to be executed. In some examples the action IDs are action IDs that were ineffective in affecting the first user s condition while in other examples the action IDs of the first user negative action list are action IDs the user does not want executed.

Using negative action lists is one way of prioritizing one user over another. By associating negative action lists only with one or more users having increased priority those users having increased priority are given the power to trump the actions of other users. Action IDs that would otherwise be identified and included in the dynamic action list are omitted solely by virtue of their inclusion in a negative action list. These action IDs are therefore not executed no matter how effective the actions may be in affecting the conditions of other lower priority users.

In the method of identifying at least one action ID for inclusion in the dynamic action list includes retrieving an action ID from a dynamic action table in dependence upon at least one action ID of the first user metric action lists or second user metric action lists and storing the action ID in the dynamic action list. In many examples of the method of a dynamic action table is a data structure including action IDs indexed by other action IDs. That is the dynamic action table is a data structure designed to index predetermined action IDs for inclusion in the dynamic action list in dependence upon the action IDs retrieved from the first user metric action lists and second user metric action lists.

In many examples of the method of a dynamic action table is designed to identify conflicting actions retrieved from the first user metric action lists and the second user metric action lists identify superseding actions retrieved from the first user metric action lists and the second user metric action lists as well as identify further actions not included in the first user metric action lists or second user metric action lists. In some examples of the method of identifying at least one action ID for inclusion in the dynamic action list includes omitting conflicting actions. In many examples of the method of a dynamic action table is used to identify action IDs that have been predetermined to conflict. For example an action ID included in one metric action list that identifies a device controlling action to turn on a ceiling fan conflicts with an action ID identifying a device controlling action to turn off the same ceiling fan. Such conflicting action IDs are omitted from the dynamic action list.

In some examples of the method of identifying at least one action ID for inclusion in the dynamic action list includes omitting superseded actions. A superseded action is an action that when executed administers the same device in the same direction as another superseding action but administers the device to a lesser degree than the other superseding action. In many examples of the method of a dynamic action table is used to identify action IDs that have been predetermined to supersede other actions IDs. Many examples of the method of include omitting the superseded action IDs from the dynamic action list and including the superseding action ID.

In the method of identifying at least one action ID for inclusion in the dynamic action list includes identifying an action ID for inclusion in the dynamic action list that is not included in any of the identified first user metric action lists or the second user metric action lists . In many examples of the method of an action ID identified by a lookup in the dynamic action table is not included in any of the identified first user metric action lists or the identified second user metric action list. In some of these examples the dynamic action table is populated with action IDs that have been predetermined to affect the same user condition when executed as other action IDs. Such a dynamic action table is indexed to identify an action ID for execution when one or more other action IDs are retrieved from the first user metric action lists or the second user metric lists.

It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.

