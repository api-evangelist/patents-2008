---

title: System and process for debugging object-oriented programming code leveraging runtime metadata
abstract: A system and process for debugging of a computer program, is provided. One implementation includes a function configured for including mark-up information marking certain methods as special fields in a source code of the application program, such annotations denoting debugging instructions and indications of which methods are intended for debugging only; a processing module configured for generating a production version of the application program including the same semantics as the original application program but potentially fewer methods and no debug related annotations, wherein methods that are not annotated as debugging only methods are maintained; and a debugger configured for debugging purposes using the debugging methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08752020&OS=08752020&RS=08752020
owner: International Business Machines Corporation
number: 08752020
owner_city: Armonk
owner_country: US
publication_date: 20081007
---
The present invention relates generally to software program debugging tools and more particularly to software debugging tools for object oriented software programs.

In existing software debugging tools debuggers while debugging applications written in object oriented OO programming languages objects are presented into a debugger according to their structure that is the fields that their class define. This requires that the fields cleanly map the semantics of the objects. However frequently a class defines parts or whole of its semantics through methods while its fields mostly map to implementation details that may or may not help the developer depending on his focus on the class or classes that use it and his level of knowledge of the class internals. In certain cases the developer intimately knows the class but the class implementation for performance reasons or otherwise encodes its semantics in very difficult to understand fields.

The invention provides a process and system for debugging of a computer program. One embodiment involves a method of debugging an object oriented computer program comprising marking certain methods as special fields in a source code of the application program for participating in a debugging process generating a debug enabled version of the computer program including debugging methods based on the special fields and providing the debug enabled version of the program computer to a debugger module for debugging purposes using the debugging methods.

Other aspects and advantages of the present invention will become apparent from the following detailed description which when taken in conjunction with the drawings illustrate by way of example the principles of the invention.

The following description is made for the purpose of illustrating the general principles of the invention and is not meant to limit the inventive concepts claimed herein. Further particular features described herein can be used in combination with other described features in each of the various possible combinations and permutations. Unless otherwise specifically defined herein all terms are to be given their broadest possible interpretation including meanings implied from the specification as well as meanings understood by those skilled in the art and or as defined in dictionaries treatises etc.

The invention provides a system and process for debugging object oriented programs code by leveraging all eligible methods that have no parameters and returning a value. The invention involves marking certain methods for participating in a debugging process as special fields using programming language annotations. The invention is useful with all languages that are able to carry complex meta data at runtime. An example of such annotation is specific Java programming language annotations. One embodiment includes a function configured for including mark up information marking annotating certain methods as special fields in a source code of the application program such annotations denoting debugging instructions and indications of which methods are intended for debugging only a processing module configured for generating a production version of the application program including the same semantics as the original application program but potentially fewer methods and no debug related annotations wherein methods that are not annotated as debugging methods are maintained and a debugger configured for debugging purposes using the debugging methods. An example implementation is described below.

In object oriented programming a class is a template for creating objects and defines attributes e.g. name value and methods e.g. associated subroutines functions behaviors of each object. shows a functional block diagram of a computer system in which an embodiment of the invention is implemented. Said embodiment of the invention is applicable to debugging e.g. testing and solving programming issues such as errors of objected oriented programs using a graphical user interface GUI debugger. A full fledged graphical windowing system is not required and character based interfaces may be used provided that information can be presented to the user e.g. software developer programmer in a multi views and multi lines format.

The debugging computer system provides a debugging session wherein an object oriented software application is running on a computing system. The application at the moments in time that are of interest to debugging runs executes under the control of a debugger e.g. a software module . The application may run on a computer based system that may include a single machine that comprises a single core processor or a networked system that comprises multiple machines some of which include a single processor or some of which include multiple processors etc.

The debugging computer system further includes a database of symbolic information about the application under test. The database may include various structures use diverse storage technologies be packaged with the executable components of the application etc. The debugger is configured to query information in the database about the application at the level of detail needed to implement its base debugging functions and implement debugging functions according to the invention.

In one implementation the debugger comprises a specialized software module configured to control execution of the application under test and to provide the user of the debugger with tools to diagnose the execution of the application from multiple points of view. The debugger further interacts with the application to selectively interrupt execution of one or more process threads of the application at precise points in time depending on specific conditions. As such the debugger controls execution of the application on behalf of the user leverages the symbolic information to provide debugging functions and interacts with the user via a user interface module .

The user interface module is configured to enable the user to interact with the debugger and control execution of the application and to diagnose the behavior of the application . The user interface provides several views and dialogs that may leverage a graphical user interface or rely upon character based multi line views and dialogs. Said views and dialogs provides controls e.g. interfaces to at least present the user with breakpoints which are points at which the execution of one or more threads of the application can be interrupted. Said views may also provide controls to resume the execution of the application in various manners e.g. step by step up to the following breakpoint etc. .

Preferably said views further include a view which for a given moment in time at which a given thread of the application is stopped at a given point in the executable code of the application presents the user with the variables that are in context. Such variable values are in memory and the application typically uses their addresses to fetch them. The debugger leverages the symbolic information database to fetch types etc.

The view provides controls for filtering part of the available information and for presenting variables that are not of elementary types via means that makes this practical within a finite view i.e. types more complex than simple types of a considered programming language such as int and other integral types chars strings of chars booleans etc. .

The view also provides controls for the user to choose how much of the internal presentation structure of the view should be displayed. It is important to consider the relationship between the view and structured variables e.g. objects and depending on the programming language other structures that are supported by dedicated language features such as arrays tuples etc. . A typical object or class instance may have many fields. Some of these fields can be objects or even of the type of the considered object itself. The view provides controls for the user to focus on presenting a subpart of the available information as desired.

For example the view may provide controls such as scrolling controls for a windowing system wherein the information is presented into what may be considered as an infinite view a small part of which is presented to the user on a display and scroll bars are provided to move up or down parts of the available information.

Another control of the view includes presenting information using a tree hierarchical metaphor wherein only digging deeper into the tree the user can view further information. For example having a Java class X int i X next at hand the three metaphor would involve presenting the user with only the following view 

where the is in fact a control that enables the user to instruct the view to expand the tree doing so could for a given execution of the application result into 

Another control of the view includes filters that leverage properties that are more related e.g. field visibility inherited fields etc. or less related e.g. field name name matching a regular expression etc. to the semantics of the programming language used by the application .

Other controls for the view provides strategies for rendering information on a display for the user may also be implemented. Such strategies may also be combined. The rendering presented in the above examples are eventually subject to various embodiments of the debugger . The operation of an example debugger may rely upon one or more processes described below as described in relation to . Only methods that have a suitable appropriate annotation can be used i.e. methods defining semantic fields . Such methods present pseudo field values along with fields of object typed variables on a user interface for debugging purposes.

At block since the variable is of simple type the debugger fetches the value of that variable which depending on the runtime environment may involve various techniques. For a compiled language such as C this would involve computing the memory address and size of the variable then interpreting the resulting memory chunk according to the variable type. For an interpreted language like Java in which a virtual machine is equipped with dedicated application programming interfaces APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value.

At block the debugger presents information about said variable into the view and the process proceeds to block . The information displayed may include the type name and value of the said variable other information about said variable may also be displayed .

At block if additional variables remain in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and the debugger awaits a next command.

At block referenced above since said variable is of complex type the debugger fetches an identifier for the variable e.g. memory address of the variable or any other value guaranteed to identify the variable . At block the debugger presents information about the variable into the view and the process proceeds to block . The display of information about the variable in view may include the type name and identifier of the variable. The user is also enabled to request the details of the variable value which may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. the user utilizes a contextual menu . The information presented may include automatically or on demand the string representation of the variable e.g. in Java this would result from the call of the toString method upon the object since all classes ultimately inherit from Object .

According to the present invention the debugger further presents in the view the result of the execution of eligible methods upon object typed variables along with the true fields of the said variables. Whenever fields of an object type are considered for eligible methods the process involves deriving a pseudo field name from the annotation or the method name running the method to obtain a pseudo field value and leveraging those names and values as if they were the names and values of a regular field. The short name can be carried by the annotation or else derived from the method name using rules. Eligible methods comprise methods annotated as special fields in a source code of the application program wherein the annotations denote debugging instructions and indications of which methods are intended for debugging only.

At block the debugger interacts with the symbolic information to determine the names and types of the fields of the variable and to elaborate a list of all eligible methods described above which can be called upon the variable. For each of those methods the debugger remembers its name and its return type. Optionally the debugger associates a short name to each method deriving that short name from the annotation or from the method name using rules and uses the resulting short names for sorting in block further below an example annotated source code is shown in Table 1 and described further below .

At block optionally the debugger filters out some of the fields and methods based upon various criteria and only retains the remaining ones for presentation.

At block optionally the debugger sorts the collection of fields and methods according to sorting criteria associated with the view or the debugger itself. Depending on the sorting criteria the fields and methods may be interleaved.

At block the debugger selects the first field or method of the variable and removes it from the list of fields and variables to be considered.

At block if the field or the method return value is of complex type then the process proceeds to block otherwise the process proceeds in sequence to block .

At block if a field was obtained at block the debugger determines the value of the field for the considered variable. Depending on the runtime environment this may involve various techniques e.g. for a compiled language such as C this would involve computing the memory address and size of the field then interpreting the resulting memory chunk according to the field type for an interpreted language such as Java in which a virtual machine is equipped with dedicated APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value . If at block a method was obtained then in block herein the debugger calls that method upon the variable at hand to get a value.

At block if a field was obtained at block then the debugger displays the field related information via the view then proceeds to block . The information displayed may include the type name and value of the said field other information may be displayed . If at block a method was obtained the debugger performs the same as for a field using the name of the method or the short name associated to the method as if it was a field name and the value computed at block as a field value.

At block if a field was obtained at block then since the field is of complex type the debugger fetches an identifier for the field e.g. this can be its memory address or any other value guaranteed to identify the field . If a method was obtained at then at the debugger calls that method upon the variable at hand to obtain any missing information e.g. determine if the value is null or it points to a specific memory location .

At block if a field was obtained at then the debugger presents the field into the view then the process proceeds to . The presentation of the field typically includes the type name if its enclosing type and identifier of the field. The user is also enabled to request for the details of the field value. This may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. when a contextual menu is provided . The information that is presented may include automatically or on demand the string representation of the field e.g. in Java this would result from the call of the toString method upon the object since all classes ultimately inherit from Object . If a method was obtained at then at the debugger performs the same as for a field using the name of the method or the short name associated to the method as if it was a field name and the information computed at .

At block if there are more fields or methods to handle for the considered complex variable the process loops back to block otherwise the process proceeds to block for completion and awaiting next commands.

At block the debugger presents the user in the user interface with information about the current point of execution of the application . At block the debugger collects the variables that are in scope at the current point of execution again . At block optionally the debugger filters out some of the variables based upon various criteria and only retains the remaining ones as needing to be presented. At block optionally the debugger sorts the variables according to sorting associated with the view or the debugger itself. At block the debugger selects the first variable in scope and removes it from the list of variables to handle. At block the debugger tests whether the current variable was already displayed in view or not. If not the process proceeds to block otherwise the process continues to block .

At block the debugger utilizes the process of starting at block and ending before block then branches to block instead of from block and . In effect the debugger handles the display of a variable that was not in scope at the former breakpoint.

At block the variable being considered was already displayed in view wherein the debugger considers whether the variable is of complex type or not. If the variable is of complex type the process branches to block otherwise the process continues to block . At block since the variable being considered is of simple type the debugger fetches the values of the variable. At block the debugger refreshes the variable display into the view then proceeds to block . In one implementation a brute force approach is used to simply display the variable as if it had not been seen at the previous step. In another implementation it is determined which variables may have changed and which have not changed and only the ones changed are refreshed.

At block since the variable being considered is of complex type it is refreshed accordingly an example is described in conjunction with further below . At block if there are more variables in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and awaiting a next user command.

At block since the variable is of simple type the value of the variable is fetched. At block the value of the variable is refreshed in the view and the process proceeds to block . At block since the variable is of complex type it is checked against void e.g. null in Java or 0 in C programming language . If the variable is void the process proceeds to block else the process proceeds to block .

At block since the variable of complex type is void it is displayed as such in the view this includes pruning the subtree that previously showed detailed values for the same variable at the previous breakpoint if any . The process then proceeds to block .

At block since a variable of complex type is non void it is checked if its details were displayed or not. If not the process proceeds to block otherwise the process proceeds to block .

At block since a non void variable of complex type was displayed without its details or was displayed with details but changed its type the display of its value is refreshed e.g. display the same information as that in block in . The process then proceeds to step .

At block since a non void variable of complex type was displayed with its details it is checked if its type has changed or not. If yes the process proceeds to block else the process proceeds to block .

At block since a non void variable of complex type was displayed with its details and its type has not changed its fields and suitable methods are collected. There are both real fields and semantic fields as for any complex type variable or method result.

At block optionally the debugger filters out some of the fields methods based upon various criteria and only retains the remaining ones as needing to be presented.

At block optionally the debugger sorts the fields methods according to sorting criteria associated with the view or the debugger itself.

At block the first field methods that is still to be handled is selected and removed from the list of fields methods to handle.

At block if there are more fields methods on the stack to handle the process loops back to block else the process loops back to block .

At block the stack is empty and all visible variables have been refreshed wherein the process proceeds to block .

Blocks use the eligible method short name and return the value computed at block as if they were the name and value of a field. The short name can be carried by the annotation or else derived from the method name using rules.

Another example involves calling methods more sparingly. The debugger presents methods as special fields and provides the user with controls to call them either individually or batches at a time. There is a continuum of possible implementations ranging from systematic execution described hereinabove to the display of a refresh indicator close to each special field which the user would have to click to obtain the corresponding value.

Embodiments of the present invention are applicable to programming languages that provide a way to add to source annotations that translate into runtime metadata. This includes Java and may include interpreted programming languages and certain compiled programming languages.

In the case of compiled programs it is common practice to pass compiler specific options to produce a debug enabled version of the executable application that version carries sufficient information for the debugger to interpret memory and registers contents and to modify the memory and registers contents with the effect of assigning new values to attributes or running methods of objects this is not using introspection per se but points to the same needed basic abilities i.e. access to an object instance access to its type description read its attributes execute its methods.

While all methods that take no parameter and return a value are eligible as methods that could be annotated as debug methods other methods may be eligible in other implementations and the debugger may be further limitative but upon the set of annotated methods not upon the set of all possible eligible methods . For example the debugger may apply matching and filtering rules to select certain methods.

The invention only leverages the user code as it is written and can be readily adopted by diverse debuggers without requiring sharing of knowledge about the debugger implementations. The invention can be reused with logging frameworks since the invention enables writing of rendering methods that are available with the code under test wherein said methods can be reused for other debugging purposes and especially logging. The invention further provides efficient encapsulation wherein the effort of bridging the internals towards semantics is left with the class under test author which is the most capable of doing so.

Now as noted in one embodiment of the invention certain methods are marked for participating in a debugging process as special fields using specific Java programming language annotations. Such annotations and their values are compiled into an executable application i.e. debug enabled version of the computer program including debug methods which the debugger can read and utilize at debug time. Then using the steps described further above the debugger provides the view with the special fields. The marked binary files can optionally be further processed by a post processor to eliminate some or all of said methods thereby generating a production system from binaries.

While the example embodiment herein is described in relation to Java and Java annotations those skilled in the art recognize that the invention is useful with all languages that are able to carry complex meta data at runtime. The production ready application can be derived from the binaries without the end user ever receiving the sources moreover it is typically simpler to strip binaries than to rebuild a full system from its sources which means that the developer has the option to provide a single version of the binaries the debug enabled one along with simple tools a post processor that can address one binary file at a time to derive a production version. If methods names conflicts are to occur they appear immediately at the source level in the source code editor and can be readily addressed.

The debugger has access to annotation information at runtime JPDA Java Platform Debugger Architecture JPDA specifies that methods bear attributes that can be retrieved. Further Java Language Specification Third edition specifies that if annotation a bears an annotation. Retention meta annotation valued to annotation.RetentionPolicy.RUNTIME the reflective libraries of the Java platform will make annotations a available at run time as well. Said information is stored into the binary files according to the Java Virtual Machine specification into attributes which can be read through the appropriate JPDA API the JVM Tool Interface aka JVMTI . A test compiling of the example annotated code in Table I below results into a class file containing the RuntimeVisibleAnnotations attribute which contains a Debug annotation and the explicit valuations of its members the default valuations are read from the Debug binary type itself . As such a specific instance of the class Employee from the example annotated code in Table I will appear in the debugger interface as the example GUI in .

Annotations allow flexibility in specifying values that can be extended to complex concepts such as specifying strings that are to be interpreted as parameter values. An annotation can have array valued members which provides a means to specify more than one special field for a single method by valuating several series of parameters. The invention is compatible with the use of different annotations provided that the debugger has knowledge of which annotations to consider and how to use their values . The projection of the annotations into the binary class files need no specifics conformant Java compilers provide such projection provided that the Debug annotation is marked with RUNTIME retention . As noted the short name can be carried by the annotation or else derived from the method name using rules specifically in another example in Table 2 below 

wherein the pseudo field is named gender which is unrelated to the method name except by implied semantics that only human beings can understand .

A determination by the debugger of the list of methods which bear the Debug attribute uses standard application programming interfaces APIs . The interpretation of a Debug annotation for debug purpose in this example and the use of specific properties for Debug itself must be synchronized between the source code for Debug the source code for the application which must make use of the appropriate members for the annotation and the debugger itself which must interpret the properties of the annotation properly . The same requirements apply to said post processor.

The embodiment described herein applies to applications written in the Java programming language with appropriate annotations as described or to applications written in other languages displaying capabilities similar to those of the Java language in the meta descriptions realm. Applications suitably annotated by their author are normally fed to a Java compiler and result into application binaries in the form of Java class files which may or may not be packaged into compressed files. Those binaries bear said annotations in their binary format. They are fed at debug time to the debugger further parameterized as follows. In step of the debugger only selects the methods which are annotated as being eligible and derives the name of a pseudo attribute from the annotation or the method name. In step of the debugger derives the name of the pseudo attribute from the annotation or the method name. In step the debugger only selects the methods which are annotated as being eligible.

In this example the annotations and their values are compiled into an executable application including debug methods which a debugger can read and utilize at debug time. Specifically a compiler transforms source files to binary application including debug methods suitable for debugger and the symbolic information leveraged accordingly.

The application comprises a binary debug ready application. The database includes symbolic information associated to the debug ready application . The debugger selects the methods that bear the annotation in the binary files . The name of the semantic field can be derived from the method name using rules or else from values borne by the annotation or a combination of the two e.g. fetch the name in the annotation if any else derive it from the method name .

The invention further provides elaboration of production applications from the binaries described above as detailed by example in a process depicted in . The binary files of the application which contain in their binary format the annotations discussed above can be transformed into smaller more efficient binaries by a processor e.g. P . The binaries are for an application meant for production which has the same semantics as the original application but potentially fewer methods and no debug related annotations. As such the binaries are optimized along the volume axis at least and will have beneficial time impact for large applications . The binaries can be produced as early as development time and as late as deployment time provided that the processor is released to the personnel in charge of deployment. The processor e.g. software module is configured for converting binaries to binaries and need only have knowledge of how to manipulate Java binaries and annotations. Such annotation in application denote debug instructions and indications of which methods are intended for debugging only and can be removed note that the annotations themselves can all be removed but methods that are not annotated as debug only must be maintained .

PCI bus provides an interface for a variety of devices that are shared by host processor s and Service Processor including for example flash memory . PCI to ISA bridge provides bus control to handle transfers between PCI bus and ISA bus universal serial bus USB functionality power management functionality and can include other functional elements not shown such as a real time clock RTC DMA control interrupt support and system management bus support. Nonvolatile RAM is attached to ISA Bus . Service Processor includes JTAG and I2C busses for communication with processor s during initialization steps. JTAG I2C busses are also coupled to L2 cache Host to PCI bridge and main memory providing a communications path between the processor the Service Processor the L2 cache the Host to PCI bridge and the main memory. Service Processor also has access to system power resources for powering down information handling device .

Peripheral devices and input output I O devices can be attached to various interfaces e.g. parallel interface serial interface keyboard interface and mouse interface coupled to ISA bus . Alternatively many I O devices can be accommodated by a super I O controller not shown attached to ISA bus .

In order to attach the computer system to another computer system to copy files over a network LAN card is coupled to PCI bus . Similarly to connect computer system to an ISP to connect to the Internet using a telephone line connection modem is connected to serial port and PCI to ISA Bridge .

While the computer system described in is capable of executing the processes described herein this computer system is simply one example of a computer system. Those skilled in the art will appreciate that many other computer system designs having one or more processors are capable of performing the processes described herein.

As is known to those skilled in the art the aforementioned example embodiments described above according to the present invention can be implemented in many ways such as program instructions for execution by a processor as software modules as computer program product on computer readable media as logic circuits as silicon wafers as integrated circuits as application specific integrated circuits as firmware etc. Though the present invention has been described with reference to certain versions thereof however other versions are possible. Therefore the spirit and scope of the appended claims should not be limited to the description of the preferred versions contained herein.

The terms computer program medium computer usable medium computer readable medium and computer program product are used to generally refer to media such main memory secondary memory removable storage drive a hard disk installed in hard disk drive and signals. These computer program products are means for providing software to the computer system. The computer readable medium allows the computer system to read data instructions messages or message packets and other computer readable information from the computer readable medium. The computer readable medium for example may include non volatile memory such as a floppy disk ROM flash memory disk drive memory a CD ROM and other permanent storage. It is useful for example for transporting information such as data and computer instructions between computer systems. Furthermore the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and or a network interface including a wired network or a wireless network that allow a computer to read such computer readable information. Computer programs also called computer control logic are stored in main memory and or secondary memory. Computer programs may also be received via a communications interface. Such computer programs when executed enable the computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable the processor multi core processor to perform the features of the computer system. Accordingly such computer programs represent controllers of the computer system.

Those skilled in the art will appreciate that various adaptations and modifications of the just described preferred embodiments can be configured without departing from the scope and spirit of the invention. Therefore it is to be understood that within the scope of the appended claims the invention may be practiced other than as specifically described herein.

