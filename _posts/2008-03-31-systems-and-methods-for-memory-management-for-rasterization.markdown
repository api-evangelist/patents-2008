---

title: Systems and methods for memory management for rasterization
abstract: Methods for managing a single memory pool comprising frame buffer memory and display list memory are presented. The single memory pool can comprise sub-pools including: a super-block pool comprising a plurality of super-block objects; a node pool comprising a plurality of node objects; and a block-pool comprising a plurality of blocks. The method may comprise: receiving a memory allocation request directed to at least one of the sub-pools; allocating an object local to the sub-pool identified in the memory request, if local sub-pool objects are available to satisfy the memory request; allocating an object from super-block pool, if the memory request is directed to the node-pool or block-pool and there are no available local objects in the respective sub-pools to satisfy the memory request; and applying at least one of a plurality of memory freeing strategies, if the sub-pools lack available free objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782371&OS=08782371&RS=08782371
owner: Konica Minolta Laboratory U.S.A., Inc.
number: 08782371
owner_city: San Mateo
owner_country: US
publication_date: 20080331
---
The present invention relates to the field of printing and in particular to systems and methods for memory management for rasterization.

Document processing software allows users to view edit process and store documents conveniently. Pages in a document may be displayed on screen exactly as they would appear in print. However before the document can be printed pages in the document are often described in a page description language PDL . As used in this document PDL s may include PostScript Adobe PDF HP PCL Microsoft XPS and variants thereof as well as any other languages used to describe pages in a document. A PDL description of a document provides a high level description of each page in a document. This PDL description is often translated to a series of lower level printer specific commands when the document is being printed. The process of translation from a PDL description of a document to a lower level description that may be used to place marks on a print medium is termed rasterization.

The translation process from PDL to lower level printer specific commands may be complex and depend on the features and capabilities offered by a particular printer. Flexible and portable general purpose schemes to translate PDL descriptions of documents to printer specific commands may allow for the optimization of printer performance based on available memory desired print speed and other cost and performance criteria.

Traditionally memory in printing systems has been organized in two distinct pools comprising the display list memory and the frame buffer memory. Display list memory typically holds display list objects for rasterization while the frame buffer memory typically holds bitmapped data specifying marks to be made on a printed page. The use of separate memory pools prevents the use of display list memory for frame buffer purposes and vice versa. Print failures can occur due to insufficient memory in either pool. In such situations there may be sufficient extra memory in the one pool but the memory is unavailable for use in the other memory pool because of the separate nature of the two pools. Moreover the use of separate memory management routines to manage display list and frame buffer memory pools may make it difficult to modify and maintain the code used to manage memory across a product family because different strategies and optimizations may be used in individual products. For example when display list memory is exhausted one product may trigger pre rasterization whereas another product may swap display list memory to disk. The lack of uniformity and the often disparate assortment of memory management routines implemented greatly increases the difficulty of rolling out updates and improving functionality and performance.

Thus there is a need for systems and methods to manage memory on printers for rasterization that would allow a seamless upgrade path while providing additional optimizations.

Consistent with disclosed embodiments systems and methods for managing a single memory pool comprising frame buffer memory and display list memory are presented. In some embodiments the single memory pool can comprise sub pools including a super block pool comprising a plurality of super block objects a node pool comprising a plurality of node objects and a block pool comprising a plurality of blocks. The method may comprise receiving a memory allocation request directed to at least one of the sub pools allocating an object local to the sub pool in response to the memory request if local objects are available in the sub pool to satisfy the memory request allocating an object from super block pool in response to the memory request if the memory request is directed to the node pool or the block pool and there are no available local objects in the respective sub pools to satisfy the memory request and applying at least one of a plurality of memory freeing strategies if there are no free objects available in any of the sub pools.

Embodiments also relate to methods created stored accessed or modified by processors using computer readable media or computer readable memory.

In accordance with embodiments reflecting various features of the present invention systems and methods for the automatic storing manipulating and processing of a second or intermediate form of printable data generated from a first printable data are presented. In some embodiments the first printable data may take the form of a PDL description of a document and the intermediate printable data may take the form of a display list of objects generated from the PDL description.

As shown in exemplary system includes computers including a computing device and a server . Further computing device and server may communicate over a connection which may pass through network which in one case could be the Internet. Computing device may be a computer workstation desktop computer laptop computer or any other computing device capable of being used in a networked environment. Server may be a platform capable of connecting to computing device and other devices not shown . Computing device and server may be capable of executing software not shown that allows the printing of documents using printers .

Exemplary printer includes devices that produce physical documents from electronic data including but not limited to laser printers ink jet printers LED printers plotters facsimile machines and digital copiers. In some embodiments printer may also be capable of directly printing documents received from computing device or server over connection . In some embodiments such an arrangement may allow for the direct printing of documents with or without additional processing by computing device or server . In some embodiments documents may contain one or more of text graphics and images. In some embodiments printer may receive PDL descriptions of documents for printing. Note too that document print processing can be distributed. Thus computing device server and or the printer may perform portions of document print processing such as half toning color matching and or other manipulation processes before a document is physically printed by printer .

Computing device also contains removable media drive . Removable media drive may include for example 3.5 inch floppy drives CD ROM drives DVD ROM drives CD RW or DVD RW drives USB flash drives and or any other removable media drives consistent with embodiments of the present invention. In some embodiments portions of the software application may reside on removable media and be read and executed by computing device using removable media drive .

Connection couples computing device server and printer and may be implemented as a wired or wireless connection using conventional communication protocols and or data port interfaces. In general connections can be any communication channel that allows transmission of data between the devices. In one embodiment for example the devices may be provided with conventional data ports such as parallel ports serial ports Ethernet USB SCSI FIREWIRE and or coaxial cable ports for transmission of data through the appropriate connection. In some embodiments connection may be a Digital Subscriber Line DSL an Asymmetric Digital Subscriber Line ADSL or a cable connection. The communication links could be wireless links or wired links or any combination consistent with embodiments of the present invention that allows communication between the various devices.

Network could include a Local Area Network LAN a Wide Area Network WAN or the Internet. In some embodiments information sent over network may be encrypted to ensure the security of the data being transmitted. Printer may be connected to network through connection . In some embodiments printer may also be connected directly to computing device and or server . System may also include other peripheral devices not shown according to some embodiments of the present invention. A computer software application consistent with the present invention may be deployed on any of the exemplary computers as shown in . For example computing device could execute software that may be downloaded directly from server . Portions of the application may also be executed by printer in accordance with some embodiments of the present invention.

In some embodiments CPU may be a general purpose processor a special purpose processor or an embedded processor. CPU can exchange data including control information and instructions with memory and or firmware . Memory may be any type of Dynamic Random Access Memory DRAM such as but not limited to SDRAM or RDRAM. Firmware may hold instructions and data including but not limited to a boot up sequence pre defined routines and other code. In some embodiments code and data in firmware may be copied to memory prior to being acted upon by CPU . Routines in firmware may include code to translate page descriptions received from computing device to display lists and image bands. In some embodiments firmware may include rasterization routines to convert display commands in a display list to an appropriate rasterized bit map and store the bit map in memory . Firmware may also include compression routines and memory management routines. In some embodiments data and instructions in firmware may be upgradeable.

In some embodiments CPU may act upon instructions and data and provide control and data to ASICs FPGAs and print engine to generate printed documents. In some embodiments ASICs FPGAs may also provide control and data to print engine . FPGAs ASICs may also implement one or more of translation compression and rasterization algorithms. In some embodiments computing device can transform document data into a first printable data. Then the first printable data can be sent to printer for transformation into intermediate printable data. Printer may transform intermediate printable data into a final form of printable data and print according to this final form. In some embodiments the first printable data may correspond to a PDL description of a document. In some embodiments the translation process from a PDL description of a document to the final printable data comprising of a series of lower level printer specific commands may include the generation intermediate printable data comprising of display lists of objects.

In some embodiments display lists may hold one or more of text graphics and image data objects. In some embodiments objects in display lists may correspond to similar objects in a user document. In some embodiments display lists may aid in the generation of intermediate printable data. In some embodiments display lists may be stored in memory or secondary storage . Exemplary secondary storage may be an internal or external hard disk memory stick or any other memory storage device capable of being used by printer . In some embodiments the display list may reside one or more of printer computing device and server . Memory to store display lists may be a dedicated memory or form part of general purpose memory or some combination thereof according to some embodiments of the present invention. In some embodiments memory may be dynamically allocated to hold display lists as needed. In some embodiments memory allocated to store display lists may be dynamically released after processing.

In some embodiments the display list may be dynamically reconfigurable and is termed a Reconfigurable Display List RDL . In one embodiment an RDL may be implemented using a data structure that allows certain display list objects to be stored in a manner that allows their manipulation dynamically. For example image objects may be compressed in place to increase the amount of available memory and decompressed when referenced and or used. In some embodiments an RDL may also permit RDL objects to be stored in memory and or secondary storage by holding pointers offsets or addresses to the actual locations of RDL objects which can then be retrieved when referenced and or used. In general the RDL allows display list objects to be flexibly stored and manipulated based on system constraints and parameters.

In one embodiment the translation of a POL description of a document into a display list and or ROL representation may be performed by language server using routines in ROL library and memory manager . For example language server may take POL language primitives and transform these into data and graphical objects and add these to the reconfigurable display list using the capability provided by functions in ROL library and memory manager . In some embodiments access to functions and routines in memory manager may be provided through a memory management API . In some embodiments the display list may be stored and manipulated in a dynamically allocated memory pool such as exemplary memory pool which may be part of memory .

In some embodiments creation of the RDL may be an intermediate step in the processing of data prior to actual printing. The RDL may be parsed before conversion into a subsequent form. In some embodiments the subsequent form may be a final representation and the conversion process may be referred to as rasterizing the data. In some embodiments rasterization may be performed by raster server using routines in frame buffer management library . Upon rasterization the rasterized data may be stored in frame buffer which may be part of memory pool using routines in memory manager which may be accessed through memory management API . In some embodiments the rasterized data may take the form of a bitmap that specifies the marks to be made on a printed page.

In one embodiment routines in memory manager may manage some subset of available memory in memory as memory pool and allocate memory from memory pool to requesting processes through memory management API . In some embodiments memory manager interacts with memory management API and access to functionality provided by memory manager occurs through memory management API . When memory is no longer needed by the requesting processes the memory may be de allocated and returned to memory pool where it can be made available to other processes. In some embodiments routines in memory manager may also include various other memory management routines including routines to free memory routines to recover memory and swapping routines that can swap memory to secondary storage . In some embodiments frame buffer may also be a part of memory pool and may be managed by memory manager . For example calls to functions in frame buffer management library may result in calls to functions in memory management API . Memory management API may then invoke one or more functions in memory manager . Results of the actions taken by memory manager may be routed back to the calling process. In one embodiment frame buffer may be allocated an initial contiguous block of memory and subsequent memory blocks may be allocated to frame buffer when requested. Memory blocks may also be allocated for other non frame buffer purposes from memory pool . In some embodiments distinct memory blocks assigned to the frame buffer or to other processes may occupy non contiguous memory locations in memory .

Print engine may process the rasterized data in frame buffer and form a printable image of the page on a print medium such as paper using routines in frame buffer library . In some embodiments raster server and engine server may also use routines in RDL library to perform their functions. In some embodiments engine server may provide control information instructions and data to print engine . In some embodiments engine server may invoke routines that lead to freeing memory used by display list objects after processing for return to memory pool using functionality provided by memory manager through frame buffer library and memory management API . In some embodiments portions of RDL memory pool and or frame buffer may reside in memory or secondary storage . In some embodiments routines for language server raster server and engine server may be provided in firmware or may be implemented using ASICs FPGAs .

As shown in mm Master Control includes three objects of class mm Pool . These objects comprise node objects block objects and super block objects. These mm Pool objects can be used in the management of shared memory pool . For example memory pool could be logically viewed as comprising of super block pool node pool and block pool . Accordingly super block pool node pool and block pool are sub pools of memory pool . Further each sub pool can comprise objects local to that sub pool. The use of the term local with objects serves solely to associate objects with their respective pools for descriptive purposes. Accordingly a super block object can be local to super block pool while a node object can be local to node pool whereas a block object can be local to block pool . For example routines in frame buffer management library associated with frame buffer can request a super block from super pool using memory manager through memory management API . Similarly a block object may be requested by RDL from block pool  Node objects can be allocated by Memory Manager from node pool upon request to manage block and super block allocations. In one embodiment one mm Node object may be used per block or super block allocation. In some embodiments each individual object may comprise a discrete contiguous section of memory.

In some embodiments mm Master Control can also include an mm PriorityQueue object . As shown in mm PriorityQueue object can include an mm List object . Further mm List object holds mm Node objects using mm Link objects . In some implementations an mm Node object keeps track of each allocated block or super block. mm PriorityQueue object can be used to keep track of swappable blocks. When available memory is low and swapping can be used mm PriorityQueue object can be used to determine an order for swapping blocks out of memory. For example an allocated block can be associated with a priority. For example the priority may be an indication of performance advantage gained by keeping block readily accessible. In one embodiment mm PriorityQueue object may order objects in order of increasing priority thereby allowing low priority blocks to be swapped out earlier than higher priority blocks. Other functions and routines may use the priority number to keep one or more higher priority chunks of memory in a quickly accessible form.

When memory is requested for use by frame buffer such as for storing a bitmap a super block can be allocated. When memory is requested for an RDL or for temporary storage and processing purposes a smaller unit of memory may be allocated. For example a free super block can be divided into equally sized blocks and one of these blocks can be allocated when used for an RDL or for temporary storage and processing purposes. The use of super block pool node pool and block pool in part allows control over the granularity of memory allocation. Node pool and block pool can grow when they allocate memory from super block pool . In some embodiments memory defragmentation routines may be employed periodically or when available memory is below some threshold or as a strategy to free memory in order to create new super blocks from disparate scattered blocks in memory pool .

If block is not in memory as may be determined in step then pre defined routine may use supplied parameters to determine the appropriate memory pool and the corresponding super block or block object to be allocated. Next if the object allocation is successful as can be determined in step then in step data for block may be read or swapped in from secondary storage and the algorithm proceeds to step . In step if the reference count for the node is non zero then the algorithm can proceed to step . In step the reference count for the node may be incremented by one and a pointer to block can be returned. If memory allocation by pre defined routine is determined to be unsuccessful in step then an insufficient memory message may be sent back to the calling routine in step .

If a request for a block is made to node pool or to block pool then in step the availability of a free or unallocated elements or allocation units in node pool or block pool can be determined. If a node object or a block is available then a node object or a block can be allocated in step based on the type of object requested. For example a node object may be allocated for internal use by memory manager . If the check for availability in step determines that there are no free or unallocated elements in node pool or block pool then the algorithm proceeds to step . In step the availability of a super block in super block pool can be determined. If a super block is available then a super block can be divided into blocks and allocated to the appropriate pool or in step . For example a super block may be divided into blocks and one block may be allocated to RDL.

If there are no super blocks available in super block pool then the algorithm may invoke one of several memory freeing strategies in step . For example the algorithm may wait until a memory is freed by another process. In some embodiments the algorithm may swap a node with a low priority from the priority queue to secondary storage . If memory freeing strategies fail as may be determined in step then the algorithm may report insufficient memory to the calling process in step .

Other embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of one or more embodiments of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the invention being indicated by the following claims.

