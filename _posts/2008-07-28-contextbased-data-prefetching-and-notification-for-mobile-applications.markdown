---

title: Context-based data pre-fetching and notification for mobile applications
abstract: Methods, systems, and computer program products for context-based data pre-fetching and notification for applications are described herein. In an embodiment, the method operates by creating a context model that includes context variables and events. The method populates context variables based upon the context of an application and instantiates a context based upon the context model. The method determines whether the context is active or inactive and infers a likely set of data needed by the application. The method executes a data selection function to generate a dataset for the application. In an embodiment, the system includes a module to create and maintain a context model. The system includes modules to: populate context variables within the context model; calculate a dataset for the application; maintain an inference engine; subscribe to changes in the context variables; and generate notifications including a dataset with associated metadata that assists with display of the dataset.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009292&OS=09009292&RS=09009292
owner: Sybase, Inc.
number: 09009292
owner_city: Dublin
owner_country: US
publication_date: 20080728
---
This application claims the benefit of U.S. Provisional Application No. 60 935 182 filed Jul. 30 2007 and entitled System Method and Computer Program Product for Context Based Data Pre Fetching and Notification for Mobile Applications which is herein incorporated by reference in its entirety.

The present invention generally relates to mobile computing and more particularly to optimization of delivery of data to mobile applications.

As mobile computing platforms become increasingly ubiquitous and with the availability of network access for the mobile computing platforms it becomes desirable to provide users with as close an approximation to the experience of a full featured computing platform as possible. In order to conserve space and battery power mobile computing platforms such as personal digital assistants PDAs frequently have small display screens limited memory limited processing power and limited communications bandwidth. Such resource restrictions of mobile computing platforms are often incompatible with the goal of providing users with data needed by the users to enjoy a full featured experience.

Mobile applications require data to be mobilized from the enterprise and stored on a mobile device for occasionally disconnected computing while the device is not connected to the enterprise network. However as the mobile devices are often resource restricted the set of data downloaded to the devices is limited to a subset of what is available on enterprise servers and devices. In addition the subset of enterprise data needed on mobile devices must be determined a priori. At times the pre determined subset of data is insufficient to meet the mobile user s needs. Necessary data is unavailable on mobile devices when unplanned and planned changes are not accounted for. Without necessary data available at the mobile devices corresponding mobile applications can be rendered difficult to use or inoperable depending on network connectivity.

In traditional enterprise computing environments users are able to request data i.e. fetch data and query databases when it is needed and receive a timely response with the subset of data they have requested. In the mobile environment this traditional request response paradigm does not always work due to potential connectivity problems of roaming mobile devices. The attention of a mobile user using a particular mobile application is on the task currently being performed so it is unreasonable to expect mobile users or applications to determine what data is necessary to complete the task. Hence pertinent information should be pushed to the mobile user s applications rather than requiring mobile devices to pull the information from enterprise servers. Relevant data and notifications must be provided at the appropriate time to mobile devices enabling mobile users to make time sensitive business decisions. This is because mobile users oftentimes do not know when and what subset of data is needed as they are not aware of the situation or context they are currently in.

Accordingly what is desired is a system method and computer program product to dynamically determine the likely set of data needed on a mobile computing platform based on the context of the mobile applications on the platform and the user using the platform.

What is further needed is a system method and computer program product to provide relevant data and notifications at the appropriate time to a mobile computing platform based on the context of the mobile applications on the platform.

An embodiment of the invention includes a computer implemented method for determining the likely set of data needed on a mobile computing device based on the context of the mobile device wherein the context reflects the context of the device s user within an enterprise as well as that of the device. Besides a human user who needs data on a mobile computing device a software application or agent sometimes needs data. Accordingly unless specifically stated the user as used herein is not necessarily limited to and does not necessarily pertain to a human being. In accordance with an embodiment of the present invention the context of a mobile device takes into account one or more of device specific variables such as the device s GPS location current data contents network connectivity and battery status. It should however be understood that the invention is not limited to these device specific variables and other variables related to the mobile platform s status may be used. The context of a mobile device is also affected by the status of a user using the device. A mobile user s status or context takes into account one or more user specific variables such as the user s schedule access privileges security role s group memberships database roles and data privileges granted in accordance with an embodiment of the present invention. It should however be understood that the invention is not limited to these user specific variables and other variables related to the mobile user s status may be used. According to an embodiment of the invention the method includes the steps of creating a context model wherein the context model represents the situational information of a mobile user updating context variables within the context model that can be used by the mobile application wherein multiple applications can share a single context model as well as having a specific context model for each application determining the set of data for the mobile application through the use of the context variables from the context model maintaining inference engines used by the data selection functions to arrive at the likely set of data needed by a mobile application maintaining the context models subscribing to changes in context variables for mobile user device combinations and executing data selection functions to calculate a dataset for applications including applications running on mobile devices.

The invention further includes a computer program product embodiment comprising a computer usable medium having computer program logic recorded thereon for enabling a processor to perform context based data pre fetching and notification for mobile applications in accordance with an embodiment of the present invention. The computer program logic includes a first context modeling means for creating a context model wherein the context model represents the combined situational information of a mobile device and its user. The computer program logic includes a means for updating and maintaining context variables within the context model that can be utilized by mobile applications executing on the mobile device wherein multiple applications can share a single context model. In an alternative embodiment each mobile application can have its own respective specific context model. The computer program logic further includes a means for determining the set of data for the mobile application that will leverage the context variables from the context model. The computer program logic also includes a means for maintaining inference engines used by the data selection functions to arrive at the likely set of data needed by a mobile application. The computer program logic includes a subscribing means for subscribing to changes in context variables for mobile user device combinations. The computer program logic includes a data selection means for executing data selection functions to calculate a dataset for mobile applications.

The invention additionally includes a system capable of context based data pre fetching and notification for mobile applications in accordance with an embodiment of the present invention. The system includes a first context modeling module configured to create a context model wherein the context model represents the combined situational information of a mobile device and its user. The system includes a context variable module configured to update and maintain context variables within the context model wherein the context model can be used by the mobile application and multiple applications can share a single context model as well as having a specific context model for each application. The system further includes a data selection module configured to determine the set of data for the mobile application that will leverage the context variables from the context model. The system includes an inference module configured to maintain an inference engine used by the data selection function to arrive at the likely set of data needed by a mobile application. The system also includes a context server module configured to maintain the context models. The system further includes an event engine module configured to subscribe to changes in context variables for mobile user device combinations and executes data selection functions to calculate a dataset for mobile applications.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

The increasing availability of wireless access to the Internet has created a significant market for mobile computing devices with wireless access capabilities. Traditionally such compact portable computing devices commonly termed hand held devices or PDAs have had less computational power than larger computing platforms such as laptops or personal computers PCs . Due to this limited computing power as well as other features inherent to a mobile computing platform such as smaller display screens custom mobile applications have been developed for purposes such as optimizing the display of web pages reducing CPU usage reducing local data storage reducing the quantity of network accesses and increasing battery life.

Of particular concern to the present invention is the reduction of network accesses by decreasing the amount and frequency of data fetching by mobile applications among other features. One skilled in the relevant arts will appreciate that accordingly the techniques described herein need not be limited to a portable computing device but can in fact be used in any computing situation where similar resource utilization problems are posed.

Mobile device is connected to the Internet through a gateway network access server . Mobile device connects to enterprise server via network . One skilled in the relevant art s will appreciate that any network such as but not limited to a corporate intranet may be used instead of the Internet . Furthermore gateway network access server is operable to support connections from multiple mobile devices such as mobile devices and . Additional mobile devices and may connect to network via another network access server to receive data from an enterprise via enterprise server . In accordance with an embodiment of the present invention pre fetched data from enterprise server is delivered to mobile devices via network based upon one or more context models stored on context server . The context models may be shared amongst multiple mobile devices or each device may have their own respective context models. In an embodiment context server maintains context models by polling for updates from physical sensors in wireless network environment . Context server also maintains context models by receiving updates to context variables residing on context server . The values of context variables on context server vary depending on the respective applications running on mobile devices and the characteristics of users using mobile devices .

Context model represents the situational information of the mobile user. According to an embodiment context model may be defined using ontology. The ontology can be as simple as key value pairs. Ontology can be leveraged in context model . Each context model has a set of concepts as well as the relationships between them expressed in context variables . Context model is a template used to enable context based data pre fetching.

Context variables can be simple derived or contextual. Derived variables are by obtained by aggregating through inferences of simple variables. Context variables may include simple context variables which in turn may contain a single value or a collection of values.

In order to facilitate delta based data updating i.e. sending out only information and data that a mobile device does not already have context model stores a representation of what is already on mobile device in one or more context variables . Context variables are part of context model .

There can be many context models within context server . Context server maintains context models by polling or receiving updates from physical sensors or software based information for simple variables. Changes in the simple variables trigger inference to update corresponding derived variables.

Context server provides a context query API to access context variables within context model . According to an embodiment a context is identified by a globally unique identifier GUID . Context Server is responsible for the lifecycle of all contexts within it. According to embodiments of the present invention context server may be a software module computer hardware or a combination of hardware and software. A context is created based on a context model. In other words a context model can be compared to a Java class whereas the context itself is akin to a Java object corresponding to the Java class or an instance of the Java class.

Data selection functions are functions that calculate the pre fetch data for applications running on mobile devices . Data selection functions may leverage context variables within context model . For each mobile user device combination there can be a set of data selection functions . The output of each function is combined to form new dataset . Data selection functions may use inference e.g. rules or Bayesian network to perform calculate the dataset required by each mobile user device combination . Data selection functions also access context model from context server .

In accordance with an embodiment of the invention Data selection functions access context model that represents the mobile user s context to determine the new dataset required by each mobile user device combination .

Each user device combination may subscribe to a set of context variables within context model . Whenever context variables within subscription changes event engine will determine and execute the affected sets of data selection functions . The new dataset created by the functions will be compared with what is already on the device stored as context variables to create a delta set of data that the mobile user device combination does not already have.

Event engine is also responsible for receiving notifications updates from sensors and software event mediator and forwards them to context server to maintain context models .

According to one embodiment of the present invention notifications and data delivered to mobile user device combination have the following characteristics.

Dataset is packaged with metadata into a metadata driven container to assist in displaying the data at the mobile device and the metadata contains a description of data .

No modification of dataset is allowed and data is provided to mobile user device combination only for reference.

Dataset requires a client side container to interpret the dataset package and display it appropriately at mobile device .

Dataset can be acknowledged and discarded by mobile device or after a predetermined time i.e. a timeout period according to a policy on mobile device .

Data is generated from mobile device user combination specified data selection functions that are subscribed to context variables within context model .

The metadata driven dataset container uses the metadata within the dataset to determine how best to display the data . Data container is context aware i.e. aware of the environment that it is executed under such as the characteristics of mobile device user combination . Hence data container can render data in a fashion that is most suitable for the device.

When data is reviewed by user it can be deleted from the mobile device . In addition if dataset has an expiration date set it will be discarded when appropriate.

Relevant data can be pushed to mobile device user combination based upon changes in the context that the data selection functions subscribed to.

Changes in a context are expressed as change events context variables within context model and can be caused by changes occurring within the enterprise such as changes in data on enterprise server execution of business processes or other change events . Change events are reported to event engine which notifies context Server to update the corresponding context model .

Change events can also be caused by a mobile device user combination triggering a change in context through user actions within applications running on mobile device natural language commands queries through messaging or short messaging service SMS and device sensor readings.

Context model may also contain a constructor and the set of parameters required to create a context based on it. At a minimum the identifier of the to be created context must be specified. This is because all created contexts must have a globally unique identifier for us to unambiguously refer to it. For example a GUID may be used to uniquely identify a context. Additional parameters to the constructor can be used to set some of the context variables within the newly created context.

Context model defines a type of context for a particular usage. For example a context model can be tailored and populated for a Customer Relationship Management CRM application for pharmaceutical sales personnel using mobile devices . Each context model consists of a set of context variables that define the domain of interest or set of situations that the context can express. For example a work context model can have two variables at office on vacation. According to one embodiment of the present invention the valid states of context model can include but are not limited to the permutations listed and described in Table 1 below.

A context is created during runtime using the metadata within context model . In an embodiment all contexts reside within context server which serves as their container. Context server is responsible for managing the lifecycle of the contexts within it. All contexts within context server have unique identifiers associated with them. Using these identifiers they can be looked up by a client subscriber or user. In an embodiment once a context is located a client can use an application programming interface API in order to interact with the context to perform work.

In an embodiment a context must be in one of its four states created active inactive or deleted and a context transitions from state to state as it moves through context lifecycle . The states of the context lifecycle and relationships between the states according to an embodiment of the invention are described in the following sections.

The lifecycle of a context begins in step when a context is created. After a context is created in step it enters the Created state. Context model defines the number of parameter s that are passed to the constructor. The minimum parameters passed to step include at least a unique identifier that will identify the newly created context. Other parameters can be used to set context variables . All context variables except contextual context variables are defined with initial values so it is not necessary to initialize them through parameters.

If the contextual variable has an association relationship it is initialized in step by looking up the designated context. This lookup of the designated context is accomplished by using an appropriate identifier for the lookup. This identifier can be passed as a parameter to constructor of the referring context. It can also be from the initial value of a context variable . The contextual variable is only initialized in step if the referred to context is located.

In step an evaluation is made regarding whether the initialization in step was successful. If it is determined that the context is initialized i.e. the context is in the initialized state control is passed to step . If it is determined in step that the context is not initialized control is passed to step .

If the context cannot be located it is considered to be an error and the creation will fail in step . However it is not treated as an error condition if no identifier is specified to use for locating the context. The contextual variable will have a null reference and it can be subsequently set up by an administrator.

In step an error is reported when the context is not initialized. In an embodiment step may include reporting a context creation error to an administrator or user who has subscribed to the context. For example the error may be reported via a message or display on a graphical user interface.

If the contextual variable has a composition relationship the owning context s constructor automatically creates the dependent context by invoking its constructor and passing in a GUID as identifier and other necessary parameters. The GUID is known to the parent context as it owns the child or created context and controls the child context s lifecycle. The failure to create the child context will cause a creation error in step .

If the contextual variable is initialized successfully in step it will have a reference to a context. For a vector of references it is possible to initialize from zero to n references. A referring context will register a relationship with this initialized context. Registration allows for change events to be propagated. Similarly de registration is be done to remove the relationship so that the referred to context can halt propagation of change events .

If the context is created and initialized in step it will automatically transition to the Active state in step .

At this point change events and state events are set for the active context. In this step input events are also processed for the active context. Context events such as change events and state events and input events are described in greater detail in section 3 below. The active state is the normal operating state of the context. In this state the context will receive and process input events to update its context variables . In addition the context will raise change events and state events to trigger subscribed consumers to perform their action. Through administrative or user actions a context in the active state can be moved to the inactive state in step .

In step the context is set to the inactive state if an administrator or user action triggers a state transition from active to inactive. A context in the inactive state can be considered disabled. An inactive context will ignore all input events and as a result will not raise any change events . Through administrative or user action a context in the inactive state can be activated back to the Active state in step . Deactivating the context and putting it into the inactive state in step may cause the context to be out of sync with the sources. For example if a notification event associated with a simple variable is reporting an edge transition of some sort rather than the actual state. An inactive context will ignore many of such notification events and lose count. In an embodiment an administrator may synchronize an inactive context in this scenario when the context is transitioned back to the active state in step .

A context can be destroyed or deleted from either the active or inactive state and enter into the Deleted state in step . According to one embodiment context server may retain or cache a deleted context for an undetermined period of time. In another embodiment the amount of time a deleted context is retained is a tunable parameter entered by an administrator. Alternatively context server may also remove a destroyed context immediately at its discretion. A context in the Deleted state cannot be looked up.

Context modeling refers to the development of context models . The relationship between context model and a context is similar to the relationship between a Java class and a Java object. Context model is the blueprint for a context and a context is created based upon context model . The first step in context based data pre fetching and notification is the development of an appropriate context model . Many different context models may be required in a typical system. Context model may depend on other context models. For example the context for mobile sales personnel may refers to the context of the mobile device being used by the sales personnel combined with the context of the personnel s respective departments and the personnel s personal information manager PIM . A mobile device s context is determined by one of more of the following factors mobile device network connectivity voice and data network battery level and GPS location. A PIM context is determined by evaluating one or more of calendar address book and other factors. A department context may be determined by evaluating sales figures the department s commission policy the department s sales goals and other department level factors. This list of variables used to determine a context is not exhaustive but is provided as an example of variables that can be used in context model .

Context modeling tool depicted in may include a graphical user interface GUI module configured to accept input of modeling parameters. Context model is described by appropriate metadata. Once a context model is developed context generator reads in the metadata representing context model and generates various support artifacts and code. The resulting output is packaged into a deployment unit and deployed into context Server . Once deployed administrator and or user can create contexts based on the deployed context model . Context model created in step described above resides within context server . Context server is responsible for maintaining the state of context model . Context model maintenance includes updates to context variables depicted in .

Context model is the blueprint for a certain kind of context. Context model includes a set of context variables that define the scope of the context. The scope determines the set of situations or scenarios that the context can express. For example a work context model can have two Boolean type variables at office on vacation. State variable contains a single value or vector of values of a particular type. Unlike simple variable it receives no external input that may change its value s .

Context variables by default raise a change event whenever its value vector of values changes. There is an option propagate change to control this behavior. When set to false the variable will not raise a change event. When any one of the context variables raises a change event the context model will also raise a change event. In order to allow the context model to control this behavior the context model also has a propagate change option. State variable does not raise change event instead it raises a state event.

In addition to the set of situations of the context represented in Table 1 there are multiple types of context variables . Context variables can have but are not limited to the types listed and described in Table 2 below.

According to an embodiment a Simple context variable is required to have a default or initial value. For a vector or array of values the initial state can be an empty vector. A user can define a source for updating a simple context variable. In an embodiment a user or administrator defines how context variables are to be updated. For example a management graphical user interface GUI can be used by users or administrators to define how simple and aggregate context variables are to be updated.

In accordance with an embodiment of the present invention a simple context variable must be associated with either a polling or notification event for it to be valid. The polling or notification event is the source for a simple context variable. A procedure may be defined to process or transform the information from the polling or notification event and update the variable.

In an embodiment a simple context variable also has associated with it an update frequency option. The update frequency option is a positive integer value. For example a value of 0 or 1 means that we the output of the polling notification event reported will be examined every time to determine if a change has occurred and a value of 4 means that the output of the event once will only be examined every four times. This mechanism allows users and administrators to use simple context variable to control how frequently changes will be reported. For example a polling event may occur each second whereas a simple context variable may be set to a value such that a user is only interested in a resolution of 30 second increments while other users may require much higher resolution such as each 10 seconds.

In an embodiment simple context variables can be updated through one of the methods described in Table 3 below. The supported simple context variable update methods include but are not limited to those listed and described in Table 3.

In an embodiment derived context variables are also required to have default or initial values. Once again for a vector value an empty vector can be the initial state. According to an embodiment in order to update derived context variables a specification of a procedure operating on a set of simple variables or derived variables is required. The output of the procedure returns a value or vector of values. In an embodiment the procedure can be triggered by one of the mechanisms listed in Table 4 below depending on the settings made by a user in a context variable within the context model . The derived context variable procedure triggers include but are not limited to those listed and described in Table 4.

Contextual context variables require the specification of another context model. If the variable is defined to be a vector of references it means that more than one contexts of the specified context model can be referenced. The relationship between the context models involved can be of association or composition a specialized form of association with ownership and lifecycle implications . Association or shared relationships work well in the context system because updating contexts is resource intensive. Hence an advantage of an embodiment of the invention is that contexts can be shared.

Contexts can also be composed. Composition means there is a parent context owner and a child context. The child context is not shared but is owned by the parent context. The parent context is responsible for the lifecycle of the child context.

The use of contextual variable allows a context model to be re usable by other context models. Reusability is important for building increasingly complex models using what is already developed.

According to an embodiment of the invention state variables are internal variables and do not have a source. Polling or notification events are not specified for state variables. However a procedure may be defined that can change its own value or even values of other state variables as well as issuing state events such as the state events described below. A procedure can be triggered by change events and state events. State variables also have initial values associated with them.

A context is an instantiation or runtime representation of context model that it is created from. For example context model describes the context and is used as a template to create the actual object hosted within context server . A context is created with an identity or unique identifier that another context or user can use to reference or lookup the context.

The context system is event driven. According to an embodiment of the invention there are two primary types of events context events such as change events input events depicted in and state events .

A change event triggers data selection functions and notifications. Input events are events triggered by sensors enterprise applications user actions and other events that update variables within the context. Change events are described in greater detail in section 3.1.1 below. A state event is raised by the specified procedure of a state variable when the context detects actionable circumstances. Thus an event is the base upon which the context system is built. State events are discussed in section 3.2 below.

Context events depicted in include change events and state events as well as input events . Input events include polling and notification events.

Change events are events raised by context variables . Whenever a context variable changes its value or vector of values based on output of the associated input event it raises a change event. According to an embodiment of the present invention a change event always contains the name of the variable that raises it. The change event is propagated to the context containing the corresponding context variable and in turn will raise a change event of its own. The change event raised will have within it the name of the variable whose change event caused the context s change event and the current value. Users can subscribe to a change to a context variable to derive useful operations and behavior from them.

Input events are the source of updates to simple variables and indirectly to derived variables. Output of input event is expressed in a canonical format with an associated entity that describes it. An embodiment of the invention uses XML and the XML schema to describe the output. depicts the role of simple variables in the pre fetching process in accordance with an embodiment of the invention. In most cases simple variable references an input event points which points to an appropriate element within the output to be the source of that variable.

Input events are shared by many simple variables . For example five simple variables from different context models can reference a single input event such as a polling event. In this example the output of the polling event upon execution is used by all five simple variables to determine if their values or vectors of values need to be updated. Similarly when a notification event is received all simple variables referencing it will examine its output for update of their values.

A polling event contains the instruction to poll or acquire the status of a certain entity. For example a polling event can contain an instruction to poll for the status of a purchase order from an enterprise application. A polling event is also has schedule and polling frequency attributes. The schedule defines when the polling is to take place. According to embodiments of the invention the schedule attribute can be configured by an administrator and can be one or more of a time of day i.e. 9 AM 6 PM days of the week i.e. Monday Friday months of the year or other ranges of time. The frequency attribute specifies how often the polling should occur. In accordance with embodiments of the present invention the frequency attribute can be configured by an administrator and can be one or more of seconds i.e. each 5 seconds minutes hours days i.e. daily or every other day weeks i.e. weekly or bi weekly or months. When the poll event is executed at the specified time the polling results in an output. The output is expressed in a canonical format for use by simple context variables. Information acquired from data sources during polling may require some transformation to the canonical format. Polling events are executed by context server according to their associated schedule.

Notification event depicted in can result from receiving a message. For example notification event can be a message from an Enterprise System Bus ESB a device reporting its status or other data sources capable of generating a message. The format of these messages can vary depending on the source. Hence notification event has associated with it transformation procedure to help transform the received message and express the message in a canonical format. The processing procedure associated with simple variable takes the canonical form and performs processing to filter out and calculate what matters to it.

Transformation procedure is added to notification event . The Processing procedure associated with notification event is where input of notification event is transformed into a canonical form. When the message is received and transformed notification event is generated.

In accordance with an embodiment of the present invention a method is invoked in a Web Service interface provided by the context system. The published Web Services Description Language WSDL will define the input message type. The entity that provides the input for context variable s can simply call a web service interface to push it. They do not need to generate a message and send it. This is an alternate method to receive inputs for context variables . The output of the event is used to update simple variables associated with context variables .

While a change event notifies external listeners of changes in non state variables a state event indicates a condition or circumstance detected by the context. State variable is the container of the value for the state variable which in turn generates stat event . State variable is not simply a passive container to collect information that constitutes a particular type of context. Rather state variable allows context to play an active role in determining actionable items based on its state. State variable contains its name and its current value.

In accordance with an embodiment of the present invention contexts can have two types of relationships between them association and composition relationships. These two relationship types are described in the sections below.

Two contexts based on context models that have an association among them are aware of each other. It is important that a referred to context has knowledge of a referring context so that events can be propagated to the referred to context. The act of initializing a contextual variable with an association relationship at creation time involves the referring context looking up the referred to context and registering with the referred to context. If the referring context is deleted or otherwise goes away it deregisters with the referred to context so that the relationship can be severed. The referring context does not own the referred to context. For example a many to one relationship can exist between referring contexts and a referred to context. When a context based on a context model with a contextual variable is created it will attempt to look up the referred to context. If the referred to cannot be found the context is considered not initialized and creation will fail as a result as depicted in step of . The creation of the referred to context should occur independently.

Composition implies ownership or a parent child relationship. The lifecycle of a child context is the responsibility of the parent context. A contextual variable with a composition relationship usually means that the child context is not to be shared and private to the parent context. This is usually done to allow the parent context to fine tune the behavior of the child context for the parent s own use. For a shared context in an association relationship each context in the relationship sees the same events. In this way there are implications when updating many contexts based on a similar set of input events.

In accordance with an embodiment a set of APIs for manipulation of contexts is defined as part of a system. In embodiments the context API can be generic or dynamic. The context API can be used to work on contexts from any context model . As a result it is not as efficient as model specific API. A client can use the API to look up any context based on a unique context identifier. The API can also be used to obtain information about the context model that the context is based upon. By using the API and the information obtained via calls to the API any context can be manipulated.

Context is a first class citizen within the system. Thus a rigorous approach for context development is employed through context modeling. In an embodiment of the invention a context modeling tool is used as part of a system to create and maintain context models.

Metadata repository allows developers to support source control and configuration management for context models . Source control and configuration management enables collaboration among developers including teams of developers who are not collocated. Metadata repository also allows developers to search for suitable context models for reuse with a powerful query language. In an embodiment of the invention the query language is fashioned after and similar to the structured query language SQL .

The context modeling process includes developing input events that feed context models with updates. Development of these input events requires knowledge of data sources including both hardware and software data sources. The acquisition of input events involves interfacing with data sources to retrieve receive information. It may require transformation of information to a canonical representation. Input events are developed once and shared by all context variables interested in the events. In other words input events are reused in the development of new context models . Hence in an embodiment all developed input events are also stored within metadata repository . The benefits of impact analysis source control and collaboration also apply to input events .

The method used by data selection function to indicate the set of data to be pre fetched for a particular mobile user device combination depends on the synchronization mechanism between the mobile device and the enterprise server depicted in . Data selection function is triggered by either a change or state event such as change events and state events . Change events and state events are generated from context through a subscription. In other words context drives data selection function which then interrogates context to determine the situation and to come up the proper dataset. In the embodiment illustrated in data selection function within a data selection subscriber writes arguments to database for use by a download cursor. In one embodiment data selection function within a data selection subscriber writes arguments to database for use by a MobiLink download cursor. As would be appreciated by those skilled in the relevant art s database can be a relational database or a staging database for a data repository a data store a data warehouse or any other structured collection of records or data.

Data selection functions are more than consumers of context events . They also take advantage of context s set of context variables . In an embodiment once triggered data selection function will use a context API as well as generated code for context model that data selection function is subscribed to. Data selection function retrieves information from the triggering event to look up context within context server . Data selection function can then use generated code to determine that state of context in addition to the state that fires the change state event. Besides the information in context data selection function may use other state information elsewhere to arrive at the appropriate dataset.

What data selection function takes advantage of once triggered is dependent on the function itself and the mobile application running on mobile devices that the function may be associated with. In some cases the event is the most important element while in other situations it is the event and the rest of context that matters. The following sections describe methods to determine what data selection function takes advantage when the function is triggered.

In the trigger only method data selection function does not access the firing context . According to this method data selection function has access to a triggering event that contains a current value of a context variable which is the contributor to the event.

In an embodiment a current value of context variable can be a Global Positioning System GPS location to calculate what the set of pre fetch data is comprised of. In more complicated cases data selection function subscribes to a state event which is more than just a change but is the output of a state machine. This means that the triggering condition for the function can be non trivial and yet data selection function does not require a lot of contextual information to arrive at the set of pre fetch data.

Data selection function has access to the firing context . In this manner data selection function is able to examine context and based on the values of all the context s context variables to determine the set of pre fetch data. The trigger only method described in the previous section is a subset of the context based method. According to an embodiment data selection function accesses context through its API rather than being given a copy.

This ensures that data selection function will always see the latest context variables within context .

Data selection function may also refer to external information stored within an enterprise such as information stored on enterprise server in order to arrive at the set of pre fetch data. For various reasons whether it is difficult to develop an input event or other technical issues this information may be determined to be inappropriate for inclusion in context .

According to an embodiment it is possible to have data selection functions using the trigger only and context based methods to leverage other information.

Data selection function can be implemented as required by the application. Data selection function can be procedural or inferential. In an embodiment of this invention there are two ways of implementing data selection function . The first example embodiment is depicted in and uses a download cursor within a relational database synchronization occurring on synchronization server . In one embodiment the download cursor may occur as part of a MobiLink relational database synchronization occurring on a MobiLink server. In the embodiment depicted in the download cursor is defined as a structured query language SQL procedure or statement executed on synchronization server . The information from the triggering event and or context is used as parameters or arguments to the download cursor. In this embodiment data selection function is the combination of the data selection subscriber that writes the arguments to database and a download cursor that selects the appropriate set of data using the arguments written by the subscriber. For more complicated scenario a data selection subscriber can be a procedure a set of rules that obtain information from the triggering event and or context that generates a new set of values for use by the download cursor as arguments.

The data selection subscriber subscribes to the events and state events of context . The data selection subscriber is paired with a download cursor to select the set of pre fetch data. The subscriber knows what arguments the download cursor expects and takes advantage of information in the triggering event and or context to come up with the set of values.

A second example embodiment of how data selection function can be implemented is depicted in . In this embodiment data selection function is within the subscriber and uses information from the triggering event as well as the firing context or other information to calculate the set of pre fetch data. Data selection function then writes the pre fetch data either in the form of a set of primary keys or the actual data to database . The pre defined download cursor will pick up the pre fetch data from database and download it to mobile device . This embodiment is a more flexible method to calculate the pre fetch data as data selection function can employ more than a SQL statement procedure that executes against synchronization server .

In both of these example embodiments of data selection function the pre fetch data is delivered to mobile device via a pull mechanism. For example a trigger is sent to mobile device which causes the device to perform database synchronization. In an embodiment this method works best under the following three scenarios.

1. The pre fetch dataset is relatively large and it is therefore more efficient to do a relational database synchronization.

2. There is a need to avoid overwriting modified data on mobile device by giving the device an opportunity to upload its modified information back to enterprise server before receiving the pre fetch data. This is because in relational database synchronization there is usually an option to perform an upload of changes from mobile device before doing a download to the device. In this scenario data selection function will create a set of primary keys that refer to the data to be pre fetched. After the upload the download cursor uses the set of primary keys to assemble the data for download. By now it will include records modified during the upload.

3. A relational data store is the appropriate storage container on mobile device . This scenario may exist when mobile device has sufficient processing capacity memory and storage capacity to enable a relational data store to reside on the device.

Despite the three scenarios described above alternative embodiments of the invention may perform a true data push to mobile device instead of a poke pull or push pull method. A data push method is most appropriate when the amount of pre fetch data is relatively small and the database synchronization workload for database is relatively large or heavy. In order to implement the data push method an agent is needed on mobile device to take the pre fetch data and update the local database resident on the device. In addition if the local data store on mobile device is not a relational database it will make more sense to actually push the pre fetch data to the device.

The mobile device and user combination depicted in is what determines the set of pre fetched data selected by data selection functions . Mobile device may not be able store all the data that is required by the user due to security reasons or resource constraints of the device. The data pre fetching process attempts to remedy this situation by using context to determine what data is likely to be required ahead of time. This determination is not an open ended prediction but it is likely that the context required in order to make the determination can be extremely large and may involve complex calculations. Therefore it is important that the use case be constrained through use of context model and an appropriately defined data selection function . In an embodiment data selection functions and the context model the function subscribes to is the implementation of the solution to the problem of predicting the data need for a particular mobile device user combination .

In accordance with embodiments of the present invention two methods for data pre fetching are supported stateful and stateless. These methods are described below.

The stateless method is performed without requiring that context or data selection function maintain a state regarding what a given mobile device has in its data store. As a result some portion of the pre fetch data may overlap with what is already stored on mobile device . This data redundancy results in lower efficiency due to performing a pre fetch of data that mobile device already has. Usually the stateless model is employed for use cases where chances of data overlap or duplication are relatively low. For example if pre fetching is performed for customer data based on the calendar i.e. date day of week and time it is unlikely that pre fetch process will push the same customer over to the same mobile device within the same day. It is very possible that the process will purge the record on mobile device after each work day due to security concerns i.e. data privacy database rights or resource limitation of the device.

The stateful method is performed by keeping information regarding the set of data the state on mobile device either within context or in some state container elsewhere. According to an embodiment the state container may be a database table such as a relational database table in database . This state is used to trim the dataset to avoid sending data that already exists on mobile device . If the state is kept within context an input event is needed to keep the state up to date. In an embodiment notification event is used to accomplish this.

In accordance with embodiments of the invention are two ways that a client s dataset status can be maintained or kept in context . This can be accomplished by use of state variable combined with receiving change event from simple variable . In an alternative embodiment this can be accomplished solely through use of simple variable . In either of these embodiments an input event for simple variable is used to notify context of changes in the client s dataset status. In an embodiment if the client side data store is non relational data pre fetch process is accomplished by sending explicit Create Update and Delete commands from the client and in situations where data inconsistencies are possible a Replace command is sent with the complete state to synchronize again. The Update command s purpose is to let data selection function to either override or skip notification of modified data on mobile device .

There is additional flexibility when state variable is used to maintain the state. Compared with simple variable state variable can receive other events such as state events and change events . State variable can also offer multiple update streams as needed.

If the client has relational data store resident on it and relational database synchronization is being used it is oftentimes easier to keep the state in a database table on the server side. According to an embodiment of the invention a synchronization server as depicted in may be used for the relational database synchronization. SYBASE MobiLink is an example of a currently available synchronization server. In one embodiment synchronization server may be a MobiLink server. In an embodiment the database table on the server side may also be part of database . The relational synchronization engine can directly update the table without going through context . However data selection function must access the state from the table rather than context . For relational synchronization this is an advantageous way to implement data selection functions .

This method of keeping a client s dataset status can also be used in non relational database synchronization scenarios. In general if data synchronization can take advantage of the state in an efficient way it is better to maintain a client s dataset status using the most suitable method i.e. either within or outside of context depending on the factors described above .

In accordance with an embodiment of the present invention there are two types of notifications actionable and informational . Actionable notifications gives users the ability to take actions defined within the notification. In addition actionable notification includes data to support the action. For example if actionable notification is for an urgent purchase order approval request the notification carries with it data needed to approve the purchase order. The action in this example is to either approve or deny the purchase order and the data comprises the actual purchase order. An information notification is just for reference and the recipient of the notification cannot act upon it. An example of an information notification is an approved purchase order notification. In this example there is no action to be carried out as the purchase order was previously approved.

In both types of notification the data within the notification is read only and cannot be modified. Instead for actionable notifications a service call can be invoked with appropriate parameters. The service call clearly defines the granularity and interface for interaction with an actionable notification .

The medium of executing an actionable context can vary. According to an embodiment of the invention there are two mechanisms to execute an actionable context . The mechanisms include but are not limited to those listed and described in Table 5 below.

Notifications are triggered by events from contexts . However context does not generate the notification. Instead context signals that a condition has been met and a subscriber should determine if it is appropriate to generate a notification such as an actionable notification or an informational notification .

Within the event engine notification generation function subscribes to change events and state events in context . Notification generation function is triggered when the change events and state events are fired and notification generation function then determines whether a notification such as an actionable notification or an informational notification needs to be generated.

The stateless class of notifications is generated based on current conditions information from the triggering change event or state event and the firing context . Additionally the notification can use other information available in the enterprise i.e. available from enterprise server . A state does not need to be kept for this type of generated notification. As a result the notification generation function can be comprised of a set of rules using the information mentioned above to determine whether a notification is appropriate. In an alternative embodiment a notification generation function can be implemented as a procedure written in a particular programming language such as Java or C .

A simple stateful case involves the use of state information kept and maintained by an external entity. In this case the notification generation function simply accesses the external state and in conjunction with the information from the change event or state event and context determines whether to generate a notification such as actionable notification or informational notification . In accordance with an embodiment of the invention a different method using context itself is employed. This method essentially calls for using context to implement a state machine. This is done through state variables and their processing procedures . The context variables serve as inputs to the state machine triggering state transition. State events serve as the output of the state machine and are used to trigger a notification generation function to execute. Since context can be associated with another context there is the ability to link up multiple state machines to help determine if a notification should be generated. This is a very powerful concept as multiple types of contexts can cooperate together to arrive at a very sophisticated condition and thereby increase the accuracy of the notification. The state machine within the context takes advantage of the event driven environment to perform state transition and generate outputs. Given the context variables within context have input events the creation of the state machine is greatly simplified.

More particularly flowchart illustrates the steps involved in the development of a context model using context modeling tool described above and depicted in . Flowchart is described with reference to the embodiments of and . However flowchart is not limited to those example embodiments. Note that the steps in the flowchart do not necessarily have to occur in the order shown.

The method begins at step wherein the scope of the context model to be developed is determined. In this step the scope of a context model is determined by answering a series of questions. In an embodiment prior to developing context model a series of determinations are made including determining what situation that the context model will describe what context variables represent the situation to be represented by context model what input events will be the source of context variables what changes to context variables are of interest for consumers of context what if any are the possible state events for context what if any context models may be re used and what are the relationships between reused context models. After the scope of context model is determined control is passed to step .

In step context modeling tool is opened and input events are created. In this step polling events are defined by specifying the polling procedure that will retrieve acquire status from one or more data sources. The schedule and frequency of the polling are also configured in step . In this step context modeling tool is also used to specify the transformation procedure if needed to convert the output of the polling procedure to a canonical form. This conversion may be done by the processing procedure associated with the event. The event provides information needed to convert the output of the polling procedure to a canonical form so the transformation procedure does not need to be specified for each consumer. However each consumer can determine how to take advantage of the notification presented to them in canonical form. The consumers may do further transformation and processing to create a form that is useful to them. After input events are created control is passed to step .

In step notification events are defined. In this step the message format that will be received is specified along with the transformation procedure if needed. The transformation procedure is a processing procedure that converts notification events from received messages to canonical form and from input messages of a Web Service call invoked by a data source to a canonical form. After notification events are defined control is passed to step .

In step context modeling tool is used to test input events to ensure that input events yield the data expected. During this step context modeling tool deploys the developed input events to a test context server as depicted in . In this step polling events can be tested by triggering a corresponding poll procedure. For notification events the context modeling tool will provide a way to generate notification messages for testing. In an embodiment context modeling tool also provides a way to receive actual messages if they are available.

In step an evaluation is made regarding whether input events yield the expected data based on the testing in step . If it is determined that input events yielded the expected data control is passed to step . If it is determined in step that input events did not yield the expected data control is passed back to step in order to modify input events until they generate expected data.

In step a new context model is created. As described above with reference to creation of context model involves adding context variables to context in step . Context variables created in step are not sharable and cannot be reused across multiple context models . After context model is created control is passed to step .

In step simple variables are established and added to context model that was created in step . In this step it is determined if a single value or a vector of values is needed for simple variables. In step a search for input events is conducted and the appropriate input events including polling and notification events are selected to associate with context model . If no suitable input events are found a new input event is created in this step and associated with context model . In step initial value s for simple variables are also set in addition to specifying whether a change event should be raised by a given simple variable. In this step the update frequency option if needed is also established for simple variables. According to an embodiment by a default of value of zero is set for simple variables.

In step derived variables are also established for the context model created in step . This is accomplished by determining if a single value or a vector of values is needed specifying initial value s for the derived variables and specifying the set of simple or derived variables that will be used by the derived variables. If it determined in this step that a new simple variable is needed and not available the simple variable establishment process described in the preceding paragraph is repeated. In this step a processing procedure is specified that takes advantage of all selected context variables to calculate the value or vector of values for the derived variables. In an embodiment of the invention this is accomplished by specifying if processing procedure is to be executed an On Change or Periodic basis. For the Periodic basis or setting schedule and frequency values are set using context modeling tool . In this step context modeling tool is also used to specify whether a change event should be raised by derived variables.

In step contextual variables are also established for context model created in step . Contextual variables are established by searching for a suitable context model using context modeling tool determining if a single reference or a vector of references for context model is needed specifying if an association or composition relationship is needed and specifying whether change event should be raised by the contextual variable. If an association relationship is needed and the reference to the relationship is to be resolved during creation step includes specifying the source of the identifier used to perform the association lookup. In an embodiment the source of the identifier is either a constructor parameter or a variable. If a composition relationship is needed and the reference to the relationship is to be resolved during creation this step includes indicating the parameters to use for calling the constructor of the child context. In accordance with an embodiment this may require the specification of a constructor other than the default constructor. If needed a custom constructor is specified to take care of creating child contexts and other initializations.

In step state variables are also established for the context model. State variables are established in this step by determining if a value or vector of values is required specifying initial value s and specifying processing procedure that may update state variables . According to an embodiment of the present invention processing procedure may raise state events also. Establishment of state variables further includes specifying a set of simple derived or state variables that will trigger processing procedure to execute if there is a processing procedure configured to update state variable . For simple and derived variables a change event is the trigger but for a state variable it is state event . After context variables are established and added to context model control is passed to step .

In step a constructor is defined for context model . In an embodiment a default constructor is generated by context modeling tool if there is no requirement for a default constructor. In this step a minimum of one parameter is specified for defined constructor defined that serves as the identifier for the created context. In step parameter s are added to the constructor as required. These parameters can be used to initialize context variables such as the simple derived and state variables established in step by using context modeling tool to link the parameters to the variables. For example a parameter can be used in the following ways by using context modeling tool to link the parameter to the contextual variable. If there is an association relationship the parameter can be used as the identifier to lookup the referred to context. If there is a composition relationship the parameter is a parameter for the constructor of the child context.

In step context modeling tool can also generate a default constructor. However if custom initialization is subsequently required this must be specified using the default constructor generated in this step as a template. After constructor is defined control is passed to step .

In step the options for the context model are specified. This is accomplished by determining if context model should raise a change event and then the process continues in step .

In step context model is tested by using context modeling tool to generate input events . Input events were already tested in step so the goal in step is to ascertain how input events will affect the behavior of context . As with input event testing in step in this step modeling tool deploys context model to a test context server and the process continues in step .

In step after context model has been developed context generator reads in metadata representing context model and generates support artifacts and code. In an embodiment of the invention the support artifacts and code are output as a generated deployment package as depicted in . For example the resulting output can be packaged into a deployment unit. In an embodiment the deployment unit can be dataset depicted in . Generated code allows a client written in various programming languages to access and manipulate context . According to embodiments of the invention the generated code is written in Java or C .

Code generated in step is based on context model and is specific to that model. This code allows the client to efficiently manipulate the associated context. The client does not have to make an initial determination as to what set of context variables and their types are. In an embodiment there are procedures that set and retrieve each variable that the client can invoke. In this embodiment it is assumed that the client knows context model and what context variables are within the context model. According to an embodiment a context API similar to Java s Reflection API is used to execute code generated in step . In an alternative embodiment a Java object is generated in step that has all of its methods defined by the Java class. The client will use the code generated in step for context model to perform its work.

Various aspects of the present invention can be implemented by software firmware hardware or a combination thereof. illustrates an example computer system in which the present invention or portions thereof can be implemented as computer readable code. For example the method illustrated by flowchart of can be implemented in system . Various embodiments of the invention are described in terms of this example computer system . After reading this description it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and or computer architectures.

Computer system includes one or more processors such as processor . Processor can be a special purpose or a general purpose processor. Processor is connected to a communication infrastructure for example a bus or network .

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . Secondary memory may include for example a hard disk drive a removable storage drive flash memory a memory stick and or any similar non volatile storage mechanism. Removable storage drive may comprise a floppy disk drive a magnetic tape drive an optical disk drive a flash memory or the like. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit may comprise a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art s removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative implementations secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means may include for example a removable storage unit and an interface . Examples of such means may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card or the like. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path . Communications path carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link or other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage unit removable storage unit and a hard disk installed in hard disk drive . Signals carried over communications path can also embody the logic described herein. Computer program medium and computer usable medium can also refer to memories such as main memory and secondary memory which can be memory semiconductors e.g. DRAMs etc. . These computer program products are means for providing software to computer system .

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable computer system to implement the present invention as discussed herein. In particular the computer programs when executed enable processor to implement the processes of the present invention such as the steps in the methods illustrated by flowchart of discussed above. Accordingly such computer programs represent controllers of the computer system . Where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive interface hard drive or communications interface .

The invention is also directed to computer program products comprising software stored on any computer useable medium. Such software when executed in one or more data processing device causes a data processing device s to operate as described herein. Embodiments of the invention employ any computer useable or readable medium known now or in the future. Examples of computer useable mediums include but are not limited to primary storage devices e.g. any type of random access memory secondary storage devices e.g. hard drives floppy disks CD ROMS ZIP disks tapes magnetic storage devices optical storage devices MEMS nanotechnological storage device etc. and communication mediums e.g. wired and wireless communications networks local area networks wide area networks intranets etc. .

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. It will be understood by those skilled in the relevant art s that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims. For example in the above embodiments and description the invention has been described with reference to particular examples such as PDAs Pocket PCs Blackberry devices mobile phones laptop computers etc. It should be understood that the invention is not limited to these examples. The invention is applicable to any elements operating as described herein. Accordingly the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

