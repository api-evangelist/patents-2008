---

title: Enhanced call-back service using rule engine
abstract: An enhanced call-back service, in which a local rule engine is caused to be capable of invoking a rule defined at an external rule engine, and a function provided by the local rule engine is exposed as a call-back service. At the call-back service and from the external rule engine, a request to interact with the function is received, and, using the call-back service, an interaction is provided between the external rule engine and the function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962436&OS=07962436&RS=07962436
owner: SAP AG
number: 07962436
owner_city: Walldorf
owner_country: DE
publication_date: 20080228
---
A rule engine allows the execution logic of a process to be modeled in a straightforward and declarative manner. For example a business rule engine processes the execution logic of a business process. In order to achieve higher agility and flexibility business rule management systems BRMSs separate business related application logic from other types of application logic so that changes to business process models are easier to implement and do not necessarily require specialized programming skills. These BRMSs are used for example in public sector financial and insurance contexts.

According to one general implementation close coupling of local and external rule engines may be enabled by allowing a call back service to orchestrate access by the external rule engine to functions or services provided by the local rule engine or by back end systems accessed via the local rule engine . Such access may be useful in a variety of business contexts.

According to another general implementation a computer implemented process includes causing a local rule engine to be capable of invoking a rule defined at an external rule engine and exposing a function provided by the local rule engine as a call back service. The process also includes receiving at the call back service and from the external rule engine a request to interact with the function and providing using the call back service an interaction between the external rule engine and the function.

Implementations may include one or more of the following features. For example the local rule engine may be caused to be capable of invoking the rule defined at the external rule engine based on transmitting a schema document that defines an input to and an output of an external rule engine to the external rule engine. The call back service may be a web service.

In further examples the process may further include registering a schema document that binds the function with a data type where the function may be a look up function. During a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list of look up functions provided via the call back service. Providing the interaction may further include transmitting to the external rule engine a response providing the list of look up functions including the function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a request for instance data the request identifying the schema document the function and a parameter. Providing the interaction may further include transmitting to the external rule engine the instance data resulting from processing the request using the function.

In additional examples during a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list identifying pre defined data types used by the function. Providing the interaction further may further include transmitting to the external rule engine a response providing the list of pre defined data types used by the function. During a run time of the external rule engine receiving the request to interact with the function further comprises receiving from the external rule engine a request for instance data associated with an identified data type on the list identifying pre defined data types. Providing the interaction may further include transmitting to the external rule engine the instance data associated with the identified type.

In other examples the function may be a conversion function. During a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list of conversion functions provided via the call back service. Providing the interaction may further include transmitting to the external rule engine a response providing the list of conversion functions including the function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a request for instance data the request identifying the function a source unit identifier and a data value. Providing the interaction may further include transmitting to the external rule engine the instance data resulting from processing the request using the function.

In still further examples the function may be a log execution trace function and during a run time of the external rule engine receiving the request to interact with the function may include receiving from the external rule engine a request identifying a previously received call from the local rule engine to the external rule engine and an execution trace logging execution of the call. Providing the interaction may further include storing the received execution trace at the local rule engine.

In additional examples the process may further include registering the function with the call back service the function provided by the local rule engine comprises an internal local rule engine function or an external back end function implemented by a back end system. During a design time of the external rule engine receiving the request to interact with the function may further include receiving a list of functions registered with the call back service. Providing the interaction may further include transmitting to the external rule engine a response providing the list of functions including the external back end function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a back end call. Providing the interaction may further include passing the back end call to the back end system and transmitting to the external rule engine a response resulting from processing the back end call using the external back end function.

In an alternative example during a design time of the external rule engine receiving the request to interact with the function may further include receiving a list of functions registered with the call back service. Providing the interaction may further include transmitting to the external rule engine a response providing the list of functions including the internal local rule engine function. During a run time of the external rule engine receiving the request to interact with the function further comprises receiving from the external rule engine a local rule engine call. Providing the interaction may further include passing the local rule engine call to the local rule engine and transmitting to the external rule engine a response resulting from processing the local rule engine call using the local rule engine function.

In another general implementation a device includes a processor configured to cause a local rule engine to be capable of invoking a rule defined at an external rule engine and to expose as a call back service a function provided by the local rule engine. The processor is further configured to receive at the call back service and from the external rule engine a request to interact with the function and provide using the call back service an interaction between the external rule engine and the function.

In a further general implementation a computer program product is tangibly embodied in a machine readable medium. The computer program product includes instructions that when read by a machine operate to cause data processing apparatus to cause a local rule engine to be capable of invoking a rule defined at an external rule engine to expose as a call back service a function provided by the local rule engine to receive at the call back service and from the external rule engine a request to interact with the function and to provide using the call back service an interaction between the external rule engine and the function.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages of the disclosure will be apparent from the description and drawings and from the claims.

Close coupling of local and external rule engines may be enabled by allowing a call back service to orchestrate access by an external rule engine to functions or services provided by the local rule engine or by back end systems accessed via the local rule engine . Such access may be useful in a variety of business contexts.

A business process refers to a series of business tasks or activities executed in a coordinated order. Applications allow business processes that span multiple functional areas to be modeled using business objects and functions that are processed by a local business rule engine.

A task refers to the atomic business process component that describes an activity or alters a business process s control flow for instance by splitting or joining the business process flow. An exemplary business process may include a dedicated begin task and sequentially executed first through third tasks that each occur prior to the dedicated end task. The execution of certain tasks may require the invocation of an external business rule engine that provides partner supplied functionalities or logic.

Under these circumstances the local business rule engine also referred to herein as a primary or proprietary business rule engine a Formula Derivation Tool FDT or a Business Rules Framework BRF Plus or BRFplus may be integrated with external or third party business rule engines or third party BRMSs . For instance an entity may wish to access a pre configured third party payroll accounting rule set that is provided or optimized for a specific platform or application. By describing these other business rule engines as external it is merely intended that these engines are distinct from the primary or local business rule engine. Thus a business rule engine may be referred to as external even if it is executing on the same machine as the local business rule engine or is associated with the same operator as the local business rule engine.

The back end system may be any system that implements a back end function such as an enterprise system or other company internal system. The local rule engine system which may implement the SAP NETWEAVER FDT or BRFplus includes a local rule engine that defines and processes business rules and that outputs data using a comprehensive application programming interface API . The local rule engine is a hardware or software module that manages and automates business rules.

The call back service may be exposed as a web service as described by a Web Services Description Language or WSDL and includes a service registry that catalogues the available services and a service component that implements a particular functionality as the web service. The BRMS includes an external rule engine that also defines and processes business rules and that outputs results of the external rule processing to the local rule engine system .

In one example configuration the external rule engine includes specialized customized proprietary or protected such as by patent or trade secret business rules that the local rule engine may wish to use or access and the local rule engine includes similar protected business rules that the external rule engine may wish to use or access. In a financial context the external rule engine may provide a credit scoring function which accepts inputs regarding a customer s credit history such as annual income or recent payment delinquencies and which outputs a credit score that rates the consumer against a pool of consumers. If the local rule engine system is operated by a mortgage provider the resulting credit score may be used to determine whether to grant a loan to a consumer.

In this example the operator of the BRMS may not want to release the credit scoring logic used by the external rule engine to derive the credit score to prevent entities from discovering weaknesses that might artificially inflate a person s credit score. At the same time the operator of the local rule engine system may not want a user of the local rule engine to know that a credit score is being sought externally or require a user to take any extra steps to access credit score data.

Thus and using the enhanced approach described herein the local rule engine may seamlessly interface with the BRMS by executing a function that is itself internal to the local rule engine system but which includes an expression that calls the external rule engine . In the described example the expression may call the external rule engine by supplying context information that uniquely identifies a customer in a format structure or data type that is readily understood by the external rule engine based on an earlier provided business vocabulary that assists allows causes or effects the definition of the external business rule.

The external rule engine evaluates or processes the context using the rule and provides result information or simply a result or a response back to the local rule engine in a format structure or data type that is readily understood by the local rule engine . The result provided by the external rule engine is parsed by the expression or parse tree of the local rule engine associated with the called function and an output of the function is returned to the user of the local rule engine system based on the result.

In a similar manner the BRMS may itself use business rules stored invoked or executed in the local rule engine or on the back end system and may also call these functions using internal expressions. Such calls and the concomitant responses may occur and may thus be orchestrated using the call back service .

Thus the function of the Formula Derivation Tool is to trigger processing of rule based logic at the external rule engine through the use of a place holding expression that seamlessly invokes communication to an external rule engine. The derivation of the Formula Derivation Tool refers to a parse tree or expression tree that provides for the parsing of contextual input. For example the derivation may be as sequence of statements such as in logic or mathematics indicating that a result is a natural consequence of previously accepted statements.

In a similar regard an expression may thus be any combination of values functions tokens atoms and procedures interpreted according to the particular rules of precedence and of association for a particular expression type which computes and then returns another value. Similarly an expression type describes the rules of precedence and association for a defined context. For each application executing a particular business process filters may restrict the use of certain expression types expressions or functions in order to reduce the quantity of available objects in a given scenario.

As inferred above the input to a function or expression is referred to as the context and the output or return value of an expression is referred to as a result. Both the context and the result may include data elements such as fields structures or tables or a set of data objects such as a scalar value a work area or a vector value where a scalar refers to a variable that holds one value at a time and a vector is a collection of scalars.

In one example instance a function that models a health insurance business rule may include an expression that accepts a table listing multiple patient names as input or that accepts a single element indicative of a single patient name as input. This function may output an elemental data field indicating whether any of the patients named in the table are insured by an entity executing the business rule or may output a table listing dates and descriptions of recent medical treatments. The rule may thus be understood as an expression or hierarchy of expressions assigned to a particular function such as an insurance fraud detection function a credit scoring function or other exemplary function. The specific rule applied to the input context may depend on the type description or structure of the input context.

In another example instance business objects are input into each business process where business objects represent uniquely identifiable business components entities or data described by a structural model an internal process model or service interfaces. Example business object types include core or hosting business object e.g. a purchase order a customer invoice request or a purchase order replicated business objects e.g. a planning view on a core business object such as a purchase order a business object template e.g. a maximal template of product with all attributes a dependent business object e.g. a reuse part of another business object such as an. address a business foundation object e.g. an object located in a foundation layer such as a business partner .

In contrast to a notion object a business object describes an entity type and not necessarily the instance of the entity itself. Similarly a dependent business object is a business object which is used as a reuse part in or by another business object and which represents a concept that cannot stand by itself from a business perspective. Although instances of dependent business objects may occur in the context of a business object dependent objects are equivalent in terms of structure and functionality over a range of embedding objects.

In more detail when process begins S a local rule engine is caused to be capable of invoking a rule defined at an external rule engine. According to one arrangement and in order to exchange data with the external rule engine the local rule engine first exchanges a vocabulary business vocabulary or BV with the external rule engine where the vocabulary provides the format type description or structure of the data to be exchanged between the local and external rule engines. The vocabulary allows causes or effects the definition of rules at the external rule engine such that input data or contexts received by the external rule engine is appropriately processed and output data or responses are properly formatted and structured for the local rule engine. Based on this vocabulary exchange rule evaluated result data may be easily imported by the local rule engine and processed further.

The exchange of the BV allows for the invocation of remote functionality at the external rule engine by the local rule engine and may also allow for the invocation of local functionally at the local rule engine by the external rule engine. Put another way external invocation of functionality at other rule engines may be said to be orchestrated.

The vocabulary is automatically generated at the local rule engine during a design time phase using context and result information. During a runtime phase i.e. after the deployment or definition of the rule at the external rule engine the local rule engine may invoke the deployed rule at the external rule engine by passing data i.e. the context to the external rule engine. Using the rule that was defined based on the expected context format type description or structure the external rule engine receives and processes the context using the rule and returns a resulting data set to the local rule engine in the appropriate format.

In doing so a business entity is better able to fulfill customer requirements particularly in the public sector insurance and finance fields. Furthermore functional gaps of local rule engines are filled since leading BRMSs which utilize proprietary or specialized rule engines may still be used by the local rule engines. Thus the user is not committed to a particular local rule engine and is offered a best of breed approach to modeling business processes thereby enhancing the overall customer experience. From the perspective of the local rule engine producer seamless integration of third party rule engines may improve their market position as well since BRMS providers may tailor their own products to enhance existing rule engine solutions.

Business rule engines for example local rule engines allow execution logic of a process to be modeled in a declarative and straightforward manner. By separating business related application logic from other application logic for instance organizations may achieve higher agility and flexibility since changes to a business process may be implemented without changing the underlying programming logic.

A local rule engine may be caused to be capable of invoking a rule defined at an external rule engine for example based on transmitting a schema document that defines an input to and an output of the external rule engine to the external rule engine. For instance a rule engine vocabulary including a context description and a result description that respectively define an input to and an output of an external rule engine may be automatically generated the rule engine vocabulary may be serialized in a schema document that when received at the external rule engine allows a rule to be defined based on the context description and the result description and the schema document may be transmitted to the external rule engine. In doing so a BRF is provided that defines a runtime and maintenance environment for the processing implementation and configuration of technical and business rules.

In order to allow the local rule engine or a component of the local rule engine to access the BRMS a function is modeled within the local rule engine to trigger the processing of the rule based logic at the external rule engine through the use of a place holding expression. Thus the function should be modeled or specified with data descriptions that can be understood by the external rule engines so that appropriate data may be transmitted to the external rule engine based on a call to the function.

The vocabulary should thus include for each of the expected context and result a description including a data type of the expected context and result. For instance the vocabulary may describe that an expected context or input may be a patient name of type or a patient identification number of type or an expected treatment cost of type . The expected result or output may be similarly described. Since the expected inputs and outputs of the function are known to the local rule engine system the local rule engine system may automatically generate its own BV for export to the external rule engine by referencing the expected inputs and outputs of a particular function. Notably since the vocabulary is based on a context provided during the design time phase it is not necessary for the rule engines to derive templates or schemas based on past communication.

The context description may be data type that is native to the external rule engine. For instance the vocabulary may be automatically generated using generic data objects such as a field structure or table data objects. In doing so the vocabulary may be used to specify the basic language constructs that define the universe of discourse between the local and external rule engines. In this regard the vocabulary may be viewed as a published description of the intended format type or structure of the context and the result that are to be communicated between the local rule engine and the external rule engine.

Furthermore a connection may be defined as a placeholder EBRMS expression that allows the local rule engine to be seamlessly integrated with the external rule engine using local rule engine internal rule processing approaches. Since users of the local rule engine are not alerted to the external calls complexity and integration costs are reduced.

The local rule engine may include generic expression subclasses such as the instance constant expression subclass decision table expression subclass a decision tree expression subclass a formula expression subclass and a function call expression subclasses as well as the aforementioned EBRMS expression subclass that allows for communication between the local and external rule engines. The EBRMS expression subclass may include for example an association to an abstract GBRMS Cclass that encapsulates parameters and function calls that are generally used to communicate with the external rule engine. The EBRMS expression instance is thus chosen created specified or otherwise defined within the expression tree at the local rule engine to connect the local rule engine to the external rule engine once the rule has been defined at the external rule engine.

Defining the expression may further include querying the rule engine to determine connection parameters and selecting the defined expression from a list of possible expressions based on the determined connection parameters. The EBRMS expression subclass may include and P functions that allow the local rule engine to determine these connection parameters and distinguish between various external rule engine application platform subclasses using reflecting programming. For example using the P function a local rule engine may determine that the external rule engine uses a Java adapter and may specify an EBRMS expression that implements a Java BRMS connector that encapsulates parameters and function calls used to communicate with a Java Adapter of the external rule engine.

Included in the schema document are the context and result definitions or descriptions that were automatically generated so as to be provided to the external rule engine. Since the context or result may be an element structure table or other type of data the schema document identifies which type of data the context or result is expected to be and provides a run time XML element associated with the identified data type.

The schema document expresses a set of rules to which a document must conform in order to be considered valid according to that schema. In this regard other schema document languages or approaches such as RELAX NG or Document Type Definitions DTDs or Schematron may be substituted or used as an adjunct for an XSD. The vocabulary serialized in the schema document allows rules to be defined on the basis of the terms and relations encoded in the vocabulary.

The schema document is transmitted to the external rule engine. A rule is defined and tested at the external rule engine based on the context description and the result description included in the received schema document. When received at the external rule engine the schema document allows a rule to be defined based on the context description and the result description. The schema document thus provides a basis for the definition of rules by the external rule engine.

The BV is derived from the local rule engine context and is provided in a generic format in the schema document. From the BV which is defined and provisioned during the design phase the rule is defined by the BRMS during the design time phase and deployed for the runtime phase. Using the BV the external rule engine uses an import function to link XML and Java templates by associating XSD entities and attributes or by creating or updating templates corresponding to XSD entities or attributes of such templates that corresponding to XSD attributes and that refer to nested entities where no more than one may occur . Furthermore the external rule engine may create or update templates representing any XSD relationships other than tree structure concepts implemented by such templates and attributes relations between such concepts as exist between the templates and their attributes that correspond to the imported schema documents or verb phrasings for such relations.

Concepts relations and verb phrasings may be updated not created if an XML template is assigned. Therefore an initial provision of concepts relations and verb phrasings may or may not occur using a default XSD Import wizard.

The schema document should also incorporate standard components such as a W3C XML Schema as well as a schema extension component FDT T that extends the standard components to specify a business context name and to define additional data constructs. The schema extension component may be imported via an element as a second namespace by the schema document . As indicated above the schema document is transmitted form the local rule engine to the external rule engine during a design time phase .

The schema document is used as a basis for defining a rule at the external rule engine where the rule is used during a run time phase to process contexts generated by the local rule engine according to the vocabulary and to output results . Thus the local rule engine may be caused to be capable of invoking the rule defined at the external rule engine based on transmitting the schema document that defines an input to and an output of an external rule engine to the external rule engine and vice versa.

Returning to a function provided by the local rule engine is exposed as a call back service S . As shown in the call back service infrastructure CSI exposes a function of the local rule engine as a web service as described by a WSDL a Java connector JCO or other integration solution . In exposing the function non trivial service operations to n representing any quantity which orchestrate the tight interaction scenarios between the local rule engine and a rule engine of the BRMS are provided.

As described in further detail below service operations which may be provided by the CSI may include but are not restricted to data look up data type look up unit conversion log execution trace backend function call local rule engine call or any other operation in which the BRMS accesses functionality or operations of the local rule engine via the CSI .

Although interaction between the BRMS and the local rule engine is described herein using a web service based on SOAP calls in other implementations other integration approaches may be used. As noted above this robust integration architecture includes the use of JCO or any other integration solution . In addition to the elements and services depicted in and depending upon a desired service configuration interaction between the BRMS and the local rule engine may utilize a registration service.

Furthermore the CSI includes core services that are used for managing the interaction of the BRMS with the local rule engine . For instance the core services may provide a logging service which log details about a traceable interaction between the BRMS and the local rule engine . Likewise the core services may provide an existing connection or metadata management service. As depicted by virtual connection it is possible that interactions between the local rule engine and the BRMS may occur without the intervention of the CSI .

Returning to a request to interact with the function is received at the call back service from the external rule engine S and using the call back service an interaction is provided between the external rule engine and the function S before the process ends S . infra describe several exemplary interactions in which a BRMS transmits one or more requests to a local rule engine and in which a response is transmitted in reply via a call back service.

During a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list of look up functions provided via the call back service and providing the interaction may further include transmitting to the external rule engine a response providing the list of look up functions including the function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a request for instance data the request identifying the schema document the function and a parameter and providing the interaction may further include transmitting to the external rule engine the instance data resulting from processing the request using the function.

Using a look up interaction instance data for a given data types may be queried making it possible to sensitively load particular requested data during design time and runtime without requiring the transport of all data associated with a data type to a BRMS. In addition to instance values more complex descriptions for instance from a data dictionary DDIC or an enterprise service repository ESR may be retrieved and transported to the BRMS.

Initially look up services are registered with a look up service registry so that the look up interaction may occur S . This registration creates an internal binding for each data type identifying a data source associated with the particular concept. By registering the look up services a BRMS is provided with the ability to call the look up service during design time or runtime.

Registration is provided using context descriptions included in XSD schemas that reflect the basic data integration infrastructure between an local rule engine and a BRMS . The binding may reflect for instance that a data type PATIENT specified in XSD A includes a binding to a look up service capable of retrieving particular or desired instance values based on a runtime query that specifies particular parameters. Different XSD schemas can bind the same data type in different ways or to different look up services.

During a design time a user can query the look up service registry to provide a list of actual look up services that may be used in a modeling process. Specifically a SOAP request may be sent from the BRMS to the look up service registry requesting an indication of the data look up services provided by the CSI S . Further the look up service registry may respond to the request with a response providing a list of look up services including the look up service provided by the CSI that can be used as modeling entities in the BRMS S .

The look up service may also be used directly in the BRMS in order to query the local rule engine for instance data during runtime. In doing so it is possible to model rules that use instance values of data objects specified in the XSD schema upon which the integration is based. For instance a rule used by the BRMS may compare two patients John Doe and Jane Doe associated with the data type P where the data type Pis specified in the XSD schema A 

Similarly a data look up interaction may occur during runtime. Specifically a SOAP request may be sent from the BRMS to the look up service referencing a registered schema a concept or data type described in the registered schema and additional parameters such as ranges S . The look up service may process the request and may respond to the request with a response providing a list of instance values for a requested concept or an error in case the concept is not registered S .

This look up interaction allows the BRMS to query the local rule engine for additional data or specific data during the execution of a rule on the BRMS without requiring the transfer of large amounts of data such as entire patient treatment histories in a call to the BRMS . As such the data look up functionality provided by the look up service may be used to receive queries and return data relating to the treatment history of a particular patient. Such queries may be initiated by statistical or other measures such as when a rule executing on the BRMS determines that insurance fraud may be occurring.

Where the interaction refers to a data type look up interaction the data type look up interaction includes during a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list identifying pre defined data types used by the function and providing the interaction further may further include transmitting to the external rule engine a response providing the list of pre defined data types used by the function. During a run time of the external rule engine receiving the request to interact with the function further comprises receiving from the external rule engine a request for instance data associated with an identified data type on the list identifying pre defined data types and providing the interaction may further include transmitting to the external rule engine the instance data associated with the identified type.

The local rule engine includes comprehensive standardized lists of instances or values associated with pre defined data types. For example the currency data type may include instances representative of U.S. dollars Euros Japanese Yen or other specified currencies and a country data type may include instance representative of Germany France the United States Canada Australia or other countries or symbols abbreviations or other indicia types corresponding to those countries. The CSI provides the data type look up service that allows the BRMS to load these lists during design time so that the modeling capabilities may be aligned with those of the local rule engine or other backend system.

During a design time the BRMS sends a request such as via a SOAP or API request to the data type look up service registry of the CSI S requesting a list of data types used by the local rule engine . The CSI sends a response to the request back to the BRMS where the response may be displayed to a user S . The response includes a list of data types for which data type look up interaction is provided by the CSI and further includes textual descriptions and identifiers that allow the user to select which data types they wish to import.

Upon selecting one or more data type lists such as upon selecting a currencies data type list the BRMS sends a request to the data type look up service of the CSI the request including an identifier identifying a requested data type list S . The request is received by the CSI and passed on the local rule engine S . The local rule engine compiles a result set that is passed back to the CSI S where a response listing the data types requested by the BRMS is sent to the BRMS processed and stored such that the data type instances can be accessed during a modeling phase S .

Where the interaction refers to a conversion interaction the interaction includes during a design time of the external rule engine receiving the request to interact with the function may further include receiving a request for a list of conversion functions provided via the call back service and providing the interaction may further include transmitting to the external rule engine a response providing the list of conversion functions including the function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a request for instance data the request identifying the function a source unit identifier and a data value and providing the interaction may further include transmitting to the external rule engine the instance data resulting from processing the request using the function.

The conversion of units for instance the conversion of U.S. dollars to Euros may be subject to legal regulations. For instance varying conversion rules may be applied depending upon the context in which the conversion is being carried out such as the country in which the conversion occurs or the currency or currencies being converted. Thus may be useful to carry out a currency conversion in an enterprise system such as local rule engine that is configured or adapted to comply with particular regulations rather than to process the currency conversion at an external rule engine .

The currency conversion interaction between the CSI and the BRMS begins when the BRMS transmits a request to a unit conversion service registry for an indication of the unit conversion service capabilities provided by the CSI S . A response to the request returns the service identifiers of services that provide such an interaction including the unit conversion service where the service identifier represents a concrete binding to a service that implements the conversion interaction and which can be used as a modeling entity in the BRMS S .

During run time the BRMS may halt its own rule execution and send a request to the CSI to invoke a currency conversion at the CSI where the request includes a target currency a source currency a data value to be converted a reference to a run time instance or service S . The reference to the actual run time instance is transferred from the BRMS to the CSI so that the local rule engine may determine the type of conversion to perform.

The request is received by the CSI and passed to the local rule engine which effects the unit conversion S . The result of the conversion is transmitted back to the CSI S which prepares and sends a response to the BRMS S . The response includes the conversion result and a reference to the run time instance.

Using this type of currency conversion interaction the BRMS is not required to implement currency conversion functionality which is available in the local rule engine . By allowing the BRMS to effect performance of this functionality at the local rule engine requirements such as requirements imposed by Sarbanes Oxley legislation or by other accounting standards may be satisfied using functionality available at the local rule engine rather than the BRMS .

BRMS may process data for which special auditing or security requirements apply. Thus it may be useful to log the execution of rules in a way that allows subsequent auditing and reconstruction of processing results. Use of the log execution trace service begins when a call to the BRMS has been made during an execution time and when the BRMS has finished the execution of rules and send the result of the execution to the local rule engine S . The BRMS logs the execution in a text format.

The request to log the execution trace is transmitted from the BRMS to the log execution trace service the request including the plain text execution trace and an identifier of the call S . The log execution trace service of the CSI transmits the execution trace and identifier to the local rule engine which stores the trace for future reference S . Call identifiers are created and maintained at the local rule engine for every call allowing the log execution trace to be unambiguously matched with the appropriate call when received.

Where the interaction refers to a back end function interaction the back end function interaction may include registering the function with the call back service the function provided by the local rule engine comprises an internal local rule engine function or an external back end function implemented by a back end system. During a design time of the external rule engine receiving the request to interact with the function may further include receiving a list of functions registered with the call back service and providing the interaction may further include transmitting to the external rule engine a response providing the list of functions including the external back end function. During a run time of the external rule engine receiving the request to interact with the function may further include receiving from the external rule engine a back end call and providing the interaction may further include passing the back end call to the back end system and transmitting to the external rule engine a response resulting from processing the back end call using the external back end function.

Internal components of the back end can expose functions to the local rule engine allowing the local rule engine to access these functions during the internal rule execution. These functions may be integrated as expression types in the local rule engine s rule execution tree. The internal rule execution is suspended if a backend function call is reached during traversal of the local rule engine s execution tree. The backend function is called and the rule execution is resumed after the result of the call is received. Backend functions may for instance be used to query for additional data or to perform complex calculations. This interaction allows backend functions can be exposed to and used by the BRMS .

Specifically the back end function call begins when the backend functions which are to be exposed to the BRMS are made accessible via a registration operation S in which a function such as function registers itself with the back end function call service registry . The BRMS transmits a request for a list of registered backend functions that are accessible to the BRMS S and a response including a list of service identifiers is transmitted to the BRMS in reply S . The service identifiers represent a concrete binding to a service which may be used as a modeling entity in the BRMS . The back end functions or services may be used in the modeling environment of the BRMS as independent entities.

During run time the BRMS transmits a request calling a back end function S and the call is passed to the requested function in the back end S . A result of the back end function is generated S and the CSI generates and transmits a response returning the result to the BRMS S 

This reverse call back interaction enables the BRMS to suspend its own rule execution in order to invoke the execution of an artifact in the local rule engine thereby inverting the normal or forward call back infrastructure. This interaction may be useful since the BRMS may itself be inflexible and incapable of performing certain functionalities whereas the local rule engine may be developed with mass data processing use in mind. Thus it may be desirable to mix or integrate the rule execution of both the BRMS and the local rule engine in order to capitalize on the strength and inherent advantages of each system.

Artifacts or functions modeled in the local rule engine that are to be exposed to the BRMS are made accessible via a registration operation S . In doing so these functions are made available to users of the BRMS which can transmit a request for a list of available local rule engine function call services including a local rule engine function call service S . The function call service registry transmits a response including a list of service identifiers where each service identifier represents a concrete binding to a service that can be used as a modeling entity in the BRMS S .

During a runtime the BRMS suspends its rule execution and transmits a request calling a function call service on the list of function call services S A response to the request is transmitted from the CSI including a result of the function call S and the BRMS resumes its rule execution using the result S . Accordingly arbitrarily nested calls are allowed between the BRMS and the local rule engine .

Using this exemplary framework the external rule engine may be loosely coupled to the local rule engine and thus may not necessarily be capable of invoking functionality of the local rule engine. Furthermore since other data transport mechanisms may require that all data to be processed by the external rule engine be transferred from the local rule engine to the external rule engine which then should process and return a result to the dataset the dataset and sends a result back the data transport mechanism may not be feasible in cases where the amount of relevant data large.

Thus the enhanced call back approach allows for a tighter integration of external rule engines with the local rule engine. This advantage allows for the reduction of integration costs and for new and extended use cases that previously could not be implemented.

As is described in more detail below the device includes a processor an interface and an output module. The processor automatically generates a rule engine vocabulary including a context description and a result description that respectively define an input to and an output of an external rule engine and serializes the rule engine vocabulary in a schema document that when received at the external rule engine allows a rule to be defined based on the context description and the result description. The interface transmits the schema document to the external rule engine transmits a context specified according to the context description as the input to the external rule engine for evaluation by the rule and receives a rule evaluated result specified according to the result description as the output of the external rule engine. The output module outputs the result.

In more detail the hardware environment of the device includes a display monitor for displaying text and images to a user a keyboard for entering text data and user commands into the device a mouse for pointing selecting and adjusting objects displayed on the display monitor a fixed disk drive a removable disk drive a tape drive a hardcopy output device and a computer network connection .

The display monitor displays graphics images and text that comprise the display for the software applications used by the device as well as the operating system programs necessary to operate the device . A user uses the keyboard to enter commands and data to operate and control the computer operating system programs the web browser and or the rule engine. The user uses the mouse to select and adjust graphics and text objects displayed on the display monitor as part of the interaction with and control of the device and applications running on the device . The mouse is any type of pointing device and may be a joystick a trackball a touch pad or other pointing device.

In a further implementation the fixed disk drive itself may include a number of physical drive units such as a redundant array of independent disks RAID or may be a disk drive farm or a disk array that is physically located in a separate computing unit. Such computer readable memory media allow the device to access computer executable process steps application programs and the like stored on removable and non removable memory media.

The wireless or wireline computer network connection may be a modem connection a local area network LAN connection including the Ethernet or a broadband wide area network WAN connection such as a digital subscriber line DSL cable high speed internet connection a power line communication PLC connection a dial up connection T 1 line T 3 line fiber optic connection or satellite connection. The network may be one or more of a LAN network a corporate or government WAN network the Internet or other network.

The computer network connection uses a wireline or wireless connector. Example wireless connectors include for example an INFRARED DATA ASSOCIATION IrDA wireless connector an optical wireless connector an INSTITUTE OF ELECTRICAL AND ELECTRONICS ENGINEERS IEEE Standard 802.11 wireless connector a BLUETOOTH wireless connector a near field communications NFC connector an orthogonal frequency division multiplexing OFDM ultra wide band UWB wireless connector a time modulated ultra wide band TM UWB wireless connector or other wireless connector. Example wireline connectors include for example a IEEE 1394 FIREWIRE connector a Universal Serial Bus USB connector a serial port connector a parallel port connector or other wireline connector.

The removable disk drive is a removable storage device that is used to off load data from the device or upload data onto the device . The removable disk drive may be a floppy disk drive an IOMEGA ZIP drive a compact disk read only memory CD ROM drive a CD Recordable drive CD R a CD Rewritable drive CD RW flash memory a USB flash drive an external hard disk drive thumb drive pen drive key drive a High Density Digital Versatile Disc HD DVD optical disc drive a Blu Ray optical disc drive a Holographic Digital Data Storage HDDS optical disc drive or any one of the various recordable or rewritable digital versatile disc DVD drives such as the DVD Recordable DVD R or DVD R DVD Rewritable DVD RW or DVD RW or DVD RAM. Operating system programs applications and various data files are stored on disks which are stored on the fixed disk drive or on removable media for the removable disk drive .

The tape drive is a tape storage device that is used to off load data from the device or to upload data onto the device . The tape drive may be a quarter inch cartridge QIC 4 mm digital audio tape DAT 8 mm digital linear tape DLT drive or other type of tape.

The hardcopy output device provides an output function for the operating system programs and applications. The hardcopy output device may be a printer or any output device that produces tangible output objects including textual or image data or graphical representations of textual or image data. While the hardcopy output device is depicted as being directly connected to the device it need not be. For instance the hardcopy output device may be connected to device via a network interface such as a wireline or wireless network.

Furthermore although the device is illustrated in as a desktop PC in further implementations the device may be a laptop a workstation a midrange computer a mainframe an embedded system telephone a handheld or tablet computer a PDA or other type of device that includes a data processing apparatus.

The computing environment includes a computer central processing unit CPU where the computer instructions that comprise an operating system or an application are processed a display interface which provides a communication interface and processing functions for rendering graphics images and texts on the display monitor a keyboard interface which provides a communication interface to the keyboard a pointing device interface which provides a communication interface to the mouse or an equivalent pointing device a hardcopy output device interface which provides a communication interface to the hardcopy output device a random access memory RAM where computer instructions and data are stored in a volatile memory device for processing by the computer CPU a read only memory ROM where invariant low level systems code or data for basic system functions such as basic input and output I O startup or reception of keystrokes from the keyboard are stored in a non volatile memory device a storage medium or other suitable type of memory e.g. such as random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM magnetic disks optical disks floppy disks hard disks removable cartridges flash drives where the files that comprise an operating system application programs including web browser application call back service application and other applications as necessary and data files are stored and a computer network interface which provides a communication interface to the network over the computer network connection . The constituent devices and the computer CPU communicate with each other over the computer bus .

The call back service application may be or may be compatible with an SAP rule engine a Workflow Magic rule engine an OpenLexicon rule engine an OpenRules rule engine a NxBRE rule engine a Rools rule engine a JBoss Rules rule engine or any other software system that helps manage and automate business rules.

Briefly a computer program product is tangibly embodied in the machine readable storage medium . The computer program product includes instructions that when read by a machine operate to cause a data processing apparatus such as the CPU to cause a local rule engine to be capable of invoking a rule defined at an external rule engine to expose as a call back service a function provided by the local rule engine to receive at the call back service and from the external rule engine a request to interact with the function and to provide using the call back service an interaction between the external rule engine and the function.

The RAM interfaces with the computer bus so as to provide quick RAM storage to the computer CPU during the execution of software programs such as the operating system application programs and device drivers. More specifically the computer CPU loads computer executable process steps from the fixed disk drive or other media into a field of the RAM in order to execute software programs. Data is stored in the RAM where the data is accessed by the computer CPU during execution.

Also shown in the device stores computer executable code for a operating system and application programs such as word processing spreadsheet presentation gaming web browsing JavaScript engine or other applications. Although it is possible to provide for the enhanced call back service using the above described implementation it is also possible to implement the functions according to the present disclosure as a dynamic link library DLL or as a plug in to other application programs such as an Internet web browser such as the APPLE SAFARI web browser or the MICROSOFT INTERNET EXPLORER web browser.

The computer CPU is one of a number of high performance computer processors including an INTEL or AMD processor a POWERPC processor a MIPS reduced instruction set computer RISC processor a SPARC processor an ACORN RISC Machine ARM architecture processor a HP ALPHASERVER processor or a proprietary computer processor for a mainframe. In an additional arrangement the computer CPU is more than one processing unit including a multiple CPU configuration found in high performance workstations and servers or a multiple scalable processing unit found in mainframes.

The operating system may be APPLE MAC OS X for INTEL and POWERPC based workstations and servers MICROSOFT WINDOWS NT WINDOWS 2000 WINDOWS XP Workstation MICROSOFT WINDOWS VISTA WINDOWS NT WINDOWS 2000 WINDOWS XP Server a variety of UNIX flavored operating systems including AIX for IBM workstations and servers SUNOS for SUN workstations and servers LINUX for INTEL CPU based workstations and servers HP UX WORKLOAD MANAGER for HP workstations and servers IRIX for SGI workstations and servers VAX VMS for Digital Equipment Corporation computers OPENVMS for HP ALPHASERVER based computers SYMBIAN OS NEWTON IPOD WINDOWS MOBILE or WINDOWS CE PALM NOKIA OS NOS OSE or EPOC for mobile devices or a proprietary operating system for computers or embedded systems. The application development platform or framework for the operating system may be BINARY RUNTIME ENVIRONMENT FOR WIRELESS BREW Java Platform Micro Edition Java ME or Java 2 Platform Micro Edition J2ME PYTHON FLASH LITE or MICROSOFT .NET Compact.

While illustrate one possible implementation of a computing system that executes program code or program or process steps configured to effectuate an enhanced rule engine other types of computers may also be used as well.

As to formal matters while the term user has been consistently used to describe an entity that interacts with these processes such a generalization is also intended to describe multiple related or unrelated living or automated entities or beings that interact with these processes at various different overlapping or non overlapping states.

In a similar vein the term selection is intended to denote throughout a manual selection by a human an automatic selection by a non human or some combination thereof. Finally it is noted that for the sake of brevity the terms Java and JavaScript are intended to reference the SUN MICROSYSTEMS JAVASCRIPT programming language and the term XML is intended to reference eXtensible Markup Language throughout.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other implementations are within the scope of the following claims.

