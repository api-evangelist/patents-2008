---

title: Method for manipulating objects in a SOA registry
abstract: A registry object in a service oriented architecture (SOA) is manipulated by an application. A mapping is defined between a registry object type and an application object type. The application object type is instantiated in the application. The instantiated object facilitates manipulation of the registry via the defined mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183040&OS=09183040&RS=09183040
owner: SOFTWARE AG
number: 09183040
owner_city: Darmstadt
owner_country: DE
publication_date: 20081215
---
This application claims priority to European Application No. 08016448.6 filed 18 Sep. 2008 the entire contents of which are hereby incorporated by reference.

Modern applications particularly in the context of Service Oriented Architectures SOA often comprise a plurality of independent components which cooperate in order to provide the overall functionality of the application. To this end SOA registries may be used to publish discover and utilize such components. A SOA registry is usually a shared resource which stores descriptions of components of a SOA and means for querying the SOA registry for certain components in the sense of electronic yellow pages . Furthermore a SOA registry may be able to not only store descriptions of web services commonly used in SOAs but any kind of component may be described by defining custom types.

In the prior art there is a number of registry specifications defining the structure and information model of the contents of a SOA registry e.g. ebXML and UDDI. In order to enable an application to access the contents of a SOA registry i.e. to publish new components to look up existing components etc. application programming interfaces APIs are known from the prior art the most popular being the Java API for XML registries JAXR .

JAXR is a generic API in that it provides access to various kinds of SOA registries e.g. to SOA registries conforming to the above described specifications. Therefore JAXR defines an information model which tries to unify the different information models of the different registry specifications.

However due to the fact that JAXR is generic the task of programming an application which utilizes JAXR is very complex and requires a detailed understanding of the underlying JAXR information model. E.g. the process of creating a registry object of a certain custom type in the SOA registry may require an application to perform a plurality of steps like creating a generic registry object creating a custom concept and linking the registry object with the concept by a classification object. Similar steps have to be defined when accessing existing registry objects. These steps typically have to be repeated every time a new registry object is to be created or searched which is inefficient and error prone so that the operation of the programmed application is likely to fail.

In view of the above it is therefore the technical problem underlying the present invention to improve the access of an application to a SOA registry through JAXR so that the manipulation of the registry objects is more efficient and less error prone and to thereby at least partly overcome the disadvantages of the prior art.

This problem is according to one embodiment of the invention solved by a method for manipulating at least one registry object of a SOA registry by an application the at least one registry object being accessible through a Java API for XML registries JAXR . In the embodiment of claim the method comprises the steps of 

Accordingly a mapping is defined which maps registry object types onto application object types i.e. application objects which are instances of application object types serve as a kind of surrogate for registry objects in the SOA registry which are instances of registry object types . The mapping is described by one or more Java annotations which allows for a concise and easy to read mapping definition that is flexibly adaptable as further outlined in the detailed description below. The mapping is typically a 1 1 mapping i.e. it maps one application object type onto one corresponding registry object type. However also 1 n mappings are possible with the present invention i.e. one application object type is mapped onto more than one registry object type or even a m n mapping may be defined.

At least one instantiated application object is then provided to the application. A manipulation of the application object by the application results in a related manipulation of the corresponding at least one registry object through the JAXR. This may be achieved in that the application object preferably offers a set of simple operations to the application and internally utilizes the complex JAXR therefore hiding the specifics of accessing the JAXR from the application.

In one aspect of the invention the at least one registry object may comprise at least one property and the mapping may comprise a mapping of the at least one property onto at least one property of the corresponding application object.

The JAXR information model may define different notions of properties of registry objects e.g. object properties object slots and properties of JAXR defined object types which are described in the detailed description below. An application however may comprise different notions of properties e.g. private attributes accessible through get and set operations. Therefore the JAXR property notions are mapped onto the application property notions. The purpose of this mapping is that when the application manipulates an application object i.e. by setting the value of a property of an application object the application object is able to set the corresponding property of the corresponding registry object e.g. by utilizing the JAXR.

In another aspect of the invention the at least one property of the at least one registry object may hold at least one string value and the mapping onto the at least one property of the corresponding application object comprises a conversion to a string value.

Certain types of properties in the JAXR information model e.g. object slots may be limited to storing values of the type string i.e. a simple sequence of characters. On the other hand the application may support a variety of other types such as integers boolean date calendar etc. Since the values of the application object properties are converted to strings they can be propagated to the corresponding properties of the registry objects and vice versa.

In yet another aspect of the invention the at least one registry object may be related to at least one second registry object by one or more association objects and the at least one application object may be related to at least one second application object by one or more aggregation and or dependency relationships and the mapping may comprise a mapping of the one or more association objects onto the one or more aggregation and or dependency relationships.

Furthermore the at least one registry object may be related to at least one concept of the SOA registry by one or more classification objects and the at least one application object may be related to at least one second application object by one or more aggregation and or composition relationships and the mapping comprises a mapping of the one or more classification objects onto the one or more aggregation and or composition relationships.

Additionally or alternatively the at least one registry object may be related to at least one classification scheme by one or more classification objects the at least one classification scheme defining at least one taxonomy in the SOA registry and the mapping may comprise a mapping of the at least one registry object onto the corresponding at least one application object.

Furthermore at least one second registry object may be related to at least one concept by one or more classification objects the at least one concept being a child concept in the at least one taxonomy. On the other hand at least one second application object may be related to the at least one application object by an inheritance relationship and the mapping may comprise a mapping of the at least one second registry object onto the at least one second application object.

As can be seen the JAXR information model may define various notions of relationships between registry objects in the XML registry e.g. associations classifications and taxonomies i.e. classification schemes . These notions may be mapped onto suitable notions of the application domain e.g. aggregation composition dependency and inheritance relationships. The specific JAXR notions application notions and the mappings are further explained in the detailed description below.

In one aspect of the invention step b. may comprise the step of creating in the SOA registry the at least one registry object corresponding to the at least one application object. Furthermore step b. may comprise the step of querying the SOA registry for the at least one registry object corresponding to the at least one application object. The two aspects allow the application to create new entries i.e. new registry objects in the SOA registry as well as to search for existing registry objects.

In another aspect of the invention the definition of the mapping is based on a set of pre defined mapping rules and the method comprises the further step of defining at least one new mapping rule. As explained above the method provides mapping rules for mapping the notions of the JAXR information model onto notions of the application. In order to enable an extension of the mapping rules for other notions new mapping rules may be defined. This ensures that e.g. a custom application can provide its own implementations of mapping rules not originally provided by the method. These custom mapping rules may then be used by the method to process the custom mappings so that the method is flexibly adaptable to new custom notions and information models.

In a further aspect the at least one application object is adapted for loading a property or a relationship only when the property or the relationship is accessed by the at least one application. Accordingly a property or relationship may not be loaded into the application object until it is actually accessed by the application. This is especially advantageous when loading complex application objects with many properties and relationships or application objects with large data which would normally require much processing power and memory in the application. It is also advantageous for composite registry objects i.e. objects that comprise other objects.

In a further aspect of the invention the at least one application object is a Java Bean and the application object type is an interface definition of a Java Bean. Java Beans are special types of Java programs comprising a number of classes and interfaces. The notion of Java Beans is explained in the detailed description below.

Finally the invention also relates to a computer program comprising instructions for implementing any of the above described methods.

In the following a presently preferred embodiment of the invention is described with respect to a scenario as schematically shown in . As can be seen a SOA registry which may e.g. be an XML registry comprises a registry object . further shows an application supposed for manipulating the registry object in the SOA registry . In the prior art shown in the application may directly utilize a Java API for XML registries JAXR as shown by the arrows in . As already described above the JAXR is an application programming interface API for accessing various kinds of SOA registries e.g. UDDI and ebXML registries which is very generic and powerful but has a high level of complexity. The prior art approach shown in therefore may lead to complex and error prone application code in the application due to the complexity of the JAXR .

In contrast the method of the present invention as shown in hides the complexity of the JAXR and allows the application to manipulate the registry object in a more efficient and simple way. This is achieved in that the application is provided with an application object which serves as a kind of surrogate for the registry object . A manipulation of the application object by the application results in a related manipulation of the corresponding registry object in that e.g. the application object may utilize the JAXR internally shown by the horizontal arrows in thus hiding the complexity of the JAXR from the application .

The JAXR defines an information model for the registry objects in the SOA registry i.e. it defines that the registry object may comprise among others certain types of properties and relationships to other registry objects. On the other hand the application may define different notions of properties and relationships depending on the concrete implementation of the application . Therefore the JAXR information model concepts are mapped onto related concepts of the application by the invention.

In the following the mapping concepts are first described in general terms and then illustrated by a concrete mapping of the JAXR notions onto notions of Java beans see used e.g. in CentraSite of applicant. CentraSite is a platform for SOA governance and lifecycle management for the development of SOA applications. It should however be appreciated that Java beans are only one of a wide variety of implementations for the application and that the advantageous concepts of the present invention may be easily adapted to other programming languages. Accordingly the present invention is not limited to a concrete product like CentraSite or the JAXR but may as well be employed in other scenarios. Furthermore although only shows one exemplary registry object and a corresponding application object it should be appreciated that the present invention works for any number of objects in the SOA registry .

The determination of which application object is a surrogate for which registry object is done by a mapping as shown in . The mapping is defined on the type level i.e. between an application object type and a registry object type . Consequently the application object which is an instance of the application object type serves as a kind of surrogate for the registry object which is an instance of the registry object type .

As can be seen an interface definition of an interface Item corresponding to the application object type is annotated by an RegistryObject annotation which maps the Item interface onto a corresponding registry object type named http namespaces.CentraSite.com csafItem via the objectTypeName parameter in a declarative way.

The JAXR information model comprises at least three notions of properties of registry objects JAXR object properties JAXR object slots and properties of JAXR defined object types i.e. properties which are specific to JAXR defined object types as opposed to general properties of the general JAXR object type RegistryEntry such as name or description . JAXR object slots provide a dynamic way to add arbitrary attributes to a registry object at runtime which enables extensibility within the information model. On the other hand application objects like e.g. Java beans in an application may comprise bean properties and corresponding get and set operations to read and manipulate the bean properties.

Accordingly standard JAXR registry object properties may be mapped to bean properties by a direct property to property mapping as shown below 

As can be seen the bean property description represented by its get operation getDescription of the application object is mapped onto a corresponding JAXR registry object property. Since the Property annotation is used without parameters the bean property description may be mapped onto a JAXR registry object property with the same name by default. In case a JAXR registry object property with a different name is targeted an annotation of the form Propety target anotherRegistryObjectProperty may be used accordingly.

The JAXR may only allow object slots to have string values. Java beans however may utilize a number of other property types like integer boolean date calendar etc. Therefore the bean properties are preferably converted to string values.

Properties of JAXR defined object types i.e. JAXR registry object properties of certain JAXR specific types e.g. TelephoneNumber or PersonName defined by the JAXR standard may be mapped onto bean properties using a dedicated annotation like depicted below 

JAXR relationships between registry objects may be represented by three objects e.g. a source registry object may be related to a target registry object through an association object. This notion is depicted in where the registry object is related to the registry object through the association object .

On the other hand the application may know relationships represented by two objects e.g. the application object may be related to the application object through an aggregation or dependency relationship wherein the aggregation or dependency relationship is not an object. In the context of a Java bean an aggregation relationship may be represented by a get operation of a bean property of the Java bean which represents the application object wherein the return value of the get operation determines the target application object the application object . The following code listing illustrates this aspect 

As can be seen the bean property action represented by its get operation getActions is mapped to the corresponding JAXR association object itself by setting the mappedTo parameter of the Association annotation to the target object of the association. The type parameter determines the type of the association object i.e. the JAXR concept which represents the association and the targetType parameter indicates the type of the association target i.e. the type of a bean which is the target of the association. In this example the type of the bean is mapped to the association object. Alternatively mappedTo MappedTo.ASSOCIATION TARGET could be used in that the targetType parameter specifies the type of the bean mapped to the association target. Additionally an AssociationTarget annotation may be used within a bean that is mapped to an association specifying that the property annotated with that annotation is mapped to the target object of the respective association. It should be appreciated that the above mapping addresses both the aggregation and dependency concept in the application domain. On an implementation level there is no clear border between the two concepts but the distinction is rather based on how a bean property is being handled by the application.

Furthermore the JAXR information model may comprise a classification relationship which classifies a registry object with a certain concept. To this end the registry object is related to the concept through the classification object in .

On the other hand the application may not know the concept of classifications. Therefore as also shown in the classification object is mapped onto the aggregation or composition relationship between the application objects and . In the context of a Java bean this may be achieved by Classification and ClassificationConcept annotations as shown in the following code listing 

As can be seen from the exemplary listing above the JAXR information model may comprise a notion called taxonomy which classifies or categorizes the objects of a SOA registry in a tree like structure. In the JAXR information model the root of a taxonomy tree is represented by a classification scheme and the child nodes of the taxonomy tree are represented by concepts. A classification of a registry object by one of the concepts then determines on which level of the taxonomy the registry object is classified. For example a Geography classification scheme could provide a taxonomy system that defines a geography structure with continents countries within continents states or provinces or internal subdivisions within countries and cities and towns within states.

Accordingly the above code listing indicates a mapping of subconcept application object properties onto all classifications where the JAXR concept is Root Concept Concept Subconcept in the taxonomy My Taxonomy . Alternatively the mapping could be applied on the concept itself by using a parameter mappedTo MappedTo.TARGET CONCEPT. There are various ways to filter the classifications which are being mapped to the property concept path concept key parent path or parent key. In the latter two cases the concept parent may be specified. This is typically used if the classification selects an element from a pre defined set of alternatives. Furthermore the application object which is the target of the classification is specified using the targetType parameter. In the case of a single result object there is no need to specify the target type because the result type getSubconcept2 in the above example may be used as a default.

Furthermore the ClassificationConcept annotation may be used within beans that are mapped to classifications themselves in order to map a bean property to the underlying concept of this classification as the following code listing shows 

The example in shows a taxonomy of the SOA registry wherein the registry object is classified by the classification as a classification scheme located at the root of the taxonomy and the registry object is classified by the classification as a child concept of the taxonomy .

On the other hand an application may not know the concept of taxonomies but provide the concept of inheritance between application objects or application object types respectively . shows how the application is related to the application object through the inheritance relationship . On the programming language level this would mean that the application object type corresponding to the application object is a subtype of the application object type inheriting all its properties and relationships i.e. the types build a type hierarchy.

As shown in the mapping between a taxonomy and a type hierarchy may be achieved in that the application objects and are each mapped onto the registry objects and depending on their level inside the taxonomy and the inheritance hierarchy respectively. In the context of a Java bean the following code listing shows how this mapping may be defined by Java annotations 

As can be seen the application object type for the application object the interface Action1 is a subtype of the application object type interface Action determined by the extends keyword. Furthermore the interface Action is mapped onto the corresponding registry object type http namespaces.CentraSite.com csafAction by the RegistryObject annotation as already described above. Furthermore the annotation ClassifiedInstances of the interface Action describes how the taxonomy is mapped to the class hierarchy of beans formed by Action and Action1 in that it comprises two ClassifiedInstance annotations which specify a mapping of a concept from the taxonomy to a bean from the bean class hierarchy. The subtype Action1 further comprises an annotation ClassifiedInstanceProperty for accessing properties represented as part of the type specific classification object. The classificationScheme parameter specifies the name of the classification scheme to which the concept used for classifying this registry object belongs a classification scheme identifies a taxonomy as explained above . The conceptPath parameter uniquely identifies a concept within the taxonomy. Lastly the BeanType parameter specifies the type of bean to be instantiated and mapped to the underlying JAXR registry object.

By utilizing one or more of the above described mapping concepts an application may efficiently manipulate the registry object through a corresponding application object . For example the task of creating a new registry object of a custom type and setting its name property may be efficiently achieved by using the method of the present invention as the following code listing illustrates 

As can be seen the application is provided with an application object app which is an instance of the application object type Application. The application then sets the name property of the application object by invoking the corresponding setName operation. The mapping of the application object type onto the corresponding registry object type as well as the mapping of the name property is achieved by the following annotated type definition of the application object type Application as already explained above 

As can be seen the application object type Application is mapped onto the corresponding registry object type via the RegistryObject annotation and the name property getName is mapped onto the corresponding object property of the registry object type and the registry object via the Property annotation.

In order to process the above defined mappings the method of the present invention is preferably unplemented in a computer program in the sense of a framework. An exemplary framework may e.g. comprise a BeanPool which manages the life cycle of the beans in a session e.g. it creates beans requested by the application . It may also serve as a session bean cache. Furthermore it may provide CRUD interfaces create read update delete and various find operations for beans. A Beans to JAXR Mapper may process the above described mapping between beans and JAXR registry objects in that it parses the Java annotations defining the mappings when being invoked by the BeanPool. Finally a RegistryAcessor may encapsulate the JAXR operations and may be adapted for being used by the Mapper classes. An exemplary sequence diagram illustrating the interworking of the above described framework components when creating and updating a bean is shown in .

The above described beans are a central point in the architecture of the exemplary framework. They preferably comprise only data without processing logic. In the exemplary framework beans need to extend a provided base class i.e. they need to implement the RegistryBean interface and extend its default implementation DynamicRegistryBean. The beans may follow more or less the ValueObject and Data Transfer Object design patterns in order to encapsulate data and transport it through the layers of an application. A typical example of such application layers is a presentation layer a business logic layer and a data layer which is a commonly used architecture for modern applications. The presentation layer may handle the visualization of the application to the user. The business logic may encapsulate all business rules within the application. Finally the data layer may take care of retrieving and storing data in the SOA registry. All layers need to interact in order to provide the functionality of the application normally the presentation logic with the business logic and the business logic with the data layer. Information between the layers may in this case be transferred in the form of beans i.e. the beans are travelling through the layers.

The class diagram in outlines the main classes which comprise the base hierarchy of the beans in the exemplary framework. The main interface is the RegistryBean. shows two implementations AbstractRegistryBean which is an abstract class and DynamicRegistryBean which is a concrete implementation. These classes may be used by an application to facilitate the implementation of the application beans. The only restriction imposed on the application beans is that they have to extend the RegistryBean interface.

As already explained above the mapping between beans and JAXR notion s hides the complexity of the JAXR by providing in the exemplary framework the mechanism of mapping beans to JAXR registry objects using mapping rules declared as Java annotations. The class diagram in outlines the main classes and interfaces of a mapper which processes the mapping rules in the exemplary framework. As can be seen the two main interfaces are the BeanMapper and the PropertyMapper. The former takes care of mapping a bean to a registry object the latter maps a bean property to a JAXR registry object property slot association classification etc. as already described above. To this end both interfaces define two methods toJaxr and toBean which handle the mapping in both directions correspondingly. The further classes in show concrete implementations of these interfaces e.g. SlotMapper is a PropertyMapper taking care of mapping a bean property to a slot. DefaultBeanMapper is the default implementation of the BeanMapper to map a bean RegistryBean to a JAXR registry object.

Furthermore CustomMapper and AnotherCustomMapper in depict application specific mappers that implement custom mappings. This illustrates an especially advantageous feature of the present invention namely its extensibility mechanism. For example an application may introduce own annotations and corresponding mapping rules and can configure the framework to instantiate and use the custom mappers when a bean is being annotated with the custom annotations. shows an overview of the annotation types described above which are implemented in the exemplary framework.

A framework according to the method of the present invention as illustrated above may offer a number of further features which are explained in the following.

In certain cases where a bean has references to a significant amount of other beans through its properties and relationships a huge amount of data may be required when loading the bean into the memory of the application. Therefore the framework may not load the relationships and properties of a bean until they are actually requested by the application. In the context of the framework this concept may be implemented transparently and relatively independent from the other functionality except the mappers and the bean pool by using the proxy pattern. The BeanPool then may have the responsibility to attach a proxy class to a bean which will load the data when the corresponding get operation is invoked.

Furthermore it may be desirable that the framework works in scenarios where multiple users access the same resources concurrently. To minimize the complexity the framework may therefore rely on and use functionality provided by the underlying JAXR layer e.g. transactional support locking thread safety etc.

