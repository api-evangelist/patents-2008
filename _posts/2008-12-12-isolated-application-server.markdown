---

title: Isolated application server
abstract: Dynamically isolating application servers, wherein only active application servers are indicated to client applications to prevent access to inactive application servers by the client applications. A central server of a distributed system determines a state of application servers in a system, and generates a list of application servers that includes all application servers of the system including an indication of the state of the application servers. The central server also generates a filtered list of application servers that excludes inactive application servers or application servers in an inactive mode. The filtered list is passed to client applications, which enables the client applications to only access the active application servers, but not access the inactive application servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08051152&OS=08051152&RS=08051152
owner: SAP AG
number: 08051152
owner_city: Walldorf
owner_country: DE
publication_date: 20081212
---
Embodiments of the invention are related generally to distributed computing systems and more particularly to isolating application servers in a distributed system.

Portions of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. The copyright notice applies to all data as described below and in the accompanying drawings hereto as well as to any software described below Copyright 2008 SAP AG All Rights Reserved.

A distributed system is a system in which multiple servers may be spread through multiple systems or subsystems. Each system may include multiple application servers. An example is the Netweaver system available from SAP AG of Walldorf Germany. The application servers receive and process requests from client applications that may be both within and external to the system. In traditional systems even when an application server is disabled from receiving requests from external applications the system itself is aware of the application server and can send requests to the application server. Thus an application server cannot traditionally be a part of a system without being seen by the system and hit with requests.

Hitting the application server with requests when trying for example to perform testing within the system can reduce the effectiveness of the testing and or increase the testing time. Additionally errors may be introduced into the testing even when the application server intended for testing should not be available to service external requests. Hitting the application server can also result in data loss within the system if the application server fails to perform the processing. Thus current systems cannot have an application server that is part of the system context and yet isolated from servicing requests.

Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein. An overview of embodiments of the invention is provided below followed by a more detailed description with reference to the drawings.

As described herein an application server operates in an isolated mode. The application server can exist and execute within the context of the system and yet be unavailable for processing requests whether internal or external requests. The external requests come from clients of the system that are external to the system. The internal requests are made by applications or client applications within the system itself. Examples of applications that make internal requests are batch jobs and load balancing modules. A system can determine a state of all application servers within the system and generate lists of application servers based on the state of the application servers. A full list may indicate all application servers even those in an inactive or isolated state. A filtered or reduced list may indicate only those that are technically available and can be accessed by applications within or outside of the system. When a request for system resources is made on the system the filtered list is provided to indicate what application servers are available as system resources. The presenting of the filtered list prevents isolated application servers of the system from being available for processing requests and makes available only those application servers that are currently active.

In one embodiment when an application server is activated within the system it accesses a central server of the distributed system and indicates its existence within the system. The application server may be initiated in an inactive state which is indicated to the system. Alternatively the application server may be initiated in an active state and later dynamically deactivated. The central server may determine the state of the application servers and generate one or more lists of the application servers. In one embodiment one list indicates only active servers which list is passed to applications requesting resources of the system. In one embodiment a full list is generated that indicates all application servers within the system and indicates a status of each application server. In one embodiment a list of all isolated or inactive servers is generated which may indicate all servers not listed in the active application servers list.

An inactive or isolated server may still be accessible if an application or client is aware of the application server and can refer to it directly e.g. via identifier or address . In one embodiment even calling the application server directly is not sufficient to provide requests to the application server which may require certain permissions passwords etc. Multiple use cases can be accomplished by allowing access to the application servers in inactive mode. For example an application server may be in a testing mode that tests functionality of the application server within the context of the system in which the application server executes. An example of testing may include installing a new kernel in an application server and testing its functionality within the system. Another mode is a maintenance mode which can for example run analysis on the application server within the context of the system or install upgrades on individual or groups of application servers without having to take down the system.

In one embodiment an application server can be selectively activated and inactivated within a system for example to dynamically change the configuration of the system. There is generally significant overhead in bringing up and shutting down an application server. Frequently shutting down an application results in abrupt stops to request processing which may result in the loss of data. However if application servers are placed in an inactive state they may be isolated from new requests and could finish processing old requests tasks until idle at which time they may be removed from the system. The application servers could be retained as inactive application servers until needed again in a demand based implementation or until it is time to activate the application servers in a time based implementation .

In one embodiment one or more application servers may be part of two separate and distinct systems within the distributed system. The application servers may be switched between the systems based on need or based on a schedule of when to switch the application servers e.g. timed switching based for example on expectations or historical observations .

Central server includes various services or servers to perform operations for instances and . Specific services that may be provided by central server include messaging services by messaging server . In one embodiment messaging server receives an indication from each application server that is initiated with distributed system . For example each application server may register with messaging server to enable inter system communications and configure communications with clients. Resource manager represents one or more components of central server that may generate lists of application servers indicating the mode or state or status of each application server. In one embodiment resource manager includes methods or interfaces e.g. APIs application programming interfaces that allow administrative access to application servers. For example administrative access may allow dynamically changing the state of an application server. In one embodiment application servers are polled or requested for their status which may be performed by resource manager .

Central server is communicatively connected to instance and instance of distributed system . Each instance may include one or more application servers which may each include various server nodes that provide services to clients and client applications that request processing resources or request services. Simply for purposes of convenience and simplicity of discussion two application servers are illustrated in each of instances and which are application servers and and and respectively. It will be appreciated that the selection of showing two application servers is solely for purposes of illustration and fewer or commonly more application servers may be present in a system.

Instance includes list which indicates both application servers and by reference number. Thus list indicates all application servers of instance referred to as AS and AS because they are both active. In contrast instance includes list which only indicates application server AS . Within instance application server is active and is available for all applications within instance as well as to client and other clients not shown that may be connected with instance . Application server is an isolated application server which is not available generally within instance and so should not be presented for either internal or external requests.

In one embodiment list is presented to all internal requests of instance . Thus applications or processes that may generate internal requests such as RFC handler batch job manager load balancer and test manager receive indication that application servers and are available with instance . Even preventing client and any associated applications from accessing the application servers would not necessarily prevent the internal requests from sending requests to the application servers.

It will be understood that internal requests are not intended to represent a complete list of all applications or processes that could generate requests of application servers from within instance . Rather internal requests merely provide some examples that may be present. Not all are required to be present in every implementation. Other applications or processes may be present in certain implementations. RFC remote function call handler generally represents one or more components that enable hitting an application server with a direct request from an external system e.g. such as a request from application server of instance . Batch job manager generally represents batch jobs or automated processes that may be executed within instance . Load balancer refers generally to any mechanism or component that may be involved in distributing requests to one application server or another based on current workloads of each application server. Thus a particular request may be sent to one application server or another based on how busy each application server is e.g. how loaded the application server are .

As illustrated for instance application server is isolated which means that internal requests which may include the same elements as internal requests or have different and or additional elements not shown cannot access application server . Reference to internal requests not being able to access the application server assumes that internal requests are not aware of application server and or do not have permission to access the isolated application server. In one embodiment application server is not exposed to or made known to internal requests which then cannot send requests to the application server given they are unaware of its presence and are unable to address the application server.

However in one embodiment internal requests administrative may have both rights and ability to access application server . For example administrative internal requests may be aware of application server based on receiving a full list e.g. a different list than list of application servers. Other internal requests could also be made aware of an isolated application server and could potentially be given rights to access the application server. Such an internal request may be an application intended to work with the isolated application server to provide a particular function on the application server while it is inactive within the system. However for purposes of description all internal requests that are able to access the isolated application server will be referred to as administrative meaning administrative internal requests may generically represent any type of application or process that accesses the isolated application server for any purpose. Such purposes may include testing maintenance etc. which are mentioned above and described in more detail below with respect to .

In one embodiment application server is originally active and accessible to internal requests but is made inactive. Similarly an inactive application server could be made active. In one embodiment the execution of internal requests is maintained on application server for all requests already made. These requests are allowed to be processed by application server while the system is prevented from adding new requests to application server . As the existing requests are processed and terminated the application server becomes idle gradually finishing all pending tasks work. The application server may then be removed from service within instance and made inaccessible or invisible to both internal requests as well as client . In one embodiment a change of status to any application server may prompt a change in list or other lists made or maintained at instance and or central server . For example the status of the application can be monitored by a Monitor Bean in a Java system Java is available from Sun Microsystems of Santa Clara Calif. . Note that all trademarks used herein are the property of their respective owners and are used herein solely for purposes of identifying the source of particular products.

While distributed system and its components are described with certain details in reference to it will be understood that in general an application server is made inactive or isolated based on a status indicator flag identifier etc. associated with the application server. In one specific example consider a debug kernel in a system landscape that runs on optimized kernels. With isolated application servers an error analysis can be made much simpler than in traditional systems. Besides the error analysis scenario isolating application servers enables a soft shutdown automated fade out of an application server. In one embodiment an isolated application server is for temporary use only. The application server can be strictly isolated to prevent users or queued data to be directed to the application server. Isolation of the application server can prevent data loss within the system. In one embodiment an application server having an isolated state is excluded from all existing load balancing methods e.g. RFC and GUI graphical user interface groups .

In one embodiment an isolated application server enables start fade out of an application server without the need for additional components and with minimal configuration. The application server is may be only visible for example for administrative tasks such as SM51 within an SAP system but not for business applications. As mentioned previously upgrades within an instance or a system may be performed by installing changes to one or more isolated application servers the number to be isolated at a time is dependent on the system . In such a way for example a rolling kernel switch may be implemented in the system where the kernel upgrade is performed on application servers as they are isolated and the application servers are removed from availability for maintenance and are then returned to normal service.

In one embodiment application servers become automatically visible within a system upon setup or initiation of the application server. In particular the application server may be visible for example to load balancing methods in the system. When the system sees the application server it will typically begin sending requests to it for processing. With application server isolation as described herein the application server will be available for only internal requests that are desired to be run on the application server or no requests will be run on the application server. With an isolated application server requests from resources such as HTTP RFC updates batch creation etc. are blocked from accessing the isolated application server because these resources rely on the list of application servers that can be used within the system. If the application server is not present on the list it is not available to these resources.

While the applications or client applications are shown within the instance in which the isolated server exists in one embodiment central server executes one or more applications that generate requests for isolated application server assuming the applications have the proper rights to make such requests. Assuming the applications do not have such rights the applications may not be able to access isolated application server which may remain invisible to the applications.

In one embodiment central server includes full list which represents a list of application servers within system and filtered list which also represents a list of application servers within system . Full list includes active application servers which lists AS application server s through . Full list also includes inactive application servers which lists AS .

Within system AS are available to process requests from applications and . AS is isolated from servicing the requests instead performing the work for example of a specific application or process designed to perform a specific work on the isolated application server while the application server is isolated or due to the isolation of the application server.

In one embodiment when an application within distributed system whether internal or external requests resources within a system the application receives the reduced list filtered list which does not include isolated AS . List is passed to applications and which are then limited to accessing the application server of which they are aware which includes AS and specifically excludes AS .

In one embodiment distributed system includes system which represents a system to execute any one of many possible tests or maintenance operations with respect to system . Test system may include any one or more of test tasks analysis tasks or maintenance tasks . Test tasks may include any type of operation that may be requested to test the functioning of system . Analysis tasks may also test the functioning of system specifically monitoring for performance parameters or performance expectations. Maintenance tasks may include for example system upgrades or server switching as described in more detail below with respect to . Additional scenarios may also be employed such as the use of a soft shut down.

In a maintenance mode such as a kernel upgrade where AS may be provided with a different kernel or different configuration parameters and executed within system to test the new configuration. In one embodiment a virtualization scenario allows load and or time based changing of the number of application servers that are available. Time based changes may depend for example on historical data or observed conditions that indicate how much demand is expected at certain times of days or even on certain days e.g. weekends versus weekdays . Load based demand may be related to the concepts of time dependent demand or could be separate. Load based demand refers generally to how many requests are on a system at a given time.

In one embodiment a soft shut down is achieved by selectively deactivating or shutting down one or more application servers e.g. AS . Consider that work could be transferred from AS and the system could wait for all current tasks to finish before removing the application server. The transfer and wait to allow all tasks to finish before removing the application helps ensure that nothing in the system is lost disrupted or broken in any way while allowing the option to shut down an active application server e.g. shutting down an application server that is not adequately utilized or not utilized more than a threshold level such as a number of requests within a given time .

In one embodiment a kernel update test is implemented in system by use of isolated application servers. In one embodiment it may be possible to update the kernel by isolating and updating the kernel of application servers either individually or in groups and then re introducing the application servers. However for purposes of discussion here the use case of introducing an isolated application server for testing is more explicitly described. A user e.g. an administrative user or developer may access system through a user interface connected to the system. The user can generate a new application server e.g. AS within system and assign a state of inactive to the application server. New application server can be developed with a new kernel. In the case of changing an existing application server e.g. AS through the user may directly address one of the application servers and change its state from active to inactive as well as modifying the kernel to an updated version. For an existing application server where the kernel may simply be changed the user could then change the state of the application server back to active which could be indicated proactively to a message server or system manager causing the application to be added to the active list or could be passively discovered in an application server state discovery routine. The application server may then be placed back on a reduced list that indicates available application server in the system. In the case of testing a new kernel in AS the inactive application server is isolated from requests either internal or external to system . A test application however could be configured directly with the address of the inactive isolated application server allowing it to send internal requests to the inactive application server. When all tests are completed application server can be removed from the system. When application server is added to the system it is placed on a full list of application servers but is excluded from a reduced list that indicates what servers are available in system . When application server is removed from the system the full list is updated to remove the application server.

Distributed system specifically illustrates an example of how one or more application servers can be switched between systems. In a single system scenario such as illustrated in an application server may simply be active or inactive with respect to the system. In distributed system however the systems can coordinate the activation and deactivation of one or more application servers in this case demand based application servers AS through . System generally includes application servers AS . When demand is high one or more of demand based application server may be selectively activated within system . Each application server may include a potential connection to system which could be activated by the application server accessing system manager or being accessed by system manager e.g. via an administrative instruction . One or more application servers of group may then be added to AS list to make them available to applications making requests within system .

Similar activity could take place in system . The systems could thus share application server group as an application server pool. However there is also a complementary activity that could occur where an application server from group may be active in system for example and then be deactivated in system and concurrently either simultaneously or closely sequentially activated in system e.g. by placing it on AS list . The sharing of the application servers may be coordinated by having one of the systems control the use of the application servers. For example one or both systems and may include business logic that can evaluate relative need between the two systems and determine or calculate e.g. algorithmically through a heuristic or a need calculation which system should currently use an application server. Alternatively one system may have priority and could control the application servers of demand based group except where demand lessens in which case they application servers could be switched over to the other system.

It will be understood that reference with respect to to activating and deactivating an application server in one system may be performed similarly to what is described above for example with respect to . Briefly each application server in demand based application server group may initially be brought up in either system or system as an active or as an isolated application server. The initialization of each application server can be implementation specific based on how the overall system is configured. In one embodiment when the application servers of group access a message server they are added both to AS list of system and AS list of system . The application servers may be initially listed as inactive on one or both of the systems. A coordination module may execute within a central services server or may execute locally to one or both of systems and . The coordination module can coordinate which system issues an administrative command or may issue the administrative commands itself to activate an application server for a particular system.

Thus each application server of group is typically active in one system or the other or in neither system. Although it may be possible for an application server to be active for both systems that may not be desirable for the system configuration. Thus assuming an implementation where an application server is active for none or one system each application server may be active on one application server list e.g. AS list or AS list assuming these lists represent the reduced or filtered list and inactive on the other list or inactive on both lists . Consider that application server is active on its reduced list e.g. AS list . System indicates its list including application server as available for servicing requests within system . At that time application server may be excluded from its reduced list e.g. AS list with which system indicates its available application servers. Thus application server may receive requests from system but not from system . In the case where demand shifts to cause application server to be moved from system to system application server would be excluded from its reduced list and specifically included on the reduced list of system . Thus application server would be isolated from system requests and active in system .

An application server is initiated in a subsystem of a distributed system . In one embodiment upon initialization the application server accesses a messaging server within the distributed system to indicate state of the application server . Alternatively the state of the application server can be otherwise determined such as by polling or requesting the state.

If the state of the application server is determined to be active the application server is made part of an active group and is listed with available application servers . If the state of the application server is determined to be inactive the application server is made part of an inactive group and is excluded from the list of available servers . The system generates a full list of application servers that indicates the application servers and their state . The system also generates a reduced list of application servers that are available for receiving and processing requests .

When an application posts a request the load balancer of the system may put it to the application servers or could get a list i.e. the reduced list or the filtered list such as filtered list of and get to one application server and get the address to the application server to enable performing a local request on the application server. The applications can only address the application servers that are known from the reduced list. However administrative tasks or tasks with appropriate rights can get the full list and obtain access to all the application servers including the inactive application servers . Access to the inactive application servers can allow the performance of testing maintenance or analysis on the system without disrupting the system and without disrupting the testing or analysis by client requests.

In one embodiment optionally the system dynamically changes the state of an application server within the system either deactivating an active application server or activating a deactivated application server . The full list is updated in accordance with the change of state . Additionally the reduced list can be updated in accordance with the change of state . The state of the application server can be changed for any of a variety of reasons such as the use cases discussed above.

Various operations or functions are described herein which may be described or defined as software code instructions configuration and or data. The content may be directly executable object or executable form source code or difference code delta or patch code . The software content of the embodiments described herein may be provided via an article of manufacture with the content stored thereon or via a method of operating a communication interface to send data via the communication interface. A machine or computer readable storage medium may cause a machine to perform the functions or operations described and includes any mechanism that stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . A communication interface includes any mechanism that interfaces to any of a hardwired wireless optical etc. medium to communicate to another device such as a memory bus interface a processor bus interface an Internet connection a disk controller etc. The communication interface can be configured by providing configuration parameters and or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.

Various components described herein may be a means for performing the operations or functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc.

Besides what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

