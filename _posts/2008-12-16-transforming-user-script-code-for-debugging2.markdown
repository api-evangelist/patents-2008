---

title: Transforming user script code for debugging
abstract: User script code that is developed to be run in a host application, for example, as a macro can be transformed into debuggable code so that the host application may continue to operate during a debugging stop operation. Traceback methods can be created that call back into the host application to allow the host application to cooperatively operate and update its user-interface. The user script code can be transformed by injecting callbacks to the traceback methods at respective locations in the code where a stopping operation may be installed during debugging. Further, two or more debugging features can be combined into a single user script code transform using an iterator pattern function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632909&OS=09632909&RS=09632909
owner: Microsoft Technology Licensing, LLC
number: 09632909
owner_city: Redmond
owner_country: US
publication_date: 20081216
---
Users of computer program applications often find a need to perform specific tasks in the application sometimes over and over again. For example a company managing their financial issues may wish perform certain calculations on data populating a spreadsheet in an application. Performing these tasks may be supported by a host application but applications may also allow a developer user to create custom solutions to automate desired tasks.

A user of an application or a developer can create macros that perform supported functions in the application thereby automating a desired task. Macros can be created by recording a series of actions the user performs in the application or can be developed in source code that is supported by the host application. Developers users may wish to debug a macro either before use or after detecting undesirable operations of the macro in the host application. Host applications may run on a platform that comprises an implementation of a programming language framework in an integrated development environment IDE which enables a user developer to write source code compile the code and debug the code to be run in the host application.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

During debugging of their user script code a developer often inserts breakpoints where they can inspect the test environment to determine whether it is functioning as expected. Further at breakpoints a developer may wish to inspect variables step to different functions without executing the code in between edit code and continue execution review exception handling amongst other things. Currently during most new debugging operations e.g. using C and .NET scripting when the debugger hits a breakpoint in the application debuggee it causes the debuggee to freeze until the debugger is restarted e.g. when restart is selected by the user . Some older IDE platforms for host applications allow the host application to continue to respond when a breakpoint is hit which may be desirable. However if a host application was moved from an older scripting platform to a new scripting platform a user may not be able to have that host application continue to respond at a debugging breakpoint.

As set forth herein techniques and systems are provided for enabling debuggability of user script code developed for running in a host application by transforming the user script code into debuggable code. For example the user script code can be instrumented with script code that can make the user script code debuggable allowing the debugger to get debugging information from the user code instead of from a debugging API that may impact the host application.

In one embodiment traceback methods can be created that call back into the host application which may allow the host application to cooperatively operate and update its user interface and to appear to continue functioning even at a debugging stop operation. e.g. a breakpoint . Further the user script code can be transformed by injecting a callback to a traceback method at one or more locations in the user script code where a stopping operation may be inserted for debugging. Additionally debuggability features may be combined in the user script code by transforming the user script code with a common helper function e.g. an iterator type function for example instead of transforming the code for each debuggability feature desired by the user e.g. stack frame management variable inspection set next statements etc. .

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

The exemplary method begins at and involves creating traceback methods that call back into the host application to allow the host application to cooperatively operate and update its user interface UI at . In one embodiment traceback methods can be created in a library of an application execution and development framework e.g. .NET Java which can then be called by script code executed in the framework. In this embodiment when called the traceback methods can allow a host application to appear to continue functioning at a debugging stopping operation by allowing the host application to operate its UI.

Currently as an example when a debugger hits a breakpoint in the debuggee e.g. the host application running the user script code the debuggee may freeze until it is inspected by the user and the debugger is restarted. In this example the debuggee typically freezes because it is being controlled by the debugger which stops the host application at a breakpoint inspects the data and merely restarts the debuggee when a user commands it to continue. Traditionally debugging breakpoints stop a thread in the application for example which blocks a message pump e.g. message pump picks up control commands and executes event associated with command from responding to commands in the UI.

However a traceback method can be used to transfer control back to the host application tier example at a breakpoint. The host application may continue to pump messages from the UI e.g. or console inputs for a console host instead of having the debugger call the operating system to park the thread at an opcode for the breakpoint as in traditional debugging breakpoints. In this example the thread can he parked in the traceback method which transfers control hack to the host application.

At in the exemplary method the script code created by a user for use in the host application can be transformed by injecting a callback which calls to a traceback method at one or more locations in the user script code where a stopping operation may be installed for debugging. Callbacks to a traceback method can be injected at respective locations where a potential breakpoint may be used in debugging. In this way for example whenever a breakpoint is encountered during debugging of the user script code the traceback method can be called which allows for the host application to continue functioning during the breakpoint.

At the user script code is instrumented with desired script code debugging features that comprise a callback to a traceback method. For example a user that develops script code to run as a macro in a host application may wish to enable desired debugging features for the user script code. In this example the user s desired debugging features can be instrumented into the user script code during compilation of the code e.g. by a framework s high level language compiler or by a dynamic runtime environment of the framework which can transform the user script code into debuggable code for the desired features.

In one embodiment a host application s macro development platform may present a user with a menu of features that can be instrumented into the user s code. In this way for example the user can select merely those debugging features desired and the user script code can be transformed by instrumenting the user script code with those selected debugging features.

At in the exemplary method two or more separate script code debugging features can be combined in the user script code by using a common helper function transform. For example debugging features that a user wishes to include in their user script code may be unified together in a common helper transform of the code which can support respective debugging features. In one embodiment for example where more than one debugging feature may be instrumented into the user script code at the same location they can be combined in a common helper function transformation of the code that provides support for the respective features.

In one aspect transforming the user script code can be high level language agnostic in one embodiment the user script code can be transformed by a language compiler that is part of an application execution and development framework which compiles a high level language into an intermediate language IL utilized by the framework. In another embodiment the script code transforms may be done in the framework s dynamic runtime environment e.g. .NET just in time compilation service in the common language runtime which compiles the framework s IL into machine language to be executed. In these embodiments the transforms may be language agnostic as transformations are done during compiling using the framework s compilation services.

In another aspect calls to traceback methods are injected into the user script code at those locations where a stopping operation e.g. a breakpoint stepping operation asynchronous break etc. may be used by a debugger. In one embodiment in this aspect a user script code transformation can inject calls to a traceback method at respective potential stopping points where arguments to the traceback method can include a context of the stopping operation.

In one embodiment for example when the debugger appears to have stopped the debuggee at a breakpoint a thread may not actually be stopped at a hard mode breakpoint. Instead in this example the thread can be parked inside the called traceback method implemented by a host application at a cooperative control delegator e.g. a message pump that allows the host to continue to function. Further in this example the thread may not resume from the traceback method until after the debugger continues from the breakpoint.

Additionally in this embodiment tracebacks can be a no operation nop so that they have little impact on the executing code. For example if a debugger requests a stopping operation e.g. a breakpoint the traceback method can detect the requested stop appropriately. However if there is no requested stopping operation from the debugger no operation is performed by the traceback method.

In another aspect various user script code transformations may be performed to enable debugging features. It will be appreciated that while the following embodiments and examples identify several common debugging features for script code the techniques and systems described herein are not limited to any particular debugging features. Those skilled in the art may devise alternate debugging features that can be instrumented into a user script code developed for running in a host application by transforming the user script code into debuggable code.

The example line of user script code can be transformed into debuggable code that comprises calls to traceback methods at the respective stepping or stopping points in the user script code. Therefore a call to traceback one can be injected at the beginning of the line a call to traceback two can be injected after Alpha and before Beta a call to traceback three can be injected after Beta and a call to traceback four can be injected after Foo .

Traditionally stepping through script code during debugging is supported by a CPU using flags and executing single instructions. In this embodiment stack steps of the respective tracebacks are known depending on a type of stepping performed e.g. step in step out step over a next traceback is known based on its designation. For example a step in can merely be stopping at a next traceback e.g. from traceback two to three regardless of the function that comprises the traceback. Further in this example a step over may be stopping a next traceback and a current or less stack level. Additionally in this example a step out can be stopping at a next traceback at a shallower stack level.

In one embodiment the thread s debugger stack thread can be stored in a thread local storage. In another embodiment the thread s debugger stack thread can be passed as a hidden parameter to respective user code functions. In this way for example a debugger s callstack window may be an inspection operation on user data in the thread s debugger stack thread .

In the debuggable script code the function header has been transformed into a function that identifies the header by a reference foo and the function body has been transformed into a function foo body . A reference has been created for a global table that links the header function with the body function . This may allow the function body to be stored in the global table and be updated for example. Further in this example the header function can be used to fetch a latest version of the corresponding body from the global table.

In one embodiment various transforms may be applied to a function body. A function body may be swapped out for editing purposes in an edit and continue debugging feature for example In this example a first function body can be swapped out and a set next statement may be used to map from the first function body to a second function body. In another example the function body may be swapped out for deoptimization purposes while other functions can continue to have a stable reference to the function header.

In another embodiment common debugging infrastructure may be stored and shared in a function header split from its body. For example infrastructure code stored in the function header could comprise notification hooks used by a debugger. In another example infrastructure code stored in the function header could comprise drivers for a switch table that may be used for set next statements in debugging.

In one embodiment the locals can be hoisted into a closure or dictionary object . In one example in this embodiment hoisting the locals into a dictionary object may adjust the locals storage and may force them to be on a heap. In statements comprise calls to traceback methods for writing and reading the local variables.

In another embodiment addresses of locals may be described via a customized display frame . In one example in this embodiment the locals could be allowed to live on a stack comprising the customized frame which may have less impact on the locals storage. For the function foo a new frame can be created that comprises unverifiable pointer code. Statements for writing and reading the local respectively comprise calls to traceback methods allowing for a host application to continue to operate its UI during debugging for example.

In both embodiments variable homes are described in a display object which can be available in a traceback for the debugger. As an example the locals may not need to be spilled to a display object until the function reaches a traceback allowing the host application to continue to operate its UI during debugging. In the locals can be spilled to the stack to be preserved across traceback function calls for example.

This type of set next statement can be implemented by injecting a switch table into the function as illustrated in the exemplary script code . In this example if a debugger user does a set next statement while in a traceback the debugger can set the pseudo local nextLine to a target line and the appropriate traceback can return true. In this example this can cause a control for a pointer to jump to the next switch table at a switch label and then to an appropriate line .

It will be appreciated the above embodiment is merely one example of implementing switch tables to utilize set next statements for debugging. The techniques and systems described herein are not limited to the above embodiment. For example C iterators or generators in Python may also be implemented with a switch table. In this example a user code transform may be able to leverage converting the user code function to an iterator as a means of getting a switch table. Those skilled in the art may devise alternate means for utilizing switch tables for set next functions in debugging.

In another embodiment asynchronous exceptions such as those caused by a divide by zero or null reference can be made synchronous using explicit checks. In this example the exemplary user code calls for a divide by function This code can be transformed so that if the divide by value is zero a traceback function for this exception is called. Otherwise the value can be divided into the original function value.

In another embodiment script code may call out to non script code . In this embodiment for example exceptions in non script code may not be visible to a script debugger until they enter the script code. In this embodiment the script code can be transformed so that outgoing calls are wrapped in a try catch block . Further the transformed code comprises a call to a traceback method for exception handling as described above.

It will be appreciated that while several embodiments of transforms of user script to script code comprising common debugging features have been described above the techniques and systems described herein are not limited to these debugging features. Debugging features are numerous and varied and those skilled in the art may devise alternate debugging features that can be brought into script code by performing user script transforms as described above.

In another aspect a transform may combine one or more debugging features such as function header body splitting exception handling guards switch tables explicit stack frames creation local variable hoisting tracebacks and others into a single transform of the user script code based on an iterator pattern such as a common helper function. is an illustration of exemplary script code where user script code can be transformed to allow for combination of two or more debugging features using an iterator pattern.

The example feature combination transform comprises inserting script code that maps function bodies to a global table of function bodies . In this example the global table g functs maps the function header foo with its corresponding body foo body. A common helper function can be inserted in the transform that can be shared across different implementations. The helper function can call to the global table for a latest version of a function body for a function header where a function body may have been edited for example. Further the helper function can comprise two or more debugging feature transforms for the user script code such as tracebacks set next statements and exception handling.

In this example the function foo calls to the common helper function with a string foo . The foo body is like an initial body but comprises yields where breakpoints may be initiated for debugging. The body is converted into an iterator where the header drives the iterator and respective yields can become calls to traceback methods before the statement lines of the function. In this way in this example the iterator pattern can be used to combine more than one debugging feature into a user script code transform.

A system may be devised that can enable a user script code developed for use in a host application to be debugged for example while allowing the host application to operate its user interface UI . is a block diagram of an exemplary system for transforming user script code developed for running in a host application into debuggable code. For example where a user developer may wish to debug user script code they developed to run as a macro in a host application the exemplary system may transform the user script code into debuggable code so that the host application can continue responding to UI events during a stopping operation in debugging.

The exemplary system comprises traceback methods that can be configured to call back into the host application to allow the host application to cooperatively operate and update its UI for example to appear to continue functioning at a debugging stopping operation. In one embodiment a traceback method can transfer control back to the host application which can continue to operate a message pump for performing UI events.

The exemplary system further comprises a user script code transformation component which can be configured to transform user script code developed for running in a host application. The user script code transformation component comprises a traceback method callback instrumentation component which can be configured to inject a callback which calls to a traceback method at one or more locations in the user script code where a stopping operation may be installed for debugging. For example the traceback method callback instrumentation component may transform user script code by injecting a call to a traceback prior to respective functions and or statements in functions of the user script code .

The user script code transformation component further comprises a user script code debugging feature combiner that can be configured to combine two or more script code debugging features in the user script code . by using an iterator pattern transform. For example if a user developer of the script code wished to utilize several debugging features during debugging of the code such as tracebacks set next statements variable inspection edit and continue and others an iterator pattern may be used to combine these transforms into one transform. hi this example a common helper function can be injected into the code that allows a combination of more than one debugging feature using an iterator pattern. In this way the user script code transformation component can transform user script code into transformed user script code that is debuggable for example while the host application can continue to function without utilizing cooperation from an operating system s virtual machine.

In one embodiment the user script code debugging feature combiner can be configured to insert script code that maps function headers to a global table of function bodies. Further the user script code debugging feature combiner can be configured to insert script code that has respective function headers having debugging features to be combined call an iterator pattern function. Additionally the user script code debugging feature combiner can be configured to retrieve corresponding updated function bodies that have been transformed to include code enabling a debugging feature using the iterator pattern function. In this way for example a function that may comprise more than one debugging feature can have a single transform that combines respective debugging features.

In another embodiment the user script code transformation component can further comprise a function separation component which can be configured to compile a function into a separate header and body and store the function body in a global table comprising function bodies mapped to corresponding function headers. In this way for example a function body may be edited during debugging and the body can still be mapped to its corresponding header using the global table.

In this example a user can write script code such as a macro that can be run in the host application . The user script code can be written in a high level language e.g. C and a compiler that is supported by the framework can compile the user script code into an intermediate language that may be sent to a runtime environment in the framework .

In this example a user script code transformer may be comprised in the compiler and transform the user script code into transformed debuggable user script code by injecting debuggable features into the code. For example calls to traceback functions in the library may be injected into the user script code to allow the host application to continue functioning during debugging. Further the host application may comprise a debugger that allows the user to debug their code and the transformed debuggable user script code can allow the host application s UI to continue to operate during the debugging process.

In another embodiment the user script code transformation component may be operably coupled to a dynamic language runtime component for the host application which can be configured to transform the user script code during just in time compilation and execution of the user script code. For example the user script code may be compiled to an intermediate code for an application development and execution framework then sent to a runtime environment within the framework. A just in time compilation service typically compiles intermediate language into machine language during execution of the code. In this embodiment the just in time compiler can comprise the user script code transformation component to transform the user script code into transformed debuggable code during execution.

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to one or more of the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method such as the exemplary method of for example. In another such embodiment the processor executable instructions may be configured to implement a system such as the exemplary system of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

