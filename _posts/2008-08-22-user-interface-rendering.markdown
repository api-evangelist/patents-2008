---

title: User interface rendering
abstract: Elements are used to define a user interface. Each element can include a corresponding user interface widget and/or arrangement information for the user interface. The elements and/or corresponding widgets are hierarchically related. Each element implements a set of application programming interfaces that enable the rendering of both design-time views (e.g., design view and preview view) of the user interface as well as a runtime view of the user interface. As a result, a designer is able to view exactly what will be generated during runtime, and a widget developer will not need to develop additional software to support the design environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08166396&OS=08166396&RS=08166396
owner: International Business Machines Corporation
number: 08166396
owner_city: Armonk
owner_country: US
publication_date: 20080822
---
The disclosure relates generally to rendering a user interface and more particularly to rendering different views of the user interface.

A graphical user interface design environment exposes libraries of user interface UI elements to programmers and graphical designers. The programmer graphical designer can combine and physically arrange one or more of these UI elements into graphical user interface aggregates such as forms web pages windows and dialogs. The presentation of these aggregates is controlled by a deployed and running software application. Current client server application development and runtime environments allow a programmer to visually assemble a client side graphical user interface aggregate which is rendered at runtime from a text based user interface definition.

Often the design environment provides a core library that contains a base set of UI elements. UI element suppliers may define and provide their own sets of UI elements which a programmer graphical designer also can include in an aggregate. These UI elements can include newly invented UI elements and or new UI elements that are created by combining multiple base UI elements. To date UI element suppliers are typically required to provide both a runtime element to be used by an executing software application and a visualizer that represents the runtime element in the design environment. The visualizer enables the design environment to visually show and work with a design time representation of the runtime element. Typically the design environment requires the UI element supplier to write the visualizer using an application programming interface API of the particular design environment.

The inventor recognizes several disadvantages with the current state of the art. For example the APIs for some design environments impose restrictions on the visualizer s physical appearance which results in an inaccurate visual representation of the runtime UI element during design time. Further the UI element supplier needs to devote additional time and resources in creating the visualizer. As a result the inventor recognizes a need for an ability for UI elements that are normally rendered in an application runtime environment to also be rendered in the design area of a design environment. In this case among other benefits the UI element supplier would no longer be required to create a separate visualizer for each UI element.

Aspects of the invention provide a solution in which elements are used to define a user interface. Each element can include a corresponding user interface widget and or arrangement information for the user interface. The elements and or corresponding widgets are hierarchically related. Each element implements a set of application programming interfaces that enable the rendering of both design time views e.g. design view and preview view of the user interface as well as a runtime view of the user interface. As a result a designer is able to view exactly what will be generated during runtime and a widget developer will not need to develop additional software to support the design environment.

A first aspect of the invention provides a method of rendering a user interface the method comprising obtaining a plurality of user interface elements and hierarchical relationship information for the plurality of user interface elements that define the user interface wherein the user interface includes a plurality of user interface widgets identifying a top level element in the plurality of user interface elements using the hierarchical relationship information wherein the top level element corresponds to a top level user interface widget in the plurality of user interface widgets requesting the top level element to create the corresponding user interface widget wherein the top level element determines whether the user interface is for a design environment or a runtime environment and creates a proxy widget in response to a determination that the user interface is for the design environment or a runtime widget in response to a determination that the user interface is for the runtime environment and rendering the corresponding user interface widget for the top level element wherein the proxy widget is rendered within another user interface widget and wherein the runtime widget is not rendered within another user interface widget.

A second aspect of the invention provides a system for rendering a user interface the system comprising a plurality of user interface elements and hierarchical relationship information for the plurality of user interface elements that define the user interface wherein the user interface includes a plurality of user interface widgets and a component configured to render the user interface wherein the component configured to render identifies a top level element in the plurality of user interface elements using the hierarchical relationship information wherein the top level element corresponds to a top level user interface widget in the plurality of user interface widgets requests the top level element to create the corresponding user interface widget wherein the top level element determines whether the user interface is for a design environment or a runtime environment and creates a proxy widget in response to a determination that the user interface is for the design environment or a runtime widget in response to a determination that the user interface is for the runtime environment and renders the corresponding user interface widget for the top level element wherein the proxy widget is rendered within another user interface widget and wherein the runtime widget is not rendered within another user interface widget.

A third aspect of the invention provides a computer program comprising program code embodied in at least one computer readable medium which when executed enables a computer system to implement a method of rendering a user interface the method comprising obtaining a plurality of user interface elements and hierarchical relationship information for the plurality of user interface elements that define the user interface wherein the user interface includes a plurality of user interface widgets identifying a top level element in the plurality of user interface elements using the hierarchical relationship information wherein the top level element corresponds to a top level user interface widget in the plurality of user interface widgets requesting the top level element to create the corresponding user interface widget wherein the top level element creates one of a proxy widget for rendering within another user interface widget or a runtime widget for rendering at a top level user interface widget and rendering the corresponding user interface widget for the top level element.

A fourth aspect of the invention provides a method of generating a system for rendering a user interface the method comprising providing a computer system operable to obtain a plurality of user interface elements and hierarchical relationship information for the plurality of user interface elements that define the user interface wherein the user interface includes a plurality of user interface widgets identify a top level element in the plurality of user interface elements using the hierarchical relationship information wherein the top level element corresponds to a top level user interface widget in the plurality of user interface widgets request the top level element to create the corresponding user interface widget wherein the top level element creates one of a proxy widget for rendering within another user interface widget or a runtime widget for rendering at a top level user interface widget and render the corresponding user interface widget for the top level element.

A fifth aspect of the invention provides a method comprising at least one of providing or receiving a copy of a computer program that is embodied in a set of data signals wherein the computer program enables a computer system to implement a method of rendering a user interface the method comprising obtaining a plurality of user interface elements and hierarchical relationship information for the plurality of user interface elements that define the user interface wherein the user interface includes a plurality of user interface widgets identifying a top level element in the plurality of user interface elements using the hierarchical relationship information wherein the top level element corresponds to a top level user interface widget in the plurality of user interface widgets requesting the top level element to create the corresponding user interface widget wherein the top level element creates one of a proxy widget for rendering within another user interface widget or a runtime widget for rendering at a top level user interface widget and rendering the corresponding user interface widget for the top level element.

Other aspects of the invention provide methods systems program products and methods of using and generating each which include and or implement some or all of the actions described herein. The illustrative aspects of the invention are designed to solve one or more of the problems herein described and or one or more other problems not discussed.

It is noted that the drawings are not to scale. The drawings are intended to depict only typical aspects of the invention and therefore should not be considered as limiting the scope of the invention. In the drawings like numbering represents like elements between the drawings.

As indicated above aspects of the invention provide a solution in which elements are used to define a user interface. Each element can include a corresponding user interface widget and or arrangement information for the user interface. The elements and or corresponding widgets are hierarchically related. Each element implements a set of application programming interfaces that enable the rendering of both design time views e.g. design view and preview view of the user interface as well as a runtime view of the user interface. As a result a designer is able to view exactly what will be generated during runtime and a widget developer will not need to develop additional software to support the design environment. As used herein unless otherwise noted the term set means one or more i.e. at least one and the phrase any solution means any now known or later developed solution.

Turning to the drawings shows an illustrative environment for developing an application that includes a user interface according to an embodiment. To this extent environment includes a computer system that can perform a process described herein in order to enable one or more users such as designer to develop application and or user interface . In particular computer system is shown including a development program which makes computer system operable to enable the user s to develop application and in particular to design user interface by performing a process described herein.

Computer system is shown including a processing component e.g. one or more processors a storage component e.g. a storage hierarchy an input output I O component e.g. one or more I O interfaces and or devices and a communications pathway . In general processing component executes program code such as development program which is at least partially embodied in storage component . While executing program code processing component can process data which can result in reading and or writing the data to from storage component and or I O component for further processing. Pathway provides a communications link between each of the components in computer system . I O component can comprise one or more human I O devices which enable a human user such as designer to interact with computer system and or one or more communications devices to enable a system user such as a computer system being used by designer to communicate with computer system using any type of communications link. To this extent development program can manage a set of interfaces e.g. graphical user interface s application program interface and or the like that enable human and or system users to interact with development program . Further development program can manage e.g. store retrieve create manipulate organize present etc. the data such as the various artifacts that define application using any solution.

In any event computer system can comprise one or more general purpose computing articles of manufacture e.g. computing devices capable of executing program code installed thereon. As used herein it is understood that program code means any collection of instructions in any language code or notation that cause a computing device having an information processing capability to perform a particular function either directly or after any combination of the following a conversion to another language code or notation b reproduction in a different material form and or c decompression. To this extent development program can be embodied as any combination of system software and or application software.

Further development program can be implemented using a set of modules such as user interface UI renderer . In this case a module can enable computer system to perform a set of tasks used by development program and can be separately developed and or implemented apart from other portions of development program . As used herein the term component means any configuration of hardware with or without software which implements and or enables a computer system to implement the functionality described in conjunction therewith using any solution while the term module means program code that enables a computer system to implement the functionality described in conjunction therewith using any solution. When embodied in a tangible medium of expression a module is a component. Regardless it is understood that two or more components modules and or systems may share some all of their respective hardware and or software. Further it is understood that some of the functionality discussed herein may not be implemented or additional functionality may be included as part of computer system .

When computer system comprises multiple computing devices each computing device can have only a portion of development program embodied thereon e.g. one or more modules . However it is understood that computer system and development program are only representative of various possible equivalent computer systems that may perform a process described herein. To this extent in other embodiments the functionality provided by computer system and development program can be at least partially implemented by one or more computing devices that include any combination of general and or specific purpose hardware with or without program code. In each embodiment the hardware and program code if included can be created using standard engineering and programming techniques respectively.

Regardless when computer system includes multiple computing devices the computing devices can communicate over any type of communications link. Further while performing a process described herein computer system can communicate with one or more other computer systems using any type of communications link. In either case the communications link can comprise any combination of various types of wired and or wireless links comprise any combination of one or more types of networks and or utilize any combination of various types of transmission techniques and protocols.

As discussed herein development program enables computer system to enable one or more users such as designer to develop application . To this extent as part of developing application development program can provide a design environment that assists designer in designing a set of user interfaces . While executing application can generate one or more of the set of user interfaces each of which enables an end user to provide data to and or receive data from application using any solution.

Each user interface is defined by a set of elements . The elements define a set of hierarchically related user interface widgets each of which comprises a user interface object that has a physical presence and behavior. Further the elements define various display characteristics e.g. the size color alignment font etc. which application uses to render the widgets. To this extent each element can include a corresponding widget data that defines display preferences for widget s and or hierarchical relationship information for the element . Alternatively hierarchical relationship information could be stored separately from the elements .

A user interface will include a top level element that includes zero or more child elements and which includes a corresponding user interface widget e.g. a frame window a dialog a message box and or the like. The child elements can include zero or more corresponding widgets such as a label an entry field a drop down field a combo box a list box menu items a button and or the like which enables an end user to interact with application by viewing data modifying data providing data and or the like. Still further the child elements can include zero or more child elements in order to group similar widgets such as a wizard page a tabbed panel a tabbed panel page a preference page and or the like. It is understood that computer system can manage e.g. store define create edit delete display etc. the set of elements and the relationship data that defines the hierarchical structure between the various elements in the set of elements using any solution.

During the development of application development program can enable designer to define user interface by including various element s using any solution. For example UI renderer can generate a design view of user interface that enables designer to view and graphically define the content and layout of user interface e.g. using drag and drop or the like . Additionally UI renderer can generate a preview view of user interface that enables designer to view how user interface will look when it is generated by application during execution.

An embodiment of the invention enables UI renderer to use elements and the corresponding widgets which are configured to be generated by application during execution to generate both the design view and preview view of user interface . To this extent shows an illustrative data flow diagram for generating various views of user interface according to an embodiment of the invention. As illustrated UI renderer for development program makes a series of application program interface API calls to the set of elements for user interface to generate design view A and or preview view B.

Design view A will include a representation of each widget A that is not active and enables designer to move resize delete etc. the widget A. To this extent shows an illustrative design view A of an illustrative user interface according to an embodiment which can be generated by UI renderer . As illustrated development program can generate a window that includes a group of tabs that enable designer to select various views of the user interface being developed. When generating design view A UI renderer can include indicators that can assist designer in positioning resizing etc. the corresponding widget A.

Returning to an embodiment of the invention enables UI renderers to use the same API calls to elements of user interface in order to generate the corresponding views A C of the user interface . To this extent each element will implement an interface that includes sufficient functionality to enable both UI renderers to generate the corresponding views A C. For example shows an inheritance hierarchy for an illustrative set of application programming interfaces according to an embodiment which can be implemented by elements of a user interface . Referring to each element can implement one or more of the interfaces in the set of interfaces. Each interface has a corresponding set of methods that are implemented by an element . Interfaces that are shown on a lower level inherit the methods implemented by the parent interface located on the level above. To this extent the ILayoutDataElementConsumer interface A inherits the methods implemented by the IWidgetElementContainer interface A which inherits the methods implemented by the IWidgetElement interface A which inherits the methods implemented by the IElement interface . Additionally each child interface implements an additional set of methods beyond those implemented by the ancestors of the interface.

Each element includes a set of common characteristics. For example each element can include an identifier. Additionally all elements except for the top level element will have a parent. To this extent the set of interfaces can include an IElement interface that implements a set of basic methods that are required for all types of elements . To this extent the IElement interface can implement the following methods 

An element can include a corresponding user interface widget which is displayed in the user interface . An element that has a corresponding user interface widget is responsible for the creation initialization and destruction of the widget. The widget can be an operating system native widget or a non native widget such as a Swing component. To this extent the set of interfaces is shown including an IWidgetElement interface A which implements a set of basic methods that are required for all elements that have a corresponding widget. For example in addition to the methods defined for the IElement interface the IWidgetElement interface A can implement the following methods 

When widgets are created they are assembled into a widget hierarchy. Using the createWidget method above a parent widget is given to a child widget when the child widget is created. In this case the parent widget must be created before the child widget. However it is understood that this is only illustrative and an alternative embodiment can allow the creation of a new widget and the later assignment of a parent widget to the new widget which allows for the creation of child widgets before the parent widget. Each user interface includes an element that includes a top level widget. The top level widget element can implement an ITopWidgetElement interface C which can include a method e.g. boolean open that asks the top level widget element to display its widget e.g. a window dialog wizard etc. .

An element also can contain an aggregate of widgets where one of the widgets can contain a definable set of child widgets. For example a wizard page may have a title area a content area and a page navigation area. In this case the element can implement an IWidgetElementContainer interface A which includes a method e.g. Object getContentParentWidget that returns the element s container widget. The container widget is capable of being a parent to application specific child widgets. Using this method a development program can identify which of the aggregate of widgets is the content area widget where child widgets are to reside.

Additionally an element can comprise an associated widget for which it may be desirable to defer the creation of its corresponding set of child widgets. For example a tabbed panel widget can include multiple tabs each of which has an associated tabbed page with a corresponding set of user interface widgets. When presented to a user the user may not select all of the tabs before closing the tabbed panel widget. In this case each tabbed page may defer creating its content until the corresponding tab has been selected. In this case element can implement an IDeferredWidgetCreator interface D. The IDeferredWidgetCreator interface D can include the following methods 

When a user interface element includes multiple overlapping user interface areas e.g. pages only one of the user interface areas is displayed at any one time. In order to determine which page of the plurality of pages is to be displayed each page can be assigned an index number. Additionally the user interface element can implement an IPagedElement interface B which includes the following methods 

An element and a container element that includes a set of elements can have preferred arrangement information. For example an element can specify how it prefers to be positioned and sized within its parent container. To this extent an entry field can include layout data information that specifies a preference of how it is positioned horizontally within its parent grid cell e.g. to the left to the right centered or the like. A container element can include layout information that specifies how the container prefers its children to be arranged within itself. For example a container that arranges its children in a two dimensional grid can prefer to space its children m pixels apart horizontally and n pixels apart vertically. It is understood that a grid layout is only illustrative. To this extent other layout types include a pixel or XY layout in which each child is positioned using pixel coordinates a stack or paged layout where only one child is shown at a time or the like which can be supported under one or more embodiments of the invention. Further it is understood that the layout information can be specified by a user e.g. designer have a default setting and or the like.

In any event a user interface element that can be contained within another element can comprise a child layout data element . The layout data element includes a set of preferred characteristics that specify how the corresponding widget of the user interface element is to be positioned and sized within its parent widget. To this extent the layout data element can implement an ILayoutDataElement interface C which includes a method e.g. void applyLayoutData ILayoutDataElementConsumer that applies the layout data to the user interface element s widget. The parent user interface element can implement an ILayoutDataElementConsumer interface A which includes the following methods 

Additionally a user interface element that can contain child elements can have a corresponding child layout element . The child layout element includes a set of preferred characteristics that specify how the corresponding widget of the parent element is to position and size its child widgets. The child layout element can implement an ILayoutElement interface B which includes a method e.g. void applyLayout ILayoutElementConsumer to position and size the child widgets within the user interface element s widget. The child layout element can arrange the parent widget s child widgets using the preferred characteristics that are defined by the parent widget and the various child widgets using any solution. In general a layout data element of a contained element and a layout element of a container element must have the same layout type e.g. grid pixel etc. . The parent user interface element can implement an ILayoutElementConsumer interface B which includes the following methods 

For the user interface definition above and illustrative set of application programming interfaces shown in the following elements and corresponding element interfaces implemented by each element can be created 

Returning to while application is being executed by runtime engine a top level element for the user interface will generate a top level widget C for the runtime view C of user interface . However as previously discussed and shown in design view A and preview view B are frequently placed within a design area of another design window. In this case the top level element for the user interface should not generate a top level widget that appears as an additional dialog window or the like but should generate a widget that is integrated into the design area of the design window.

Otherwise in process T element attempts to obtain a corresponding widget of the parent element e.g. using the getWidget method implemented by the IWidgetElement interface A. In process T element determines whether the parent element has a corresponding widget e.g. by determining whether the getWidget method returned a valid Object using any solution. Further when using the Standard Widget Toolkit SWT user interface library element can examine the type of the widget that is returned. If the widget type is that of an SWT Composite then a valid Object was returned.

If the parent element has a valid corresponding widget then in process T element creates a proxy widget with the parent element s widget as its parent. The proxy widget comprises a widget that is displayed within another widget and emulates the visual appearance and behavior of the runtime widget. In this manner the top level element can create a widget that is rendered within window that is created by development program . Otherwise element creates its runtime widget C in process T. As a top level widget the runtime widget comprises a window dialog or the like and is not rendered within another user interface widget.

Since each element including the top level element can generate a corresponding widget regardless of whether it is being utilized by development program in a development environment or runtime engine in a runtime environment UI renderers can implement the same process to generate views A C. For example show an illustrative process for generating a view of a user interface according to an embodiment which can be implemented by UI renderers .

Referring to in process A the UI renderer can identify the top level element for the user interface using any solution e.g. using hierarchical relationship information for the elements . Subsequently the UI renderer will process the element based on its corresponding element type as discussed herein with respect to . Subsequently in process A the UI renderer determines whether the element is an IWidgetElement using any solution. If not the processing for the element ends. Otherwise the element may include one or more child elements. In process A the UI renderer determines whether there is another child element that requires processing. If so then in process A the UI renderer obtains the next child element of the element using any solution and in process A the UI renderer makes a recursive call to A in the process flow for the child element in order to process the child element and create the descendent widget s if any. For the current element processing returns to A to continue processing the child elements.

As discussed herein the UI renderer will process each element for the user interface based on its corresponding element type in order to generate the corresponding view A C. To this extent referring to after obtaining an unprocessed element in process B the UI renderer will initialize the element using any solution e.g. by calling the initialize method of the IElement interface . In process B the UI renderer determines whether the element includes a corresponding widget e.g. by determining whether the element implements the IWidgetElement interface A . If so in process B the UI renderer determines whether the element supports deferred creation of its widget e.g. by determining whether the element implements the IDeferredWidgetCreator interface D . If so in process B the UI renderer gives the IDeferredWidgetCreatorListener to the element e.g. by calling the addDeferredWidgetCreatorListener method of the IDeferredWidgetCreator interface D. If the element does not support deferred creation of its widget in process B the UI renderer requests that the element create its widget e.g. by calling the createWidget method of the IWidgetElement interface A. In an embodiment the element implements the process shown and described in in order to create its widget.

When the UI renderer determines that the element does not include a corresponding widget in process B the UI renderer determines whether the element includes arrangement information such as child layout data e.g. a set of preferred characteristics specifying how a child widget is to be positioned and sized within its parent widget and or parent layout data e.g. a set of preferred characteristics specifying how a parent widget is to position and size its child widgets and processes the element accordingly. To this extent in process B the UI renderer determines whether the element includes child layout data e.g. by determining whether the element implements the ILayoutDataElement interface C. If so in process B the UI renderer obtains the parent element of the current element e.g. using the getParent method of the IElement interface . In process B the UI renderer determines whether the parent element processes the child layout data e.g. by determining whether the parent element implements the ILayoutDataElementConsumer interface A. If so the UI renderer will continue processing the element as described with reference to .

In any event in process B the UI renderer determines whether the element includes parent layout data e.g. by determining whether the element implements the ILayoutElement interface B. If so in process B the UI renderer obtains the parent element of the current element e.g. using the getParent method of the IElement interface . In process B the UI renderer determines whether the parent element processes the parent layout data e.g by determining whether the parent element implements the ILayoutElementConsumer interface B. If so the UI renderer will continue processing the element as described with reference to .

Turning to when the current element includes child layout data and the parent element of the current element processes the child layout data in process C the UI renderer gives the current element to the parent element e.g. by calling the setLayoutDataElement method of the ILayoutDataElementConsumer interface A. In process C the parent element modifies the current element s layout data preferences as required. In process C the current element obtains the parent element s widget e.g. by calling the getWidget method of the IWidgetElement interface A. In process C the current element applies the child layout data to the parent element s widget.

Turning to when the current element includes parent layout data and the parent element of the current element processes the parent layout data in process D the UI renderer gives the current element to the parent element e.g. by calling the setLayoutElement method of the ILayoutElementConsumer interface B. In process D the parent element modifies the current element s layout preferences as required. In process D the current element obtains the parent element s content widget e.g. by calling the getContentParentWidget method of the IWidgetElementElementContainer interface A. In process D the current element applies the parent layout data to the parent element s content widget.

Returning to after processing all of the elements for a user interface the UI renderer can render the corresponding view A C for the user interface . To this extent the UI renderer can ensure that any element that is visible and supports deferred widget creation creates its widgets for display in the view A C. Further if necessary the UI renderer can add any indicia such as indicators in a design view A.

As discussed herein UI renderer can create two different views for user interface e.g. a design view A and a preview view B. When a designer is developing a user interface that includes overlapping paged widgets only one of which is displayed at a time it may be desirable to synchronize the particular paged widget that is displayed in both the design view A and the preview view B. For example if a designer is designing a preference dialog user interface with four preference pages and the second page is being designed using the design view A when the designer turns to the preview view B the second page of the preview view s B preference dialog should be displayed. For views A B UI renderer can maintain separate identical user interface hierarchy trees. UI renderer can maintain synchronization between the two user interface hierarchy trees by traversing one user interface hierarchy tree e.g. corresponding to the design view A and updating the paged widget to be displayed for the other user interface hierarchy tree e.g. corresponding to the preview view B with the paged widget currently displayed in the one user interface hierarchy tree.

To this extent shows an illustrative process for synchronizing the overlapping pages of a user interface according to an embodiment which can be implemented by UI renderer . In process S the UI renderer can obtain the top level element in the design view hierarchy tree and the top level element in the preview view hierarchy tree using any solution e.g. using hierarchical relationship information for the elements. In process S the UI renderer determines whether the current design element may include multiple pages e.g. by determining whether the design element implements an IPagedElement interface B . If so in process S the UI renderer obtains the design element s page index e.g. using getCurrentPageIndex method of the IPagedElement interface B and in process S gives the page index to the preview element e.g. using the setCurrentPageIndex method of the IPagedElement interface B.

In any event in process S the UI renderer obtains the first child element of the design element and in process S the UI renderer obtains the first child element of the preview element. In process S the UI renderer determines whether the design child element may include multiple pages or include a child widget that includes multiple pages e.g. the UI renderer can determine whether the UI renderer implements the IWidgetElementContainer interface A . If so in process S the UI renderer makes a recursive call to S for the child design and preview elements. In process S the UI renderer determines whether the current child element includes another child element and if so in process S the UI renderer obtains the next child element of the design element and in process S the UI renderer obtains the next child element of the preview element. The process then returns to process S to evaluate the current child elements.

It is understood that the methods shown and described herein are only illustrative. To this extent one or more of the processes described herein can be performed in parallel combined or omitted. Further while the illustrative process of synchronizes the preview view B to the current state of the design view A it is understood that the UI renderer could synchronize the design view A to the current state of the preview view B in a similar manner.

Returning to as discussed herein an embodiment provides elements that are configured to represent runtime widgets for user interface . Each element is used by UI renderer at runtime to construct a hierarchical user interface tree. Additionally the element is also used at design time by UI renderer which allows a designer to construct and create a hierarchical user interface tree. The element implements a set of application programming interfaces that allows both the runtime and design time environments to understand the element s widget s capabilities. This allows a third party to create a new runtime widget and corresponding element without having to create a parallel representative entity for the design time environment. Since the design time element and the run time element are the same element no element transformation occurs when going from the development to the runtime environment. In an embodiment elements are written in Java and can represent an SWT or Eclipse UI widgets. Both the design time and run time environments can be Eclipse based where the run time environment is the Eclipse Rich Client Platform. In an embodiment the development program stores a designed user interface tree for user interface as an XML file. In this case the runtime engine reads and renders the XML into Eclipse and SWT widgets.

While shown and described herein as a method and system for generating various views of a user interface it is understood that aspects of the invention further provide various alternative embodiments. For example in one embodiment the invention provides a computer program embodied in at least one computer readable medium which when executed enables a computer system to generate one or more views of a user interface. To this extent the computer readable medium includes program code such as development program which implements some or all of a process described herein. It is understood that the term computer readable medium comprises one or more of any type of tangible medium of expression capable of embodying a copy of the program code e.g. a physical embodiment . For example the computer readable medium can comprise one or more portable storage articles of manufacture one or more memory storage components of a computing device paper and or the like. Further a copy of the program code can be transitory e.g. embodied in a modulated data signal having one or more of its characteristics set and or changed in such a manner as to encode information in the signal.

In another embodiment the invention provides a method of providing a copy of program code such as development program which implements some or all of a process described herein. In this case a computer system can generate and transmit for reception at a second distinct location a set of data signals that has one or more of its characteristics set and or changed in such a manner as to encode a copy of the program code in the set of data signals. Similarly an embodiment of the invention provides a method of acquiring a copy of program code that implements some or all of a process described herein which includes a computer system receiving the set of data signals described herein and translating the set of data signals into a copy of the computer program embodied in at least one computer readable medium. In either case the set of data signals can be transmitted received using any type of communications link.

In still another embodiment the invention provides a method of generating a system for generating various views of a user interface. In this case a computer system such as computer system can be obtained e.g. created maintained made available etc. and one or more modules for performing a process described herein can be obtained e.g. created purchased used modified etc. and deployed to the computer system. To this extent the deployment can comprise one or more of 1 installing program code on a computing device from a computer readable medium 2 adding one or more computing and or I O devices to the computer system and 3 incorporating and or modifying the computer system to enable it to perform a process described herein.

The foregoing description of various aspects of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed and obviously many modifications and variations are possible. Such modifications and variations that may be apparent to an individual in the art are included within the scope of the invention as defined by the accompanying claims.

