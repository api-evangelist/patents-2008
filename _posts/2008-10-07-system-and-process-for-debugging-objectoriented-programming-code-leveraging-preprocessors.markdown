---

title: System and process for debugging object-oriented programming code leveraging preprocessors
abstract: A process and system for debugging of a computer program, is provided. One implementation involves including mark-up information into source code of the application program, generating a debug-enabled version of the computer program including debugging methods based on the mark-up information, and providing the debug-enabled version of the program computer to a debugger for debugging purposes using the debugging methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08683439&OS=08683439&RS=08683439
owner: International Business Machines Corporation
number: 08683439
owner_city: Armonk
owner_country: US
publication_date: 20081007
---
The present invention relates generally to software program debugging tools and more particularly to software debugging tools for object oriented software programs.

In existing software debugging tools debuggers while debugging applications written in object oriented OO programming languages objects are presented into a debugger according to their structure that is the fields that their class define. This requires that the fields cleanly map the semantics of the objects. However frequently a class defines parts or whole of its semantics through methods while its fields mostly map to implementation details that may or may not help the developer depending on his focus on the class or classes that use it and his level of knowledge of the class internals. In certain cases the developer intimately knows the class but the class implementation for performance reasons or otherwise encodes its semantics in very difficult to understand fields.

The invention provides a process and system for debugging of an object oriented computer program. One embodiment involves including mark up information into source code of the application program the mark up information associated with eligible debugging methods then generating a debug enabled version of the computer program including debugging methods based on the mark up information and providing the debug enabled version of the program computer to a debugger for debugging purposes using the debugging methods.

Other aspects and advantages of the present invention will become apparent from the following detailed description which when taken in conjunction with the drawings illustrate by way of example the principles of the invention.

The following description is made for the purpose of illustrating the general principles of the invention and is not meant to limit the inventive concepts claimed herein. Further particular features described herein can be used in combination with other described features in each of the various possible combinations and permutations. Unless otherwise specifically defined herein all terms are to be given their broadest possible interpretation including meanings implied from the specification as well as meanings understood by those skilled in the art and or as defined in dictionaries treatises etc. The invention provides a system and process for debugging object oriented programs code by identifying all possible eligible methods that have no parameters and returning a value and then selecting among these possible eligible methods using pattern based filtering of methods wherein the selected eligible methods are leveraged for debugging. In one embodiment of the invention all methods that take no parameter and return a value are possibly eligible for application of the invention. A developer uses explicit markers to sort those that are elected as semantic fields from those that are not. The former results into additional methods named after a recognizable pattern and a pattern based filtering of methods is used to determine eligible methods. The debugger may apply further matching and filtering rules to select even fewer methods e.g. the debugger may be equipped with built in or user level matching rules such as all instance methods whose name starts with get . The recognizable pattern may be unique or multiple and can be disclosed to and changed by the developer or not depending upon the implementation.

The following description first explains identifying all possible eligible methods that have no parameters and returning a value and then explains selecting among such methods using a pattern based filtering of the possible eligible methods. Specifically all methods that take no parameter and return a value are possible eligible methods for application of the invention. Certain methods of the class under test may include defining semantic fields of the class. Then a recognizable pattern is used to sort out eligible methods out of the set of possible eligible methods. A debugger according to the invention recognizes and leverages those methods at debug time. As such the invention provides a process for including mark up information in the source code of an object oriented application program and leveraging the mark up information to generate a debug enabled version of the application program. Such a debug enabled version of the application program comprises eligible methods named after a recognizable pattern. Then a pattern based filtering of methods is used to select among possible eligible methods.

In object oriented programming a class is template for creating objects and defines attributes e.g. name value and methods e.g. associated subroutines functions behaviours of each object. shows a functional block diagram of a computer system in which an embodiment of the invention is implemented. Said embodiment of the invention is applicable to debugging e.g. testing and solving programming issues such as errors of objected oriented programs using a graphical user interface GUI debugger. A full fledged graphical windowing system is not required and character based interfaces may be used provided that information can be presented to the user e.g. software developer programmer in a multi views and multi lines format.

The debugging computer system provides a debugging session wherein an object oriented software application is running on a computing system. The application at the moments in time that are of interest to debugging runs executes under the control of a debugger e.g. a software module . The application may run on a computer based system that may include a single machine that comprises a single core processor or a networked system that comprises multiple machines some of which include a single processor or some of which include multiple processors etc.

The debugging computer system further includes database of symbolic information about the application under test. The database may include various structures use diverse storage technologies be packaged with the executable components of the application etc. The debugger is configured to query information in the database about the application at the level of detail needed to implement its base debugging functions and implement debugging functions according to the invention.

In one implementation the debugger comprises a specialized software module configured to control execution of the application under test and to provide the user of the debugger with tools to diagnose the execution of the application from multiple points of view. The debugger further interacts with the application to selectively interrupt execution of one or more process threads of the application at precise points in time depending on specific conditions. As such the debugger controls execution of the application on behalf of the user leverages the symbolic information to provide debugging functions and interacts with the user via a user interface module .

The user interface module is configured to enable the user to interact with the debugger and control execution of the application and to diagnose the behavior of the application . The user interface provides several views and dialogs that may leverage a graphical user interface or rely upon character based multi line views and dialogs. Said views and dialogs provides controls e.g. interfaces to at least present the user with breakpoints which are points at which the execution of one or more threads of the application can be interrupted. Said views may also provide controls to resume the execution of the application in various manners e.g. step by step up to the following breakpoint etc. .

Preferably said views further include a view which for a given moment in time at which a given thread of the application is stopped at a given point in the executable code of the application presents the user with the variables that are in context. Such variable values are in memory and the application typically uses their addresses to fetch them. The debugger leverages the symbolic information database to fetch types etc.

The view provides controls for filtering part of the available information and for presenting variables that are not of elementary types via means that makes this practical within a finite view i.e. types more complex than simple types of a considered programming language such as int and other integral types chars strings of chars booleans etc. .

The view also provides controls for the user to choose how much of the internal presentation structure of the view should be displayed. It is important to consider the relationship between the view and structured variables e.g. objects and depending on the programming language other structures that are supported by dedicated language features such as arrays tuples etc. . A typical object or class instance may have many fields. Some of these fields can be objects or even of the type of the considered object itself. The view provides controls for the user to focus on presenting a subpart of the available information as desired.

For example the view may provide controls such as scrolling controls for a windowing system wherein the information is presented into what may be considered as an infinite view a small part of which is presented to the user on a display and scroll bars are provided to move up or down parts of the available information.

Another control of the view includes presenting information using a tree hierarchical metaphor wherein only digging deeper into the tree the user can view further information. For example having a Java class X int i X next at hand the tree metaphor would involve presenting the user with only the following view 

where the is in fact a control that enables the user to instruct the view to expand the tree doing so could for a given execution of the application result into 

Another control of the view includes filters that leverage properties that are more related e.g. field visibility inherited fields etc. or less related e.g. field name name matching a regular expression etc. to the semantics of the programming language used by the application .

Other controls for the view provides strategies for rendering information on a display for the user may also be implemented. Such strategies may also be combined. The rendering presented in the above examples are eventually subject to various embodiments of the debugger . The operation of an example debugger may rely upon one or more processes described below as described in relation to . Only methods that have a suitable signature can be used i.e. methods defining semantic fields . Such methods present pseudo field values along with fields of object typed variables on a user interface for debugging purposes. A recognizable pattern is used to sort out eligible methods out of the set of possible eligible methods. A pattern based filtering of methods is used to select among the eligible methods.

At block since the variable is of simple type the debugger fetches the value of that variable which depending on the runtime environment may involve various techniques. For a compiled language such as C this would involve computing the memory address and size of the variable then interpreting the resulting memory chunk according to the variable type. For an interpreted language like Java in which a virtual machine is equipped with dedicated application programming interfaces APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value.

At block the debugger presents information about said variable into the view and the process proceeds to block . The information displayed may include the type name and value of the said variable other information about said variable may also be displayed .

At block if additional variables remain in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and the debugger awaits a next command.

At block referenced above since said variable is of complex type the debugger fetches an identifier for the variable e.g. memory address of the variable or any other value guaranteed to identify the variable . At block the debugger presents information about the variable into the view and the process proceeds to block . The display of information about the variable in view may include the type name and identifier of the variable. The user is also enabled to request the details of the variable value which may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. the user utilizes a contextual menu . The information presented may include automatically or on demand the string representation of the variable e.g. in Java this would result from the call of the toString method upon the object since all classes ultimately inherit from Object .

According to an embodiment of the invention the debugger further presents in the view the result of the execution of eligible methods upon object typed variables along with the true fields of the said variables. Whenever fields of an object type are considered for all methods that have a return type and do not take parameters the process involves deriving a pseudo field name from the method name running the method to obtain a pseudo field value and leveraging those names and values as if they were the names and values of a regular field. For selecting among eligible methods a recognizable pattern is used to sort out eligible methods out of the set of possible eligible methods. A pattern based filtering of methods is used to select among the eligible methods.

At block the debugger interacts with the symbolic information to determine the names and types of the fields of the variable and to elaborate a list of all methods that can be called upon the variable said methods having no parameter and return a value. As above pattern based filtering of methods is used to select among the eligible methods. For each of those selected methods the debugger remembers its name and its return type. Optionally the debugger associates a short name to each method deriving that short name from the method name using rules e.g. method getName may be associated to name name by a rule strip leading get and lowercase leading letter and uses the resulting short names for sorting in block further below.

At block optionally the debugger filters out some of the fields and methods based upon various criteria and only retain the remaining ones for presentation.

At block optionally the debugger sorts the collection of fields and methods according to sorting criteria associated with the view or the debugger itself. Depending on the sorting criteria the fields and methods may be interleaved.

At block the debugger selects the first field or method of the variable and removes it from the list of fields and variables to be considered.

At block if the field or the method return value is of complex type then the process proceeds to block otherwise the process proceeds in sequence to block .

At block if a field was obtained at block the debugger determines the value of the field for the considered variable. Depending on the runtime environment this may involve various techniques e.g. for a compiled language such as C this would involve computing the memory address and size of the field then interpreting the resulting memory chunk according to the field type for an interpreted language such as Java in which a virtual machine is equipped with dedicated APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value . If at block a method was obtained then in block herein the debugger calls that method upon the variable at hand to get a value.

At block if a field was obtained at block then the debugger displays the field related information via the view then proceeds to block . The information displayed may include the type name and value of the said field other information may be displayed . If at block a method was obtained the debugger performs the same as for a field using a subpart of the pattern based method name indicating the method is an eligible method as if it was a field name and the value computed at block as a field value. For example assuming that SEMANTIC FIELD be the marker then a method named SEMANTIC FIELD gender would be presented as a semantic field named gender.

At block if a field was obtained at block then since the field is of complex type the debugger fetches an identifier for the field e.g. this can be its memory address or any other value guaranteed to identify the field . If a method was obtained at then at the debugger calls that method upon the variable at hand to obtain any missing information e.g. determine if the value is null or it points to a specific memory location .

At block if a field was obtained at then the debugger presents the field into the view then the process proceeds to . The presentation of the field typically includes the type name if its enclosing type and identifier of the field. The user is also enabled to request for the details of the field value. This may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. when a contextual menu is provided . The information that is presented may include automatically or on demand the string representation of the field e.g. in Java this would result from the call of the toString method upon the object since all classes ultimately inherit from Object . If a method was obtained at then at the debugger performs the same as for a field using the pattern based marker for the method indicating the method is an eligible method as if it was a field name and the information computed at . The simple name is a subpart of the complete pattern based method name wherein for example assuming that SEMANTIC FIELD be the marker then a method named SEMANTIC FIELD gender would be presented as a semantic field named gender.

At block if there are more fields or methods to handle for the considered complex variable the process loops back to block otherwise the process proceeds to block for completion and awaiting next commands.

At block the debugger presents the user in the user interface with information about the current point of execution of the application . At block the debugger collects the variables that are in scope at the current point of execution again . At block optionally the debugger filters out some of the variables based upon various criteria and only retains the remaining ones as needing to be presented. At block optionally the debugger sorts the variables according to sorting associated with the view or the debugger itself. At block the debugger selects the first variable in scope and removes it from the list of variables to handle. At block the debugger tests whether the current variable was already displayed in view or not. If not the process proceeds to block otherwise the process continues to block .

At block the debugger utilizes the process of starting at block and ending before block then branches to block instead of from block and . In effect the debugger handles the display of a variable that was not in scope at the former breakpoint.

At block the variable being considered was already displayed in view wherein the debugger considers whether the variable is of complex type or not. If the variable is of complex type the process branches to block otherwise the process continues to block . At block since the variable being considered is of simple type the debugger fetches the values of the variable. At block the debugger refreshes the variable display into the view then proceeds to block . In one implementation a brute force approach is used to simply display the variable as if it had not been seen at the previous step. In another implementation it is determined which variables may have changed and which have not changed and only the ones changed are refreshed.

At block since the variable being considered is of complex type it is refreshed accordingly an example is described in conjunction with further below . At block if there are more variables in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and awaiting a next user command.

At block since the variable is of simple type the value of the variable is fetched. At block the value of the variable is refreshed in the view and the process proceeds to block . At block since the variable is of complex type it is checked against void e.g. null in Java or 0 in C programming language . If the variable is void the process proceeds to block else the process proceeds to block .

At block since the variable of complex type is void it is displayed as such in the view this includes pruning the subtree that previously showed detailed values for the same variable at the previous breakpoint if any . The process then proceeds to block .

At block since a variable of complex type is non void it is checked if its details were displayed or not. If not the process proceeds to block otherwise the process proceeds to block .

At block since a non void variable of complex type was displayed without its details or was displayed with details but changed its type the display of its value is refreshed e.g. display the same information as that in block in . The process then proceeds to step .

At block since a non void variable of complex type was displayed with its details it is checked if its type has changed or not. If yes the process proceeds to block else the process proceeds to block .

At block since a non void variable of complex type was displayed with its details and its type has not changed its fields and suitable methods are collected. There are both real fields and semantic fields as for any complex type variable or method result.

At block optionally the debugger filters out some of the fields methods based upon various criteria and only retains the remaining ones as needing to be presented.

At block optionally the debugger sorts the fields methods according to sorting criteria associated with the view or the debugger itself.

At block the first field methods that is still to be handled is selected and removed from the list of fields methods to handle.

At block if there are more fields methods on the stack to handle the process loops back to block else the process loops back to block .

At block the stack is empty and all visible variables have been refreshed wherein the process proceeds to block .

Blocks use the pattern based marker for the method indicating the method is an eligible method and return the value computed at block as if they were the name and value of a field. The simple name is a subpart of the complete pattern based method name wherein for example assuming that SEMANTIC FIELD be the marker then a method named SEMANTIC FIELD gender would be presented as a semantic field named gender.

Another example involves calling methods more sparingly. The debugger presents methods as special fields and provides the user with controls to call them either individually or batches at a time. There is a continuum of possible implementations ranging from systematic execution described hereinabove to the display of a refresh indicator close to each special field which the user would have to click to obtain the corresponding value.

Embodiments of the present invention are applicable to all object programming languages that are equipped with debug time runtime introspection at least to the point of enabling the execution of methods which are selected at runtime. This includes at least most interpreted programming languages certain semi interpreted programming languages e.g. Java and certain compiled programming languages. In the case of compiled programs it is common practice to pass compiler specific options to produce a debug enabled version of the executable application that version carries sufficient information for the debugger to interpret memory and registers contents and to modify the memory and registers contents with the effect of assigning new values to attributes or running methods of objects this is not using introspection per se but points to the same needed basic abilities i.e. access to an object instance access to its type description read its attributes execute its methods.

All methods that take no parameter and return a value are possibly eligible for application of the invention. A developer uses explicit markers to sort those that are elected as semantic fields from those that are not. The former results into additional methods named after a recognizable pattern and a pattern based filtering of methods is used to determine eligible methods.

The debugger may apply further matching and filtering rules to select even fewer methods e.g. the debugger may be equipped with built in or user level matching rules such as all instance methods whose name starts with get . The recognizable pattern may be unique or multiple and can be disclosed to and changed by the developer or not depending upon the implementation.

The invention only leverages the user code as it is written and can be readily adopted by diverse debuggers without requiring sharing of knowledge about the debugger implementations. The invention can be reused with logging frameworks since the invention enables writing of rendering methods that are available with the code under test wherein said methods can be reused for other debugging purposes and especially logging. The invention further provides efficient encapsulation wherein the effort of bridging the internals towards semantics is left with the class under test author which is the most capable of doing so.

As noted according to an embodiment of the invention mark up information is included in the source code of an application program. The mark up information is then processed to generate a debug enabled version of the application program. Such a debug enabled version of the application program may comprise eligible debugging methods named after a recognizable pattern. An example debugger includes a built in filtering rule naming rule that keeps eligible methods named after said recognizable pattern and a short name derivation rule that leverages said recognizable pattern.

In one implementation the mark up information comprises specific keywords that are included into comments of the source code of the considered programming language for the application program. A preprocessor P then processes the application program source code including the mark up information and generates a debug enabled version of the application program. The debug enabled version of the application program may be compiled depending upon the language for all languages except purely interpreted ones . Then the result is provided to a debugger described further above and may be further parameterized to filter methods and derive their short names details further below .

Eligible methods naming rules must enable the filtering of the eligible methods. One example involves a recognizable pattern that is both compatible with the considered programming language and very unlikely to appear in typical method names e.g. a name starting with  DEBUG  or a name such as 7ZEG6534 . Different patterns may be used with or without offering the user the choice of using some or all of them at any given time.

Said naming rules must also carry the desired short name of a method if specified . One example involves using the recognizable pattern e.g.  DEBUG  wherein denotes the short name .

Said naming rules may also carry other parameters if needed wherein in one example a developer associates a debug level to each eligible method or associates one or more debug channels to each eligible method. The user can decide at which level or upon which channel the debugger focuses.

After P preprocessing then optionally a production version of the application program is generated which is more compact than the debug enabled version and potentially more compact than the original application program. The production version of the application program may comprise a copy of the original application program without methods marked by the developer as needed for debugging purposes only.

For example a preprocessor P processes the source code of the application program and generates source code for a production version of the application program which is provided to a production system i.e. sent to a production environment after having been transformed from sources to whatever the production system consumes using the normal existing means to do so .

For each mark up that signifies to P that an eligible method is needed P generates a wrapper method with the appropriate name. A developer would have the choice to develop methods that have the appropriate name beforehand and to mark such method as e.g. use for debug . Certain mark up information may be dedicated to P as needed.

An example source code including mark up information and result of processing by P P are provided in Tables 1 3 below respectively comments start with . Further shows an example view resulting from the code in Tables 1 3.

Source files of the application program to be debugged are processed by a processor i.e. P to generate debug ready sources . A processor i.e. P processes the source files and generates production sources .

The processor may comprise a software module configured for processing the mark up information in the source files as described herein. The processor is configured for reading source files of the target language including mark up information e.g. embedded into comments and generating debug ready source files . The debug ready sources comprises a version of the sources augmented with debug only methods which take no parameter return a result and have a name that encodes a marker and a simple short name that the debugger will be able to decode .

The processor is configured for reading source files of the target language including mark up information and generating production source files . The processor may comprise a software module from processor or a single software module used with different options can provide functionality of processors . Production sources comprise a version of the source files without the debug methods that the author of sources deems desirable for debug purposes only.

Optionally depending on the target language of the sources the following can be in the realm of programming language to machine binary compilers programming language to virtual machine binary compilers or pure interpreted target languages in which case the sources and are executed and debugged directly on the target system. A compiler transforms source files to binaries suitable for execution in a target computing system wherein a same program typically produces the applications and the symbolic information leveraged by debuggers .

The application comprises a binary debug ready application that has all the methods generated by the processor P. The database includes symbolic information associated to the debug ready application note that in this embodiment the present invention is implemented in P and affects processing by P leveraging the normal operation of the compiler . The application comprises a binary production application that includes no debug only methods.

The developer of the class under test selects which methods will be used as special fields. As the writer of the code of the application under test the developer is uniquely positioned to decide whether a given method has side effects or not and may not select methods that have side effects thereby eliminates the risk of modifying the behaviour of the application program under test. The developer is provided an opportunity to decide the short name of each special field which may potentially vary from the method name. The developer is also provided with an opportunity to introduce as many special fields deemed necessary without impacting the production version of the application.

The invention promotes programming of as many special fields as needed and provides appropriate mechanisms to release production grade systems that are unencumbered with debug only code. The invention further provides more efficient encapsulation wherein the effort of bridging the internals towards semantics is left with the author developer of the class under test.

The invention further provides lightweight runtime by use of markers to exclude renderers that are not necessary. The invention provides versatility e.g. levels channels parameters . A preferred embodiment leverages the full Java programming language making certain desirable patterns simple to implement.

In one example Java annotations available since Java 5 are at the conceptual level a preferable manner of marking methods for the purpose of the present invention. Such annotations are more flexible than comments and better linked to the methods they decorate. However they have the drawback that they are not available in most languages and that a processor that understands them is needed. While such processors exist understanding how they work and leveraging them can be more complex than a very simple comments grammar. An implementation targeting the Java language would then prefer annotations while other implementations would use the simpler and more generally available techniques described above.

PCI bus provides an interface for a variety of devices that are shared by host processor s and Service Processor including for example flash memory . PCI to ISA bridge provides bus control to handle transfers between PCI bus and ISA bus universal serial bus USB functionality power management functionality and can include other functional elements not shown such as a real time clock RTC DMA control interrupt support and system management bus support. Nonvolatile RAM is attached to ISA Bus . Service Processor includes JTAG and I2C busses for communication with processor s during initialization steps. JTAG I2C busses are also coupled to L2 cache Host to PCI bridge and main memory providing a communications path between the processor the Service Processor the L2 cache the Host to PCI bridge and the main memory. Service Processor also has access to system power resources for powering down information handling device .

Peripheral devices and input output I O devices can be attached to various interfaces e.g. parallel interface serial interface keyboard interface and mouse interface coupled to ISA bus . Alternatively many I O devices can be accommodated by a super I O controller not shown attached to ISA bus .

In order to attach the computer system to another computer system to copy files over a network LAN card is coupled to PCI bus . Similarly to connect computer system to an ISP to connect to the Internet using a telephone line connection modem is connected to serial port and PCI to ISA Bridge .

While the computer system described in is capable of executing the processes described herein this computer system is simply one example of a computer system. Those skilled in the art will appreciate that many other computer system designs having one or more processors are capable of performing the processes described herein.

As is known to those skilled in the art the aforementioned example embodiments described above according to the present invention can be implemented in many ways such as program instructions for execution by a processor as software modules as computer program product on computer readable media as logic circuits as silicon wafers as integrated circuits as application specific integrated circuits as firmware etc. Though the present invention has been described with reference to certain versions thereof however other versions are possible. Therefore the spirit and scope of the appended claims should not be limited to the description of the preferred versions contained herein.

Those skilled in the art will appreciate that various adaptations and modifications of the just described preferred embodiments can be configured without departing from the scope and spirit of the invention. Therefore it is to be understood that within the scope of the appended claims the invention may be practiced other than as specifically described herein.

