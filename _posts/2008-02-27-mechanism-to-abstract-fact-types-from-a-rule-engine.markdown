---

title: Mechanism to abstract fact types from a rule engine
abstract: Some embodiments of a fact type abstraction mechanism of a rule engine have been presented. In one embodiment, a fact type abstraction layer is provided to a rule engine core to allow the rule engine core to access facts of multiple different types. Further, the rule engine core is used to process the facts of multiple different types against a predetermined set of rules without converting the facts of multiple different types into a native type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07991727&OS=07991727&RS=07991727
owner: Red Hat, Inc.
number: 07991727
owner_city: Raleigh
owner_country: US
publication_date: 20080227
---
Embodiments of the present invention relate to artificial intelligence and more specifically to rule engines.

The development and application of rule engines is one branch of Artificial Intelligence A.I. which is a very broad research area that focuses on making computers think like people. Broadly speaking a rule engine processes information by applying rules to data objects also known as facts . A rule is a logical construct for describing the operations definitions conditions and or constraints that apply to some predetermined data to achieve a goal. Various types of rule engines have been developed to evaluate and process rules. Conventionally a rule engine implements a network to process rules and data objects also referred to as facts such as a Rete network. A network may include many different types of nodes including for example object type nodes alpha nodes left input adapter nodes eval nodes join nodes not nodes and terminal nodes etc.

In general the Rete algorithm describes a way to organize and reason efficiently over facts. The Rete algorithm further allows a conventional rule engine to generate conclusions and trigger actions on the facts according to the rules. Although the Rete algorithm is efficient the Rete algorithm requires the fact to be defined and available to the conventional rule engine in a pre defined structure because the conventional rule engine typically supports only a single type or a few types of facts. Thus the supported type of facts may be herein referred to as the native type of facts of the rule engine. In other words the use of the rule engine is limited by the requirement that the data of all facts is to be copied into the predefined structure before the rule engine can reason over the data. Moreover the reverse operation is also required to journalize the results of the reasoning process of the conventional rule engine.

As more and more applications of the rule engine are developed support of other different types of facts is desired. However applying the conventional technique above to process facts of different types is cumbersome and the conventional technique significantly reduces the efficiency of the rule engine as the number of different types of facts increases.

Described herein are some embodiments of a mechanism to abstract fact types from a rule engine. Broadly speaking abstraction of fact types from a rule engine refers to making the types of facts asserted into a working memory of the rule engine transparent to the rule engine core according to some embodiments. Specifically a fact type abstraction layer defines a standard way for the rule engine core to interact with facts independent of the actual type of the facts. The fact type abstraction layer allows the rule engine core to access facts of multiple different types without converting the facts into a native type. Further the rule engine core evaluates rules against the facts of multiple different types via the fact type abstraction layer. More details of some embodiments of the rule engine and fact type abstraction are described below.

In the following description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions below are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required operations. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

Referring to processing logic creates an object type application programming interface API between the rule engine core and a working memory of the rule engine processing block . The object type API allows for different implementations to support different types of facts. Some examples of the different types of facts include plain text Extended Markup Language XML documents database tables Plain Old Java Objects POJOs predefined templates comma separated value CSV records custom log entries Java Message Service JMS messages etc. One important feature of object type implementation is the ability to recognize when a given fact matches a pattern declaration. For instance a user may define a pattern as follows 

Then an exemplary object type implementation is capable of identifying which facts match the pattern declaration Customer. 

In addition to the object type API processing logic creates an extractor API between the rule engine core and the working memory processing block . While the object type API allows different types of facts to be supported by the rule engine core the extractor API allows the rule engine core to reason over the data of these fact types. In some embodiments the extractor API provides a standard way for the rule engine core to access fact attributes so that the rule engine does not have to define how an attribute of the facts is accessed. For instance processing logic defines an Extractor interface as well as a related ExtractorFactory interface. To support a fact type a set of classes implementing both the ExtractorFactory interface and the Extractor interface is provided as a rule engine plugin. For example if the fact is a POJO fact the implemented ExtractorFactory builds and provides an Extractor instance capable of reading the attribute of the POJO fact. Likewise if the fact is an XML document the implemented ExtractorFactory builds and provides an Extractor instance capable of reading the attribute of the XML document.

Then processing logic allows the rule engine core to access and process facts asserted into the working memory by using the Object Type API and the Extractor API without any fact type conversion processing block . At runtime all the interactions between the rule engine core and the facts are made through the instances of both the object type API and the extractor API such that the rule engine core may reason transparently over different types of facts without any substantial impact on application code or rule declarations. More details on how one embodiment of a rule engine core processes different types of facts are discussed below.

Referring to processing logic identifies facts matching a pattern declaration using an object type API processing block . Then processing logic reads a value of an attribute of the facts using an extractor API processing block . Details of some embodiments of the object type API and the extractor API have been discussed above.

In some embodiments processing logic extracts the constraints declared in each rule of a rule set using the rule engine core processing block . Processing logic further evaluates the constraints using the values of the attributes read from the facts by using the Extractor API processing block . When there is a match the matched rule and fact pair is placed into an agenda of the rule engine core processing block . Finally processing logic executes the matched rules in the agenda processing block .

The rule set may include business rules pertaining to a specific application e.g. mortgage application travel service health management etc. . For example suppose the user has written a rule to provide automatic upgrade of cruise ship room to all VIP customers then the rule engine core may extract the literal constraint category VIP from the rule. Then the rule engine core may evaluate the constraint by comparing the value of the category attribute of each Customer fact against the constant string VIP. For instance if a Customer fact John Smith has a category attribute equal to VIP then there is match. Therefore the Customer John Smith is provided with an upgrade of cruise ship room automatically when the matched rule in the agenda is executed.

Using the above technique a rule engine core may process different types of facts without converting them. In other words the rule engine does not have to copy data from different types of facts into a predefined structure or template before the rule engine can evaluate and reason over the data against rules. The above architecture also provides the benefit of allowing different access methods to be used to access the same type of fact attributes so that the rule engine may choose to use the one that offers the best benefits on a case by case basis. For instance to access attributes of regular POJOs the rule engine may decide to use bytecode generated extractors for attributes that are frequently accessed while using reflection to access attributes that are rarely accessed. This is because reflection may be more efficient at lower access rates.

In some embodiments the rule engine includes a fact type abstraction layer a pattern matcher and an agenda . The pattern matcher generates a network such as a Rete network to evaluate the rules from the rule repository against the facts from the working memory . The fact type abstraction layer provides a mechanism to abstract fact types away from the rule engine without converting different types of facts into a native type. Details of some embodiments of the fact type abstraction layer have been described above.

In some embodiments the server includes a rule engine having an architecture as illustrated in . The client machine may present a GUI e.g. a webpage rendered by a browser to allow users to input rule sets and or data objects which may be sent to the server to be processed using the rule engine as discussed above.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor a central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium also known as a computer readable storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media. The software may further be transmitted or received over a network via the network interface device .

While the machine accessible storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media etc.

Thus some embodiments of a mechanism to abstract fact types from a rule engine have been described. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

