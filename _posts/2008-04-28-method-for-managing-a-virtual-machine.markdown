---

title: Method for managing a virtual machine
abstract: Methods for managing a virtual machine wherein an administration console (AC) () transmits a query to a virtualization server (). The virtualization server  includes at least one virtual machine (VM) (). AC () receives, in response to the query, identification of a VM () and establishes an authenticated communications link with a proxy machine () adapted for communicating with the VM (). AC () transmits over the authenticated communications link to proxy machine () the identification of the VM () and performs a management function with respect to the VM ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08539570&OS=08539570&RS=08539570
owner: Red Hat, Inc.
number: 08539570
owner_city: Raleigh
owner_country: US
publication_date: 20080428
---
This patent application is a continuation in part of and claims priority to U.S. patent application Ser. No. 11 867 456 filed on Oct. 4 2007 patent application Ser. No. 11 867 456 is a continuation in part of and claims priority to U.S. patent application Ser. No. 11 767 173 filed on Jun. 22 2007. Both of the aforementioned prior patent applications are hereby incorporated by reference into the present patent application in their entireties.

The invention relates generally to virtualization techniques within a communications network and more specifically to inspecting and manipulating an at rest virtual machine VM .

Systems using virtualization technology where a communications network system includes one or more virtual machine have been previously described. For example U.S. application Ser. No. 11 867 456 filed Oct. 4 2007 and assigned to the assignee of the present invention described methods for collaboration amongst nodes within a communications network where some of the nodes were virtual machines. U.S. application Ser. No. 11 867 500 filed Oct. 4 2007 and assigned to the assignee of the present invention described methods for the insertion of a driver directly into a virtual machine executable file. U.S. application Ser. No. 12 013 314 filed Jan. 11 2008 and assigned to the assignee of the present invention described methods for communications between entities within a virtual communications network some of which entities were virtual machines and to tracking the activities of those virtual machines. U.S. application Ser. No. 12 013 304 filed Jan. 11 2008 and assigned to the assignee of the present invention described methods by which a virtual machine could determine information about and identify a host machine. All three of the aforementioned prior patent applications are hereby incorporated by reference into the present patent application in their entireties.

In a typical system utilizing virtualization technology management of a virtual machine requires that the virtual machine actually be online. The ability to manipulate an at rest offline VM was limited. For example in U.S. patent applications Ser. No. 11 867 500 filed Oct. 4 2007 a method for direct insertion of a virtual machine driver was described but the method was limited to altering the flat file of the VM and required that the driver to be inserted be compressible into the same size memory as a driver being replaced.

In many circumstances the ability to manage a VM is critical to the proper functioning of the VM or the overall system. For example one or more VM s within the system may need to have a new software package installed or an existing software package within the VM may need to be patched or otherwise updated.

A need therefore exists for a more robust capability to manage virtual machines within a communications network. In particular a method is needed that enables inspection and or alteration of files associated with a VM where the method is operable whether or not the VM is online. A further need exists to maintain knowledge of the current configuration of a VM within a network and to control that configuration at any time whether or not the VM is online. This would facilitate performance of periodic inspections of multiple virtual machines associated with a network and enable a network administrator to prevent VM configuration drift e.g. unauthorized modifications whether deliberate or accidental to a VM configuration . Furthermore a need exists for methods to insert software into a file directory of an offline VM for installation and operation upon the next startup of the VM and to delete software from an offline VM. Finally a need exists for methods to implement policy management on all VM s within a network whether or not some VM s are offline.

In accordance with one embodiment of the invention a method for managing one or more virtual machines is provided wherein an administrative console establishes an authenticated communications link with a proxy machine adapted for communicating with a virtual machine VM transmits over the authenticated communications link to the proxy machine identification of the VM and performs a management function with respect to the VM.

In an embodiment the proxy machine is a physical proxy machine a virtual proxy machine executing on a physical machine separate from the virtualization server and or a virtual proxy machine executing on the virtualization server. In a further embodiment the management function includes inspecting a file within the VM where the file is a disk image file a wrapper files a log file and or a snapshot related file. In an embodiment information obtained by inspecting the file is stored within a within the AC the VM and or the proxy machine.

In an embodiment the stored information has a quasi unique identifier for associating the stored information with the VM. In a further embodiment the quasi unique identifier is a hash of a record associated with the VM.

In an embodiment the management function further comprises at least one of enforcing a policy and modifying the VM. In a further embodiment modifying the VM includes installing administrative data installing new software updating an existing software component and or deleting a software component. In yet another embodiment enforcing a policy comprises at least one of inserting deleting and deprecating a certificate associated with the policy.

In an embodiment the AC performs a management function by providing to the proxy machine identification information of a selected VM and the proxy machine mounts the selected VM and inspects a file within the selected VM.

In an embodiment prior to establishing the authenticated communications link with the proxy machine the AC transmits a query to a virtualization server including at least one virtual machine VM . The AC receives in response to the query identification of a VM 

Numerous opportunities may exist within an enterprise for a host computing device or simply host device to connect to an enterprise network. Often such host devices may connect to the enterprise network in a way that results in a degradation of business continuity the loss or destruction of intellectual property or some other negative impact. These negative results could occur as a result of a malicious user purposefully trying to harm the network or as a result of an inadvertent user simply unaware of the damage being caused. Examples of such negative effects include infecting the enterprise network with viruses Trojans or other malware being used as a zombie in a distributed denial of service DDoS attack or maliciously causing a DDoS on the infected host and also to other hosts on the network by flooding the network with unauthorized traffic.

One approach for handling the above situation would be to validate untrusted hosts in the enterprise before full enterprise communication and resource allocation is permitted between trusted peers. In this context a trusted peer is a host device within an enterprise network and an untrusted host comprises a host device that has not been or for some reason cannot be fully authenticated. A trusted peer is a host device that has been adequately authenticated to the enterprise. Such authentication may be facilitated by a single trusted peer in collaboration with the administration console and also by collaboration between multiple trusted peers to determine peer authenticity and remediation of non authentic enterprise nodes.

Once a distributed system of collaborating trusted i.e. authenticated peers has been established within an enterprise network those trusted peers can operate in conjunction to determine a classification for another untrusted node. This collaboration requires only that the trusted nodes observe or witness the communication behavior of the untrusted node. Similarly within a trusted node collaboration can occur between trusted components at various levels within the computing stack to determine if any security vulnerabilities are being exploited.

Various embodiments of this mechanism and an exemplary process for installing it are described in the following subsections. As indicated this mechanism could be remotely distributed from a single hardware platform to one or more nodes within an enterprise network. The mechanism could be installed in stages and each stage can be selected with the characteristics of that node in mind. The configuration at any given node could comprise an observation functionality an analysis functionality a reporting functionality a remediation functionality or some subset of those functionalities.

In this example the AC has at least the following components user interface application server mapper JDBC SQL database and AC communication module . The AC propagates the security mechanism out to the various network nodes via the data transmission medium. It might propagate the mechanism in stages so as to first cause a receiving network node to install the core aspect or core engine of the mechanism when a user of the node logs in. The installation is designed to be transparent to the user and the core engine is hooked into the stack of the operating system of the node. This installation thus yields the disposition of the core engine and stealth kernel driver as shown in each of nodes and .

Once the core engine component is installed the AC may send a communication module component that enables data traffic pertaining to the collaboration mechanism functionality to be conveyed or communicated to and or from that network node. These components are shown as the node communication modules in each of nodes and . Collectively the core engine the node communication module and the additional modules described below comprise a set of functional modules.

Once the node communication module is installed the AC can forward one or more observation modules to the node. Examples of types of observation modules will be described below. Each such module can be designed to receive data packets intercepted between an adapter driver and a protocol layer of the node s operating system and then analyze the data packets to determine whether they are indicative of some activity or behavior of interest.

In one possible embodiment the user interface of the AC will present a security dashboard to an operator. The dashboard will facilitate operator actions intended to remotely install execute report on and manage the state of the enterprise from a single geographic location.

In addition to illustrating components of interest illustrates example packet flows that indicate those packets directed to the security mechanism packets that are target packets that is packets of interest to the security mechanism and flows where the packets are mixed that is where there are target packets and security mechanism packets. In this example the packet flows between the highlighted components with AC are directed to the security mechanism as is the traffic between the core engine and the node communication module within a node. The traffic between the core engine and the observation modules and remediation modules pertains to the target packets. The remainder of the illustrated data packet flows can be considered mixed.

In the example of the AC can include six major components a communication package an object adapter an EJB Servlet container a J2EE Application Container a data store and thick client .

In one example configuration data store can include a relational database to store all persistent data pertaining to the security mechanism. This data can include but is not limited to system configuration information system state information activity reports from node modules such as from a communication module an observation module or remediation module. The database could additionally store module activity event configuration network topology data node inventory data operator credentials and operator activity log data. Thus the AC can monitor track and act on information detected and or collected by the security mechanism at the respective nodes. As a consequence an operator or system monitor can prescribe further security related activities to the network via the various network nodes. Also because the AC can see the reports of multiple nodes it can detect security attacks that might not be detectable by a single network node operating on its own.

The modules for observation and or remediation are associated with the module component . In this example the module component includes communications capabilities inventory data stores one or more observation modules and one or more remediation modules . These observation and remediation modules are intended to handle the details of the packet processing operations. The modules also can be dynamically updated.

The above described architecture is designed to include multiple strategies for packet drivers. An appropriate packet driver for a particular customer or node will depend on customer requirements. While the specifics may vary it is beneficial if a packet driver has one or more of the following characteristics 

3. it detects whether the connection to the adapter driver is hooked intercepted tampered with in any way and

Additionally the Secure Intermediate Driver described above can be designed so that for example in a Microsoft operating system environment it will effectively look like an adapter driver to the protocols and a protocol to the adaptive driver. The SID can then forward all of the packets to the CE and it can effectively forward all packets between the protocols and the adapter driver transparently if desired.

In an intermediate driver receives packets from the network and transmits packets to the network. This could be the SID described above. The intermediate driver intercepts packets from this flow and provides them to the CE . In this illustration two aspects of the CE are referred to XML router and Packet Manager and Ripping Engine . The intermediate driver exchanges packets with Packet Manager and Ripping Engine . As will be described in connection with the Core Engine will forward packets to from the drivers to any module that is registered to receive that traffic. In this illustration however the focus is on communications particularly between this instantiation of the security mechanism and another instantiation of the mechanism at another node or with the Administrative Console.

In the arrangement of the XML Router interacts with C API a device that has a read write interface that enables the AC to communicate with elements of the security mechanism. Furthermore the XML Router and the Packet Manager and Ripping Engine interface with communication module . The Packet Manager and Ripping Engine sends an intercepted packet to the Packet of Interest Check . If the packet is of interest it is queried for processing by the Packet Handler Builder and Reassembly Engine which is responsive to XML Handier and XML Handler . The result is that the communications module will take any XML message destined for another security mechanism and package that message into an Ethernet message. The Ethernet message is sent back to the Packet Manager in the CE and is forwarded to the Intermediate Driver for transmission on the network.

In this arrangement the CE s Packet Manager and Ripping Engine exchanges packets with the intermediate driver as above and with the TCP IP device intercept . The Packet Manager and Ripping Engine further exchanges packets with various handling modules as appropriate.

Within the CE the API interface thread handles the read write interface from the CAPI as described above with respect to . The XML Router performs the same functions as in but is now shown to interface more specifically with a configuration handier that has associated CE Configuration persistent storage . The Configuration Handier is a thread that will process all CE messages and will persist the current configuration so it can be retrieved on any re start. This might even include information about any of the modules that have been installed in the system.

As illustrated in the Packet Decoder can receive packets from the secure intermediate driver and or a TCP filter. The TCP filter could be a TCP UDP Raw filter used to intercept packets data to and from the TCP IP device the UDP device and the Raw device. This will allow a module to receive traffic before it reaches the TCP IP stack from an application. As in prior descriptions the Secure Intermediate Driver will be used to intercept packets from any protocol device or any additional intermediate drivers that are installed in the stack and from the Adaptive Driver.

The PDM will get packets from each connection to the TCP IP device. In the case where there are multiple TCP IP addresses the PDM could identify each connection with a unique identifier. This connection identifier will have correlating information stored in an Inventory Module which is described below. The PDM will also get packets from each adapter driver that is currently installed in the system. The PDM will also identify each packet stream to from the adapter driver with a unique identifier.

The PDM allows modules to request packets data from each potential source. The PDM has two specific request types the first is a serial forward of the packets and the second is to forward the packet information in parallel with a smart pointer . Modules that request a serial forward of the packets data will have the potential of modifying the data before the data is forwarded onto the next module or the egress of the PDM. The PDM will allow the modules to specifically ask for traffic from a specific point in the network stack i.e. egress down from a specific TCP IP device connection or ingress up from the adapter driver or from a specific direction to from all connections in the network stack i.e. ingress up from all adapter drivers .

The PDM will perform packet decodes as much as possible on all packets data received by the PDM. The PDM will allow modules to ask for packets data based on decoded packet data information.

1. The PDM will obtain traffic flows to from the Adapter Driver with a connection that is as close to the Adapter Driver as possible.

2. The PDM will obtain traffic flows to from the TCP UDP Raw filter with a connection that is as close to the Applications as possible.

3. The PDM will allow modules to register for serial packet data forwards based on a specific location and unique device based on a specific location for all devices or based on a decoded packet filter.

4. The PDM will allow the modules to modify the serial packet data traffic and will forward the modified data.

5. The PDM will allow modules to register for parallel packet data traffic. The PDM will distribute this information using smart pointers . Modules are not allowed to modify packet data traffic received with a parallel packet registration.

6. The PDM will allow modules to register for parallel packet decodes information to be sent to the module. The PDM will distribute the packet decodes information using smart pointers.

7. The PDM will allow modules to specify the priority of the filter for serial packet forwarding parallel packet forwarding and parallel packet decode forwarding for packets data received at any specific location. The priority of the filter will determine what order packets will be forwarded to a module. A module may specify a different priority for packets received at different points. For example a module may specify a high priority for packets received on the ingress from the adapter drivers so that it sees packets before any other modules for traffic on the way in and specify a low priority for packets received on the ingress from the protocol drivers so that it sees packets last after any other modules for traffic on the way out.

8. The PDM will allow modules to kill packets data so that the data is no longer forwarded. This will allow a remediation module to block all packets to from devices as required.

As illustrated in many of the drawing figures and as discussed above the security mechanism can be deployed within a node with one or more modules such as observation modules and remediation modules 

Modules could have a variety of functionality. Some modules could gather computer inventory some modules could gather network topology some modules could perform behavior analysis on the network traffic and some modules could remediate network traffic. All modules in the system must be designed against a set of generic requirements for modules. The generic requirements are as follows 

1. Modules will be installed by the Core Engine and be coded to operate in kernel space or user space.

As indicated above the communications module will be used by all other modules to communicate with the Administration Console. The communications module may have multiple modes of communication that it can use including 

1. Ethernet Broadcast packets These broadcast packets will not use IP and therefore will not be routable. However other nodes which see these messages may route them to from the AC.

3. Spliced UDP packets This will be standard UDP packet streams sent in different splices routed via other nodes to the AC.

4. Covert communications this will use normal IP traffic streams and embed covert communications in to the stream so that communications can not be easily traced.

5. Covert spliced communications this will use normal IP traffic streams and may splice the traffic via different channels to reach the AC. The spliced traffic may be routed via other nodes to the AC.

1. Receive authenticate validate and decrypt all messages from the AC. Encrypt create a message integrity check sign and send all messages to the AC.

2. Receive all module creation messages and when a module is complete authenticate validate and decrypt the module. Send the module to the module manager for installation.

4. Handle multiple priority messages from various modules and send those messages in the order required based on priority. The CM should be able to stop sending a lower priority message that has been partially sent in order to send a higher priority message. The CM should resume sending the lower priority message when possible with out retransmitting the entire message.

Other potential modules that might be used include an Inventory Module IM a Discovery Module DM Remediation Modules RM and Observation Modules OM .

The IM could be used by all other modules to get inventory information about the computer. The IM could track information like the following 

1. What network cards are installed in the system and will generate a unique identifier for traffic to from the network card. The IM will attempt to determine the type of network card including wireless Ethernet GigE card and etc. and will determine if Microsoft VPN services are configured on the system.

2. What protocols are installed in the system and will generate a unique identifier for the traffic to from the protocol.

4. Will attempt to determine if VPN software is installed on the system. Will specifically look for an intermediate driver from DNE and PCAUSA.

5. Will attempt to determine if a packet sniffer is installed on the system i.e. Sniffer Pro Etherpeek and Ethereal. Will determine if winpcap is installed on the system.

The DM could be used by all other modules to get discovered network information. The DM could maintain information like the following 

RM s could perform remediation against network traffic flows. These may be flows detected by Observation Modules OMs that are originating from malware flows blocked by AC configuration or other network traffic flows identified by any Observation Module OM . Remediation may be blocking the traffic flow resetting the traffic flow or spoofing that the traffic flow is proceeding while blocking the flow i.e. like a honey pot .

Initially the RM s will be dormant and not have any packet filters registered. They will register their APIs to the API Manager in the CE. If an RM receives a configuration message from the AC or an OM to filter a specific network traffic stream then it will use the API manager to get the Packet Manager API and register a serial packet filter for the traffic stream. When that packet stream is delivered to the RM then it can perform remediation.

OMs could perform behavior analysis on the various network packet flows received by the security mechanism. There will be different type of OMs that will look for different network behaviors. The OMs will use the other modules in the system to perform the behavior analysis.

Determining whether an untrusted host can be acceptable to trusted peers and have access to enterprise resources can occur by allowing multiple trusted peers to collaborate with each other to identify and classify the state of the unknown or untrusted host being observed. Referring to the exemplary system shown in a trusted peer and another trusted peer can be connected to local area network via wireless access point . In an embodiment each trusted peer and in the wireless network can contain the collaboration module described above. If an untrusted host connects to access point trusted peers and can collaborate with each other the administrative console and possibly other trusted nodes connected to local area network in observing the behavior of untrusted host . Based on the observation identification and classification of the activities of untrusted host by the trusted nodes untrusted host could become trusted.

In a similar fashion untrusted host can be physically connected to local area network . Trusted peers and each containing a collaboration module as described above can collaborate on the observation identification and classification of the activities of untrusted host . This can be accomplished by trusted nodes sharing information they observe from the unknown host s communications with enterprise networks resources as well as the trusted peers themselves. Eventually that collaboration could lead to untrusted host becoming trusted. Alternatively untrusted host could exhibit questionable behavior or could violate policy. In such a case the rest of the trusted nodes on network could contribute to preventing access by untrusted host to network resources.

Any number of behaviors by or characteristics of an untrusted node could be observed by the trusted hosts. Enterprise network communications between both trusted peers and untrusted hosts could be observed or monitored for behavior that could be used to determine the risk associated with continuing a networked relationship with any given trusted peer or untrusted host regardless of it s classification. Such a list of behaviors could be provided to the trusted peers by a user developed through a self learning process or some combination of the two.

As an example trusted peers and in could observe and monitor untrusted host for attempting such things as DNS cache poisoning IP mapping modifications phishing and resource access polling and then communicate such information amongst all trusted peers including the administration module . DNS cache poisoning refers to an attack that causes a Domain Name Server DNS to appear to have received accurate DNS information. The attack exploits a flaw in the DNS software that can make it accept incorrect information that can then leads to legitimate DNS requests being directed to IP addresses of rogue servers that could potentially contain malicious content. IP mapping modifications involve an attacker attempting to divert traffic by modifying the IP address of a machine which can be handled within the system described herein via DNS name to IP mapping verification . Phishing refers to an email based attack which attempts to gain personal information by convincing the recipient to share personal information with the sender who is usually masquerading as a different entity e.g. a bank or other financial institution . Resource access polling describes the activity of an attacker trying to access information without authorized access e.g. searching for social security numbers in databases on the system .

Since each of the above attacks is network based the trusted peers could collaborate in their observation and remediation of the untrusted host. In a virtual environment if the untrusted node existed on a physical machine that was a trusted peer the attacks could be observed there as well by the collaboration between the driver in the hypervisor and the device driver in the operating system as discussed further in the context of .

Also as a result of the above described distributed approach if one or more trusted peers require a module that is temporarily unavailable from Administration Console a trusted peer may request or be pushed a module or set of modules and updated configuration from the other trusted peers. For example in the event that trusted peer did not have one or more particular remediation modules as described above in the context of those modules could be requested from trusted peers and . Alternatively if trusted peers and detected that trusted peer did not have those remediation modules without being requested by trusted host trusted peers and could push those remediation modules to trusted host .

With the observation and determination of authenticated peers that exhibit one or many of these behaviors a system according to the present invention can allow for the denial of access to network resources by the untrusted host. To do this one or more trusted peers can ignore the communication attempts by an untrusted host. This methodology can also prevent an untrusted host from introducing unauthorized traffic into an intranet or over the Internet. Further behavior by neighboring hosts and other network elements like routers switches firewalls etc can be enforced per policies supplied for example by the network administrator.

Similarly access by an untrusted host can be remediated in a virtualized environment. In such a case access by the untrusted host to the network could be restricted or completely prevented by a driver running on the associated hypervisor as illustrated in the context of . This could occur for example where an untrusted host is determined to be and thus classified as a rogue. In such an instance that rogue host s network communications can be filtered by all trusted peers. The rogue host could effectively be removed from the enterprise including for example by terminating the process on the physical machine on which it resides or in a virtualized environment by having the other trusted peers ignore the untrusted host s virtual machine. This could result from a configuration change dynamically sent to the trusted peers by administration console .

Using collaboration in the virtualized environment as illustrated further in the context of it is possible to determine if a kernel driver or other malicious code has been maliciously inserted. This could occur for example where malicious code is inserted inline between the operating system driver and the physical kernel driver i.e. in the hypervisor . Such a case could be observed and analyzed by the two drivers collaborating with each other in analyzing the differences between what was requested or inserted into the stack and what was yielded or realized at the driver placed directly above the adapter driver of the physical machine.

For cases where trusted peers determine and classify a formally untrusted host s state as safe or trusted a message can be sent to administration console to insert the core engine described above to the newly classified peer along with other modules appropriate for that trusted peer. Having been authenticated the now trusted peer will also be instantiated with a collaboration module to assist in future analysis of untrusted hosts that connect to the network. The insertion of the collaboration module in the now trusted peer could further be accomplished without needing to restart the trusted peer.

Once installed device driver in the operating system kernel and hypervisor driver can collaborate with each other and with other trusted peers to observe activity by other untrusted hosts. For example device driver and driver could determine if an untrusted host has installed a rootkit by collaborating and comparing activity that was intended by the application and what services were actually requested to the hypervisor of the physical machine.

Similarly hosted virtual machine can collaborate with hosted virtual machine . In an embodiment collaboration module within hosted virtual machine can communicate over the network with collaboration module within hosted virtual machine . As described above with respect to the two hosted virtual machines and can collaborate on the observation identification and classification of the activities of other trusted peers and untrusted hosts in the network. This can be accomplished by trusted nodes sharing information they observe from the unknown host s communications with enterprise networks resources as well as the authenticated nodes themselves.

Within hosted virtual machine collaboration module can also perform observation and analysis on activities that lie only within hosted virtual machine . For example collaboration module can observe the integrity and authenticity of the code that makes up all of hosted virtual machine by utilizing an electronic signature. In an embodiment collaboration module can generate a cryptographic digital signature across various portions of the executable code that make up hosted virtual machine . The digital signatures could then be checked at various times during the operation of hosted virtual machine to verify that no changes had been made to any of the code e.g. by a malicious or rogue entity within the network .

In an embodiment a digital signature refers to a public key digital signature or simply digital signature which can be calculated across any data object using well understood cryptographic techniques. A digital signature derives its security from the concept of a key pair consisting of a public key and private key that have a specific mathematical relationship between them. Within a public key infrastructure PKI a key pair can be provided to each entity or machine that is to generate digital signatures. In a PKI the public key can be shared publicly without jeopardizing the overall security of the system.

More specifically the mathematical relationship between the public key and the private key that comprise the key pair permits the public key to be revealed while maintaining the security of the overall system. This characteristic is particularly important in an open network system such as the Internet where entities need a reliable means of authentication. The private key on the other hand must be securely maintained in order for the security of the system to be maintained.

A public key pair used to produce a public key digital signature further has the property of computational infeasibility i.e. it would be computationally infeasible for an entity to determine the private key of a user from the public key of that user. Thus the user may share the public key of the user s key pair through a mechanism known as a digital certificate or simply a certificate . In addition to the public key a certificate may contain a number of other fields that contain information about the holder of the certificate. The well understood X.509 standard ITU recommendation ITU T X.509 defines a certificate format commonly used for Internet communications.

In the system shown in collaboration module would securely maintain the private key e.g. encrypted in nonvolatile memory . When needed collaboration module could use a private key to calculate a digital signature on the code that comprises V Driver Kernel Driver core engine remediation module A observation module A observation module B remediation module B and collaboration module . The resulting digital signature and the public key that corresponds to the private key could then be used by collaboration module to check the integrity of the code that makes up hosted virtual machine .

Administration console can identify or qualify which virtual machines in network storage contain specific software. In an embodiment a list of virtual machines that do not contain a specific software technology including for example a kernel V driver according to the present invention can be developed. Since a hypervisor contains information on the location of each at rest virtual machine i.e. the flat file of a virtual machine that is not being executed the list of virtual machines that do not contain a kernel V driver can be used to query hypervisor API or kernel V driver in hypervisor kernel to locate where physically those virtual machines reside when they are at rest. It will thus be possible to identify locate and insert a kernel level device driver into a virtual machine file that is resident on a physical machine or on a local disk storage area network or network attached storage associated with a particular hypervisor.

The insertion of a kernel driver into a flat file that when executed is considered a virtual machine may be accomplished by parsing though the at rest flat file of the virtual machine and identifying the bit location of other known drivers e.g. printer drivers communications drivers and other similar drivers Once a specific known driver is location various methods could be used to insert the kernel driver into the virtual machine flat file.

In an embodiment virtual machine flat file can be parsed for known drivers and once located a known driver can be replaced with a kernel driver such as V driver Kernel Driver shown in that mimics the same functionality as the original driver by compressing both the original driver the V driver and a compression engine into the same size memory space as the original uncompressed driver.

In an alternate embodiment virtual machine flat file can be parsed for known drivers as described above. The known driver can be replaced with V driver kernel driver that will facilitate the functions of the known driver by encapsulating the known driver with an application wrapper that can then utilize V driver kernel driver to execute the encapsulated known driver from application space while providing it a kernel interface. The V driver will assume the location and connection of the known driver and move the known driver into application space setting up a conduit to interface the known driver back into the kernel.

In yet another embodiment the virtual machine can be executed in temporary contained memory also known as a sandbox and the V driver Kernel Driver can be inserted at run time with no user interaction. The insertion is accomplished by utilizing the exposed interfaces at run time. By loading the Virtual Machine in a separate virtual player instance for the purposes running a driver insertion script against the file the virtual machine will temporarily be executed by the virtual player instance and then inserted with the driver and terminated without user interaction. This process will be performed as a batch process against virtual machines that do not contain the V driver automatically at the user s option.

The above described methods of inspecting the flat file of a non executing virtual machine and altering the flat file by inserting a driver provide a limited VM management capability. A VM management method with substantially enhanced capabilities will now be described. The method is operable on various network architectures exemplary architectures are illustrated in and .

In accordance with an embodiment illustrated in AC is communicatively coupled to physical proxy machines. For example AC may be communicatively coupled to Linux Proxy and Windows Proxy . Linux Proxy and Windows Proxy are respectively capable of interfacing with Linux VM s and Windows VM s . In an embodiment the Linux proxy can interface with VM by way of API . In another embodiment a physical proxy can directly manage a respective VM. For example Windows proxy may directly mount a VM . For purposes of illustration depicts a Linux Proxy that is separate from Windows Proxy but a single proxy may be operable to manage both Linux and Windows VM s

AC and the physical proxy machines e.g. Linux Proxy and Windows Proxy can be communicatively coupled to a virtualization server . The virtualization server may be the VMWare ESX Server for example. Virtualization server interfaces with the AC and the physical proxy machines e.g. Linux Proxy and Windows Proxy by way of API . API can provide control and access interfaces to offline virtual machines and in an embodiment can comprise an ESX Server API as shown in . For example API may be communicatively coupled to a number of offline virtual machines within Virtualization server .

As discussed hereinabove virtual machines may also be contained within network storage comprising a storage area network or network attached storage devices SAN NAS . In such case a SAN NAS API not shown may be communicatively coupled to physical proxies and and to VM s within network storage .

The offline virtual machines may comprise diverse operating systems. For example as illustrated in offline virtual machines and may run the Linux operating system whereas offline virtual machines and may run the Windows operating system.

The AC is operable to interface directly with online VM s. For example as illustrated in AC is communicatively coupled to Linux VM and Windows VM . As described above offline VM s e.g. Linux VM s and and Windows VM s and may be accessed in three ways 

An embodiment of the present method will now be described with reference to the network architecture illustrated by . In accordance with the present invention the method begins by AC establishing an authenticated communications link with one or more proxy machines adapted for communication with an identified VM. For example if the identified VM is a Linux VM such as VM and the AC will preferably establish an authenticated communications link with Linux proxy if the identified VM is a Windows VM such as VM and the AC will preferably establish an authenticated communications link with Windows proxy .

As explained in more detail hereinafter the AC can then utilize the established authenticated communications link to perform a management function with respect to the one or more VM s.

In an embodiment the method of the present invention is operable even when the identified VM is offline. Further the method of the present invention is operable whether or not the proxy machine e.g. Linux proxy or Windows proxy is a physical machine. For example the proxy machine may be a virtual proxy machine. If the proxy machine is a virtual proxy machine it may be executing on a physical machine separate from the virtualization server or be executing on the virtualization server .

In an embodiment prior to establishing the authenticated communications link the AC may transmit a query to virtualization server . Alternatively the query may be transmitted to a SAN NAS API not shown . The query may be sent to API of virtualization server and may request identification of one or more VM s comprising virtualization server .

The management function contemplated by the present invention may include inspecting a file or other data structure within the identified VM. When the management function includes inspecting a file the file inspected may be any of several types. Examples of file types inspectable under the present method include but are not limited to 

1. disk image file a virtual disk file that stores the contents of the virtual machine s hard disk drive 

4. snapshot file a file that stores the running state of the VM at a particular moment in time usually in terms of deltas with respect to a baseline state.

The inspected files may be in a binary or readable format. In the case of binary formatted files the proxy may first perform a mounting function whereby the binary formatted file is processed in order to make it readable.

Information obtained by inspecting the file may be stored within the AC and or the proxy machine e.g. Linux proxy or Windows proxy . Preferably the stored information is provided with an identifier associating the stored information with the identified VM. The identifier is preferably related to information contained at least one of the files inspected. Preferably the identifier is uniquely or quasi uniquely associated with information from all of the inspected files. The identifier is advantageously for example a hash of a record associated with the VM.

In addition or instead of storing information on the AC and or a proxy machine the method contemplates storing information obtained by inspecting a file of a VM within the VM itself. For example the information may be advantageously stored within a file directory a wrapper file or other data structure within the VM.

In an embodiment of the present method the management function may include functions in addition to inspecting a file of a VM. For example AC may be operable to enforce a policy and or to modify the VM. If the management function relates to modifying the VM the modification may for example be associated with installing administrative data installing new software updating an existing software component for example via a patch as is well known and or deleting a software component. If the management function relates to enforcing a policy the enforcement may include for example inserting deleting or deprecating a certificate associated with the policy.

In an embodiment of the present method AC may delegate to a proxy machine certain tasks. For example AC may provide to proxy machine or identification information of a selected VM. For purposes of illustration if AC provides to proxy machine the identification information of selected VM proxy machine under the present method may inspect one or more files within VM . As above the inspected file may be for example a disk image file a wrapper file a log file or a snapshot related file.

Information obtained by inspecting the file may be stored within the AC and or the proxy machine in the present example Linux proxy . Preferably the stored information is provided with a unique or quasi unique identifier associating the stored information with in the present example VM . Moreover the unique identifier is advantageously for example a hash of a record associated with VM . As used herein a hash can include a hash result or hash value from a one way hashing function. A one way hashing function can be applied to every portion of a data object thus producing a deterministic value for that data object. In an embodiment the one way hashing function can include the Secure Hash Algorithm SHA 1 or SHA 256 .

In addition to or instead of storing information on the AC and or proxy machine the method contemplates storing information obtained by inspecting a file of VM within VM itself. For example the information may be advantageously stored within a file directory or a wrapper file associated with VM .

The management function may include aspects in addition to inspecting a file of VM . For example AC may be operable to enforce a policy or to modify VM . If the management function relates to modifying the VM the modification may for example be associated with installing administrative data installing new software updating an existing software component or deleting a software component. If the management function relates to enforcing a policy the enforcement may include for example one or more of the following 

As used herein a certificate can include any data object that identifies another data object. A certificate could for example include a digital certificate that can contain a public key along with a number of other fields that contain information about the policy or about the issuer of the certificate. The well understood X.509 standard ITU recommendation ITU T X.509 defines a certificate format commonly used for Internet communications.

In an embodiment the AC performs a management function with respect to a VM for example VM by inspecting a snapshot file created by virtualization server . In this embodiment VM is running i.e. online at the moment the snapshot is created by virtualization server . The AC may receive information regarding the snapshot file from virtualization server the received information can enable the AC to obtain and inspect the snapshot file. In addition AC may perform or enable an operator to perform other appropriate actions in response to results of the inspection including those actions described above. For example it may modify the snapshot file in order to enforce a policy. As another example the results of the inspection can be used in taking a further decision with respect to VM e.g. to turn off VM or to isolate VM from other virtual or proxy machines. Thereby a configuration of the VM may be managed whether or not a driver has been installed on the VM .

As noted above the present method is operable whether or not the proxy machine is a physical machine. Moreover if the proxy machine is a virtual proxy machine it may be executing on physical machine separate from the virtualization server or be executing on the virtualization server. illustrates an example of an architecture wherein a proxy machine is a virtual proxy executing on the virtualization server.

In accordance with the embodiment illustrated in AC is communicatively coupled to virtual proxy machines. As illustrated AC is communicatively coupled to Linux Proxy VM s and and to Windows Proxy VM s and . In this embodiment virtual Linux proxy VM and virtual Windows Proxy VM are executing within virtualization server and virtual Linux Proxy VM and virtual Windows Proxy VM are executing within virtualization server . The virtualization servers may be the VMWare ESX Server for example.

In the embodiment illustrated in virtualization servers and interface with the AC by way of API and respectively. The APIs and can provide control and access interfaces to offline virtual machines associated with respective virtualization servers and . For example API may be communicatively coupled to a number of offline virtual machines within Virtualization server e.g. Linux VM and Windows VM .

The AC is operable to interface directly with online VM s. For example as illustrated in AC is communicatively coupled to Linux VM and Windows VM . As described above offline VM s e.g. Linux VM s and and Windows VM s and may be accessed in three ways 

Thus a method for managing virtual machines within a communications network has been disclosed. The method enables inspection of files associated with a VM even when the VM is offline. Thereby the current configuration of a VM may be known and controlled at substantially any time whether or not the VM is executing. The method is advantageously employed in the performance of periodic inspections of a network of virtual machines so as to stop VM configuration drift e.g. unauthorized modifications whether deliberate or accidental to a VM configuration within the network. Furthermore software may be inserted into a file directory of an offline VM for installation and operation upon the next startup of the VM and software may be deleted from an offline VM. Finally policy management can be implemented on all VM s within a network whether or not some VM s are offline. For example certificates or tags associated with policy management may be inserted deleted or deprecated.

The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

