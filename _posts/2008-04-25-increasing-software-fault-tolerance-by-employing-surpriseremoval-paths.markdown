---

title: Increasing software fault tolerance by employing surprise-removal paths
abstract: The subject invention relates to systems and methods for automatic recovery from errors in a computing environment. A system is provided to facilitate failure recovery in the computing system. The system includes at least one driver component that enumerates at least one layer of a driver stack. A module associated with the driver component requests re-enumeration of the driver stack upon detection of an error in the computing system. When an error is detected by a driver or operating system component, a protocol can be established whereby a new copy of the driver's stack or system resources is re-enumerated in parallel to existing resources that may be in an unknown or error state. The new copy of the stack may allow the driver to become operational in lieu of the previous stack which can be reclaimed for other system uses over time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08006120&OS=08006120&RS=08006120
owner: Microsoft Corporation
number: 08006120
owner_city: Redmond
owner_country: US
publication_date: 20080425
---
This application is a continuation of U.S. patent application Ser. No. 11 036 803 filed Jan. 15 2005 and entitled INCREASING SOFTWARE FAULT TOLERANCE BY EMPLOYING SURPRISE REMOVAL PATHS the entirety of which is incorporated herein by reference.

The subject invention relates generally to computer systems and more particularly the subject invention relates to a system that enables components to recover from soft failure situations by simulating hardware removal conditions.

In some operating systems drivers are software modules that can be inserted into an operating system kernel allowing for support of specific hardware or for extension of the operating system or both. Generally drivers run in a fully trusted mode whereby any failure in these components can cause machine services to fail or a full system crash. Thus any successful effort to make drivers more resilient or fault tolerant usually causes greater system reliability and consequently customer satisfaction to increase.

One of the barriers to greater driver resilience is that a driver typically has to respond to many events generated by the operating system which may require the driver to initiate operations which can fail. For example these events may be file handle creation device insertion power being turned off statistics gathering and so forth. Most of the time the exact action that a driver should take in response to an internal failure is poorly defined. This is partly due to the operating system not always being designed to handle every conceivable set of failures partly due to external documentation not covering every situation and partly due to certain failures that involve a large amount of judgment on the part of the driver designer. Furthermore drivers are often constructed internally as large state machines wherein a response to an event will depend largely on which events have occurred in the past. After a failure occurs the driver designer often has to immediately turn around and handle new events even though the failure probably implies that new events are likely to fail as well.

Currently there is no efficient manner within some operating systems to easily cause a driver to reset its internal state. This implies that the driver s internal state machine should be designed to process failure events at every moment possible. This vastly increases the complexity of the driver often doubling or tripling it in size in terms of the amount of code necessary to support such failure events. This increase in size also implies an exponential growth in the amount of time necessary to test and debug the driver as most of the code paths within it may never be executed unless there is some failure in the operating system the hardware or the driver itself. Since failures are not the normal case mistakes in error handling code paths often go undetected.

1 They ignore some or all errors. This leads to for instance machines that crash as soon as some application requests all of memory.

2 They attempt to request as much of the resources that they will possibly need e.g. memory registry handles and so forth at startup time minimizing the number of possible failure paths at run time. This may lead to wasted memory and other frustrating situations such as the need to reboot a machine to upgrade a driver.

3 They spend years hardening their drivers handling every error path. Today this is generally only performed by designers who are trying to run operating systems in datacenter environments as they are typically the only ones who can afford the cost of such hardening.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

The subject invention relates to systems and methods for enabling drivers or other software components to automatically recover from failure in a reliable and predictable manner. This includes providing methods and or components for allowing a driver to reset its internal state by abandoning a running copy of its current state and creating a new instance of the driver from the beginning. This can allow a driver to skip handling of many common error cases enabling a more general reset mechanism to process errors at a higher level and decreasing the internal complexity of the driver and or increasing the driver s resilience to continue normal operations. In one aspect an interface or message protocol is provided whereby a functional device object FDO or other driver layered on top of a physical device object PDO in a component stack can send a request down a device stack requesting the driver to simulate a series of physical unplug and re plug events e.g. simulate a hardware module being plugged unplugged . When the request reaches the PDO the receiving driver informs an operating system component that the device has disappeared or is no longer operational. A subsequent operating stack is then enumerated in parallel with the previous stack that encountered the error in order to attempt to resume normal operations of the driver. Other protocols can be provided to remove older stack resources over time.

The above described messaging protocol can include many different aspects to attempt to revive a component from failure. These can include a device or component driver which enumerates other drivers along with a module possibly within the same driver which can request that it be re enumerated when a failure occurs. The module that requests re enumeration can reside inside a functional driver a bus driver or filter for example where the request to re enumerate is eventually processed by the lowest level driver in a stack. The request to re enumerate can also be handled by the driver by informing a bus manager that the device is missing and then later informing it that the device is present again. Generally after re enumeration the drivers in the stack abandon old error related state when an error occurs and create new or reset software related state when the device is re enumerated. In another aspect the drivers can reset hardware states after a new software state has been created possibly recovering from a hardware error.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced all of which are intended to be covered by the subject invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The subject invention relates to systems and methods for automatic recovery from errors in a computing system. In one aspect a system is provided to facilitate failure recovery in the computing environment. The system includes at least one driver component that enumerates at least one layer of a driver stack. A module e.g. bus or system manager associated with the driver component receives requests for re enumeration of the driver stack upon detection of an error in the computing system. Thus if an error is detected by a driver or operating system component a protocol can be established whereby a new copy of the driver s stack or system resources is created re enumerated in parallel to existing resources that may be in an unknown or error state. The new copy of the stack may allow the driver to become operational in lieu of the previous stack which can be reclaimed for other system uses over time. The protocol has the effect of simulating a plug and unplug hardware event which causes the stack to be re enumerated and to reset driver states in order to facilitate recovery from various failure events.

As used in this application the terms component driver system object and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal .

Referring initially to an error recovery system is illustrated in accordance with an aspect of the subject invention. The system includes an operating system framework or framework that interacts with one or more driver components also referred to as drivers to facilitate operations with hardware and or software components of a computing system. During normal operations e.g. non failure states the driver generally instantiates a stack of objects that facilitate interactions with the driver and the framework . For instance a Stack may be created at providing interface components such as I O Request Packet IRPs handlers that process I O events from the framework . Stack operations are described in more detail below with respect to . It is noted that the drivers can control hardware peripherals such as a keyboard mouse memory disk drive network ports and so forth and or can control software components drivers that can be partitioned combined or replicated into various functional elements.

During an error condition detected by the framework and or the driver a message protocol can be established that causes the driver to re enumerate or recreate one or more stacks in order to reset internal state mechanisms and to facilitate recovery from the condition . This allows for bootstrapping of the stacks in a controlled manner whereby the internal state of the re enumerated stack is reset. In many cases this can overcome permanent or temporary error conditions that may cause conventional drivers to lock up. For example the driver may indicate to the framework that an error has occurred. The framework can then via the message protocol initiate a surprise removal sequence which simulates in software the conditions of a module being removed from the system . The simulation causes the driver to then create a subsequent stack such as Stack from which to operate. If other errors are detected subsequent stacks can be created. Over time previously created stacks can be removed as is described in more detail below.

Generally the drivers can optionally support the concept of Surprise Removal. This allows the driver to be notified that a device or component that it is driving controlling has been physically removed from the system without notice. Typically all operations that are in progress should cease such as data transfers handling or I O request packets and so forth. The framework has standard infrastructure for negotiating with applications to cause release of any resources that are blocking the orderly disposal of the software state associated with a device or component instance. When that negotiation is complete old device objects can be deleted along with related state information.

Drivers which currently support Surprise Removal already have built in one mechanism for resetting all of their internal state insomuch as physically removing a device out of a system and reinserting it causes the current software state to be torn down and then rebuilt. In some conventional operating systems it is only possible to trigger a Surprise Removal by removing a physical object out of a machine or out of a port on the side of the machine. The subject invention provides the message protocol to trigger the same sequence of software events that would happen if a device were removed and reinserted. When this sequence is triggered the existing driver software state is abandoned and new state is created via the stacks . If the negotiation with associated applications is successful the old abandoned state can be torn down and disposed of e.g. memory space reclaimed for other uses .

Referring now to an exemplary stack is illustrated in accordance with an aspect of the subject invention. The stack can include one or more stack objects. For example the objects can include a Functional Device Object FDO a filter object supplied by an operating system framework and a Physical Device Object PDO . As illustrated I O Request packets IRP s can be propagated up or down the stack for respective processing wherein framework components or drivers can be driven and or synchronized from a respective IRP.

It is noted that some operating systems or frameworks support the concept of driver stacking. For example when an application opens up a handle to a device it controls the device by sending I O Request Packets to the stack of drivers at . Generally each of those drivers in the stack may react to modify or otherwise handle the IRPs that it observes. When one driver is finished with an IRP it usually passes the IRP down to the driver below it. There is also an opportunity for a driver to process an IRP after the driver below it has completed it. These type of stack actions are relevant since each physical device or component may have several drivers acting on it in some manner.

Generally surprise removal functionality relates to how drivers are structured wherein drivers are built in stacks with defined methods of passing requests called I O Request Packets or IRPs down and then back up the stacks. This allows for modular extension of existing function along with segmenting control of a device or component into multiple modules. When devices are connected to a machine it is usually through physical or logical connector often one that is called a bus. In software the connector and the circuitry behind it is modeled by a bus driver. The bus driver is generally responsible for determining what is plugged into the connector. When something is plugged in the driver creates the Physical Device Object or PDO which represents the new device. The PDO becomes the bottom of a new device stack. A Plug and Play manager or other component in the framework kernel sends IRPs to the new PDO to retrieve information about the PDO including which drivers should be loaded on top of it to provide device specific function. A driver which sits atop a PDO and provides specific functionality is the Functional Device Object or FDO . A device stack generally will consist of at least these two objects.

In order to re use the code paths that already exist to process Surprise Removal conditions an interface is provided whereby the FDO or any other driver layered on top of a PDO can send a request down the device stack requesting the bus driver to simulate a series of physical unplug and re plug events. When the request reaches the PDO the bus driver notifies the framework e.g. Plug and Play manager that the device has been removed. A subsequent operating stack is then re enumerated as is described in more detail below.

The driver returns a list of PDOs at that includes the child PDOs in the previous list at plus a new PDO created to represent the device anew. The manager responds to this new unknown PDO at by sending the IRPs it would to a brand new device gradually discovering which drivers should be layered on top of it. It should discover the same drivers that were atop the old PDO. As those get loaded a new state will be created for each PDO allowing device operation or a general kernel extension to re start cleanly. In a similar manner failures in PDO related code of the driver can also be handled by sending a similar sort of request internally from one part of the driver to another.

When the above API is called a request is sent to the PDO by making a direct call through an interface obtained by sending IRP MN QUERY INTERFACE. This interface is defined as follows 

For the above mechanism to succeed the failing driver and the bus driver which may be the same should support the interface. If they do then no further changes are necessary from the Kernel s PnP manager. It is noted that by keeping the interface functionality in the drivers older versions of the operating system do not have to be upgraded to support such functionality. An alternative implementation however could put some of the interface functionality into the PnP manager. It is also noted that the interface approach outlined above may also allow a device to continue operating after experiencing hardware related failures.

At a determination is made as to whether or not a failure has been detected with respect to a given driver. If not the process proceeds back to to continue normal system operations. If a failure has been detected at the process proceeds to where a surprise removal procedure is invoked by initiating a message protocol between the operating system and driver or visa versa that simulates a device s removal from the computing system. This exchange of protocol causes a re enumeration of the driver and associated stack at which results in a new driver state to be initialized that facilitates recovery from faults such as a non responsive or inordinately slow responding driver. After the re enumeration at the process proceeds back to to continue normal operations. As will be described in more with respect to various processes can be employed to reclaim resources that were previously allocated for non functioning driver stack or stacks that are no longer operational due to the protocol initiated at .

Proceeding to various example stack removal conditions for non functioning or previously allocated stacks are described. As noted above when an error condition is detected the subject invention can initiate re enumeration of a component stack to in effect simulate an actual module removal and thus facilitate resetting states within a new version of the stack in order to attempt to recover from a fault condition or conditions. When a new stack has been re enumerated or created in parallel other memory to an older version of the stack old stacks associated with previous fault conditions can be removed or reclaimed according to various techniques.

In one aspect proceeding to if an operating system or framework detects that all or a predetermined subset of handles to previously used or old stacks are closed interfaces or routines that may possibly access the old stacks can be terminated and the memory employed for the old stack can be reclaimed by the system and allocated for other uses. At old stack space can be reclaimed based upon a predetermined time threshold e.g. after 5 minutes of initiating a re enumeration remove old stack and calls thereto from system . At stack cleanup can occur after a predetermined count. For example an algorithm could run that says any time re enumeration of a driver has exceeded a predetermined count threshold then remove or reclaim all or a predetermined number of previous driver stacks. At stack cleanup and removal can occur as part of normal system background or foreground operations for example. For instance in a managed object system object memory can be reclaimed by a garbage collector that automatically removes unused objects from memory or the system. It is noted that another condition for the employment of timers and or counters is to facilitate that the same error condition is not encountered repeatedly. This could cause a new stack or stacks to be re enumerated for a similar problem encountered by the old stack and thereby cause excessive resources such as memory to be used.

A third state machine referred to as the Power Policy State Machine tracks system Power Management events or IRPs supplied by a system Power Manager . In one aspect the Power Policy State Machine manages tracking overall system state along with device usage deciding what power state the device should be in. The Power Policy Machine sends device Power management IRPs at that can become input events for the Power State Machine . Generally each of these state machines and generate some events that are consumed by the other machines or other components. Together they make up a larger system for implementing PnP and Power in the device driver or drivers . When the machines are integrated into a Driver Framework or operating system layer they can be employed by a plurality of different device drivers solving many problems such as system power consumption driver complexity error handling and system robustness.

Generally the state machines support a system that implements a general mechanism for PnP Device Power and or Device Power Policy events. The system includes entry into states in one state machine that can cause transitions to occur in other state machines or components. In one example entry into one state causes a Power Up event to be sent to the other state machines since these machines may have been sent events that caused the device to start being used. This would result in an Implicit event sent to the Power state machine which unifies the PnP and Power machines. In a multiprocessing operating system components generally do not wait by sitting in a loop with the processor these components suspend operations. Thus the Power Up event alerts the PnP state machine and causes it to start running again finishing the PnP operation. Specific state processing implementation examples include entry into a lower power state in the Power state machine causes a Power Down event to be fed into the Power Policy and the PnP state machines.

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the subject invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the subject invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the subject invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject invention are possible. Accordingly the subject invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

