---

title: Interface protocol and API for a wireless transceiver
abstract: A wireless protocol may be implemented in a smart transceiver device that contains the physical (PHY) and media access control (MAC) layers of the wireless protocol stack. In various embodiments, a serial peripheral interface (SPI) based design may be used. Disclosed is an embodiment of a protocol which may be used to provide control and data transfer to and from the smart transceiver. In particular, an exemplary format of the protocol, the commands, and responses is disclosed. In a further embodiment, an application programming interface (API) is disclosed. The API may provide hardware independent services that can be used to establish, maintain, and transport data to and from the system and the smart transceiver device. In particular, an exemplary and non-limiting set of services, function calls, configuration methods, events, and parameters is disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08060681&OS=08060681&RS=08060681
owner: Microsoft Corporation
number: 08060681
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
This application claims the benefit of U.S. Provisional Application No. 60 990 365 filed Nov. 27 2007 the entirety of which is incorporated herein by reference.

This application is related by subject matter to the subject matter disclosed in the following commonly assigned application the entirety of which are hereby incorporated by reference herein U.S. patent application Ser. No. 12 163 880 filed on Jun. 27 2008 and entitled Serial Peripheral Interface For A Transceiver Integrated Circuit. 

A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document Copyright 2006 2007 Microsoft Corp.

The presently disclosed subject matter relates to the field of computing and electronics and more particularly to fields such as entertainment consoles although these are merely exemplary and non limiting fields.

Video game and entertainment systems are increasingly incorporating wireless features and accessories. Development of the wireless radios and the necessary drivers require significant design effort. In turn the commands and protocols required to control and manage the wireless interfaces can be complicated and require significant development resources for developers of software and hardware accessories for the wireless systems. Furthermore wireless technologies and related standards change on a frequent basis requiring developers to adapt to new interface requirements. Thus a developer s investment in developing products for a particular wireless interface may not be recouped when the interfaces and protocols frequently change.

Nevertheless it would be advantageous to use an existing standard interface developing wireless features and accessories. An interface standard widely used in the industry and supported by a large number of products typically drive down costs and incorporation of such off the shelf components is desirable to reduce the cost of product development. Furthermore in the case of a wireless transceiver it is typically desirable to limit the number of IC pins needed to support inter processor communications while at the same time providing sufficient data bandwidth. Therefore a simple serial interface may be selected for a wireless architecture. One such standard interface commonly used and well known in the art that provides such features is the Serial Peripheral Interface SPI . One limitation of the SPI interfaces is that data transfers are limited to 8 bits at one time. Because many applications may require higher command and data transfer capability a higher level protocol is needed that has the advantages of a serial interface. Furthermore it would advantageous to provide an interface that developers can use to utilize the wireless features while not having to be concerned with the physical and transport details of the interface.

Various systems methods and computer readable instructions are disclosed herein for providing a platform to support the development of new wireless accessories for video game and entertainment systems using serial interfaces such as the Serial Peripheral Interface SPI . In one exemplary and non limiting aspect of the present disclosure a smart transceiver device may contain the complete physical PHY and media access control MAC layers of the wireless protocol stack and the wireless protocol functionality may be partitioned into a single device.

In various embodiments a protocol is disclosed that may be used to provide control and data transfer to and from the smart transceiver device. In particular an exemplary format for the protocol the commands and responses is disclosed.

In a further embodiment an application programming interface API is disclosed to provide an interface for developers to provide a hardware independent set of services. Such an API may be used to establish maintain and transport data to and from the system and the smart transceiver device. Services may be invoked as desired by the API. In particular an exemplary and non limiting set of services function calls configuration methods events and parameters is disclosed.

It should be noted that this Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

This section of the present disclosure provides the general aspects of an exemplary and non limiting game console. Referring now to a block diagram shows an exemplary multimedia console. The multimedia console has a central processing unit CPU having a level 1 L1 cache a level 2 L2 cache and a flash ROM Read only Memory . The level 1 cache and level 2 cache temporarily store data and hence reduce the number of memory access cycles thereby improving processing speed and throughput. The flash ROM may store executable code that is loaded during an initial phase of a boot process when the multimedia console is powered. Alternatively the executable code that is loaded during the initial boot phase may be stored in a flash memory device not shown . Furthermore ROM may be located separate from CPU .

A graphics processing unit GPU and a video encoder video codec coder decoder form a video processing pipeline for high speed and high resolution graphics processing. Data is carried from the graphics processing unit to the video encoder video codec via a bus. The video processing pipeline outputs data to an A V audio video port for transmission to a television or other display. A memory controller is connected to the GPU and CPU to facilitate processor access to various types of memory such as but not limited to a RAM Random Access Memory .

The multimedia console includes an I O controller a system management controller an audio processing unit a network interface controller a first USB host controller a second USB controller and a front panel I O subassembly that are preferably implemented on a module . The USB controllers and serve as hosts for peripheral controllers a wireless adapter and an external memory unit e.g. flash memory external CD DVD ROM drive removable media etc. . The network interface and or wireless adapter provide access to a network e.g. the Internet home network etc. and may be any of a wide variety of various wired or wireless interface components including an Ethernet card a modem a Bluetooth module a cable modem and the like.

System memory is provided to store application data that is loaded during the boot process. A media drive is provided and may comprise a DVD CD drive hard drive or other removable media drive etc. The media drive may be internal or external to the multimedia console . Application data may be accessed via the media drive for execution playback etc. by the multimedia console . The media drive is connected to the I O controller via a bus such as a Serial ATA bus or other high speed connection e.g. IEEE 1394 .

The system management controller provides a variety of service functions related to assuring availability of the multimedia console . The audio processing unit and an audio codec form a corresponding audio processing pipeline with high fidelity 3D surround and stereo audio processing according to aspects of the present disclosure described above. Audio data is carried between the audio processing unit and the audio codec via a communication link. The audio processing pipeline outputs data to the A V port for reproduction by an external audio player or device having audio capabilities.

The front panel I O subassembly supports the functionality of the power button and the eject button as well as any LEDs light emitting diodes or other indicators exposed on the outer surface of the multimedia console . A system power supply module provides power to the components of the multimedia console . A fan cools the circuitry within the multimedia console .

The CPU GPU memory controller and various other components within the multimedia console are interconnected via one or more buses including serial and parallel buses a memory bus a peripheral bus and a processor or local bus using any of a variety of bus architectures.

When the multimedia console is powered on or rebooted application data may be loaded from the system memory into memory and or caches and executed on the CPU . The application may present a graphical user interface that provides a consistent user experience when navigating to different media types available on the multimedia console . In operation applications and or other media contained within the media drive may be launched or played from the media drive to provide additional functionalities to the multimedia console .

The multimedia console may be operated as a standalone system by simply connecting the system to a television or other display. In this standalone mode the multimedia console may allow one or more users to interact with the system watch movies listen to music and the like. However with the integration of broadband connectivity made available through the network interface or the wireless adapter the multimedia console may further be operated as a participant in a larger network community. In this latter scenario the console may be connected via a network to a server for example.

Second now turning to illustrated is a block diagram representing an exemplary computing device that may be suitable for use in conjunction with implementing the subject matter disclosed above. Numerous embodiments of the present disclosure may execute on a computer. For example the computer executable instructions that carry out the processes and methods for providing PC experiences on gaming consoles may reside and or be executed in such a computing environment as shown in . The computing system environment is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the presently disclosed subject matter. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment . In some embodiments the various depicted computing elements may include circuitry configured to instantiate specific aspects of the present disclosure. For example the term circuitry used in the disclosure can include specialized hardware components configured to perform function s by firmware or switches. In other examples embodiments the term circuitry can include a general purpose processing unit memory etc. configured by software instructions that embody logic operable to perform function s . In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic and the source code can be compiled into machine readable code that can be processed by the general purpose processing unit. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware software or a combination of hardware software the selection of hardware versus software to effectuate specific functions is a design choice left to an implementer. More specifically one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process. Thus the selection of a hardware implementation versus a software implementation is one of design choice and left to the implementer.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It may be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

This network may itself comprise other computing entities that provide services to the system of and may itself represent multiple interconnected networks. In accordance with an aspect of the presently disclosed subject matter each entity and may contain discrete functional program modules that might make use of an API or other object software firmware and or hardware to request services of one or more of the other entities and .

It can also be appreciated that an object such as may be hosted on another computing device . Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any such infrastructures whether coupled to the Internet or not may be used in conjunction with the systems and methods provided.

A network infrastructure may enable a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. In computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of any entity and can be considered a client a server or both depending on the circumstances. And moreover regarding the entertainment console it can be a client to a server.

A server is typically though not necessarily a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

In light of the diverse computing environments that may be built according to the general framework provided in and the further diversification that can occur in computing in a network environment such as that of the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture or operating system. Instead the presently disclosed subject matter should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims. Thus for example although game consoles and server PCs have been discussed just as easily full desktops could be remoted to smart phones as a means to access data and functionality that is otherwise unavailable to smart phones.

Finally it should also be noted that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods computer readable media and systems of the presently disclosed subject matter or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium where when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the subject matter.

In the case of program code execution on programmable computers the computing device may generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects of the present disclosure e.g. through the use of a data processing API or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Various systems methods and computer readable instructions are disclosed herein for providing a platform to support the development of new wireless accessories for video game and entertainment systems. To limit the number of IC pins needed to support inter processor communications a simple serial interface may be used. In particular to provide a common interface with as many off the shelf CPU parts as possible and to support the required data traffic a Serial Peripheral Interface SPI based design may be implemented.

SPI is an interface that enables the serial exchange of data between a master and a slave device. SPI typically uses a synchronous protocol where transmitting and receiving is guided by a clock signal generated by master microcontroller. The SPI interface allows the connection of several SPI devices while a master selects each device with a CS Chip Select signal.

SPI is a synchronous serial data link standard. Devices communicate in a master slave mode where the master device initiates the data frame. Multiple slave devices are allowed with individual chip select lines.

During each SPI clock cycle a full duplex data transmission occurs in which the master sends a bit on the MOSI line the slave reads the bit from that same line the slave sends a bit on the MISO line and the master reads it from that same line. Transmissions typically involve two shift registers of a given word size such as eight bits one in the master and one in the slave. The shift registers are connected in a ring configuration. Data is typically shifted out with the most significant bit first while shifting a new least significant bit into the same register. After that register has been shifted out the master and slave have exchanged register values. The process may then repeat as needed.

In one exemplary and non limiting aspect of the present disclosure a smart transceiver device may be provided to support the rapid development of new wireless accessories for gaming platforms. In an embodiment a smart transceiver may provide receiver and transmitter functions for physical and link wireless communications layers. In particular the PHY and Link layers of a wireless protocol stack and wireless protocol functionality for such a device may be implemented in a wireless application specific integrated circuit ASIC . In one embodiment the smart transceiver may be the slave and a master control application may be the master of an SPI bus.

In an embodiment wireless communication may be provided using a frequency hopping digital radio protocol with time division multiplexed access TDMA granting radio time for each wireless accessory. The unlicensed worldwide 2.4 GHz Industrial Scientific Medical ISM radio band may be utilized. A minimum of external components may be needed to implement a complete Frequency Hopping Spread Spectrum FHSS 2.4 GHz ISM band digital radio transceiver compliant with worldwide regulatory requirements.

A shortcoming of a standard SPI interface is that data transfers are limited to 8 bits at one time. Because many applications may require higher command and data transfer capability a higher level protocol is needed that still retains the advantages of a serial interface. In consideration of an efficient control data transport method across the SPI bus with full duplex data transfer in various embodiments a frame based SPI protocol is disclosed that may be used to provide control and data transfer to and from the smart transceiver device. In particular an exemplary format for the protocol the commands and responses is disclosed. In an embodiment each frame may consist of a 2 byte header with a variable payload length. The header may comprise 2 parts a command byte and a length byte. The length of the payload may be dependent upon the specific command and the longest packet may define the length of the transfer. provides an exemplary illustration of a typical data transfer.

Because the disclosed protocol comprises a full duplex interface if one device has no information to transfer the device may send an idle command. The disclosed protocol may maintain a master slave structure with a master control application typically controlling all transactions and the master control application transferring data whenever it has a message ready to transmit. The smart transceiver may act as the slave device and may return a reply indicating either the result of the request compliance to the command or an indication of the occurrence of an event from a previous request. The smart transceiver may further generate an interrupt to the master control application indicating that a message is ready to be read by the master.

The disclosed protocol may further comprise the following rules that apply to a frame transaction. First the chip select may be in an active state. Second a header may always be transmitted first on both ends of the link. If one end has no valid message to transmit the command field may be set to be 0x00. Third the longest frame master to slave or slave to master may be used to define the length of the transfer. Fourth if one side has more than one packet to send the independent messages may be appended together within the same frame.

No guard time may be required after the frame header. A CS transition low to high can be used for frame synchronization. To support SPI multi slave applications MISO pads may be set to tristate after data transfer is finished triggered by CS . Data bytes may be set to don t care after the number of data bytes defined by length bytes are transmitted.

In one embodiment the smart transceiver functionality may be selected at startup. The functionality of the smart transceiver may be different depending upon the desired application. The functionality may further depend upon the product type the smart transceiver is used in. For example if the IC is used in a voice only device the IC may operate differently than if the product is a game controller device. The SPI command structure may change depending upon the type of application the smart transceiver is configured for.

The smart transceiver device may be designed to simultaneously support up to four data and voice accessories or four data only and 4 voice only accessories or any combination in between. The smart transceiver when implemented in a wireless accessory may communicate with wireless video game consoles or a wireless enabled personal computer or other computing device that is equipped with a similar smart transceiver.

The smart transceiver may be a platform that may be used to support various product configurations. Firmware within the smart transceiver may be adjusted to support various product versions without changing the chip hardware. In a video game system the smart transceiver may be used to support video console products game controller products and various peripheral products.

The smart transceiver may respond with a Startup Configuration Response . The master control application may send commands to retrieve EEPROM data for application configuration. If transmitted the master control application may send the commands and wait for the responses from the smart transceiver .

The master control application may send an application configuration command . The application configuration command may set up the smart transceiver chip into the mode that the master control application needs. The smart transceiver may respond with the Application Configuration response .

The master control application may send the command to set the application to active . The smart transceiver may then respond with the current mode of Application Active .

In the configuration standby state limited SPI commands may be allowed by the master control application. The smart transceiver typically does not have enough information to perform any functions at this point and needs the master control application to provide more data. Typically the only commands that may be allowed in this state are mode control i.e. power reset and startup configuration messaging.

The pre application state may be entered after the master control application sends a valid startup configuration message. This state may allow more SPI commands but the number may be limited because the application has not been established. The primary functionality of the allowed commands typically may be configuration reads configuration setting and mode control. The smart transceiver may remain in this state until the master control application changes it to another state.

The application standby state may be entered after the master control application sets the application configuration. The application typically does not start until the master control application sets the state to active.

The application active state may be entered from the application standby state after the master control application sets the mode to active. The application active state is typically the normal operating mode of the device. The master control application may continue to issue commands that are allowed by the application.

The following is an exemplary list of messages that support smart transceiver functionality. The commands are depicted in two sets. The first set are commands that may be independent of the application. The second set depicts exemplary application specific commands. Typically the command set may be a subset of a more complete command set.

The table below lists exemplary application independent commands. The command details specific format and field means are provided in Appendix A.

A gamepad application may use a wireless protocol associated with gamepad handling. The voice part of the gamepad application may acquire the voice channel using gamepad rules. The table below shows the SPI messages that may be used by a gamepad application.

A voice device application may use a wireless protocol associated with a voice device. The voice part of the wireless application may acquire the voice channel using voice rules. The table below shows exemplary SPI messages used by a voice application.

Next the API is described. In one embodiment the slave device may be comprised of an application processor AP and the smart transceiver as a wireless protocol processor. The API may be located in the application processor. The two processors may be connected via a Serial Peripheral Interface SPI .

As shown in while the services may be provided independently of the actual hardware and software environment in one embodiment the API may assume a separate application processor master control application processor communicating via a serial interface with the smart transceiver. Furthermore in another embodiment the API may be used by a generic GPIO application.

In one embodiment the API may handle access to the physical radio channel and to the smart transceiver pins. The API may further be responsible for the following tasks 

A data communication service may be defined in terms of service primitives as exemplified in . A service primitive is an abstract interaction between the service providing layer and any service user task layer etc. . As such it may be independent of software implementation details. The service may be implemented as a function call or an operating system message as appropriate for the target system.

As shown in the Information Base IB may contain API parameters and configuration values. A service primitive may be one of four generic types 

The following convention may be used for primitives . The may be one of the following Req Ind Conf or Resp.

An exemplary list of packet types for the upstream data service are shown below. All types may be used in arbitrary sequence. The maximum upstream throughput may be given as 48 bytes per frame plus up to 16 bits in the header . The frame duration may be 8 ms. The total requested throughput typically does not exceed the maximum. For pure wireless voice devices e.g. headsets the . . . DATA VOICE . . . packet types may be used.

Most upstream packet types and the corresponding data sub services do not provide any packet queuing or flow control on the radio link. These data packets are assumed rewriteable. When rewriteable packets are sent faster than the available throughput permits a packet sent later may overwrite a packet sent earlier. Rewriteable packets are typically used to periodically transmit some state information.

An exemplary list of packet types for the downstream data service are listed. All types may be used in arbitrary sequence. The maximum downstream throughput may be given as 8 bytes per frame plus up to 16 bits in the header . The frame duration may be 8 ms. The total throughput typically does not exceed the maximum. For pure wireless voice devices e.g. headsets the . . . DATA VOICE . . . packet types may be used.

The PCM data therefore may be encoded by the smart transceiver to satisfy the throughput restrictions. PCM voice samples may be transferred 16 bit per sample left justified 2 s complement little endian format .

The sample rate may be changed any time by the master device. A sample rate indication may be provided for this case to trigger the audio handler to change the AD conversion parameters accordingly.

The upstream voice packet size attribute IB VOICE PACKET SIZE and the initial upstream encoding type attribute IB UPSTREAM VOICE ENCODING TYPE may be setup in the IB header file.

The management services may combine primitives not directly related to data or voice transmission services and the layer configuration via the information base IB . In typical application environments the IB attributes have fixed values and need not be changed during application execution.

The IB attributes may also be accessed by corresponding primitives get and set as an option for further extension. Then the IB access primitives may have separate confirm primitives because in most cases a communication with the smart transceiver involved.

The smart transceiver may have spare GPIO pins that can be used for either inputs or outputs. The configuration may be done via IB attributes.

The service primitives may set or clear up to 16 IO pins or deliver the current state of up to 16 IO pins either on request with the confirm primitive or unsolicited with the indication primitive .

An exemplary basic structure of the API is shown in . Depicted is a state machine which may handle the requests by the application generate events for the application depending on received SPI messages by the smart transceiver and the internal state. Buffering for transferring data and voice between master control application controller and the smart transceiver may be integrated in the API. The application layer may communicate with the API regarding primitive function calls to send out requests. In addition in one embodiment there are two functions GetEvent . . . and ReadEventDetails . . . for handling event messages from the API. For voice handling two functions PutVoiceBuffer . . . and GetVoiceBuffer . . . may be implemented. The SPI driver may be interfaced to the API with four functions to process the API buffer.

Indications and confirms may be received by the application as events event identifier and list of pointers to the received primitive elements . Function calls may be available to get an event and to read the event details. To optimize the voice processing task the buffer management for voice samples may be handled by a separate function call instead of an event. With an underlying Operating System this may be implemented with messages received by tasks or threads.

Instead of having an event loop for the reception of indications and confirms call back functions may be registered with the API. When the respective indication or confirm is received the corresponding function may be called.

The following table cross references SPI commands available to users and third party applications to the primitives discussed herein. If a primitive is listed more than once the relevant command is selected according to a primitive parameter e.g. Xair MdDataReq or an internal driver state e.g. Xair MmStartReq . Commands marked as FFS are currently not included in the specification but may be added as desired.

Lastly while the present disclosure has been described in connection with the preferred aspects as illustrated in the various figures it is understood that other similar aspects may be used or modifications and additions may be made to the described aspects for performing the same function of the present disclosure without deviating there from. For example in various aspects of the disclosure a protocol and API were disclosed. However other equivalent mechanisms to these described aspects are also contemplated by the teachings herein. Therefore the present disclosure should not be limited to any single aspect but rather construed in breadth and scope in accordance with the appended claims.

When the smart transceiver first starts up and the SPI mode has been detected and it is ready for SPI transfer it may load a startup message in its SPI output FIFO and assert the D AVAIL line. This message is typically used as a configuration message to let the master control application know the type of chip and its configuration. Even though the smart transceiver may automatically send this message at startup the master control application may request it at any time with the smart transceiver Startup Message Request.

After the master control application has received the Smart transceiver startup message it may send a startup configuration message to the Smart transceiver Chip. This message may let the Smart transceiver know what SPI protocol version it is using and the output clock speed it wants. The response message may contain the configuration data that was sent for a debugging check. The current startup configuration may be polled by the master control application sending the command with a length of 0 no payload .

Note that the response contains the data sent with the startup command as a confirmation it was received correctly.

If the SPI driver uses an SPI protocol version which is different than which the chip supports the chip may return its supported version and not the requested version. It is the driver s responsibility to use a version the chip can operate with.

The master control application has ultimate control over the smart transceiver operation. The mode commands allow the master control application to change the smart transceiver between modes. The different reset modes reset the smart transceiver chip so that it can start from a known state. The power modes either power down the smart transceiver or put it into another power state. A mode change message may be acknowledged by the smart transceiver before the mode change occurs.

The mode control poll is a good choice to use for a keep alive message for the master control application to determine the smart transceiver is still running correctly in different modes.

The master control application may send this command to the smart transceiver to change the mode or request the current mode. If no length is sent the request may be considered a poll of the current mode.

The Mode Control Response Message may be available at the SPI interface within 1 msec of reception of the Mode Control Request.

Typically the master control application may not send messages too fast for the smart transceiver to handle. Error messages are defined however in case the smart transceiver buffers are starting to fill. There is one message for warning the master control application about the buffers that are almost full. There is another message to clear the warning for a buffer type. In addition there is a message for the smart transceiver to tell the master control application that the last message was rejected. The reject message would only be sent if the master control application ignores the buffer warning and sends data for that buffer anyway or if the message is wrong for the current application or state.

This message may be sent by the smart transceiver when a buffer or buffers are almost filled. The smart transceiver firmware may be written such that it may send the warning when there is still room for at least one more message not including the one currently being received . Anytime this message is sent a complete list of all buffers that are in a warning status may be sent. When the master control application receives a buffer warning it should no longer send a buffer of that type until the warning is cleared.

This message may be sent when a buffer in warning has sufficiently cleared to allow more messages. The payload may list each of the buffer types that are being cleared. This may only list the buffers that had the warning type set previously and which are now safe to write to.

With good master control application coding this message should never be sent but it may be if the master control application ignores a buffer warning message and sends a buffer that cannot be accepted by the smart transceiver or if the message is wrong for the current application or state.

The master control application may request data to be written to or read from the EEPROM. Messages are limited to 32 bytes of data and only one message can be outstanding at a time one EEPROM read or one write message .

The master control application can request data from the EEPROM. This is performed with a read request. Sometime later when the smart transceiver chip as read the EEPROM it may return the data over the SPI with the EEPROM read response message. Both messages contain the EEPROM offset and length being read this lets the master control application sync its outstanding read request with the response. If there is an error the smart transceiver may return a request with no EEPROM data read. The messaging allows the master control application processor to put a context in the message to be returned. This can be used in any way the master control application processor wants. For example this may be a task number to resume when the response message is received.

The master control application can save nonvolatile data in the EEPROM. This is performed with a write request. Sometime later after the smart transceiver chip has written the data and validated it it may return a response message over the SPI channel to let the master control application know it is done. Both messages may contain the EEPROM offset and length being read allowing the master control application to sync its outstanding write request with the response. If there is an error the smart transceiver may return a request with an error status. The messaging allows the master control application processor to put a context in the message to be returned. This can be used any way the master control application processor wants. For example this may be a task number to resume when the response message is received. Data written may be returned in the response so the master control application can verify the correct data was written.

When this comment is transmitted the smart transceiver may change the HW encode type for the upstream path if necessary and also tag the upstream voice data with this type. If the command is sent without a payload the Smart transceiver may send the current type.

The smart transceiver IC has spare GPIO pins that can be used by the master control application chip for either inputs or outputs. At the smart transceiver initialization time all of the spare GPIOs may be configured as inputs and their status may be sent as part of the smart transceiver Startup message. Messages may allow the master control application to configure the GPIOs and to read or write to the GPIOs. When configuring inputs the master control application can request that GPIO status messages be sent whenever a requested input changes. These messages may be queued and ready to send to the master control application within 4 msec. The GPIO status messages are lower priority than buffer and mode messages.

If the master control application wants to use the GPIO of the smart transceiver it has to set them up correctly. There are separate bit maps to determine inputs and outputs.

The application may set up the frame sync message to be any location in the frame. By default the frame sync message may be turned off. When enabled the frame sync message may be loaded into the SPI buffer and made ready when the frame bit clock reaches the trigger value.

To improve throughput across the SPI port it is possible to synchronize the upstream and downstream voice data so both packets types are transferred simultaneously across the full duplex connection.

By default when this message is enabled the Frame Sync message may be disabled. When this message is disabled the Frame Sync message may be enabled.

The master control application can use this message to begin full duplex transport across the SPI interface.

The configuration messages allow the master control application to set the smart transceiver chip to the correct application with its specific options.

This mechanism allows the master control application to select the correct application and the various options for it.

If invalid option flags or voice packet size fields are detected by the smart transceiver it may remain in the Pre Application state until it receives a valid Application Configuration command.

Once the master control application is ready it may try to initiate a connection to the host. In the gamepad application it may first establish the data connection and once that is done it may try to establish a voice connection if there is a headset plugged in. Once connections are established they can be dropped because of three different instances 

Once the application is up and running it may ask the smart transceiver to connect to the host. The smart transceiver chip may use the protocol rules to find the host and select a wireless slot. As soon as the connection process is started the host may return a connect request response. Once a slot is obtained a connection status report may be sent. If the master control application wants the connection dropped it may set the Action to Drop Connection and send that message. The Smart transceiver may drop the connection and turn off the radio. A connection dropped response may be returned. In addition a link status message may be sent with a link status of Slot dropped per master control application request and then a link status of Radio off .

The master control application shouldn t send any data to be transferred before it receives a link status message indicating the link was acquired. If it does the data may get flushed and never sent.

Once the application is up and running and a headset is plugged in and a data connection is obtained the master control application may ask the smart transceiver for a voice connection. The smart transceiver chip may use the gamepad voice protocol rules to select a wireless slot. As soon as the connection process is started the host may return a connect request response. Once a slot is obtained a connection status report may be sent.

The master control application may want to query link status. In addition the smart transceiver application may want to send messages when the link status changes.

Once the applications are up and running and the radio links are obtained most of the transfers are buffer transfers for data to be sent or data that was received. Each data type defined in the protocol has its own set of buffers. For upstream messages the master control application may send buffers as it has them. If the buffer allocation for a particular data type is low the Smart transceiver chip may send a warning with the buffer type that is low. The master control application can only send one more buffer of that type including one that may be simultaneously being transferred until it gets a warning clear . In practice it is assumed that there are enough buffers that the warnings may never happen. As the smart transceiver receives messages from the wireless channel it may send them on to the master control application using the correct data type message.

Controller header reports are the status reports sent via the wireless header. An example of these is the device type report.

The voice buffers may be the longest data that can be sent in one message on a regular basis. To allow better use of the full duplex bus the master control application may configure the voice buffers to be split into smaller pieces. This configuration may be set at startup and not set on the fly. Packet may considered the base type and if the voice is not split up it may be the only voice packet type transferred. The master control application processor may let the smart transceiver chip know which type of coding is being used so that it can put the correct data type in the voice header. If the smart transceiver is performing the voice encoding it may use the type that the master control application has set. The smart transceiver may need to keep track of the voice packets received over SPI and ensure that when split packets are used all packets are received before the complete buffer is sent over the wireless channel. The master control application may need to provide similar functionality on the data it receives from the smart transceiver.

If the master control application has configured the application to provide voice decode and encode these packet types may be used to fill the buffer. The configuration option Upstream Voice Packet Count may be used to control which packets are sent. Packets with different command codes may be used so that the smart transceiver can set up its DMA to point to the correct buffer location. Table 43 shows the maximum packet sizes used for PCM packets.

All PCM samples may be 16 bit 2 s compliment little endian format. This means the first byte is the low byte of the first sample the second byte is the high byte of the first sample etc. In addition if an ADC is used that is less than 16 bits the samples may be left justified.

If the master control application has configured the application to provide voice decode and encode these packet types may be sent. The configuration option Downstream Voice Packet Count may be used to control how many packets are sent. Table 47 shows the maximum packet sizes used for PCM packets. Note that the packets may contain an extra byte for status to let the master control application processor know whether the data CRC validated. Bad data may only be sent if the master control application has configured the smart transceiver for it.

The configuration messages allow the master control application to set the smart transceiver chip to the correct application with its specific options.

This mechanism allows the master control application to select the correct application and the various options for it.

Once the master control application is ready it may try to initiate a connection to the host. In the voice device application it may first search for and sync with the host and then may establish a voice slot connection using the voice device protocol. Once connections are established they can be dropped because of three different instances 

Once the application is up and running the master control application may ask the smart transceiver for a voice connection. The smart transceiver chip may use the voice device protocol rules to select a wireless slot. As soon as the connection process is started the host may return a connect request response. Once a slot is obtained a connection status report may be sent. If there is no binding information the smart transceiver may return an error connection response.

The master control application may want to query link status. In addition the smart transceiver application may want to send messages when the link status changes.

The voice buffers are the longest data that can be sent in one message on a regular basis. To allow better use of the full duplex bus the master control application may configure the voice buffers to be split into smaller pieces. This configuration may be set at startup and not on the fly. Packet is considered the base type and if the voice is not split up it may be the only voice packet type transferred. The master control application processor may let the smart transceiver chip know which type of coding is being used so that it can put the correct data type in the voice header. If the smart transceiver is performing the voice encoding it may use the type that the master control application has set. The smart transceiver may need to keep track of the voice packets received over SPI and ensure that when split packets are used all packets are received before the complete buffer is sent over the wireless channel. The master control application may need to provide similar functionality on the data it receives from the smart transceiver.

If the master control application has configured the application to provide voice decode and encode these packet types may be used to fill the buffer. The configuration option Upstream Voice Packet Count may be used to control which packets are sent. Packets with different command codes may be used so that the smart transceiver can set up its DMA to point to the correct buffer location. Table 43 shows the maximum packet sizes used for PCM packets.

All PCM samples are 16 bit 2 s compliment little endian format. This means the first byte is the low byte of the first sample the second byte is the high byte of the first sample etc. In addition if an ADC is used that is less than 16 bits the samples may be left justified.

If the master control application has configured the application to provide voice decode and encode these packet types are sent. The configuration option Downstream Voice Packet Count is used to control how many packets are sent. Table 47 shows the maximum packet sizes used for PCM packets. Note that the packets contain an extra byte for status to let the master control application processor know whether the data CRC validated.

API request functions may be called from the application in order to initiate an action in the communication stack at the API level. API functions may be prefixed with and suffixed with  req.

