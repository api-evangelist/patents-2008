---

title: Method and system for performing software verification
abstract: Described is a method, system, and computer program product that provides control of a hardware/software system, and allows deterministic execution of the software under examination. According to one approach, a virtual machine for testing software is used with a tightly synchronized stimulus for the software being tested. A verification tool external to the virtual machine is used to provide test stimulus to and to collect test information from the virtual machine. Test stimulus from the verification tool that is external to the virtual machine provides the stimulation that incrementally operates and changes the state of the virtual machine. The stimulus is created and coverage is collected from outside the virtual machine by first stopping the virtual machine, depositing stimulus, and then reading coverage directly from the virtual machine memory while the machine is stopped.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930912&OS=08930912&RS=08930912
owner: Cadence Design Systems, Inc.
number: 08930912
owner_city: San Jose
owner_country: US
publication_date: 20081216
---
Important steps in the modern software development process are the steps of testing and debugging software to ensure that the software will work and function as expected in its intended processing environment. These steps are usually implemented as methodical processes of finding and reducing the number of defects in the software program to make it behave as expected or intended.

These tasks are often made much more difficult if the software program is tightly coupled to other devices subsystems or programs because it is often difficult to determine and test the complex interactions between the software and the other subsystems and components in the overall system particularly if the operating environment is constantly subject to multiple inputs and status changes. Moreover changes in one part of the system may cause unexpected results and errors to emerge in other parts the system.

For example programmers often have a problem testing software that runs in the context of an operating system because of the enormous number of complex inputs and interactions that occur on a near constant basis. One reason for this is because when errors occur it is very difficult to repeatedly observe the errors and to repeat the error in a deterministic way. This desire to be able to repeatedly observe the errors is very important for purposes of performing program debugging and correction.

A common example of a program that may need to be tested in the context of an operating system is a device driver that executes in the context of an operating system such as the Linux operating system . A typical type of problem that occurs with device drivers is the intermittent problem that is experienced when the timing of events cause a problem e.g. when a particular state S of the hardware combines with a particular state S of the device driver software such that an error occurs where neither the state S of the hardware nor the state S of the software by themselves would cause an error but it is the combination of both states occurring at exactly the same time that causes the error.

In this situation it is a common struggle for software engineers to attempt to observe such intermittent problems and it is particularly difficult for the engineers to reproduce such problems so that they can be debugged. Since the problems are often timing related typical debugging techniques such as using print statements or using a software debugger introduces changes to the system states which could change the system timing and mask the problem.

Some embodiments of the present invention provide an approach that provides control of the hardware software system and allows deterministic execution of the software under examination. According to some embodiments the current invention utilizes a virtual machine for testing software with a tightly synchronized stimulus for the software being tested. In some embodiments of the invention a verification tool external to the virtual machine is used to provide test stimulus to and to collect test information from the virtual machine. Test stimulus from the verification tool that is external to the virtual machine provides the stimulation that incrementally operates and changes the state of the virtual machine. The stimulus is created and coverage is collected from outside the virtual machine by first stopping the virtual machine depositing stimulus and then reading coverage directly from the virtual machine memory while the machine is stopped.

Further details of aspects objects and advantages of the invention are described below in the detailed description drawings and claims. Both the foregoing general description and the following detailed description are exemplary and explanatory and are not intended to be limiting as to the scope of the invention.

The present invention provides an approach that allows control of a hardware software system and permits deterministic execution of the software under examination. According to some embodiments the current invention utilizes a virtual machine for testing software with a tightly synchronized stimulus for the software being tested.

In some embodiments of the invention a verification tool external to the virtual machine is used to provide test stimulus also referred to as stimulus to and to collect test information from the virtual machine. Rather than running test software from within the virtual machine test stimulus that is external to the virtual machine provides the stimulation that incrementally operates and changes the state of the virtual machine. The stimulus is created and coverage is collected from outside the virtual machine by first stopping the virtual machine depositing stimulus and then reading coverage directly from the virtual machine memory while the machine is stopped so that no extra execution is required. After new stimulus is deposited into memory the virtual machine is restarted. The concept of starting and stopping the virtual machine for the purpose of synchronization with the verification environment and for backdoor read and write access to virtual machine is a novel feature of the invention and allows full deterministic testing of the software that is under examination.

The verification tool interacts with both the software design and the virtual system that is to be run on an actual hardware device providing test stimulus that is used to test and verify the software . Verification is the term that is often used to refer to the process of determining whether a given design meets its requirements. In practice verification is the process of identifying and removing as many functional bugs in the hardware and software as possible. According to the present embodiment verification tool is a computer aided design CAD tool or electronic design automation EDA tool that has the capability to utilize a verification environment for testing a design having hardware software or a combination of both hardware and software. The verification environment is used to create activity that is similar to the way the overall system is expected to behave thereby providing stimulus to actively and thoroughly test the design. The test verification environment may be implemented using test software in a language specific to the test system.

A virtual machine is a software implementation that is built above a hardware based system and performs processing in a manner that is like a hardware based system. Different variants of virtual machines exist that are either more or less tied to an actual physical machine. One reason for using a virtual machine in the architecture of is that the virtual machine technology can be used to emulate the hardware operating system and software of an underlying system . While some virtual machine implementations have a feature to record and replay an execution history that is meant to help debug software problems this feature replays a fixed instruction sequence in a way that does not allow for any modification of the test program or any instruction changes. Therefore it is usable only for debugging purposes and cannot be effectively used to generally perform verification upon a software application that covers different functions of the software with different coverages.

For the purposes of illustration various embodiments of the invention will be described and explained with respect to specific examples of virtual machine implementations. It is noted however that the invention is not limited to the specific examples shown herein and indeed may readily be applied to other types of virtual machine implementations within the scope of the invention.

In operation verification tool uses the control interface to perform controlled stops and starts of activity within the virtual machine . During the controlled stop test stimulus can be applied to the virtual machine to exercise the software that is under test. One approach for performing this action of sending the test stimulus to the virtual machine is to insert the test stimulus into the memory at the virtual machine in the portions of the memory that hold data for the software . Any suitable memory copy access operation may be utilized to perform the act of inserting the test data into the memory .

In addition during the controlled stop the verification tool can access read the memory to obtain the state and status of the virtual machine . By accessing the memory in this manner the verification tool is able to collect the results from the last cycle of tests that were performed upon the software . This action is performed by performing a memory copy access operation upon the portion of the memory that holds status and state data for the software as well as the portions that hold status state data for any other parts of the virtual machine that would be of interest e.g. the operating system or hardware. In effect the verification tool provides an external monitor for the activities that occur at the virtual machine based the test stimulus that is applied to the virtual machine .

Once the test stimulus has been sent to the virtual machine and any necessary status state results have collected a controlled start is performed to restart activity at the virtual machine . The verification tool waits while the virtual machine continues processing based upon the test stimulus that was provided to the software .

At any point in the test cycle the software test engineer can perform a controlled stop to collect test data and or to provide further test stimulus . For example the test engineer may perform a controlled stop upon the occurrence of an error or at the end of a test cycle.

While shows both collecting of test data and sending of test stimulus during a single cycle of start and stop it is noted that both activities and need not be performed during the same start stop cycle. Instead the start stop cycles may be configured to only include collection of data or only the sending of additional test stimulus .

A system virtual machine provides a complete platform which supports the execution of a complete operating and run time environment. System virtual machines sometimes called hardware virtual machine allow the sharing of the underlying physical machine resources between different virtual machines each running its own operating system. The software layer providing the virtualization is called a virtual machine monitor or a hypervisor. Multiple operating systems can co exist on the same computer in isolation from each other. In addition the virtual machine can provide an instruction set and machine controls that are different from that of the real underlying machine.

A process virtual machine runs as a single program and supports a single process. A process virtual machine runs as a normal application inside an operating system and supports a single process. The process virtual machine is created when that process is started and destroyed when it exits and provides a platform independent environment that abstracts away details of the underlying hardware or operating system and allows a program to execute in the same way on any platform. This type of virtual machine is often used for example in conjunction with Java programming.

The virtualization software is used to emulate the hardware operating system and software of an underlying physical system . This type of emulation is referred to as full virtualization of a system and can be implemented with the hypervisor of a system virtual machine. The hypervisor may run directly on the underlying hardware or over an intervening operating system such as Linux. Any suitable virtualization software may be used in conjunction with the present invention. Examples of commercially or openly available virtualization software include for example software from VMware Xensource and QEMU.

The virtual machine comprises application software and an operating system . Multiple virtual machines may co exist in the system with each running their own operating system and application software . The present verification system can be used to test and debug multiple items of software running on multiple virtual machines.

Software interface provides an external program with the ability to interact with and control the activities within the virtual machines . According to some embodiments of the invention the software interface comprises a set of API application programming interface calls that are established by the vendors of the virtualization software to allow third party developers to create add ons and modification to the virtualization mechanisms. It is this set of vendor provided APIs that can be used to perform controlled starts and stops of the virtual machines while sending test stimuli to and collecting test results from the virtual machines.

The verification tool may implement one or more automated verification plans containing a set of goal metrics that are used to measure progress toward verification completion. By definition of the plan s if these metrics are achieved the design is verified. The process of verification planning is used to define the corner cases that need to be addressed and the use of automated constrained random stimulus to address these corner cases is known as Coverage Driven Verification CDV . To perform CDV the corner cases are converted into coverage points where the goal is to reach 100 coverage. Using random generation to reach coverage points may also result in new corner cases that engineers may not themselves have contemplated. Constrained random stimulus and functional coverage metrics may be applied to the software design in conjunction with co debugging in which the system may be started and stopped to observe the behavior of the system. In this context the term co debugging means inspecting both the software program being verified and the hardware model running in the virtual machine.

The verification test should provide sufficient code and functional coverage of the software being tested. Code coverage items that can be addressed by the invention include for example line coverage branch coverage and function call coverage. Functional coverage items include values of variables including state variables function call arguments local variables global variables and function return values.

At environment creation is performed to create the verification environment. This action defines and identifies the functions and variables to be accessed within the software under test. In addition ports are identified to define the interfaces to the software under test. For example if the e programming language is being used for the verification environment then the method simple and event ports are generated at to define the interfaces to the software under test. The software binary may be accessed and functions and variables may be identified using debug type information.

Sequence and test creation are performed at . This action creates software routines and variables for the verification sequence where test sequences may be graphically created from the generated environment. The order and timing within the test sequence may be varied and constraints defined for the test. Software code can also be created for the test files.

The test is created by identifying the specific functions and variables to operate upon for the software being tested. This action may be performed based upon user interaction and selection. Test generation information is then produced based upon the selected functions and variables. The test generation information may include function prototypes variable names and data types and data type size and representations. Function prototypes refer to the semantic representations of functions and their arguments. The information about variable names and sizes include the names and sizes of each of the variables that have been selected for testing. The information about type size and representations include type sizes and representations for the software program generated by the compiler during the process of compiling source code into analyzed object code.

The testbench generator takes as input the function prototypes variable names and types and type size and representations to produce a testbench that can be used by a verification tool to verify the software program. The verification tool will be used in conjunction with a software adapter or interface logic to connect the verification environment to the software being verified. For example the Specman ISX verification tool can be modified to include software adapter logic to interface a verification environment written in the e language to a Linux device driver that is written in the C programming language. The testbench includes information and constructs that are appropriate to allow the software adaptor from the verification tool to the virtual machine to operate with the software program being verified. For example such information and constructs could include method function ports ports for variables sequence information coverage information and type mappings. Type interpreter logic may be employed to generate the type mappings.

Ports allow communications between the methods and functions in the source and test language codes. Ports are generated by identifying the source method function prototype for the method or function of the software program under test for which a port is needed. An identification is made of the method or function within the test system code that needs to communicate with the function or method in the software program under test. Output method ports can be defined that specifies the method prototype in the test system code and function prototype in the software program under test. The prototypes are used to map method function parameters between the call to the method in the test system code and the function in the software program under test. The output port is called from within the verification environment to exchange information and to interact with functions in the program under test. Input method ports can be defined that specifies both the method prototype in the test system code and function prototype in the software program being tested. The input port is called from within the embedded software to return data or to interact with the test language code in the verification environment.

Ports can also be implemented between variables which allow exchange and interaction between the variables in the software program being tested and the variables in the test language code e.g. the verification environment. Identification is made of the source variable in the software program being tested for which a port is needed as well as the variable type for which the port is needed. According to some embodiments the variable could be an event variable or a non event simple standard variable. It is sometimes useful to be able to trigger an event based upon a change in a software variable. The event type variable would be associated with event type ports to allow the triggering of events. If it is desired to be able to trigger events with the variable then an event port is defined for the variable. As an example consider if the software design has a variable or attribute called edge which has allowed values of rise fall or change . Further assume that it is desirable to allow the value or transition of value for this attribute to trigger an event within the verification environment. In this situation an event port would be defined that can be used to trigger events within the verification environment or the software program being tested e.g. for coverage and checking. If the variable is a standard or simple variable that is not to be used for triggering an event then a standard simple port is defined for the variable.

Given a set of functions it may be desirable to configure the sequences in which those functions are called. As a simple example to the extent the software program includes an initialize function to initialize the system then it is likely to be desirable to make sure that this function is called at the start of processing before calling other substantive functions within the system. As another example for the purpose of completeness in testing a software program it may be desirable to implement several alternate sequences in which the functions within the software program are executed. To implement sequencing identification is made for one or more items from the software under test for which it is desirable to impose a sequence. This action identifies for example functions from the software for which it may be desirable or beneficial to associate or imply a sequence. A determination is made of one or more sequences for the identified items from the embedded software. This action may be performed based upon the input from a user to select particular sequences of functions. In an alternate embodiment this action may be performed automatically by the system to select one or more possible sequences based upon analysis of software code based upon past activities or selections of the user or based upon heuristics derived from past verification testing or other analysis factors. A software sequence environment is defined for the sequence items which allows the creation of stimulus sequences that call the software methods and accesses the software variables. For example the software sequence items could include a sequence of e language methods that are called in order to provide a sequenced set of stimulus to the embedded software program.

Execution and coverage analysis is performed at . This action is performed to run the test sequence against the software in the virtual machine. The test sequences may be generated with random data which is inserted into the designated locations in the memory of the virtual machine. Coverage data may be collected from the virtual machine to determine whether the coverage of the test data is adequate. Controlled starts and stops are performed at the virtual machine to provide deterministic observation and testing of the software at the virtual machine.

The goal of a coverage driven verification process to provide stimulus that gives adequate complete coverage of the possible defect space for software under test. According to some embodiments of the invention coverage information can be used for example to configure and tune the type range and values of stimulus for verifying the software. To accomplish this identification is made of the objects for which it is desired to configure the coverage information or parameters. For example this action can be used to identify method or method ports for which it is desired to configure coverage. One or more coverage items may be specified which identifies the specific items for which it is desired to have coverage upon. For example the value of specific variables may be defined as items for which it is desired to impose coverage upon. One or more coverage events may also be specified which provides an event or temporal basis for checking coverage. For example assume that it is desired to check the value of a particular variable at a given point in time. A coverage event may be configured to check that variable value at the designated point in time. One or more coverage groups may also be defined for the identified item where the coverage group is an approach for imposing a grouping upon a set of coverage items. In an embodiment the coverage group and event are defined to contain as many items as coverable port parameters. Additional coverage may be specified for the identified method. For example a range of values can be defined for a method port. The specified range of values would be used to generate stimulus for the verification of the embedded software.

At regression analysis is performed to check the test results. This action involves gathering any errors that occurred and coverage results across many runs with different random seeds and different tests. Since full testing involves many runs if there are any errors then the engineer can go back and use the same test and the execution with the virtual machine can be exactly repeated to debug the errors. This highlights an advantage of the invention since without the present invention there does not exist an effective way to repeat the errors and debug them.

An example of the invention will now be illustratively described for the verification of an operating system device driver. The task of programmatically creating a new device driver is normally considered a very difficult and complex project. There are many reasons for this. One reason is because a typical operating system uses many different device drivers with many of the device drivers performing operations that may conflict with one another. Another reason is that concurrency and race conditions are common particularly with multi processing machines becoming more and more common.

Combined with the high level of difficulty inherent in device driver programming is the severe lack of available tools that can adequately test such device drivers. For example until the present invention deterministic testing and test observation was not available to the device driver programmer. To test the device driver the programmer would write a program that would test the device driver e.g. a test program that calls the driver using system calls. The problem with this approach is that the test program would run on the same system as the device driver creating an inherently unreliable test situation since the test program itself could have loading effects on the system that it is testing. Another approach is to run the device driver in a system context and see if it will work for its intended purpose. This approach is problematic because of the lack of deterministic behavior and lack of an ability to isolate specific causes of failures and problems. This may also involve manual steps such as a human to remove and insert the USB memory stick. Debug outputs can be obtained that take raw dumps of system memory or traces can be performed on the system. However these approaches again have intrusive effects on the system and are very complex to perform and often with very unintelligible data that must be analyzed.

Moreover the act of testing the device driver is not just related to testing of the software by itself like other types of programming but also requires the involvement of the underlying hardware as well to be present of the testing. In many cases the hardware is not even available to the device driver programmer e.g. because the hardware is still under development it is expensive or is just simply not available because of scarcity or high demand.

Device drivers are specific to an operating system and normally cannot be reused between different operating systems. Therefore the device driver may need to be re written and or recompiled to port the device driver and hardware to a new operating system.

The device driver essentially executes as part of the operating system in the kernel space . Therefore the device driver must understand details of hardware operation and interface to operating system. In operation system calls are performed by the application to the kernel in the operating system. This causes data transfers to occur between the processes threads in the user space and the device driver in the kernel space .

According to one embodiment of the invention a verification tool is used to call the device driver to perform hardware operations where the device driver is running on a virtual machine. Stimulus checking and coverage for the test program are generated and supplied with the verification tool. The test stimulus is generated outside of the virtual machine e.g. using a command or sequence for the device driver to carry out. When the stimulus is ready it will be sent to the virtual machine. According to some embodiments the stimulus generation program can be running on the same physical machine as the virtual machine.

The virtual machine will receive the stimulus stop the virtual machine execution use a backdoor call in the virtual machine to deposit the stimulus command into virtual machine memory and then restart the virtual machine. The device driver test program will see the new stimulus when the virtual machine is restarted and apply it to the device driver.

The invention can illustratively be applied to test a USB universal serial bus storage driver intended to run on the Linux operating system. illustrates a diagram of the stack of components that are used to implement a USB device driver in the Linux environment. The Linux kernel functions as the main operating system program. Various user applications may run in and above the Linux kernel . A systems call interface interfaces between the user applications and accesses made to the Linux kernel .

A USB hardware device interfaces with a USB controller mechanism . A USB host controller driver acts to control the operation of the USB controller mechanism . The USB core provides the main programmatic functionality for the USB host controller driver . The USB storage driver is the operating system component that interacts with and controls the USB core .

Coverage driven verification is performed using a verification tool such as the ISX tool. The verification is driven with a set of one or more verification tests e.g. test that are created using the e verification language. A verification planning tool may be used to create a verification plan to guide the process of generating the verification tests using the verification tool . Any suitable verification planning tool may be employed within the scope of the invention such as the Enterprise Manager eManager verification planning and management product available from Cadence Design Systems Inc. of San Jose Calif.

Verification is performed based upon an application on the target machine that exercises the USB device driver. For example functionality that may be exercised include mount open close read and write functionality for the USB device. The block and file system interfaces may also be exercised by the verification. In some embodiments multiple instances may be employed to provide additional testing stress upon the device driver.

The tests are inserted into the portions of the memory for the virtual machine corresponding to the device driver being verified. In addition the tests are used to modify the state of the emulated USB host controller so that the emulation of the USB device under test realistically responds to any provided stimulus or changes in system conditions. The API is employed to control the virtual machine e.g. for performing a controlled stop to insert the data into the memory and for performing a controlled start to restart the virtual machine processing. The virtual network interface is also employed to access the memory for the virtual machine where memory access is to obtain the state of the system and software that is running on the virtual machine . This information can be analyzed to determine whether the device driver is operating correctly.

The external nature of the test stimuli allows for more accurate testing that is not subject to interference based upon test itself. Instead any timing errors that otherwise would occur while operating the device driver would still occur when running the external test stimuli without fear that the testing itself would change the timing behavior and cause different or inconsistent results. Instead the testing occurs in a deterministic way that allows the software engineer to maintain observability and repeatability of the software being tested.

Therefore this technique eliminates the problems associated with either generating the stimulus commands inside the virtual machine or sending them from outside the virtual machine to the test program over a networking socket. In both cases the control of when the device driver will receive the stimulus commands cannot be maintained and different results may occur due to timing differences due to other factors in operating system running in the virtual machine such as another program consuming some of the CPU time.

This invention can be applied to many areas of software verification both for stimulus generation such as in calling a software API or in passively collecting coverage information about software execution for the purpose of measuring functional coverage or for performance profiling.

According to one embodiment of the invention computer system performs specific operations by processor executing one or more sequences of one or more instructions contained in system memory . Such instructions may be read into system memory from another computer readable usable medium such as static storage device or disk drive . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and or software. In one embodiment the term logic shall mean any combination of software or hardware that is used to implement all or part of the invention.

The term computer readable medium or computer usable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as disk drive . Volatile media includes dynamic memory such as system memory .

Common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

In an embodiment of the invention execution of the sequences of instructions to practice the invention is performed by a single computer system . According to other embodiments of the invention two or more computer systems coupled by communication link e.g. LAN PTSN or wireless network may perform the sequence of instructions required to practice the invention in coordination with one another.

Computer system may transmit and receive messages data and instructions including program i.e. application code through communication link and communication interface . Received program code may be executed by processor as it is received and or stored in disk drive or other non volatile storage for later execution.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example the above described process flows are described with reference to a particular ordering of process actions. However the ordering of many of the described process actions may be changed without affecting the scope or operation of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

