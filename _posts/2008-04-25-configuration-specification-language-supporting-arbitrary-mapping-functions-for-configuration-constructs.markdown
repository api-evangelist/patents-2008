---

title: Configuration specification language supporting arbitrary mapping functions for configuration constructs
abstract: A method is disclosed of associating a mapping function with a configuration construct of a digital design defined by one or more hardware description language (HDL) files. According to the method, in the HDL files, a configuration latch is specified within a design entity forming at least a portion of the digital design. In addition, a Dial is specified that defines a relationship between each of a plurality of input values and a respective one of a plurality of different output values. The HDL files also include a statement that instantiates an instance of the Dial in association with the configuration latch such that a one-to-one correspondence exists between a value contained within the configuration latch and an input value of the instance of the Dial. The HDL files further include a statement associating the Dial with a mapping function that applies a selected transformation to values read from or written to the instance of the Dial.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895558&OS=07895558&RS=07895558
owner: International Machines Corporation
number: 07895558
owner_city: Armonk
owner_country: US
publication_date: 20080425
---
The present application is a continuation of U.S. patent application Ser. No. 11 408 583 now U.S. Pat. No. 7 392 501 filed on Apr. 21 2006 entitled Method System and Program Product Providing a Configuration Specification Language Supporting Arbitrary Mapping Functions for Configuration Constructs which is a divisional of U.S. patent application Ser. No. 10 749 759 now U.S. Pat. No. 7 096 434 filed on Dec. 31 2003. Applicants hereby claim benefit of priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 10 749 759 which is incorporated by reference herein in its entirety and for all purposes.

The present invention relates in general to designing simulating and configuring digital devices modules and systems and in particular to methods and systems for computer aided design simulation and configuration of digital devices modules and systems described by a hardware description language HDL model.

In a typical digital design process verifying the logical correctness of a digital design and debugging the design if necessary are important steps of the design process performed prior to developing a circuit layout. Although it is certainly possible to test a digital design by actually building the digital design digital designs particularly those implemented by integrated circuitry are typically verified and debugged by simulating the digital design on a computer due in part to the time and expense required for integrated circuit fabrication.

In a typical automated design process a circuit designer enters into an electronic computer aided design ECAD system a high level description of the digital design to be simulated utilizing a hardware description language HDL such as VHDL thus producing a digital representation of the various circuit blocks and their interconnections. In the digital representation the overall circuit design is frequently divided into smaller parts hereinafter referred to as design entities which are individually designed often by different designers and then combined in a hierarchical manner to create an overall model. This hierarchical design technique is very useful in managing the enormous complexity of the overall design and facilitates error detection during simulation.

The ECAD system compiles the digital representation of the design into a simulation model having a format best suited for simulation. A simulator then exercises the simulation model to detect logical errors in the digital design.

A simulator is typically a software tool that operates on the simulation model by applying a list of input stimuli representing inputs of the digital system. The simulator generates a numerical representation of the response of the circuit to the input stimuli which response may then either be viewed on the display screen as a list of values or further interpreted often by a separate software program and presented on the display screen in graphical form. The simulator may be run either on a general purpose computer or on another piece of electronic apparatus specially designed for simulation. Simulators that run entirely in software on a general purpose computer are referred to as software simulators and simulators that run with the assistance of specially designed electronic apparatus are referred to as hardware simulators. 

As digital designs have become increasingly complex digital designs are commonly simulated at several levels of abstraction for example at functional logical and circuit levels. At the functional level system operation is described in terms of a sequence of transactions between registers adders memories and other functional units. Simulation at the functional level is utilized to verify the high level design of digital systems. At the logical level a digital system is described in terms of logic elements such as logic gates and flip flops. Simulation at the logical level is utilized to verify the correctness of the logic design. At the circuit level each logic gate is described in terms of its circuit components such as transistors impedances capacitances and other such devices. Simulation at the circuit level provides detailed information about voltage levels and switching speeds.

In order to verify the results of any given simulation run custom developed programs written in high level languages such as C or C referred to as a reference model are written to process input stimuli also referred to as test vectors to produce expected results of the simulation run. The test vector is then run against the simulation execution model by the simulator. The results of the simulation run are then compared to the results predicted by the reference model to detect discrepancies which are flagged as errors. Such a simulation check is known in the verification art as an end to end check.

In modern data processing systems especially large server class computer systems the number of latches that must be loaded to configure the system for operation or simulation is increasing dramatically. One reason for the increase in configuration latches is that many chips are being designed to support multiple different configurations and operating modes in order to improve manufacturer profit margins and simplify system design. For example memory controllers commonly require substantial configuration information to properly interface memory cards of different types sizes and operating frequencies.

A second reason for the increase in configuration latches is the ever increasing transistor budget within processors and other integrated circuit chips. Often the additional transistors available within the next generation of chips are devoted to replicated copies of existing functional units in order to improve fault tolerance and parallelism. However because transmission latency via intra chip wiring is not decreasing proportionally to the increase in the operating frequency of functional logic it is generally viewed as undesirable to centralize configuration latches for all similar functional units. Consequently even though all instances of a replicated functional unit are frequently identically configured each instance tends to be designed with its own copy of the configuration latches. Thus configuring an operating parameter having only a few valid values e.g. the ratio between the bus clock frequency and processor clock frequency may involve setting hundreds of configuration latches in a processor chip.

Conventionally configuration latches and their permitted range of values have been specified by error prone paper documentation that is tedious to create and maintain. Compounding the difficulty in maintaining accurate configuration documentation and the effort required to set configuration latches is the fact that different constituencies within a single company e.g. a functional simulation team a laboratory debug team and one or more customer firmware teams often separately develop configuration software from the configuration documentation. As the configuration software is separately developed by each constituency each team may introduce its own errors and employ its own terminology and naming conventions. Consequently the configuration software developed by the different teams is not compatible and cannot easily be shared between the different teams.

In addition to the foregoing shortcomings in the process of developing configuration code conventional configuration software is extremely tedious to code. In particular the vocabulary used to document the various configuration bits is often quite cumbersome. For example in at least some implementations configuration code must specify for each configuration latch bit a full latch name which may include fifty or more ASCII characters. In addition valid binary bit patterns for each group of configuration latches must be individually specified.

In view of the foregoing the above referenced co pending patent application introduces a configuration specification language that permits configuration information for a digital system described by an HDL model to be specified in a logical manner with a reasonable amount of input and then shared among the various organizational constituencies involved in the design simulation and commercial implementation of the digital system. This configuration specification language provides a configuration construct referred to as a Dial that permits configuration latch values to be easily specified and accessed as well as other configuration constructs that allow a designer to define various relationships between Dials. As described further herein a Dial s function is to map between an input value and one or more output values. In general the Dial output values ultimately directly or indirectly reflect configuration values of configuration latches within the digital design.

The present invention recognizes that for at least some Dials the specific implementation of the underlying configuration latches in the digital design do not identically correspond to the configuration values to be loaded into the configuration latches. For example the configuration value may be unaligned with respect to the underlying configuration latch. In addition the present invention recognizes that it may be desirable to apply a known transform to the configuration value before setting or reading the configuration value. Accordingly the present invention supports the definition of arbitrary mapping functions and the association of such mapping functions with particular Dials.

Methods data processing systems and program products are disclosed that support the definition of arbitrary mapping functions and the association of such mapping functions with configuration constructs of a digital design defined by one or more hardware description language HDL files. According to one method in the HDL files a configuration latch is specified within a design entity forming at least a portion of the digital design. In addition a Dial is specified that defines a relationship between each of a plurality of input values and a respective one of a plurality of different output values. The HDL files also include a statement that instantiates an instance of the Dial in association with the configuration latch such that a one to one correspondence exists between a value contained within the configuration latch and an input value of the instance of the Dial. The HDL files further include a statement associating the Dial with a mapping function that applies a selected transformation to values read from or written to the instance of the Dial.

All objects features and advantages of the present invention will become apparent in the following detailed written description.

The present invention discloses a configuration specification language and associated methods systems and program products for configuring and controlling the setup of a digital system e.g. one or more integrated circuits or a simulation model thereof . In at least one embodiment configuration specifications for signals in the digital system are created in HDL code by the designer responsible for an associated design entity. Thus designers at the front end of the design process who are best able to specify the signal names and associated legal values are responsible for creating the configuration specification. The configuration specification is compiled at model build time together with the HDL describing the digital system to obtain a configuration database that can then be utilized by downstream organizational groups involved in the design simulation and hardware implementation processes.

With reference now to the FIGS. and in particular with reference to there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized for example as a workstation server or mainframe computer.

As illustrated data processing system includes one or more processing nodes which if more than one processing node is implemented are interconnected by node interconnect . Processing nodes may each include one or more processors a local interconnect and a system memory that is accessed via a memory controller . Processors are preferably but not necessarily identical and may comprise a processor within the PowerPC line of processors available from International Business Machines IBM Corporation of Armonk N.Y. In addition to the registers instruction flow logic and execution units utilized to execute program instructions which are generally designated as processor core each of processors also includes an on chip cache hierarchy that is utilized to stage data to the associated processor core from system memories .

Each of processing nodes further includes a respective node controller coupled between local interconnect and node interconnect . Each node controller serves as a local agent for remote processing nodes by performing at least two functions. First each node controller snoops the associated local interconnect and facilitates the transmission of local communication transactions to remote processing nodes . Second each node controller snoops communication transactions on node interconnect and masters relevant communication transactions on the associated local interconnect . Communication on each local interconnect is controlled by an arbiter . Arbiters regulate access to local interconnects based on bus request signals generated by processors and compile coherency responses for snooped communication transactions on local interconnects .

Local interconnect is coupled via mezzanine bus bridge to a mezzanine bus . Mezzanine bus bridge provides both a low latency path through which processors may directly access devices among I O devices and storage devices that are mapped to bus memory and or I O address spaces and a high bandwidth path through which I O devices and storage devices may access system memory . I O devices may include for example a display device a keyboard a graphical pointer and serial and parallel ports for connection to external networks or attached devices. Storage devices may include for example optical or magnetic disks that provide non volatile storage for operating system middleware and application software. In the present embodiment such application software includes an ECAD system which can be utilized to develop verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.

Simulated digital circuit design models created utilizing ECAD system are comprised of at least one and usually many sub units referred to hereinafter as design entities. Referring now to there is illustrated a block diagram representation of an exemplary design entity which may be created utilizing ECAD system . Design entity is defined by a number of components an entity name entity ports and a representation of the function performed by design entity . Each design entity within a given model has a unique entity name not explicitly shown in that is declared in the HDL description of the design entity. Furthermore each design entity typically contains a number of signal interconnections known as ports to signals outside the design entity. These outside signals may be primary input outputs I Os of an overall design or signals connected to other design entities within an overall design.

Typically ports are categorized as belonging to one of three distinct types input ports output ports and bi directional ports. Design entity is depicted as having a number of input ports that convey signals into design entity . Input ports are connected to input signals . In addition design entity includes a number of output ports that convey signals out of design entity . Output ports are connected to a set of output signals . Bi directional ports are utilized to convey signals into and out of design entity . Bi directional ports are in turn connected to a set of bi directional signals . A design entity such as design entity need not contain ports of all three types and in the degenerate case contains no ports at all. To accomplish the connection of entity ports to external signals a mapping technique known as a port map is utilized. A port map not explicitly depicted in consists of a specified correspondence between entity port names and external signals to which the entity is connected. When building a simulation model ECAD software is utilized to connect external signals to appropriate ports of the entity according to a port map specification.

As further illustrated in design entity contains a body section that describes one or more functions performed by design entity . In the case of a digital design body section contains an interconnection of logic gates storage elements etc. in addition to instantiations of other entities. By instantiating an entity within another entity a hierarchical description of an overall design is achieved. For example a microprocessor may contain multiple instances of an identical functional unit. As such the microprocessor itself will often be modeled as a single entity. Within the microprocessor entity multiple instantiations of any duplicated functional entities will be present.

Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.

With reference now to there is illustrated a diagrammatic representation of an exemplary simulation model that may be employed by ECAD system to represent a digital design e.g. an integrated circuit chip or a computer system in a preferred embodiment of the present invention. For visual simplicity and clarity the ports and signals interconnecting the design entities within simulation model have not been explicitly shown.

Simulation model includes a number of hierarchically arranged design entities. As within any simulation model simulation model includes one and only one top level entity encompassing all other entities within simulation model . That is to say top level entity instantiates either directly or indirectly all descendant entities within the digital design. Specifically top level entity directly instantiates i.e. is the direct ancestor of two instances and of the same FiXed point execution Unit FXU entity and a single instance of a Floating Point Unit FPU entity . FXU entity instances having instantiation names FXU and FXU respectively in turn instantiate additional design entities including multiple instantiations of entity A having instantiation names A and A respectively.

Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name which must be unique among all descendants of the direct ancestor entity if any. For example top level entity has a description including an entity name i.e. the TOP preceding the colon and also includes an instantiation name i.e. the TOP following the colon . Within an entity description it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example single instances of entity B and entity C instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However this naming convention is not required by the present invention as shown by FPU entity i.e. the instantiation name is FPU while the entity name is FPU .

The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity provided that all entities instantiated whether singly or multiply have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.

Associated with each design entity instantiation is a so called instantiation identifier . The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top level entity instantiation name. For example the design instantiation identifier of instantiation of entity C within instantiation of FXU entity is TOP.FXU.B.C . This instantiation identifier serves to uniquely identify each instantiation within a simulation model.

As discussed above a digital design whether realized utilizing physical integrated circuitry or as a software model such as simulation model typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies which employ stand alone configuration software created after a design is realized to load values into the configuration latches the present invention introduces a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design as illustrated in or in one or more external configuration files referenced by the one or more HDL files specifying the digital design as depicted in .

Referring now to there is depicted an exemplary HDL file in this case a VHDL file including embedded configuration statements in accordance with the present invention. In this example HDL file specifies entity A of simulation model and includes three sections of VHDL code namely a port list that specifies ports and signal declarations that specify the signals within body section and a design specification that specifies the logic and functionality of body section . Interspersed within these sections are conventional VHDL comments denoted by an initial double dash . In addition embedded within design specification are one or more configuration specification statements in accordance with the present invention which are collectively denoted by reference numerals and . As shown these configuration specification statements are written in a special comment form beginning with in order to permit a compiler to easily distinguish the configuration specification statements from the conventional HDL code and HDL comments. Configuration specification statements preferably employ a syntax that is insensitive to case and white space.

With reference now to there is illustrated an exemplary HDL file that includes a reference to an external configuration file containing one or more configuration specification statements in accordance with the present invention. As indicated by prime notation HDL file is identical to HDL file in all respects except that configuration specification statements are replaced with one or more and in this case only one configuration file reference statement referencing a separate configuration file containing configuration specification statements .

Configuration file reference statement like the embedded configuration specification statements illustrated in is identified as a configuration statement by the identifier . Configuration file reference statement includes the directive cfg file which instructs the compiler to locate a separate configuration file and the filename of the configuration file i.e. file00 . Configuration files such as configuration file preferably all employ a selected filename extension e.g. .cfg so that they can be easily located organized and managed within the file system employed by data processing system .

As discussed further below with reference to configuration specification statements whether embedded within an HDL file or collected in one or more configuration files are processed by a compiler together with the associated HDL files.

In accordance with a preferred embodiment of the present invention configuration specification statements such as configuration specification statements facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a Dial. A Dial s function is to map between an input value and one or more output values. In general such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently by virtue of their association with particular design entities which all have unique instantiation identifiers Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent many different types of Dials can be defined beginning with a Latch Dial or LDial .

Referring now to there is depicted a representation of an exemplary LDial . In this particular example LDial which has the name bus ratio is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.

As illustrated LDial like all Dials logically has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . That is mapping table specifies a one to one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches each output of LDial logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations each configuration latch is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .

At input LDial receives an enumerated input value i.e. a string among a set of legal values including 2 1 3 1 and 4 1 . The enumerated input value can be provided directly by software e.g. by a software simulator or service processor firmware or can be provided by the output of another Dial as discussed further below with respect to . For each enumerated input value the mapping table of LDial indicates a selected binary value i.e. 0 or 1 for each configuration latch .

With reference now to there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model of which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model of illustrates two properties of Dials namely replication and scope.

Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example in order to instantiate the six instances of LDials illustrated in the designer need only code two LDial configuration specification statements utilizing either of the two techniques illustrated in . That is the designer codes a first LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity A in order to automatically instantiate LDials and within entity A instantiations and respectively. The designer codes a second LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity FXU in order to automatically instantiate LDials and within FXU entity instantiations and respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values different instances of the same Dial can be set to generate different outputs by providing them different inputs.

The scope of a Dial is defined herein as the set of entities to which the Dial can refer in its specification. By convention the scope of a Dial comprises the design entity with which the Dial is associated i.e. the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated and any design entity contained within the associated design entity i.e. the associated design entity and its descendents . Thus a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated but can also specify configuration latches at any lower level of the design hierarchy within its scope. For example LDials and even though associated with FXU entity instantiations and respectively can specify configuration latches within entity C instantiations and respectively.

Referring now to there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of .

As shown simulation model of includes an LDial associated with top level design entity . LDial specifies the signal states of each signal sig which is determined by a respective configuration latch the signal states of each signal sig which is determined by a respective configuration latch the signal state of signal sig which is determined by configuration latch and the signal state of signal sig which is determined by configuration latch . Thus LDial configures the signal states of numerous different signals which are all instantiated at or below the hierarchy level of LDial which is the top level .

As discussed above with respect to LDial is instantiated within top level entity of simulation model by embedding within the HDL file of top level entity a configuration specification statement specifying LDial or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case an exemplary configuration specification statement for LDial is as follows 

The exemplary configuration specification statement given above begins with the keyword LDial which specifies that the type of Dial being declared is an LDial and the Dial name which in this case is bus ratio. Next the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above the signal identifier for each signal is specified hierarchically e.g. FXU.A.SIG for signal relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Several different syntaxes can be employed to specify the signal states. In the example given above signal states are specified in either binary format which specifies a binary constant preceded by the prefix 0b or in hexadecimal format which specifies a hexadecimal constant preceded by the prefix 0x . Although not shown signal states can also be specified in integer format in which case no prefix is employed. For ease of data entry the configuration specification language of ECAD system also preferably supports a concatenated syntax in which one constant value which is automatically extended with leading zeros is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax the mapping table of the configuration specification statement given above can be rewritten as 

With reference now to there is illustrated a diagrammatic representation of a special case of an LDial having a one bit output which is defined herein as a Switch. As shown a Switch has a single input a single 1 bit output that controls the setting of a configuration latch and a mapping table that maps each enumerated input value that may be received at input to a 1 bit output value driven on output .

Because Switches frequently comprise a significant majority of the Dials employed in a digital design it is preferable if the enumerated value sets for all Switches in a simulation model of a digital design are the same e.g. ON OFF . In a typical embodiment of a Switch the positive enumerated input value e.g. ON is mapped by mapping table to an output value of 0b1 and the negative enumerated input value e.g. OFF is mapped to an output value of 0b0. In order to facilitate use of logic of the opposite polarity a Negative Switch or NSwitch declaration is also preferably supported that reverses this default correspondence between input values and output values in mapping table .

The central advantage to defining a Switch primitive is a reduction in the amount of input that designers are required to enter. In particular to specify a comparable 1 bit LDial a designer would be required to enter a configuration specification statement of the form 

Referring now to there is depicted a diagrammatic representation of an Integer Dial IDial in accordance with a preferred embodiment of the present invention. Like an LDial an IDial directly specifies the value loaded into each of one or more configuration latches by indicating within mapping table a correspondence between each input value received at an input and an output value for each output . However unlike LDials which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables the legal input value set of an IDial includes all possible integer values within the bit size of output . Input integer values containing fewer bits than the bit size of output s are right justified and extended with zeros to fill all available bits. Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table mapping table simply indicates the manner in which the integer input value received at input is applied to the one or more outputs .

IDials are ideally suited for applications in which one or more multi bit registers must be initialized and the number of legal values includes most values of the register s . For example if a 4 bit configuration register comprising 4 configuration latches and an 11 bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial the designer would have to explicitly enumerate up to 2input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement 

IDials may also be utilized to specify the same value for multiple replicated configuration registers as depicted in . In the illustrated embodiment an IDial which can be described as an IDial splitter specifies the configuration of three sets of replicated configuration registers each comprising 15 configuration latches based upon a single 15 bit integer input value. An exemplary configuration specification statement for instantiating IDial may be given as follows 

Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials in many cases it would be inefficient and inconvenient to do so. In particular for hierarchical digital designs such as that illustrated in the use of LDials and or IDials alone would force many Dials to higher levels of the design hierarchy which from an organizational standpoint may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result proper configuration of the configuration latches would require not only significant organizational coordination between design groups but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.

In view of the foregoing the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower level Dials and control of the lower level Dials by one or more higher level Dials. The configuration specification language of the present invention terms a higher level Dial that controls one or more lower level Dials as a Control Dial CDial .

Referring now to there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial like all Dials preferably has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . Unlike LDials and IDials which directly specify configuration latches a CDial does not directly specify configuration latches. Instead a CDial controls one or more other Dials i.e. CDials and or LDials and or IDials logically coupled to CDial in an n way Dial tree in which each lower level Dial forms at least a portion of a branch that ultimately terminates in leaves of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.

In the exemplary embodiment given in CDial receives at input an enumerated input value i.e. a string among a set of legal values including A . . . N . If CDial or an LDial or IDial is a top level Dial i.e. there are no Dials above it in a Dial tree CDial receives the enumerated input value directly from software e.g. simulation software or firmware . Alternatively if CDial forms part of a branch of a dial tree then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input CDial specifies a selected enumerated value or bit value for each connected Dial e.g. Dials and in mapping table . The values in mapping table associated with each output are interpreted by ECAD system in accordance with the type of lower level Dial coupled to the output . That is values specified for LDials and CDials are interpreted as enumerated values while values specified for IDials are interpreted as integer values. With these values each of Dials and ultimately specifies either directly or indirectly the values for one or more configuration latches .

With reference now to there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top level CDial that controls multiple lower level LDials. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of and contains the same configuration latches and associated signals as simulation model of .

As shown simulation model of includes a top level CDial associated with top level design entity . Simulation model further includes four LDials and . LDial which is associated with entity instantiation A controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is a replication of LDial associated with entity instantiation A similarly controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is associated with top level entity controls the signal state of signal sig which is determined by configuration latch . Finally LDial which is associated with entity instantiation FPU controls the signal state of signal sig which is determined by configuration latch . Each of these four LDials is controlled by CDial associated with top level entity .

As discussed above with respect to CDial and each of the four LDials depicted in is instantiated within the associated design entity by embedding a configuration specification statement or a configuration file reference statement pointing to a configuration file containing a configuration specification statement within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in is given below 

By implementing a hierarchical Dial tree in this manner several advantages are realized. First the amount of software code that must be entered is reduced since the automatic replication of LDials within FXU entity instantiations and allows the code specifying LDials to be entered only once. Second the organizational boundaries of the design process are respected by allowing each designer or design team to specify the configuration of signals within the design entity for which he is responsible. Third coding of upper level Dials i.e. CDial is greatly simplified reducing the likelihood of errors. Thus for example the CDial and LDial collection specified immediately above performs the same function as the large LDial specified above with reference to but with much less complexity in any one Dial.

Many Dials for example Switches utilized to disable a particular design entity in the event an uncorrectable error is detected have a particular input value that the Dial should have in nearly all circumstances. For such Dials the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment a Default value is specified by including default value following the specification of a Dial and prior to the concluding semicolon. For example a default value for a CDial can be given as follows 

The use of default values for Dials is subject to a number of rules. First a default value may be specified for any type of Dial including LDials IDials including those with split outputs and CDials. Second if default values are specified for multiple Dials in a multiple level Dial tree only the highest level default value affecting each branch of the Dial tree is applied including that specified for the top level Dial and the remaining default values if any are ignored. Despite this rule it is nevertheless beneficial to specify default values for lower level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated as discussed above. In the event that the combination of default values specified for lower level Dials forming the branches of a Dial tree do not correspond to a legal output value set for a higher level Dial the compiler will flag an error. Third a default value is overridden when a Dial receives an input to actively set the Dial.

By specifying default values for Dials a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition as discussed further below use of default values assists in auditing which Dials have been actively set.

In addition to defining syntax for configuration specification statements specifying Dials the configuration specification language of the present invention supports at least two additional HDL semantic constructs comments and attribute specification statements. A comment which may have the form 

Attribute specification statements are statements that declare an attribute name and attribute value and associate the attribute name with a particular Dial name. For example an attribute specification statement may have the form 

In this example BusRatio.attribute declares that this statement is an attribute specification statement associating an attribute with a Dial having BusRatio as its Dial name myattribute is the name of the attribute and scom57 0 9 is a string that specifies the attribute value. Attributes support custom features and language extensions to the base configuration specification language.

Referring now to there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files which include configuration specification statements and or configuration file reference statements and optionally one or more configuration specification reference files . HDL compiler processes HDL file s and configuration specification file s if any beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file s describing a complete simulation model. As HDL compiler processes each HDL file HDL compiler creates markers in the design intermediate files produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.

Thereafter the design intermediate files in memory are processed by a configuration compiler and model build tool to complete the model build process. Model build tool processes design intermediate files into a simulation executable model that when executed models the logical functions of the digital design which may represent for example a portion of an integrated circuit an entire integrated circuit or module or a digital system including multiple integrated circuits or modules. Configuration compiler processes the configuration specification statements marked in design intermediate files and creates from those statements a configuration documentation file and a configuration database .

Configuration documentation file lists in human readable format information describing the Dials associated with the simulation model. The information includes the Dials names their mapping tables the structure of Dial trees if any instance information etc. In addition as noted above configuration documentation file includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a bottom up fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design simulation laboratory hardware evaluation and commercial hardware implementation of the digital design.

Configuration database contains a number of data structures pertaining to Dials. As described in detail below these data structures include Dial data structures describing Dial entities latch data structures and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design i.e. simulation executable model . In a preferred embodiment the configuration values can be specified in terms of either signal states or configuration latch values and the selection of which values are used is user selectable. Configuration database is accessed via Application Programming Interface API routines during simulation of the digital design utilizing simulation executable model and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment the APIs are designed so that only top level Dials i.e. LDials IDials or CDials without a CDial logically above them can be set and all Dial values can be read.

As described above the configuration specification language of the present invention advantageously permits the specification of the output values of LDials and IDials by reference to signal names e.g. sig . As noted above a key motivation for this feature is that designers tend to think in terms of configuring operative signals to particular signal states rather than configuring the associated configuration latches. In practice however a signal that a designer desires to configure to a particular state may not be directly connected to the output of an associated configuration latch. Instead a signal to be configured may be coupled to an associated configuration latch through one or more intermediate circuit elements such as buffers and inverters. Rather than burdening the designer with manually tracing back each configurable signal to an associated configuration latch and then determining an appropriate value for the configuration latch configuration compiler automatically traces back a specified signal to the first storage element i.e. configuration latch coupled to the signal and performs any necessary inversions of the designer specified signal state value to obtain the proper value to load into the configuration latch.

With reference now to there is illustrated a portion of a digital design including an LDial that controls the states of a plurality of signals within the digital design. When configuration compiler performs a traceback of signal no inversion of the designer specified signal states is required because signal is directly connected to configuration latch . Accordingly configuration compiler stores into configuration database the designer specified values from the configuration specification statement of LDial as the values to be loaded into configuration latch . Traceback of signal to configuration latch similarly does not result in the inversion of any designer specified values from the configuration specification statement of LDial because the only intervening element between signal and configuration register is a non inverting buffer .

Configuration latches such as configuration latches and are frequently instantiated by designers through inclusion in an HDL file of an HDL statement referencing a latch primitive in an HDL design library. The latch entity inserted into the simulation executable model in response to such HDL library references may include inverters such as inverters which are not explicitly visible to the designer in the HDL code. The automatic traceback performed by configuration compiler nevertheless detects these inverters thus preventing possible configuration errors.

Accordingly when performing a traceback of signal configuration compiler automatically inverts the designer specified configuration value specified for signal before storing the configuration value for configuration latch in configuration database because of the presence of an inverter between signal and configuration latch . When configuration compiler performs traceback of signal however configuration compiler does not invert the designer specified signal state values despite the presence of inverters and buffer in the signal path because the logic is collectively non inverting. It should be noted that configuration compiler can accurately process both hidden inverters like inverter and explicitly declared inverters like inverter .

Referring now to there is depicted a high level logical flowchart of the traceback process implemented by configuration compiler for each signal name specified in a configuration specification statement. As shown the process begins at block and then proceeds to block which illustrate configuration compiler initializing an inversion count to zero and then locating the signal identified by the signal name specified in a configuration specification statement.

The process then enters a loop comprising blocks which collectively represent configuration compiler tracing back the specified signal to the first latch element in the signal path. Specifically as illustrated at blocks configuration compiler determines whether the next upstream circuit element in the signal path is a latch buffer or inverter . If the circuit element is a latch the process exits the loop and passes to block which is described below. If however the circuit element is a buffer the process passes to block which illustrates configuration compiler moving to the next upstream circuit element to be processed without incrementing the inversion count. If the circuit element is an inverter the process passes to blocks and which depicts incrementing the inversion count and then moving to the next upstream circuit element to be processed. In this manner configuration compiler traces back a specified signal to a configuration latch while determining a number of inversions of signal state implemented by the circuit elements in the path. As noted above if configuration compiler detects a circuit element other than a buffer or inverter in the signal path configuration compiler preferably flags an error as shown at block . The process thereafter terminates at block .

Following detection of a configuration latch at block configuration compiler determines whether the inversion count is odd or even. As shown at blocks if the inversion count is odd configuration compiler inverts the designer specified configuration values for the signal at block prior to inserting the values into configuration database . No inversion is performed prior to inserting the configuration values into configuration database if the inversion count is even. The process thereafter terminates at block .

As has been described the present invention provides a configuration specification language that permits a designer of a digital system to specify a configuration for the digital system utilizing configuration statements embedded in the HDL design files describing the digital system. The configuration statements logically instantiate within the digital design one or more Dials which provide configuration values for the digital design in response to particular inputs. The Dials like the design entities comprising the digital design may be hierarchically arranged. The configuration specification statements are compiled together with the HDL files describing the digital design to produce a configuration database that may be accessed to configure a simulation executable model or after appropriate transformations a physical realization of the digital design. The compilation of the configuration specification statements preferably supports a traceback process in which designer specified configuration values for a signal are inverted in response to detection of an odd number of inverters coupled between the signal and an associated configuration latch.

With reference again to recall that an exemplary configuration specification statement for LDial includes a parenthetical signal enumeration of the form 

In order to reduce the amount of input required to input the signal or Dial enumeration sections of configuration specification statements and to reduce the burden of code maintenance as new signal and Dial instances are added to the digital design an ECAD system in accordance with the present invention also supports a compact expression syntax for the signal or Dial enumeration sections of configuration specification statements. This syntax is referred to herein more specifically as compact signal expression when applied to the configuration specification statements of LDials and IDials and is referred to as compact Dial expression when referring to the configuration specification statements of CDials.

In a compact expression of a signal or Dial enumeration all instances of an entity within a selected scope for which a common configuration is desired can be enumerated with a single identifier. For example in if the designer wants a common configuration for all four instantiations of signal sig the designer could enumerate all four instantiations in the configuration specification statement of LDial with the single compact signal expression A .sig where the bracketed term is the name of the entity in which the signal of interest occurs. In compact expressions the default scope of the expression is implied as the scope of the design entity in this case top level entity with which the Dial is associated. The identifier A .sig thus specifies all four instantiations of signal sig within A entity instantiations within the default scope of top level entity .

The scope of the identifier in a compact expression can further be narrowed by explicitly enumerating selected levels of the design hierarchy. For example the compact expression FXU. A .sig refers only to signal sig instantiations and within FXU entity instantiation but does not encompass signal sig instantiations and within FXU entity instantiation

Of course when only a single instance of a signal or Dial is instantiated at higher levels of the design hierarchy the compact expression and the full expression will require approximately the same amount of input e.g. FPU.sig versus FPU .sig to identify signal sig . However it should be noted that if another FPU entity were later added to simulation model the compact expression of the identification would advantageously apply to any later added FPU entities within the scope of top level entity .

Utilizing compact expression the configuration specification statement for LDial can now be rewritten more compactly as follows 

Compact Dial expressions are constructed and parsed by the compiler in the same manner as compact signal expressions. For example the configuration specification statement for CDial of can be rewritten utilizing compact Dial expression as follows 

Referring now to there is depicted a high level logical flowchart of an exemplary method by which configuration compiler parses each signal or Dial identification within a configuration specification statement in accordance with the present invention. As described above each signal or Dial identification is constructed hierarchically from one or more fields separated by periods . . The last field specifies an instance name of a signal e.g. sig or Dial e.g. Bus Ratio and the preceding fields narrow the scope from the default scope which by convention is the scope of the design entity with which the Dial is associated.

As shown the process begins at block and then proceeds to block which illustrates configuration compiler determining whether the first or current field of the signal or Dial identification contains an entity identifier enclosed in brackets e.g. A that is whether the identification is a compact expression. If so the process passes to block which is described below. If not configuration compiler determines at block whether the identification is a full expression by determining whether the first or current field of the identification is the last field of the identification. If so the signal or Dial identification is a full expression and the process passes to block . If on the other hand the current field of the identification is not the last field configuration compiler narrows a current scope to the design entity instantiation identified in the current field of the identification as depicted at block . For example if configuration compiler were processing the identification FPU.SIG within the configuration specification statement of CDial of configuration compiler would narrow the scope from the default scope of top entity to FPU entity instantiation . If the entity instantiation indicated by the current field of the identification exists as shown at block the process returns to block after updating the current field to be the next field as shown at block . If however the entity instantiation specified by the current field does not exist within the current scope configuration compiler flags an error at block and terminates processing of the signal or Dial identification.

Referring again to block when configuration compiler detects that it has reached the last field of a full expression the process shown in passes from block to block . Block illustrates configuration compiler attempting to locate within the current scope the single signal or Dial instance having a name matching that specified in the last field of the signal or Dial identification. If configuration compiler determines at block that no matching instance is found within the current scope the process passes to block and configuration compiler flags an error. However if configuration compiler locates the matching signal or Dial instance then configuration compiler makes an entry in configuration database binding the signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed as shown at block . Thereafter processing of the signal or Dial identification terminates at block .

With reference now to block and following blocks the processing of a signal or Dial identification employing compact expression will now be described. Block depicts configuration compiler attempting to locate within each of one or more instances in the current scope of the entity indicated by the bracketed field each Dial or signal instance matching that specified in the signal or Dial identification. For example when processing the compact expression FXU. A .sig for simulation model of configuration compiler upon reaching the field A searches FXU for instantiations of entity A and upon finding entity instantiations and searches within each of these two entity instantiations to locate signals instantiations sig and . If configuration compiler determines at block that no matching signal or Dial instance is found within the current scope the process passes to block which depicts configuration compiler terminating processing of the signal or Dial identification after flagging an error. However if configuration compiler locates one or more matching signal or Dial instances then the process passes from block to block . Block illustrates configuration compiler making one or more entries in configuration database binding each matching signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed. Thereafter processing of the signal or Dial identification terminates at block .

Utilizing the compact expressions supported by the present invention the amount of code a designer must enter in a configuration specification statement can be advantageously reduced. The use of compact expressions not only reduces input requirements and the likelihood of input errors but also simplifies code maintenance through the automatic application of specified configuration parameters to later entered instances of signals and Dials falling within a selected scope.

As described above every Dial has a one to one mapping between each of its input values and a unique output value of the Dial. In other words each input value has a unique output value different than the output value for any other input value. For CDials and LDials the mapping table must explicitly enumerate each legal input value and its associated mapping.

The requirement that the input values must be explicitly enumerated in the mapping table limits the overall complexity of any given LDial or CDial. For example consider the case of an integrated circuit e.g. a memory controller containing 10 to 20 configuration registers each having between 5 and 20 legal values. In many cases these registers have mutual dependencies the value loaded in one register can affect the legal possibilities of one or more of the other registers. Ideally it would be convenient to specify values for all of the registers utilizing a Dial tree controlled by a single CDial. In this manner the configuration of all of the 10 to 20 registers could be controlled as a group.

Unfortunately given the assumptions set forth above the 10 to 20 registers collectively may have over 300 000 legal combinations of values. The specification of a CDial in such a case although theoretically possible is undesirable and practically infeasible. Moreover even if a looping construct could be employed to automate construction of the configuration specification statement of the CDial the configuration specification statement although informing simulation software which input values are legal would not inform users how to set a CDial of this size.

In recognition of the foregoing the configuration specification language of the present invention provides a Dial group construct. A Dial group is a collection of Dials among which the designer desires to create an association. The runtime APIs utilized to provide Dial input values observe this association by preventing the individual Dials within a Dial group from being set individually. In other words all Dials in a Dial group must be set at the same time so that individual Dials are not set independently without concern for the interactions between Dials. Because software enforces an observance of the grouping of the Dials forming a Dial group use of Dial groups also provides a mechanism by which a designer can warn the downstream user community that an unstated set of interdependencies exists between the Dials comprising the Dial group.

With reference now to there is illustrated a diagrammatic representation of a Dial group . A Dial group is defined by a group name e.g. GroupG and a Dial list listing one or more Dials or other Dial groups. Dial groups do not have any inputs or outputs. The Dials listed within Dial list which are all top level Dials may be LDials CDials and or IDials.

One motivation for implementing Dial groups hierarchically is to coordinate configuration of groups of Dials spanning organizational boundaries. For example consider a digital system in which 30 Dials logically belong in a Dial group and 10 of the Dials are contained within a first design entity that is the responsibility of a first designer and 20 of the Dials are contained within a second design entity that is the responsibility of a second designer. Without a hierarchical Dial group a single Dial group explicitly listing all 30 Dials in its Dial list would have to be specified at a higher level of the design hierarchy encompassing both of the first and second design entities. This implementation would be inconvenient in that the designer or design team responsible for the higher level design entity would have to know all of the related Dials in the lower level design entities and specifically identify each of the 30 Dials in the Dial list of the Dial group.

An alternative hierarchical approach would entail creating a first Dial group containing the 10 Dials within the first design entity a second Dial group containing the 20 Dials within the second design entity and a third higher level Dial group that refers to the first and second Dial groups. Importantly the Dial list of the higher level Dial group must only refer to the two lower level Dial groups thus shielding designers responsible for higher levels of the design hierarchy from low level details. In addition code maintenance is reduced since changing which Dials belong to the two lower level Dial groups would not affect the Dial list of the upper level Dial group.

Dial groups are subject to a number of rules. First no Dial or Dial group may be listed in the Dial list of more than one Dial group. Second a Dial group must refer to at least one Dial or other Dial group in its Dial list . Third in its Dial list a Dial group can only refer to Dials or Dial groups within its scope which by convention and like the concept of scope as applied to Dials is that of its associated design entity i.e. the design entity itself and any lower level design entity within the design entity . Fourth each Dial referred to in a Dial list of a Dial group must be a top level Dial.

Referring now to there is depicted an exemplary simulation model illustrating the use of Dial groups. Exemplary simulation model includes a top level design entity having instantiation identifier TOP TOP . Within top level design entity two design entities and are instantiated which have entity names FBC and L respectively. FBC entity instantiation in turn instantiates a Dial instance having Dial name C a Z entity instantiation containing a Dial instance having Dial name B and two instantiations of entity X which are respectively named X0 and X1 . Each entity X instantiation contains two entity Y instantiations each further instantiating a Dial instance having Dial name A . L2 entity instantiation contains a Dial instance having Dial name D and two entity L instantiations each containing a Dial instance having Dial name E .

As shown FBC entity instantiation has an associated Dial group instance having a group name F . As indicated by arrows Dial group instance includes each of Dials instances and within FBC entity instantiation . L2 entity instantiation similarly has an associated Dial group instance that includes each of Dial instances and within L2 entity instantiation . Both of these Dial group instances in turn belong to a higher level Dial group instance having group name H which is associated with top level design entity .

Each Dial group instance is created by including within the HDL file of the associated design entity an appropriate configuration statement. For example exemplary syntax for configuration statements creating Dial groups F G and H are respectively given as follows 

In each configuration statement a Dial group is declared by the keyword GDial which is followed by string e.g. F representing the group name. Within the parenthesis following the group name the Dial list for the Dial group is specified. As indicated in the configuration statement for Dial group H the Dial list for a hierarchical Dial group specifies other Dial groups in the same manner as Dials. It should also be noted that the compact dial expression syntax discussed above can be employed in specifying Dials or Dial groups in the Dial list as indicated in the configuration statements for Dial groups F and G . In addition default values may be applied to a Dial group by specifying a default value for each top level Dial included in the Dial group.

Now that basic types of Dials syntax for their specification and the application and Dial groups have been described a description of an exemplary implementation of configuration database and its use will be provided. To promote understanding of the manner in which particular Dial instantiations or multiple instantiations of a Dial can be accessed in configuration database a nomenclature for Dials within configuration database will be described.

The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity i.e. the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.

Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model e.g. due to replication use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly in a preferred embodiment the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an extended Dial identifier for each Dial within the simulation model.

As an aside it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example conventional VHDL entity naming constructs permit two design entities to share the same entity name entity name. However VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance the entity name is equivalent to the VHDL library name concatenated by a period . to the entity name as declared in the entity declaration. Thus pre pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.

In a preferred embodiment an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields an instantiation identifier field a design entity name and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period . as follows 

In the extended Dial identifier the design entity field contains the entity name of the design entity in which the Dial is instantiated and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers proceeding from the top level entity of the simulation model to the direct ancestor design entity of the given Dial instance with adjacent instance identifiers separated by periods . . Because no design entity can include two Dials of the same name the instantiation identifier is unique for each and every instance of a Dial within the model.

The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier each design entity is in effect given a unique namespace for the Dials associated with that design entity i.e. Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is due to the uniqueness of instantiation identifiers Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However such a naming scheme does not associate Dials with a given design entity. In practice it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.

As noted above use of extended Dial identifiers permits the unique identification of a particular instantiation of a Dial and permits the re use of design entities within any arbitrary model without risk of Dial name collisions. For example referring again to Dial A entity instantiations and can be respectively uniquely identified by the following extended Dial identifiers 

With an understanding of a preferred nomenclature of Dials reference is now made to which is a diagrammatic representation of an exemplary format for a configuration database created by configuration compiler . In this exemplary embodiment configuration database includes at least four different types of data structures Dial definition data structures DDDS Dial instance data structures DIDS latch data structures and top level pointer array . Configuration database may optionally include additional data structures such as Dial pointer array latch pointer array instance pointer array and other data structures depicted in dashed line illustration which may alternatively be constructed in volatile memory when configuration database is loaded as described in the above referenced application. Generating these additional data structures only after configuration database is loaded into volatile memory advantageously promotes a more compact configuration database .

A respective Dial definition data structure DDDS is created within configuration database for each Dial or Dial group in the digital system. Preferably only one DDDS is created in configuration database regardless of the number of instantiations of the Dial or Dial group in the digital system. As discussed below information regarding particular instantiations of a Dial described in a DDDS is specified in separate DIDSs .

As shown each DDDS includes a type field denoting whether DDDS describes a Dial or Dial group and if a Dial the type of Dial. In one embodiment the value set for type field includes G for Dial group I for integer Dial IDial L for latch Dial LDial and C for control Dial CDial . DDDS further includes a name field which specifies the name of the Dial or Dial group described by DDDS . This field preferably contains the design entity name of the Dial or Dial group followed by a period . followed by the name of Dial or Dial group given in the configuration specification statement of the Dial or Dial group . The contents of name field correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.

DDDS also includes a mapping table that contains the mapping from the input of the given Dial to its output s if required. For LDials and CDials mapping table specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output mapping table is an empty data structure and is not used. In the case of an IDial with a split output mapping table specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields. If the configuration specification statement for the Dial has a default specified DDDS indicates the default value in default field if no default is specified default field is NULL or is omitted.

Finally DDDS may include an instance pointer array containing one or more instance pointers pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array facilitates access to multiple instances of a particular Dial or Dial group.

As further illustrated in configuration database contains a DIDS corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS contains a definition field containing a definition pointer pointing to the DDDS of the Dial for which the DIDS describes a particular instance. Definition pointer permits the Dial name Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.

DIDS further includes a parent field that in the case of an IDial CDial or LDial contains a parent pointer pointing to the DIDS of the higher level Dial instance if any having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group parent pointer points to the DIDS of the higher level Dial group if any that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS is a top level Dial and does not belong to any Dial group parent pointer in parent field is a NULL pointer. It should be noted that a Dial can be a top level Dial but still belong to a Dial group. In that case parent pointer is not NULL but rather points to the DIDS of the Dial group containing the top level Dial.

Thus parent fields of the DIDSs in configuration database collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described below the hierarchical information provided by parent fields advantageously enables a determination of the input value of any top level Dial given the configuration values of the configuration latches ultimately controlled by that top level Dial.

Instance name field of DIDS gives the fully qualified instance name of the Dial instance described by DIDS from the top level design entity of the digital design. For Dial instances associated with the top level entity instance name field preferably contains a NULL string.

Finally DIDS includes an output pointer array containing pointers pointing to data structures describing the lower level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically in the case of IDials and LDials output pointers refer to latch data structures corresponding to the configuration latches coupled to the Dial instance. For non split IDials the configuration latch entity referred to by output pointer receives the high order bit of the integer input value and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial output pointers refer to other DIDSs corresponding to the Dial instances controlled by the CDial. For Dial groups output pointers refer to the top level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS .

Configuration database further includes a respective latch data structure for each configuration latch in simulation executable model to which an output of an LDial or IDial is logically coupled. Each latch data structure includes a parent field containing a parent pointer to the DIDS of the LDial or IDial directly controlling the corresponding configuration latch. In addition latch data structure includes a latch name field specifying the hierarchical latch name relative to the entity containing the Dial instantiation identified by parent pointer . For example if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name a.b.c.d.latch latch name field will contain the string d.latch . Prepending contents of an instance name field of the DIDS identified by parent pointer to the contents of a latch name field thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .

Still referring to as noted above configuration database includes top level pointer array and optionally Dial pointer array and latch pointer array . Top level pointer array contains top level pointers that for each top level Dial and each top level Dial group points to an associated DIDS for the top level entity instance. Dial pointer array includes Dial pointers pointing to each DDDS in configuration database to permit indirect access to particular Dial instances through Dial and or entity names. Finally latch pointer array includes latch pointers pointing to each latch data structure within configuration database to permit easy access to all configuration latches.

When employing Dials and Dial Groups to simplify the configuration or control of a data processing system as described herein and in the above referenced patent application there are some cases in which the implementation of the underlying latches does not correspond precisely to the logical values to be placed within the latches. For example linear feedback shift registers LFSRs are often utilized as counters in many systems. LFSRs count in a pseudo random pattern that must be mapped manually to obtain a corresponding integer count value. Another case in which the logical or natural value of a quantity in a digital system may not match the corresponding implementation value is when a register stores an unaligned quantity for example address bits through of a 64 bit address.

In order to permit these types of values to be read and set utilizing the logical or natural values rather than the less intuitive implementation values the present invention provides a mechanism to read and set Dials utilizing the logical or natural values rather than the implementation values. In this manner the designer is insulated from the specific implementation of the underlying latches and is able to focus his or her attention on the logical correctness of the design itself.

With reference now to there is illustrated a representation of an exemplary mapping function that is invoked to map between a logical or natural value and an implementation latch value in accordance with a preferred embodiment of the present invention. Exemplary mapping function is a compiled dynamically loadable module which has a name in this example mapX by which mapping function is identified in Dial declaration statements. Each mapping function is preferably implemented with a respective dynamically loadable module and the mapping functions needed for a particular simulation are loaded dynamically at runtime utilizing the mapping function names specified in the configuration specification language as discussed further below.

Mapping function includes a set of routines written in C C or some other suitable a high level language namely a read routine utilized to translate values during a read of a Dial having mapX as an associated mapping function and a set routine utilized to translate values in conjunction with setting a Dial having mapX as an associated mapping function. Read routine may implement any desired value transformation including a mathematical or logical transformation shifting padding or truncating bits generation of pseudo random values mapping between enumerated values etc. Set routine preferably implements the reverse transformation of read routine .

As illustrated read routine has a read entry point . The name of the read entry point is mapX read in out where mapX is the name of mapping function and in and out are input and output parameters consisting of bits. When a Dial associated with mapping function mapX is read read routine takes as input a bit field in the in parameter that corresponds to the values for the latches controlled by Dial. The routine returns through parameter out the transformed bit field.

Set entry point likewise has the name mapX set in out where mapX is again the name of mapping function parameter in corresponds to the input value and parameter out corresponds to the transformed output value. This transformed output value is utilized to update the value of latches when the Dial is set.

As shown in the menu of mapping functions that may legally be associated with Dials in a design is preferably collected in a file such as mapping control file . In the exemplary embodiment shown in mapping control file includes a respective entry for each mapping function that has been defined. Each such entry includes five fields a mapping function name field that specifies the name of the mapping function read input and output width fields and that respectively specify that bit widths of the in and out parameters of the read entry point of the mapping function and set input and output width fields and that respectively specify that bit widths of the in and out parameters of the set entry point of the mapping function.

In order to associate a mapping function with a particular Dial the user specifies the name of the mapping function to be applied to the Dial in a configuration specification language statement within an HDL file or configuration specification file . For example expanding upon the syntax introduced above a user may employ the following syntax 

In this configuration specification language statement the qualifier lfsr 12 in parenthesis appended to the Dial declaration statement specifies the name of the mapping function to be applied to instances of this IDial. Because mapping functions are preferably a property of the Dial definition and apply to all instances of the Dial the association of the Dial and the mapping function is recorded in the DDDS as described below with respect to .

In accordance with one embodiment of the present invention mapping functions can be associated with any of three Dial types described above i.e. IDials LDials and CDials utilizing the syntax as described above as well as additional Dial types described in the above referenced patent application. However mapping functions find their most advantageous usage in association with IDials and LDials and the implementation of mapping functions within such dials will now be described.

For IDials or LDials it is possible to implement the mapping function above or below the mapping table defined for the Dial. If the mapping function is implemented above mapping table 

As noted above another alternative for LDials and IDials is to implement the mapping function below mapping table . In this case 

The mapping functions for both LDials and IDials would thus receive as input a bit string and produce as output a bit string. In the case of a mapping function associated with an LDial the widths of the input and output parameters for both the set and read entry points of the mapping function are equal and equal to the number of latches controlled by the LDial. In the case of an IDial the read input bit width and the set output bit width for the mapping function equal the number of latches controlled by the IDial or replicated portion of the IDial with split output. However the set input bit width of the set entry point and the read output bit width of the read entry point of the mapping function while generally equal in width need not be equal and furthermore need not equal the number of latches controlled by the Dial.

Mapping functions may similarly be implemented for CDials. If the mapping function for a CDial is implemented below mapping table the mapping function would receive a set of enumerated values as input and output an altered set of enumerated values for both set and read operations. Because in general creating such mapping functions would be at least as complex and similar in nature to defining a new mapping table it is presently preferred to implement mapping functions for CDials if at all above mapping table .

If a mapping function for a CDial is defined above mapping table the mapping function receives as input a single enumerated value and returns a single enumerated value. Such mapping functions do not provide significant additional function that cannot be similarly achieved by altering mapping table directly. Therefore while it is possible to apply the teachings of the present invention to CDials it is generally preferred to utilize mapping functions in conjunction with LDials and in particular IDials.

Further to promote uniformity in the parameter types of mapping functions in what follows mapping functions for LDials and IDials will be demonstrated as being below mapping table . Those skilled in the art will appreciate the alterations necessary to practice the present invention for CDials and LDials or IDials with mapping functions placed above mapping table .

Referring now to there is illustrated there is depicted a high level flow diagram of a model build process in which mapping functions are dynamically bound to Dial definitions in accordance with a preferred embodiment of the present invention. As indicated by like reference numerals the process shown in is substantially similar to that described above with respect to with the differences noted below.

As indicated by prime notation HDL compiler is substantially similar to HDL compiler of but in accordance with the present invention has been modified to process configuration specification language statements within configuration specification file and or HDL files that specify an association between a Dial and a mapping function. When HDL compiler processes a configuration specification language statement e.g. a Dial declaration indicating an association between a mapping function and a Dial HDL compiler examines mapping control file to ensure the mapping function exists and has the compatible bit widths for its input and output parameters. For example for an IDial HDL compiler verifies by reference to output width field of the relevant entry in mapping control file that the output bit width of the mapping function matches the number of output latches of the IDial. Similarly for an LDial HDL compiler verifies that the input and output bit widths indicated in input and output width fields and of the relevant entry of mapping control file match the mapping table bit size and the number of controlled latches for the LDial. If a mapping function declared in a configuration specification language statement does not exist or if any bit width is incorrect the HDL compiler terminates with an error.

The remainder of the model build process shown in is identical to that described above except for the addition of data structures to configuration database by configuration compiler to support mapping functions. These data structures are described below with respect to .

With reference now to there is illustrated a high level logical representation of a configuration database in accordance with one embodiment of the present invention. As again indicated by prime notation configuration database is substantially similar to configuration database of with the exception of the addition of data structures to support mapping functions in accordance with the present invention.

In particular configuration database is augmented to include a mapping function table . Mapping function table preferably includes a respective entry for each mapping function actually associated with a Dial by a configuration specification language statement within configuration specification files or HDL files . Thus mapping control file may list 100 different mapping functions that are available but if the configuration specification language code compiled during the model build process calls out only five mapping functions mapping function table will contain only five entries. As depicted each entry in mapping function table preferably includes seven fields 

At least the DDDSs of Dials with which a mapping function is associated are also augmented to include a mapping function pointer . In the DDDSs of such Dials mapping function pointer points to an entry of mapping function table that specifies the name of the associated mapping function.

Once a configuration database or is constructed the contents of configuration database or can be loaded into volatile memory such as system memory of data processing system of in order to appropriately configure a simulation model for simulation. In general data structures and can be loaded directly into system memory and may optionally be augmented with additional fields as described in the above referenced application. However as noted above if it is desirable for the non volatile image of configuration database to be compact it is helpful to generate additional data structures such as Dial pointer array latch pointer array and instance pointer arrays in the volatile configuration database image in system memory .

Referring now to there is depicted a high level logical flowchart of a method by which configuration database is expanded within volatile memory of a data processing system such as system memory of data processing system . Because depicts logical steps rather than operational steps it should be understood that many of the steps illustrated in may be performed concurrently or in a different order than that shown.

As illustrated the process begins at block and then proceeds to block which illustrates data processing system copying the existing data structures within configuration database from non volatile storage e.g. disk storage or flash memory into volatile system memory . Next at block a determination is made whether all top level pointers within top level pointer array of configuration database have been processed. If so the process passes to block which is discussed below. If not the process proceeds to block which illustrates selection from top level array of the next top level pointer to be processed.

A determination is then made at block of whether or not parent pointer within the DIDS identified by the selected top level pointer is a NULL pointer. If not which indicates that the DIDS describes a top level Dial belonging to a Dial group the process returns to block indicating that the top level Dial and its associated lower level Dials will be processed when the Dial group to which it belongs is processed.

In response to a determination at block that the parent pointer is a NULL pointer data processing system creates an instance pointer to the DIDS in the instance array of the DDDS to which definition pointer in definition field of DIDS points as depicted at block . Next at block data processing system creates a Dial pointer to the DDDS of the top level Dial within Dial pointer array if the Dial pointer is not redundant. In addition as shown at block data processing system creates a latch pointer within latch pointer array pointing to each latch data structure if any referenced by an output pointer of the DIDS of the top level Dial. As shown at block each branch at each lower level of the Dial tree if any headed by the top level Dial referenced by the selected top level pointer is then processed similarly by performing the functions illustrated at block until a latch data structure terminating that branch is found and processed. The process then returns to block representing the processing of each top level pointer within top level pointer array .

In response to a determination at block that all top level pointers have been processed the process illustrated in proceeds to block . Block illustrates the creation of a Dial set field in each DIDS in the configuration database. Dial set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set. In addition as depicted at block data processing system creates a latch value field and latch set field in each latch data structure to respectively indicate the current set value of the associated configuration latch and to indicate whether the configuration latch has been explicitly set. Although the creation of the three fields indicated at blocks is illustrated separately from the processing depicted at blocks for purposes of clarity it will be appreciated that it is more efficient to create Dial set field as each DIDS is processed and to create latch value and latch set fields as the latch data structures at the bottom of each Dial tree are reached.

Following block the process proceeds to block which illustrates the loading into system memory of each of the mapping functions listed within mapping function table utilizing the mapping function names specified within mapping function name fields . Read and set entry pointer fields and within mapping function table are then updated to reflect the locations of the corresponding mapping function entry points within system memory . The process of loading the configuration database into volatile memory thereafter terminates at block .

With the configuration database loaded into volatile memory a simulation model can be configured and utilized to simulate a digital design through the execution of simulation software. With reference to there is illustrated a block diagram depicting the contents of system memory during a simulation run of a simulation model. As shown system memory includes a simulation model which is a logical representation of the digital design to be simulated as well as software including configuration APIs a simulator and an RTX Run Time eXecutive .

Simulator loads simulation models such as simulation model into system memory . During a simulation run simulator resets clocks and evaluates simulation model via various APIs . In addition simulator reads values in simulation model utilizing GETFAC API and writes values to simulation model utilizing PUTFAC API . Although simulator is implemented in entirely in software it will be appreciated in what follows that the simulator can alternatively be implemented at least partially in hardware.

Configuration APIs comprise software typically written in a high level language such as C or C that support the configuration of simulation model . These APIs which are dynamically loaded by simulator as needed include a first API that loads configuration model from non volatile storage and expands it in the manner described above with reference to to provide a memory image of configuration database . Configuration APIs further include additional APIs to access and manipulate configuration database as described in detail below.

RTX controls simulation of simulation models such as simulation model . For example RTX loads test cases to apply to simulation model . In addition RTX delivers a set of API calls to configuration APIs and the APIs provided by simulator to initialize configure and simulate operation of simulation model . During and after simulation RTX also calls configuration APIs and the APIs provided by simulator to check for the correctness of simulation model by accessing various Dials configuration latches counters and other entities within simulation model .

RTX has two modes by which it accesses Dials instantiated within simulation model interactive mode and batch mode. In interactive mode RTX calls a first set of APIs to read from or write to one or more instances of a particular Dial within configuration database . The latch value s obtained by reference to configuration database take immediate effect in simulation model . In batch mode RTX calls a different second set of APIs to read or write instantiations of multiple Dials in configuration database and then make any changes to simulation model at the same time.

In either interactive or batch mode RTX must employ some syntax in its API calls to specify which Dial or Dial group instances within simulation model are to be accessed. Although a number of different syntaxes can be employed including conventional regular expressions employing wildcarding in an illustrative embodiment the syntax utilized to specify Dial or Dial group instances in API calls is similar to the compact expression hereinbefore described. A key difference between the compact expressions discussed above and the syntax utilized to specify Dial or Dial group instances in the RTX API calls is that in the illustrative embodiment Dial and Dial group instances are specified in the RTX API calls by reference to the top level design entity of simulation model rather than relative to the design entity in which the Dial or Dial group is specified.

In the illustrative embodiment each RTX API call targeting one or more Dial or Dial group instances in simulation model specifies the Dial or Dial group instances utilizing two parameters an instance qualifier and a dialname qualifier. To refer to only a single Dial or Dial group instantiation the instance qualifier takes the form a.b.c.d which is the hierarchical instantiation identifier of the design entity in which the single Dial or Dial group instantiation occurs. To refer to multiple Dial or Dial group instances the instance qualifier takes the form a.b.c X which identifies all instantiations of entity X within the scope of entity instance a.b.c. In the degenerate form the instance qualifier may simply be X which identifies all instantiations of entity X anywhere within simulation model .

The dialname qualifier preferably takes the form Entity.dialname where Entity is the design entity in which the Dial or Dial group is instantiated and dialname is the name assigned to the Dial or Dial group in its configuration specification statement. If bracketed syntax is employed to specify the instance qualifier the Entity field can be dropped from the dialname qualifier since it will match the bracketed entity name.

Referring now to there is depicted a high level logical flowchart of an exemplary process by which configuration APIs locate particular Dial or Dial group instances in configuration database based upon an instance qualifier and dialname qualifier pair in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of an API call from RTX containing an instance qualifier and a dialname qualifier as discussed above. In response to the API call the configuration API enters configuration database at Dial pointer array as depicted at block and utilizes Dial pointers to locate a DDDS having a name field that exactly matches the specified dialname qualifier as illustrated at block .

Next at block the configuration API determines whether the instance qualifier employs bracketed syntax as described above. If so the process passes to block which is described below. However if the instance qualifier does not employ bracketed syntax the configuration API follows the instance pointers of the matching DDDS to locate the single DIDS having an instance name field that exactly matches the specified instance qualifier. As indicated at blocks if no match is found the process terminates with an error. However if a matching DIDS is located a temporary result pointer identifying the single matching DIDS is created at block . The process thereafter terminates at block .

Returning to block if bracketed syntax is employed the configuration API utilizes instance pointers of the matching DDDS to locate one or more DIDSs of Dial or Dial group instances within the scope specified by the prefix portion of the instance identifier preceding the bracketing. That is a DIDS is said to match if the instance name field of the DIDS contains the prefix portion of the instance qualifier. Again if no match is found the process passes through block and terminates with an error at block . However if one or more DIDSs match the instance qualifier temporary result pointers identifying the matching DIDSs are constructed at block . The process shown in thereafter terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial instances in interactive mode in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of a read Dial API call by RTX . As indicated at block a configuration API responds to the read Dial API call by locating within configuration database one or more DIDSs of Dial instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API determines by reference to type field of the DDDS associated with the DIDS identified by the current result pointer whether the DIDS corresponds to a Dial group. If so the process illustrated in terminates with an error condition at block indicating that RTX has utilized the wrong API call to read a Dial instance.

In response to a determination at block that the DIDS identified by the current result pointer does not correspond to a Dial group instance the process proceeds to block . Block depicts configuration API utilizing output pointers of the DIDS and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the Dial instance specified in the API call. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch value s of all of the configuration latches listed in the data set constructed at block .

Following block the process proceeds to block which illustrates configuration API checking the DDDS of the Dial instance specified in the API call for the presence of a non NULL mapping function pointer . If DDDS contains a NULL mapping function pointer no mapping function is called and the process simply passes to block . If however DDDS contains a non NULL mapping function pointer configuration API invokes the mapping function within mapping function table indicated by mapping function pointer to transform the latch value s obtained at block . As discussed above the mapping function is invoked by calling the read entry point utilizing the latch values as the in parameter. The mapping function transforms the latch value s and returns transformed values as the out parameter.

Configuration API then verifies the possibly transformed latch values by reference to configuration database as shown at block . In order to verify the latch values configuration API utilizes mapping tables and mapping functions if any to propagate the latch values up the Dial tree from the corresponding latch data structures through intermediate DIDSs if any until an input value for the requested Dial instance is determined. If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

As indicated by the process returning to block the above described process is repeated for each temporary result pointer returned by the process of . Once all result pointers have been processed the process passes from block to blocks which illustrate the configuration API returning the result data structure to RTX and then terminating.

RTX reads Dial instances in interactive mode utilizing the method of for example to initialize checkers that monitor portions of simulation model during simulation runs. The Dial settings of interest include not only those of top level Dial instances but also those of lower level Dial instances affiliated with the portions of the simulation model monitored by the checkers.

Referring now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial group instances in interactive mode in accordance with the present invention. As can be seen by comparison of the process of reading a Dial group instance is similar to the process of reading a Dial instance but returns the value of one or more top level Dial instances of possibly different Dial entities rather than one or more instances of the same Dial entity.

As shown the process shown in begins at block in response to receipt by a configuration API of a read Dial group API call by RTX . As indicated at block a configuration API responds to the read Dial group API call by locating within configuration database one or more DIDSs of Dial group instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API identifies and creates temporary pointers to all of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The top level Dial instances are identified by locating the highest level DIDS for each output pointer for which the type field in the associated DDDS specifies a type other than Dial group. In other words the configuration API may have to search down through one or more hierarchical Dial groups to locate the relevant top level Dial instances.

The process illustrated in then enters a loop beginning at block in which each of the top level Dial instances belonging to the Dial group corresponding to the Dial group DIDS referenced by the current result pointer is individually processed to obtain the value s of the top level Dial instance s . The process next proceeds to block which depicts configuration API utilizing output pointers of the DIDS of the first or next top level Dial instance and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the top level Dial instance. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

Following block the process proceeds to block which illustrates configuration API checking the DDDS of the Dial instance specified in the API call for the presence of a non NULL mapping function pointer . If DDDS contains a NULL mapping function pointer no mapping function is called and the process simply passes to block . If however DDDS contains a non NULL mapping function pointer configuration API invokes the mapping function within mapping function table indicated by mapping function pointer to transform the latch value s obtained at block . As discussed above the mapping function is invoked by calling the read entry point utilizing the latch values as the in parameter. The mapping function transforms the latch value s and returns transformed values as the out parameter.

At block configuration API then verifies the possibly transformed latch values obtained from simulation model by reference to configuration database utilizing the same technique described above with reference to block of . If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

Following either block or block the process returns to block which represents a determination of whether or not all top level Dials belonging to the Dial group corresponding to the DIDS referenced by the current result pointer have been processed. If not the process returns to block which has been described. However if all top level Dials have been processed the process returns to block which illustrates a determination of whether or not all result pointers have been processed. If not the next result pointer is processed at block and following blocks which have been described. If however all result pointers have been processed the process passes to block which illustrates the configuration API returning the result data structure to RTX and then terminating.

Reading Dial and Dial group instances in a batch mode of RTX is preferably handled by configuration APIs in the same manner as interactive mode with one exception. Whereas in interactive mode latch values are always read from simulation model via calls to GETFAC API at blocks and in batch mode a latch value is preferably obtained from latch value field of a latch data structure in configuration database if latch set field indicates that the corresponding configuration latch has been set. If the configuration latch has not been set the latch value is obtained from simulation model by a call to GETFAC API . This difference ensures that Dial settings made in batch mode which may not yet have been reflected in simulation model are correctly reported.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which an RTX sets a Dial instance in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial API call from RTX . In response to the set Dial API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial instance s specified in the set Dial API call utilizing the technique described above with reference to as illustrated at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial instances. This determination can be made for example by examining the parent pointer of each such DIDS and that of any higher level DIDS linked by a parent pointer and the type fields of the associated DDDSs . The DIDS of a top level Dial instance will have either a NULL parent pointer or a non NULL parent pointer pointing to another DIDS that the type field of the associated DDDS indicates represents a Dial group. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial instance the process terminates at block with an error condition.

In response to a determination at block that all of the DIDSs referenced by the result pointers correspond to top level Dial instances a further determination is made at block whether or not the specified value to which the Dial instance s are to be set is one of the values specified in the mapping table of the associated DDDS . If not the process terminates with an error at block . However in response to a determination at block that the specified value to which the Dial instance s are to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set a respective Dial instance.

At block configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified in the set Dial API call down the Dial tree headed by the top level Dial instance associated with the DIDS referenced by the current result pointer. In order to propagate the desired Dial setting mapping table in the DDDS associated with the DIDS referenced by the current result pointer is first referenced if necessary i.e. for CDials and LDials to determine the output values for each of output pointers in the output pointer array of the DIDS referenced by the current result pointer. These output values are propagated down the Dial tree as the input values of the next lower level Dial instances if any corresponding to the DIDSs referenced by output pointers . This propagation continues until a latch value is determined for each configuration latch terminating the Dial tree which are represented in configuration database by latch data structures .

Following block the process proceeds to block which illustrates configuration API checking the DDDS of the Dial instance specified in the API call for the presence of a non NULL mapping function pointer . If DDDS contains a NULL mapping function pointer no mapping function is called and the process simply passes to block . If however DDDS contains a non NULL mapping function pointer configuration API invokes the mapping function within mapping function table indicated by mapping function pointer to transform the latch value s obtained at block . As discussed above the mapping function is invoked by calling the set entry point utilizing the latch values as the in parameter. The mapping function transforms the latch value s and returns transformed values as the out parameter.

As shown at block as each possibly transformed latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure .

Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer. After all result pointers are processed the process terminates at block .

Referring now to there is depicted a high level logical flowchart of an illustrative process by which an RTX sets a Dial group in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial group API call from an RTX . In response to the set Dial group API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial group instance s specified in the set Dial group API call utilizing the technique described above with reference to as depicted at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial group instances. This determination can be made for example by examining the parent pointer of each such DIDS to ascertain whether the parent pointer is NULL. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial group i.e. has a non NULL parent pointer the process terminates at block with an error condition.

In response to a determination at block that each of the DIDSs referenced by the result pointers corresponds to a top level Dial group the process passes to blocks . Block illustrates configuration API locating all of the top level Dial instances within each Dial group for which the corresponding DIDS is referenced by a result pointer. Then as depicted at block the configuration API determines whether or not the specified value to which each top level Dial instance is to be set is one of the values specified in the mapping table of the corresponding DDDS . If not the process terminates with an error at block .

In the illustrated embodiment the prevalidation steps illustrated at blocks and are performed prior to setting any Dial instances because it is deemed preferable to implement setting a Dial group instance as an atomic operation that either successfully sets all relevant top level Dial instances or completely fails. In this manner a complex condition in which some top level Dial instances within the Dial group instance are set and others are not can be avoided.

In response to a determination at block that the specified value to which each top level Dial instance is to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set the top level Dial instance s belonging to each Dial group instance.

At block the configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified for each top level Dial in the set Dial group API call down the Dial trees of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The propagation of Dial settings down the Dial trees is performed in the same manner discussed above with reference to block of .

Following block the process proceeds to block which illustrates configuration API checking the DDDS of the Dial instance specified in the API call for the presence of a non NULL mapping function pointer . If DDDS contains a NULL mapping function pointer no mapping function is called and the process simply passes to block . If however DDDS contains a non NULL mapping function pointer configuration API invokes the mapping function within mapping function table indicated by mapping function pointer to transform the latch value s obtained at block . As discussed above the mapping function is invoked by calling the set entry point utilizing the latch values as the in parameter. The mapping function transforms the latch value s and returns transformed values as the out parameter.

As shown at block as each possibly transformed latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure . Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer if any.

With reference now to there is illustrated a high level logical flowchart of an exemplary method of setting Dial and Dial group instances in batch mode in accordance with the present invention. As illustrated the process begins at block and thereafter proceeds to block which illustrates RTX initializing configuration database by calling a configuration API e.g. start batch in order to initialize configuration database . The start batch API routine initializes configuration database for example by setting each Dial set field and latch set field in configuration database to FALSE. By resetting all of the set fields in configuration database the Dials and configuration latches that are not set by the current batch mode call sequence can be easily detected as discussed below.

Following initialization of configuration database RTX issues a batch mode set Dial or set Dial group API call to enter settings for Dial instances and their underlying configuration latches into configuration database . A configuration API responds to the API call in the same manner described above with respect to for setting Dial instances or for setting Dial group instances with two exceptions. First when any top level or lower level Dial instances are set whether as a result of a set Dial or set Dial group API call the Dial set field of the corresponding DIDS is set to TRUE. Second no latch values are written to simulation model by the set API routines as illustrated at blocks and of . Instead the latch values are written into latch value fields of the latch data structure corresponding to each affected configuration latch and the latch set field is updated to TRUE. In this manner the Dial instances and configuration latches that are explicitly set by the API call can be readily identified during subsequent processing. It should be noted that as Dial instances are set by the propagation of settings down Dial trees any mapping functions associated with the Dial instances as indicated by mapping function pointer in the associated DDDS are applied to transform values as discussed above.

Following block the process passes to block which illustrates RTX calling an end batch API routine among configuration APIs to complete the batch mode access. As illustrated at block the end batch API routine first applies default values if any to any Dial instances not explicitly set at block if a default mode is enabled e.g. through a parameter of the end batch API call or an operational parameter of RTX . To apply default values the end batch API routine locates all unset top level Dial instances i.e. those for which Dial set field is FALSE in configuration database and applies the default value if any specified in the default field of the associated DDDS . These default values are propagated down the Dial tree of each affected top level Dial applying the mapping function if any associated with each Dial instance and utilized to set latch value fields Dial set field and latch set field in the manner described above with reference to block . The end batch API routine then traverses the Dial tree of each top level CDial that remains unset following the application of default values to top level Dials and applies the default value of the next highest level Dial instance in each branch of the Dial tree that has a specified default value. Again these default values are propagated down the Dial tree of each affected lower level Dial applying the relevant mapping functions and utilized to set latch value fields Dial set field and latch set field in the manner described above with reference to block . This methodology of applying default values allows default values higher in a Dial tree to have precedence over default values lower in the Dial tree.

After default values have been optionally applied as illustrated at block the end batch API routine utilizes latch pointer array to examine each latch data structure in configuration database . For each latch data structure in which latch set field has the value TRUE the end batch API routine issues a call to PUTFAC API of simulator to update simulation model with the latch value contained in latch value field . Thereafter the batch process terminates at block .

Configuration APIs preferably further include a find unset latch API that following a batch mode setting of Dial or Dial group instances in configuration database audits all of the latch data structures in configuration database by reference to latch pointer array in order to detect configuration latches that have not been configured by an explicit or default setting i.e. those having latch set field set to FALSE . For each such unset configuration latch the find unset latch API preferably returns the fully qualified instance name of the configuration latch from latch name field in the corresponding latch data structure and the fully qualified instantiation identifier of the top level Dial instance that controls the unset latch. The find unset latch API thus provides an automated mechanism for a user to verify that all Dial and latch instances requiring an explicit or default setting are properly configured for a simulation run.

Configuration APIs preferably further include a check model API that when called utilizes top level pointer array to verify by reference to the appropriate mapping tables that each top level CDial and LDial instance in simulation model is set to one of its legal values. Any top level LDial or CDial set to an illegal value is returned by the check model API.

The Dial and Dial group primitives introduced by the present invention can be employed not only to configure a simulation model of a digital design as described above but also to configure hardware realizations of the digital design for laboratory testing and customer use. In accordance with an important aspect of the present invention hardware realizations of the digital design are configured by reference to a hardware configuration database which like configuration databases and discussed above is derived from configuration specification statements coded by the designers. The hardware configuration database may then be utilized to read and set latches within a hardware realization of a digital design according to the process hereinbefore described. In this manner continuity in configuration methodology exists from design through simulation and laboratory testing to commercial deployment of a digital design. Because the derivation and use of a hardware configuration database is described in detail in the above referenced application it is not described further herein.

As described above the present invention provides improved methods systems and program products supporting the association of arbitrary mapping functions within configuration constructs such as Dials in a digital design. By employing mapping functions in this way users may advantageously interact with a simulation model or hardware implementation of a digital design by reading and setting values of Dial instances utilizing intuitive logical or natural values rather than implementation specific values.

While the invention has been particularly shown as described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration constructs having different rules than the particular exemplary embodiments disclosed herein. In addition although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal bearing media which include without limitation non rewritable storage media e.g. CD ROM rewritable storage media e.g. a floppy diskette or hard disk drive and communication media such as digital and analog networks. It should be understood therefore that such signal bearing media when carrying or encoding computer readable instructions that direct the functions of the present invention represent alternative embodiments of the present invention.

In addition it will be appreciated that mapping functions in accordance with the present invention are not restricted to use with IDials LDials and CDials but are instead applicable to other type of Dials for example the read only Dials disclosed in the above referenced patent application.

