---

title: SCSI device emulation in user space facilitating storage virtualization
abstract: A method for storage virtualization in user space. The method includes providing a first emulation module running in the OS kernel and providing a second emulation module in the user space of the computer, which may emulate a media changer or other SCSI or other storage device. The method continues with a kernel-resident driver receiving a packet of data at a port of the computer that is linked to a data communications network (such as a SAN). The packet of data may include command data for a particular data storage device (e.g., a SCSI command for a SCSI device). The method includes operating the first emulation module to communicate with the driver and to then pass through the packet of data to the second emulation module, allowing the second emulation module to run in user space but efficiently receive data from the kernel-resident driver via the first emulation module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08073674&OS=08073674&RS=08073674
owner: Oracle America, Inc.
number: 08073674
owner_city: Redwood City
owner_country: US
publication_date: 20080923
---
The present invention relates in general to methods and systems for storage virtualization including emulating SCSI devices and more particularly to systems and methods for providing high performance SCSI device emulation with virtualization code or modules that run at least partially in the user space of a computer device or system rather than wholly within the kernel.

Recently there has been a strong demand for storage virtualization and studies show that the trend toward virtualizing or emulating storage devices will only increase in coming years. Virtualization of data storage devices or storage virtualization generally refers to the process of abstracting logical storage from physical storage. Often storage virtualization involves pooling or aggregating a variety of heterogeneous devices such as tape drives tape libraries and disk arrays but presenting a portion to a client device for its use based on its needs or demands e.g. presenting a tape drive to a client device requesting data storage but physically utilizing disk storage device or portions of two or more tape drives . Virtualization of storage helps achieve location independence by abstracting the physical location of the stored data. The virtualization system presents to the user or client a logical space for data storage and the virtualization system handles the process of mapping the logical space to the actual physical location.

Storage virtualization is often achieved in part through emulation or virtualization of storage devices to clients linked to a communications network such as a storage area network SAN . Small Computer System Interface SCSI is a bus that allows computers or client devices to communicate with peripheral devices such as storage devices using a well defined communication protocol and tape drives disk drives tape libraries may be considered SCSI devices. SCSI device emulation is utilized in many products that provide storage virtialization. For example a storage server may be adapted for storage virtualization by functioning to present on a SAN what appear to host applications or other storage clients to be SCSI devices such as tape or disk drives while in fact the presented device is virtual or emulated. Such storage device emulation allows product vendors to insert value adding solutions or logic behind the virtual SCSI devices. One example may be a virtual tape in which a host application believes it is writing to a tape drive where instead the storage server product is actually using a disk drive to store the host s data. There are many types of virtualization products with virtualization making up a large segment of the overall storage market.

One common feature of most virtualization products is the emulation of SCSI devices which presents a number of challenges and complexities. Device emulation is typically achieved with a software program or module that rums inside the operating system OS space or kernel. The emulation module runs in the kernel such that it can talk or communicate with a host bus adapter HBA or other interface to the SAN or with a driver in the kernel that drives HBA input output I O . As a result SCSI emulation requires a significant amount of difficult and or tedious coding as the kernel based emulation module is written in a low level language such as the C Programming Language to support running inside the kernel. As such the downsides and difficulties associated with developing kernel resident code apply.

There remains a need for methods and systems for achieving high performance SCSI device emulation to facilitate data storage virtualization. Preferably such methods and systems would provide improved interfacing between emulation products or modules and with business logic or storage products modules running or present in the user space of storage server products.

The inventors recognized that a better approach to emulation code development may be to place the emulation code module in user space where a higher level language such as Java may be used to interface naturally with the business logic that provide value added functions. However in order to perform SCSI device efficiently the user space application code needs to communicate with kernel resident transport drivers. With this in mind the present invention addresses the above problems by providing a SCSI device emulation method that includes a highly efficient and transport independent technique for communicating between a kernel transport layer driver and a user space emulation application e.g. a media changer or the like provided in Java or other user space programming language in order to provide SCSI device emulation. By utilizing the SCSI device emulation method with its kernel to user space communication facility virtualization products may be developed and extended much more rapidly and reliably than was previously achievable when emulation code was run solely in the OS kernel.

More particularly a computer based method is provided for data storage virtualization. The method includes providing a first emulation module or code running in the OS kernel of a computer or computer system such as a virtualization server accessible by SCSI clients . A second emulation module is provided that runs in the user space of the computer such as a Java or other higher level programming language program or code set and the second emulation module may emulate a media changer or other device and or provide access to additional emulation virtualization code e.g. to business logic that adds value to storage virtualization products . The method continues with a kernel resident driver receiving a packet of data at a port of the computer that is linked to a data communications network such as a SAN or the like that may be configured for communicating per Fibre Channel protocols or the like . The packet of data may include command data for a particular data storage device e.g. a SCSI command for a SCSI device such as tape library or a disk array . Significantly the method includes operating the first emulation module to communicate with the driver in the OS kernel and to then pass through the packet of data to the second emulation module thereby allowing the second emulation module to run in user space but to be able to efficiently receive data from the kernel resident driver via the first emulation module.

The method may also include the first emulation module storing a copy of the packet of data in kernel memory and the second emulation module storing a copy of the packet of data in user space memory. The method may then include a step of mapping the packets in the two memories to provide a zero copy solution when the second emulation module provides the packet of data to additional emulation processes or business logic that results in the packet of data being modified. The modified packet is returned to the first emulation module in the kernel for use in modifying the copy in kernel memory e.g. DMA memory . In some cases the high performance communications between the kernel emulation module and the user space module includes the kernel emulation module first emulation module initiating a door call function e.g. a door call with a name of a door that the second emulation module is listening for when the OS is Solaris for example and after modification of the packet of data by user space emulation logic code the second emulation module can return the modified data by initiating a door return function. Each door call may cause the kernel to spin a processing thread in user space for the second emulation module and the passing of the packet of data from the kernel may include a step of attaching to the corresponding thread. Further the pass through of the packet of data may also include creating a data structure such as a data object when the user space is object oriented such as Java based user space and then receiving this data structure with the second emulation module. The data structure may be configured to control the modifications to data in its fields such as by limiting which sets writes can be performed by emulation or other logic modules in the user space.

Mapping of memory is typically used when the SCSI command has a payload associated with it that is to be returned to the client such as may be the case for a read command. In those cases an interface e.g. an ioctl C function call or the like is used that allows the user space emulation module to request storage from the kernel emulation module. This storage or memory is allocated by the kernel module using DMA memory and then mapped to the caller s user space so that when business logic executing within a user space process accesses this memory it is actually directly manipulating the DMA memory. Further a technique may be employed that maps this memory space to a high level language object e.g. a Java object or the like again without actually making a copy. For write operations the payload has already been received into DMA memory by the target driver. When this command is passed up to the emulation module the same mapping technique is employed except that instead of the user space module requesting memory e.g. as was done for a read operation the user space memory address of the payload is provided in the emulation packet passed to the user space module. The emulation packet is small in size and therefore the copy that occurs between kernel and user space has an insignificant impact on performance. The copy of the emulation packet from kernel to user and then user to kernel can be thought of as part of an inter process communication IPC mechanism. In some embodiments the IPC mechanism may be implemented using the Solaris doors IPC facility to perform these functions automatically as part of a door call kernel to user and a door return user to kernel .

Briefly embodiments of the present invention are directed to methods and systems for storage virtualization. One aspect of the methods and systems described herein is that they provide techniques and or mechanisms for supporting communication between kernel and user space resident processes such that a relatively small light kernel resident emulation module e.g. a pass through logical unit or LU provider may communicate emulation data to a user space resident emulation module which in turn may communicate interface with virtualization business logic. Typically storage virtualization involves emulation of SCSI devices such as tape drives and disk drives and hence implementations of the methods and systems may be adapted to support high performance SCSI device emulation in user space such as within storage server with a Solaris OS and using Solaris and Java facilities to support included functionalities.

A goal of the system may be to provide emulation or virtualization of one or more storage devices with storage devices providing actual data storage e.g. emulate a SCSI tape library but the device may be an array of disks or disk drive . To this end a virtualization server is provided that is linked at a port with the communications network to receive commands from and communicate data and messages to and from the client systems . For example the port s or target port s may be a FC port and a host bus adapter HBA may be provided to act as an interface between the server and the SAN network . The server further includes a kernel resident target mode transport driver to pass information to and from the SAN Fibre Channel . As shown the server is divided up into code running in kernel and in user space e.g. the server may use the Solaris OS such that the kernel resident code is in C or another lower machine level programming language while the code running in the user space may be Java or some other higher level programming language.

The system is adapted to move a significant amount or fraction of the emulation or virtualization code out of the kernel and into user space. As shown a kernel resident pass through module is provided in the kernel of server to communicate or pass through data it receives from the driver to a user space resident emulation module that interacts with business logic to emulate storage devices e.g. present SCSI devices to SCSI clients . According to one aspect of the invention a kernel to user space communication interface is provided to enable the user space resident emulation module to communicate with the kernel resident pass through or emulation module . Generally the interface whose operation is discussed in detail below acts to pass a string of bytes or data in the form of an emulation packet to the emulation module . In SCSI implementations of system the emulation packet includes SCSI command data or command data fields as well as other information such as command state information. The emulation module then uses the data to interact with business logic so as to emulate or virtualize storage devices and the packet is returned to the pass through module for transmittal over the SAN to the SCSI or other client such as via driver and HBA . Also as will be explained in detail below efficient data transfer e.g. a zero copy solution or efficient use of communications between the user space and kernel is achieved via special memory and or buffer management that allows packets in user space memory that is operated on by the emulation module and or business logic to be mapped as shown at to kernel memory or direct memory access DMA memory and its stored version of the emulation packets . Note a distinction may be made between the emulation packet used to communicate between kernel and user and the memory emulation packet . The memory emulation packet is basically a data buffer whose address is contained in the communication emulation packet .

The techniques described herein may be used to provide high performance SCSI device emulation in user space and it may be useful to provide a more particular example of this with a tape library emulation system shown in . The system is shown as having four sections or portions an outside SLM portion a SLM front ends portion a SLM portion and an ACSLS portion with SLM referring to storage library manager and ACSLS referring to Automated Cartridge System Library Software that may include software to control an Automated Cartridge System ACS or is library management software or business logic . A plurality of SCSI clients such as backup servers and the like access virtualization devices provided in the SLM front ends portion and SLM portion of system via a SAN . An HBA is provided along with a target driver running in the kernel with the driver generally being a C code software application for communicating over SAN via HBA .

According to one aspect or embodiment of the invention a small kernel resident module labeled SCST in figure is positioned logically between the kernel resident target mode transport driver running in kernel and the user space SCSI device emulation code module running in user space which in this example is a SCSI media changer and labeled SMCE . Note although the user space emulation code is shown in this example to be a SCSI media changer the code may be used to emulate any type of SCSI or storage device. The transport driver may be a driver configured specifically for a particular HBA or set of HBAs such as an HBA provided by a particular company such as QLogic Corporation or the like with the driver then being a QLogic target driver or be a more universal driver such as the Sun Common Multiprotocol SCSI Target Driver COMSTAR as available from Sun Microsystems Inc. and described at http opensolaris.org os project comstar .

The interface between SCST module or kernel resident emulation module code and the SMCE or user space emulation module code is unique and is useful aspect of embodiments of the invention. The interface in a Solaris Java implementation utilizes a number of available facilities to provide the unique functionality and high performance SCSI protocol that may be used to perform SCSI device emulation in a user space process module using Java code rather than C code or other lower machine language. One implementation of the interface as it may be used in system or server or system is described below in detail with reference to . The system further includes a model application programming interface API that may be used to interact with ACSLS components such as library control business logic and ACSLS databases as well as interacting with user interfaces or GUI provided in the JavaServer Faces JSF portion of the SLM front ends portion and SLM portion of system e.g. GUI may be used to create or set business logic that provides emulation of SCSI devices not shown used to store client data and emulate a tape library in this example with library control .

In some embodiments the design of the SCST interface and SMCE provides a clear separation of functional responsibilities. The transport layer driver is not aware of the SCSI commands contained as payload within the transport layer packets and the SCSI emulation code or SMCE is completely unaware of the underlying protocol of the transport layer. Before turning to the flow diagram of that describes an embodiment of interfacing as may be performed with interface and SCST and SMCE it may be useful to provide a more general description of communication techniques of the invention. The communication protocol between SCST and SMCE may be defined by exchanged emulation packets that are also labeled termed scstPackets herein. The scstPacket is a data structure such as a C data structure that encapsulates the information useful for transferring SCSI commands and responses between the SCST module and the SMCE process in user space .

During operation of system scstPackets are passed back and forth between the SCST module and the SMCE process in one implementation using the Solaris Doors IPC facility. The Doors IPC facility or kernel to user space communication routine command provides three functions 1 provides a very low overhead synchronous remote procedure call BLOC mechanism from kernel to user space e.g. provides copy of SCSI command data from kernel to user space such as set of bytes including SCSI command and other useful information but not actual data e.g. less than about 200 bytes 2 provides the execution context for all SMCE processing e.g. each door call internally spawns a thread such as shown with threads in and 3 provides memory management to map the scstPacket from kernel to user space and back again as shown with mapping in . Coupling the use of the Doors IPC facility with a number of Java JNI methods and making use of Java s facilities for creating buffers data objects such as with Java DirectByteBuffer the interface provides a low overhead zero copy solution to the problem of emulating SCSI devices with code running in user space e.g. with target port can emulate multiple LUNs that each can be any SCSI device .

At this point the flow of diagram becomes effective with the SCST or PTLU or the like making a door call passing the scstPacket to a listener for the user space emulation module . The emulation packet is sent at to user space or to JVM and the SCST is attached at to the current emulation thread previously spawned in the user space. Note the AttachCurrentThread function is called to provide another thread with access to the JVM and to obtain JNI interface pointer and once attached to the JVM a native thread works just like an ordinary Java thread running inside a native method. At a data object is formed using the scstPacket such as using the NewDirectByteBuffer facility to create an scstCommandBuffer as shown at . The NewDirectByteBuffer function allocates and returns a buffer referring to a particular memory address and extending a particular number of bytes or capacity setting. Typically native code such the SCST or listener but returns the resulting byte buffer e.g. scstCommandBuffer to Java level code with a reference to a valid region of memory that is accessible for reading and if appropriate writing e.g. returns a local reference to the newly instantiated data structure or byte buffer object.

At this point of flow the data object e.g. SCSI command network data and the like and other data such as the information initiator the target and the LUN are provided to the SMCE e.g. listener . The user space emulation code further acts to handle or process the command at with handler that allows the data is the user space memory or data object to be used processed by business logic to affect a desired SCSI device emulation and or storage virtualization with logic with the results e.g. sets or writes to the data fields of the data object in user space memory by logic being returned at to kernel or C space. At the process is detached from the current thread typically the native thread remains attached to the JVM until it calls DetachCurrentThread function to detach itself and a door return is used to update the emulation packet stored in kernel or DMA memory. Note typically the state is saved as part of the emulation packet or in packet butter because a particular command or SCSI network information may be processed through the flow two or more times to complete a particular emulation activity.

As can be seen in diagram the SCST or kernel resident module senses one or more scstPackets to the SMCE or user space resident module via a door call. The call wakes up a waiting thread that was previously started by the JVM that then calls into the JVM e.g. making sue of the AttachCurrentThread and NewDirectByteBuffer functions or the like passing the thread the scstPacket for execution. At this point the code of the emulation mechanism of this embodiment of the invention is executing in Java on the door thread. When the SMCE is finished with command execution status and responses are sent back to the SCST or kernel resident module simply via the door return facility or function. The information passed between the SCST and SMCE is contained within the scstPacket. The state of each command is maintained within the packet. Optimization may be provided by including a way for the emulation code to pass back both data and status in a single door call. Also the SMCE may make use of a buffer or memory management module not shown that allows a zero copy solution for transferring large data buffers.

The door function is synchronous and hence during operations the kernel based code PTLU or SCSI modules may have multiple door calls open or going concurrently waiting for return. Also as noted a common SCSI target may be provided through use of a COMSTAR target that provides a port provider interface with a set of drivers for transport cards e.g. HBA and other port providers . These drivers are kernel modules that implement the protocol for SCSI command transport e.g. Fibre Channel iSCSI SAS iSER and the like and provide local ports to be used as targets. The port providers focus on the transport protocol and do not have knowledge of SCSI command functionality of the LUs exposed through the port. A COMSTAR target also provides a SCSI target management framework STMF to communicate between the port provider interface which knows how to communicate with Fibre Channel and the like and an LU providers interface or layer. This latter interface layer may include the PTLU or similar kernel resident emulation module that provides a pass through of network data such as the SCSI command data or scstPackets as discussed above to the user space resident emulation module e.g. via door calls or the like .

As noted with reference to the IPC mechanisms of the invention include creating a data structure or object for use in passing and processing device or network data such as SCSI commands and information useful for emulating storage devices. illustrates generally a data object that is wrapped around an emulation or scstPacket of the invention e.g. as may be created with a NewDirectByteBuffer function call . The emulation packet generally includes a string of bytes such as up to about 200 bytes or more that may include a plurality of fields or data fields. As shown a number of these fields are command fields or fields reserved for SCSI data while other fields may include an emulator context field an LU context field and a port provider context field . These may also be thought of as providing data in input fields and output fields and processing by business logic as shown in process may be achieved simply in some embodiments by modifying the output fields. To protect the passed command network data the object may be adapted defined to allow only a particular number and or type of sets or writes to the data in packet e.g. change the output data fields but not portions of the command fields or the like .

A copy of the packet as discussed above is stored in kernel memory or DMA memory and at the door call a copy is made of the packet in user space memory. In one SCSI embodiment the data stored in the packet includes a set of SCSI command fields including a CDB or actual SCSI command field a state or completion status field e.g. send status transfer data status transfer final status free and other SCSI or other protocol status data a direction field a length field. Since the packet may simply be a string of bytes the method includes such as initiation time a process of explaining to the Java emulation module a technique for understanding the bytes. This definition guide may include defining fields in the buffer by offsets and data type e.g. integer string and the like and such a definition of the data in the packet may involve performing a plurality of JNI calls to get offsets and retrieve data or a property file may be generated that can then later be read by the emulation module in user space and or by business logic provided for device emulation to provide offsets data types field lengths and the like.

In operation of a system such as that shown in and in process of the user space emulation module achieves zero copy as the user space emulation module is provided access to DMA memory e.g. kernel memory Regarding the DMA memory the HBA hardware of the virtualization server knows memory i.e. DMA memory that it can communicate with during communications with SCSI clients the SAN network and a mapping function module is provided as part of the emulation mechanism or device described herein to map the DMA memory to user space memory.

The communications between the kernel resident emulation module or pass through module and the user space resident emulation module may be performed with zero copy I O i.e. I O without copying data buffers between operations . In this respect these two emulation modules or a mapping memory management mechanism module running in the virtualization server may function to provide single buffer allocation per I O operation with only the address of data being copied and not the data itself. Zero copy I O uses less memory CPU cycles and bus bandwidth and can provide much higher performance and it is useful with pass through applications such as the kernel resident emulation module described herein.

At this point it may be useful to describe a Solaris specific architecture or implementation for the zero copy I O mechanism. In this embodiment memory is allocated in kernel space. Applications call e.g. ioctl C function call into a buffer manager kernel module not shown in the figures but may be provided as a separate module resident in the kernel or as part of the pass through module to allocate and map buffers. Mapping is done via a user system call e.g. mmap C function call from within the buffer manager kernel module. After the mapping both kernel and user space have access to the data simultaneously e.g. the pass through module and the user space resident emulation module can both access the scstPacket or other data structures objects discussed herein . Multiple buffers may be allocated and mapped by a single application and multiple applications may map and access the same buffer address. During operation the buffer manager kernel module may notify the user application e.g. the user space resident emulation module asynchronously that a buffer has been filled using Solaris Doors functions facilities. The kernel fills in write data asynchronously notifies the user application when data is available via a door upcall or the like. For reads user applications may simply fill in the buffer and return via the door upcall. Bluffers are automatically freed when application reference count reaches zero. Briefly the buffer manager kernel module supports calls from user space resident emulation modules and the applications access a kernel DMA buffer containing the scstPacket or emulation packet data structure via a mapped pointer while kernel resident modules such as kernel resident emulation or pass through module may access the same kernel DMA buffer directly During operation of this embodiment zero copy data flow is achieved as buffer data may not touched by the user space resident emulation module or copied but may be simply transferred from the kernel buffer to an I O device.

Although the invention has been described and illustrated with a certain degree of particularity it is understood that the present disclosure has been made only by way of example and that numerous changes in the combination and arrangement of parts can be resorted to by those skilled in the art without departing from the spirit and scope of the invention as hereinafter claimed. The above discussion provides examples of facilities available in a Solaris OS and using Java but the invention is not limited to such embodiments but instead may be used in nearly any operating system and programming language environment to allow a lower level or kernel process to communicate with a processes running in user space or using higher level user friendly code. Similarly a number of Solaris and Java specific functions facilities were provided in the above description and these are not considered limiting but instead were provided as an example of one way to implement the inventive ideas. Those skilled in the art will understand these specific functions and facilities may be replaced with other Solaris and Java functions facilities to achieve the same effect or by facilities functions available in other operating system and programming environments that provide similar functionality to support internal process communications. Further the particular emulation performed by the business logic is not limiting to the invention as nearly any storage device SCSI device and combination such as a tape library one or more tape drives one or more disks or disk drives and combinations thereof may be emulated using the kernel to user space communication processes taught by this description.

