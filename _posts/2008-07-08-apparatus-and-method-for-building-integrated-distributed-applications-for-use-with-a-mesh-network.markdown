---

title: Apparatus and method for building integrated distributed applications for use with a mesh network
abstract: Various embodiments provide an apparatus and method for building integrated distributed applications for use with a mesh network. An example embodiment is configured to receive a shared view that is shared among a plurality of components of a network; generate a schema for the plurality of components from the shared view; use the schema to generate code components; and use the shared view and the generated schema to generate integration code for integrating the code components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08473898&OS=08473898&RS=08473898
owner: SynapSense Corporation
number: 08473898
owner_city: Folsom
owner_country: US
publication_date: 20080708
---
This patent application is related to co pending patent application Ser. No. 12 001 884 filed on Dec. 12 2007 titled APPARATUS AND METHOD FOR ADAPTIVE DATA PACKET SCHEDULING IN MESH NETWORKS and assigned to the same assignee as the present application.

This patent application is related to co pending patent application Ser. No. 12 001 917 filed on Dec. 12 2007 titled APPARATUS AND METHOD FOR ADAPTING TO FAILURES IN GATEWAY DEVICES IN MESH NETWORKS and assigned to the same assignee as the present application.

The disclosed subject matter relates to the field of software and system generation and network communications and more particularly to building integrated distributed applications for use with a mesh network.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings that form a part of this document Copyright 2007 2008 SynapSense Corporation All Rights Reserved.

Mesh networking is a way to route data and instructions between nodes. A node can be any device connected to a computer network. Nodes can be computers routers or various other networked devices. On a TCP IP network a node is any device with an Internet Protocol IP address. Mesh networking allows for continuous connections and reconfiguration around broken or blocked paths by hopping from node to node until the destination is reached. Mesh networks differ from other networks in that the component parts can all connect to each other via multiple hops and they generally are not mobile devices. In a packet switching network a hop is the trip a data packet takes from one router or intermediate node in a network to another node in the network. On the Internet or a network that uses TCP IP the number of hops a packet has taken toward its destination called the hop count is kept in the packet header.

Wireless mesh networks employ intelligent nodes typically including a wireless e.g. radio transmitter and receiver a power source input devices sometimes output devices and an intelligent controller such as a programmable microprocessor controller with memory. In the past wireless mesh networks have been developed having configurations or networks for communication that are static dynamic or a hybrid of static and dynamic. Power for these networks has been supplied either via wires the nodes are plugged in or from batteries in each node. As the size power and cost of the computation and communication requirements of these devices has decreased over time battery powered wireless nodes have gotten smaller yet the computing demands on the wireless nodes have increased.

Wireless sensor networks are finding applications in a wide range of areas including disaster recovery homeland security infrastructure monitoring habitat monitoring and pervasive computing environments. Wireless sensor network technology can be used for deploying sensors as nodes in a variety of different environments for monitoring diverse parameters such as for example temperature pressure particle counts and humidity. These types of networks can be denoted wireless sensor networks WSN . A wireless sensor network is typically comprised of a collection of devices embedded in a physical environment which gather information perform local computations and communicate with other devices and hosts through a wireless network.

Wireless sensor networks pose unique challenges for software developers compared to other forms of software construction because the devices that comprise wireless sensor networks have limited amounts of memory processing capability and battery power. As a result wireless sensor network research has created designs for a wide variety of highly efficient hardware platforms specialized to perform specific tasks. The wide variety of such platforms creates a considerable burden for the programmer who needs to be aware of the idiosyncrasies of each specific platform.

Over time as the installed base of sensor networks grows the need to support applications across heterogeneous devices and platforms will continue to grow. The capabilities of the system software used during development of applications for wireless sensor networks can greatly affect the complexity of implementing wireless sensor networks. However existing techniques for developing such applications have so far only focused on developing applications for a single platform.

U.S. Patent Application Publication No. 2006 0161909 describes a method and a system for synthesizing a scalable and incrementally updatable system software infrastructure for sensor networks. During operation the system receives a specification for an application and a specification for target devices. The system analyzes these specifications in order to identify a set of software components required to support the application and then proceeds to synthesize a customizable software stack that accommodates the identified set of software components on a specified target device. This process generates a minimal resource efficient software stack for a specific application on the specified target device.

Building distributed WSN applications has been extremely difficult as it requires mechanisms for addressing extreme heterogeneity among embedded devices and enterprise systems for developing software stacks that fit on highly resource constrained embedded devices and for integrating different software components that use different forms of networking technology such as 802.15.4 TCP IP local area networking and Web based systems to communicate with each other.

Currently most application developers use an ad hoc approach to building such applications. These conventional approaches typically involve manually developing and assembling the following components i low level implementation of applications on embedded devices ii data collection software that acts as bridge software between the sensor network and the enterprise world iii utility software such as database storage visualization and alert system etc iii bridge software for transcoding between different networking models and protocols and iv serialization de serialization software at both the embedded system end and the analysis processing and enterprise application end. Such a build and assemble approach has several weaknesses 1 Data inconsistency Different software components may use different data models thereby introducing inconsistency across the entire system. This will lead to incorrect data collection and analysis 2 Code duplication The manual effort duplicates much of the data processing and data communication code. This is time consuming and error prone 3 Limited remote control support The manual approach limits the kinds of remote control that can be supported 4 Limited extensibility The manual effort limits the number of service components that can be easily added to the system 5 Manual development The approach requires manual development of a large portion of the application which entails significant effort and cost and is error prone and 6 Device specific development The development approach tends to be specific to a device. This requires significant re development effort if heterogeneous sets of devices and gateways are used.

Thus an apparatus and method for building integrated distributed applications for use with a mesh network are needed.

In the following detailed description reference is made to the accompanying drawings that form a part hereof and in which are shown by way of illustration specific embodiments in which the disclosed subject matter can be practiced. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the disclosed subject matter.

According to various example embodiments of the disclosed subject matter as described herein there is provided an apparatus and a method for building integrated distributed applications for use with a mesh network. A particular embodiment relates to wireless sensor networks. Wireless sensor networks WSN s are emerging as an important technology that allows tight integration of the physical world with a computing system infrastructure. Ad hoc self organizing distributed wireless sensor systems composed of a vast number of sensor nodes can be deeply embedded in physical environments. While nodes can vary in their basic architecture most have severe resource limitations that call for extremely efficient computation models and communication patterns. The design and maintenance of a software infrastructure needs to be attentive to these constraints while addressing the complexities inherent to any distributed system.

WSN s are diverse at all levels from their hardware configurations to the applications they run. Multiple modes of sensing computing and communication enable a wide spectrum of applications that include but are not limited to disaster recovery homeland security civilian infrastructure monitoring condition based maintenance in factories education habitat monitoring precision agriculture military use and pervasive computing environments. Applications in these areas can be characterized not only by their diversity but also by the specific and unique requirements they impose on underlying software and network infrastructure. Often these applications require long term uninterrupted and unattended operations. Key characteristics that these applications must address include 1 small embedded nodes with cost limitations and highly limited resources e.g. small amounts of memory and low power low band width communication mechanisms 2 heterogeneity in the network nodes 3 applications and systems software that evolve during the application lifetime and 4 variations in physical node deployment.

In order to enable the successful development deployment and management of sensor network applications the applied software technology should ideally not limit long term reliability and secure deployment and should ideally ensure that each of the above characteristics are suitably addressed.

A particular embodiment described herein has application to data collection from an array of sensors disposed in a network topology wherein at least two intelligent communication nodes are within reliable radio communication range within an array of peer communication nodes. The particular embodiment of an example system and method described herein presents an apparatus and method for building integrated distributed applications for use with a mesh network. The network and node configuration in to particular example embodiment are described in more detail below.

Referring still to data packets or messages can be directed between any two nodes of the WSN as each node has a unique identifier. A data packet or message is a self contained unit of transmitted information. Typically a data packet has a header a payload and an optional trailer. A link is a path which originates at one node and terminates at one other node. A link or path between nodes may include multiple hops between a plurality of intermediate nodes prior to reaching a destination node. The transfer of messages between two nodes of WSN in a unicast or broadcast transmission is termed a local communication.

Each of the nodes of WSN can also communicate with a gateway via as gateway interface . The gateway provides a connection between the WSN and an analysis processor . In an alternative embodiment gateway and gateway interface can be located outside of the WSN . Gateway can be implemented as any node of WSN . It will be apparent to those of ordinary skill in the art that in the description herein variations of the WSN are still within the scope of the appended claims. Analysis processor can be used to receive sensor data from any of the nodes of WSN via gateway and to analyze the sensor data for aggregated environmental monitoring and control. Gateway and analysis processor can use a conventional data storage device for data storage and retrieval. Analysis processor can also include a connection to a wide area network such as the Internet. In this manner the gateway and the WSN can obtain access to the Internet

Gateway can also provide synchronization timing for the nodes of WSN . Gateway can send periodic messages to each of the nodes of WSN . These periodic messages can include a timing signal e.g. a beacon to which each of the nodes can synchronize their internal timers. Similarly messages from gateway to each of the nodes can be used to provide system status configuration and control settings for the nodes of WSN . The transfer of messages between the gateway and each of the nodes or between a node and all other nodes of WSN in a broadcast or multicast transmission is termed a global communication. According to a particular embodiment communication between nodes and or between nodes and gateway occurs only at specific times and on specific channels for local and global data communications.

The WSN can be configured in any of a variety of ways. Nodes can be added removed or moved within the array of nodes of WSN . Each of the nodes include functionality to join or reconfigure themselves in the WSN when a node is added or moved. As part of this functionality each node can discover its neighbor nodes and automatically negotiate and establish communication paths with those neighbors. A node can be in data communication with neighbors that are within the radio reception range of the node. Depending on the strength of the wireless transceivers e.g. radios within each node the distance between neighbor nodes is variable. Given that in some applications the environment in which WSN is being used may be subject to radio interference it is possible that the wireless data communications between nodes may be disrupted. In these cases each node can sense the loss of data communications with a neighbor and may reconfigure itself to use alternate data paths through other functioning nodes of WSN . As such the WSN is highly adaptable to changing conditions in the environment and in the configuration of the wireless network.

The example node includes a processor e.g. a central processing unit CPU or a wireless sensor processing unit a main memory and optionally a static memory which communicate with each other via a bus . The node may further include one or more sensor devices and . These sensor devices can include temperature sensors humidity sensors air flow sensors particle counters and or other types of sensors for detecting and measuring a desired condition. The sensor devices and can also include security devices such as motion detectors acoustical detectors seismic detectors vibration detectors metal detectors magnetic anomaly detectors explosives detection and the like. Additionally sensor devices and can also include process control devices such as conveyor motion activation and status robotic system activation and status tooling or machine system activation and status and the like. In general sensor devices and can include any sensors for detecting and measuring a desired condition within an environmental management system process control system building management system or the like.

The node may further include a non volatile memory a control signal generation device and a network interface device e.g. a radio transceiver . The non volatile memory includes a machine readable medium in which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or partially within the main memory the static memory and or within the processor during execution thereof by the node . The main memory static memory and the processor also may constitute machine readable media. The software instructions and or related data may further be transmitted or received over a network via the network interface device . The network interface device in a wireless node configuration of one embodiment may include a radio transceiver or transceiver unit for sending and receiving data to from network using a wireless data transfer protocol such as the family of 802.11 standards from IEEE. In this manner node can perform wireless data communications with other nodes of WSN . The control signal generation device can be used to control the operation of any system external to the WSN such as an environmental management system process control system building management system or other device or system that can alter the conditions being monitored by sensors and .

WSN applications are typically built using a software infrastructure e.g. operating systems middleware virtual machines etc. that interface the applications with the low level devices provide communication mechanisms for cooperation among devices and manage device and network wide resources. illustrates the structure of a traditional software stack. A layer of operating system software is implemented directly upon the device hardware and a set of middleware services are built on top of the operating system software . Applications can interact with the middleware or directly with the operating system software to perform a particular application function or to provide a service.

WSN software infrastructure needs to be configurable to run on a wide variety of devices have a minimal resource footprint and be easily adapted to run on a new set of devices. One option is to build for the lowest common denominator but this fails to take advantage of the unique features of each platform. Maintaining a separate version of an application for each platform takes advantage of unique platform features but requires developers to understand the peculiarities of each platform. In addition in such an environment it is difficult for developers who need to be able to work with software that they did not write and to account for performance and resource usage implications.

In a particular embodiment a WSN application may consist of several software components. These software components relate to the various types of nodes and processors e.g. sensor nodes gateways data analysis processors enterprise application servers user interface processors system alert processors and web servers provided in the WSN network system. For example referring again to the components and of system require a software stack that runs on embedded devices and that performs sensing and control in the real world. This software stack includes a system software environment such as an operating system and or a virtual machine a wireless networking stack and related applications. These software components are denoted embedded components.

Component of system requires a software stack that can store sensor data and support the searching and serving of this data to other system components. Component of system requires a software stack that can obtain sensor data either directly or from storage analyze and mine the data and provide processed results to other system components. Component of system requires a software stack that can integrate the WSN system with other enterprise systems via enterprise application integration EAI software. EAI software acts as a hub that translates data and messages between different applications. Component of system requires a software stack that can produce visualizations of the sensor data and related analyzed data. Component of system requires a software stack that can monitor system conditions and alert system operators of significant changes in the system state. Other system components such as process control software can run on laptops desktops servers and enterprise application systems. The software components that are not embedded components are denoted as integration service components.

The system also includes protocols such as the protocols and interfaces used with local network web server and wide area network that facilitate communication among embedded and service components. These protocols can also include conventional wired or wireless communication protocols authentication protocols encryption protocols and the like.

A WSN application in a particular embodiment therefore spans both traditional computing systems and abstractions and networked embedded devices. The various embodiments described herein address several key questions in building a WSN application. First it is important to define the various components that comprise the WSN application. Secondly it is important to specify how these components are assembled together to build a complete WSN system solution. These WSN application component definition and assembly operations are described in more detail below.

Various embodiments provide a set of component based development techniques that automate the process of customizing applications and system software for a range of widely different platforms thereby making WSN applications easier to write deploy and maintain. This approach addresses the problems with conventional techniques by defining an integrated approach to application development of both embedded and service components of the WSN application.

In a particular example embodiment there are two components of the software architecture one component is the data model that is shared between the embedded and service components. We call this view the shared data view. The shared data view captures the state that will be collected and processed at the embedded devices and will then be manipulated and or viewed by the service components in different ways. In a particular embodiment the shared data view includes a description of runtime state that will be evaluated at the components of the network. The shared data view becomes the basis for automated generation of a data schema on devices and on service components and for generation of communication and integration code. The shared data view enables a visualization system to provide a visualization description of the runtime state that is evaluated at the components of the network. The shared data view also enables generation of an alert system to provide management of events alerts and responses related to the runtime state at the component. The shared data view can be defined using a C C Java or C structure or class abstraction in a particular embodiment. It will be apparent to those of ordinary skill in the art that other programming languages scripting languages mark up languages or logic descriptors may similarly be used.

The second component of the software architecture of a particular embodiment is the operational view of the application which allows interoperation among different components. We call this view the shared service view. The shared service view defines the set of services the embedded components can export or otherwise provide to other components of the network. Embedded application and service components use the shared service view to interact and communicate with each other. In a particular embodiment the description of services provided in a shared service view is defined in terms of method signatures. The shared service view can be defined using C Java or C class component specification mechanisms in a particular embodiment. It will be apparent to those of ordinary skill in the art that other programming languages scripting languages mark up languages or logic descriptors may similarly be used.

Additionally an application developer may optionally extend the default shared data view and shared service view collectively called the shared views or the common view to customize the default behavior of the WSN system. For example referring to the figure illustrates four extensions of the shared views in an example embodiment. These example views include the device view data view Graphical User Interface GUI alert view and web services view . The device view extends the common view to extend or override the default behavior on the embedded devices. The data view specifies how WSN data will be stored in the long term data storage device . The GUI alert view extends the shared view to customize the visualization characteristics for a particular WSN system. The GUI alert view enables generation of a visualization system to provide a visualization description of the services provided by the plurality of components of the network. GUI alert view also enables generation of an alert system to provide management of events alerts and responses related to the services provided by the plurality of components of the network. Similarly the web services view extends the common view to customize the enterprise integration characteristics for a particular WSN system. The web services view enables the generation of a web services system that provides web specific inter operability between network components that provide the services and network components that use the services. Further the shared service view enables generation of an integration system that provides process control software specific inter operability between network components that provide services and components that use the services. A WSN application is thus defined in terms of a shared data view a shared service view and extended views. The shared data view shared service view and extended views serve as a high level specification of how the WSN application captures and collects data at the embedded devices and of network and how the collected data is processed and manipulated by the service components and . The generation and use of this high level specification in a particular embodiment is described in more detail below.

The following shows an example of a shared data view written in annotated Java for a particular embodiment 

In this example TempRHSchema represents a shared data view or a data model shared among embedded devices and service components. The shared data view of the example definition includes the following variables rhVal and tempVal which respectively denote the relative humidity and temperature data collected by the sensors at the embedded devices. Variable globalTime denotes the time at which data was sampled whereas nodeId captures the logical identifier of the device. The definition includes annotations prefixed in this example with an symbol used to associate specific semantics with the data entities. These annotations can be used by compilers to generate components of the software stack for the end devices and the integration services. Example annotation shared data view is a keyword used to indicate that TempRHSchema is a data structure used to share information among different distributed components. Compilers can use this definition to automatically generate database schemas and queries code for serialization and deserialization graphical user interface GUI schemas alert schemas and high level application programming interfaces API s . Annotations include system metadata indicates that the variable is a data structure maintained system wide by the runtime system. For instance in the above example definition globalTime is represented by system metadata indicating a common global time maintained internally by the underlying runtime system. When the node collects temperature and humidity data the current global time is read from the system and stored as part of the data structure. Similarly the annotation include logical id metadata represents the logical identifier metadata associated with each device and is associated with variable nodeId.

An extended data view adds or modifies the attributes to a shared data view. The example below shows an extended alert data view that will enable the alert system to trigger errors and exception conditions.

In the above example extended data view definition AlertTempRHSchema extends TempRHSchema to include three additional variables tempVal low tempVal up message and mail address. The additional variables can be used to check for boundary conditions and trigger a message to a pre defined mail address. The compiler can use the above example extended data view definition to automatically generate code for i setting up lower and upper bounds on temperature values ii setting up messages and mail addresses iii checking for upper and lower bounds on the incoming packets and iv sending messages if exception conditions are reached. Similar extended views can be defined for other integration services.

The shared service view or common service model defines an interface into the services provided by devices and applications in the network of a particular embodiment. Each device can export a set of services through a standard set of interfaces. The interfaces become the basis for each software component to interact with other software components. A common service model can be used to model hardware components such as a micro controller unit flash or light emitting diodes LED s sensors and application services. The example definitions below show examples of each 

The above example shared service view definition specifies a service called Led which represents a hardware component of a device as identified by the tag or annotation device component . The example shared service view definition exports three services ledOn ledOff and ledToggle that any hardware LED component supports. An application service can run on specific devices and can provide a set of services. Below an example of an application service is shown 

In the above example of an application service definition CollectTempRHSVC defines an application service. CollectTempRHSVC exports services such as start stop getTemp and getAvgTempValue that can be used by other software components. For instance an invocation of a service getTemp returns the current temperature as sensed by the end user or other device.

A distributed program is thus defined by a set of shared data views extended data views and shared service definitions that specify and enable a compiler to automatically generate the program executed at each device.

In a particular embodiment a WSN application generation system receives as input a specific shared data view shared service view and extended view. In conformity with these views the WSN application generation system can generate an entire WSN application system. In a particular embodiment and referring to the example embodiments shown in the operation of the WSN application generation system includes the operations described below.

In one embodiment a device compiler reads the shared view and the device view and builds a customized software environment for different systems of the embedded devices of network . Device compiler uses the shared view and the device view to configure the system software stack that is needed to run on different devices of the embedded devices of network .

The compiler can use the shared and extended data views and service views to generate different software stacks for system devices. Referring again to the specific example shared data view described above the compiler can use the example shared data view TempRHSchema to automatically generate a relational table as follows 

In addition the compiler can also automatically generate queries to store retrieve and delete specific tuples from the TBL TempRHSchema defined in the example above.

As shown in the example of and described above device compiler can generate a customized software stack which is customized thr each device of the embedded devices of network by system configurator . As shown in system configurator can use the device software stack generated by device compiler to generate a customized software stack for gateway device of sensor network . The customized software stack includes an application layer APPL A a middleware layer MDLWR A and an operating system layer OPSYS A . In the example shown in each of the layers of software stack can be configured with a specific set of software components designated set A that provide the data and service elements specified for gateway device by the device view and the shared view .

In a similar manner system configurator can use the device software stack generated by device compiler to generate a customized software stack for sensor device of sensor network . The customized software stack includes an application layer APPL A a middleware layer MDLWR A and an operating system layer OPSYS A . In the example shown in each of the layers of software stack can be configured with a specific set of software components designated set A that provide the data and service elements specified for sensor device by the device view and the shared view .

The system configurator can also use the device software stack generated by device compiler to generate a customized software stack for sensor device of sensor network . The customized software stack includes an application layer APPL A a middleware layer MDLWR B and an operating system layer OPSYS B . In the example shown in each of the layers of software stack can be configured with a specific set of software components that provide the data and service elements specified for sensor device by the device view and the shared view . In this case software stack includes the same application layer APPL A as software stacks and . However the middleware layer and operating system layer of software stack are different designated set B from the corresponding layers of software stacks and . This difference in the customized software stack produced for sensor by system configurator corresponds to the differences in the capabilities and responsibilities associated with sensor as specified in the device view and shared view .

The system configurator can also use the device software stack generated by device compiler to generate a customized software stack for sensor device of sensor network . The customized software stack includes an application layer APPL A a middleware layer MDLWR B and an operating system layer OPSYS C . In the example shown in each of the layers of software stack can be configured with a specific set of software components that provide the data and service elements specified for sensor device by the device view and the shared view . In this case software stack includes the same application layer APPL A as software stacks and and the same middleware layer MDLWR B as software stack . However the middleware layer and operating system layer of software stack are different from the corresponding layers of software stacks and . Further the operating system layer OPSYS C of software stack is different from the corresponding layer of software stack . This difference in the customized software stack produced for sensor by system configurator corresponds to the differences in the capabilities and responsibilities associated with sensor as specified in the device view and shared view .

In a similar manner system configurator can build customized software stacks for each of the devices of embedded network . These software stacks can include a unique set of software layers or the stacks may include layers in common with other device software stacks as shown in the example of .

Once the customized software stacks are generated as described above the customized software stacks can then be distributed to each of the corresponding nodes of network . The device compiler can also generate the code for serializing and de serializing the data on the devices of network .

In another operation of a particular embodiment a database compiler as shown in reads the shared view and the data view and generates a schema and database queries for storing modifying and accessing data entries produced by the embedded devices of network . The schema and database queries can be used by the database processor to provide system access to the data stored in data storage device .

In another operation of a particular embodiment a GUI compiler as shown in reads the shared view and the GUI alert view and generates a visualization schema and an alert system from the GUI alert view .

In yet another operation of a particular embodiment a web services compiler as shown in reads the shared view and the web services view and generates a web services proxy which translates web services protocol into a protocol compatible with the WSN system.

The approach as described in various embodiments herein has several advantages. Firstly the WSN application generation system of various embodiments is platform independent. Secondly the system provides a high level programming model. This model enables the system to automatically generate much of the system software code and plumbing or interoperability code which eliminates data inconsistency and coding errors between embedded and service components. The approach also eliminates code duplication and reduces manual coding and integration efforts.

Applications that may include the apparatus and systems of various embodiments broadly include a variety of electronic and computer systems. Some embodiments implement functions in two or more specific interconnected hardware modules or devices with related control and data signals communicated between and through the modules or as portions of an application specific integrated circuit. Thus the example system is applicable to software firmware and hardware implementations.

In example embodiments a node configured by an application may constitute a module that is configured and operates to perform certain operations as described herein. In other embodiments the module may be implemented mechanically or electronically. For example a module may comprise dedicated circuitry or logic that is permanently configured e.g. within a special purpose processor to perform certain operations. A module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a module mechanically in the dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations. Accordingly the term module should be understood to encompass a functional entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein.

While the machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single non transitory computer readable storage medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies described herein. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media.

As noted the software and or related data may be transmitted over a network using a transmission medium. The term transmission medium shall be taken to include any medium that is capable of storing encoding or carrying instructions for transmission to and execution by the machine and includes digital or analog communication signals or other intangible media to facilitate transmission and communication of such software and or data.

The illustrations of embodiments described herein are intended to provide a general understanding of the structure of various embodiments and they are not intended to serve as a complete description of all the elements and features of components and systems that might make use of the structures described herein. Many other embodiments will be apparent to those of ordinary skill in the art upon reviewing the description provided herein. Other embodiments may be utilized and derived such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. The figures herein are merely representational and may not be drawn to scale. Certain proportions thereof may be exaggerated while others may be minimized. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

The description herein may include terms such as up down upper lower first second etc. that are used for descriptive purposes only and are not to be construed as limiting. The elements materials geometries dimensions and sequence of operations may all be varied to suit particular applications. Parts of some embodiments may be included in or substituted for those of other embodiments. While the foregoing examples of dimensions and ranges are considered typical the various embodiments are not limited to such dimensions or ranges.

The Abstract is provided to comply with 37 C.F.R. 1.74 b to allow the reader to quickly ascertain the nature and gist of the technical disclosure. The Abstract is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims.

In the foregoing Detailed Description various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments have more features than are expressly recited in each claim. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separate embodiment.

Thus as described above an apparatus and method for building integrated distributed applications for use with a mesh network is disclosed. Although the disclosed subject matter has been described with reference to several example embodiments it may be understood that the words that have been used are words of description and illustration rather than words of limitation. Changes may be made within the purview of the appended claims as presently stated and as amended without departing from the scope and spirit of the disclosed subject matter in all its aspects. Although the disclosed subject matter has been described with reference to particular means materials and embodiments the disclosed subject matter is not intended to be limited to the particulars disclosed rather the subject matter extends to all functionally equivalent structures methods and uses such as are within the scope of the appended claims.

