---

title: Two-factor USB authentication token
abstract: The present patent application discloses a USB token that advantageously mimics a human interface device such as a keyboard in interacting with a host computer, thus removing the need for pre-installation of a dedicated device driver. This is accomplished by requiring the host computer to direct the input of the attached human interface devices of the keyboard type, including the USB token, exclusively to the program interacting with the USB token, by using cryptographic algorithms based on a shared secret, which require less data to be transferred than PKI-based algorithms, and by employing an efficient encoding scheme that minimizes the time needed to exchange information with the USB token, and minimizes the probability of generating ambiguity with input that might legitimately be generated by other attached human interface devices. By using only symmetric encryption and the low-speed USB protocol, a single low-performance processor may be used, which results in a more cost-effective solution than PKI USB tokens emulating the combination of smart cards and smart card readers or USB tokens presenting themselves to the host computer as mass storage devices. The overall security is increased by adding a second authentication factor consisting of a static password entered by the user, and by limiting the number of valid token response that can be generated or retrieved in a usage session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214888&OS=08214888&RS=08214888
owner: Vasco Data Security, Inc.
number: 08214888
owner_city: Oakbrook Terrace
owner_country: US
publication_date: 20080613
---
This application claims the benefit of the priority date of U.S. provisional patent application no. 61 006767 of Jan. 30 2008 the entirety of which is incorporated by this reference.

The invention relates to securing remote access to computers and applications and remote transactions over computer networks. More specifically the invention relates to client authentication and transaction signature capabilities using a two factor USB authentication token.

As remote access of computer systems and applications grows in popularity the number and variety of transactions which are accessed remotely over public networks such as the Internet has increased dramatically. This popularity has underlined a need for security in particular authentication and data integrity. Authentication deals with ensuring that people who are remotely accessing an application are who they claim they are and ensuring that the transactions being conducted remotely are initiated by legitimate individuals. Data integrity deals with ensuring that transaction data has not been altered before being received at an application server.

In the past application providers have relied on static passwords as client credentials to provide the security for remote applications. In recent years it has become evident that static passwords are not sufficient and that more advanced security technology is required.

Several software or hardware based solutions have been devised to provide a higher level of security. The most important ones are hardware based strong authentication tokens smart cards USB tokens and authentication software. These solutions and their respective advantages and disadvantages will be discussed in the following paragraphs.

A hardware based strong authentication token is a pocket size battery powered device with its own display and keypad. In some cases the keypad is reduced to a single button or even completely omitted. The main purpose of a strong authentication token is to generate so called One Time Passwords OTPs as client credentials. In some cases strong authentication tokens are also capable of generating electronic signatures or Message Authentication Codes MACs on data that has been entered on the token s keypad these signatures and MACs are also considered to be covered by the term client credentials . If the token has a keypad the usage of the token is often protected by a personal identification number PIN . To be able to generate OTPs or MACs strong authentication tokens are capable of performing cryptographic calculations on a dynamic variable such as a time indicator a counter a challenge or transaction data based on symmetric cryptographic algorithms parameterized with a secret value or key. Typical examples of such symmetric cryptographic algorithms parameterized with a secret value or key are symmetric encryption decryption algorithms such as DES Data Encryption Standard 3DES Triple Data Encryption Standard or AES Advanced Encryption Standard and or keyed one way hash functions such as MD5 or SHA 1 in OATH compliant tokens .

The advantages of hardware based strong authentication tokens include a very high level of security independence of application and independence of delivery channel there is no need to install any driver .

Disadvantages include a certain minimum size and volume due to the presence of display battery and keypad a certain minimum cost due to the presence of those same elements and practical limitations on the nature and size of data that can be signed because all data needs to be manually input by the user on a keypad which is usually numerical .

Smart cards are essentially microprocessors embedded in a credit card sized piece of plastic. They are often capable of performing sophisticated cryptographic algorithms. Examples include so called EMV compliant bank cards EMV is the abbreviation of Europay Mastercard Visa to secure payments and PKI Public Key Infrastructure cards capable of making generic digital signatures on any kind of electronic data.

Advantages of smart cards include a high level of security broad applicability to a wide range of applications securing payments protecting e mail computer login signing electronic documents . . . and a very practical form factor they can be carried along with credit cards in a wallet .

Disadvantages include a complex technical interface requiring specific command structures and drivers dependence on specific reader infrastructure which very often means that end users have to install smart card readers on their client computers which is not always possible and relatively high direct and indirect costs.

USB Universal Serial Bus authentication tokens try to overcome some of the major disadvantages of smart cards by combining into a single hardware device the functions of both a smart card reader and a smart card. Usually such USB tokens offer the same functionality as PKI enabled smart cards. USB tokens interact with a host according to the USB specification USB Implementers Forum. Universal Serial Bus Specification Revision 2.0. Compaq Computer Corporation et al. 2000. .

Disadvantages of USB tokens include the need to install a driver prior to use specific security issues once connected and unlocked malicious software can ask the token to perform security sensitive operations without the user noticing and for PKI based USB tokens high cost and a need for large amounts of data to be exchanged.

Several software only security solutions exist whereby all cryptographic operations are done on the user s PC instead of in dedicated hardware. One example of such software solutions is comprised of so called software certificates whereby a PKI private key and certificate are stored in a software repository. Another example is comprised of so called software tokens which emulate in software the functionality of hardware strong authentication tokens.

By avoiding the need for hardware these software solutions try to circumvent the cost and complexity often associated with rolling out hardware solutions. However since the cryptographic calculations take place on the user s PC all secret keys involved in these calculations must appear in the clear at least at some time on this PC. This makes software solutions inherently less secure. Another disadvantage of software solutions is that quite often they rely on a file with cryptographic secrets being present on the client PC. This considerably reduces the ability of the user to work from any client PC mobility .

What is needed is an authentication and signature solution that combines the advantages of the solutions described above 

USB tokens come close to meeting all goals the main remaining impediment being the requirement to preinstall a dedicated driver on the host computer prior to using a USB token. This disadvantage is well known and some work arounds are known in the art. The Driverless USB Security Token invented by Laszlo Elteto et al. and disclosed in US 20040098596 A RAINBOW TECHNOLOGIES INC. Nov. 10 2003 avoids the issue by making the USB token mimic the behavior of a class of devices for which a pre installed driver is included in the host computer s operating system. These classes include. USB hubs mass storage devices and human interface devices HIDs . It can be foreseen that in some contexts the use of detachable portable mass storage devices would be disabled for security reasons e.g. to avoid illicit copying by users of information stored on the host computer s fixed storage media. Such a policy obviously also disables the use of USB tokens relying on the driver for USB mass storage devices such as those proposed by Elteto et al.

Under the USB architecture human interface devices operate according to the Device Class Definition for Human Interface Devices USB Implementers Forum. Device Class Definition for Human Interface Devices HID Version 1.11. USB Implementers Forum 2001. . With respect to the emulation of human interface devices Elteto et al. state that although the token can emulate a variety of HIDs it should not ordinarily emulate a keyboard or mouse as that would interfere with the normal use of the computer . 

The present invention is based on the insight that contrary to the opinions found in the prior art a USB authentication token can advantageously mimic a human interface device such as a keyboard in interacting with a host computer thus removing the need for pre installation of a dedicated device driver. The present invention accomplishes this by 1 requiring the host computer to direct the input of the attached human interface devices of the keyboard type including the USB token exclusively to the program interacting with the USB token by 2 arranging the token to use cryptographic algorithms based on a shared secret which require less data to be transferred than PKI based algorithms and by 3 employing an efficient encoding scheme that a minimizes the time needed to exchange information with the USB token and b minimizes the probability of generating ambiguity with input that might legitimately be generated by an attached human interface device or devices. It is furthermore advantageous to reduce the length of any messages sent from the host computer to the token and therefore the maximum entropy of the dynamic value that can be encoded within such a token message to be as small as the required security allows so as to minimize the transfer time and maximize the user experience.

The present invention is further based on the insight that the usage of only symmetric encryption and the low speed USB protocol permits the usage of a single low performance processor which results in a more cost effective solution than PKI USB tokens emulating the combination of smart cards and smart card readers or USB tokens presenting themselves to the host computer as mass storage devices.

In a multi tasking operating system with a graphical user interface the keyboard focus property determines which program or application window receives information about the user s keystrokes. This is an essential concept to allow multiple programs to run simultaneously and share a single set of human interface devices without messing up the input to all these programs. The requirement that the host computer direct the input of the attached keyboards and emulated keyboards to the running instance of the program interacting with the USB token comes down to capturing the keyboard focus. This can be accomplished by requesting the keyboard focus by means of an API call of the operating system e.g. in Java 1.4 and greater using the Component.requestFocus method and by subsequently monitoring the state of the keyboard focus to make sure that focus is being retained. Only if the focus is retained for the entire duration of the incoming message can one be sure that no parts of the message got lost i.e. got sent to other running programs .

Authentication algorithms using a dynamic variable and based on shared secrets may consist of encrypting the dynamic variable with a well known symmetric cipher such as DES 3DES AES RC4 blowfish and twofish or hashing the dynamic variable with a keyed hash algorithm such as SHA and HMAC using the shared secret as the key. These examples are not limitative as it shall be obvious for someone skilled in the art that many other methods and algorithms exist to cryptographically combine a dynamic variable with a secret shared between client and server. By judiciously combining the cryptographic operations a best of both worlds solution can be designed that reuses existing static password verification infrastructure while adding a strong authentication front end based on the shared secret in the token and a dynamic variable which may be presented by the server . The present invention achieves this by including an encrypted static password in the dynamic client credential the encryption key for which is cryptographically derived from the dynamic variable and the shared secret. This aspect makes the token according to the invention a very attractive choice for migrating existing static password based services to a strong authentication platform.

The requirements of the encoding scheme can be achieved according to the encoding presented in the preferred embodiment. A USB token according to the invention behaves as a Keyboard member of the Human Interface Device HID class. Hence two relevant layers can be distinguished in the communication protocol between the USB token according to the invention and the host computer the standard USB HID Keyboard Device protocol and a layer specific to this invention hereinafter called the Key Stroke Protocol . The Key Stroke Protocol is used to transport the Command and Response packets by means of this standard system keyboard functionality. The data link and the transport mechanism are different for outgoing messages from the client application to the USB token according to the invention and incoming messages from the USB token according to the invention to the client application . The Data Link Layer Protocol for the outgoing messages is a bit oriented protocol whereby message transport is realized through the simulation of CAPS NUM and SCROLL Lock keystrokes by the client application. Any such change in the state of CAPS NUM and SCROLL is broadcast by the System Keyboard driver to all attached keyboards including the USB token according to the invention. These broadcast state changes are used to construct outgoing data frames that contain Command messages. The transport of incoming messages uses keystrokes sent by the USB token according to the invention and received by the client application. These keystrokes will build frames of incoming data that contain Response messages. In order to minimize the chance of providing nonsensical input to unintended recipients i.e. other applications running concurrently with the client application in a multitasking environment it is an option to restrict the keystrokes sent by the USB token to non printable characters. Conversely this restriction also reduces the chance that text being typed on an actual USB keyboard is mistaken by the client application for a USB token transmission. On the other hand it is also an option to restrict the keystrokes sent by the USB token to characters that can be generated by physical keystrokes on standard keyboards thus avoiding the risk of some operating systems filtering out certain emulated keystrokes which would prevent them from reaching the intended application.

It is an additional inventive aspect that the security level of a challenge response based authentication solution wherein the required user interaction is minimal and wherein the challenge entropy is relatively low can be increased by limiting the number of valid responses that can be generated or retrieved in a given time frame.

Two factor authentication systems augment the delivered level of security with respect to single factor authentication systems based on static passwords by providing security against theft and replay of static passwords. USB tokens are a cost effective way of realizing two factor authentication as they rely on the host computer for the interaction with the user they don t require a display or keypad and as they extract power from the USB interface they don t require a battery. By not requiring a keypad display or battery USB tokens can be produced at very low cost and can have smaller physical dimensions which makes them more convenient to transport.

A USB token without dedicated driver requirement is particularly easy to use because the user simply has to plug it into one of the USB ports of his computer and enter his static password no additional software has to be installed on the computer and many people are already familiar with USB sticks. This is a fortiori true for a USB token that uses a generic class driver for a class of USB drivers that can be assumed to be supported by a very wide range of computer systems and for which it is very unlikely that support will be disabled.

USB tokens according to the invention are even more cost effective by providing two factor authentication without the nice but expensive functions of storage asymmetric encryption and digital signatures PKI . Because of its support for strong symmetric cryptography and the hardware protection of the keys being used the device is capable of providing authentication and signature functions with a security level that is comparable to that of smart cards. The USB token according to the invention presents itself as a HID and hence it can use the low speed USB protocol . This in combination with symmetric cryptography allows an implementation by means of a single low performance microprocessor which lowers the cost for devices according to the invention. As the USB token according to the invention presents itself more specifically as a keyboard it is accessible from virtually any application including applications running inside a web browser e.g. Java applets regardless of local security settings.

USB tokens that are challenge response based and that limit the number of valid responses that can be generated or retrieved increase the overall security level by making it more difficult for attackers to compile a dictionary of valid challenge response pairs. This is especially valuable in cases where the length and thus the entropy of the challenges is relatively low in order to enhance the user experience by reducing the time needed to communicate the challenge from the host computer to the USB token.

The foregoing and other features and advantages of the invention will be apparent from the following more particular description of several embodiments of the invention as illustrated in the accompanying drawings.

The preferred embodiment of the present invention consists of an authentication and signature hardware device with the following features 

The preferred embodiment will be detailed with reference to where relevant and will be referred to as USB token . Where mention is made of the internals of USB token these will be detailed with reference to other figures where relevant. To clarify the functions of USB token the following usage scenario is offered as an example. When a user wants to authenticate himself to a certain server he might proceed as follows 

USB token shown as USB token in consists minimally of a microprocessor in a slim housing with a USB compatible connector to connect it to a host computer . In a typical embodiment the host computer would be the user s PC. The overall physical form factor is that of a USB device resembling the so called memory stick . In a typical embodiment USB token has no display or keypad. In one particular embodiment USB token is provided with a LED.

The at least one microprocessor has access to a non volatile memory containing at least some personalized data including at least one symmetric secret key. In some embodiments the personalized data can also include extra secret keys and or a serial number and or one or more PIN codes or passwords to protect access to the functionality of the preferred embodiment.

USB token is capable of performing at least one symmetric cryptographic algorithm. The terminology symmetric cryptographic algorithm should be understood in a broad sense. It includes all cryptographic algorithms whereby the same secret key is used to both generate a cryptogram and verify said generated cryptogram. In particular it includes keyed hashing algorithms.

USB token is a USB peripheral device that behaves as a Keyboard member of the Human Interface Device HID class. The behavior as Keyboard precludes the need to maintain and install a USB driver with the targeted Operating Systems Microsoft Windows 2000 and later Apple MacOS X and Linux with kernel version 2.6 and later .

USB token is intended to be interfaced from host computer resident application software. In a preferred embodiment this host computer resident application software takes the form of a Java applet that can be installed during a visit to the application or service provider web site.

Two relevant layers can be distinguished in the communication protocol between USB token and the Host Computer the standard USB HID Keyboard Device protocol and the layer specific to this invention hereinafter the Key Stroke protocol .

From the USB interface point of view USB token presents itself to the Host computer as a standard USB HID Keyboard Device. This implicates compatibility with the following aspects defined by the USB standard 

USB token presents itself as a standard USB HID keyboard device. This approach allows a client application to use USB token by invoking standard system keyboard functionality and using standard HID interactions and avoids the need to install a specific device driver. The Key Stroke Protocol is used to transport the Command and Response packets by means of this standard system keyboard functionality. It is responsible for the following 

The Key Stroke Protocol provides a data link on top of the standard keyboard functionality between the client application on the host computer and USB token . The data link and the transport mechanism are different for outgoing messages client application to USB token and incoming messages USB token to client application .

The Data Link Layer Protocol for the outgoing messages is a bit oriented protocol. The transport of outgoing messages is realized through the simulation of CAPS NUM and SCROLL Lock keystrokes by the client application. The transport mechanism relies on the principle that any change in the state of CAPS NUM and SCROLL is broadcast by the System Keyboard driver to all attached keyboards including USB token . These broadcast state changes are used to construct outgoing data frames that contain Command messages.

The transport of incoming messages uses emulated keystrokes sent by USB token and received by the client application. These keystrokes will build frames of incoming data that contain Response messages.

Outgoing messages are transmitted by changing the states of CAPS LOCK NUM LOCK and SCROLL LOCK. These state changes are forced by the client application posting keystrokes in the system keyboard queue. The system keyboard driver will then broadcast these changes to all attached keyboards. For a standard USB HID keyboard the CAPS LOCK NUM LOCK and SCROLL LOCK states are sent to the keyboard in the format of a Report out data packet. This is a data packet of 1 byte carrying 3 bits of information in the following format individual bits labeled b through b 

To transport a complete outgoing Key Stroke Message the Key Stroke Message is sent serially to USB token . Note that on some operating systems the system keyboard driver only broadcasts the lock states if at least one of the lock states is changed so every Report out data packet must contain at least one bit that has changed with respect to the previous Report out data packet. Note also that on some operating systems the system keyboard driver does not allow a client application to atomically change more than one lock state at a time i.e. separate keystrokes must be posted to change different lock states. This means that the change of more than one lock state can result in a broadcast from the keyboard driver to the attached keyboards of more than one Report out data packet.

The invention supports multiple transport modes. In some transport modes the Keystroke Protocol uses 1 or 2 bits of the Report out to transmit 1 or 2 bits of the serialized outgoing Key Stroke Message and uses a change in another bit of the Report out to ensure that there is at least one of the LOCK states that has changed so that a Report out is effectively generated and sent to the token and or to allow the token to distinguish which received Report out data packets are relevant and which have to be ignored.

The actions needed to serially send a Key Stroke Protocol Message to USB token using the 1 bit Key Stroke Protocol are illustrated in . Those actions consist of repeatedly setting the NUM lock state equal to the next data bit while toggling the CAPS lock state if and only if two identical data bits are to be sent consecutively as represented in by the operation of comparator XOR gate and unit delays and and inserting a wait time to allow the system to broadcast the updated lock states to the keyboards. In some embodiments the wait time insertion is replaced by an explicit confirmation step whereby the token sends a message to the host system to confirm receipt of a Report out message. In some particular embodiments the confirmation message contains a representation of the state of one or more of NUM lock CAPS lock and SCROLL lock that results from the received Report out message. In some particular embodiments the confirmation message is sent using scan codes that do not represent printable characters and that are hence very unlikely to interfere with any application that happens to have keyboard focus. Such keystrokes can include SHIFT CTRL ALT GR. In some other embodiments either a wait time insertion or an explicit confirmation step can be used for example depending on which part of the outgoing message is being sent. For example in some particular embodiments the wait time insertion can be used for the START flag While an explicit confirmation is used for the rest of the message.

The actions needed to serially send a Key Stroke Protocol Message to USB token using the 2 bit Key Stroke Protocol are illustrated in . They consist of sending a SCROLL lock sync packet leave NUM lock unchanged clear CAPS lock and then toggle SCROLL lock repeatedly setting the NUM lock and CAPS lock states from 2 data bits and while always toggling the SCROLL lock state the toggling being represented in by the operation of NOT gate and unit delay and inserting a wait time after posting every 2 bit frame to allow the system to broadcast the updated lock states to the keyboards by means of one or more Report out data packets. In some embodiments the wait time insertion is replaced by an explicit confirmation step whereby the token sends a message to the host system to confirm receipt of a Report out message or 2 bit frame. In some particular embodiments the confirmation message contains a representation of the state of one or more of NUM lock CAPS lock and SCROLL lock that results from the received Report out message. In some particular embodiments the confirmation message is sent using scan codes that do not represent printable characters and that are hence very unlikely to interfere with any application that happens to have keyboard focus. Such keystrokes can include SHIFT CTRL ALT GR. In some other embodiments either a wait time insertion or an explicit confirmation step can be used for example depending on which part of the outgoing message is being sent. For example in some particular embodiments the wait time insertion can be used for the START flag while an explicit confirmation is used for the rest of the message. The USB token only needs to consider the received Report out data packets of which the SCROLL lock state has toggled with respect to the SCROLL lock state of the previously received Report out data packet and can discard all other received Report out data packets. As long as the token has not yet received any Report out data packet the token has no way of knowing the actual lock states. This means that the actual lock states as assumed by the host computer and the lock states assumed by default by the token might be out of sync. If the SCROLL lock state of the token and the SCROLL lock state of the host computer are different when the first Report out data packet of the Key Stroke Protocol Message is sent the token will not perceive the change in the SCROLL lock state and therefore it will discard this first Report out data packet. This problem can be solved by transmitting at least one dummy bit prior to the START flag. By preference this dummy bit has a different value than the first bit of the START flag. In case the first START flag bit is a a SCROLL lock sync packet could be generated as follows leave NUM lock unchanged clear CAPS lock and then toggle SCROLL lock.

In another transport mode which can be seen as an improvement of the 1 bit Key Stroke Protocol the NUM lock state is set equal to the next data bit to be sent if the NUM lock state has thus been toggled the CAPS lock state and the SCROLL lock state are not toggled if however the NUM lock state has thus not been toggled either the CAPS lock state or the SCROLL lock state is toggled whereby the value of the data bit following the data bit coded in the NUM lock state determines whether the CAPS lock state or SCROLL lock state is toggled. For reasons similar to the reasons explained for the 2 bit Key Stroke Protocol also for this variant it is preferable that one or more sync packets are sent prior to sending the first bit of the START flag. Alternatively the START flag might be sent using the original 1 bit Key Stroke Protocol and only the data bits of the payload of the Key Stroke Protocol Message are sent using the coding just described.

In yet another transport mode the serialized outgoing Key Stroke Message is first encoded into a sequence of ternary symbols which is then converted into a sequence of Report out data packets where two consecutive Report out data packets always differ from one another in exactly one of the three lock states. The ternary symbol to be transported determines which of the three lock states is changed.

Whenever the time between 2 consecutive received Report out packets is larger than the current configured Inter Report Timeout the USB token will drop any frame in progress and reset its receiving state machine. Thereafter USB token resumes waiting for a start sequence.

The data returned by USB token to the Host System is carried across 8 bit data bytes in Output Reports following the Device Class Definition for USB Human Interface Devices HID .

The Data Link Layer Protocol is a byte oriented protocol that allows variable length messages delimited by special START and END bytes whereby the special START byte 0x01 defines the start of a Message Body and the special END byte 0x03 defines the end of a Message Body. A Response Message Body always starts with the CRC16 CCITT for the Command message that provoked the response message. A Response Message Body always ends with the CRC16 CCITT for all bytes in the Message Body starting with the Command CRC and up to the last Data Field byte. A Response Message Body always contains a Response ID in the first byte that follows the Command CRC. A Response Message Body may contain a Data Field of up to 16 bytes in length.

In the Response Message Body all data bytes that take value 0x01 and value 0x03 must be translated in order to avoid confusion with the START and END bytes. This is implemented using a Sequence Escape ESC byte 0x02 ASCII plus the bit wise complement of the original data byte. This mechanism is called byte stuffing . The data value 0x02 is also stuffed.

In general the method for generating client credentials for use in transactions with a server comprises generating in a client computer a token message encoding said token message as a series of keyboard status code updates sending said series of keyboard status code updates from said client computer to a USB token attached to said client computer using standard HID interactions receiving a token response from said USB token said token response including a dynamic client credential and said token response encoded as a series of emulated keyboard scan codes receiving said series of emulated keyboard scan codes using standard HID interactions.

In one embodiment of the present invention said step of generating a token message further includes encoding a dynamic value into said token message. In a particular embodiment the method further comprises the anterior step of receiving a dynamic value from said server. In another particular embodiment said dynamic value is combined with at least one of a password entered by a user and a time representation. In a specific embodiment this password is passed through a cryptographic function prior to said combining.

In one embodiment of the present invention said scan codes are chosen as codes which do not represent printable characters.

In a set of embodiments of the present invention the method further comprises monitoring the keyboard focus relating to said attached USB token during said receiving of said token response and said decoding is conditional upon said monitoring indicating that said keyboard focus was maintained during said receiving of said token response.

In some embodiments of the present invention the method further comprises the step of decoding said token response to retrieve a dynamic client credential. In some particular embodiments the method further comprises the step of deriving a second client credential from said retrieved client credential said second client credential to be used in a transaction with a server. In some other particular embodiments said derivation of said second client credential uses a static password entered by the user. In yet some other particular embodiments said derivation of said second client credential involves the encryption of a static password entered by the user using a symmetric cryptographic algorithm and a session key that is derived from said first client credential.

In some other embodiments said token response or at least a part of it or some representation of said dynamic client credential is used directly as a client credential or to derive a second client credential in ways similar to what has been described above.

In one embodiment of the present invention the client computer is a personal computer. In another embodiment of the present invention the client computer is a portable digital assistant PDA equipped with at least one USB port. In yet another embodiment of the present invention the client computer is a mobile telephone equipped with at least one USB port.

In general a computer program according to the invention to prepare a dynamic client credential for use in a transaction with a server sends a token message to an attached USB token said attached USB token emulating a human interface device and receives a response comprising a client credential from said attached USB token said response being encoded as emulated keyboard scan codes.

In one embodiment of the present invention said token message includes a dynamic value. In a particular embodiment the computer program first receives the dynamic value from said server. In another particular embodiment said dynamic value is combined with at least one of a password entered by a user and a time representation. In a specific embodiment this password is passed through a cryptographic function prior to said combining.

In one embodiment of the present invention said scan codes are selected as codes which do not represent printable characters.

In one set of embodiments of the present invention said program further requests and verifies possession of the keyboard input focus for the duration of said receiving. In a particular embodiment said requesting and verifying is done by means of calls to dedicated functions in the application programming interface API of the client computer s operating system.

In some embodiments of the present invention the program further derives a second client credential from said client credential said second client credential to be used in a transaction with a server. In some particular embodiments said derivation of said second client credential uses a static password entered by the user. In some other particular embodiments said derivation of said second client credential involves the encryption of a static password entered by the user using a symmetric cryptographic algorithm and a session key that is derived from said first client credential.

In one embodiment of the present invention the program is a Java applet. In another embodiment of the present invention the program is an ActiveX applet. In yet another embodiment of the present invention the program is a stand alone executable.

In general an apparatus according to the invention for generating client credentials for use in transactions with a server comprises a USB interface such as for interacting with a computer through emulation of a human interface device a memory such as for storing a secret shared with said server and an agent such as for generating a client credential in response to a token message received from said computer through said USB interface. The client credential may be based on at least said secret and at least a dynamic value said token message being received as a message comprising keyboard status codes and said agent creating said client credential which is sent by means of a message comprising keyboard scan codes.

In one set of embodiments of the present invention illustrated in the apparatus further comprises a decoder to extract said dynamic value from said token message in addition to the aforementioned USB interface memory and agent . In a particular embodiment said dynamic value depends on data related to the transaction that is to be authorized by means of said client credential. In another set of embodiments of the present invention illustrated in the apparatus further comprises an event tracker the status of which is used to derive said dynamic value in addition to the aforementioned USB interface memory and agent . In one particular embodiment said event tracker is a counter. In another particular embodiment said event tracker is a clock.

In still another set of embodiments of the present invention said apparatus comprises a decoder and an event tracker and said agent derives said dynamic value from a combination of at least a value extracted by said decoder from said token message and the status of said event tracker.

In one embodiment of the present invention said scan codes are selected as codes which do not represent printable characters.

One embodiment of the present invention is also adapted to receive an information retrieval request as a message comprising keyboard status codes and to send a response to said information retrieval request as a message comprising keyboard scan codes. In a particular embodiment said information retrieval request pertains to production related data. In another particular embodiment said information retrieval request pertains to deployment related data.

In one set of embodiments of the present invention said client credential is further based on a password received from said computer through said USB interface wherein said password is received as a message comprising keyboard status codes. In some particular embodiments said client credential consists of a response and a ciphertext said response being a first part of a cryptogram generated by encrypting said dynamic variable using a first cryptographic algorithm with said secret as a key and said ciphertext being the encryption of said password using a second cryptographic algorithm and a second part of said cryptogram as a key. In a very particular embodiment said first cryptographic algorithm is 3DES and said second cryptographic algorithm is DES CBC. In some embodiments said password depends on data related to the transaction that is to be authorized by means of said client credential.

In one embodiment of the present invention said agent for generating credentials based on at least said secret and at least said dynamic value is a microprocessor. In another embodiment of the present invention said agent for generating credentials based on at least said secret and at least said dynamic value is an application specific integrated circuit ASIC . In yet another embodiment of the present invention said agent for generating credentials based on at least said secret and at least said dynamic value is a programmable semiconductor device.

In some embodiments of the present invention said generating a dynamic client credential in response to a token message takes into account the time that has passed since an event which may be inter alia the sending of a client credential or the powering up of the apparatus or both. In some particular embodiments a response containing an error indication is returned if insufficient time in comparison to a minimum time has passed since the last such event. In other particular embodiments a delay in sending said client credential is inserted until a minimum amount of time has passed from the last such event. In yet other particular embodiments the generation of said client credential involves an indication of the fact that insufficient time in comparison to a minimum time has passed since the last such event. In still other particular embodiments an invalid client credential is generated if insufficient time in comparison to a minimum time has passed since the last such event. In some embodiments the minimum time that must have passed evolves dynamically in function of the usage history since the last time that the apparatus has been powered on. In a particular embodiment the apparatus must be powered off and powered on again after a certain number of responses have been generated. In some other embodiments the minimum time between two response generations increases and is decreased again only if a sufficiently long time substantially longer than the minimum time has elapsed since the previous client credential generation.

The concept of taking into account the time that has passed since an event is also useful outside the context of USB tokens that interact with a computer through emulation of a human interface especially when the entropy of the generated credential is relatively low. In a general alternative embodiment of that aspect of the invention the apparatus for generating client credentials for use in transactions with a server comprises an interface for interacting with a computer a memory for storing a secret shared with said server and an agent for generating a client credential in response to a token message received from said computer through said interface based on at least said secret and at least a dynamic value wherein said generating a dynamic client credential in response to a token message takes into account the time that has passed since an event which may be inter alia the sending of a client credential or the powering up of the apparatus or both. In some particular embodiments a response containing an error indication is returned if insufficient time in comparison to a minimum time has passed since the last such event. In other particular embodiments a delay in sending said client credential is inserted until a minimum amount of time has passed from the last such event. In yet other particular embodiments the generation of said client credential involves an indication of the fact that insufficient time in comparison to a minimum time has passed since the last such event. In still other particular embodiments an invalid client credential is generated if insufficient time in comparison to a minimum time has passed since the last such event. In some embodiments the minimum time that must have passed evolves dynamically in function of the usage history since the last time that the apparatus has been powered on. In a particular embodiment the apparatus must be powered off and powered on again after a certain number of responses have been generated. In some other embodiments the minimum time between two response generations increases and is decreased again only if a sufficiently long time substantially longer than the minimum time has elapsed since the previous client credential generation. In another general embodiment the apparatus is responsive to a command that blocks further generating of client credentials until a certain release event takes place or until a certain time has elapsed from a certain release event. In one embodiment said release event is a removal and reinsertion of the apparatus into the host computer s interface. In another embodiment said release event is a power off power on cycle of the apparatus. In yet another embodiment the apparatus further comprises a release button and the release event is said button being pressed. In yet another embodiment the apparatus is adapted to include a counter value in the token response message such that the authenticating entity can reject any client credential with a counter value outside a predetermined range such a range exception being indicative of a replay or preplay attack.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

