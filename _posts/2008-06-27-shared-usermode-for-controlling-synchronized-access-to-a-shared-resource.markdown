---

title: Shared user-mode for controlling synchronized access to a shared resource
abstract: Technologies are described herein for implementing shared locks for controlling synchronized access to a shared resource. In one method, in a user mode of an operating system, a notification is received indicating that a first process begins execution. The first process is adapted to acquire the shared lock during execution of the first process. Upon receiving the notification, it is determined whether the first process terminates execution without releasing the shared lock. Upon determining that the first process terminates execution without releasing the shared lock, the shared lock is released for access by a second process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938738&OS=08938738&RS=08938738
owner: Microsoft Corporation
number: 08938738
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
In many information processing applications multiple executing entities attempt to access data concurrently. In one example in an email application multiple processes may attempt to access emails profiles stores and other related data at the same time. In this case a single program executes multiple threads concurrently accessing the same data. In another example in a database application multiple users may attempt to access the same database tables records and fields at the same time. In this case multiple programs operated by multiple users may concurrently access the same data. As used herein an entity may refer to processes threads tasks processors programming objects and the like.

Concurrent access to the same data if left uncontrolled can potentially lead to data corruption. For example consider the following scenario in which two computers A and B both attempt to remove one item from inventory by subtracting one from an inventory field in a database 

4. Computer A subtracts one from its local storage value two yielding a new local storage value of one.

5. Computer B subtracts one from its local storage value two yielding a new local storage value of one.

As indicated above the final inventory field value is one. However it is clear that the final inventory field value should be zero because two items have been removed from inventory. The illustrated scenario shows that two or more entities concurrently accessing the same data value may corrupt the value potentially leading to disastrous consequences.

Programmers have advanced a variety of approaches to address problems arising from concurrent processing. On a general level many programming systems provide synchronization services to provide certain guarantees in light of potential concurrency issues. For example some programming environments support simple synchronization mechanisms such as semaphores locks critical sections and mutual exclusion objects mutexes or mutex objects . Each of these mechanisms controls in one form or another concurrent access to a shared resource. Examples of mutex objects include mutex objects an implementation of which is provided as part of the WIN32 application programming interface within the WINDOWS operating system also from MICROSOFT CORPORATION. Many WINDOWS based programs such as email and database computer applications utilize these mutex objects for synchronizing access to various shared data.

Mutex objects synchronize access to a shared resource such as shared memory from multiple processes executing on a single machine. Generally mutex objects are kernel objects. A kernel object is a memory block allocated by the kernel and is accessible only by the kernel. As such computer applications operating in user mode are typically transitioned to kernel mode before mutex objects can be utilized. This transition between user mode and kernel mode can result in significant overall performance cost especially when mutex objects are often utilized.

Technologies are described herein for providing user mode shared locks. In particular through the utilization of the technologies and concepts presented herein user mode shared locks are provided that can replace conventional kernel mode mutex objects when multiple processes concurrently access the same shared resource such as shared memory. These shared locks are adapted to provide much of the same functionality as mutex objects except that shared locks operate in user mode instead of kernel mode. As a result in contrast with the mutex objects the shared locks may provide at least a reduction in performance cost caused by transitions between user mode and kernel mode especially when little or no contention is on the shared locks.

According to one aspect presented herein a methodology is provided for implementing shared locks for controlling synchronized access to a shared resource. In a user mode of an operating system a second process receives a notification indicating that a first process begins execution. The first process may be adapted to acquire the shared lock during execution of the first process. Upon receiving the notification the second process determines whether the first process terminates execution without releasing the shared lock. Upon determining that the first process terminates execution without releasing the shared lock the second process releases the shared lock on behalf of the first process i.e. the terminating process such that the shared lock can be acquired by a second process or any other process capable of utilizing the shared lock.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended that this Summary be used to limit the scope of the claimed subject matter. Furthermore the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.

The following detailed description is directed to technologies for providing user mode shared locks. Through the utilization of the technologies and concepts presented herein user mode shared locks are provided that can replace conventional kernel mode mutex objects when multiple processes concurrently access the same shared resource such as shared memory. These shared locks are adapted to provide much of the same functionality as mutex objects except that shared locks operate in user mode instead of kernel mode. That is in contrast with the mutex objects a transition between user mode and kernel mode is not required to acquire the shared lock. As a result performance cost caused by transitions between user mode and kernel mode can be reduced or eliminated by operating shared locks in place of mutex objects. It should be understood however that even with shared locks a transition from user mode to kernel mode may occur when the shared lock is busy having been acquired by another user.

As used herein a conventional lock in contrast with a user mode shared lock as described in greater below refers to a mechanism for synchronizing access to a shared resource by multiple threads within a single process. When one thread desires to access the shared resource the thread acquires the lock which prevents other threads from accessing the shared resource. Once the thread finishes executing the thread releases the lock so that other threads may access the lock. Locks generally operate entirely in user mode and therefore do not suffer performance costs arising from transitioning between user mode and kernel mode. Unlike mutex objects however locks can only be used by one process at a time primarily due to security issues with operating in user mode. As such locks are typically not suitable for situations where multiple processes concurrently access a shared resource.

Embodiments described below introduce the concept of user mode shared locks. In contrast with conventional locks shared locks are capable of synchronizing access to a shared resource by multiple processes. In one embodiment a linked list is utilized to enable a first process to monitor a second process to determine whether the second process has terminated. Further shared locks operate in user mode which reduces or eliminates any performance cost caused by transitioning between user mode and kernel mode.

While the subject matter described herein is presented in the general context of program modules that execute in conjunction with the execution of an operating system and application programs on a computer system those skilled in the art will recognize that other implementations may be performed in combination with other types of program modules. Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the subject matter described herein may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

In the following detailed description references are made to the accompanying drawings that form a part hereof and which are shown by way of illustration specific embodiments or examples. Referring now to the drawings in which like numerals represent like elements through the several figures aspects of a computing system and methodology for implementing shared locks will be described. illustrates a computer implementing a shared lock as a replacement for conventional mutex objects. In contrast to the shared lock also illustrates a plurality of conventional locks A C which are denoted by dashed lines.

It should be appreciated that the conventional locks A C are shown merely as a reference to contrast the operation of the shared lock according to embodiments. The first lock A is associated with threads A B executing in a first process A. The second lock B is associated with threads C D executing in a second process B. The third lock C is associated with threads E F executing in a third process C. While only three processes each of which includes two threads are illustrated in it should be appreciated that the computer may include any number of processes and threads.

As illustrated in each of the locks A C is implemented by only one process. For example the first lock A can be utilized by the threads A B executing in the first process A but cannot be utilized by the threads C F executing in the second process B and the third process C. As such the locks A C are suitable for handling only synchronized access to a resource by multiple threads within the same process. The locks A C are not suitable for handling synchronized access to a shared resource by separate processes.

Additional details will now be provided regarding the shared lock . For the sake of simplicity only one shared lock is illustrated in . However it should be appreciated that multiple shared locks may be utilized in other implementations to control access to multiple shared resources. As previously discussed the conventional mutex object can be replaced by the shared lock according to embodiments. As illustrated in the processes A C can access the shared lock .

Further the processes A C are adapted to monitor each other in a manner similar to a circular linked list referred to herein as a circular linked list configuration . As such if one process terminates another process will be adapted to monitor the terminated process and will therefore be able to clean up any abandoned locks resulting from the terminated process. For example the second process B monitors the first process A as denoted by a first pointer A and the third process C monitors the second process B as denoted by a second pointer B. The first process A monitors the third process C as denoted a third pointer C. It should be appreciated that the pointers A and B C are shown merely to illustrate an exemplary implementation of the circular linked list configuration in which the processes A C monitor each other. The processes A C may or may not be connected or linked in any other manner like an actual circular linked list.

It should further be appreciated that the circular linked list configuration does not necessarily ensure a predefined order for acquiring the shared lock . For example if two threads are waiting for the shared lock the circular linked list configuration does not ensure that either thread has priority for acquiring the shared lock . In one embodiment a fair lock mechanism may be implemented to ensure that one thread has priority to acquire the shared lock over another thread. The fair lock mechanism may be implemented based on first in first out FIFO ordering in which the first thread that reserves the shared lock is the first thread to acquire the shared lock .

With conventional mutex objects an operating system will be aware when a process starts and ends. This information is made available through kernel mode. However since the shared lock operates entirely in user mode there is a goal to detect when a process terminates abnormally. Thus the second process B may be configured to monitor at least the first process A. Likewise the third process C may be configured to monitor at least the second process B and the first process A may be configured to monitor at least the third process C. In one embodiment the responsibility for the processes A C to monitor the other processes A C is determined by a circular linked list configuration as previously described. In another embodiment a master process as illustrated in the computer of may be configured to monitor the processes A C and arbitrate access to the shared lock . As illustrated in the pointers A C may be removed when the master process is utilized because the master process handles the monitoring responsibility.

Referring again to in an illustrative scenario the first process A acquires the shared lock which controls access to data stored in a portion of memory. In one embodiment the linked list configuration is built prior to the first process A acquiring the shared lock . Thus each of the processes A C is aware of its responsibility for monitoring other processes before the first process A acquires the shared lock . As illustrated in the second process B is monitoring the first process A. In other implementations the third process C may also monitor the first process A.

It should be appreciated that processes can be added to the linked list configuration at a later time i.e. when another process is started by the user . The new process may notify other processes about its creation via a broadcast message before acquiring the shared lock . Alternatively the new process may notify the master process instead of all of the other processes. The new process may also start to monitor one of the other processes before acquiring the shared lock . In one embodiment the methodology that all processes use to determine who monitors whom is based on program security identifier PSID ordering. The PSID ordering ensures that processes will be able to build a correct circular linked list configuration in which each process is monitored by one or more other processes.

In normal operation the first process A will finish executing and then release the shared lock . However if the first process A abnormally terminates then the first process A will fail to release the shared lock . In this case the second process B will recognize that the first process A abnormally terminated and subsequently will release the shared lock e.g. transition the shared lock from a busy state to an abandoned state . Upon the release of the shared lock either through normal operation or abnormal termination the second process B or the third process C can acquire the shared lock by transitioning the shared lock from the abandoned state to the busy state.

If the second process B acquires the shared lock the third process C then begins to monitor the second process B to determine if the second process B abnormally terminates. The sequence of one process accessing the shared lock and the next process in the circular linked list configuration monitoring the previous process may continue until the every process in the circular linked list configuration has accessed the shared lock . In one embodiment processes may be associated with a suitable process identifier for identifying the processes with respect to the shared lock .

Referring now to additional details will be provided regarding the shared lock . In particular illustrates an exemplary data structure for implementing the shared lock . In one embodiment the data structure is stored on a computer readable storage medium which can then be executed on any suitable computer. Although not so limited the data structure in is written in the C programming language. It should also be appreciated that the data structure shown in is merely illustrative. It should be appreciated that other data structures and approaches for describing and implementing the shared lock may be contemplated by those skilled in the art. It should further be appreciated that the shared lock may reside in a shared memory accessible by all processes that use the shared lock .

As illustrated in the data structure includes an allocation index a first reference counter a PSID a second reference counter a compare and swap operation a thread ID and a recursion counter . The allocation index is a unique identifier that identifies the shared lock . In this way a plurality of shared locks can be identified and distinguished. The allocation index may be equivalent of a mutex name e.g. a number a string . The first reference counter is a reference counter indicating a total number of entities using the shared lock . An entity may be a thread a process an object or the like capable of using the shared lock .

The PSID and the second reference counter are contained in an embedded data structure as designated by the keyword STRUCT. The PSID is a unique identifier that identifies the process that has acquired the shared lock . Although not so limited the PSID is described in as a 32 bit integer as designated by the keyword ULONG. However the PSID may be any suitable string of characters and or numbers in other embodiments. In one embodiment the PSID is zero when the shared lock is not owned by any thread and is 0xffffffff when the shared lock is abandoned. The second reference counter is a reference counter indicating the number of outstanding threads waiting for the shared lock . The second reference counter is incremented as threads waiting for the shared lock are added. The second reference counter is decremented as the waiting threads acquire the shared lock or by timing out.

An illustrative operation of the second reference counter is as follows. Consider a first thread that currently owns the shared lock . When a second thread cannot acquire ownership of the shared lock e.g. the shared lock has been acquired by another thread the second thread increments the second reference counter . By incrementing the second reference counter the second thread informs the first thread that another thread is waiting to acquire the shared lock . When the first thread releases the shared lock the first thread checks the value of the second reference counter . If the value of the second reference counter is non zero the first thread informs the waiting threads that the shared lock is free to be acquired. The first thread may inform the waiting threads via an event object according to one embodiment. If the first thread abnormally abandons the shared lock another process can signal that the shared lock is free to be acquired.

The data structure is also combined with the compare and swap operation to form another embedded data structure as designated by the keyword UNION. The compare and swap operation atomically changes the PSID and the second reference counter . The thread ID is a unique identifier indicating the thread that currently owns the shared lock . The thread ID may be used to allow recursive lock entrance. The recursion counter is a counter indicating the number of times that the same thread has acquired the shared lock . In particular the recursion counter is incremented as the shared lock is acquired by a given function and the recursion counter is decremented as the shared lock is released by the function. Once the recursion counter reaches zero the shared lock is released and is accessible to other threads and processes.

Turning now to additional details will be provided regarding the operation of the shared lock . In particular shows a flow diagram illustrating aspects of one method provided herein for implementing the shared lock . It should be appreciated that the logical operations described herein are implemented 1 as a sequence of computer implemented acts or program modules running on a computing system and or 2 as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly the logical operations described herein are referred to variously as states operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. It should be appreciated that more or fewer operations may be performed than shown in the figures and described herein. These operations may also be performed in a different order than those described herein.

Referring to the diagram includes a first routine and a second routine . The first routine and the second routine each begin at operation . After operation the first routine branches to operations and the second routine branches to operations . The first routine and the second routine each begin at operation where the first process A sends a notification indicating that it is beginning execution. In one embodiment the notification is a broadcast message sent by the first process A to one or more of the other processes B C. In another embodiment the notification may be sent by the first process A to the master process . In other embodiments the notification may be sent via other suitable mechanisms. The notification may also be provided by an operating system or other suitable application. Upon the first process A sending the notification indicating that it is beginning execution the first routine proceeds to operation and the second routine proceeds to operation .

Referring to the second routine at operation the second process B or the master process receives the notification from the first process A. The second routine then proceeds to operation where the second process B or the master process monitors the first process A. In particular the second process B or the master process may monitor the first process A to determine whether the first process A terminates without releasing the shared lock.

For example referring to the first routine upon sending the notification that it is beginning execution at operation the first routine proceeds to operation where the first process A acquires the shared lock . For example the first process A may transition the shared lock from any previous state to a busy state. Upon acquiring the shared lock the first routine proceeds to operation . At operation the first process A executes and access the data associated with the shared lock . If the first process A successfully executes then the first routine proceeds to operation where the first process A releases the shared lock . However if the first process A abnormally terminates before completing execution then the first routine will not proceed to operation and the first process A will not release the shared lock . Without further intervention the other processes B C will not be aware that the shared lock is available.

Referring again to the second routine at operation the second process B or the master process as shown in will monitor the first process A until it terminates. Upon detecting that the first process A terminates the second routine proceeds to operation where the second process B or the master process determines whether the first process A abnormally terminated without releasing the shared lock . If the first process A terminates normally i.e. the first routine successfully performs the operation then the second routine ends. If the first process A abnormally terminates i.e. the first routine crashes at operation and does not proceed to operation then the second routine proceeds to operation . At operation the second process B or the master process releases the shared lock . For example the second process B or the master process may transition the shared lock from a busy state to an abandoned state. Once the shared lock is in the abandoned state other processes can access the shared lock .

Referring now to an exemplary computer architecture diagram showing aspects of a computer is illustrated. Examples of the computer may include computers . The computer includes a processing unit CPU a system memory and a system bus that couples the memory to the CPU . The computer further includes a mass storage device for storing one or more program modules and one or more databases . In one embodiment the program modules may be adapted to implement the data structure of . The program modules may also include an operating system. The mass storage device is connected to the CPU through a mass storage controller not shown connected to the bus . The mass storage device and its associated computer readable media provide non volatile storage for the computer . Although the description of computer readable media contained herein refers to a mass storage device such as a hard disk or CD ROM drive it should be appreciated by those skilled in the art that computer readable media can be any available computer storage media that can be accessed by the computer .

By way of example and not limitation computer readable media may include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer readable media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM digital versatile disks DVD HD DVD BLU RAY or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer .

According to various embodiments the computer may operate in a networked environment using logical connections to remote computers through a network . The computer may connect to the network through a network interface unit connected to the bus . It should be appreciated that the network interface unit may also be utilized to connect to other types of networks and remote computer systems. The computer may also include an input output controller for receiving and processing input from a number of input devices not shown including a keyboard a mouse a microphone and a game controller. Similarly the input output controller may provide output to a display or other type of output device not shown .

Based on the foregoing it should be appreciated that technologies for providing user mode shared locks are presented herein. Although the subject matter presented herein has been described in language specific to computer structural features methodological acts and computer readable media it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features acts or media described herein. Rather the specific features acts and mediums are disclosed as example forms of implementing the claims.

The subject matter described above is provided by way of illustration only and should not be construed as limiting. Various modifications and changes may be made to the subject matter described herein without following the example embodiments and applications illustrated and described and without departing from the true spirit and scope of the present invention which is set forth in the following claims.

