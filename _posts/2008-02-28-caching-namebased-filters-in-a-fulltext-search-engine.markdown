---

title: Caching name-based filters in a full-text search engine
abstract: Techniques for filtering a full-text search result in a full-text search engine level are described herein. According to one embodiment, in response to a search query received at an ORM system for a full-text search in a relational database, a full-text search engine is invoked to perform the requested full-text search based on the search query. A filter is utilized to filter a search result generated from the full-text search engine using a filter object representing a filter associated with the search query and returning the filtered result to the application client. Thereafter, the filter object is cached in a cache memory of the ORM system such that the cached filter object can be used in subsequent search queries without having to recreating the same filter object. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08612467&OS=08612467&RS=08612467
owner: Red Hat, Inc.
number: 08612467
owner_city: Raleigh
owner_country: US
publication_date: 20080228
---
The present invention relates generally to object relational mapping for accessing databases. More particularly this invention relates to filtering database accesses via object relational mapping.

Full text searching of data is becoming increasingly popular and significant in the computing world. For many years the information retrieval community has had to deal with the storage of documents and with the retrieval of documents based on one or more keywords. Since the burgeoning of the Internet and the feasibility of storing documents on line retrieval of documents based on keywords has become a complex problem. A search result may contain massive information. Typically a filter may be utilized to filter the search result to obtain narrower information based on a set of rules.

Typically an application client that initiates a full text search has to maintain the filter. That is when the application client submits a full text search query the application client has to create and maintain a filter throughout the search session. Otherwise the same filter has to be recreated in every search session. In addition a filter is typically represented by a filter object referenced by a filter object handle which an application programmer has to maintain and there is no human friendly reference.

In the following description numerous details are set forth to provide a more thorough explanation of the embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to certain embodiments a filter utilized by a full text search engine may be maintained by an object relational mapping ORM system. For example when a filter is created during a full text search session the filter may be cached within a cache memory of the ORM system. Upon a next full text search session the cached filter may be reutilized without having to recreate the same filter which has an impact on the performance e.g. speed .

In addition according to one embodiment a filter may be defined via a filter name and associated with a filter implementation. For example a filter may be defined in a filter definition file or section by a file name. The definition of the filter also identifies an implementation of the filter such as a filter factory or implementation class in an object oriented programming environment. That is when defining a filter for a full text search an application programmer may utilize any filter name he she likes and associates the filter name with a particular filter implementation class that is used to create and carry the functionality of the filter. Further according to one embodiment when defining a filter the definition statement also allows a programmer to indicate whether the corresponding filter should be cached within the ORM system such that the ORM system can cache and reuse the filter subsequently without having to recreate the same filter.

Referring to ORM provides data query and retrieval facilities that reduce development time which is designed to relieve a software developer from most of common data persistence related programming tasks by reducing the need for manual hand crafted data processing using SQL and JDBC Java database connectivity . The JDBC API is the industry standard for database independent connectivity between the Java programming language and a wide range of databases SQL databases and other tabular data sources such as spreadsheets or flat files.

According to one embodiment ORM includes but is not limited to a set of APIs to allow client to communicate with ORM a filter definition unit and corresponding filter implementation unit a filter caching unit and one or more filter objects representing one or more filters which may be created by ORM and cached within a cache memory not shown in the ORM .

When a search query for a full text search is received by ORM from client a full text search engine is invoked to perform the requested full text search in database . For example full text search engine may be an Apache Lucene compatible search engine. In addition dependent upon a specific configuration a filter object representing a filter may be created to filter a search result generated from the search engine according to certain rules or categories such as for example security temporal data e.g. view only last month s data population filter e.g. search limited to a given category etc. Thereafter the filter object may be cached by filter caching mechanism within a cache memory of ORM . Subsequently if the same filter is needed for subsequent search queries the filter object may be retrieved from the cache memory and reused without having to recreate the same filter. Thus contrary to a conventional system in which application client has to maintain the filter object in this example ORM is configured to maintain and manage the filter object on behalf of the client .

In addition according to one embodiment a filter is defined via a definition file or section using a filter name by filter definition unit . Each filter definition is also associated by the filter implementation unit with a filter implementation or factory that actually creates and or implements the functionality of the filter. As a result an application programmer of client can name a filter to any name that he she feels comfortable e.g. easy to remember and does not have to remember the binary number representing a handle of a filter object. Further by referencing a filter via a filter name it is easier to configure a filter such as for example setting a particular parameter of a particular filter during a full text search. Note that some or all components or units as shown in may be implemented in software hardware or a combination of both. More or fewer components may be implemented and other configurations may exist.

Framework includes a variety of components. For example session factory is configured to provide a thread safe immutable cache of compiled mappings for a single database. Session factory is a factory for session and a client of connection provider and it may hold an optional e.g. second level cache of data that is reusable between transactions at a process or cluster level. Session is a single threaded short lived object representing a conversation between the application and the persistent store . Session wraps a JDBC connection and is a factory for transaction . Session holds a mandatory first level cache of persistent objects which are used when navigating an object graph or looking up objects based on an identifier.

Persistent objects are short lived single threaded objects containing persistent state and business function. Persistent objects may be for example ordinary JavaBeans POJOs plain old Java objects . Persistent objects may be associated with a session e.g. session . As soon as the associated session is closed the persistent objects may be detached and free to use in any application layer e.g. directly as data transfer objects to and from presentation . Transaction is a single threaded short lived object used by the application to specify atomic units of work. Transaction abstract applications from underlying JDBC Java database connectivity JTA Java transaction API and or CORBA common object request broker architecture transactions. A session may span several transactions in some situations.

The JDBC API is the industry standard for database independent connectivity between the Java programming language and a wide range of databases SQL databases and other tabular data sources such as spreadsheets or flat files. The JDBC API provides a call level API for SQL based database access. The JTA specifies standard Java interfaces between a transaction manager and the parties involved in a distributed transaction system such as the resource manager the application server and the transactional applications. The CORBA is a standard defined by the Object Management Group OMG that enables software components written in multiple computer languages and running on multiple computers to interoperate. CORBA wraps program code into a bundle containing information about the capabilities of the code inside and how to call it. The resulting wrapped objects can then be called from other programs or CORBA objects across a network. CORBA uses an interface definition language IDL to specify the interfaces that objects will present to the world. CORBA then specifies a mapping from IDL to a specific implementation language like C or Java.

Referring back to connection provider is a factory for and pool of JDBC connections. Connection provider abstracts application from underlying data sources or driver managers e.g. JNDI or Java naming and directory interface JDBC and JTA . Transaction factory is a factory for transaction instances. Framework supports a variety of databases including for example Oracle DB2 Sybase MS SQL server MySQL etc. In one embodiment framework may include modules that implement the filter definition and caching mechanisms as described above. Note that some or all of the components as shown in may be implemented in hardware software or a combination of both hardware and software.

When a filter is defined with caching enabled this forces the ORM system to search the filter in its internal cache memory and reuses it if found. According to one embodiment a filter using IndexReader may be wrapped in a Lucene CacheWrapperFilter to benefit from some caching speed improvement. If a filter creation requires additional operations or if a filter does not have a no argument constructor a filter factory or implementation may be implemented similar to one as shown in . In this example the ORM search facility will look for a Factory annotated method and use it to build the filter instance. The factory must have a no argument constructor.

A named filter can benefit some parameter injection. For example a security filter needs to know which credentials a user is willing to filter by setting the corresponding parameter and each parameter name should have an associated setter or setting function member on either the filter or filter factory of the targeted named filter definition as shown in . Referring to a member function of setLevel may be used to set a parameter of level in the filter factory of SecurityFilter Factory which may be associated with a filter name of security . Note that with respect to the method annotated Key and returning a FilterKey object the returned object has a special contract in which the key object must implement equals hashcode so that two keys are equal if and only if the given filter types are the same and the set of parameters are identical. In other words two filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism. Key methods are needed only if a user enables the filter caching system and the corresponding filter has a parameter otherwise the caching mechanism generate a key transparently. In most cases involving parameters using a StandardFilterKey implementation provided by the framework will be sufficient enough. It delegates the equal hashcode implementation to each of the parameters equal and hashcode methods.

There are various advantages to use filter caching features in which the system does not have to update the targeted entity index often e.g. the IndexReader is reuse often and filter BitSet is relatively expensive to compute. However caching filters could require a large cache memory within the ORM system. If there is a limited amount of cache memory available in the ORM system certain filters that are not frequently e.g. least recently used or LRU used may be purged to make rooms for the new filters.

As shown in the system which is a form of a data processing system includes a bus or interconnect which is coupled to one or more microprocessors and a ROM a volatile RAM and a non volatile memory . The microprocessor is coupled to cache memory as shown in the example of . Processor may be for example a PowerPC microprocessor or an Intel compatible processor. Alternatively processor may be a digital signal processor or processing unit of any type of architecture such as an ASIC Application Specific Integrated Circuit a CISC Complex Instruction Set Computing RISC Reduced Instruction Set Computing VLIW Very Long Instruction Word or hybrid architecture although any appropriate processor may be used.

The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required.

While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system embodiments of the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals. Alternatively I O controller may include an IEEE 1394 adapter also known as FireWire adapter for controlling FireWire devices.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable medium. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of embodiments of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

