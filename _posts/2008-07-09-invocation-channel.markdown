---

title: Invocation channel
abstract: Creating interoperability between a calling entity and an external service includes configuring an invocation channel using codeless process, designating the external service, passing source data from the calling entity to the invocation channel, the invocation channel formatting the data, invoking a connection to the external service, and passing the data over the connection to the external service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261296&OS=08261296&RS=08261296
owner: International Business Machines Corporation
number: 08261296
owner_city: Armonk
owner_country: US
publication_date: 20080709
---
Aspects of the present specification relate in general to computer processing and more specifically to the automation of tasks and interoperability of applications within computer systems.

In modern computer systems a number of applications and services can be used to fulfill a user s needs. In many cases the applications and services may use different data formats communication protocols and logic. The interoperability between these applications and services depends on the system s ability to translate between these different data formats make the desired connections between the applications and access the logic of the various services. As business or other needs arise the users of the computer system may desire to create responsive combinations of various elements or functionalities with the computer system that are not natively compatible.

A method for creating interoperability between a calling entity and an external service includes configuring an invocation channel using a codeless process designating the external service passing source data from the calling entity to the invocation channel the invocation channel formatting the data invoking a connection to the external service and passing the data over the connection to the external service. A computer program product for interoperability between a calling entity and an external entity includes computer usable program code configured to accept a source object from the calling entity and serialize the source object into an eXtensible Markup Language XML message transform the XML message into a second message having a data format compatible with the external entity invoke a connection with the external entity and communicate the second message to the external entity and transmit a response back to the calling entity.

Throughout the drawings identical reference numbers designate similar but not necessarily identical elements.

As will be appreciated by one skilled in the art the present invention may be embodied as a method system or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product on a computer usable storage medium having computer usable program code embodied in the medium.

Any suitable computer usable or computer readable medium may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer usable medium may include a propagated data signal with the computer usable program code embodied therewith either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium including but not limited to the Internet wireline optical fiber cable RF etc.

Computer program code for carrying out operations of the present invention may be written in an object oriented programming language such as Java Smalltalk C or the like. However the computer program code for carrying out operations of the present invention may also be written in conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

A simple hypothetical situation illustrates the usefulness of the invocation channel in bridging the gap between a calling entity and an external system or service . In this example the calling entity may be an automated workflow that as part of its output is to generate a printed image on paper. The information technology IT infrastructure includes three printers from various manufacturers. Each of these printers has varying capabilities communication protocols and data format requirements. One of these printers will be the external system or service in this example.

Initially the automated workflow creates a print source object which is passed into the invocation channel . The invocation channel consists of various modules which interpret the source object determine which external system or service is best suited to execute the source object format the data within the source object to be compatible with the selected external system or service invoke a connection with the external system or service and transmit the formatted request and data to the external system or service for execution. In this example the invocation channel selects a printer to execute the print job formats the print command and image data so that they are compatible with the selected printer invokes a connection to the printer and passes the formatted information to the select printer for execution.

The example above is simplified in many respects to better communicate the general role of an invocation channel . In an actual implementation of the above example other elements and considerations might be included. For example the invocation channel may actually interface with intermediate printer software printer drivers and other elements.

In other applications the source objects generated by the calling entity may require significantly more complex functionality within the invocation channel . For example if a software patch is to be distributed to all machines within an organization that have a specific operating system the calling entity may generate a patch source object which contains the patch software and other needed data. In one embodiment the invocation channel would then determine which machines require the update and what method should be used to install the update on each target machine.

If the invocation channel determined that an appropriate installation service existed on each machine it would gather the required credentials to access the target machines and format the data as required for each target machine invoke the connections to the target machines and pass the data to the installation service. If a response was required such as installation complete the invocation channel would accept the response data format it and route it back to the appropriate calling entity .

A variety of methods can be used to initiate the invocation channel . The invocation channel may be invoked by automated processes or processes that have an active human user. By way of example and not limitation an automated or semi automated invocation may be initiated by an application user interface UI a workflow field validation event listener application programming interface or an escalation.

According to one exemplary embodiment the invocation channel includes an object structure component a custom module A a processing class and an eXtensible Sheet Language XSL map A . The logical processing flow of source objects progresses through the invocation channel as shown by arrows pointing to the right. When the invocation channel is invoked a source object is passed into the invocation channel . The source object contains data and or relationships that are to be used by the external system or service to execute the desired operation. The source object is comprised of one or more business objects. Each business object contains a single type of data. When business objects are combined to form a source object the relationships and hierarchy of the combined business objects are captured in the source object. For example a source object for an invocation channel People could be made up of a business object Person and a business child object Phone. The business object Person may contain the first and last name of a given individual. The business object Phone may contain one or more phone numbers for contacting the individual identified in the Person business object. When the invocation channel for People is called the source object which contains the business object Person and related source child objects Phone are passed to the invocation channel and the object structure component will build an eXtensible Markup Language XML message made up of the Person business object and all its related Phone business objects. This XML message captures both the content of the business objects and the relationship between the various business objects. According to one exemplary embodiment the input to the object structure component is the primary top business object and any other business objects to which the main object maintains a processing relationship. The output is an XML message containing the content per object structure component definition.

The object structure component creates this XML message by serializing the received source object . This serialization process retains the relationship information between the data elements within the source object as well as the data elements themselves. The object structure component can also retrieve additional data from internal or external sources if required. This additional data could then be formatted and included in the XML message. This XML message is then passed to the transformation layer .

The transformation layer may be comprised of various components including custom modules A and B a processing class and XSL maps A and B . In one illustrative embodiment custom module A and custom module B are Java classes where the customer can insert any code or operation that is desired. By way of example and not limitation the custom modules A and B may contain filtering data transformation business logic and or other desirable operations. The custom modules A and B are normally implemented as part of a customer installation customization. In some situations it may be desirable to provide a base class within the custom modules A and B that can be extended if desired. The custom modules A and B operate on both the outgoing data flow and the incoming data flow. According to one illustrative embodiment the custom modules A and B operate on the data flows before they are passed to the processing class .

The processing class is a Java class where filtering data transformation and business logic can be performed. According to one exemplary embodiment pre packaged enterprise resource planning adapters and integration modules may provide processing classes to support their integration functionality. The user or other logic can select the appropriate processing class functionality from the available processing classes or can use the custom modules A and B to implement the desired functionality. Similar to the custom modules A and B it may be desirable to provide a base class within the processing class that can be extended if desired.

In one embodiment the XSL maps A and B are eXtensible Stylesheet Language Transformations XSLT that perform data transformation and or mapping of the XML message from the input format to an output format. XSL files can be implemented via an enterprise archive EAR file or through an absolute path reference. Using the latter allows XSL to be implemented without rebuilding the EAR file and restarting the application server. The XSL files allow for a no code implementation of the invocation channel. According to one illustrative embodiment the XSL maps A and B and other elements within the invocation channel can be accessed through a graphical user interface that allows customization of the invocation channel and its various components without any computer program coding

The endpoint handler makes the actual connection between the invocation channel and the external system or service . According to one exemplary embodiment the endpoint handler has two distinct subcomponents an endpoint and a handler. An endpoint contains a data structure with the information required to make a connection to a given resource or service. This information may include the service name and location the type of connections that can be made with a given service credentials used in making the connection a port number format information and other like data. According to one exemplary embodiment the other invocation channel elements such as the object structure component or custom module A can override or replace endpoint values. This allows for the dynamic selection of the external system or service and the method used to connect to that external system or service . For example if the invocation channel logic determines that the originally designated external system or service is unavailable or otherwise undesirable the invocation channel may select an alternative external service and call the appropriate endpoint handler combination to make the connection.

In addition to an endpoint a variety of other data structures may be used in conjunction with an appropriate handler to store the relevant system connection information in a retrievable form. By way of example and not limitation a hashmap is a data structure that associates keys with values. The hashmap supports lookup in which given a target or key such as the identity of a remote server the system finds the corresponding values to enable connection to the remote server such as the username and password associated with the remote server.

The handler of the endpoint handler uses values collected or contained within the endpoint to make the connection to the external system or service . The handler first invokes a communication port and conveys the credentials to the external system or service using the correct communication protocol. For example if the handler were connecting to a remote web server the handler would invoke a web service connection and transmit the credentials to the web server. If the credentials are accepted by the remote web server a connection is established the XML message is transmitted and the desired operation is executed. One or more handlers may be configured to invoke a variety of connection types. By way of example and not limitation the handler may invoke an HTTP Post write data to a Java Message Service JMS queue invoke a web service connection invoke an Enterprise Java Bean EJB or execute a series of commands via a command line interface.

Following the execution of the operation or at other times the external system or service may provide a response. The invocation channel may support one or more response patterns including synchronous asynchronous one way asynchronous deferred response or asynchronous call back. The synchronous response pattern refers to an invocation channel that is configured to receive a response from the external system or service and pass that response to the calling entity . The asynchronous one way response pattern refers to an invocation where there is no response returned to the calling entity . A third response pattern is Asynchronous deferred response where the calling entity retrieves a response from the external system or service at later time. The fourth response pattern is Asynchronous call back in which the external system or service returns an identifier to the calling entity that allows it to request a response or status update from the external system or service at a later time.

According to one exemplary embodiment the default configuration of the invocation channel is for synchronous replies. Synchronous replies can be particularly useful when a user needs to make real time business decisions using the response from the external service . If the calling entity is not expecting a response the synchronous reply can simply be ignored.

The response is received by the endpoint handler and passed back through the transformation layer to the object structure component . The transformation layer may perform a variety of tasks including reformatting the response into an internal XML schema and passing the resulting XML message to the object structure component . The object structure component may perform any number or type of logical operations on the response based on the external data it receives. The object structure component then reformats the resulting data into a target object structure and sends this target object structure to the calling entity .

In sum the invocation channel creates a generic framework to invoke external systems or services on behalf of a calling entity . This can be particularly advantageous in a service oriented architecture environment where applications routinely use services provided by external applications either for processing or as part of a workflow. It allows data and services provided by external applications to be displayed in the native environment of the calling application or user interface. In many cases this interoperability can be so transparent that the user may be unaware than an external system or service is providing the data being displayed by the calling entity .

Further the invocation channel can be customized and used without writing code or having a working knowledge of a programming language. The invocation channel is designed to be customized if required through modular elements. The custom modules A and B and other customizable elements may be accessed through a user interface which prompts the user to insert the required data and or assemble any number of pre built elements to accomplish the desired objective. These modular elements are easily configurable to include additional pieces of programming. The configuration and update of the various invocation channel elements or definitions can be performed without interruption to the calling entity or calling application server.

The transformation between the various data formats is customizable at any point. For example the conversion from source object structure to an internal XML format is customizable at the object structure component while the transformation from the XML format to the external format can utilize a number of pre built modules within the processing class . According to one exemplary embodiment these pre built modules perform common transformations to interface with a number of popular external applications and services.

As described above configuring an invocation channel can be accomplished in an entirely codeless process by simply selecting and associating various modular components. As can be seen from the flowchart shown in the custom modules processing class and XSL maps are all optional components within the invocation channel. In circumstances where the mapping and logic contained within the object structure component are sufficient to allow communication with the external system these optional components can be inactivated or omitted from the invocation channel. Additionally it is possible for the registered endpoint in the invocation channel to be bypassed in the custom module and or processing class.

The object structure component receives the source object and performs filtering step based on one or more conditions and then serializes step data from the source object into XML format. For example the user may desire to use an external service to perform a tax calculation on the Item amount object within the Purchase order object structure. The object structure component would extract the Item amount object from the larger object structure and serialize the Item amount into an internal XML schema. The filtering and serialization of the relevant data into an XML message transforms the source object which may have a variety of structures and elements into a generic XML message which still retains the required data and element relationships. The XML message facilitates the sharing of structured data across the various elements and systems within the invocation framework. This XML message is then passed to the transformation layer.

Within the transformation layer a custom module the processing class and a XSL map perform the necessary operations to format the internal XML data into a format compatible with the external system or service step . According to one exemplary embodiment this transformation may be from the internal XML schema to an external XML format. One or more of the components within the transformation layer may perform the necessary transformation. By way of example and not limitation the processing class may contain a pre built module that converts the data formatted according to the internal XML schema into the appropriate external XML format. Where the pre built functionality of the processing class makes the required transformation the custom module and the XSL map would not be needed and would be inactive during the transformation process.

The formatted message is then passed to the endpoint handler which invokes the external system or service step . The handler executes the desired operation and accepts the response from the invoked system or service step . For example the handler may invoke a web service connection to a service which will perform the tax calculation on the Item amount. The handler transmits the XML message containing the Item amount and waits for a response. The external service calculates the Tax amount and passes back an XML message containing the Tax amount to the handler. This response message is then passed back through the transformation layer and is reformatted from the external XML schema into the internal XML schema step . In some circumstances the internal and external XML data can be compatible and no transformation is required.

The object structure component then deserializes the XML message and transforms it into object format step and performs any other operation that is desired to define the target object. For example the object structure component could deserialize the XML message containing the Tax amount and convert the Tax amount into a business object. The object structure component could then insert the Tax amount object into the Purchase Order object structure as a child object. The object structure component could then pass the Purchase Order object structure back to the calling entity as the target object. The calling entity could then display the data on a user interface or save the information in a database step . For example the calling entity may be an accounting application. The accounting application could receive the Purchase order object structure from the invocation channel and display the updated information including the Tax amount. 

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the Figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Having thus described the invention of the present application in detail and by reference to embodiments thereof it will be apparent that modifications and variations are possible without departing from the scope of the invention defined in the appended claims.

