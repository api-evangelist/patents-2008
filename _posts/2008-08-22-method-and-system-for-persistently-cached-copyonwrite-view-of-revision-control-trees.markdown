---

title: Method and system for persistently cached, copy-on-write view of revision control trees
abstract: A method and system for efficient usage of revision control system resources by providing a client-based file system tree based on managed cache resources is provided. The managed cache resources include both a persistent, disk-based cache that maintains copies of requested file data from a repository server and an ordered tree data structure-based metadata cache for tracking file metadata across revisions. Embodiments of the present invention further maintain in the data cache data related only to specifically requested files. Embodiments of the present invention further track a range of versions of the file system tree for which particular file versions are applicable, so that unnecessary downloading to the client of unchanged files is avoided. Thus, file data and metadata are only requested from a repository server when needed and only a single version of a file is maintained until a modification to that file is made.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069792&OS=09069792&RS=09069792
owner: Conifer Systems LLC
number: 09069792
owner_city: Austin
owner_country: US
publication_date: 20080822
---
The present invention relates to the field of revision control systems and particularly to providing a persistently cached copy on write view of file system trees for clients of a revision control system.

Modern computer software and hardware development projects often require a large number of people e.g. programmers engineers technical writers and artists working in parallel to generate a product. Since this large number of people often require access to a common set of information and an ability to modify that information e.g. software code a mechanism for sharing this information among collaborators is necessary. A revision control system is a centralized system for sharing such information in a controlled manner.

Revision control systems maintain historical copies of all source code and other relevant artifacts e.g. images documentation tools and test cases that are used in building the project. At the core of a revision control system is a repository server which maintains a central store of data called the repository. A repository can store project information in the form of a file system tree which is a typical hierarchy of files and directories. Unlike a standard file system however a repository contains every past version of every file in the file system tree since the beginning of a project and the repository maintains a record of when each change was made to each file and typically information as to why such changes were made and who made those changes. Using a repository a user can reconstruct a precise state of the project at all points in time during the development of that project.

In a typical revision control system environment if a user wants to make changes to files in the repository the user first checks out a copy of relevant portions of the file system tree of the project in interest to a local storage volume of the user s client computer. The user will then edit the local copy of the files. Once the user is satisfied with the changes that have been made those changes are committed back to the repository. A commit typically involves scanning through the user s copy of the file system tree for files which have been changed and then uploading the changed files back to the repository server to update the repository. In order to determine the changes made to files a client typically stores two copies of every file on the local volume one of which is maintained in its original form. In order to store two copies of the relevant portions of the project file system tree client resources are expended in the form of disk space to maintain the file system tree copies and repository server resources are consumed in order to respond to the request to download the requested files from the file system tree which are typically many more than the files being modified and often the complete file system tree from the repository. Further network resources are consumed during the period in which files are being transferred from the repository server to the user s client computer.

Traditional revision control systems therefore consume significant storage resources network resources and repository server resources while responding to client requests for file system trees. In addition since many clients can be connected to a single repository server the repository server can be further slowed by competing requests for information and therefore users can experience significant time delays in waiting for responses to requests for information. Thus a traditional revision control system also makes inefficient use of personnel resources and consequently costs a business additional money.

It is therefore desirable to provide a mechanism by which a user s client computer need request and receive only information the client computer requires at that time rather than file and directory information from a file system tree that is not needed by the client computer. Such a mechanism would thereby conserve repository server network client and personnel resources. It is further desirable that such an improved mechanism be capable of integration in traditional revision control environments to avoid costs associated with migration from one repository server to another.

Embodiments of the present invention provide for efficient usage of revision control system resources by providing a client based file system tree based on managed cache resources. The managed cache resources include both a persistent disk based cache that maintains copies of requested file data from a repository server and an ordered tree data structure based metadata cache for tracking file metadata across revisions. Embodiments of the data cache include copy on write functionality for modified files so that two copies of a file system tree need not be maintained by the client computer. Embodiments of the present invention further only maintain data related to files specifically requested by a user in the data cache. Should the user modify contents of a file embodiments of the present invention will make a copy of that file that includes the modifications made to that file. Embodiments of the present invention further track a range of versions of the file system tree for which particular file versions are applicable so that unnecessary downloading to the client of unchanged files is avoided. Embodiments of the present invention also maintain information downloaded from the repository server in a hash based single instance storage so that duplication of files stored on a client system is minimized.

Through the use of these managed cache resources revision control system resources are conserved. File data and metadata are only requested from a repository server when needed. Only a single version of a file is maintained until a modification to that file is made. But the client maintains access to the entire file system tree upon demand.

A revision control system is a centralized system for sharing information among a group of users of that information. Revision control systems are designed to maintain historical copies of all source code and other relevant artifacts used to build the software or hardware project throughout the life of the project. A repository server provides access to a central store of data called a repository. Typically repository servers structure an associated repository in one of a variety of database formats specific to the vendor of the repository server. The repository stores information for a project in the form of a file system tree within the repository. Client computers can access the repository via the repository server and can read and write files that are members of the file system tree in a controlled manner.

Repository server is coupled to a network that provides communication with one or more client computers N . It should be noted that there can be more than one repository server coupled to a network that are accessible to the plurality of client computers. It should also be noted that network is not restricted in type and can be for example a local area network metro area network or wide area network or a combination thereof. Further network is not limited as to protocol. In other revision control environments a client and repository server can be located on the same physical computing equipment thereby eliminating the need for a network connection between the client and the repository server. In still other revision control environments a client computer can access a repository directly without going through the repository server as an intermediary.

A client computer can include a number of modules to facilitate interactions with the revision control system. For example a communication module can provide bidirectional communication between client and repository server . Such communications can be provided in a vendor specific form expected by repository server e.g. by using an appropriate application program interface API or vendor modified web based distributed authoring and versioning WebDAV extensions . Communication module can be coupled to a processor module that provides a variety of client based revision control system functionality as described more fully below. Processor module can further be coupled to a user interface that permits user interaction with the various revision control system functionality. Processor module can also be coupled to a storage module that permits storing and access to local copies of the file system tree . In a typical revision control system not only is a read write local version of the file system stored but also a hidden read only version of the file system tree that maintains an original form for a particular revision downloaded from the repository.

In a typical revision control system if a user wants to make changes to files in a repository the user first checks out a copy of the file system tree or a portion of the file system tree onto the user s client computer local hard drive e.g. local file system and hidden file system . The user can then edit the local copy of the files using an appropriate editor through user interface . When the user is satisfied with the changes those changes can be committed back to repository . In order to perform a commit the client system can scan through the local copy of the file system tree to find files that have been changed and then the client system uploads those changes back to repository server to update the file system tree located in repository . In order to perform the local scan to find changes in the files client needs an original copy of every file in the locally stored file system tree e.g. hidden file system .

Since a revision control system typically services more than one user or client system at a time prior to allowing a commit to proceed a client should check to see if any of the locally modified files have been previously modified and committed to repository by another user. Client can query repository server to determine if a a current revision of the file system tree is the same as the version locally stored on the client system and b if the revision number is not the same then determine whether the individual files that have been modified on the client have previously been changed and committed to the repository. If a file has been changed then the client can download the committed and previously modified version of the file from the repository and perform a merge between the local version of the file and the version of the file retrieved from the repository. In some cases such a merge can be performed automatically but in instances where conflicts between the local modifications and those previously committed to the repository are likely user interaction with the merge is required.

Once a commit can proceed the modified versions of the files are provided to repository server which then saves the modified versions of the files in repository and increments the revision number of the file system tree. In addition metadata can be provided by the client to the repository server indicating for example the changes that were made and why those changes were made. In turn repository server tracks and stores the metadata provided by the clients in association with the revision number.

A typical repository server provides the following functionality responding to requests to read data stored in repository responding to requests for information about files and or file system tree versions e.g. metadata and responding to commits provided by clients . In addition a repository server may also track the identity of one or more users who are currently editing a file. A repository server may also in certain circumstances allow only one user to access a file for editing at a time e.g. by assigning a lock to a file . A repository server may also be configured to inform users of the repository server about a commit being made to a particular file thereby enabling those users to update their local file system trees to include the new version of the file.

As stated above an initial step for a user in making modifications to a file system tree is to download all or part of a file system tree from a repository during the checkout process. Checking out a file system tree is resource intensive. The transfer of file data across the network consumes bandwidth on both local area and wide area network connections. A checkout request also consumes resources on the repository server in order to respond to the request. A checkout request also consumes computing resources on the client as well as storage resources required to store two versions of the checked out file system tree. Checking out an update to a local file system tree requires fewer resources because fewer files typically will be exchanged but updates involve bidirectional communication between the client and the repository server to determine those files that should be updated to the client computer.

Typically a user may only look at approximately 10 of the files checked out using a traditional revision control system and may further edit only 1 of those files. Further the total size of the files in the repository file system tree may be very large especially for projects having large binary files such as images 3D models and audio or video clips. This issue is compounded if a user of a client system wishes to work on multiple file system trees wherein data for each tree must be downloaded and stored by the client. It is therefore desirable to have a mechanism for downloading only those files needed rather than the entire file system tree or significant portions thereof. While traditional revision control systems may have a mechanism for selecting a subset of files to download such selection is labor intensive and error prone e.g. file selection is manual and if too few files are downloaded then the selection process needs to be repeated later . In addition it is desirable that such a mechanism not require going to a different revision control system in order to realize the benefits. There are significant costs associated with changing a repository e.g. migration which can take weeks possible lossy conversion of metadata compatibility issues between the old and new system and training issues .

Embodiments of the present invention provide a solution to the above listed problems by allowing a user to view and edit files from traditional revision control system repositories without first making a copy of all the files in the repository file system tree on the user s local hard drive. Only file data that is actually viewed or edited will be downloaded from the repository server to a client s system. On the other hand a user can always have access to an entire repository file system tree at no extra costs in storage or network bandwidth. Embodiments of the present invention use a copy on write file system methodology so that when a user edits a file a copy of the file is edited and not the downloaded original. Embodiments of the present invention maintain a persistent cache of all file system tree data accessed by the client and a cache of associated metadata. The persistent cache is maintained on local disk storage of the client and therefore when a system is powered down the data in the persistent cache is not lost.

Query module is configured to exchange information with a cache manager . As will be discussed more fully below cache manager maintains information about locally stored cached copies of files from repository server and can provide that information to revision control file system RCFS upon request by RCFS . In addition if a locally stored version of a requested file is not available cache manager can request download of that file s information e.g. data or metadata from repository server via query module . Upon receipt of file information from the repository server the cache manager can provide the file information to RCFS and can provide file data to storage manager for storing in a persistent cache area located on storage volume or store file metadata in a separate cache.

Storage manager is responsible for maintaining storage volume . Embodiments of the present invention can store storage volume as a container file in a larger file system. Alternatively storage volume can be stored in a dedicated storage device e.g. one or more hard drives solid state drives and the like . As will be discussed more fully below storage volume can include both the cached copies of original files received from repository server as well as modified files provided by RCFS . The cached files can be maintained in a hash based cache that is part of the storage volume. By using a hash based file identification system storage manager can also provide cache storage as a single instance data store in which only one copy of file contents corresponding to a hash value need be maintained. Storage manager further provides a mechanism for tracking most recently used files in the cache in order to enable freeing cache storage resources upon demand by deleting files that have remained unused for a prolonged period of time. Embodiments of the present invention further provide for storing cached file data in compressed form in order to conserve storage resources. Storage manager also maintains copies of files modified by RCFS in uncached storage that is not subject to deletion for lack of use.

As illustrated revision control file system is a user space file system process that provides not only a set of standard file system operations but also a set of operations specific to communicating with a revision control system e.g. a repository . RCFS is configured to communicate directly with both cache manager and storage manager . For operations requiring access to information from repository server file system trees RCFS communicates with cache manager . For operations in which RCFS modifies files or accesses modified files then RCFS communicates directly with storage manager .

As a user space process RCFS is further configured to communicate with a file system interface library. As illustrated in for a Linux based operating system RCFS communicates with a fuse kernel module e.g. fuse.ko via a fuse library e.g. library libfuse.so . As will be understood by a person of ordinary skill FUSE also known as Filesystem in User Space provides for implementation of a fully functional file system such as RCFS as a user space program. The fuse library is an application program interface API between the user space program and the fuse kernel module. The fuse kernel module in turn communicates with a Linux virtual file system switch VFS that is configured to provide access to all files in any file system in the Linux environment. VFS is a layer of code that implements generic file system actions and directs requests to specific code to handle the request. VFS is configured to communicate with a variety of available file systems including for example the ext2fs file system.

VFS in turn provides communication with programs present in the user space. User programs can include for example one or more editors viewing utilities client software specifically developed for RCFS or web servers.

A hash table is also provided in storage volume . Hash table provides a mapping of hash indexes to associated inode numbers. The hash index of a file is determined using a cache key that uniquely identifies a file stored in the storage volume as will be discussed more fully below. Due to limitations in the length of hash index numbers only a portion of the hash from a cache key is used and therefore multiple files can correspond to the same hash index. Thus an entry in the hash table refers to an inode corresponding to a first file that corresponds to the entry in the hash table. As will be discussed below subsequent file inodes that have the same hash index are linked to the first file inode in a chain.

Inodes corresponding to files stored in storage volume are provided in inode table . Inodes provided in inode table are similar in purpose to those provided in a standard file system with differences included to enable the hashing and caching features of storage volume .

Inode further includes a field available for flags . Flags can provide a variety of information to storage manager including for example whether the inode is associated with a file directory or a symbolic link and whether the inode reference is a cache entry file. Since storage volume can include both cached and non cached files e.g. files provided by RCFS a flag is used to distinguish between both types of files. A size field is also provided to indicate the size of a file associated with the inode. A modified time field is provided that indicates when the associated file data was last modified either by another user storing the file data on the repository server prior to being downloaded to the local system or by RCFS .

The following four fields illustrated in are found only in inodes corresponding to cache entry files in storage volume . A 32 bit representation of the hash of the cache key for the file is included in field . This can be used to detect hash table collisions with other inodes or to locate an inode s corresponding hash table entry. It should be noted that a full representation of the cache key can be stored with the file data itself in an associated data block or within inode if the file data can be included within inode .

As stated above each cached file stored within storage volume has an associated cache key that uniquely identifies the contents of the file. The cache key is provided to storage manager by cache manager and is generated from information provided by repository server . In general a cache key is a tag that identifies some data stored in the cache area. For example a cache key for a file can include information about the file such as a Boolean indication of whether data in the file is compressed a Boolean as to whether new line indications in the file correspond to a Unix operating system or a Windows based operating system a checksum based hash of the contents of the file and an indication of the method by which the checksum was generated e.g. MD5 or SHA 1 . As another example a cache key for a changeset can include a repository URL and a revision number.

A hash index for a chunk of data e.g. a file associated with a cache key is generated by taking a hash of the cache key. Since such a hash will in general be longer than a number of bits available for each entry in hash table the hash of the cache key is then truncated to an appropriate number of bits to generate the hash index. Because of such truncation it is possible for more than one distinct file to be represented by the same hash index even though their cache key will be different. Additionally two or more files or other chunks of data can have the same hash index because two distinct cache keys hash to a same 32 bit hash value. Storage volume handles this by linking inodes of files having the same hash index.

Inode also includes fields pointing to a next and previous inode in a most recently used listing of inodes . As stated above storage manager tracks usage of cache entry files in order to determine whether a file can be evicted from the cache should additional space be required. The storage manager performs this task by maintaining a most recently used listing of cache entry inodes that have a refcnt equal to one. For example if a file A has recently transitioned to an unused state e.g. refcnt 1 then the inode number associated with that file enters a most recently used list e.g. a linked list having references stored in the reserved block header of storage volume . As time goes by additional inode references are included in the most recently used list and the inode reference for file A progresses down the list where the oldest files in the list are at the bottom. Should storage manager require additional space the storage manager reads the most recently used list to determine which inodes are at the bottom and deletes the data associated with those inodes and clears the inode referencing that data until the required cache space is freed. Should a file on the most recently used list become accessed while the file is on the list the file is removed from the list until the file is no longer being used and is reinserted at the top of the list. Reference to inodes before and after a particular inode are included in the MRU next and MRU previous 465 fields in inode .

As stated above since only a portion of a hash of a cache key that uniquely identifies a file is available for hash indexing multiple files may correspond to the same hash index. In order to allow reference to a next file that corresponds to a particular hash index next in chain field provides a reference to a next inode corresponding to a file having the same hash index. In order to locate a file having a particular cache key storage manager will determine the appropriate hash index and find the first inode corresponding to that hash index through the hash table lookup. Storage manager will then examine 32 bit hash value 455 to verify whether the hashes of the cache key being searched matches the hash of the cache key associated with the inode. If the 32 bit cache key hash values match then the cache key for the first file will be examined against the cache key being searched. If either the first file s 32 bit cache key hash value or the first file s cache key does not match the searched for cache key hash value or the cache key respectively then the inode referenced in next in chain field is looked up and a similar cache key hash cache key comparison is performed. This inspection of files down the chain of inodes is performed until a match is found for the cache key or when the chain of inodes ends e.g. there is no match for the cache key hash cache key and thus the file is not present in the cache .

File data for files having more data than would fit in an inode is stored in data blocks . Inode contains pointers to direct blocks that contain file data. More than one direct reference to a data block can be provided in inode . In one embodiment of the present invention an inode can contain references to 13 direct blocks. Should the number of blocks containing data be so large that the list of blocks will not fit within an inode then inode provides indirect block pointers for storing pointers to a data block that contains pointers to direct blocks or other indirect blocks . In one embodiment of the present invention an inode can contain a single indirect block pointer a double indirect block pointer and a triple indirect block pointer in indirect block pointers .

Storage Manager in embodiments of the present invention provides for example the following functionality 

Hash table is then examined to determine if there is an entry corresponding to the generated hash index in the hash table . If there is no corresponding entry in the hash table then storage manager returns an indication to cache manager that the sought after file is not present in the cache and the process ends. If there is a corresponding entry in the hash table then storage manager looks up the inode referenced in the hash table entry . The hash field in the corresponding inode is then examined to determine if the hash of the cache key matches that stored in the hash field . If the inode hash field does not match the cache key hash then the inode is examined to determine if there is a next in chain inode referenced in field . If there is no next in chain inode then an indication is returned if the file is not in the cache . If there is a next in chain inode then the next in chain inode is looked up and the process of examining the hash field in the next in chain inode is performed as before.

If a determination is made that the hash field in an inode does match the cache key hash then a lookup is performed on a referenced block containing the corresponding file data . A determination is then made as to whether the cache key stored in the data block matches the cache key of the file being sought . If not then the next in chain inode is examined as before . If the block cache key does match the cache key of the file being sought then an indication is returned that the file being sought is present or further operations are performed on the file as requested . Upon receiving this information from the storage manager the cache manager makes a determination as to whether information requested by the RCFS can be provided from storage volume or must be downloaded from repository server .

Cache manager functions as a gate keeper between a client computer and the repository server. In response to a request for file information associated with a file in a file system tree made by revision control file system cache manager in conjunction with storage manager makes a determination as to whether the requested file information has already been downloaded to the client. If the file information is already stored locally then the cache manager provides the locally stored file information to the RCFS. If the file information has not already been downloaded then cache manager requests an appropriate version of the file information from repository server via a corresponding query module . File information can include not only file data stored in the cached file system maintained by the storage manager but also file metadata stored by the cache manager.

Cache manager also provides a storage manager interface module for communication between cache manager and storage manager . Embodiments of the present invention provide such communication through an application programming interface supporting the operations provided by the storage manager. Similarly cache manager incorporates a revision control file system interface module to interface with RCFS . Each of the interface modules and are coupled to a processor module that manages and performs processing related to cache manager s functions. Processor module is further coupled to metadata storage in which file metadata is stored.

As indicated above cache manager and storage manager use a cache key to determine whether a requested file is already present in local storage. Cache manager can store the cache key as metadata e.g. in metadata storage . The cache key for a specific file can include information such as the checksum or hash of the file data as received in response to the get file checksum command along with information about the type of checksum represented by that hash.

Embodiments of the present invention provide the file metadata tree as a cache. Each node within the metadata tree can be linked together on a most recently used list similar to that discussed above with regard to the file data cache. The most recently used list provides an order in which nodes have been used in the metadata tree. Thus if it is desired to keep the metadata tree at or below a certain number of nodes when new information arrives that information is first inspected to determine whether that information can be merged with an existing node and if not then an old entry can be removed from the tree based upon its position in the most recently used list.

Embodiments of the present invention associate information gathered about files in the metadata tree. Examples of such information include information returned by the operations get file info and get file checksum as well as either the cache key for the associated file or the information necessary to generate a cache key.

Cache manager will then check to determine if metadata associated with the requested file is currently stored in the metadata cache . The cache manager will search the metadata tree for the specified revision number to determine if there is metadata for the requested file already stored. Such a search based on the revision number key can be performed using well understood tree search algorithms. If metadata associated with the requested file information is previously stored in the metadata cache that metadata is retrieved . If metadata associated with the requested file information is not already stored in the metadata cache then cache manager requests metadata associated with the requested file information from a repository server . The metadata is received from the repository server along with a range of revisions over which the metadata information is valid and the metadata is stored in association with an appropriate node in the metadata cache tree as discussed above. Embodiments of the present invention can also prefetch metadata associated with files in the same directory as the requested file. In this manner the cache manager can more efficiently provide information related to those files in the event of a request for that information.

If the received request for file information is only for file metadata then the requested metadata information will be returned to RCFS and the response session will terminate. If the request for file information is for file data then cache manager will provide a request and cache key to storage manager . As stated above the cache key or information comprising the cache key can be stored in the metadata cache. If the cache key is not stored in the metadata cache then cache manager will generate the cache key prior to providing the information to storage manager .

Upon receiving a response from the storage manager a determination will be made as to whether the requested file data was present in the storage volume associated with the storage manager . If the requested file data was present in the storage volume then the requested file data will be provided to the RCFS . If the requested file data is not present in the storage volume then the file data will be requested from the appropriate repository server . Upon receipt of the file data from the repository server metadata associated with the received file data can be stored in the metadata cache and the received file data can be provided to the storage manager for storage . In addition the file data will be provided to RCFS .

Revision control file system RCFS provides various file system semantics and interfaces to permit a user or a program to access files provided by storage manager and repository server via cache manager . RCFS provides basic file system operations as well as specialized operations to provide access to information and data associated with local copies of repository files.

RCFS processor module communicates with cache manager via a cache manager interface and with storage manager via a storage manager interface . Each of interfaces and provide appropriate calls to their associated destinations e.g. RCFS Interface Module in Cache Manager . These communication interfaces are configured for bidirectional communication with their targets in order to permit access to data associated with each target.

As stated above RCFS provides not only a standard set of operations for a file system but also provides operations that are unique to the needs of the revision control system. A standard set of file system operations included in RCFS can include for example the following 

RCFS can also provide additional specialized commands that permit access to files located originally on the repository. Examples of such commands include the following 

In one embodiment of the present invention the standard file system operations are similar to those found in ext2fs a traditional Linux based file system. In such a file system each path in the file system maps to an inode and sometimes more than one path may map to a particular inode. Directories have inodes that contain a list of filenames and inodes of files in the directory. In order to find a file a lookup occurs from the path stated to locate the inode and then operations can proceed on the inode or data associated with the inode. When a directory is created a file is formed that has no data. As files are included in the directory a list of inodes and references to the inodes e.g. filenames are created in the parent directory file.

RCFS has additional commands to mount a repository in association with a directory of the file system e.g. create mount point . When the create mount point command is used an empty directory is formed similar to that for creating a directory in a standard file system. RCFS provides a field in the inode associated with the mount point directory in which the URL path of the repository server and the revision number associated with the mount point e.g. as set by set revision are stored. Thus when an operation is performed on the mount point the system will see that the directory itself is empty but there are special tags pointing to the repository server. Since the tags are indicated RCFS queries the cache manager for the contents of the directory rather than just providing an empty list. For example if the enum files in directory command is provided RCFS forwards that command to cache manager which returns file information about the requested directory structure. RCFS will then populate the directory structure in the local file system using the information provided by the cache manager.

RCFS populates the local directory structure only as needed. Inodes in the directory file specified by create mount point are allocated in response to using a command such as enum files in directory. Inodes for files in the directory are allocated when using a command such as get file info once such a command returns information stating whether the specified target is a file or a directory.

Subsequently if information about file x y is desired RCFS can provide a get file info command to cache manager and the returned information can be stored in inode associated with file x y. It should be noted that at this time the inode is only associated with the requested information and not with file data. On the other hand if a read file command is provided for a file associated with the inode referenced as x z an inode is created for the information related to that file and that inode can be linked to a cache entry inode . Thus a read operation will be satisfied by referencing the cache entry inode associated with the file. If however a user desires to modify file x z then the data referenced by cache entry inode is copied to inode or one or more data blocks associated with inode and subsequent reads and writes to file x z are satisfied by the copy and not the cache entry.

In this manner inodes within the file system do not get populated with file data until that file data is required. For example if a file is merely being deleted then access to the data found in the cache manager is not required. If one needs read access to the data then an RCFS inode is linked to the cache manager cache entry inode and reads can be satisfied by the cache manager cache entry inode. RCFS provides a copy on write of data from the cache manager cache entry inode by copying data to the RCFS inode upon modification of the data as discussed above.

Dependency tracking tracks accesses to files in the file system tree. Every time an inode is accessed such access is tagged as a dependency. Accesses can be recorded in an expanding list of files and directories that have been accessed during a period of dependency tracking. Alternatively tags within the inodes can be flagged for each type of dependency as needed.

A user of RCFS can also choose to store changes made to the file system tree as a checkpoint of the tree at a particular time. RCFS can store information regarding the changes in a permanent storage area such as a checkpoint server or a persistent area of storage volume or a locally available file system. A checkpoint can include a full copy of all edited files. A file system tree can be restored from a checkpoint by creating a new mount point and including all files and information in the directory tree structure necessary to support the checkpointed files and all files depending therefrom.

Upon receiving the request RCFS can perform a lookup of the requested file or directory associated with the request in the file system . RCFS can perform this lookup by providing one or more appropriate commands to storage manager for a file system tree stored in a non cached area of the storage volume managed by storage manager . Upon receiving a response from the storage manager a determination is made as to whether the requested file directory is already present in the file system . If the requested file directory is not present in the file system then an inode can be created in the file system corresponding to the requested file directory . Again this inode can be created through an appropriate command to the storage manager e.g. alloc .

RCFS can then request the desired file directory information from cache manager . The cache manager performs an information lookup as described above first determining whether the desired information is present in the local persistent cache and if not then requesting the information from a repository server . The cache manager returns the requested information to RCFS and then RCFS can store the requested file directory information in association with the inode created in step . If the requested information is small such information can be stored in the inode itself. If the file directory information includes file data that is too large to be stored in the inode then the information can be stored in a data block referenced as a direct or indirect block from the inode. The requested information can then be provided to the requesting user .

If the file directory associated with the requested information is present in the file system then an inquiry is made to determine if the requested information associated with the file directory is present in the file system . If the requested information is not present in the file system then a request can be made for the information from the cache manager . Upon receipt of the requested information the requested information can be stored and provided to the user per previously discussed steps and . Alternatively if the requested information is already present in the file system then the requested information is provided to the user.

In the above described manner the revision control file system can make visible to a user as much of the repository s file system tree as the user desires or needs to see. Not only can directory information be available to a user but also information related to file metadata upon request. But file data associated with a file name is only stored in the file system if that data has been modified from a form originally found on the repository. The original data accessed from the repository is stored in the persistent cache and accessed by the cache manager. Through interaction with cache manager if metadata and data for a particular file at a requested revision have already been downloaded to the client computer and stored in the local cache the requested information is retrieved from the local copy in the cache rather than requesting and downloading the information from a repository server.

This interaction between cache manager and RCFS results in a conservation of resources of the client the repository server and the network coupling the client to the repository server. Client storage resources are conserved by needing to maintain only one copy of each downloaded file from the repository until that file is modified by a user of the client. Further only a portion of the file system tree that is needed by a user is actually downloaded to the client computer and metadata associated with file system tree files can be downloaded separately from associated data. Network resources are likewise conserved due to the reduction in the amount of data being downloaded from a repository server to a client. Similarly repository server resources are conserved by needing to respond only to requests for smaller amounts of information rather than needing to respond to requests for downloading entire file system trees. Since repository resources are freed up time spent waiting for a response from the repository server is also reduced thereby improving personnel efficiency.

As shown above the present invention can be implemented using a variety of computer systems and networks. An example of one such computing and network environment is described below with reference to .

Bus allows data communication between central processor and system memory which may include read only memory ROM or flash memory neither shown and random access memory RAM not shown as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded. The ROM or flash memory can contain among other code the Basic Input Output system BIOS which controls basic hardware operation such as the interaction with peripheral components. Applications resident with computer system are generally stored on and accessed via a computer readable medium such as a hard disk drive e.g. fixed disk an optical drive e.g. optical drive a floppy disk unit or other storage medium. Additionally applications can be in the form of electronic signals modulated in accordance with the application and data communication technology when accessed via network modem or interface .

Storage interface as with the other storage interfaces of computer system can connect to a standard computer readable medium for storage and or retrieval of information such as a fixed disk drive . Fixed disk drive may be a part of computer system or may be separate and accessed through other interface systems. Modem may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider ISP . Network interface may provide a direct connection to a remote server via a direct network link to the Internet via a POP point of presence . Network interface may provide such connection using wireless techniques including digital cellular telephone connection Cellular Digital Packet Data CDPD connection digital satellite data connection or the like.

Many other devices or subsystems not shown may be connected in a similar manner e.g. document scanners digital cameras and so on . Conversely all of the devices shown in need not be present to practice the present invention. The devices and subsystems can be interconnected in different ways from that shown in . The operation of a computer system such as that shown in is readily known in the art and is not discussed in detail in this application. Code to implement the present invention can be stored in computer readable storage media such as one or more of system memory fixed disk optical disk or floppy disk . The operating system provided on computer system may be MS DOS MS WINDOWS OS 2 UNIX Linux or another known operating system.

Moreover regarding the signals described herein those skilled in the art will recognize that a signal can be directly transmitted from a first block to a second block or a signal can be modified e.g. amplified attenuated delayed latched buffered inverted filtered or otherwise modified between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and or functional aspect of the signal is transmitted between blocks. To some extent a signal input at a second block can be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved e.g. there will inevitably be some attenuation and delay . Therefore as used herein a second signal derived from a first signal includes the first signal or any modifications to the first signal whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and or final functional aspect of the first signal.

With reference to computer system modem network interface or some other method can be used to provide connectivity from each of client computer systems and to network . Client systems and are able to access information on storage server A or B using for example a web browser or other client software not shown . Such a client allows client systems and to access data hosted by storage server A or B or one of storage devices A N B N N or intelligent storage array . depicts the use of a network such as the Internet for exchanging data but the present invention is not limited to the Internet or any particular network based environment.

The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted described and is defined by reference to particular embodiments of the invention such references do not imply a limitation on the invention and no such limitation is to be inferred. The invention is capable of considerable modification alteration and equivalents in form and function as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only and are not exhaustive of the scope of the invention.

The foregoing describes embodiments including components contained within other components e.g. the various elements shown as components of cache manager and client computer . Such architectures are merely examples and in fact many other architectures can be implemented which achieve the same functionality. In an abstract but still definite sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermediate components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

The foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams flowcharts and examples. It will be understood by those within the art that each block diagram component flowchart step operation and or component illustrated by the use of examples can be implemented individually and or collectively by a wide range of hardware software firmware or any combination thereof.

The present invention has been described in the context of fully functional computer systems however those skilled in the art will appreciate that the present invention is capable of being distributed as a program product in a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media used to actually carry out the distribution. Examples of signal bearing media include computer readable storage media transmission type media such as digital and analog communications links as well as media storage and distribution systems developed in the future.

The above discussed embodiments can be implemented by software modules that perform certain tasks. The software modules discussed herein may include script batch or other executable files. The software modules may be stored on a machine readable or computer readable storage media such as magnetic floppy disks hard disks semiconductor memory e.g. RAM ROM and flash type media optical discs e.g. CD ROMs CD Rs and DVDs or other types of memory modules. A storage device used for storing firmware or hardware modules in accordance with an embodiment of the invention can also include a semiconductor based memory which may be permanently removably or remotely coupled to a microprocessor memory system. Thus the modules can be stored within a computer system memory to configure the computer system to perform the functions of the module. Other new and various types of computer readable storage media may be used to store the modules discussed herein.

The above description is intended to be illustrative of the invention and should not be taken to be limiting. Other embodiments within the scope of the present invention are possible. Those skilled in the art will readily implement the steps necessary to provide the structures and the methods disclosed herein and will understand that the process parameters and sequence of steps are given by way of example only and can be varied to achieve the desired structure as well as modifications that are within the scope of the invention. Variations and modifications of the embodiments disclosed herein can be made based on the description set forth herein without departing from the scope of the invention.

Consequently the invention is intended to be limited only by the scope of the appended claims giving full cognizance to equivalents in all respects.

Although the present invention has been described in connection with several embodiments the invention is not intended to be limited to the specific forms set forth herein. On the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims.

