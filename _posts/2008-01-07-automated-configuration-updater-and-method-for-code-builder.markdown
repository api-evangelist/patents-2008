---

title: Automated configuration updater and method for code builder
abstract: A method for automating updates to configuration data includes coding a builder method within a source file for an application component and running the source file through a transformer engine configured to implement an interface within the source file. The builder method is implemented to construct an in-memory data structure representing one or more configuration data elements of a configuration object provided by a configuration service for the application component. The interface provides a mapping between one or more configuration data elements represented in the in-memory data structure and one or more corresponding data elements of a listener object representing changes to the configuration object. The mapping is implemented to update the in-memory data structure at runtime whenever a change to the configuration object is signaled to the listener object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08141041&OS=08141041&RS=08141041
owner: International Business Machines Corporation
number: 08141041
owner_city: Armonk
owner_country: US
publication_date: 20080107
---
Exemplary embodiments of the present invention relate to configuration information for application components and more particularly to the updating of configuration data in response to changes in configuration information.

With the continuing evolution of network computing distributed applications utilizing a client server computing model have become prevalent. An application server is a software engine that can be implemented in a distributed network to deliver applications and resources to connected client computers or devices typically through the Internet using the HTTP protocol. The term application server applies to all computing platforms including those providing servers for Web based applications such as integrated platforms for e commerce content management systems and Web site builders. An application server handles most if not all of the business logic and data access for an application program. A primary benefit provided by application servers is the ease of application development provided by a centralized configuration as applications need not be programmed rather they can be assembled from building blocks provided by the application server and changes to application configurations such as a move of a database server or system settings can be done centrally.

Nevertheless applications that execute on a server require reloading and re initialization when the underlying software code is revised or when the application configuration is revised. In these situations the server may be in the midst of processing requests on behalf of users for the application to be revised while the application is being reloaded or re initialized. Thus it is a challenge to keep the underlying software code or application configuration continuously up to date with revisions.

One approach that is used for reconfiguring a server based application upon an application revision is to stop the server from processing reload the revised application and reconfigure the server accordingly and then restart the server in order to implement the changes made to the application and the server. For example in IBM s WEBSPHERE Application Server platform for all administrative revisions the administrator is prompted that the server may need to be restarted for the revisions to take effect. WEBSPHERE provides a configuration listener that developers can implement within software components to listen for configuration changes. Most of the components however do not use the listener properly or do not use it at all leaving stale data in the code.

This approach has numerous shortcomings one of which is the fact that the server cannot process requests for the revised application or any other application installed on the server while it is off line or in the process of restarting. Requests that are in progress when the server is restarted may be interrupted which typically leads to request processing errors. Furthermore any server down time adversely affects the availability of the server which in turn may have an impact on for example SLAs Service Level Agreements associated with the services provided by the server.

Another shortcoming of this approach is that because large servers typically have multiple applications executing an application maintenance operation requiring server stop restart each time an application is changed may not be a practical approach for a high traffic server partly due to the time it takes to restart a server running multiple applications. Again while the server is off line and while being restarted users may be denied access to the server. A complex server can take on the order of minutes to restart and a tremendous amount of request traffic can be lost in that time. Furthermore if an error is discovered in the new application configuration subsequent to the reload another server stop restart will be required. Yet another shortcoming to note is that interrupting requests that are in progress by restarting the server may have the effect of compromising the integrity of the data associated with the current user sessions which can lead to errors when the server resumes its request processing.

Accordingly it is desirable to provide a listener mechanism that does not need to be implemented by application developers so that developers are able to focus on designing components fixing bugs etc.

The shortcomings of the prior art can be overcome and additional advantages can be provided through exemplary embodiments of the present invention that are related to a method for automating updates to configuration data. The method comprises coding a builder method within a source file for an application component and running the source file through a transformer engine configured to implement an interface within the source file. The builder method is implemented to construct an in memory data structure representing one or more configuration data elements of a configuration object provided by a configuration service for the application component. The interface provides a mapping between one or more configuration data elements represented in the in memory data structure and one or more corresponding data elements of a listener object representing changes to the configuration object. The mapping is implemented to update the in memory data structure at runtime whenever a change to the configuration object is signaled to the listener object.

The shortcomings of the prior art can also be overcome and additional advantages can also be provided through exemplary embodiments of the present invention that are related to computer program products and data processing systems corresponding to the above summarized method are also described herein.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

As a result of the summarized invention technically we have achieved a solution that can be implemented to automate the configuration listener update process for application or software components to support changes in configuration data. Exemplary embodiments can thereby facilitate software development by allowing developers and programmers to focus on meeting software requirements for specific problems rather than dealing with more tedious low level details of providing the listener services themselves and incrementally implementing changes to configuration data within the component.

The detailed description explains exemplary embodiments of the present invention together with advantages and features by way of example with reference to the drawings. The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the specification concludes with claims defining the features of the invention that are regarded as novel it is believed that the invention will be better understood from a consideration of the description of exemplary embodiments in conjunction with the drawings. It is of course to be understood that the embodiments described herein are merely exemplary of the invention which can be embodied in various forms. Therefore specific structural and functional details disclosed in relation to the exemplary embodiments described herein are not to be interpreted as limiting but merely as a representative basis for teaching one skilled in the art to variously employ the present invention in virtually any appropriate form. Further the terms and phrases used herein are not intended to be limiting but rather to provide an understandable description of the invention.

Exemplary embodiments of the present invention can be implemented to automate the configuration listener update process for developers of application or software components to support changes in configuration data. Exemplary embodiments can thereby facilitate software development by allowing developers and programmers to focus on meeting software requirements for specific problems rather than dealing with more tedious low level details of providing the listener services themselves and incrementally implementing changes to configuration data within the component. Rather code for the listener and updating configuration data will be built for them using a software engine. Exemplary embodiments can therefore be implemented to enable applications to remain up to date with configuration data while requiring few if any restarts upon administrative configuration changes. This can enable internal or in memory data structure representations of configuration data to be updated at any time without requiring the developer to re implement listener code.

Generally a software component can be defined as a program building block that may be reusable and may be combined with other components in the same application or other computers in a distributed network to form an application. Examples of components include but are not limited to GUI buttons and database management interfaces. Components may be deployed on different servers in a network and may communicate with each other for needed services. A component may run within a context called a container which is a class a data structure or an abstract data type ADT the instances of which are collections of other objects. Examples of containers include but are not limited to pages on a Web site Web browsers and word processors.

Referring now to an exemplary embodiment of a client server application programming architecture is illustrated within which exemplary embodiments of the present invention may be implemented. Architecture provides a three tier architecture for the application logic layer enabling client components to interact with data resources and legacy applications. An example of platform that utilizes application programming architecture is IBM s WEBSPHERE Application Server. Architecture enables the distribution of application functionality across three independent systems 1 client components running on local workstations in a presentation tier and typically providing a Web browser based graphical user interface GUI such as the NETSCAPE NAVIGATOR or MICROSOFT INTERNET EXPLORER web browsers it is noted that the web browser need not be a web browser per se but may be any of various types of client side applications that include web browsing functionality 2 processes running on a cluster of remote application servers in a business logic tier possibly on a local area network or Internet server and 3 a discrete collection of legacy application databases resource manager applications and mainframe applications in a back end data resource tier possibly on a mainframe or a large server.

All three tiers communicate with each other and this communication can be simplified through the use of open standard protocols and exposed application programming interfaces APIs . Client components can be written in any programming language such as Java or C and these clients can be run on any operating system through communication with the processes running in business logic tier . Business logic tier is the middleman between browser based front ends and back end databases and legacy systems. Databases in the third tier can be of any suitable design that allows the processes running in business logic tier to query and manipulate them. Data resource tier may for example be responsible for managing enterprise data or performing business functions for an enterprise.

In the present exemplary embodiment responsibility for presentation and user interaction resides with client components in presentation tier . Client components enable the user to interact with the processes running in business logic tier in a secure and intuitive manner. Exemplary embodiments can support several client types. For example client components may be run in desktop computers or workstations running any of various operating systems such as Windows Mac OS Unix etc. as well as portable computing devices such as a personal data assistant smart cellular phone etc. Client components may use a network connection for communicating with processes running in business logic tier via a network such as the Internet or an Intranet. Although web applications are often associated with particular communication protocols such as HTTP or SSL it is noted that any communication protocol including TCP based protocols and UDP based protocols may be used to communicate over network . Client components do not access data resource tier directly.

The processes running on remote application servers in business logic tier are commonly referred to as the application logic layer. These processes manage the business logic of the application and are permitted access to the services provided in data resource tier . The application logic layer is where most of the processing work occurs. Multiple client components presentation tier can access the processes running in business logic tier simultaneously so this application logic layer is implemented to manage its own transactions. It should be noted that application server clusters may be implemented and utilized in any of various types of systems and illustrates only one exemplary use. Although illustrates business logic tier having three application servers it is noted that the business logic tier may comprise any number of application servers. Each application server may interface with various types of other servers or systems. For example as illustrated in application servers may communicate with databases . Each application server in the cluster may interface with the same systems or application servers may differ in the systems with which they interface.

In exemplary embodiments application servers in business logic tier may or may not be in close physical proximity to each other. The application server computers may be connected to each other in any of various ways. In one exemplary embodiment each application server computer may be a member of a single local area network LAN . In another exemplary embodiment the application server computers may be distributed between two or more LANs wherein the LANs are networked together.

In exemplary embodiments application servers can be Java virtual machine JVMs running user applications. Application servers can be implemented for example to use Java technology to extend Web server capabilities to handle Web application requests. A Web application can comprise a collection of resources that may include web pages comprising HTML XML scripting code such as Javascript or VBScript or other types of elements. The resources may also include any of various types of executable programs or components such as CGI programs Java servlets JavaBeans components CORBA components downloadable code such as Java classes or ActiveX components etc. The resources may also include any other type of resource addressable through a URL. Application servers can comprise application code including servlets JavaServer Pages JSP files enterprise beans and their supporting classes and be implemented to make it possible to generate a dynamic customized response to a client request.

In exemplary embodiments application servers can be implemented such that administrated tasks that are responsible for the operational environment that is the process settings in which the resources that is executable programs or components run are performed using administrative clients such as for example administrative consoles scripting clients administrative programs for example a Java programming interface through which application configuration can be queried or modified and command line tools. Administrative tasks typically involve defining new configurations or performing operations on managed resources within the environment. These administrative clients can be used to manipulate meta information for example XML configuration files schema DTD files etc. that may describe elements or properties of configuration data and relationships for example hierarchical relationships among the elements of the configuration data by editing these meta information files. During development configuration data and thus the meta information describing the configuration data may be changed. In exemplary embodiments the configuration data for application servers can be maintained by an administration server. The administration server can for instance be implemented within back end data resource tier .

Referring now to an exemplary embodiment of an administration server is illustrated. includes administration server and meta information describing a persistent store of configuration information maintained by the administration server. Meta information may be configuration information in any of different formats including but not limited to XML LDAP DTD schema database based and file based. A configuration API is implemented within administration server that may be used as a basis for administering a server system. Configuration API includes a configuration context and represents the configuration information of persistent store in memory of administration server .

In exemplary embodiments all elements or properties of the persistent store may be represented in one or more meta information files for example XML files which may include rules defining the system configuration data including instances of configuration information for associated application components. In exemplary embodiments there may be one such file per instance in the server system. Meta information may describe configuration data elements to be administered and their attributes. This configuration information may include server level configuration information such as information describing data of persistent store and information describing deployed applications that application servers associated with administration server may run. For example an element called server may have attributes such as name locale s log root etc. These attributes may have default values described in meta information as well as a list of correct possible values and certain attributes may be described as REQUIRED or IMPLIED.

In exemplary embodiments configuration API may provide an interface to manage for example create read validate write and or delete the system configuration information of persistent store as represented by meta information and may abstract the persistent store for client components of administration server to provide flexibility of storage and location transparency. Configuration API can be used as a generic transparent access method to the backend storage of persistent store as represented in meta information independent of the format of the backend storage. In exemplary embodiments persistent store of configuration information may be distributed across one or more data storage devices and may be formatted in accordance with one of a variety of heterogeneous data storage formats for example the persistent store may be an XML file an object database a relational database or any other type of file based or database repository . The data storage format and or distribution of persistent store may be changed for example to meet changing requirements of the system. A query mechanism may be provided that uses a query language for example XML Path Language XPath to access persistent store and to hide the persistent store implementation.

In exemplary embodiments configuration API functionality may include but is not limited to one or more of basic configuration operations for example set and get elements and attributes APIs event notification and a change management mechanism. Client components of configuration API may do a lookup using the configuration API to construct an in memory representation of the corresponding configuration data from persistent store . Configuration API may provide support for distributed systems and may provide hierarchical semantics into the configuration data.

In exemplary embodiment configuration context may provide an interface that includes APIs to read persist and access persistent store data. Configuration context may provide central in memory abstraction of the configuration data. Configuration API also includes storage adapters of that may be used and switched below the configuration to interface to the particular persistent store format. Configuration context may be used for example by a listener service or container to look up configuration data as desired. In exemplary embodiments configuration context may be used to write to multiple storages on different machines with a single operation. In exemplary embodiments a configuration context may be created for each associated server during server initialization.

Configuration context can include an event notification mechanism that tracks changes to configuration data and allows clients to register a listener service if the clients desire to hear about changes to configuration objects. A configuration object refers to a configuration document that defines configuration instances of runtime client components. For each registered listener service configuration context tracks changes done to configuration objects implemented by the registered client. Each change may be obtained reset anytime from configuration context and can be used to trigger a notification event. Configuration context may propagate notifications about configuration changes for example add update delete set etc. to all registered listener services as listener objects. The listener objects built upon configuration API may be abstracted from the details of persistent store of the configuration data as well as from the tracking of changes. Using this event notification mechanism the listening clients may not need to access persistent store for configurations updates. Instead each client receives event notifications of changes and can update the appropriate elements and or attributes of its instances of configuration objects in memory as indicated in the listener objects provided by the notifications. In exemplary embodiments a query language for example XPath may be used to determine the locations of changes in configuration context . In exemplary embodiments notifications may be sent over a RMI Remote Method Invocation channel using a wire protocol for example JRMP wire protocol . In exemplary embodiments the changes cached in configuration context may be categorized into one or more notifications. Thus there may be a many to many relationship between configuration context cached changes and notifications.

In accordance with an exemplary embodiment of the present invention illustrates a flow diagram of a process for automating the updating of an instance of a configuration data for an administration client component in response to a change in the configuration data. In exemplary process at block the developer of the client component implements code within a source file for reading and returning one or more configuration data elements from the configuration files provided by performing for example a lookup of the a back end persistent store through a configuration API . This data may be for example provided in the form of a Java Properties file an XML file or other file type representing configuration information.

In the present exemplary embodiment an implementation of the configuration API termed ConfigService is provided support requests to read the configuration data elements from an object in the configuration context by the client component. ConfigService provides a programming interface through which the configuration context for a client component domain can be queried or modified. A call to ConfigService may be implemented to obtain all of the configuration data elements from a configuration object of the configuration context or to obtain only a subset or simply one of the configuration data elements from a configuration object. In exemplary embodiments the ConfigService implementation may return entire configuration objects queried from the configuration context for a client component domain from which the desired configuration data elements can be obtained or ConfigService may return only the desired data elements. In exemplary embodiments different calls to ConfigService at block may obtain data configuration elements from the same configuration object.

At block of exemplary process the developer also implements code within the source file for constructing corresponding internal data structure representations of the configuration data elements. This code uses the configuration data elements returned by the calls to ConfigService to construct the internal data structure representations and can comprise any of a number of suitable methods for constructing data structures. Such methods are well known and can provide all the necessary logic for mapping configuration data elements to the internal data structures and also may implement constraints on the data elements as defined in meta information. For example an internal data structure can be constructed in a hierarchical relationship to represent a hierarchical relationship of the configuration data elements. In the present exemplary embodiment the source file is implemented to reside within a ConfigUpdater class that includes get methods for the configuration data elements in the configuration API.

In the present exemplary embodiment at block the ConfigUpdater file containing the internal data structures created by the developer at block for example a file written in the Java programming language called ConfigUpdater.java is run through a transformer engine to create an interface that maps the data elements of the internal data structures to corresponding data elements of listener objects so that the internal data structures can be updated at runtime in responses to changes in configuration data. The transformer engine is implemented to perform a method that receives the ConfigUpdater source file as input and outputs a modified or transformed ConfigUpdater source file that contains code for updating an internal data structure at runtime whenever a change is made to the corresponding configuration data elements. In creating the interface the transformer engine utilizes an existing listener service for the configuration context for the client component that specifies mappings from the data elements of the configuration objects that are read using ConfigService at block to corresponding method names that obtain those data elements. Each listener object thus represents a configuration object in which configuration data has been changed. There is a one to one mapping relationship between number of different configuration objects that are read by the ConfigService calls implemented at block and the number of listener objects specified by the mapping provided at block .

In particular at block the method performed by the transformer engine creates a process path method for each call to ConfigService implemented at block that maps the corresponding data elements of the internal data structure to the configuration API. The method operates by examining the code implemented at blocks to determine the dynamic flow of objects from the configuration data elements to the internal data structures and the dynamic flow is then implemented within process path methods. Each process path method contains code for updating an internal data structure at runtime whenever the listener object corresponding to that internal data structure is fired by the listener service upon receiving notification of a change to the corresponding configuration data elements.

After the process path flow is created at block in exemplary process the ConfigUpdater source file can be compiled and run at block . During system development configuration data as well as the meta information describing the configuration data may be changed. By creating the ConfigUpdater file and running it through the transformer engine to create the listener interface the ConfigUpdater file is thereby configured to provide an automatic way to update the internal data structures representing configuration data when the configuration data is changed. Thus it is not necessary for the developer to manually locate every instance of the corresponding data elements or attributes in the internal data structures and make changes to the internal data structures to support changes in configuration data elements or attributes whenever such a change occurs.

To further illustrate exemplary process an example is now provided in which consider a HashMap internal data structure is implemented to represent configuration data mapping a Community UID to a list of domains associated with that Community UID. To construct the HashMap a developer could implement the pseudo code illustrated in . Upon running the code through the transformer engine and compiling as described at blocks and in exemplary process the ConfigUpdater will be implemented to use a process path for domains to update the HashMap with the new list whenever the domains change during runtime. As illustrated by the pseudo code in the process path method created in this example mimics the wellKnownMethod method implemented by the developer and shown in . That is the process path queries the configuration API for the domains and adds the return value into the HashMap using Community UID as the key as shown in .

As shown by this example the code for the listener object mapping method implemented by the transformer engine in a ConfigUpdater file is derived from the existing code for constructing the internal data structure. To illustrate this mapping relationship can be characterized by a tree data structure having a set of linked nodes in which the nodes represent code statements and the branches represent points of contact with other nodes. The root node of the tree represents the code statement where the configuration data elements are read directly from the configuration API using ConfigService. In the HashMap example provided above this would be the code statement List domains configService .getCommunityDomains Community uid in which the list of domains is obtained.

To further illustrate an exemplary embodiment of the method performed by the transformer engine to provide for listener object mapping is provided as pseudo code in . The exemplary transformer method of can be viewed as a flow of objects within the tree having endpoints where the flow stops and will now be described using the following terms as defined below 

Contact Message flow via objects that connects two statements. These two statements are said to be in contact.

Type 1 contact Represents a contact due to input parameters that are variables assigned in a previous assignment statement. Used for backward tracking.

Type 2 contact Represents a contact due to passing the assigned variable in an assignment statement as a parameter input to a method in a later statement. Used for forward tracking.

Forward tracking endpoint A statement that is a node that is not an assignment statement that is does not set a variable that could be used later or an assignment statement whose variable is never used.

Back tracking endpoint An assignment statement that is a node that assigns a literal or a member field to the variable or an assignment statement with method calls whose parameter inputs are exclusively literals and or member variables.

inLeftBranchTree node attribute Specifies whether a node was added as a left child in the tree during back tracking.

inRightBrachTree node attribute Specifies whether a node is added as a right child in the tree during forward tracking.

For a given method there could be backward flow representing objects passed into the method and forward flow representing variables that are set and used later. The method tracks both forward and backward object flow from this root node until all endpoints are reached. This flow path includes all the logic required to update the internal data structures upon a change to a given configuration object. The code for constructing the internal data structures is essentially repeated in the listener object mapping code to implement the logic that needs to be implemented to map a given configuration object to an internal data structure in a process path method that performs this logic when that object changes in the configuration.

The inLeftBranchTree and inRightBranchTree attributes specify if a given node was added to the tree during back tracking and forward tracking respectively. When the tree is built a node is only added as left child node the first time it appears when building from the left side and not on subsequent appearances. Likewise a node is only added as right child node the first time it appears when building the tree from the right side. Otherwise duplicate sub trees could result throughout the tree where multiple parent nodes point to identical child nodes.

The UID is the means by which configuration objects are identified in the code. Therefore the UIDs are hard coded within the code for accessing configuration objects. Upon change in configuration data the configuration API notifies the aggregate listener object by passing the UID of the configuration object that was changed to the corresponding listener object so that it can be used by the internal data structure to access the appropriate object from the configuration API. In alternative exemplary embodiments the process path methods can be created by the transformer to provide mappings that facilitate internal data structures in getting configuration data elements of changed configuration objects directly from the listener objects.

In the present exemplary embodiment the transformer method is implemented under the assumption that a list of node objects termed allNodesList in is provided in the order in which they appear in the code. For simplicity the present exemplary embodiment also assumes that there is no variable reuse that is each variable appears in no more than one assignment statement. The transformer method is recursive operating to first build the left branches then build the right branches and then traverse the tree to implement the statements for the listener code. The inLeftBranchTree node attribute ensures multi contacted left nodes appear farthest left in the tree and the inRightBranchTree node attribute ensures multi contacted right nodes appear farthest right in the tree. The left branches are added from the bottom up and left to right. The right branches are then added from the bottom up and right to left. To illustrate when the back tracking completes you will have a disjoint tree with only left branches as shown in the example in . After the forward tracking completes the tree has the right branches added as shown in the example in

In the HashMap example described above after the transformer method is performed the resulting tree will have two nodes that correspond to the two code statements in the domainsProcessPath method with a type 2 contact between the List domains configService .getCommunityDomains Community uid assignment statement and the map.put Community uid domains method call statement that represents a type 2 contact that results from passing the assigned domains variable from the first statement as a parameter input to the method of the second statement.

Exemplary embodiments of the present invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment including both hardware and software elements. In exemplary embodiments implemented in software the software can include but is not limited to firmware resident software microcode etc.

Furthermore exemplary embodiments can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. In exemplary embodiments a computer usable or computer readable medium can be any apparatus that may include store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Examples of optical disks include read only memory compact disk CD ROM read write compact disk CD R W and DVD.

In exemplary embodiments a data processing system suitable for storing and or executing program code may include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories that provide temporary storage of at least some program code to reduce the number of times code is retrieved from bulk storage during execution. Input output or I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers.

In exemplary embodiments network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently exemplary types of network adapters.

Although exemplary embodiments of the present invention have been described in detail it should be understood that various changes substitutions and alternations can be made therein without departing from spirit and scope of the inventions as defined by the appended claims. Variations described for exemplary embodiments of the present invention can be realized in any combination desirable for each particular application. Thus particular limitations and or embodiment enhancements described herein which may have particular advantages to a particular application need not be used for all applications. Also not all limitations need be implemented in methods systems and or apparatuses including one or more concepts described with relation to exemplary embodiments of the present invention.

While exemplary embodiments of the present invention have been described it will be understood that those skilled in the art both now and in the future may make various modifications without departing from the spirit and the scope of the present invention as set forth in the following claims. These following claims should be construed to maintain the proper protection for the present invention.

