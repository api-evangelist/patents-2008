---

title: Advanced security negotiation protocol
abstract: This disclosure describes methods, systems and application programming interfaces for creating an advanced security negotiation package. This disclosure describes creating an advanced security negotiation protocol under a Simple and Protected Negotiation Mechanism (SPNEGO) protocol to negotiate an authentication scheme. The protocol describes defining a Windows Security Type (WST) Library message to protect negotiation data during the advanced security negotiation protocol. The protocol sends an initial message that carries multiple authentication messages to reduce redundant roundtrips and implements key exchanges by a mini Security Support Provider (SSP).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08799630&OS=08799630&RS=08799630
owner: Microsoft Corporation
number: 08799630
owner_city: Redmond
owner_country: US
publication_date: 20080626
---
The subject matter relates generally to a security negotiation mechanism and more specifically providing a negotiation protocol to negotiate an authentication scheme under SPNEGO.

There are many negotiation mechanisms available when a client wants to authenticate to a remote server. One negotiation mechanism that is typically known is a Simple and Protected Negotiation Mechanism SPNEGO .

SPNEGO has many existing problems. One problem is that SPNEGO negotiates a common mechanism during a first round of negotiation. If this negotiated mechanism does not work and the client determines it does not have the necessary credentials based on a server policy the client can not attempt a different security package. Thus SPNEGO does not allow renegotiation after a first failed roundtrip. Another problem is that SPNEGO does not provide support for auxiliary data to be provided in the negotiation. Such auxiliary data can be useful or even required when the configuration information such as the trust anchors on both the client and the server are needed to determine if a particular security mechanism can authenticate the client and the server.

Although SPNEGO provides a common negotiation mechanism there is room for improvement. It is desirable to find ways to improve upon these problems and other deficiencies.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In view of the above this disclosure describes various exemplary systems methods and computer program products for providing an advanced security negotiation package under a Simple and Protected Negotiation Mechanism SPNEGO mechanism. The disclosure describes creating an advanced security negotiation protocol to negotiate an authentication scheme. Furthermore the protocol describes sending an initial message that carries multiple authentication messages to reduce redundant roundtrips.

This advanced security negotiation package maintains backward compatibility and reduces the operation costs when being deployed and configured for today s technological environment. Furthermore there is improved efficiency and convenience of minimizing a number of context establishment tokens by using the advanced security negotiation package between a client and a server. Thus security is improved and user experience is enhanced.

Many specific details of certain implementations of the subject matter are set forth in the following description and in to provide a thorough understanding of such implementations. One skilled in the art will understand however that the subject matter may have additional implementations or that the subject matter may be practiced without several of the details described in the following description.

This disclosure is directed to various exemplary methods computer program products and systems for an advanced security negotiation package. The package describes providing an advanced security negotiation protocol under a Simple and Protected Negotiation Mechanism SPNEGO mechanism. The package uses the advanced security negotiation protocol to negotiate an authentication scheme. Furthermore the package defines a Windows Security Type WST Library message the message is used to protect negotiation data the WST message includes a fixed length header and a variable length payload. The package sends an initial message that carries multiple authentication messages to reduce redundant roundtrips and implements key exchanges by a Security Support Provider SSP .

This disclosure also describes a client and a server supporting the advanced security negotiation package and or protocol in order for the advanced security negotiation package and or protocol to negotiate the authentication scheme. Benefits of the advanced security negotiation package include backward compatibility for applications running on a Windows system minimal management number of context establishment tokens and thus reduced cost of protocol negotiation. For example the advanced security negotiation package allows automatic updating.

The advanced security negotiation package described herein are not limited to any particular application but may be applied to many contexts and environments. By way of example and not limitation the advanced security negotiation package may be employed in Office Live Rich Client federation client software applications such as Word Excel Visio server applications such as SharePoint Exchange and Windows web based networking interfaces such as Winlnet WebDAV WinHttp RPC and the like.

The following discussion of an exemplary operating environment provides the reader with assistance in understanding ways in which various subject matter aspects of the system methods and computer program products may be employed. The environment described below constitutes an example and is not intended to limit application of the subject matter to any one particular operating environment.

The environment may include an advanced security negotiation package including but not limited to a tool a method a solver software an application program a service technology resources which include access to the internet and the like. Here the advanced security negotiation package is implemented as an application program .

The advanced security negotiation application program selects a negotiation mechanism and establishes security context. Then the process performs an authentication or an encryption scheme. The advanced security negotiation application program is a security package that creates a security protocol extended under a negotiation mechanism known as a Simple and Protected Negotiation Mechanism SPNEGO . SPNEGO invokes security context establishment if there is a common security mechanism between a client and a server.

This advanced security negotiation protocol can protect any negotiation information between the client and the server. This protection occurs when the underlying mechanism selected is capable of integrity protection. The term advanced security negotiation package is used interchangeably with the terms advanced security negotiation protocol and advanced security negotiation application program . The advanced security negotiation application program is operational when a client application attempts to authenticate to a remote server without knowing a priori what authentication protocols the other supports. The advanced security negotiation package application program operates under the SPNEGO mechanism and Windows Server. Once the negotiation protocols are selected and identified by the client and the server the advanced security negotiation protocol is used as an authentication mechanism between the client and the server.

The advanced security negotiation protocol offers an advantage by allowing auxiliary data to be used in negotiating the protocol. This auxiliary data is known as Authentication Metadata in web services security language which may contain information in helping a user perform the authentication. A benefit of the advanced security negotiation protocol allows renegotiation after a first roundtrip. For example the renegotiation facility can be used to select a subsequent authentication mechanism in cases when selection agreement was possible not in the first roundtrip.

Illustrated in is an exemplary system configured to negotiate the protocol negotiation session between a client computing device and the server over a network . The system illustrates architecture of some components on a client side and a server side . Alternatively these components may reside in multiple other locations. For instance all of the components of may exist on the client side or the server side . Furthermore two or more of the illustrated components may combine to form a single component at a single location.

The client side includes the client computing device to access services resources and applications on the system . The advanced security negotiation package is available to a user via a Security Support Provider Interface SSPI infrastructure of an operating system of the client side . The client operating system includes but is not limited to Windows Server System Windows Server Longhorn Windows Vista Windows 7 and the like.

The server side also includes similar components to the client side . For ease of understanding the components identified first by the reference number are ones associated with the client followed by the reference number for the components associated with the server side .

The SSPI authenticates the user by verifying user identification name and password and the like. The client and the server transmit information back and forth until SSPI are satisfied with the process. More details follow in regarding a client first protocol and a server first protocol respectively.

Referring back to are components that are similar on the client side and the server side . Shown is SPNEGO the negotiation protocol between the client and the server to negotiate an authentication protocol. Here the client and the server may propose an authentication package or exchange a list of authentication packages that each supports and accept the authentication package or choose one from the list of authentication packages. In some instances the authentication package may be rejected.

In this implementation Windows supports three primary SSPs for SPNEGO to handle negotiations as part of the process. The authentication packages shown are Kerberos the advanced security negotiation package and Windows NT Lan Manager NTLM . People skilled in the art are familiar with Kerberos and NTLM authentication packages. For example Kerberos tends to be a default authentication for a service in the computer network and NTLM is an authentication protocol used in various Microsoft network implementations. These two authentication packages are viewed as negotiable sub mechanisms of SPNEGO and may use an Active Directory.

The third authentication package is the advanced security negotiation package which enables enhanced negotiation capabilities. The client and the server should support the advanced negotiation package in order for negotiation to be handled by the advanced security negotiation package on behalf of SPNEGO . If the negotiation selected is the advanced security negotiation package the process may also include custom SSPs . These custom SSPs are to provide implementation and integration of additional protocols for other applications.

The advanced security negotiation package may be implemented as an SSP known as V5 SPMI SSP. The advanced security negotiation package supports a standard SPMI interface and may be able to negotiate a SSP that supports a V5 SPMI interfaces. The V5 SPMI interfaces add more operations functions that these SSPs need to implement. An object identifier OID of the advanced security negotiation package is 1.3.6.1.4.1.311.2.2.30. The OID is allocated in a Microsoft specific OID arc. One more change that the advanced security negotiation package brings is that instead of OIDs Global Unique Identifiers GUID are used to identify authentication packages. This is done to simplify the message processing and complexity associated with variable length OIDs. Furthermore the dependency of OID processing on ASN for encoding and decoding is also removed. Thus the security package that can be negotiated with the advanced security negotiation package is known as Auth Scheme.

Since some legacy SSPs are anointed with OIDs a mapping from the GUIDs to OIDs is necessary. If the Auth Scheme s GUID is x and this Auth Scheme does not already have an OID otherwise assigned the object identifier for this Auth Scheme is 1.3.6.1.4.1.311.2.2.30.x.

In an implementation Live and a third party SSP may each have own trust roots and certificate verification. These items may be part of the authentication protocol implemented by the authentication packages and may refer to the respective trust roots. As part of the negotiation the trust roots may be sent between the client and the server and the appropriate package chosen based on whichever one is supported in both machines. In this implementation both machines support both the package may be chosen in an order of choice by the user.

To avoid redundant roundtrips the authentication meta data blobs from each SSP may be sent together alongside the list of supported authentication packages in the initial round trip of the advanced security negotiation protocol . Since this authentication metadata may be part of the initial exchange the prescriptive guidance for such SSP writers is to be conscious to not produce a large chunk of data. Another prescriptive guidance may be that SSPs should not attempt to perform expensive key exchanges during the authentication metadata exchange. Any context establishment tokens should instead be encapsulated in the AP REQUEST and CHALLENGE messages. There may be at most one AP REQUEST CHALLENGE message per SSPI token but there can be multiple authentication metadata messages.

A basic unit of the advanced security negotiation protocol message is a Windows Security Type Library WST message. The WST message consists of a fixed length header and the variable length payload. A variable length field in the protocol message is described with the length and the payload offset in the message. Any offset field in the message contains an offset of the payload starting from the beginning of the structure header through the WST message.

The WST message contains the length of the header and the length of the whole WST message. The self describing property of WST messages provides framing when there are multiple WST messages in input or output SSPI tokens of InitializeSecurityContext or AcceptSecurityContext.

The WST messages for establishing a security context is called a conversation. A conversation is identified using the ConversationID in the message independent header. The ConversationID in the WST messages in a particular conversation is the same and is introduced in order to identify the messages that are part of the same negotiation.

The client generates a unique conversation ID and fills a common header. The ConversationID in subsequent messages should remain the same. The client also fills a Random field using a secure random number generator and fills AuthScheme with available authentication packages supported by the client in decreasing preference order. The WST AUTH SCHEME type is an alias for GUID.

There is an extension field in the advanced security negotiation package which contains extensions for future extensibility. The extension field was introduced as a placeholder to plug in data in a forward compatible way. That data can for example be used to implement fast reconnects. The interpretation of this data is specific to the type of the extension and is described as below.

All negative extension types the highest bit is set to 1 are unfavorable. If the receiver does not understand a critical extension the authentication should be rejected.

At block the process generates an authentication metadata token for each supported scheme by the client. The client authentication metadata token should be encapsulated in an EXCHANGE message with the message type WST MESSAGE TYPE CLIENT META DATA. Metadata means several things depending on the type of application. For example metadata may mean implementation of an authentication package to use certificate trust roots as metadata that may identify the implementation of an authentication package to be used in an application scenario. In other scenarios the site ID may act as metadata in Office Live and the claim types the server supports may act as metadata in federation case of Windows.

Both an AP REQUEST message and a CLIENT META DATA message are instances of the WST EXCHANGE MESSAGE structure with different message type values. An AP REQUEST message contains the type WST MESSAGE TYPE AP REQUEST while a META DATA message contains the type WST MESSAGE TYPE CLIENT META DATA. An example is shown below 

The AuthScheme field signifies the authentication scheme for which the EXCHANGE message is targeted. If the authentication scheme fails to produce the authentication metadata token the authentication scheme should be removed from a list of supported authentication schemes. The client can terminate the negotiation if the failure to acquire the initial authentication token implies an inability to authenticate in a secure fashion.

If there are more than one exchange messages the order in which the exchange message is included bears no significance. In other words the exchange messages are in an unordered set. The client may determine to terminate the authentication exchange to protect the client.

At block the server calls AcceptSecurityContext which may be added as part of a typical SSPI exchange with the CLIENT HELLO message sent by the client as the input token. The CLIENT NEGO message may be optionally followed by a set of CLIENT META DATA messages as described above in which case all the WST messages concatenated by the client are taken as a single input token.

The server verifies the CLIENT NEGO message to make sure the message is well formed. The server then examines the set of authentication schemes supported by the client and computes the list of authentication schemes mutually supported by the client and the server. The server should examine the extensions in the CLIENT HELLO message and reject any authentication with an unknown critical extension.

Block illustrates selecting a negotiation protocol. Here the output token starts as a SERVER HELLO message. The SERVER HELLO message is a WST HELLO MESSAGE structure of the WST MESSAGE TYPE SERVER HELLO message type. The AuthScheme field contains the set of mutually supported auth schemes. There is no extension in the HELLO message defined for the server but reserved for future extensibility. The authentication schemes are sent in the decreasing preference order of the server. The server does not need to honor the preference order chosen by the client.

The first authentication scheme in the SERVER HELLO message is the authentication scheme selected by the server. This is also known as the negotiated authentication scheme.

If the auth scheme selected by the server can return an authentication metadata token that contains server policy the server s authentication metadata should be encapsulated in a SERVER META DATA message and should be included in the output token of the initial call to AcceptSecurityContext and the meta data tokens are included in a returned output SSPI token.

If the auth scheme selected by the server requires a server challenge the server challenge should be encapsulated in a CHALLENGE message and should be included in the output token of AcceptSecurityContext this challenge message should immediately follow the SERVER HELLO message in order to optimize away a roundtrip. However the advanced security negotiation protocol allows for the authentication negotiation to span multiple roundtrips.

A CHALLENGE message is a WST EXCHANGE MESSAGE structure of the message type WST MESSAGE TYPE CHALLENGE. The AuthScheme field in the WST EXCHANGE MESSAGE structure signifies for which authentication scheme the server side challenge is targeted.

If the client included an AP REQUEST message and the AP REQUEST message is for a mutually supported scheme the AP REQUEST should be processed by the server or saved for future use. If the AP REQUEST message for the negotiated authentication scheme is processed by the server and the authentication produces a response the response should be encapsulated in a CHALLENGE message. There is at most one CHALLENGE message in the server response.

Both the client and the server can choose another authentication scheme at any time during the negotiation. If an authentication scheme was used and another authentication scheme is selected the previous authentication scheme may not be selected again in this conversation. If the client included the AP REQUEST for the authentication scheme in the initial SSPI token and chooses to select that auth scheme the client should send an alert type message signifying that auth scheme. This is to allow the server to continue the handshake by picking up the initial AP REQUEST message sent in the initial SSPI context token for this authentication scheme. The negotiation may eventually terminate when there is no more authentication schemes left from the mutually supported set.

At block there is a decision point on whether there is an agreement on the advanced security negotiation package . If there is no agreement as shown by the process proceeds to block indicating a failed negotiation.

If there is an agreement between the client and the server on the advanced security negotiation package the process travels to yes shown by .

The client then calls InitializeSecurityContext which may be added as a part of a typical SSPI exchange with the SERVER HELLO message as the input token note that the input token may contains one CHALLENGE messages as described above in addition to the SERVER HELLO message . If the server includes a CHALLENGE message for the negotiated authentication scheme the CHALLENGE message should be processed by the client. Otherwise the client picks one authentication scheme from the list of mutually supported authentication schemes in the server hello message and replies with a handshake message of the selected authentication scheme. The handshake message in the reply should be encapsulated in an AP EXCHANGE message.

Whenever there is a key available for either the client or the server a VERIFY message is produced and included in the output token. The authentication schemes managed by the advanced security negotiation package should support RFC3961 by producing a protocol key based on RFC3961. That protocol key is used as the base key in the parlance of RFC3961 to sign the WST messages in the conversation.

A VERIFY message is a WST VERIFY MESSAGE structure. The AuthScheme field signifies from which authentication scheme the protocol key was obtained. An example is shown below.

The WST verify message protects negotiation data prevents downgrade and ensures mutually preferred packages are selected. Thus both the client and the server should send a VERIFY message and receive a verify message in order for the advanced security negotiation package to complete the negotiation.

From there the process proceeds to authentication . In some implementations the server determines whether to terminate the authentication exchange in order to protect the server or the client.

The authentication schemes managed by the advanced security negotiation package should support RFC3961 by producing a protocol key based on RFC3961. That protocol key is used as the base key in the parlance of RFC3961 to sign the WST messages in the conversation.

In block the server makes the first call to AcceptSecurityContext with no input token and the output token starts as a WST message type. If the authentication scheme supported by the server requires a server challenge token the authentication scheme should be included in the initial context token from the server the output token of AcceptSecurtyContext . A server challenge message should be encapsulated in a CHALLENGE message. There can be one CHALLENGE message per authentication scheme in the initial context token.

Block illustrates the client then calls AcceptSecurityContext with the WST message as the input token note that in the input token the SERVER HELLO message may be followed by a list of CHALLENGE messages as described above in which case the WST messages concatenated by the server are taken as a single input token . If there is an unknown critical extension in the SERVER HELLO message the authentication should be rejected.

The output token starts as a CLIENT HELLO message. The client does not need to honor the preference order chosen by the server. The first authentication scheme in the CLIENT HELLO message is the negotiated authentication scheme. If the negotiated authentication scheme sends AP EXCHANGE handshake message the handshake message should be encapsulated in a AP REQUEST message and should be included in the output token of InitializeSecurityContext .

There is at most one AP REQUEST message in the client response. The client determines whether to terminate the authentication exchange in order to protect the server or the client.

Block shows the server then calls InitializeSecurityContext with the CLIENT HELLO message as the input token note that the input token may contain one AP REQUEST messages as described above in which case the two WST messages concatenated by the client are taken as a single input token .

If the client included an AP REQUEST message for the negotiated authentication scheme that AP REQUEST message should be processed. Otherwise the server can pick one authentication scheme from the list of mutually supported authentication schemes in the client hello message and replies with a handshake message of the selected authentication scheme. The handshake message in the reply should be encapsulated in an AP EXCHANGE message.

Block shows selecting an authentication protocol. The client and the server can proceed to exchange handshake messages as determined by the chosen authentication scheme. Both the client and the server can choose another authentication scheme during the negotiation at any time during the negotiation. If an authentication scheme was used and another authentication scheme is selected the previous authentication scheme may not be selected again in this conversation. The negotiation may eventually terminate when there is no more authentication scheme left from the mutually supported set. If the server included the CHALLENGE message for an authentication scheme in the initial SSPI token and chooses to select that auth scheme the server should send an alert message signifying that auth scheme. This is to allow the client to continue the handshake by picking up the initial CHALLENGE message sent in the initial SSPI context token for this authentication scheme.

Block illustrates sending a verify message. Whenever there is a key available for either the client or the server a VERIFY message is produced and included in the output token.

The authentication schemes managed by the advanced security negotiation package should support RFC3961 by producing a protocol key based on RFC3961. That protocol key is used as the base key in the parlance of RFC3961 to sign the WST messages in the conversation. For per message tokens such as the output tokens of MakeSignature and EncryptMessage the advanced security negotiation package implements RFC4121.

Advanced security negotiation package offers advantages of maintaining backward compatibility as there are no changes to the messages of RFC4178 and updates to the client and the server make optimistic negotiation possible in minimizing the number of context establishment tokens. The updates to the context are based on information collected from the user. Thus the backward compatibility and minimal context establishment tokens reduce the costs of protocol negotiation.

Memory may store programs of instructions that are loadable and executable on the processor as well as data generated during the execution of these programs. Depending on the configuration and type of computing device memory may be volatile such as RAM and or non volatile such as ROM flash memory etc. . The server may also include additional removable storage and or non removable storage including but not limited to magnetic storage optical disks and or tape storage. The disk drives and their associated computer readable media may provide non volatile storage of computer readable instructions data structures program modules and other data for the computing devices.

Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Additional types of computer storage media that may be present include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the server or other computing device.

Turning to the contents of the memory in more detail may include an operating system one or more application programs or service for implementing the advanced security negotiation application program . In one implementation the memory includes a manager module and a protocol management module . The manager module includes but is not limited to identifying and tracking a session. The protocol management module stores and manages storage of information such as session identifier session state computing devices of the user and the like and may communicate with one or more local and or remote databases or services.

The memory further includes a user interface module and a session module . The user interface module presents the user with the user interface to log in or log off in and out of a session and the like. The session module includes but is not limited to tracking a state of the computing devices logging in or logging off connecting or disconnecting and the like. The session module performs connections disconnections search functions such as performing searches to identify the client devices that are logged on logged off state of the client devices the status of the user and the like.

The memory may include application programming interface APIs module and an internal interface module . The APIs help support requests for creating the advanced security negotiation package identifying the account to be queried and an enumerating the account made by the advanced security negotiation application program .

The processing functionality may also contain communications connection s that allow the processing functionality to communicate with a stored database another computing device or server the user terminals and or other devices on the network. Communications connection s is an example of communication media. Communication media typically embodies computer readable instructions data structures and program modules. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.

The processing functionality may also include input device s such as a keyboard mouse pen voice input device touch input device etc. and output device s such as a display speakers printer etc. The processing functionality may include a database hosted on the processing functionality including but is not limited to session data network addresses list of computing devices and the like. All these devices are well known in the art and need not be discussed at length here.

The subject matter described above can be implemented in hardware or software or in both hardware and software. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed subject matter. For example the methodological acts need not be performed in the order or combinations described herein and may be performed in any combination of one or more acts.

