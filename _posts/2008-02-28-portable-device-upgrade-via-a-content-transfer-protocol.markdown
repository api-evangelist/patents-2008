---

title: Portable device upgrade via a content transfer protocol
abstract: Embodiments of the present invention provide a portable MTP framework. In an embodiment, the portable MTP framework includes an MTP communications stack and a portability layer. The portability layer decouples the MTP communications stack from the underlying platform, storage, and transport components, thereby achieving transport protocol, platform, and storage media independence. The portable MTP framework according to embodiments of the present invention includes platform-specific software components, including, for example, communications device drivers (USB, TCP/IP, etc.), a transport controller, a session handler, storage device drivers (USB drive, SD card, Hard disk, etc.), a storage controller, and a platform interface. The portable MTP framework further includes application-specific software components, including, for example, an MTP router, MTP agents, and MTP managers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788634&OS=08788634&RS=08788634
owner: Broadcom Corporation
number: 08788634
owner_city: Irvine
owner_country: US
publication_date: 20080228
---
The present application is related to U.S. patent application Ser. No. 12 071 987 filed Feb. 28 2008 U.S. patent application Ser. No. 12 071 988 filed Feb. 28 2008 and U.S. patent application Ser. No. 12 071 989 filed Feb. 28 2008 all of which are herein incorporated by reference in their entirety.

The present invention relates generally to portable device communications and more particularly to a portable communications framework.

Media Transfer Protocol MTP was developed as an extension to Picture Transfer Protocol PTP and is directed particularly to digital cameras portable media players and cellular phones.

One purpose of MTP is to facilitate communication with media devices that have transient connectivity and significant storage capacity. These media devices can be generally described as having intermittent or infrequent connections with a computer system or other device and typically fulfill their primary functionality while not connected to a computer system or other device.

Another purpose of MTP is to enable command and control of these media devices including remote invocation of device functionality monitoring of device initiated events and reading setting of device properties.

MTP is transport protocol independent. In other words MTP objects can be transported within virtually any transport protocol including USB Universal Serial Bus TCP IP Transmission Control Protocol Internet Protocol and Bluetooth for example. MTP is also operating system and file system independent. However conventional MTP frameworks are typically designed for specific transport operating system and file system configurations.

There is a need therefore for a portable MTP framework which is decoupled from the specific details of the device transport platform and storage systems thereby being usable in a variety of portable devices irrespective of the supported device transport platform and storage.

Embodiments of the present invention provide a portable MTP framework. In an embodiment the portable MTP framework includes an MTP communications stack and a portability layer. The portability layer decouples the MTP communications stack from the underlying platform storage and transport components thereby achieving transport protocol platform and storage media independence.

The portable MTP framework according to embodiments of the present invention includes platform specific components including for example communications device drivers USB TCP IP etc. a transport controller a session handler storage device drivers USB drive SD card Hard disk etc. a storage controller and a platform interface. The portable MTP framework farther includes application specific components including for example an MTP router MTP agents and MTP managers.

Further embodiments features and advantages of the present invention as well as the structure and operation of the various embodiments of the present invention are described in detail below with reference to the accompanying drawings.

The present invention will be described with reference to the accompanying drawings. Generally the drawing in which an element first appears is typically indicated by the leftmost digit s in the corresponding reference number.

MTP was developed as an extension to Picture Transfer Protocol PTP and is directed particularly to digital cameras portable media players and cellular phones.

One purpose of MTP is to facilitate communication with media devices that have transient connectivity and significant storage capacity. These media devices can be generally described as having intermittent connections with a computer system or other device and typically fulfill their primary functionality while not connected to a computer system or other device.

Another purpose of MTP is to enable command and control of these media devices including remote invocation of device functionality monitoring of device initiated events and reading setting of device properties.

It is noted that when used in the context of MTP the term media is used to identify any binary data and is not limited to audio video. Examples of non audio video data include contacts programs scheduled events and text files.

MTP follows a communication model in which MTP exchanges may only occur between two devices at a given time. is a block diagram that illustrates the MTP communication model. A first device acts as an MTP Initiator and a second device acts as an MTP Responder. MTP Initiator and MTP Responder are linked by a communications link that supports MTP communication. MTP Initiator may be for example a host computer and MTP Responder may be for example a hand held device. MTP Initiator and MTP Responder each includes suitable logic circuitry and or code as illustrated by processors and in to enable transfer of information via MTP.

MTP initiator initiates actions with MTP Responder by sending operations to MTP Responder over communications link . In response to operations MTP Responder sends responses to MTP Initiator . Typically MTP Responder does not initiate actions but may send unsolicited events to MTP Initiator .

Data flow in MTP is unidirectional. When an operation is initiated data flows from MTP Initiator to MTP Responder . Conversely data flows from MTP Responder to MTP Initiator when a response is being sent. As such bi directional flow occurs over multiple sequential operations responses.

Generally communication between MTP Initiator and MTP Responder is performed using MTP transactions where an MTP transaction includes up to three phases an Operation Request Phase an optional Data Phase and a Response Phase. A transaction ID is associated with data being communicated in each phase to identify the data as relating to the same MTP transaction. Generally the MTP Initiator generates transaction IDs incremented by one for each successive transaction.

A state diagram illustrating an MTP transaction is shown in . As shown an MTP transaction begins in an Operation Request Phase which includes initiating a transaction by transmitting an Operation dataset from the MTP Initiator to the MTP Responder. The Operation dataset identifies the operation being invoked by the MTP Initiator the context in which it is to be executed and includes a limited set of parameters. illustrates the data structure of an Operation dataset. As shown the Operation dataset includes an Operation Code field which identifies the operation being initiated. MTP supports a variety of operations including for example operations related to objects at the MTP Responder e.g. GetObject MoveObject etc. operations related to the MTP Responder device ResetDevice PowerDown etc. and operations related to the device storage e.g. FormatStore GetStorageInfo etc. . A complete description of MTP Operations and their usages can be found in the MTP specification which is incorporated herein by reference in its entirety.

Further as shown in the Operation dataset may include a Session ID a Transaction ID and up to five parameters.

The Session ID identifies an MTP session within which the operation exists which represents a communication state in which a connection has persisted between the MTP Initiator and the MTP Responder and a state has been maintained. Within a given session the MTP Responder state does not change without alerting the MTP Initiator to the change. It is noted that certain operations do not require a SessionID as they may be executed within or without an active session.

The operation parameters include information required to execute the operation. The contents of these parameters depend on the Operation Code field and or the context in which the operation is being used.

Referring back to an optional Data Phase may follow the Operation Request Phase . Typically the Data Phase is used to send any data that cannot be transferred using the parameters of the Operation dataset during the Operation Request phase. The type of data sent in the Data Phase also depends on the operation. For example for certain operations the data consists of datasets defined by the MTP specification. For others the data is binary data exchanged for the purpose of storage on the MTP Responder device.

Whether or not a Data Phase follows the Operation Request Phase depends on the operation sent in the Operation Request Phase . A typical example involves the sending of objects from an MTP Initiator to an MTP Responder which includes the MTP Initiator sending a SendObjectInfo operation which includes an ObjectInfo dataset in its data field in the Operation Request phase followed by a SendObject operation which includes the object in binary data in its data field in the Data Phase. The ObjectInfo dataset provides transfer context to the MTP Responder allowing it to allocate appropriate resources for the transfer.

It is noted that data flow in the Data Phase can be from the MTP Initiator to the MTP Responder or vice versa.

An MTP transaction terminates with a Response Phase as shown in . The Response Phase includes the MTP Responder transmitting a Response dataset to the MTP Initiator in response to the operation. illustrates the data structure of an MTP Response. As shown a Response dataset may include a Response Code a Session ID a Transaction I and up to five parameters.

The Response code identifies the result of the operation request. Response code options depend on the operation request and or the response context. The Session ID Transaction ID and the parameters serve substantially similar functions as described above with respect to the Operation dataset.

As described above MTP transactions are initiated only by the MTP Initiator. As such a mechanism is needed to enable the MTP Responder to proactively transmit information or alerts to the MTP Initiator. This is accomplished using Events in MTP which are typically one way transmissions from the MTP Responder to the MTP Initiator the MTP Initiator may also send events .

Events in MTP are not intended to convey information beyond the notification of a change of a given state at the MTP Responder. As such events are communicated to the MTP Initiator in the form of an event dataset which includes a minimum of required information to describe the event including an event code for example. When the event code alone is not sufficient to convey all information related to the event the receiving device the MTP Initiator is generally made to probe the sending device the MTP Responder for more information after receiving the initial event dataset. illustrates the data structure of an MTP Event. As shown an Event dataset may include an Event Code a Session ID a Transaction ID and up to three parameters. The Event Code field identifies the event being indicated by the dataset. A listing of event codes and their meanings can be found in the MTP specification.

Device representation in MTP is designed such that the capabilities and properties of a device can be exploited to enable a number of features including rich user interface UI representation of a connected device matching of content to device capabilities meta functionality on objects device state awareness and device command and control. These features are implemented by a combination of a device describing dataset DeviceInfo Dataset and flexible and extensible device properties. illustrates the MTP DeviceInfo dataset. The DeviceInfo dataset is used to provide a description of the device and can be obtained using the GetDeviceInfo operation. As shown in the DeviceInfo dataset includes among other fields a Device Properties Supported field which identifies by code all device properties that the device supports in its current functional mode. The device properties identify settings or state conditions of the device and are not linked to any data objects on the device. Device properties may be read only or read write and are defined by their DevicePropDesc dataset which can be retrieved with the GetDevicePropDesc operation. The DevicePropDesc dataset provides for example the device property value read write settings a default value and where relevant any restrictions on allowed property values.

MTP devices generally include a substantial amount of persistent data storage either within the device or on removable storage. Storage in MTP is identified using a 32 bit unsigned integer called a StorageID. The StorageID is subdivided into two halves with the most significant half identifying a physical storage location and the least significant half identifying a logical partition of the physical storage. Storage description is done using the StorageInfo dataset which is illustrated in . As shown the StorageInfo dataset includes among others a Storage Type field and a Filesystem Type field. The StorageType field identifies the physical nature of the storage described by the StorageInfo data set which may be a fixed Read Only Memory ROM removable ROM Fixed Random Access Memory RAM or Removable RAM. The Filesystem Type field identifies the logical file system including the file naming or directory structure conventions in used on the storage.

MTP is file system independent. As such MTP uses objects which are abstract containers to encapsulate media or other structured data. Examples of objects include for example image files audio video files contacts calendar task items and generic binary files.

An MTP object includes four parts the object s binary data the ObjectInfo dataset object properties and object references. The ObjectInfo dataset is a standard fixed dataset available for every object which provides basic information about the object. The ObjectInfo dataset was originally defined in PTP and has been largely replaced in MTP by Object Properties.

Object properties provide a flexible and extensible way of representing object metadata. Object properties serve to not only describe the actual content of the object but also to indirectly indicate the various structures a particular object format can take. Further object properties provide a mechanism for exchanging object describing metadata separate from the objects themselves thereby permitting the rapid enumeration of large storages regardless of the file system. Object properties are defined by an ObjectPropDesc dataset which is illustrated in .

To support object properties a device will be required to support the following operations GetObjectPropsSupported GetObjectPropValue and GetObjectPropDesc. Operations support of a device is listed in the DeviceInfo dataset of the device. A device that further supports the setting of object properties supports the SetObjectPropValue operation.

In step the Initiator initiates a GetObjectHandles operation in response to which the Responder sends the ObjectHandle array.

In step the Initiator initiates a GetObjectPropSupported operation to which the Responder responds by sending the ObjectPropCode array which includes codes of object properties supported.

In steps and the Initiator requests descriptions of the object properties by repeatedly invoking the GetObjectPropDesc operation for all object handles received in step . In response to each GetObjectPropDesc operation the Responder responds by sending the corresponding ObjectPropDesc dataset. Subsequently in steps and the Initiator requests the values of the object properties by repeatedly invoking the GetObjectPropValue for object handles received in step . In response to each GetObjectPropValue operation the Responder responds by sending the value of the corresponding object property.

MTP is transport protocol independent. In other words MTP objects can be transported within virtually any transport protocol including USB TCP IP and Bluetooth for example. MTP is also operating system and file system independent. However conventional MTP frameworks are typically designed for specific transport operating system and file system configurations.

There is a need therefore for a portable MTP framework which is decoupled from the specific details of the device transport platform and storage systems thereby being usable in a variety of portable devices irrespective of the supported device transport platform and storage.

Embodiments of the present invention provide a portable MTP framework. In an embodiment the portable MTP framework includes an MTP communications stack and a portability layer. The portability layer decouples the MTP communications stack from the underlying platform storage and transport components thereby achieving transport protocol platform and storage media independence.

The portable MTP framework according to embodiments of the present invention includes platform specific software components including for example communications device drivers USB TCP IP etc. a transport controller a session handler storage device drivers USB drive SD card Hard disk etc. a storage controller and a platform interface. The portable MTP framework further includes application specific software components including for example an MTP router MTP agents and MTP managers.

Transport Controller layer provides an Application Programming Interface API to abstract a plurality of different transport protocols including USB TCP IP WIFI and Bluetooth. Session Handler layer provides coarse level packet inspection and session management functionalities. MTP Router layer provides application specific packet routing functionalities. MTP Agents layer provides application specific fine level packet inspection and management functionalities. MTP Managers layer provides application specific MTP logic. MTP Applications layer include end user applications. Further description of the different layers and components of portable MTP framework will be further described below.

Portable MTP framework can be implemented within a portable MTP device and enables the device to act as either an MTP Initiator or an MTP Responder. When the portable device acts as an MTP Responder as is primarily the case the MTP stack responds to Operations and Events sent by an MTP Initiator such as a Windows Media Player application for example running on a computer attached to the device. The MTP stack may also initiate asynchronous MTP Events for reporting specific events at the portable device.

As shown in portable MTP framework includes a Transport controller a Session handler a Responder Router a plurality of MTP agents and a plurality of MTP managers . These components correspond substantially to Transport Controller layer Session Handler layer MTP Router layer MTP Agents layer and MTP Managers layer respectively of portable MTP framework described above. Portable MTP framework further includes a DataPhaseAccelerator component which makes part of the Session Handler layer and communicates with Session Handler .

Portable MTP framework further provides a plurality of APIs including for example a Platform Interface component a Storage Controller component and a Metadata Manager component .

As described above Transport controller is a platform software component which serves to abstract the specific details of the transport protocol used e.g. USB TCP IP etc. from upper layers of portable MTP framework . In other words Transport controller enables MTP objects to be communicated over various transport mechanisms in a manner transparent to the upper layers of the MTP stack. In an embodiment Transport controller hides the details of interfacing with the underlying transport by providing a common API with a common set of transport data structures to the upper layers of portable MTP framework .

In an embodiment Transport controller supports multiple simultaneous transports and provides interfaces for three separate simultaneous channels per transport including a control channel a payload channel and an event channel. The control channel is used to carry MTP control information including Operation Event and Response Datasets. The payload channel is used for the transfer of payload data including structured metadata and binary media file data. The event channel is used to send asynchronous events from the MTP Responder to the an MTP Initiator.

Session handler provides an interface between upper layers of portable MTP framework and Transport Controller . In particular session handler provides a coarse grained packet inspection function of incoming control data to ensure that valid Operation Event and Response datasets are received before passing them to the upper layers of portable MTP framework . Subsequently session handler routes the incoming control data to either Responder Router in the case of an MTP Responder as illustrated in or to appropriate MTP Initiator code in the case of an MTP Initiator .

In addition session handler provides an API for sending MTP Operation Event and Response datasets over a control channel of the transport. The API can be used by either MTP Initiator code or MTP Responder code. As such session handler supports both MTP Responder and MTP Initiator roles. Further session handler provides an API for sending and receiving payload data including metadata datasets and media files over a payload channel of the transport.

Session handler further provides an API for optimized sending and receiving of payload data between storage drivers and the transport within portable MTP framework . This API is referred to herein as DataPhaseAccelerator and will be described in further detail below.

Session handler further provides session management functionality including management of the OpenSession and CloseSession operations. Generally one session is allowed for incoming traffic and one session is allowed for outgoing traffic i.e. one session per Initiator role and one session per Responder role .

If a DataPhaseInterrupt is received the state machine proceeds to state which includes invoking the DataPhaseAccelerator API. The DataPhaseAccelerator then controls the details of the data transfer between the storage systems and the transport. Otherwise the state machine proceeds to state which includes inspecting the incoming packet to determine whether it is a valid MTP Operation Event or Response dataset.

If the incoming packet is an unrecognized dataset the state machine proceeds to state and then to state which includes sending a response code to indicate incomplete transfer. If on the other hand the incoming packet is recognized as an MTP packet the state machine proceeds to state and then to either state or state depending on whether or not a session is currently open.

If a session is currently open the state machine proceeds to state . Subsequently if the incoming packet is a closeSession operation the state machine proceeds to close the session by moving into states and successively. Similarly the state machine proceeds to close the session if the incoming packet is a cancelTransaction event by moving into states and successively. If the incoming packet however is a valid dataset the state machine proceeds to send the incoming packet to the router in states and .

If no session is currently open the session handler may also be able to handle the incoming packet if it is one of certain operations which do not require an open session. As shown in the incoming packet may be a GetDeviceInfo operation which the session handler manages by forwarding it to the router which routes the incoming packet to the appropriate device in states and . The incoming packet may also be an OpenSession operation which the session handler manages by proceeding through states and successively to send an Open Session response and set the Session state as open. On the other hand if the incoming packet is an unsolicited packet that does not match any of the two operations just described the state machine proceeds through states and to send a response code indicating that the session is not opened.

As described above the session handler provides a data transfer optimization API to optimize data transfer between an Initiator e.g. Windows Media Player running on a computer and a Responder e.g. portable device . This includes among other features optimizing data transmission between the storage devices and the transport layer. In an embodiment as illustrated in this is achieved by implementing a common API DataPhaseAccelerator API shared by Transport Controller and Storage Controller will be described further below which manages all the underlying details of interfacing the transport and storage layers to allow for maximum data transfer performance.

DataPhaseAccelerator API can be used to transfer the binary portion of large media files when a GetObject SendObject operation is invoked by the Initiator to retrieve send an object from to the Responder.

DataPhaseAccelerator API also handles any interrupts to data transfer independently from Session Handler . This is described in which illustrates a state machine diagram of the DataPhaseAccelerator interrupt handling functionality. As shown state machine begins in state which includes receiving control data. If the control data received is a CloseSession operation state machine proceeds to state . Subsequently if the data phase is inactive state machine proceeds to state before returning to the session handler in state . However if the data phase is active which means that either a data send or a data receive is in progress state machine will proceed to either state or state as shown in . State machine will then proceed to either state or state to stop the data send receive before returning to the session handler in state . On the other hand if the control data received is a CancelTransaction event state machine proceeds to state . Subsequently state machine as shown in will behave in a similar manner as described above with respect to the CloseSession operation. If the control data received is any other operation event code state machine will proceed to state and then return to the session handler in step .

State machine can be implemented in various hardware software and or firmware topologies including sub embedded software running on an embedded processor for example.

Storage controller of portable MTP framework is a platform software component which provides an API to abstract the interfacing with supported device storage systems. As shown in for example storage controller provides an interface with an IDE Integrated Drive Electronics Drive an SDRAM Synchronous Dynamic Random Access Memory memory and a USB memory stick.

In an embodiment abstracting the interfacing with storage systems includes abstracting file operations e.g. open read write delete close etc. and partition mounting of storage partitions including among others DRM Digital Rights Management stores metadata databases and removable storage. Generally storage controller discovers storage partitions through Platform interface which in certain platforms retrieves partitions information from NVRAM non volatile RAM .

In another embodiment storage controller further manages notification events for hot plug and hot unplug removable storage calls appropriate code to update the database e.g. add objects and initiates events via MTP as needed. For example storage controller initiates MTP events such as StoreAdded StoreRemoved to indicate the addition removal of a storage system.

Also as described above storage controller supports data transmission optimization for data transfer with Transport Controller using DataPhaseAccelerator API .

In a further embodiment storage controller manages the enumeration and un enumeration of media files on fixed and or removable storage partitions.

Platform interface of portable MTP framework is a platform software component which provides several APIs to support the portability of platform specific resources. For example platform interface provides a portability API to abstract platform resources and libraries including file systems and persistent storage e.g. NVRAM . In an embodiment the portability API includes a run time API that supports file system abstraction e.g. open read write etc. of persistent storage. Platform interface further provides a user notification interface API which allows portable MTP framework to provide error and status messages to an application for display in a GUI.

In another aspect platform interface provides a Firmware Upgrade API which enables a firmware upgrade cycle of the device via MTP. is a process flowchart that illustrates a method of performing firmware upgrade using MTP according to an embodiment of the present invention. Process begins in step which includes receiving an MTP object. In an embodiment step is achieved via the SendObject MTP operation.

Step includes routing the received object to the Object Agent of portable MTP Framework . As shown in the Object Agent is an MTP agent located in the Agents layer of portable MTP framework .

Step includes determining if the received object is a firmware upgrade object. In an embodiment step includes checking the received object for the undefined firmware property code which is a property code associated with a firmware upgrade object in MTP. In other embodiments step includes checking a specified file type or file name associated with a firmware upgrade object.

If the received object is not a firmware upgrade object process proceeds to step which includes calling the Object Manager to appropriately handle the received object.

On the other hand if the received object is determined to be a firmware upgrade object in step process proceeds to step which includes calling the Firmware Manager to initiate the firmware upgrade process. Note that the Firmware Manager not shown in is a unique manager in MTP in that it requires no corresponding MTP agent.

Subsequently step includes calling the Firmware Upgrade API of platform interface by passing it the received object. When the Firmware Upgrade API receives the object it proceeds in step to shut down all system processes install the firmware upgrade and initiate a reboot of the device.

Note that the firmware upgrade cycle modifies the MTP DeviceInfo dataset of the device to reflect the upgraded firmware information. Generally the new firmware information is stored in the NVRAM of the device and will be reported to the initiator e.g. Windows Media Player on PC via a SendDeviceInfo response.

Metadata manager provides an API that can be used by native application components e.g. Media Player application GUIs etc. as well as MTP stack components e.g. Object manager Playback manager etc. of portable MTP framework to manage metadata. In an embodiment Metadata manager uses Database controller which is a database interface code to control the database.

Database controller provides primitive database operations including an API abstraction for storing and retrieving MTP Object Properties and Object Associations in a database. In an embodiment Database controller provides SQL database operations.

As noted above the MTP database can be accessed via Metadata manager by either MTP stack components and native GUI applications illustrated in as Applications GUI . However the behavior of portable MTP framework is different with respect to the MTP database based on the operating mode of the framework. According to embodiments of the present invention portable MTP framework can operate in the following modes 

During this mode the portable MTP framework does not run. As such it is for the native GUI application to notify the portable MTP framework of any objects which have been added removed from the portable device while in this mode.

As described above in certain operating modes the native GUI application may modify the database while the portable MTP framework is not running. These changes need to be reported to the remote PC initiator. Accordingly a mechanism is needed to notify the portable MTP framework of any changes made to the database when the portable MTP framework returns to Slave mode.

According to an embodiment of the present invention this is achieved using Change Tables which are tables created and updated by Database controller every time the native GUI application accesses database controller via metadata manager to reflect changes to objects or storage. illustrates an exemplary database change table according to an embodiment of the present invention. As shown the database change table includes listings of changes to objects and to storages.

In an embodiment change tables are maintained transparently in database controller for all database transactions. However they are only used during startup of the portable MTP framework. For example upon entering Slave mode the change tables are processed by the portable MTP framework and appropriate events are sent to the remote PC initiator. The change tables are then be deleted. is a state machine diagram which illustrates the usage of database change tables. As shown state machine diagram begins with the initialization of the portable MTP framework in states and . Subsequently state machine proceeds to either state or state depending on whether or not the portable device is connected to the remote PC initiator.

If the portable device is connected to the remote PC initiator state machine proceeds to state which includes shutting down the native GUI application and then to state which includes starting the portable MTP framework in Slave mode. Subsequently state machine proceeds to reading the change tables in state and sending object events in state and storage events in state . Then state machine proceeds to state which includes purging the change tables before returning control to MTP Responder Router in state . illustrates example MTP events that the portable MTP framework may send to a remote PC initiator based on the change tables.

On the other hand if the portable device is not connected to the remote PC initiator state machine proceeds to state which includes shutting down the portable MTP framework and then to state which includes starting up the native GUI application. The portable MTP framework thus enters into the native GUI mode in state . During this mode as described above the native GUI application may access the database to add objects via state remove objects via state or to enumerate media files via state . As shown the native GUI application accesses the database via metadata manager in state which in turn uses database controller in state . Throughout this operating mode as described above database controller maintains changes to the database in change tables as illustrated in state .

Accordingly the above described mechanism allows the creation of an audit trail of database changes when the portable MTP framework is shut down which can be communicated to the remote PC initiator as soon as the portable MTP framework is restarted. In other words this enables an automatic synchronization mechanism via MTP of a shared database between the portable device and the remote PC initiator.

As shown in portable MTP framework includes a responder router a plurality of MTP agents and a plurality of MTP managers .

Responder router performs the functions of 1 routing received MTP Operations and Events to an appropriate agent of MTP agents and 2 returning MTP Responses to Transport controller on behalf of MTP agents .

MTP agents and MTP managers are designed to operate in a paired fashion as shown in . Generally MTP agents deal with MTP protocol specific issues e.g. packing and unpacking MTP packets on behalf of MTP managers . MTP agents can be initiator agents or responder agents. Since portable devices are primarily used as MTP Responders the majority of agents in portable MTP framework are responder agents. However portable MTP framework can also be designed to be implemented within an initiator according to the present invention.

MTP managers deal with application specific issues such as interfacing with the GUI application and the database. As with agents MTP managers can be initiator or responder agents. As shown in MTP managers access Platform interface Database Controller Storage Controller and the DRM library as needed.

Various example use cases are provided in this section in the form of sequence diagrams to illustrate the operation of and interaction between different components of the portable MTP framework. These example use cases are provided for the purpose of illustration and are not limiting of possible operations interactions and or functions allowed by the various components of the portable framework.

The present invention may be implemented using hardware software or a combination thereof and may be implemented in one or more computer systems or other processing systems.

Computer system includes one or more processors such as processor . Processor is connected to a communication infrastructure e.g. a communications bus cross over bar or network . Various software embodiments are described in terms of this exemplary computer system. After reading this description it will become apparent to a person skilled in the relevant art s how to implement the invention using other computer systems and or architectures.

Computer system can include a display interface that forwards graphics text and other data from communication infrastructure or from a frame buffer not shown for display on display unit .

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . Secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. Removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative embodiments secondary memory may include other similar devices for allowing computer programs or other instructions to be loaded into computer system . Such devices may include for example a removable storage unit and an interface . Examples of such may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an erasable programmable read only memory EPROM or programmable read only memory PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a Personal Computer Memory Card International Association PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path e.g. channel . This channel carries signals and may be implemented using wire or cable fiber optics a telephone line a cellular link an radio frequency RF link and other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage drive a hard disk installed in hard disk drive and signals . These computer program products provide software to computer system .

Computer programs also referred to as computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable processor to perform the features of the present invention. Accordingly such computer programs represent controllers of computer system .

In an embodiment where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive hard drive or communications interface . The control logic software when executed by processor causes processor to perform the functions of the invention as described herein.

In another embodiment the invention is implemented primarily in hardware using for example hardware components such as application specific integrated circuits ASICs . Implementation of the hardware state machine so as to perform the functions described herein will be apparent to persons skilled in the relevant art s .

In yet another embodiment the invention is implemented using a combination of both hardware and software.

Embodiments of the invention may also be implemented as instructions stored on a machine readable medium which may be read and executed by one or more processors. A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computing device . For example a machine readable medium may include read only memory ROM random access memory RAM magnetic disk storage media optical storage media and flash memory devices 

Further firmware software routines instructions may be described herein as performing certain actions. However it should be appreciated that such descriptions are merely for convenience and that such actions in fact result from computing devices processors controllers or other devices executing the firmware software routines instructions etc.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art that various changes in form and detail can be made therein without departing from the spirit and scope of the invention. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

