---

title: Architecture for data validation
abstract: A data validation architecture is provided that minimizes duplicate code and enables easy creation of new validations using a high-performance and scalable design. Such an architecture provides sufficient flexibility to disable certain validations when they are not applicable to the flow, interpret validation failures differently according to requirements of the calling application, and specify the type of document for which a particular validation is applicable. The architecture provides a standardized flow for performing data validation, specifying a set of required parameters for validation subroutines, as well as where validation results are to be stored for access by a calling program. Such an architecture also provides a framework for performing common processing required for most validation flows without restricting the flexibility of the validation subroutines.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08418142&OS=08418142&RS=08418142
owner: Oracle International Corporation
number: 08418142
owner_city: Redwood Shores
owner_country: US
publication_date: 20080122
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates generally to data validation and in particular to providing a scalable architecture for validating data that reduces duplication of code and enables easy creation of new validations.

In many computer and network based systems information often needs to be validated to ensure for example that the information is complete correct in the proper format of a maximum length or any of a number of other such aspects. When validating data to be stored into a database system for example there can be a number of such validations that can be done with strict rules as to the form and content of the data. Because many systems today are distributed and further involve both client side and server side aspects this can allow validation to be done at a number of different points across a system or network. Because these different points can be different types of devices can be running different software and or can utilize different technology different versions of the code needed for data validation typically needs to be generated and maintained which results in an undesirable duplication of code. The need for such duplication further results in increased cost and time in developing maintaining and deploying the code as well as increased complexity in calling validations depending upon where the validation will be done.

In an example of an e business application for example applications can be developed on two main technology stacks such as Java and PL SQL. illustrates an exemplary environment for implementing such an application wherein a client device communicates with an application server across a network . In this example the network is the Internet and the environment accordingly utilizes a Web server to receive requests and serve content but it should be understood that any of a number of other appropriate networks such as intranets or local area networks LANs can be used as discussed elsewhere herein. In such an environment a validation can be done on the client device such as before the data is submitted across the network and another validation can be done at the application server or another appropriate back end device before the data is entered into the appropriate data storage device . In one example and entity level validation can be done on the client device such as for validating that the quantity for an item being ordered on a purchase order is greater than 0 using a Business Components for Java BC4J architecture for a browser application where the validation code is generally contained within the entity object EO itself. A validation also can be done on the back end or the client side for an import program using PL SQL or another appropriate language which allows the data to be imported without a user having to enter the data through the browser application. Both the validation module for the browser application and the validation module for the import application need to execute the same or similar validations such as where each supports purchase order creation. Currently this requires repeating the validations in both technology stacks utilizing different code algorithms.

Further there may be a number of fields of data that need to be validated. Currently there is no easy way to control the order and timing of the validations for the various fields. When passing between pages such as a summary page and a detail page it would be desirable to be able to control the order and timing along with other such aspects.

Systems and methods in accordance with various embodiments provide an architecture for data validation that minimizes duplicate code and enables easy creation of new validations using a high performance and scalable design. Such an architecture also provides sufficient flexibility to disable certain validations when they are not applicable to the flow interpret validation failures differently according to requirements of the calling application and specify the type of document for which a particular validation is applicable. A validation architecture can provide a standardized flow for performing data validation the standard specifying a set of required parameters for validation subroutines as well as where validation results are to be stored for access by the calling program. Such an architecture also can provide a framework for performing common processing that is required for most validation flows without restricting the flexibility of the validation subroutines. While the architecture provides great flexibility validation processing can be standardized such as by specifying the source for most validation data.

In one embodiment data is validated by first providing a validation architecture including code for validating data where the code is written in a first language. The validation architecture includes or provides an interface operable to receive validation calls from applications written in the first language and at least one other language. When a validation call is received that includes a validation set a validation is performed for each instance of information in the validation set. In this embodiment the validation set includes information for at least one validation to be executed using the validation architecture. Any errors or warnings are determined for each validation and the results of each validation along with any errors or warnings are returned in response to the validation call.

The validation call in this embodiment can be received from a remote application a local application a front end application a back end application a front end layer a back end layer or a middle layer. The call in one embodiment is a bulk call including a plurality of instances of information to be validated. The first language can be a language such as PL SQL where the interface is a PL SQL API operable to function as a starting point for entity level validations. The method also can include steps such as defining standardized methods for passing entity attributes to be validated in the validation calls as well as storing all validation logic relating to the validation architecture in a central location. Steps also can include receiving a subroutine to enable an additional validation procedure to be executed via the validation framework and registering the subroutine with the validation framework.

In addition to other methods that can be used in accordance with these and other embodiments there also are a number of systems computer products and other such aspects for implementing practicing performing or otherwise utilizing aspects of the various embodiments.

A further understanding of the nature and the advantages of the inventions disclosed herein may be realized by reference of the remaining portions of the specification and the attached drawings.

Systems and methods in accordance with various embodiments overcome the aforementioned and other deficiencies in existing validation approaches by providing an architecture useful in standardizing a portion of the validation process. An interface such as a PL SQL API in one embodiment can serve as a starting point for all entity level validations. Underneath the interface is a validation architecture that provides the framework for developers or other users to define validations.

A validation architecture in accordance with one embodiment includes a single entry point for invoking the entity validation API as well as a standard way to define methods for passing in the entity attributes to be validated in ways that are efficient easy to maintain and take advantage of maximum code sharing ability. The architecture also can include a central location for storing all validation logic for the various entities which makes it easy for developers to locate the appropriate code. An architecture can provide a standard way for calling programs to define the validations to be executed as well as a standard way to record validation errors and report any errors back to the calling program. The architecture can reduce code duplication while allowing developers to easily add validations for any entity. While the architecture can be developed in a certain language such as PL SQL validations can be shared by multiple modules regardless of whether they are called in languages such as Java or PL SQL for example. A calling program can allow for the validation of multiple records from the same entity in a single call while validations can be done in bulk or batches for better performance where appropriate. As discussed elsewhere herein previous approaches would have performed validations record by record.

A user of a calling application or other such user likely would prefer to have at least some control over when validations occur. Further it would be desirable for the validation to be able to be shared between the front end and the back end such that the validation can be accomplished without duplication whether a user enters data into a front end application such as a Web page and or dumps data into tables in an interface application that can be imported into the back end applications. Currently a validation for the front end application needs to be in the front end layer such as a Java layer while the back end process is done in PL SQL in one example. In such an example Java cannot be called from PL SQL but PL SQL can be called from Java. In such a case a validation architecture can be created in the PL SQL layer such that programs in both layers can call the PL SQL based validation providing a single access point for validations.

Further using such an architecture provides advantages over certain existing systems because it is not necessary to call each validation separately when there are a number of validations to be processed. In many existing systems a user or application uses calls to validate a first field for a record then validate a second field for a record and so on such that the validations are done one call at a time. A user of a system in accordance with one embodiment is able to predefine a list of validations to be done within the architecture. A user then can have a list or validation set indicating the validations that will be done. A calling program then can simply use that validation set and pass the set to the validation architecture. Passing the set indicates the validations to be done and the calling program does not indicate or care how the validations are done. The architecture will execute the validations in the set one by one without separate calls or instructions and will have a common way of returning any errors or warnings. Thus the calling program does not have to worry about how certain things are implemented and can be located at any appropriate layer in the system. The use of standardized calls and logic allows any appropriate application module or other such entity to simply pass in the validation set and the architecture takes over processing.

When new validations are required by a business flow in one embodiment a developer can implement a minimal set of subroutines to enable the validations. First the developer implements each subroutine to perform a specific validation. These subroutines may exist outside of the validation packages but still obey the specifications of a validation subroutine. Once these subroutines are implemented the developer makes the subroutines known to the validation architecture and registers the subroutines as part of an executable set of validations. Such functionality can be provided easily with just a small bit of coding in the validation package.

Once the validation subroutines are made known to the validation architecture calling applications or other such callers can invoke a validation interface e.g. an API which will execute the appropriate validations. The validation architecture can call each validation subroutine collect all of the output and return any validation errors or warnings to the caller as for example a PL SQL object.

In one embodiment APIs that will be exposed by the validation architecture have the following common parameters 

A validation architecture can be used to validate an entity record such as a header or line of a purchase order. Each entity that utilizes this validation architecture will have a corresponding  VAL TYPE object defined in the database. The object in this example is essentially a list of tables with each table having one column corresponding to an attribute in the entity. An example of such an object here PO HEADERS VAL TYPE takes the form of the following 

In some instance validation requires parameters that are not in the entity. Such parameters are passed in as two lists in one embodiment including a first list that stores the names of these parameters and a second list that stores the corresponding values for these parameters i.e. p parameter name tbl and p parameter value tbl . Each validation subroutine in one embodiment must take common parameters. Examples of such common parameters are as follows 

When a validation subroutine detects a validation error or warning the subroutine can insert the error into a global temporary table such as PO VALIDATION RESULTS GT. A parameter such as x result set id can be used to identify the records. Such a method might be used when the validation is performed via a SQL statement for example. The subroutine also could add the error in a parameter x results which is of type PO VALIDATION RESULTS TYPE. Such an approach might be used when the validation is performed in PL SQL code for example.

Once all validations of a set are performed the validation architecture can extract the results from an appropriate location such as global temporary table PO VALIDATION RESULTS GT and can add the results to PO VALIDATION RESULTS TYPE. The PO VALIDATION RESULTS GT table can contain the detailed results of the validation subroutines and can be served as a temporary table into which the validation subroutines can populate results. An example of such a table is as follows 

The PO VALIDATION RESULTS table also can contain the detailed results of the validation subroutines. An object of this type will eventually be returned to the caller with all the results coming from the validation subroutines. An example is as follows 

A package such as PO VALIDATIONS package can contain procedures responsible for implementing a validation architecture. Developers who implement new validations can add their validation subroutine calls to this package. Such a package can be used to perform common processing that is generally required by most validation flows. The following are primary components inside an exemplary PO VALIDATIONS package 

As discussed above there can be a number of validation subroutines each with a validation subroutine identifier as well as any number of validation sets from the caller s . In one embodiment each validation identifier is simply a constant of varchar2. As long as it is unique the value of the constant is not important. The convention is that the value is the same as the name of the constant.

Validation sets can group these identifiers together. A different validation set may be used depending on the module that calls the validation subroutine as well as the entity record for which the validation is being performed. All the validation sets can be defined in the PO VALIDATIONS package as well 

The following example illustrates how new validations can be added to the architecture in accordance with one embodiment. When adding a new validation a caller first implements the validation subroutine. The caller or developer then adds a call to the subroutine from a procedure such as a PO VALIDATIONS.validate set procedure. A new validation subroutine identifier is created and the validation subroutine is added to a validation set. A public subprogram e.g. validation API is included to execute the validation set.

A validation subroutine may be implemented in any package although the subroutine should satisfy the contract of a validation subroutine as was stated previously. The following demonstrates an example of how a validation subroutine might be implemented in accordance with one embodiment here to display a warning message if the supplier is on hold. Logic common to a set of validation subroutines could be extracted out and placed in a common procedure call but this is not include here for sake of simplicity. Further hard coded strings found in the following code would be replaced with constants in actual code but again are omitted for purposes of clarity and ease of understanding 

The validation subroutine should be called from the validation architecture such as from within PO VALIDATIONS.validate set. An exemplary implementation of such as process could proceed as follows.

The validation subroutine also can be added to a validation set such as is set forth by the following 

A validation interface e.g. a validation API also can be provided for the validation set. If a new module is created and needs to utilize validation architecture a wrapper can be created inside PO VALIDATIONS for this new module to call. The wrapper can determine which validation set to use since the wrapper is module specific. The wrapper also can invoke a validate set procedure such as by the following 

In an embodiment where the validation architecture is implemented at the back end such as in PL SQL in database tier an advantage is obtained in that the validation architecture also can be invoked from the middle tier which can be written in Java or another appropriate language. Such an architecture can replace the traditional way of validating an entity record and can be particularly useful when an application wants to have control over when the validation should be performed.

In most embodiments the system includes some type of network . The network may can be any type of network familiar to those skilled in the art that can support data communications using any of a variety of commercially available protocols including without limitation TCP IP SNA IPX AppleTalk and the like. Merely by way of example the network can be a local area network LAN such as an Ethernet network a Token Ring network and or the like a wide area network a virtual network including without limitation a virtual private network VPN the Internet an intranet an extranet a public switched telephone network PSTN an infra red network a wireless network e.g. a network operating under any of the IEEE 802.11 suite of protocols GRPS GSM UMTS EDGE 2G 2.5G 3G 4G Wimax WiFi CDMA 2000 WCDMA the Bluetooth protocol known in the art and or any other wireless protocol and or any combination of these and or other networks.

The system may also include one or more server computers which can be general purpose computers specialized server computers including merely by way of example PC servers UNIX servers mid range servers mainframe computers rack mounted servers etc. server farms server clusters or any other appropriate arrangement and or combination. One or more of the servers e.g. may be dedicated to running applications such as a business application a Web server application server etc. Such servers may be used to process requests from user computers . The applications can also include any number of applications for controlling access to resources of the servers .

The Web server can be running an operating system including any of those discussed above as well as any commercially available server operating systems. The Web server can also run any of a variety of server applications and or mid tier applications including HTTP servers FTP servers CGI servers database servers Java servers business applications and the like. The server s also may be one or more computers which can be capable of executing programs or scripts in response to the user computers . As one example a server may execute one or more Web applications. The Web application may be implemented as one or more scripts or programs written in any programming language such as Java C C or C and or any scripting language such as Perl Python or TCL as well as combinations of any programming scripting languages. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase IBM and the like which can process requests from database clients running on a user computer .

The system may also include one or more databases . The database s may reside in a variety of locations. By way of example a database may reside on a storage medium local to and or resident in one or more of the computers . Alternatively it may be remote from any or all of the computers and or in communication e.g. via the network with one or more of these. In a particular set of embodiments the database may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers may be stored locally on the respective computer and or remotely as appropriate. In one set of embodiments the database may be a relational database such as Oracle 10g that is adapted to store update and retrieve data in response to SQL formatted commands.

The computer system may additionally include a computer readable storage media reader a communications system e.g. a modem a network card wireless or wired an infra red communication device etc. and working memory which may include RAM and ROM devices as described above. In some embodiments the computer system may also include a processing acceleration unit which can include a digital signal processor DSP a special purpose processor and or the like.

The computer readable storage media reader can further be connected to a computer readable storage medium together and optionally in combination with storage device s comprehensively representing remote local fixed and or removable storage devices plus storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The communications system may permit data to be exchanged with the network and or any other computer described above with respect to the system .

The computer system may also comprise software elements shown as being currently located within a working memory including an operating system and or other code such as an application program which may be a client application Web browser mid tier application RDBMS etc. . It should be appreciated that alternate embodiments of a computer system may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices data signals data transmissions or any other medium which can be used to store or transmit the desired information and which can be accessed by the computer. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

