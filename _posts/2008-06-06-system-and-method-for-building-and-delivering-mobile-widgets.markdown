---

title: System and method for building and delivering mobile widgets
abstract: Systems and methods are provided for creating, publishing, sharing, and delivering mobile software applications called “mobile widgets” onto mobile devices. A system may include functionality to render a declaratory component of a widget, such as HTML, and also functionality to execute an imperative component of a widget, which may or may not be compiled and/or in a scripting or functional language. Mechanisms for providing common access to disparate device capabilities APIs are also provided, as are mechanisms for installing widgets onto mobile devices and managing those widgets.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08595186&OS=08595186&RS=08595186
owner: Plusmo LLC
number: 08595186
owner_city: Glendale
owner_country: US
publication_date: 20080606
---
This application claims the benefit of U.S. Provisional Patent Application No. 60 942 406 filed Jun. 6 2007 the entire content of which is incorporated herein by reference.

The present disclosure relates to applications and user interfaces for mobile computing devices and particularly to methods and systems for creating publishing sharing and delivering mobile software applications.

Cell phone data usage is on the rise. Phones may support the wireless application protocol WAP an international standard for applications that use wireless communication from mobile phones. Mobile data applications include SMS and the WAP browser an Internet browser for accessing mobile web sites. Interactive and specialized kinds of applications are also in use.

Mobile usage patterns are different from desktop usage. Users may be on the move in a movie line on public transportation or in a coffee shop and may have very short attention spans and may be in situations where it is very hard to type. Such a user may launch the browser and waits for the results. By the time the results are delivered to the mobile device the user may have moved on to another task.

Further mobile devices may have diverse non standard feature sets and user interfaces. Phone manufacturer has a different way of presenting the user interface on the mobile device. Menus may be unique to a particular device and users may have to learn where the application modules are and how to perform device setup. At any given time there may be multiple mobile models supported by multiple mobile operators with diverse physical layouts including QWERTY keyboards keypads thumb wheels joy sticks styluses roller balls etc.

A system is provided for executing a widget application installed on a mobile device including a declaratory markup language renderer for rendering a declaratory markup language component of a widget application on a display of the mobile device a compiled programming language execution engine for executing a compiled programming language component of a widget application installed on the mobile device a mobile device API adapted to be accessible to a widget application and providing access to a device service API of the mobile device and a widget manager configured to automatically download widget applications or descriptions of widget applications from a network location to the mobile device without receiving user instructions for said widget applications.

Software is provided which includes a plurality of different widget executing engines for executing software widget applications installed on a plurality of different types of mobile devices where each of the mobile device types is adapted to run software applications written in a programming language that is distinct from programming languages supported by the other mobile device types and all of the widget executing engines provide a common application programming interface for the widget applications to access a common device capability of the mobile devices.

A method for executing a widget software application is provided. The method includes rendering a declaratory markup language component of the widget application executing a compiled programming language component of the widget application and automatically downloading widget applications or descriptions of widget applications from a network location to the mobile device without receiving user instructions for said widget applications. Executing the compiled programming language component includes making available to the widget application an API to access a device service of the mobile device.

A software widget application is provided and configured for installation and execution on a mobile device. The application includes code written in a declaratory markup language and code written in a programming language where the code written in a scripting language contains a call to an API accessing a device service of the mobile device.

An application is provided including a software widget configured when compiled to be installed and run on a plurality of different mobile devices each device having an operating system that runs software applications written in a programming language that is different than programming languages supported by the operating systems of the other devices wherein the devices have a common device service the devices having different device services APIs for accessing the device service the widget being configured to access the device service only through a single API distinct from each of the device services APIs.

A method for creating a mobile software widget application is provided. The method includes accessing a first section of code written in a declaratory markup language accessing a second section of code written in a programming language compiling the second section of code to produce a compiled section packaging the first section of code and the compiled section to produce a mobile widget application configured to be installed onto a mobile computing device so that a user of the device can repeatedly select run and terminate the widget application.

A widget application distribution system is provided. The system includes a server adapted to transmit a software widget application to a plurality of mobile devices of different types for installation thereupon wherein each mobile device type includes a distinct API to a mobile device service that is common to all of the mobile device types a software widget application stored on the server the widget application comprising a first component including programming language code and a second component including declaratory markup language. The widget application is configured to utilize the mobile device service without directly accessing any of the distinct APIs.

A widget application distribution system is provided where the system includes a server having gallery of widget software applications the server configured to allow users of mobile computing devices to browse the gallery of widget applications from the mobile devices each of the widget applications configured to be installed onto one of the mobile devices the server configured to receive requests for downloading selected ones of the widget applications from the mobile devices the server configured to respond to a request to download a widget application by electronically sending the widget application to be downloaded and installed to the mobile device that sent the request to the server.

A method for synchronizing information with a mobile device is provided including maintaining a first version of the information on an electronic storage the information comprising one or more of 1 widget software applications configured to be installed onto the mobile device and repeatedly selected run and terminated 2 network content used by widget applications and 3 logged data related to activities of widget applications receiving a synchronization request from a mobile device having a second version of the information the synchronization request including a mobile timestamp and mobile identifier related to the information the mobile timestamp indicating a time at which the second version of the information was last updated and comparing the mobile timestamp to a local timestamp and local identifier stored in the storage the local timestamp indicating a time at which the first version of the information on the storage was last updated and determining based on the timestamps and identifiers whether the information has been changed on the mobile device the storage or both since a previous synchronization request.

A system for synchronizing information between a server and a mobile device is provided. The system includes a server comprising a server data store and a conflict resolver the server data store being configured to store a version of the information the information comprising one or more of 1 widget software applications configured to be installed onto the mobile device and repeatedly selected run and terminated 2 network content used by widget applications and 3 logged data related to activities of widget applications and a mobile device comprising a synchronization engine and a mobile data store the mobile data store being configured to store a version of the information the mobile device configured to transmit synchronization requests to the server each synchronization request comprising a mobile timestamp related to the version of the information on the mobile data store. The server is configured to respond to the synchronization request by comparing the mobile timestamp to a local timestamp stored in the server data store the local timestamp indicating a time at which the version of the information on the server data store was last updated the server further configured to determine based on the timestamps whether the information has been changed on the mobile data store the server data store or both since a previous synchronization request by the mobile device.

A mobile device including a memory a display and engine that executes a compiled software widget application installed on the mobile device is provided. The widget application requests network content without receiving a specific request for said content from a user of the mobile device. The device is configured to download the network content at the request of the widget application without immediately displaying the downloaded content on the display the device being configured to store the downloaded network content in the memory so that it is available for later use by the widget application in the absence of a network connection.

A mobile device including a widget execution engine and a software widget application installed on the device and configured to be executed by the widget execution engine is provided. The widget application is configured to receive a user instruction to request a first content datum from a network location the widget application is also configured to respond to the user instruction by initiating the downloading of the first content datum from the network location to the device and the widget application is further configured to initiate the downloading of a second content datum from the network location to the device without receiving a user instruction to download the second content datum.

A mobile device is provided. The mobile device includes a location identification module configured to determine a location of the device and a software widget application installed on the device the widget application configured to obtain a location of the device from the location identification module the widget application configured to request network content customized to the location of the device.

A method for providing localized content on a mobile device is provided. The method includes causing a widget software application to access a location identification service to determine a present location of the mobile device the widget software application being installed on the mobile device and being configured to be repeatedly selected run and terminated by a user of the mobile device causing the widget application to select content to be transmitted to the mobile device based in part upon the present location of the mobile device and causing the content to be transmitted to the mobile device.

A computer implemented method of receiving a widget application for a mobile device is provided. The method includes running a widget execution engine on a mobile device causing the widget execution engine to conduct diagnostic tests on the device where the diagnostic tests are adapted to test for capabilities of the device sending results of the diagnostic tests to a server and receiving a software widget application from the server where the widget application being selected based on the results of the diagnostic tests.

A computer implemented method of selecting widget applications for installation and execution on a mobile device is provided. The method includes receiving results of diagnostic tests run on a mobile device by a widget execution engine running on the device selecting one or more software widget applications based on the results and sending the selected one or more widget applications to the device for installation.

A widget execution engine for running widget software applications on a mobile device is provided. The engine includes a diagnostic testing module configured to run diagnostic tests on the device the diagnostic tests adapted to test for capabilities of the device the engine configured to send results of the diagnostic tests to a server the engine configured to install software widget applications received from the server.

A mobile device included a virtual machine that executes compiled widgets wherein a code segment footprint of the virtual machine is less than 10 000 bytes is provided.

A widget execution engine adapted to run on a mobile device and configured to execute compiled widgets included a virtual machine with a code segment footprint of less than 10 000 bytes the virtual machine being represented in computer storage is provided.

In figures showing multiple components nothing herein is meant to imply that all of such components are required and certain embodiments may include only a subset of the components or modules depicted in any one or more figures. Likewise with respect to figures showing method elements nothing herein is meant to imply that all the elements illustrated in any one or more of such figures are required and certain embodiments may include only a subset of the elements shown in any one or more figures.

In one embodiment methods and systems are provided for creating publishing sharing and delivering mobile software applications called mobile widgets while maintaining device independence across hundreds of disparate mobile devices. The term widget may be interchangeably used with other similar terms such as module application or program. 

Many mobile devices such as cellular phones and PDAs have a browser to browse the Internet. But the end user experience may be poor resulting in single digit mobile adoption rates even for essential web services like email and weather. Tasks that may be simple on a desktop computer can turn out to be complex chores when performed on a mobile phone. For example on a desktop machine getting the weather forecast for the day may require only for the user to type new york weather on a search engine and see the results. On a mobile phone however users may need to first find the web browser which may be hidden in a menu then users may laboriously type the URL on a little keypad wait for the browser to connect possibly deal with mal formatted content pages and then try to use the web site. Normal users may not have the patience or attention span to perform so many steps just to get the weather or the current sports score.

Mobile widgets can offer an enhanced user experience for similar web services. The architecture may include server side technology device agnostic client side technology and publishing technology for widget creation. Some embodiments of the architecture may allow relevant information to be made available on the mobile terminal for when users glance at the phone.

The system and techniques presented here may include server side architecture for authoring hosting and delivering the widgets and mobile content a mobile client side platform to run the widgets and render content a framework for developing and publishing the widgets and a system for measuring mobile widget usage.

A mobile terminal may refer to a mobile computing device including but not limited to wirelessly connectible PDAs mobile phones handheld pads 2 way pagers voice recognition terminals and portable computers with wireless connection capability. Other similar names used for a mobile terminal include handheld device client device cellular phone mobile phone or more commonly phone.

A mobile widget may refer to a mobile software application that runs on a mobile device and may perform a specific task. As an example consider a weather forecast mobile widget that displays the forecast graphically for a specific city or a cartoon reader that formats a cartoon strip so that it is easily readable on a mobile phone. Of course widgets may have more or less functionality and may be adapted to perform multiple tasks.

The widget service client software may refer to a software application that runs on a terminal device and is capable of hosting and running mobile widgets. Other names used for this module are client software or more commonly client. The widget service server system may be an embodiment of the basic server side architecture configured to author host and deliver the mobile widget service.

As shown in the environment may include the widget service server system a first network e.g. the internet a second network e.g. a wireless network the widget service client and various content sources such as content publishers web services web portals and other web sites .

The client device may include mobile computing devices capable of sending and receiving data over a network . Such devices may include mobile terminals that connect via a cellular network Wi Fi network and the like such as connected PDAs cellular phones smart phones Blackberry devices Windows PocketPC and Smartphone devices and wireless gaming devices such as PSP Nintendo DS or any other device that is equipped to communicate over a wireless communication medium. Mobile devices may include storage memory displays operating systems additional software such as email calendar PIM and phone specific features.

Relative to non mobile devices the mobile client device may have slower transmission rates may exhibit a network latency may have a smaller screen may have different or limited user entry mechanisms such as soft keys key pads or thumb wheels and may not have a full keyboard. Client devices may be further configured with a built in browser application that supports receiving and display of markup languages such as Wireless Markup Language WML WMLScript JavaScript and Hypertext Markup Language HTML to display text graphics or multimedia. Further client devices may run mobile operating systems such as Symbian OS Mobile Linux Windows Mobile RIM Blackberry and Palm OS. The operating systems may provide a virtual machine such as a Java Virtual machine JVM or BREW. Client devices may further be configured to support download and installation of new applications and functionality. Mobile client devices may have several additional components such as GPS camera multiple networks and the like.

The widget service server system may contain one or more server systems and may be configured to communicate with client devices and to respond accordingly. The server system may communicate with a wide area network such as the Internet a cellular telephone network or a local area network. As an example the widget service client software running on the client device may communicate with the widget service server system to receive information about the widgets. The widget service server system may also be capable of communicating with various content sources and services on the Internet such as search engines web services XML repositories relational databases structured markup content sites content aggregators portals and the like. The widget service server system may also host online tools to develop and deploy widgets. It may also provide application interfaces to develop and deploy mobile widgets.

With reference to in some embodiments the client device may include a widget service client . The widget service client may be a software program that runs on the mobile computing device and communicates with the widget service server system over wireless networks and wire line networks using standard networking protocols such as Wireless Application Protocol WAP Transmission Control Protocol Internet Protocol TCP IP and the like. The widget service client may be able to run widgets on the client device . Users may have a personalized set of widgets that they choose to install and use on the widget client .

In another embodiment of the operating environment the mobile computing device may not support or allow the download or installation of a software such as the widget service client . In such a case if the mobile computing device is equipped with a built in browser the widget service server system may be able to offer widgets via e.g. a built in browser on the mobile device .

The widget service server system may provide tools programming interfaces or hosting infrastructure wizards for the creation or publishing of mobile widgets. As an example the wizards enable non programmatic ways of creating device independent mobile widgets for content publishers. Furthermore programming interfaces may allow developers and those skilled in the art to build new kinds of mobile widgets in a device independent way.

Another embodiment of the widget service system is illustrated in . In this embodiment an individual user or publisher may download a personal version of the widget service server and install it on a local computer server . The personal widget service server and accompanying tools may interface with services on the local computer server where the user may create personal widgets from local data sources and share it with friends and family. The data for these local widgets may come from personal local applications such as email calendar photos personal media etc. and may be accessed via a personal web server or operating system . Here the data may reside on the user system instead of public widget service servers . Users who use the personal widget service server may also be able to syndicate other widgets from the public widget service . A web server or web operating system can be provided to enable the server . It will be understood that mobile devices can receive widgets from the server via networks .

As recited earlier a mobile widget may include a mobile software application which may run on a mobile computing device and may offer a user experience to perform a task. shows an exemplary mobile widget launchpad with several widgets installed. The widgets are represented by the grid of icons in the center of the figure. As depicted each widget may have a completely different user interface and behavior. As examples in this diagram we illustrate a mobile widget that displays the news in pictures another one that displays a chat session another one that represents a local search query another one for viewing comic strips in a slider a livecast widget that displays play by play updates with video for a live cricket game and a weather widget . Many other types of widgets may be created and delivered in this embodiment. A mobile widget could be an encapsulated version of a web site a portion of a web site a mobile web WAP site an HTML page an RSS feed an ATOM feed a webcam feed a video or audio feed or any other data source. The widget may offer a mobile friendly version of the functionality offered by these original data sources.

In one embodiment a widget may display a golf leaderboard in a mobile computing device. The widget may offer the information so that it is well formatted and easily viewable on a specific mobile device. Furthermore the leaderboard may be automatically updated every few minutes without the user having to hit a refresh control. The information may be pre fetched so that the user does not have to experience the network latency typical of mobile data networks. The widget may automatically display a particular golf shot via video. The widget may overlay a golf ball s path over a picture of a golf hole. These features when used in conjunction with each other improve the end users experience significantly because very specific information is available at a glance.

In another embodiment a widget may show traffic information for a user s afternoon commute. The mobile widget could be configured to update every 30 minutes with the latest traffic information from a specific web data source personalized to the user s home location and update a status image to a red light or green light based on whether there is a traffic incident or not. The user would be able to receive the information at a glance without having to go through tedious steps to get the traffic information from a mobile web browser. In this embodiment the information may be periodically pushed to the widget rather than pulled by a user using the web browser.

In another embodiment a widget may be a mobile display of personal media. For example a user could carry her favorite family photographs in a mobile slideshow widget. Widgets like these may include simple to do lists music playlists with links to the media video playlists person to person greetings and the like. In many cases may be possible to construct the widget s user interface in a unique or simple way so that it is easy to use by the end user.

In another embodiment a widget may use special functions or device services of the mobile computing device such as a voice recorder a camera or a video recorder. As an example a mobile widget may allow a user to record a voice note and upload it to another user or web site. In another embodiment a widget may be related to communication. Widgets may offer access to Instant Messaging Voice Over IP VOIP call bridging and chat rooms.

The foregoing embodiments provide several examples of mobile widgets supported by this disclosure. However other types and configurations of mobile widgets apparent to those skilled in the art may also be created published and used in the system of the embodiments described above.

There are many ways in which users may discover mobile widgets such as through affiliate sites like web logs blogs online content brands or aggregators where mobile widgets are featured. In some instances users may receive an invitation from a friend or users may hear of the widget service and access the widget service s website or mobile sites. In any of these potential use cases users may be allowed to preview and pick various widgets and then register to receive mobile widgets on their mobile phones. After registration users mobile phones may be provisioned with the widget service client software via a text message or email. Users may then manage their own widget sets from the widget service mobile client software or from the widget service web front end. Users may program the widgets as to how often data should be downloaded how much data should be downloaded and the like. Users may use search capabilities on the device to add more widgets or invite other friends to use widgets.

Widgets may include multiple components some of which may be executed or rendered on the mobile device. When executed or rendered widgets may access a common device API provided by the client and may access a feature of the mobile device without necessarily accessing any of the distinct APIs native to the mobile devices.

Once a widget is created it may be uploaded to the server for storage and indexing. The server may store the widget in a database. In one embodiment the widget s manifest may also be read to obtain the widget name description tags assigned to the widget creation time author version and other attributes. These attributes may be indexed by the search engine so that the widget can be searched by end users to be added to their accounts.

In an embodiment users may either browse a catalog gallery of widgets or they may search for a particular widget. Once found the user may add the widget to their account using the user interface. When a widget is added to a user account an entry may be created in the database that references a widget and applies to the user account. A user account may be specified when a user logs in to the system via the web user interface or via the mobile client unique identifier. By having this entry in the database the user has effectively added the widget to their account.

Referring to and the user may synchronize their mobile client with their online account. The client synchronization engines and or server synchronization engine may detect that a new widget has been added. The widget may be transmitted to the client.

The mobile client may install the widget by unpacking the widget archive. Installation may be handled by an installation component of the client where the installation component is designed to install widgets onto the mobile device . Installation may be permanent persistent temporary or of some other definite or indefinite duration. Installation may include unpacking the widget components installing each some or a section of some of the components onto the device. Such installed components may include code compiled code images text video multimedia and so forth. Widget installation may also include decompression of the widget or other processing before installation. The widget may then be registered into the user s views. The user can then interact with the widget. The widget may contain code that retrieves additional data if required. For example an RSS feed widget may have a server counterpart that fetches feeds and reformats the feeds to the capabilities of the mobile client. This may include resizing images transcoding the content to simplified HTML transcoding media types such as video etc. The widget may then utilize the synchronization engine on the client and the server to transmit data between the systems.

So for example the operating system may provide a proprietary API to allow authorized applications running on the device to access one of the specialized features of the device. The API may include calls to open the camera shutter close the shutter and save the image to a storage location. Various mobile devices provide different features functionality and services so the operating systems which run on the devices will provide various device services APIs . Additionally various operating systems may provide a different device services APIs for the same feature. Thus a program written for one device and operating system may not be able to run on another device or operating system.

The client widget engine may run on top of the operating system . Alternatively the widget engine may be a component or constituent of the operating system . The engine may provide functionality for widgets to be executed on the mobile device . The widget engine may typically provide a renderer an execution engine and a common device services API .

In turn a widget to be executed on the widget engine may contain among others a declaratory language component e.g. a declaratory markup language such as HTML and an imperative language component e.g. a scripting programming language such as JavaScript . The declaratory language component may be rendered or otherwise executed by the renderer or the widget engine . The imperative language component may be executed by the execution engine . The imperative language component may also contain code calls to device services and features. These calls may be to the common device services API provided by the widget engine .

The following sections detail components and functionality of some embodiments of the widget engine .

The rendering engine may generally parse and execute a declaratory language. Declaratory languages include markup languages such as XML HTML XHTML and SGML. The language need not be declaratory and may be functional or imperative. These languages may form components of a widget application.

The rendering engine also known as a microbrowser may include a mobile browser canvas . depicts a schematic diagram of one embodiment of an execution engine and mobile browser canvas . illustrates among other elements a repository of pre built widgets and a font rendering engine . According to one embodiment the mobile browser canvas provides a canvas for application developers to render user interfaces for applications. This canvas may be a modified XHTML and SVG rendering engine. The canvas may allow application developers to display rich user interfaces. User interfaces may include formatted text and bitmap graphics as well as vector graphics. Embodiments may implement caching of for example rendered elements a second canvas for for example pre rendering a second frame for display while keeping a first canvas active on the display and active client server pages .

The following are widgets that application developers may use to display user interfaces. These widgets may be stored in a pre built widgets repository . These widgets may be accessible to widgets executing on the widget engine .

These types of widgets may display information. In some embodiments users do not interact with these widgets.

Interaction elements may allow users to interact with the mobile widgets. Interaction may be accomplished by selecting the widget by directional cursor movements mouse pointer movements stylus clicks voice commands etc. For the mobile client implementation the system may use well defined input mechanisms available on mobile devices such as directional cursor movements and stylus pen inputs.

A four way directional cursor pad may be used to move a selection cursor up down left or right as per cursor pad to select the elements on a document. In one embodiment if there are no selectable elements on a page the document may scroll up or down depending on the direction the user has selected until a selectable widget is visible. The system may then select the widget and change its visual indicator to indicate that the user has selected the widget and that this widget can perform some further action based on further user input.

For the user interaction elements there may be a hidden form widget comprising form specific elements. In one embodiment all form specific elements may have a name assigned to them as well as a value. When the form widget is submitted the data contained in the form may be collected encoded and sent to a specified URL for further processing. These name and value pairs may then be considered the data.

Appendix F lists sample user interaction elements according to an embodiment. illustrates example interaction elements according to one embodiment including for example hyperlinks text fields and controls checkboxes radio controls list boxes drop downs and file upload controls .

The elements described above that accept user input can also have optional attributes to provide additional context to the system to apply additional actions that the user can perform. These optional attributes may be specified in the same manner as other attributes on the elements.

According to one embodiment one such usage of the meta descriptor is the use of automatic form filling with last entry history. A naming convention is used for describe some of the entry fields. For example email is used to describe a user s email address or phone mobile can be used to describe a user s mobile phone number. When the page renderer encounters such entry fields it may optionally changes the visual indicator of the element so that the end user knows the automatic form filling can apply to the fields. The form may then be filled manually by the user in which case the entries are saved into a storage mechanism which exists locally and or remotely on the server . Alternatively the renderer may display special user interface features when users select the input element. For example in a text entry field where a meta descriptor is specified the background color might change to yellow indicating that this field can be auto filled. The user selects this field at some point. A popup can then appear presenting the user with items that the user can choose using any input mechanism. After filling the result is saved into a history stack so that whenever the renderer encounters the element again it can present to the user the entered items again.

In addition to the history stack the meta descriptor values can come from external sources. According to one embodiment the user may register on the web site. They enter their personal information such as name address phone number etc. This information is transmitted to the client at some point using the synchronization module. The mobile client can then use this data to fill form elements conforming to the naming conventions and implementing the meta descriptor attributes.

The mobile client may contain a parser for languages. Two such parser are described below but the client may generally parse any programming or rendering language including XML XHTML SVG other declaratory markup languages in general as well other languages such as the imperative languages C and Java and the functional language Scheme.

With reference to the following is one example of an XML based parser to render HTML. XML is a text based document that conforms to certain rules to make machine parsing easier. The parser in this example may be a non strict version to handle some instances where user entered XML code might not be compliant as might be the case with HTML documents . There are several ways to handle non XML compliant documents. One is to have a relaxed parser. Another is to tidy up the document to be XML compliant before parsing. Both methods are compatible with the present disclosure but only the first method will be described below.

According to one embodiment the first element may be lexical analysis whereupon the document is broken up to get the characters. The XML parser may choose not to validate the XML for correctness. For example when the parser encounters a tag that does not close it may be closed automatically rather than generate an error. To do this the engine may provide two stages A generic XML parsing stage and a semantic information processing stage.

In the generic XML parsing element the parser parses the input to determine what the next item is. The item may be a tag end tag that closes the opening tag text exists between the start and end tag or end of file so that it is known when to stop calling the function. The function may return a constant to specify what the next retrieved type is e.g. TAG END TAG TEXT or EOF so that other functions may be called as appropriate. Appendix E contains pseudocode for some embodiments of the first element of parsing.

The second stage of the parser may grab the XML elements and match against HTML tags. It may keep a stack of tags that are to be closed in a stack. So for a start tag it waits for an end tag matching that name to arrive. When we encounter a start tag we place it on the stack. When we encounter an end tag we ll match against the start tag at the top of the stack. If it s the same we ll pop that one off. If it s not the same we ll keep popping the tags off the stack until we find the matching start tag or until the stack is empty. Similarly we can handle the following case. A start tag is placed on the stack. Then another start tag begins that is the same as the start tag on the top of the stack. This should not occur in HTML. So we pop off the tag on the stack and close both tags.

The user interface of a widget may be specified using a declarative syntax such as XHTML. It may be provided as a declaratory markup language component of the widget. According to one embodiment widgets may be based upon XHTML and SVG standards derived from XML documents see these docs as ref . In this embodiment the first element is to prepare the user interface for display is to parse the user interface. As mobile devices can be resource constrained it sometimes may not be possible to parse the user interface on the device due to resource limitations. Hence some embodiments support several methods to parse and render the user interfaces.

To support more scalable clients an API may be made available for capabilities discovery. Examples include ability to do bitmap image scaling supported multimedia objects supported input events multiple screens etc.

In some embodiments within the renderer or mobile browser canvas application developers may specify a block of the canvas to display vector based graphics. A component of the mobile client or the renderer may include a vector graphics display unit or engine . According to one embodiment this is demarcated by the tag. Attributes it can take are width and height of the vector graphics area.

The objects can take on various attributes to affect rendering. Some attributes include color fill color font family font size font style.

Transformations may be applied to the objects. These may include translation rotation and scaling and skewing. In some embodiments only the first three or some other subset of the transformations may be implemented. The transformations may use matrix notion of linear algebra as follows 

The renderer and or mobile browser canvas may render the object primitives on a raster graphics display unit . A mobile device may expose APIs to allocate and use a block of memory to represent the graphics display. This block of memory can represent screen pixels by the following equation mem offset screen width Lines and curves that are represented by geometric equations may be optimized for rendering on a pixel by pixel case according to the following equations.

Lines may be rendered on a raster graphics display canvas using J. E. Bresenham s line drawing algorithm Algorithm for Computer Control of a Digital Plotter . It describes an method of line drawing by using an error value that is accumulated as lines are traversed.

Circles and ellipses can be rendered on a raster canvas using a variant of Bresenham s line drawing algorithm as described by J. R. Van Aken An Efficient Ellipse Drawing Algorithm .

The quadratic Bezier curve is described by the following parametric equation. Given points P0 P1 and P2 1 20 2 1 1 22 0 1 The cubic Bezier curve is described by the following parametric equation. Given points P0 P1 P2 and P3 0 1 3 31 1 2 322 1 33 0 1 

An approximation to a raster canvas may be made by breaking up the curve into several line segments e.g. 16 segments . These line segments can be rendered individually using the Bresenham algorithm for line raster rendering. Computation for the points on the segments can also be made by breaking down the equations. For example one can solve for 1 t in the equations above. One can also assume that at the beginning of the curve t 0 and at the end of the curve t 1.

Widgets may contain sections or components of general programming language code. Such code may increase the expressive power available to widget designers relative to widgets containing declarative e.g. HTML code alone. The execution engine may execute code that has been compiled. In some embodiments the widget execution engine may be unable to compile code. Alternatively the execution engine may contain a compiler or interpreter or make use of a compiler or interpreter on the mobile device . The execution engine may execute and therefore widgets may contain scripting programming language code such as JavaScript and the script may be compiled such as bytecode or object code. The execution engine may include a facility for executing code written in another programming language and APIs that the code may access to interface to device services .

A virtual machine may execute the bytecode and interact with the user through APIs . Bytecode may be in the form of an octet stream 8 bits 1 byte . The virtual machine may have an instruction pointer that points to a list of instructions bytecodes . After each instruction that gets executed the instruction pointer may be incremented except for branch instructions . Appendix D illustrates sample 1 byte opcodes of the instructions that may be implemented.

A generic virtual machine may support many languages. However adopting a simple version of JavaScript may lower the learning curve to create applications. A compact reduced version of JavaScript may accommodate low resource mobile devices. Operations may include 

The virtual machine may be a stack based architecture or machine. With continued reference to values that are required by the instructions may be pushed and popped from the stack as required. In addition a heap space may be provided where variables of a particular scope get stored. Whenever a new scope is created a space for heap may be created and pushed onto the stack. Whenever program control leaves a scope the space for the heap may be popped from the heap stack and destroyed. In addition to the local scope a global scope may be provided. If references to variables do not exist on the local scope the global scope may be referenced.

The object stack may be a temporary storage area that the virtual machine may use to perform computations. The stack may be a last in first out stack where the last item pushed into the stack may be the first item popped out of the stack . Various computations may be performed using postfix operations on the stack . The stack may be located on a data storage module .

The object heap may be used by the virtual machine to save the values of variables. In the example above section on stack the variables x y and z may be used. These variables are stored in the object heap .

The object heap may be garbage collected as described in the garbage collection section below. Garbage collection may clean up and free up space in the heap so that more objects can be put into the heap without the developer having to concern themselves about managing the heap . Cleanup may be needed when objects in the heap are no longer referenced by widgets. The heap may be located on a data storage module .

A garbage collector may be provided for freeing unused memory. For simplicity a simple mark and sweep algorithm can be used. It can be invoked at strategic moments e.g. after 1000 instructions after 60 seconds after idle etc. . An alternative is the store and copy approach. This approach avoids fragmentation at the cost of using double the memory required. Yet another alternative is the mark and compact approach which combines features of both. Pseudocode descriptions of some embodiments of the algorithms are provided in Appendix B. The garbage collector may be optimized for the particular languages to be executed by the execution engine. For example an engine which executed compiled JavaScript may implement a version of the mark and sweep or mark and compact algorithms described above.

In some embodiments code executing on the virtual machine may interact with the system resources and with the user. Application Programming Interfaces APIs are interfaces exposed to the virtual machine to display user interface and get user input. These APIs include but are not limited to 

The operating system typically exposes APIs to device features such as a camera. These APIs may be called device services APIs . Different operating systems on different devices may provide different APIs to the same feature. So for example while many phones from different manufacturers may have cameras the operating systems on these phones may expose different APIS TakePicture versus OpenShutter for example. The API may be included in the execution engine or may be separate from it.

Depending on the underlying function they provide access to these APIs may or may not be exposed by the operating system to a given application.

The client widget engine may provide a common device services API that may be accessed by executable code that includes calls to devices features. The common device services API allows widgets to be made more independent from the underlying device type and operating system . Widgets may make a call to a function included in the common device services API with little regard to the underlying proprietary device services API . As such multiple engines may be installed on multiple different types of mobile devices such as by different manufacturers where each of the devices utilizes different APIs programming languages operating systems OS versions and other features from other devices. Despite running on different hardware platforms all of the engines may provide a common API for widgets to access common device services of the mobile devices.

With reference to and in one embodiment widgets may be stored in a widget repository on the mobile engine . According to this embodiment when a widget is installed it may be unpacked. The resources contained within it may be stored in the repository along with some meta information about the widget . One of attributes in the meta data may be a widget s version. If widget authors deploy newer versions of a widget the widget may be upgraded. This may work similarly to the client auto update as described below. The widget version may be compared against the version on the server. If there is a newer version this data may be transmitted to the client. The user may either be prompted with a mandatory widget update or an optional update depending on what the widget author has specified . If applicable the new version of the widget may be downloaded. If the download fails the download may resume the next time the application initiates a widget synchronization. After a successful download the old widget may be removed and the new widget may be unpacked and registered with the mobile client.

With reference to and the synchronization engine on the mobile client may be used to ensure that the data is the same between the server and the client. The synchronization engine may work in conjunction with a server side synchronization engine described below.

Page requests take a finite time to load and render. Each element within a page may make separate requests to various servers to load resources e.g. images . As such a user may wait for data to come over the network and the widget may be rendered before the user can begin to view and interact with some content. Alternatively the widget may not be rendered until all or a portion of the data is received. Some embodiments allow downloading or prefetching of data in the background thus allowing the user to interact with other non blocking widgets or with the data requesting widget as described below. Mobile prefetch may be initiated by a widget controlled by a widget or operated autonomously by the widget client engine .

Mobile prefetching works by downloading at least some of the content needed before the user begins to interact with the widget. Once the content is downloaded users can interact with the widget without having to make network connections again. According to one embodiment the process begins when the widget is requested. The widget may begin downloading in the background. The user can then choose to perform other application tasks or wait for the download to complete. Once the download is complete the widget may contain the resources necessary for the widget to function without having to access the network.

Mobile prefetch can also be configured to download content in the background and have the result appear at a later time. For example a large video clip may take for example 5 minutes to download. The user may prefer to perform other activities while the download occurs. According to one embodiment the widget may call the mobile download or prefetch module to fetch the specified resource in the background and to put the resource into a mailbox that users can later visit to pick up the content. The download proceeds and eventually the download completes. In some embodiments an unobtrusive notification appears either audio or visual to indicate that the download has completed. The user can then open the mailbox to retrieve the content and play it.

Another application of the mobile prefetch is to enable use of the mobile client by mobile devices with extremely limited storage. Although the mobile client can prefetch the data for all of the widgets before usage storage limited mobile clients may choose a delayed on demand fetch instead of prefetch. The user may select the content they wish to prefetch and content that they wish to only fetch on demand. One example is the display of articles on a web site. The user may choose to prefetch the article titles first and then retrieve the article content only when they wish to view the article. Note that this is slightly different from the above where content is downloaded into a mailbox . In this case the download may occur on demand so that the user can view the result as soon as the download is complete.

In some embodiments widgets may query an API provided by the engine in these two modes to render themselves differently. For example in a grid view mode where the widgets may be minimized a widget might render itself as grayed out when there is no data. Then it may change to a flashing indicator to indicate when there is new data or can change to a static image once the user has viewed the data for that widget.

Mobile client engines that are downloaded for installation on a mobile device may have versions associated with them. When a newer version of a mobile client is available the older mobile client may need to be updated. There may be two types of version updates. The first is a mandatory update in which the old mobile client must be updated in order to further use the services of the server. The second is an optional upgrade where an older mobile client is not required to be updated in order to function. For example new features might have been introduced but the same basic functionality is preserved and hence does not require an update.

Mobile clients may be notified of new updates. According to one embodiment when a new update is available the update is marked on the server. The server may then maintain a list of versions that it keeps track of and may keep the current version that has been deployed. When a new version becomes available that is not the current version mobile clients may be notified. This may occur when the mobile client connects to the server as follows As part of a handshake the mobile clients send their current version. The server responds with whether there is a new version or not and whether or not it is a mandatory update. The mobile client then acts appropriately. If a new update is to be downloaded user accepts the upgrade the mobile client may connect to the server at a URL that either has been transmitted to the mobile client during handshake or to a default URL embedded with each mobile client. The URL may be a download page that allows users to download a new version of the mobile client replacing or superseding the old version.

Referring to the widget service server system may include one or more modules. The modules may be split on different physical machines. There may be additional components in an embodiment. The server system may include one or more of the following illustrated components 

The following sections detail some of the components of the Widget Service Server system depicted in .

The content adapters may serve to determine what type of content can be processed. Content adapters may then process the raw data into a structured format that is usable in the server system . In the system there may be a registry of adapters . Each adapter may register the type of data that it accepts and the location of the adapter.

Raw data may come into the system through channels. Data can go through a directed channel where it is known what type of data needs to be transformed. Alternatively data can go through a global channel where the system determines the appropriate adapter that can handle the data. In the case of a directed channel the system need not process what type of data is coming and can let the adapter handle the data. According to one embodiment for a global channel a stream is obtained from the data source. The raw data may flow through this stream. The system may pass this stream to each of the registered adapters. Each adapter may determine from the stream whether it can handle the stream or not. If it can handle the stream it notifies the registry that it can handle the data and may proceed to process the data.

In the event that there is more than one adapter than can handle the stream a priority based system may be in effect. As an example an RSS feed data source can be handled by an RSS parser a web service by web services adaptor and an XML document by an XML parser. The system may provide a method of registering priorities of adapters in an adapter registry such that a specific kind of adapter such as an RSS feed adapter may have the highest priority while a plain text document parser may have the lowest priority.

The raw data may be then processed for fast access and optimal delivery to mobile clients. It is up to the adapter to determine how best to optimize the raw data. According to one embodiment this may be done as follows The raw data may get processed as appropriate for its data type. For RSS feeds data may pass through an RSS feed parser. The data may be represented as objects while parsed. The data may then get normalized into a common data format so that other types of feeds such as ATOM can be stored in the normalized data structure. The normalized data may then be merged as appropriate with the data that is already in the data store. In the case of RSS or ATOM feeds each feed may have many articles. After normalization the articles may be taken and then compared against what is already in the data store. If it doesn t exist it can be added. Otherwise it can be ignored. The result is one unified feed that may contain all of the unique articles. The data can be filtered some more based on user preferences. For example a search string could be specified such that a user receives only articles matching the search. Finally the data may be transcoded to match the capabilities of the mobile device and the mobile application. The resulting transcoded data can be cached for fast access when multiple users with the same feed requirements access that data.

Textual data may come from a variety of data sources. One example is from RSS feeds that web sites can publish. Another source could be a relational database. Another could be a via human entered sportscasting tool. Still another could be from an IM instant messaging platform or a chat system. describes a system by which textual data enters the system for delivery according to one embodiment 

The content adapters may have push and or pull interfaces. The pull interface may implement a polling policy that has certain parameters to influence polling characteristics. For example over HTTP the source server could transmit HTTP headers to control the cache content of the feed e.g. when the feed expires so that we can fetch again . The frequency of the polling may also be influenced by the number of subscribers to the feed and the usage patterns when the feed gets accessed . These policies may affect the frequency of the polling thereby improving the speed at which the end user receives the feed. The system may not need to fetch the feed every time a user makes a request for the feed. Furthermore since the feed may be cached many different users could share the cached content without having to refetch over a slow network.

For sources that need timely updates the source may be prefetched as appropriate using the above described frequency fetching policy. This policy may ensure that the server is not overloaded by unnecessarily fetching and may also allow for timely updates to mobile devices. The policy can also be overridden to update on a fixed schedule. This might be done with sources used for demonstration purposes for example where users might not necessarily subscribe to the source but the source content needs to be fresh.

To optimize on server bandwidth the following algorithm may be used to determine when to pull content from a feed source if the feed source requires polling 

A push mechanism may also be used where a content publisher can push updates to the server when some data has changed. Polling policies need not apply here. When new data arrives it may be normalized and transformed as appropriate. For example sports data is usually pushed since the clients need to be updated in a timely fashion. After the data is received the clients may then be notified as appropriate.

When raw data enters the system it may be sent through a parser . The parser reads the raw data and converts it into data structures.

Data may enter the server through polling or push adapters as described above. A method by which data enters the system according to one embodiment is shown in and described below.

A mobile livecast widget may refer to a specialized mobile widget that delivers an interactive personalized information stream about an event. Such information may include without limitation a combination of a user personalized event status event specific graphical illustrations that depict various states of the event relevant summaries of the event edited media clips including video clips photos and commentary play by play event descriptions event based notifications related statistics and charts. Multiple end users may be able to simultaneously consume the information stream from their terminals. Further the information stream may be personalized based on the end users preferences and the terminal capabilities.

A livecast channel may refer to a specific mobile livecast. Alternatively there may be many channels being delivered to different sets of users. Users may be able to select and tune in to a specific mobile livecast. An exemplary livecast widget for the game of cricket is depicted in . Another example of a livecast widget could be streaming video of a live concert or streaming text and picture updates from a live event such as a competition conference or media reporting.

The livecasting server may include multiple subsystems. The first is a data source aggregation module where various content sources enter the system through adapters as described by pull adapters above . Sources can be automated RSS feeds or manual video clipping . In the case of video clipping tools may be available to clip the video and then assign timestamp information for synchronizing the video stream with other streams later in the pipeline as described below .

Content can be transcoded so that the media can by rendered by the various connecting device types. This is done through a transcoding engine that is specific to different media types described in the transcoding section above .

The various streams of information may be then synchronized by the media synchronization engine . This engine may take the different media types and match them to form a coherent stream of data including the different channels. An example is video audio and text commentary streams that come together so that the streams match their time signatures with one another. This may be done by marking each stream as they enter the adapters with timestamp information. This timestamp information provides a reference for the time at which the content enters the system. The timestamp may be provided by the system or provided externally. In one embodiment a sportscasting widget may contain several streams of information. The first stream that may arrive is a text stream containing text commentary of what happened at a particular time. In the meantime video may be processed externally clipped edited etc and then sent to the server. Before the video is sent it may be marked with a timestamp for the time at which the video is pertinent. So after the stream enters the system the video stream can match with the text stream based on the timestamps.

A broadcast module may then send the data stream to the connected clients . The broadcast module may also send data to replication servers to distribute high server loads. According to one embodiment the replication server may contain a registry of listeners . For each listener there may be a channel by which data can be pushed through. There may also be a cache that temporarily stores data for transmission. This data is in a pre rendered form for the various devices as created through the transcoding engine . For example a video stream would have been rendered into WMV 3GPP MPEG2 MPEG4 QuickTime and into 3 different bitrates for different network speeds . There may be a provision for the broadcast module to request the transcoding engine to transcode to a new format on demand. This might happen in the case when a requested format does not exist in the cache . In this case the data may be transcoded on demand and then stored in cache . As data is to be broadcast the broadcast module may pick up data from the cache and send to the connected clients it may be unaware whether the connected client is an end user mobile device or a replication server . However the adapters to which the listeners connect may determine what to send to the respective end points. For example a replication server adapter may broadcast other metadata about the streams such as author stream sources creation times etc .

On the client widgets can be created to listen for the streams. They can request different channels in the stream to be transmitted based on user requests and device capabilities. As an example embodiment a livecast stream may contain several channels video audio text advertisements. On a device with limited network bandwidth the client can request only text and image based channels in the stream text and advertisements . Clients can later request download of the omitted video and audio stream separate from the original real time stream. Users can delay the stream due to bandwidth constraints. In an example embodiment a stream may contain video audio text and advertisements channels. The user may choose for example only text and advertisements channels. So the text and advertisements are sent to the client in real time. The streaming widget on the client then displays an indicator to indicate that additional data is available on a different stream. Then the end user can initiate a separate download when he chooses to view this additional channel. The download might take longer however the user may be able to view the channel. The livecasting engine may support a backoff protocol described below to support large numbers of mobile widget clients connecting for updates frequently.

A location engine may generally act to store transmit and make use of location information provided by and to a mobile device. A mobile device may itself contain a location identification module implementing part of all of or more than the functionality of the server based location engine and the engine and module may work complementarily. The location identification module may be designed to determine the location of the device as for example by GPS or cell tower location. The location identification module may communicate with the mobile client or a component thereof e.g. the download manager to localize content such as widgets and data downloaded to the device. As such widget applications installed on the device may request network content customized to the location of the device. Similarly the server based location module may transmit information customized to the location of the device to the device. The device may transmit its location information to the server. The mobile device the server or a network resource may contain a location identification service which may be accessed by the device the server or another network resource. Information provided by the location identification service may be used to differentially serve content including data and widgets to a mobile device or a user.

The user vault may be used to store authentication credentials for the system and external systems. Credentials may include a login username and a login password. In the case of the system it may store username password and other user preferences. Such preferences include a users phone number their location topic interests address books search history favorite locations etc. User vault data may be used to simplify and eliminate user inputs on the mobile device when necessary by prompting or auto filling responses inside mobile widget inputs. These credentials may be used for a user to identify himself or herself and allow access to his or her account in the system.

In addition external credentials may be stored. These might include usernames and passwords for external email accounts instant messaging systems chat servers. These credentials may be associated with the user s primary system account. So when the user needs to access an external email through the system they need not login again. Instead the system may provide the credentials to the external system to grant access.

There may potentially be vast amounts of information in the system cache and data stores . A search facility may be provided for users to access specific information in the system. According to one embodiment search index is handled through an external pluggable search engine such as Lucene. The pertinent text fields may be passed through the indexer to build a searchable index of keywords. When users enter the keywords the associated document results may be returned.

The search may be split between public versus private data versus shared data. Public data includes data that any user can access. Private data includes data specific only to a particular user. Example public data includes RSS feeds from a news syndicate. An example of private data might be the user s bank records. A shared data pool refers to data that is shared amongst a set of users. Separate search indices may be created for different public private shared pools.

The search module can also have plugins for external search engines. This way if there is content that a user wants to access that doesn t exist in the system the external search can be invoked to return results.

In addition the system search results may be externalized so that external search engines can find data within the system . This is done by building adapters to the external search engines to provide them with documents to be indexed. An example adapter might be a web page that is publicly accessible on the web site. This web page may list the documents as hyperlinks to other documents that are to be indexed. This way search engines can use web crawlers to find this page and traverse the hyperlinks to the documents that are to be indexed.

The session manager may serve to provide a state that follows the user between stateless modes. For example web browsers and the HTML protocol are typically request response based and may not provide inter request context to other requests. Clients can send some identifying information about the user. This might be in the form of some unique server generated identifier that gets sent as a browser cookie. In one embodiment this cookie saves the generated identifier and sends it back to the user between requests to the server. The server may look up the current state based on this unique identifier thus the session state is maintained. Similarly a mobile client can have some similar mechanism to save the user s current state as a unique identifier. This way the session can be kept across requests.

The server may generate unique session identifiers. One type of identifier is a persistent identifier that may stay with the user regardless of whether they have contacted the server or not. The second type is a transient identifier that exists only for the lifetime of a login logout event. Using the persistent identifier a user s state can span across multiple devices. For example a user starts a persistent session on the web. The user then has to step away from the desktop. The user can continue the session on a mobile device. This may be done by referencing the same persistent identifier. The server can associate the same data because the same identifier is referenced.

The system may handle billing integration with third party vendors as well as custom internal billing. The billing system may include a database containing the events that are to be billed and another database including the cost per event or series of events.

A catalog may exist that contains an item to be sold and the price per unit. This catalog may be referenced by a widget as appropriate e.g. a user interface to display a catalog of sports games available for viewing . According to one embodiment an end user who wishes to purchase an item makes the request through the user interface. This request is transmitted to the server. For example the mobile client contains information about the user unique user ID as per Unique ID Generation above . On the server the user has registered some information about billing details. For example this could be credit card information or the user s mobile phone account number for charges to appear on their mobile phone bill . A confirmation is presented to the user.

At this point the system may make an entry in the database that indicates the user wishes to purchase n units of an item. The purchase is not finalized yet. Requests are then made to the necessary systems to bill the user. This might include a third party payment service such as PayPal or CyberSource. Or this might be an operator or an intermediary that handles payment. These requests may occur through adapters to each type of billing services. Once billing is confirmed by the billing service the respective adapter may receive the request. It may then mark a particular item as having been purchased. The widget can then access the item as desired.

Before the mobile client receives data the data can be further transformed to optimize for a particular device. Example transformations including image size scaling and format transformations. Another might include transcoding HTML into simplified HTML for mobile client browser. The results of the transcoding can be further cached so that subsequent requests to the same data from the same or different mobile client can be fetched from cache rather than recomputed. Another example is the transformation of video and audio for mobile devices. The source format of video might be AVI while the mobile version might require a 3GP format. So a transformation can occur. In this case caching can be done ahead of time since the transformation takes a noticeable amount of time.

For certain types of widgets such as RSS feed viewers each article may often contain a link that allows the user to read the actual source of the article. This link may point to a web site that might render well for desktop computers but not as well for mobile devices. In these cases the mobile client can run the content through a transcoding proxy on the system first. The transcoding proxy can simplify the page by applying heuristics to strip out unnecessary formatting ads navigational elements etc. reformat images resize and recompress paginate large pages strip out scripting elements handle complex rendering elements such as forms and frames and handle cookies .

For each page the full HTML that a site outputs may be transcoded to a simplified version that can render well on mobile devices. One embodiment of such a transcoder is described below. It is a regular expression based system. One embodiment of the process is illustrated in which includes a request for a page optional storage of cookies a server fetch a rules application loop and url rewriting caching of results and outputting of results . In the parsed state content can be filtered. For example objectionable material can be filtered out. Images larger or smaller than a certain size can be omitted.

With reference to the system may include a cache . The content in the data structures can be normalized into a global format that gets stored in the system. An example is RSS versus ATOM feeds Both may be characterized basically as representations of individual articles. Each feed may have a title and description each article has a title and summary etc. The two different formats may be parsed into data structures. The data structures may then be converted into a common format and stored in the system.

Another example is with sports data. The various content sources may each have their own data formats for transmitting game data. Sometimes however the elements of the same game remain the same. The content may be parsed into data structures. The data structures may then converted into a common format and stored in the system.

The system may include a cache . To implement the cache the data sources locations may be specified by a URL uniform resource locator . Using the URL the content can be indexed. In one embodiment an MD5 message digest 5 hash may be used which generates a 128 bit hash value or 32 character hexadecimal string . A hash is a one way function that can be used to fingerprint a string. MD5 can be used in a security context. However an implementation can use it as an index for a resource using the following elements 1 Perform an MD5 on the URL string. This becomes the index string. 2 Generate a filename with the index string. 3 Store the contents of the data into this file. 4 Then take the first n characters of the filename to generate a directory in which to store the file as shown below.

The above example used n 2. The number of characters to use for the directory name depends on the number of files in a directory to ensure quick access in a typical UNIX filesystem. For example if a system is to include 100000 data sources and the maximum number of files to be in a directory to ensure speedy access is 100 then n should be round up log 16 100000 100 is 3.

In the unlikely event that there is a collision for the MD5 hash same hash for two different URLs we may append a numeric counter at the end of the filename part of the path. In the above example if there is another URL that has a hash fingerprint of f016fc75785862248ed8bad4fb12de89 we ll append 0 to the filename to form f016fc75785862248ed8bad4fb12de89 0 . We ll continue with 1 2 etc for further collisions. To determine if we have a collision we may also store the URL as part of the data for the file.

In another embodiment we can utilize a relational database to index the URLs. In such a scenario we would create a database table that could have two fields. The first is for the URL. The second is a unique numeric identifier associated with that URL. When a URL is requested we look up in the database to determine the unique identifier associated with that URL. That unique identifier can form the basis of a filename that we can use to store the contents into. Alternatively we can also choose to store the data into the database using the BLOB binary large object data type.

According to one embodiment the logging module provides a fast method for other subsystems to write messages such as error message and access logs. It uses a buffered write mechanism where logging requests are buffered into fast memory. When the time is appropriate for example when the buffer fills up or the system is idle the logs may be written to disk.

Synchronization may be used to ensure that the data is the same between the server and the client i.e. that a first version or content and a second version of content are the same or may be updated. Because the client does not necessarily have the same storage space as on the server the client may receive smaller chunks of information. Additional information may be retrieved as requested. In addition the user might request bandwidth metering which limits the amount of data that is transferred to avoid costly monthly billing .

According to one embodiment the server synchronization engine may operate as follows see The server maintains a state of all the data for items of interest in storage. For example the server state may contain data about a user s subscription to widgets the widget contents like RSS feeds other information known about a user or widget applications etc. The items of data may have unique identifiers associated with them as well as a timestamp representing when the data was modified or updated. The unique identifiers increment such that given an ID n the next ID may be n 1 .

On the mobile client the client may compare the copy of the data that it has with what the server has. This can be done through the timestamp. At block the client may then request synchronization with the server. The client s timestamp and last seen identifier is transmitted to the server . If the timestamp is different we may know that the data has been modified and can begin the synchronization process. The next element is to determine what data was modified. This may be done through the unique identifier that is marked for each item of data. The comparison may be done against the unique identifier that is transmitted with the timestamp . A server identifier that is greater in value than the client identifier may indicate that server data was modified . This may indicate that the server is to send the new data from the last seen client ID on until the last server ID to the client. A client identifier value that is greater than the identifier on the server may indicate that the client data was modified . In this case the client sends the new data from the last seen server ID to the last client ID to the server. Timestamps may be updated appropriately.

If data was modified or removed the following can occur 1 The old data entry may be removed and or 2 in the case of modified or updated data a new data entry may be created with a new identifier. This new data entry may contain the modified data. The old data entry may not exist any longer and its unique identifier might not re used.

Conflict resolution may take place when both the server and the client have modified data . The system will check for registered conflict resolvers . If none are found default handlers may be in place to resolve conflicts . These default handlers can assume several modes. The mode used may depend on user preferences which may be fetched . In a first mode the server changes take precedence over client changes . A second mode makes client changes take precedence over server changes . A third mode is that the data is merged by appending data entries from the server and client together and maybe renumbering the identifiers to be sequential . As mentioned these behaviors may be configured by the user. Sometimes however this is not desired by widget developers. Widgets might want to define their own policies regarding data conflict resolution. In such cases there may be a registration module where widgets can register their own conflict resolution modules with the system. Then when the widget data is to be synchronized this module may get invoked whereby a registered resolver is found the resolver is applied to the data type and the resolved entries are sent .

Data may be compressed between the server and client. Compression may occur in a compression module . Example compression formats include but are not limited to gzip and deflate which are standard web compression formats . In addition data can be encrypted for additional security.

Data synchronization may be used to synchronize any content on the device including content acquisition settings which may include how often to retrieve content and what type of content to retrieve. Reconciliation of conflicts may take place according to the preferences of a user.

In one embodiment the mobile client can download and cache important data as well as simplified meta data about an item. Some of the resources that take a long time to download can be downloaded at a later time. For example see and . shows an article where the text has already been downloaded and cached. The image is not downloaded yet because it might take too long to download initially and the image might not be important for the article. Users can configure when to download the image. In this example the user has configured to download on demand. shows a clock icon in place of the image to indicate that the image is currently being loaded. A Loading . . . text in the upper right corner of Figure a tells the user that elements on the page are being downloaded. When complete the view looks like .

For widgets that require data sources the system may provide a mechanism to synchronize the data and handle transcoding for the client. This mechanism may perform content fetching and aggregation.

Several data sources may be encountered by the system. Examples include RSS feeds databases web services email calendaring systems web pages IRC or IM chat sessions application programmable interfaces etc. Each type of input may be handled by various adapters. For example with sports commentary data an operator could be sitting at a terminal entering comments for a particular sports play. The terminal could host a tool to capture user input and convert into an XML file for transmission to the system. Another type of data could be an RSS feed that is hosted on a site. The system might have an adapter that fetches updates from that RSS feed to be updated on the system.

The system may filter the data into individual types. The raw data may then enter the system and be stored in either a permanent or temporary store. For example RSS feeds may be stored into permanent storage whereas chat session data may be stored temporarily for forwarding. This may be the role of the content adapter .

It may be desirable to ensure server availability. Many clients polling a server for updates may cause many requests to come in at the same time causing server load to hit a ceiling. This may affect the quality of service for all clients that connect to the server. One solution is to implement a backoff protocol. illustrates one embodiment of the backoff protocol described below.

When the user receives and reads the message on his mobile device he may select the embedded link to install widget service client software on the device. The widget service client software may be installed on the mobile device and on initial launch the software may synchronize with the widget service website and download all the mobile widgets that the user has chosen. In certain embodiments the user s registration can be conducted on a traditional home computer. However in some embodiments the registration can be conducted on a mobile device.

In addition the registration system may prompt for a CAPTCHA Completely Automated Public Turing test to tell Computers and Humans Apart . This may be a raster image with some garbled text displayed such that humans can read the text while computers have a difficult time reading the text. The server may generate the CAPTCHA box display the CAPTCHA box and validate that the user identified the garbled text correctly box and or that the user entered valid fields . This test is often used to keep automated programs from registering dummy users.

Once registration is successful box the user may be prompted for a phone number or additional email address to send installation instructions to. In the phone number case the system may send an SMS containing a download link for users to download the mobile client. The download may proceed when the user selects a link in the message that appears on their mobile device. The mobile client can optionally be embedded with a unique identifier for user identification. This way the mobile client can download content from the user s account without having to enter login information.

The ability to track individual users may be helpful. Sometimes it is desirable to be able to track unique users as they access the server system from various mobile devices. Ideally a device may transmit its own unique identifier to the system. Such a system exists for some mobile devices. One such tracking mechanism is called an MSISDN mobile subscriber ISDN number . There could be a unique identifier that is embedded on the device or the user s phone number of the device. However such tracking information is sometimes filtered by carriers. Therefore the system may assign unique identifiers to the users when they first initialize the application.

The gallery may also be searchable. illustrates an exemplary search result display according to one embodiment. Users may select mobile widgets by searching for information such as New York Giants or Tiger Woods . The system may search through all available mobile widgets in the system and provide results. In addition the user may be provided with links to results generated from popular external search engines such as Google Search or Yahoo Search. As an example a mobile widget may be generated for Google search results on New York Giants . Then the user may be able to add this widget to his mobile device by selecting it. Additionally search results may include external web site results which match New York Giants . If the user selects these results a new mobile widget may be created with the selected web site as the data source.

Users may gather all the widgets they need by browsing or searching through the gallery and all their selections may be saved in the session. When ready a user may click the Add to my phone control to add the selected mobile widgets to his account. At this point all these widgets may be added to his account and become available on the mobile device the next time the device performs a synchronization session see section Sync Engine with the server. If the user is not registered the user may be presented with the registration element previously shown in to create an account and may further receive an SMS or email on his mobile device to install the widget service client for the first time.

A server may provide a gallery of software widget applications. Users of mobile computing devices may browse the gallery of widget applications from the mobile devices. The server may receive requests from the mobile devices for downloading widgets and the server may respond electronically sending a widget application to be downloaded and causing it to be installed. The mobile device itself may provide a gallery that provides such functionality where the objects and information in the gallery may in whole or in part be downloaded in the absence of a request by a user. Thus a mobile device gallery may download widget information the user may subsequently e.g. a week later review the widget information and may mark a widget for download and the mobile device gallery may subsequently e.g. at the next network connection or at a time of cheaper data or bandwidth costs download and or install that widget. Both a device based and server based gallery may use user profiles to determine which widgets to install or recommend.

The web front end may also provide an interface for the user to manage his mobile widgets from the web. shows an exemplary mobile widget management display where the user may be provided with all his currently active widgets. Here the user may delete a widget by simply clicking on the X on a widget icon . Then the widget may be removed from his account. He may also add any widget from the gallery to his account. All changes may appear on the mobile device after the next synchronization session. Further as in the user may preview all his mobile widgets on the web. Though this exemplary preview screen displays the widgets in a horizontal scroller note that they may also be displayed just as they would appear on the mobile client device. For example a mobile preview screen may replicate how the widgets will actually appear on the mobile device. The mobile preview screen may have the exact screen dimensions resolutions and appearance as the user s specific mobile device.

In some embodiments users may also manage their widgets directly from the mobile device. Many users worldwide may never have access to a desktop computer. Such users may perform all actions including registration login browse the gallery search and add mobile widgets remove mobile widgets preview the widgets and the like right from their mobile device from the embedded mobile browser and from the widget service client software installed on the device.

Since many mobile widgets may be added to the widget service s mobile widget repository it is desirable to make it easy for users to pick and choose the widgets they may like. According to one embodiment a built in recommendation system uses users preferences such as interests reading patterns and location and recommends other mobile widgets that the user may be interested in. This may be achieved through integration with a standard available collaborative filtering system such as Taste CoFI or Consensus.

According to one embodiment the recommendation system may suggest other widgets that a user may like. As an example consider a user from London in United Kingdom. If she has widgets such as Tube Delays Local TV guide and BBC news based on the interests of other users in the same location with the same widgets the recommendation system may suggest a set of widgets for her to add. The recommendations may be made both in the web front end and in the widget service client software.

In one embodiment users can manage their widgets on the mobile client. Users can reorder widgets and remove widgets from their mobile client without needing server connectivity. These requests may be queued on the client and rendered appropriately to the user. When the user connects back to the server these queued requests may be transmitted to the server for the server to process and reconfigure the server side image of the widget.

In another embodiment the mobile client may have an offline gallery of applications that the user can browse to add additional widgets. This gallery may be periodically downloaded by the server against the server. Users can browse this gallery to add new widgets without connecting to the server. Then when the widget is to be added a server connection is created and the widget is downloaded and subsequently installed.

The mobile device or mobile client may contain a widget adding component which may be designed to view and or obtain widgets for testing or installation on the device. The widget adding component may access the server or the offline gallery.

In one embodiment installation of new widgets occurs as follows A user adds the widget to their account. This may be done either through web WAP site or through another mechanism that has a real time connection to the system. The system can perform the request as follows First the appropriate widget may be located. Then an entry may be created in the database that marks the widget as installed for a user. The widget may then be transmitted to the mobile client when the client connects to the server. Widgets may have server side and client side portions of each package. The client side portion is transmitted to the client . The client accepts the package which is then unpacked by the client. The widget may then be stored in the widget storage with meta information describing the widget. Then as the client runs it may pick up the widget for display when appropriate.

The mobile client may include a widget discovery manager component. The discovery manager may contain a pointer or other reference to an online gallery of widgets or other repository or network location of data. The discovery manager may from time to time download widgets information or other references to or descriptions about widgets from the repository. The discovery manager may store the widgets information or other references on the mobile device for offline access and availability to the user. Such widgets or information may be displayed or previewed for the user. The discovery manager may perform such a download in the absence of a request by a user and the manager may preempt interrupt or otherwise notify the user of downloaded or to be downloaded content including widgets and references. The discovery manager may provide for any downloaded widgets to be installed either automatically or pursuant to authorization by a user. The discovery manager may further provide for deletion uninstallation or reset reinstallation of widgets or information either automatically or at the request of a user or transmission of preferences or other information to a server and thus perhaps changing the types of information to be downloaded in the future . Installation may include placing a widget or other data in a memory or store of a device such that the widget may be accessed displayed selected or terminated repeatedly Widget discovery or download may make use of user profiles associated with the user or mobile device.

The discovery manager may generally access any network or interactive resource as a location for widgets including an online gallery. The discovery manager may generally search or crawl a network resource may browse a collection of resources or may visit a URL. The gallery may display widgets or crawl for widgets based on a query by the user. The query may be handled by the discovery manager or the network resource or gallery. Query results may be presented to the user on a display. The discovery manager or another component may also personalize widgets such as by causing them or creating them to display specific data representative of a user user attribute or user interest or content.

In one embodiment the widget meta data may be stored on the server as a database entry. Widgets and widget data can be forwarded to others regardless of the accepting party s mobile operator or device. depicts one embodiment of this process. In this embodiment the originating party makes a request to send a widget to another party . This can be by specifying the widget and the other party s identifier . The identifier could be an email address phone number or any other unique property of the user s account. A connection may then be made to the server and the request is transmitted . The server accepts the request and then makes an entry in the database in the other party s account with the widget and a message from the originator e.g. Hello friend try this widget. . Then when the other party connects to the server they may receive this message along with an option to install the widget . Installing the widget may include the client connecting to the server the server checking a pending add queue and add list transmitting the request to the user . If the user accepts the installation the widget may be installed as described above . Otherwise if the user refuses installation the widget is removed from the database queue.

Users can also download the mobile client directly without having to register on the web site first. In this case the system can create an account for the user from the mobile device.

Otherwise users can select to create a new account. They enter an email address in a form field . The email address is checked to ensure uniqueness. If not unique a message may appear and a prompt to enter another email address appears. If the entered email is available unique in the system the user can optionally have the system generate a password to avoid more typing on a mobile device or to enter the password in a form field .

Users can then select some categories that contain predefined widgets for the user . This may be a quick way to get started on the mobile device without having to browse or search for widgets to add.

Further personalization of the user s account is also possible. In the user is prompted for their location. Here the user s location may be approximated by determining the connecting IP internet protocol address from which the mobile device is connecting from. Based on this address the system can map an IP address to a physical real world address via a lookup table of IP addresses to physical addresses. The system may present the computed location . If the automated determination is incorrect users can enter their location on the form field .

In some embodiments unique provisioning allows tracking of users so that users do not have to re enter login information from the client . It may be easier for users to enter their user information on a PC accessing a web site rather than entering the information from the device. An exemplary method of provisioning from a website according to one embodiment is shown in and described below 

A widget or application archive can contain code resources data and meta information. Code includes the application instructions to execute. Resources include media such as images sounds etc. Data is bundled data. Meta information describes the application. is a flowchart depicting the elements performed by the widget service according to one embodiment which are 

The server may transmit a given widget to a plurality of mobile devices of different types and different APIs and may change or not change the widget or the package as necessary to for execution of the widget on the device.

The system may include a tool that can be installed on an end user s web browser that allows for extracting specific areas from a web page and creating a mobile widget using that information as a widget data source. One embodiment of this tool is a plugin for browsers such as Microsoft s Internet Explorer product or a Mozilla Organization Firefox application. According to one embodiment the tool installs as a plugin that users interact with see . As a plugin the tool accesses various browser APIs to determine the page that the user is currently viewing the elements on the page etc.

Because this tool is able to access information about the page it can provide features that allow users to select various portions of a page to represent a source of data that the server can consume and hence allow the mobile clients to download. displays one embodiment of this functionality. In this figure users use their pointing device e.g. computer mouse to highlight areas of a web page as shown at . A floating window may display the various actions commands and status that users can use to refine the data selection. displays the completed data selection whose starting point was from . In this example the user has omitted the surrounding extraneous images and text and chose to obtain only the entries for Top Stories . The floating window may display the various actions that the user took to filter the content in order to obtain the refined data.

The various actions as summarized in the floating window may be then sent to the server once the user has completed the user interface portion of the data definition. When the widget on the mobile browser needs data from this data source the server may first fetch the web page just as an end user would do on a web browser. The server may then take the commands and apply them in the same manner as the user did using the tool. Because the dataset is now in a simpler format the server may take the resulting data and format it for consumption by the widget .

Alternatively this functionality can be applied on the user s web browser without sending to the server. This case is useful for when users want to format a particular web site to the way that they want the web site to appear. For example might be too cluttered for a user s liking. Instead the user can apply the tool to render the view as such that whenever the user visits this web site displays instead of .

Some embodiments may access the Document Object Model DOM elements on a web page. These DOM elements may be manipulated to trim add and remove entries on the page. The web browser may take care of rendering the result to the user. The tool manipulates the data through the DOM elements. The tool may also trap information about mouse cursor positions key presses etc so that users can interact with the tool. If the tool has access to the elements on the page that the user is viewing this tool can also contain other functionality such as advertisement filters search term highlighters hide animations etc. and show other example functions for which the tool can be in addition to web data filtering.

Publishers may also create mobile widgets programmatically. A framework for generating mobile wizards may be provided so that developers may create different types of mobile widgets that are not supported by the wizards such as those depicted in .

Many web users may have accounts on several RSS reader portals and other aggregator sites such as My Yahoo Bloglines or Google Reader. The web front end may offer a process for a user who has an account on one of those web sites to import their preferences into the widget service website. Several methods of import may be supported as depicted in . In one embodiment a user may enter his login information in an import field and select a control for an external reader suite such as Yahoo Google or Bloglines . A second exemplary method is for the user to provide a list of his subscriptions via OPML Outline Processor Markup Language a standard XML format for outlines.

There are many possible methods for importing an OPML file to the web front end. For example the user may paste the OPML file upload it or provide a web URL to the file. In one embodiment the user may select a control labeled Import Paste Upload or Enter URL . The system may parse the OPML file and add equivalent mobile widgets to the user s widget service account when he selects an OK control .

As an example if the user had a Bloglines account where he had CNN News CNET News and BBC News as subscriptions the widget service server may search for similar mobile widgets in the widget service gallery and add it to the user s widget service account. If a particular data source is not available as a mobile widget on the widget service website a new mobile widget may be created with that specific data source and then added to the system.

Bookmarklets may include lengths of code such as JavaScript that users may add to their browser bookmarks. This code may perform some action either directly or by executing other code which performs an action. As an example the system may contain a series of bookmarklets to help users add RSS feeds as data sources into various widgets. The user may visit a site containing an RSS feed to add. The user may then execute a bookmarklet which instructs the widget server to add the feed as a widget. Bookmarklets may be saved and used as normal bookmarks. When used as such they are simple one click tools which add functionality to the browser.

As an example a user with the bookmarklet installed visiting the web site www.about.com may simply click on a bookmarklet link while the web browser is pointed to www.about.com. The bookmarklet may then add a mobile widget that represents this selected web site to the user s account on the widget service website. If a widget does not exist a new mobile widget may be created for the selected web site. Note that even in this case if the user does not have a widget service account he may be presented with the elements to register and get the widget service software on his mobile device. After he downloads and installs the widget service software client on his mobile device he may then able to use the specific widgets added by him via the bookmarklet on his mobile device.

In one embodiment bookmarklets work as follows The bookmarklet may contain JavaScript code that may be saved in the user s web browser bookmarks entry. When the user selects the bookmark to execute while the user is viewing a web page the script may run. The script may get the web site URL that the user is currently viewing. It then passes this URL to the server . The server may receive this URL. It may then process the URL by grabbing the page that the user was viewing. From that it may collect information about the page to be referenced and may even create a new mobile widget if one doesn t already exist for that page. Once the data is in the system the user may proceed to browsing to other sites with his browser. This mobile widget may be available in the user s account while using the widget client on his mobile device.

According to one embodiment when the visitor clicks on this control he may be redirected to preview page of that blog widget see where the user can see a live preview of the blog widget in various mobile phone emulators . In this exemplary preview users may be able to experience the mobile widget right on the computer. The emulator may display the widget in several popular devices from vendors such as Sony Ericsson Motorola Nokia and BlackBerry. Users may be able to use the emulator controls to view a simulated experience of the Raw feed as a picture slideshow. Once the user decides that he wants the widget on his mobile device he may register and add this mobile widget to his phone. If the user is registered on the widget service server system he may login at this element. If he is not registered he may be asked to register first with a form as depicted by the exemplary form in . If he is already registered and logged in he may have the option of directly adding the mobile widget to his phone by clicking the Add control . Text may be presented to the user e.g. Click on the add control to add the blog to your list of mobile widget feeds. The next time you synchronize this blog will appear on your mobile phone or similar. Additional text may say Bloggers you may instantly mobilize your blog into a cool mobile slideshow . . . Click here to send to someone s mobile phone or similar.

In one embodiment if the user has created an account for the very first time and registered for the mobile widget service this way the user may get an email or SMS message on his mobile device to install the widget service client software and once installed this mobile widget may then be downloaded onto his mobile client. If he already has an account he may automatically receive the widget on the next synchronization session with the server system. shows a view of an exemplary user account with the widget service client software running on a Blackberry device where the exemplary Raw Feed widget is downloaded and displayed as an icon .

Thus it is possible for web users to directly add mobile widgets from publishers web sites as they browse their favorite sites on the Internet. Note that while this example describes a use case from a web log publisher similar elements may be used by any content publisher including web portals aggregators web services web video sites and the like.

The client and server may maintain counters for data usage. This data usage may be used to limit the amount of content a user is allowed to send and receive. This is helpful when a user wishes to limit their bandwidth usage to save on mobile data costs for example. These metrics are also useful in collecting usage information. This information may in turn be used to optimize server performance by allocating more resources for certain types of content that requires more bandwidth.

The user interface may contain configuration parameters that end users can specify to limit their bandwidth usage. When the server determines that the client has received the limit on the amount of information it may stop sending data to the client. Similarly the client may also store size limits locally so that if it receives more data than the threshold set on the device it can stop receiving more data. This limit may be parameterized to reset at certain times e.g. once a month after a billing period .

Information of widget usage by end users may be gathered for analytics learning user behavior and for recommending other mobile widgets based on a user s tastes. Here we describe the kinds of information gathered by the system and how the information is gathered by the analysis subsystem. The UniqueID method described earlier allows uniquely identifying a specific user. Since widget service client software enables mobile widget usage in an offline mode even while not connecting to the server such as on an airplane or when there is no wireless connectivity it is desirable to gather analytics even when the users are not connected. Thus each time the application is used by an end user to view a mobile widget the client may gather information on for example when the application was launched which widgets were used by the user and for how long the user stayed on each widget. This data may be saved locally on the mobile device and then posted to the server during synchronization.

The server can gather and allow processing of this information to learn both macro level patterns and individual patterns using standard business intelligence software such as Cognos or BRIO. Examples of macro level usage patterns include being able to answer questions such as what are the reading patterns and interests of male users ages 18 25 in the Continental United States or How popular is the weather widget during winter in Canada . Examples of individual patterns would be Who are all the active subscribers to the NFL and College Football mobile Widgets . The system may be able to perform various kinds of analytics on the usage of mobile widgets based on the data gathered by the system.

Some embodiments of the system can also use this data for recommendations to other users by providing some usage data. An example is the number of subscribers to a widget or the number of times a widget is accessed or by user rankings of widgets.

Some embodiments of the server include an ad syndication engine . The ad syndication engine may store and determine when and how to deliver advertisements to users. Advertisement delivery can be based on user demographics capable devices certain events etc. Advertisements may be presented in real time offline online and or contextually.

Even without the benefit of specific location detecting mechanisms on mobile devices such as GPS the location of a device may be determined by using the connecting IP address. Each mobile device that connects to the server may send an address to send a response back to. According to one embodiment the server may use this response address to approximate the user s location. The server may perform a mapping to a physical real world address via a lookup table of IP addresses to physical addresses. The mapping may occur in a database that contains the IP addresses to physical address mappings. The structure of the database may contain IP address ranges from and to addresses and a real world physical address for each entry. A comparison of an IP address against the IP address range may determine a match.

Along with the client side components of a widget that the mobile client can download server side components can also exist. According to one embodiment widgets exist in packages that contain a manifest. The manifest may describe the package contents as well as additional external resources that are required.

A widget package can contain resources that the client keeps and hence does not need to access the server for functionality . Examples include images HTML page snippets scripting code etc. Further examples include widget specific data such as currency rates audio and video files svg files text files general data files. The manifest may describe the resources the name of the application version external resources that need to be downloaded etc.

The server can host resources that are required but not downloaded by the client. Examples include database queries where it may be infeasible to download an entire database to a mobile client and each of the examples listed above. Instead the server can host a component that makes database requests and relays results to the mobile client.

The device fingerprint collector may gather clues as to the type of device connecting to the server. This may be accomplished via device HTTP browser headers that are transmitted by the mobile browser and optionally the mobile gateway through which mobile browsers could connect. These headers may include some identifying information about the device browser version make acceptable media types etc. This information however may not be standardized and it may be up to individual device manufacturers to decide how much or how little information to provide through the headers.

As such a device database on the server may fill in the gap. According to one embodiment the device database contains full information about a device s characteristics such as screen size available memory color depth etc. that usually are not transmitted when the mobile device connects. In addition the device database may have fallback mapping such that if a specific model of a device does not exist in the database a mapping is available to get to a generic version of the device characteristics. For example a fingerprint might identify a device as a Nokia 6030 version 2.3 . The database might not have an entry for that particular model of device. However it might have characteristics for a Nokia 6030 device and would hence return that result and so on comparing manufacturers and phone models. The analysis module described below may sift through the data in the database to return a correct result.

A second method of collecting a device fingerprint is through downloadable software that may be also included in the mobile client. It may be possible for the client engine to determine device class e.g. a Java based device or a Windows PDA device . From that the client engine can load some additional detection code or diagnostic tests that get sent to the client. When run this detection code and tests may use the device s platform APIs to determine more information about the device and send that information back to the server. The results of the diagnostic tests and code may be used as the basis for determining what types of content to transcode for a mobile device and how to transcode the content. The results of the diagnostic tests may be sent to a server and the results may be used to select which widget applications versions of the mobile client engine or other data to send to a mobile client. The diagnostic tests may be used as part of an installation method.

With reference to according to one embodiment when a device connects to the server either via web browser or via mobile application the analysis module may collect all information from the fingerprinting system and query the device database . It may first look for specific matches on the fingerprint e.g. model make firmware version supported media types etc . Weights may be assigned to different identifying marks. For example the model number might have the most weight while supported media types have the least weight. From this a query is performed on the database. If an exact match is found that match may be used . Otherwise the system may return a list of possible matches the highest ranked of which may be used . Alternatively if no matches are found a fallback mechanism may used . For example a firmware version may not match exactly. If device characteristics of an earlier firmware version are defined that may be used. If a phone model is specified that may be used. And if nothing other than manufacturer is defined that can be used etc.

Various tools may be provided to allow developers and users to create additional widgets that can be uploaded to the widget service. Tools may exist in hosted form as user installed tools and as mobile tools.

However the mobile client can choose to show the current progress of the download. A screen may appear with a progress bar to indicate the current download progress. While the user waits the mobile client can begin to show a preview of the items that have already been downloaded . The items may automatically rotate at a predetermined interval. Users can also interact with the screen to view other downloaded items and to scroll down the item to show more text.

In another mode the mobile client may be configured to download in the background and allow users to begin interacting with the widgets as they are downloaded. A network content download manager as a component of the widget client may receive requests from widget applications to download network content. The download manager may manage the downloading of requested content while the widget is running or alternatively when the widget is not running is terminated or is blocking. The download manager may resume restart callback or launch the widget at certain points in the download or after the download is complete. The download manager may store the downloaded content permanently or ephemerally. The download manager or the widget may from time to time cause the deletion of stored network content.

In some embodiments the device or client engine may be configured to download network content at the request of a widget without requiring the user to request the content and without necessarily immediately displaying the network content. Rather the downloaded content may be stored in a memory of the device for later sue and consumption by the widget especially in the later absence of a network connection. Content may of course be transcoded into a form more suitable for use or display on the device before being downloaded. For example content may have its volume lowered or increased dynamic range changed color palate changed width or size adjusted images scaled or compressed and so forth.

In some embodiments a software widget may receive a first request for data from a user. The widget may initiate a downloaded of the content perhaps via the download manager described above . The widget or the download manager or client software may thereafter initiate requests for other additional network content that has not been specifically requested or instructed by the user. The identity of which data to prefetching may be determined by heuristics located on the server or the client device and may be private to a widget.

After download is complete the user can enter a widget launchpad screen illustrates one embodiment of the widget launchpad screen. In this embodiment the launchpad displays the set of widgets that the user has chosen and personalized based on his preferences. A user may select any widget icon to launch it and see more detail. The user can use a multi directional selection key on a cellular telephone to move around the screen. Other input mechanisms such as a stylus or voice input may be used as appropriate. The illustrated widget icons are displayed in a grid. They may also be displayed in other layouts such as a list or a dynamic homepage canvas as appropriate. For example widgets may also be displayed in a carousel format where selecting or hovering over a widget may cause more information to be displayed possibly above the widget and where widgets may slide horizontally or vertically in a manner akin to a CD carousel.

There may also be a dynamic information display which rotates information from the widgets. As one example a few of the widgets installed include CNN News Local Traffic Local Weather and news from the POPSugar weblog. The dynamic information display may rotate headlines or status messages from these widgets every few seconds. The user may click on the information display to view more detail such as an article summary or a traffic incident detail or weather for a certain day. See top of . 

When a user selects a specific widget the maximized detail view of the widget may be displayed. illustrates detailed views of an example widget according to one embodiment. In this embodiment the user has added an RSS widget that shows headlines from various sources. and show three different RSS feeds that the user has configured for the RSS widget. The feed title as well as a random sample of articles in the feed is displayed. Links appear for the user to show more articles in a particular feed the Show More link or to remove the feed from the RSS widget the Delete link . Users can also choose a different view in which the feed icon appears to the left and just the feed title appears along with the number of unread articles in a particular feed. Users can configure different display representations by configuring parameters of the RSS widget.

A widget can present itself in multiple formats depending on the mode screen size and capabilities of the mobile client. Some of these modes may include a minimized state a full screen view and a summary screen view. In a minimized state one embodiment of this application can be a grid of icons . Each icon represents a minimized view of the application. When users select the icon a full screen view of the widget may be displayed . In the summary view a screen of important user defined to appear widgets can be displayed .

For the minimized view the icon can be static or it can show a state of the application. For example a weather widget may display a cloudy icon if it s currently cloudy. A traffic widget might show a stop sign if there is traffic on a predefined route. A clock widget might show the current time.

In the summary view a larger space may be allocated for display of some status information. For example a weather widget might show a five day forecast as five icons that represent the weather for each day. A stock widget might show a scrolling ticker of stock symbols and current prices. A clock widget might show the current time as well as the current date.

In the full screen view the widget may have the entire screen of the mobile device to render on. In addition the full input capabilities may be available for the user to interact with the user interface. For example there may be more space for text input fields.

In addition to being available in the mobile client as maximized minimized or summarized views widgets can preferably be hosted on native home screens on mobile clients. Certain mobile devices have the capability to display application information on a home screen. Examples include a Windows Mobile PDA. The home screen of a PDA may contain the time signal strength upcoming appointments etc. see .

In some embodiments the mobile client may contain a plugin on supported platforms. These plugin hosts widgets that are otherwise displayed in the mobile client. The plugin may be registered with the native home screen. The mobile widget may be displayed on a native display canvas on the native home screen.

On the client there may exist an advertisement ads store where ads are stored and queued in. When the mobile client receives commands to display these ads the mobile client can pick up the appropriate ad from the ads store to display. Also the mobile client can determine when to pick up the ad from the store and display it. In some embodiments the mobile client does not need to be connected to the server in order for the ads to be rendered. The ads may get displayed even if there is no connection to the server. If a user interacts with an ad such as by clicking it the ad or client may be configured to perform an additional action such as accessing a URL initiating a telephone call to a service or company show additional information e.g. popups relevant to an ad or play audio or video relevant to the ad.

As the ads are displayed information may be logged about the displayed ads and the user interaction with the ads. This may include the number of times the ad has been shown in which context whether the user clicked on the ad whether the user initiated a voice call based on the ad the times these events occurred etc. All this information may be stored locally on the mobile client so that a network connection need not be created. Then when the mobile client establishes a network connection this information may be transmitted back to the server.

A server may contain a repository of adveristement to be displayed on mobile devices and in association with widget applications where the server may select advertisements based on user actions such as downloading history and or user profiles.

The client may support a mechanism to cache mobile advertisements. The widget service server may support a technique wherein advertisement commands are sent once to the client and the client caches the advertisements and displays them when required.

The advertisement server component may maintain a list of advertisements in the current campaign and the total impressions required over a period of time. When a client connects to the server one or more delayed advertisements referred to herein as AdCommands may be sent to the client. An AdCommand may contain some or all of the following details 

In some embodiments one or more AdCommands can be sent to the client . The client may maintain a round robin queue of these advertisement commands and render the advertisements whenever the user uses a widget. The user may use the widget application in a disconnected mode and these commands may execute and display the advertisements even when the user is not connected over a mobile data network. In some embodiments the advertisements need only be downloaded once to the client. The weight may be used to control the frequency of the advertisements. Higher weights may represent advertisements that are displayed more often.

The client may maintain a log of all the advertisements displayed and these metrics may be collected and posted back to the server each time the client performs a synchronization session with the server . In some embodiments new AdCommands may be sent to the client at any time to augment the current set or reset the advertisement queue.

As described earlier the client software may be capable of displaying a dynamic information display such as a ticker or a dynamically formatted homepage. According to one embodiment when headlines are rotated on such a ticker users can glance at these articles and may click on headlines that they are interested in. It may be desirable to increase the relevance of the articles to the user so that they click more on these articles. Here we describe techniques and methods to increase the relevancy of the information displayed based on a variety of factors. illustrates these techniques according to one embodiment.

Box shows processes performed on the client device to increase relevancy of the articles. Initially in Box a list of articles is scanned from the local storage on the mobile device. The dynamic information ticker may be functional even when the mobile client is not connected to the wireless network. Initially the most recent articles from all the widgets that have a dynamic content source associated with them may be added to the information ticker display and may be rotated at an interval in a circular queue. Elements described in Boxes may be performed to increase the relevancy of the information to the user. Box represents filtering by unread articles so that there is no repetition of articles. Box represents prioritizing the articles based on weights. Initially a weight of 1.0 may be assigned to all widgets. As users use the widgets possibly based in part on the number of times a particular widget is used and based on whether the users click on a headline pertaining to a widget the weights are modified. Thus as the user uses the widget service client software the system may deliver headlines more in line with what the user clicks. In addition the weights may be manipulated by external factors. As an example it is possible to use standard user ratings and collaborative filtering systems to identify hot topics and automatically offer them as headlines even though the user has not subscribed to those widgets and therefore may be missing important updates.

The next element may filter out specially tagged feeds such as graphics only feeds e.g. comic strips that require a big display for them to be effective search results from search engine widgets or static widgets if desired such as to do lists. The next element may add any updates of desirable essential widgets such as weather and local traffic periodically if there is an event. As an example if there is a change in traffic conditions a headline could be added from traffic. Otherwise no traffic information is added in the ticker. The next element may add advertisements from the local cache based on the advertisement cache. If there are any advertisements that need to be included in the ticker they may be inserted based on the rotation frequency specified by the AdCommand.

Finally box this filtered list of headlines may be rendered periodically in the information display. At the end of each cycle a scan may be made to see if new articles have arrived on to the local store of the client software. If so elements described in box may be repeated.

It is possible to further improve the relevance of the articles by using other parameters such as local time current weather and semantic knowledge of current headlines. As an example if there is a winter storm in the local area the system may include more weather headlines. If it is closer to the afternoon the system may show the traffic updates more often. Therefore though not mentioned here anyone skilled in the art may be able to add such rules to increase article relevance for the dynamic information ticker.

Referring to according to one embodiment a user may create a topical mash up mobile widget. In this example the user creates a widget on the topic of Arabian Horses . A topical mash up is a type of mobile widget that may continually aggregate information from several content sources and present it as one mobile information stream. A user who adds this widget onto their mobile device may receive regular information updates about the topic Arabian Horses on her mobile device.

As in the widget publisher may be asked to enter a few keywords on the topic on which he wants to create a widget. Text may be presented to the user such as Use this wizard to publish your own mobile widget. At this time you may create a mash up widget which aggregates content around a topic from several content sources. Star by entering a few keywords. Once you publish the widget you can get it on your mobile phone share it with friends. We will automatically update your mobile widget with new content as and when it becomes available The user may enter the information in a text box and submit it by selecting the Start key or an equivalent. The query may be transmitted back to a central server and parsed. A next control can be provided to enter the inputted data and proceed to the screen of . In the user selects an image that visually represents the widget provides a title and enters optional descriptive information such as description and tags . shows an exemplary method of selecting images in which the user picks the image by clicking on a particular image . This information may be associated with the widget and used later to categorize the widgets in a repository. Another next control may be provided.

The display in allows the widget publisher to pick information sources to aggregate into his widget. The user can select one or more sources to add to the widget. Several information source choices 3735 may be presented to the publisher. One set of information sources represent search engine resources on the web such as Google search yahoo search Google News search Yahoo Image Search Flickr Image search Upcoming.org event search MySpace Blog search eBay product search and the like. An information source may be the result of running the query on any of these search engines. The publisher can select this by selecting the checkbox next to any of these provided choices. The sources may also include data repositories news sites and so forth.

Another information source in may be already available content sources on Arabian horses that other widget service users have added previously thus far into the system. Another information source is similar content sources derived from running the query Arabian horses on external search engines. Further the user may know a specific web site and he may also be able to enter that specifically as a URL in a text box . illustrates an emulator preview that enables the user to click on any information source on the page any preview portions of the widget on a mobile emulator. Once the user is satisfied with his selections to include in the mash up widget he may submit the information by selecting a Next key or equivalent.

Yet another widget type is a blog widget that encapsulates a web log commonly referred to as blog. An exemplary set of elements according to one embodiment for creating a web log widget non programmatically is disclosed in . A blogger who is the publisher of a weblog may use this publishing wizard tool to generate a mobile widget. In an exemplary element is provided where the blogger chooses one of various kinds of graphical controls . These controls also referred to as blog controls may be standard widget service controls or personalized controls . Some bloggers prefer to personalize these controls. The exemplary display in shows the control personalization element. Here the blogger may select a background graphic presented by the system and also upload a graphic that represents his or her blog. A new personalized blog control is then generated for blogger. The blogger may further try out variations by loading different graphics cropping the images until satisfied. Then he clicks the Next control or equivalent to proceed to the next element.

An exemplary display representing this next element is shown in . The blogger may enter a title for the widget a short description and a few keywords that relate to the blog. All of these fields may be used to search and categorize the blog widget in the gallery. The blogger clicks the Next control to complete generation of the mobile blog widget representing his blog. As in he may be presented with a short snippet of HTML JavaScript or other code with instructions to use it. In this display the code may be emailed to him for convenience.

In addition to the generated blog control a mobile widget with the same graphic may also be generated. The mobile widget may be added to the gallery on the widget service for other users to use and share. The blog control may be used by the blogger to put on his website to advertise the fact that his blog is now available as a mobile widget. The blog controls may be standard Send to Phone controls or personalized picture controls or also dynamic slideshows that show the entire preview of the mobile widget experience itself. In addition to bloggers though not shown in this figure in some embodiments any user with a web home page on social sites such as MySpace Facebook or any web site owner can create a mobile widget and an associated blog control using the Wizard. When a reader of that blog clicks on that control on the blog site he or she may be redirected to the widget service web front end and may be allowed to register to widget service and add that specific blog widget on to his widget service client software .

Further as shown in in some embodiments the blogger may preview the mobile widget on the web. Current information may be fetched from his web log and may be rendered as a live preview in the exemplary mobile emulator . Here the blogger may fully navigate through the widget and view the blog widget that he just created.

Another set of widget publishing wizards may be offered to mobile users. These mobile widget publishing wizards may be available on a client device via a mobile web browser on a client device or as a widget itself. Similar to the web interface the mobile user may be presented with a series of elements to create and publish a new widget.

The example of illustrates a parent creating a mobile widget for her daughter s soccer season. She periodically takes pictures from a camera of her mobile phone during every game and posts it to that widget . Grandparents and other family members that may subscribe to this widget to periodically receive a photo stream as and when new pictures are uploaded. This whole use case may not require a desktop computer since the widget is both created and subscribed to from a mobile client device.

Though not shown it is possible to present the user with several such wizards to publish various kinds of mobile widgets. Other examples include a mobile widget that shows a picture slideshow of personal pictures music or videos. In this case the user may be asked to input URLs to upload the specific media and a mobile widget may be generated with the associated media. Yet another widget could be a personalized weather widget where the user specifies a location and a weather mobile widget would be generated for him.

As described in the previous example in the system may then present the user with one or more choices where the user selects the type of information to be added in the mobile widget box . For a weather widget this may be the zip code or location for a mashup widget this may be a list of content sources for a photo album widget this may be a list of image URLs. The user may then add the content details and submits these choices to the system box . The widget service server system may then generate the mobile widget in a element depicted by box . The details of process are depicted in and described in the section named Mobile Widget Creation 

In the embodiments described above each flowchart is shown for the illustrative purposes. Some blocks in the flowcharts can be omitted or combined with one another in other embodiments.

Although this invention has been disclosed in the context of certain preferred embodiments and examples it will be understood by those skilled in the art that the present invention extends beyond the specifically disclosed embodiments to other alternative embodiments and or uses of the invention and obvious modifications thereof. Thus it is intended that the scope of the present invention herein disclosed should not be limited by the particular disclosed embodiments described above.

Push the following string onto the stack. The following value is an integer index into a constants table with the string values indexed by the integer index.

Get the value of the specified variable and pushes that value onto the stack. First we ll check the local scope. If the variable doesn t exist we ll look in the global scope.

Pops a value off the stack and stores that value for the specified variable in the local scope if a variable has already been defined in a local scope. Otherwise save into the global scope.

Pops a value off the stack and stores that value for the specified variable in the local scope. Also sets the accumulator with the value.

Gets the value of the specified property on an object. Pops the object to retrieve a property from off the stack and then references the specified property. The value is pushed onto the stack.

Sets a property on an object with a specified value. Pops the value to store and then pops the object to apply. Then the property is applied on the object with the value.

Calls the function at the specified program counter. First pops the number of arguments that are going to be passed in. Then pops the arguments one by one in reverse order. So the first argument popped in is the last argument to the function. Next we push the program counter of the next instruction onto the stack so we can return . Finally we set the program counter to the function reference pointer to begin execution of the function. OP FUNCTION RETURN Specified at the end of the function to return to the instruction after the function call. First pops a value from the stack to return to the caller. Then pops the program counter from the stack to return to. Then sets the accumulator to the return value back for consumption after the function call. OP DEFINE FUNCTION This is to be used at the start of function definitions to map arguments passed into a function into the parameter names that the function declared. The parameter names should have been pushed in reverse order. The top of the stack should contain the number of parameter names. Then for each parameter name we ll go through the arguments array that gets passed into all functions and map the values to the variable names in the stack. OP NEW not there Calls the constructor function at the specified program counter and creates an object. First pops the number of arguments that are going to be passed in. Then pops the arguments one by one in reverse order. So the first argument popped in is the last argument to the function. Next we push the program counter of the next instruction onto the stack so we can return . Finally we set the program counter to the function reference pointer to begin execution of the function. On return we discard the return value. Instead we ll use the object this to be pushed onto the stack. OP JSR Pushes the next instruction pointer onto the stack. Then jumps to the specified program counter. OP JSR RETURN Pops an instruction pointer off the stack and jumps to that program counter location. OP SUB Subtracts two values from the stack. Pops the right value and then the left value from the stack. Then subtracts the right value from the left value. The resulting value is pushed back on the stack. OP ADD Adds two values from the stack. Pops the right value and then the left value from the stack. Then adds the right value to the left value. The resulting value is pushed back on the stack. OP MUL Multiplies two values from the stack. Pops the right value and then the left value from the stack. Then multiplies the right value to the left value. The resulting value is pushed back on the stack. OP DIV Divides two values from the stack. Pops the right value and then the left value from the stack. Then divides the right value into the left value. The resulting value is pushed back on the stack. OP MOD Gets the remainder of a division between two values from the stack. Pops the right value and then the left value from the stack. Then divides the right value into the left value and gets the remainder. The resulting value is pushed back on the stack. OP NEG Negates 2 s complement a value on the stack. Pops a value from the stack negate it and pushes the value back onto the stack. OP NOT Inverts 1 s complement a value on the stack. Pops a value from the stack NOT it and pushes the value back onto the stack. OP AND Performs a bitwise AND of two values from the stack. Pops the right value and then the left value from the stack. Then performs a bitwise AND of the right value into the left value. The resulting value is pushed back on the stack. OP OR Performs a bitwise OR of two values from the stack. Pops the right value and then the left value from the stack. Then performs a bitwise OR of the right value into the left value. The resulting value is pushed back on the stack. OP LE Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is less than or equal to the right value a True is pushed onto the stack. Otherwise a False is pushed. OP GE Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is greater than or equal to the right value a True is pushed onto the stack. Otherwise a False is pushed. OP EQ Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is equal to the right value a True is pushed onto the stack. Otherwise a False is pushed. OP NE Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is not equal to the right value a True is pushed onto the stack. Otherwise a False is pushed. OP LT Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is less than the right value a True is pushed onto the stack. Otherwise a False is pushed. OP GT Performs a logical comparison of two values from the stack. Pops the right value and then the left value from the stack. Then compares the left value to the right value. If the left value is greater than the right value a True is pushed onto the stack. Otherwise a False is pushed. OP COND JUMP TRUE Pops a value from the stack. If its boolean equivalent is True then branch to the specified program counter. Otherwise continue to the next instruction. OP COND JUMP FALSE Pops a value from the stack. If its boolean equivalent is False then branch to the specified program counter. Otherwise continue to the next instruction. OP JUMP Branch to the specified program counter. OP LOGICAL NOT Performs a logical not on a value on the stack. First pops the value. Then converts the value into a boolean equivalent. If the value is True we ll push False onto the stack. If the value is False we ll push a True onto the stack. OP SHR Shifts a value to the right by the specified number of bits preserving the sign bit. First pops the number of bits to shift by. Then pops the value to shift. Then shifts the bits as specified pushing the resulting value back onto the stack. OP USHR Shifts a value to the right by the specified number of bits ignoring the sign bit. First pops the number of bits to shift by. Then pops the value to shift. Then shifts the bits as specified pushing the resulting value back onto the stack. OP SHL Shifts a value to the left by the specified number of bits. First pops the number of bits to shift by. Then pops the value to shift. Then shifts the bits as specified pushing the resulting value back onto the stack. OP LOGICAL AND Performs a logical AND on two values on the stack. Pops the right value and then the left value from the stack. If the boolean equivalents of both values are True then push a True onto the stack. Otherwise a False is pushed. Note that the compiler should generate a short circuit evaluation of this operator so that if the first value is False it does not evaluate the right operand. OP LOGICAL OR Performs a logical OR on two values on the stack. Pops the right value and then the left value from the stack. If the boolean equivalents of either of the two values are True then push a True onto the stack. Otherwise a False is pushed. Note that the compiler should generate a short circuit evaluation of this operator so that if the first value is True it does not evaluate the right operand. OP XOR Performs a bitwise exclusive OR of two values from the stack. Pops the right value and then the left value from the stack. Then performs a bitwise exclusive OR of the right value into the left value. The resulting value is pushed back on the stack. OP TRY Defines a try catch finally block. Pops two values off the stack. Pops the PC of the catch block and saves in the handler. Pops the PC of the finally block and saves in the handler. The catch block handles the exception if thrown. The code in the finally block always gets executed whether or not an exception occurred. If the PC for either value is 0 then the respective block is disabled. For example if the catch PC value is 0 the catch block is not defined and exceptions may not be handled. Similarly if the finally PC value is 0 the finally block is not defined. OP END TRY Closes the try catch finally block by resetting the handler for the current stack frame. OP THROW Pops the value off the stack and throws an exception. Looks for the current handler. If an exception handler is defined the handler may handle the exception. Otherwise pops off the current invocation stack frame to the caller frame to see if a handler exists there. It continues until there is a handler or until there are no more stack frames. At that point the mobile client handles the exception one implementation could show the error to the user . OP CLEAR EXCEPTION Clears the pending exception.

