---

title: Systems and methods for framebuffer management
abstract: Methods for managing a framebuffer in a single memory pool comprising frame buffer memory and display list memory on printing devices are presented. In some embodiments, a method for managing at least one pixmap corresponding to an image using equal sized blocks allocated to the pixmap from a memory pool comprises: receiving a request for at least one scanline in the image; securing a pointer to at least one block from the memory pool in response to the request for the at least one scanline, if memory blocks are available in the memory pool; and applying at least one of a plurality of memory freeing strategies, if there are no memory blocks available in the memory pool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08817032&OS=08817032&RS=08817032
owner: Konica Minolta Laboratory U.S.A., Inc.
number: 08817032
owner_city: San Matco
owner_country: US
publication_date: 20080829
---
The present disclosure pertains to the field of printing and in particular to systems and methods for framebuffer management.

Document processing software allows users to view edit process store and print documents conveniently. However before a document can be printed pages in the document are often described in a page description language PDL . As used in this document PDL s include languages used to describe pages in a document such as PostScript Adobe PDF HP PCL Microsoft XPS and variants thereof. PDL descriptions provide a high level portrayal of each page in a document and are often translated to a series of lower level printer specific commands when the document is being printed a process termed rasterization. Although the rasterization process may be complex and depend on the features and capabilities offered by a particular printer flexible and portable general purpose rasterization schemes may allow printer performance optimizations based on available memory desired print speed cost and other criteria.

Traditionally memory in printing systems has been organized in two distinct pools comprising display list memory and frame buffer memory. Display list memory typically holds display list objects for rasterization while the frame buffer memory typically holds image data specifying marks to be made on a printed page. A bitmap is a type of memory organization used to store digital images in which each pixel is assigned a single bit i.e. the pixel is either on or off . The term pixmap or pixel map is used to denote a raster image that can exist at a number of bit depths. Because of the separate nature of the two pools display list memory cannot typically be used for frame buffer purposes and vice versa. Therefore print failures can occur due to insufficient memory in one pool even if there is sufficient available memory in the other pool. Moreover the use of separate routines to manage the two distinct pools may make it difficult to modify and maintain the code used to manage memory across a product family because different strategies and optimizations may be used in individual products.

Memory resource optimizations may be important even in situations where the entire memory is treated as a single pool. For example pixmaps in frame buffers have traditionally used variable sized contiguous chunks of memory which leads to memory fragmentation. Fragmentation causes available memory to be scattered in small unusable blocks preventing satisfaction of some memory allocation requests even though the aggregate of the available memory in the small blocks could have satisfied the memory request if the small blocks were contiguous.

Where the memory is shared between the display list and frame buffer memory optimizations become important in ensuring that each pool has adequate available memory during printer operation and that potentially available memory is not lost due to inefficiencies in allocation. At a global level the optimization strategies may ensure that memory is allocated between display list and framebuffer memory to meet printer design goals such as cost and or print speed. In addition localized display list and framebuffer specific optimizations ensure that optimizations available at a lower level are exploited. In inexpensive printers efficient memory resource may allow design functionality to be achieved using relatively lower memory. In high end printers efficient use of memory may allow for greater real time availability of memory for printing applications and lead to performance improvements.

Thus there is a need for systems and methods to manage memory on printers for rasterization including framebuffer memory that would allow an optimal use of memory resources while providing a seamless upgrade path.

Consistent with disclosed embodiments systems and methods for managing a frame buffer memory are presented. In some embodiments a method for managing at least one pixmap corresponding to an image using equal sized blocks allocated to the pixmap from a memory pool comprises receiving a request for at least one scanline in the image securing a pointer to at least one block from the memory pool in response to the request for the at least one scanline if memory blocks are available in the memory pool and applying at least one of a plurality of memory freeing strategies if there are no memory blocks available in the memory pool. The memory pool may comprise frame buffer memory and display list memory.

Embodiments disclosed also relate to methods created stored accessed or modified by processors using computer readable media or computer readable memory.

In accordance with embodiments reflecting various features of disclosed embodiments systems and methods for the automatic storing manipulating and processing of a second or intermediate form of printable data generated from a first printable data are presented. In some embodiments the first printable data may take the form of a PDL description of a document and the intermediate printable data may take the form of a display list of objects generated from the PDL description.

As shown in exemplary system includes computers including a computing device and a server . Further computing device and server may communicate over a connection which may pass through network which in one case could be the Internet. Computing device may be a computer workstation desktop computer laptop computer or any other computing device capable of being used in a networked environment. Server may be a platform capable of connecting to computing device and other devices not shown . Computing device and server may be capable of executing software not shown that allows the printing of documents using printers .

Exemplary printer includes devices that produce physical documents from electronic data including but not limited to laser printers inkjet printers LED printers plotters facsimile machines and digital copiers. In some embodiments printer may also be capable of directly printing documents received from computing device or server over connection . In some embodiments such an arrangement may allow for the direct printing of documents with or without additional processing by computing device or server . In some embodiments documents may contain one or more of text graphics and images. In some embodiments printer may receive PDL descriptions of documents for printing. Note too that document print processing can be distributed. Thus computing device server and or the printer may perform portions of document print processing such as half toning color matching and or other manipulation processes before a document is physically printed by printer .

Computing device also contains removable media drive . Removable media drive may include for example 3.5 inch floppy drives CD ROM drives DVD ROM drives CD RW or DVD RW drives USB flash drives and or any other removable media drives consistent with disclosed embodiments. In some embodiments portions of the software application may reside on removable media and be read and executed by computing device using removable media drive .

Connection couples computing device server and printer and may be implemented as a wired or wireless connection using conventional communication protocols and or data port interfaces. In general connections can be any communication channel that allows transmission of data between the devices. In one embodiment for example the devices may be provided with conventional data ports such as parallel ports serial ports Ethernet USB SCSI FIREWIRE and or coaxial cable ports for transmission of data through the appropriate connection. In some embodiments connection may be a Digital Subscriber Line DSL an Asymmetric Digital Subscriber Line ADSL or a cable connection. The communication links could be wireless links or wired links or any combination consistent with disclosed embodiments that allows communication between the various devices.

Network could include a Local Area Network LAN a Wide Area Network WAN or the Internet. In some embodiments information sent over network may be encrypted to ensure the security of the data being transmitted. Printer may be connected to network through connection . In some embodiments printer may also be connected directly to computing device and or server . System may also include other peripheral devices not shown according to some embodiments. A computer software application consistent with the disclosed embodiments may be deployed on any of the exemplary computers as shown in . For example computing device could execute software that may be downloaded directly from server . Portions of the application may also be executed by printer in accordance with disclosed embodiments.

In some embodiments CPU may be a general purpose processor a special purpose processor or an embedded processor. CPU can exchange data including control information and instructions with memory and or firmware . Memory may be any type of Dynamic Random Access Memory DRAM such as but not limited to SDRAM or RDRAM. Firmware may hold instructions and data including but not limited to a boot up sequence pre defined routines memory management routines and other code. In some embodiments code and data in firmware may be copied to memory prior to being acted upon by CPU . Routines in firmware may include code to translate page descriptions received from computing device to display lists and image bands. In some embodiments firmware may include routines to rasterize display lists to an appropriate pixmap and store the pixmap in memory . Firmware may also include compression routines and memory management routines. In some embodiments data and instructions in firmware may be upgradeable.

In some embodiments CPU may act upon instructions and data and provide control and data to ASICs FPGAs and print engine to generate printed documents. In some embodiments ASICs FPGAs may also provide control and data to print engine . FPGAs ASICs may also implement one or more of translation compression and rasterization algorithms. In some embodiments computing device can transform document data into a first printable data. Then the first printable data can be sent to printer for transformation into intermediate printable data. Printer may transform intermediate printable data into a final form of printable data and print according to this final form which may take the form of a pixmap. In some embodiments the first printable data may correspond to a PDL description of a document. In some embodiments the translation process from a PDL description of a document to the final printable data comprising of a series of lower level printer specific commands may include the generation of intermediate printable data comprising of display lists of objects.

In some embodiments display lists may hold one or more of text graphics and image data objects. In some embodiments objects in display lists may correspond to similar objects in a user document. In some embodiments display lists may aid in the generation of intermediate or final printable data. In some embodiments display lists and or pixmaps may be stored in memory or secondary storage . Exemplary secondary storage may be an internal or external hard disk memory stick or any other memory storage device capable of being used in printer . In some embodiments the display list may reside on one or more of printer computing device and server . Memory to store display lists and or pixmaps may include dedicated memory or may form part of general purpose memory or some combination thereof according to some embodiments. In some embodiments memory may be dynamically allocated to hold display lists and or pixmaps as needed. In some embodiments memory allocated to store display lists and or pixmaps may be dynamically released after processing.

As shown in language server engine server and raster server may communicate with each other. In addition language server engine server and raster server may invoke routines and communicate with RDL library . The system may also include frame buffer management library which communicates with pixmap code and with raster server and engine server through memory management API .

Memory manager allocates and manages memory. Routines in memory manager may be accessed using memory management API . Thus details of memory management code can be abstracted away from program code used to manage and or manipulate the display list or frame buffer. Similarly in some embodiments pixmap code may allow the use and manipulation of pixmaps as a single logical entity while permitting pixmaps to extend over one or more discontiguous memory blocks. This abstraction can be achieved using frame buffer management library to manage block and pointer allocation and deallocation for pixmaps state information pertaining to pixmaps and to track processes utilizing pixmaps. In some embodiments pixmap code may enable access to memory blocks for pixmaps. Each memory block is a chunk of contiguous memory. Memory blocks may contain one or more scanlines. A scanline is one row of pixels in the image.

In some embodiments frame buffer management library may allocate memory in blocks. In one embodiment the blocks may be of equal size. In another embodiment memory may be allocated either as a block or as an integral multiple of blocks called a super block. A super block is a set of contiguous blocks. For example frame buffer management library may allocate memory in blocks and super blocks where a super block may comprise four blocks. Super blocks may be useful to hold larger pixmaps and also facilitate support for different paper sizes resolutions and orientations.

In some embodiments use of functionality provided by memory manager may occur through a memory management application API . For example frame buffer management library may use memory manager to obtain blocks and pointers using interfaces specified in the memory management API . Memory manager defines the functions of the memory management API . In some embodiments code pertaining to display lists and the frame buffer such as code in frame buffer management library interface with memory manager through memory management API . Accordingly in these embodiments the memory manager can be replaced or easily modified by a product specific memory manager without changing program code used to manage and or manipulate the display list or frame buffer.

In some embodiments the display list may include commands defining data objects and their contexts within a document or a page within the document to be printed. These display commands may include data comprising characters or text line drawings or vectors and images or raster data.

In some embodiments the display list may be dynamically reconfigurable and is termed a Reconfigurable Display List RDL . In one embodiment an RDL may be implemented using a data structure that allows certain display list objects to be stored in a manner that allows their manipulation dynamically. For example image objects may be compressed in place to increase the amount of available memory and decompressed when referenced and or used. In some embodiments an RDL may also permit RDL objects to be stored in memory and or secondary storage by holding pointers offsets or addresses to the actual locations of RDL objects which can then be retrieved when referenced and or used. In general the RDL allows display list objects to be flexibly stored and manipulated based on system constraints and parameters.

In one embodiment the translation of a PDL description of a document into a display list and or RDL representation may be performed by language server using routines in RDL library and memory manager . For example language server may take PDL language primitives and transform these into data and graphical objects and add these to the reconfigurable display list using the capability provided by functions in RDL library and memory manager . In one embodiment the display list may be stored and manipulated in a dynamically allocated memory pool such as exemplary memory pool which may be part of memory .

In some embodiments creation of the RDL may be an intermediate step in the processing of data prior to actual printing. The RDL may be parsed before conversion into a subsequent form. In some embodiments the subsequent form may be a final representation and the conversion process may be referred to as rasterizing the data. For example rasterization may be performed by raster server using routines in frame buffer management library and pixmap code . Upon rasterization the rasterized data may be stored in frame buffer which may be part of memory pool using routines in memory manager which may be accessed through memory management API . In one embodiment the rasterized data may take the form of a bitmap or pixmap that specifies the marks to be made on a printed page.

In one embodiment routines in memory manager may manage some subset of available memory in memory as memory pool and allocate memory from memory pool to requesting processes through memory management API . When memory is no longer needed by the requesting processes the memory may be de allocated and returned to memory pool where it can be made available to other processes. Thus exemplary memory manager may also provide various other memory management functions including routines to free memory routines to recover memory and swapping routines that can swap memory to secondary storage .

In some embodiments frame buffer may also be a part of memory pool and may be managed by memory manager . For example calls to functions in frame buffer management library may result in calls to functions in memory management API . Memory management API may then invoke one or more functions in memory manager . Results of the actions taken by memory manager may be routed back to the calling process. In one embodiment frame buffer may be allocated an initial contiguous block of memory and subsequent memory blocks may be allocated to frame buffer when requested. Memory blocks may also be allocated for other non frame buffer purposes from memory pool . In some embodiments distinct memory blocks assigned to the frame buffer or to other processes may occupy non contiguous memory locations in memory .

Print engine may process the rasterized data in frame buffer and form a printable image of the page on a print medium such as paper using routines in frame buffer library . In some embodiments raster server and engine server may also use routines in RDL library and pixmap code to perform their functions. For example routines in pixmap code may provide raster server with access to pixmap routines to support rasterization. In one embodiment routines in pixmap code may permit a final pixmap comprising one or more color plane components and an alpha plane component to be utilized by print engine through engine server .

In some embodiments engine server may provide control information instructions and data to print engine . In some embodiments engine server may invoke routines that lead to freeing memory used by framebuffer objects after processing for return to memory pool using functionality provided by memory manager through pixmap code frame buffer library and memory management API . Routines in pixmap code may provide engine server with access to scanlines for a pixmap. In some embodiments portions of memory pool and or frame buffer may reside in memory or secondary storage .

In some embodiments routines for language server raster server and engine server may be provided in firmware or may be implemented using ASICs FPGAs .

When memory is requested for use by frame buffer such as for storing a pixmap a block or super block may be allocated. When memory is requested for an RDL or for temporary storage and processing purposes a block may be allocated. As shown in pixmaps A B and C are dispersed among discontiguous memory blocks scattered throughout memory . In some embodiments memory defragmentation routines may be employed periodically or when available memory is below some threshold or as a strategy to free memory in order to create new super blocks from disparate scattered blocks in memory pool . For example objects in memory may be rearranged and disparate scattered blocks combined to create larger contiguous memory sections.

In some embodiments defragmentation may also be eliminated through the use of super blocks. Accordingly a super block can be allocated when a block is requested. Because only a single block has been requested one or more blocks in the super block may be unused. When additional blocks are requested then any unused blocks from the previously allocated super block can be provided to the requester until none remain at which time another super block can allocated. For example as shown in pixmap D is contained within super block .

In some embodiments the breaking up of framebuffer into discontiguous blocks permits the efficient use of memory. For example when a single scanline is accessed blocks in the pixmap that do not contain the scanline of interest can be subjected to memory conservation or recovery schemes to increase the amount of available memory. For example memory blocks may be swapped to disk or compressed to increase the availability of memory.

Pixmap object may also include block list which can hold information pertaining to blocks or super blocks corresponding to a given pixmap. Exemplary block list may comprise one or more block handles shown as block handle  through block handle n. In some embodiments each block handle may provide access to one or more scanlines in block or super block . Block list may also include data fields that hold pointers to blocks in the list. For example a data structure associated with each block may hold pointers to the immediately succeeding and or preceding block. In some embodiments block list may also be implemented as a dynamic array which can be resized and also allows elements to be added or removed.

In some embodiments the number of scanlines held by block or super block may be determined by the size of the allocated unit and other system parameters. For example each block corresponding to a pixmap may comprise N scanlines. However the last block for the pixmap may hold less than N scanlines. As shown in each block holds five scanlines. In some embodiments a scanline may be divided further into components including one or more of component planes an alpha component etc. For example a pixel for a color image may comprise Cyan Magenta Yellow and Black CMYK components.

In some embodiments scanlines for a pixmap may be packed together and component planes for pixmap blocks may be interleaved. An interleaved component plane organization is shown in . For a printer with a four cycle print engine the print medium makes four passes across the transfer belt or photosensitive drum . During each pass a component image is transferred and a composite image is obtained after four passes. Accordingly in printers with four cycle print engines an interleaved color plane organization may be beneficial. In the interleaved color plane organization all scanlines for a color component are packed together. For example C color component holds all Cyan scanlines. Similarly M color component Y color component and K color component hold all Magenta Yellow and Black scanlines respectively. When component planes are interleaved scanlines for each component plane may be output sequentially to the transfer belt or photosensitive drum before the print engine proceeds to scanlines for the next color plane. In some embodiments the engines may be offset with respect to each other so that the cycle time can be shortened considerably.

In step the pixmap object may be activated. When pixmap object is activated by a process pixmap object is marked as being used by that process and internal pointers may be refreshed appropriately. Thus an association exists between pixmap object and a process following the activation step. Maintaining an association between pixmap object and a process can be useful in the implementation of memory recovery schemes. For example any memory recovery strategies that are invoked when a process is unable to obtain additional framebuffer memory may be applied to pixmap objects associated with that process.

In some embodiments in step upon receiving the first request for a scanline for pixmap object a pointer to block or super block may be obtained. For example when a scanline for pixmap object is requested and a pointer to the block is not yet available then a pointer to the block can be obtained. The successful obtaining of a pointer to block guarantees that block is physically present in memory .

In step pixmap object may be deactivated. For example pixmap object may be deactivated when a process has completed operations involving pixmap object . Deactivation frees pointers associated with blocks or super blocks . After deactivation blocks or super blocks comprising pixmap object may be swapped to secondary storage . In some embodiments pointers to blocks or super blocks may persist until pixmap object is deactivated.

In some embodiments when a requesting process is unable to obtain additional framebuffer memory or a pointer to a block memory recovery strategies may be invoked. Memory recovery strategies may include waiting for other processes to release memory. If the wait times out then additional memory recovery strategies may be invoked. For example pointers to unused blocks in any pixmap objects activated by the requesting process may be freed. Freeing the pointer allows memory manager to swap out these blocks to secondary storage thereby freeing memory for the requesting process.

In step it may be determined if pixmap object will be used subsequently in additional operations. If pixmap object is not being used for any further operations then it may be destroyed in step . Otherwise the pixmap may remain deactivated in secondary storage until it is activated. Accordingly the process iterates through steps until utilization of pixmap object has finished. Pixmap object may then be destroyed in step . Destruction of pixmap object permits blocks and or super blocks associated with pixmap object to be returned to the memory pool. In some embodiments deactivation step may be performed in conjunction with the destruction of pixmap object in step .

Other implementations will be apparent to those skilled in the art from consideration of the specification and practice of disclosed embodiments. It is intended that the specification and examples be considered as exemplary only with its true scope and spirit being indicated by the following claims.

