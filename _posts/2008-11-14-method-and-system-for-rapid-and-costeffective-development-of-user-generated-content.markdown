---

title: Method and system for rapid and cost-effective development of user generated content
abstract: An express content metadata system (“ECM”) may provide functionality for uploading, querying and downloading game content without heavy coding requirements on the part of the developers. The ECM may provide fast indexing, searching and data retrieval of content. The ECM may manage evolving changes to content definitions by providing flexible and efficient versioning control over content definitions that allows multiple versions of game content to coexist and be independently searchable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08356059&OS=08356059&RS=08356059
owner: Microsoft Corporation
number: 08356059
owner_city: Redmond
owner_country: US
publication_date: 20081114
---
Entertainment and video game software applications have evolved in ways unforeseen by early pioneers in the field. While early video games typically provided static content including graphics and sound modern video games may be dynamically configured to include new content only limited by the abilities of game and content developers. In addition new content may be generated not only by professional game developers but also game enthusiasts who wish to share their content with other gamers. This provides a very rich creative environment for game development.

Thus when a user purchases a game the user typically relies on the assumption that new content will become available over time for a title. This scenario is mutually beneficial for the user and the game developers. For the user it insures that the lifetime of the game will be virtually unlimited as new content will become available over time. For game developers a single title provides a sustained revenue stream if users are willing to pay for new content created for the title. Thus the ability to provide dynamic content over time to users makes users more willing to buy and thus developers more invested in developing complex and often expensive titles.

Nonetheless dynamic content availability creates a number of technical challenges from a development and information technology perspective. As content may be created dynamically a game is always under development multiple schema versions of content may coexist at a single point in time. Typically a content server is configured to allow a game development team to upload modify and download game content during the development phase.

This scenario raises a number of challenges for efficient game development. With known methods game development of a new content element or feature may be very slow and require the developer to generate significant amounts of code unrelated to the substantive game feature they are developing. In addition traditional methods do not allow for schema versioning. Thus an alternative method is required.

An express content metadata system ECM may provide developers functionality for uploading querying and downloading game content without heavy coding requirements on the part of the developers. The ECM may provide fast indexing searching and data retrieval of content. The ECM may manage evolving changes to content definitions by providing flexible and efficient versioning control over content definitions that allows multiple versions of game content to coexist and be independently searchable.

According to one embodiment a rapid design paradigm for iteration and deployment of new content is described. The process commences with a developer conceiving a new feature or content element for a game. The developer may then generate an XML Extensible Markup Language schema pertaining to that feature describing a model for the content element which serves as metadata for the content element. The developer may then upload the content schema which is validated. Upon validation a code generation process may generate Wrapper APIs with friendly API methods to invoke various methods relating to the content element. The developer may then download the generated wrapper source code integrate the wrapper code and libraries into their game source code and finally build and run their game to test out the features.

In order to search for digital content element user may provide a search query to search engine via search engine interface which may be a Web interface. Search engine may perform a search against the entirety of content metadata in datastore to retrieve all content items satisfying the search query. The user may then be presented with options for performing interactions with the retrieved content items such as downloading updating etc.

Development devices may utilize any type of communication protocol in order to communicate with ECM via network . Development devices and ECM may be coupled to network and may utilize any type of communications protocol and transport protocol for the transmission and exchange of information. For example in the case where network is the Internet development devices and ECM may communicate using the TCP IP protocols. As described below ECM may provide a Web server and thus development devices may communicate with ECM via HTTP Hypertext Transport Protocol .

ECM may comprise ORM Object Relational Mapping layer web application layer administrator page web server CodeGen layer validation server and RDBMS Relational Database Management System .

RDBMS stores data relating to generated content using a relational model. According to one embodiment RDBMS stores data utilizing a plurality of tables comprising database schema such that data may be stored in a normalized fashion. According to one embodiment the schema defined for RDBMS is static i.e. fixed.

Although RDBMS schema may be fixed users of ECM typically require defining and interacting with objects in a dynamic and flexible manner. ORM layer provides a mapping between objects exposed to users and data stored in RDBMS which are scalar values. According to one embodiment ORM layer defines an individual content metadata unit referred to herein as a SearchableItem. ORM layer further comprises a schema component The structure of ORM layer and the content metadata unit SearchableItem will be described in detail below.

Web application layer provides various methods for interacting with ECM. According to one exemplary embodiment web application layer provides a create method that allows a client to upload digital content along with its metadata in a single call and create a metadata object referred to herein as a SearchableItem Object and described below an update method that enables a client to modify an existing record when its data changes on the client a search method that enables a client to query the ECM for content based on specific search criteria and a get method that retrieves all metadata for a single content item.

CodeGen layer receives a content schema definition not shown in which among other things defines comprises a well defined a structured definition of a title s content along with query definitions on how to update and or search for that content as well as what data is relevant to be returned with each query. The CodeGen layer may analyze the content schema definition and generate custom data structures based upon the names and data types for that definition. According to one embodiment CodeGen layer may analyze customer queries and create local in title APIs mapped and named after customer defined query names that wrap actual calls to lower level web methods that may not be as user friendly. This allows a game developer to write a schema that results in friendly looking APIs that map directly to in game data and only that data. For example a user might be able to write an API entitled CreateCar as opposed to calling a more cumbersome and generic API where many arguments will not apply to their specific needs. According to one embodiment as described in more detail below a more generic API that may ultimately be called.

Administrator page may provide an interface for users to interact with ECM . According to one embodiment administrator page may be a HTML Hypertext Markup Language page served by web server upon request of a specific URL Uniform Resource Locator . Thus users may interact with ECM via a web browser not shown in which display administrator page upon request of a specific URL associated with ECM . Administrator page may allow a development team to configure a particular content server configuration based upon content they are developing.

Among other functionality administrator page may allow users to upload a content schema definition described in detail below which may be a schema written in an XML format that defines content and how search for the content based upon particular object definitions. Upon receipt of a content schema definition the administrator page may call CodeGen layer which may then generate header .h and body .cpp files that may wrap calls to an underlying API.

According to one embodiment administrator page may parse content schema and configure various tables in RDBMS that control how content schema maps to a fixed schema in RDBMS .

Upon validation of content schema the content schema may be registered and stored in RDBMS . RDBMS may store mutltiple versions of a schema for versioning purposes. Thus as shown in for example RDBMS may store schema schema and schema all pertaining to different versions of a content element. Administrator page may then call CodeGen layer using the validated content schema to generate wrapper code based upon content schema . The structure and functions of CodeGen layer in generating wrapper code based upon a content schema is described in detail below.

In addition upon uploading content schema administrator page may populate schema tables based upon received content schema. Schema tables described in more detail below store information regarding information defined in content schema such as the fields updates and queries. The structure of an exemplary content schema as well as schema tables is described in detail below. Content tables may store actual content element data according to one embodiment.

The dashed arrows in illustrate processes occurring due to user invoking a method in friendly API . As noted previously friendly API may have been generated automatically by CodeGen layer . Upon invocation of a method in friendly API a name resolution process is performed the name resolution process is described below . The name resolution process maps from a method name in friendly API to corresponding information stored in schema tables . That is the call to a friendly API may map to various rows in schema tables Schema ORM . This mapping is transparent to user .

The method invocation via friendly API may be made via web application layer . As noted previously web application layer may support methods create get update and search methods described in detail below . Friendly API calls on the client may be mapped to a fixed API call such as XTS ContentServerSearchableContent still on the client which in turn use may invoke a web method in application layer that knows how to map that data to a SearchableContent object on the server. The structure of a SearchableContent object is described in detail below. Calls to the web application layer result in a SearchableContent object that may invoke ORM layer which negotiates between SearchableItem Object and underlying metadata stored in RDBMS in metadata tables.

Updates block describes types of targeted updates users may make to existing model records already existing in schema tables of RDBMS . Queries block describes types of search queries users may perform against the models. According to one embodiment content schema is an XML file. As previously discussed administrator page allows for the uploading of a content schema .

This exemplary content schema comprises a model for a content element called Car with metadata fields Color Price DriverXuid Make Model Thumbnail Logo and Sound . These fields are respectively int int ulong string string blob and blob types.

As shown in ORM module negotiates between SearchableItem object and metadata tables . Typically users will interact with object such as SearchableItem directly. However the data comprising a SearchableItem object is persisted in metadata tables which may comprise a portion of a relational database. ORM module performs functions for negotiating between an object representation such as SearchableItem and an underlying relational database representation such as metadata tables . It should be understood that ORM layer may be implemented utilizing any programming language or representation.

The structure and function of the class hierarchy shown in is now described. PersistedBase class comprises logic to bind a parent object to a database table named after that object. According to one embodiment a custom installer creates tables when binaries built with PersistedBase objects are installed. The installer may utilize managed code reflection capability to examine all objects in the binaries to build the SQL tables with foreign key relationships along with columns named after member data in the corresponding object definition.

According to one embodiment base class Item defines all data common to content stored on ECM such as created data creator XUID payload size popularity and average rating . According to one embodiment item utilizes the following definition 

These definitions provide a separate sub table in RDBMS that allow each item to store a series of ratings based on a customer ID key 

This item object allows for uploading and downloading of a payload stored in a payload table and further allowing updates of customers opinion of that payload via its rating attribute. The payload table stores the actual data corresponding to a content element.

SearchableItem may store metadata type fields which are used to describe a title s content in detail and allows content objects to be queried in specific and varied ways. According to one embodiment SearchableItem may store only a fixed number of five primitive types ints floats ulongs DateTime values and strings. Of course SearchableItem may store any number of primitive types and the five specific types noted are merely exemplary. SearchableItem may also store a number of references into a SearchableitemBlob table that may store non searchable blob data. Non searchable blob data may include content preview information such as thumbnails sounds or any other sort of custom data structure data stream or proprietary content.

Item table is also associated with SearchableItem table because SearchableItem object inherits from Item object . According to one embodiment SearchableItem table is associated with SearchableItem.Tags table that stores primitive string types SearchableItem.DateTimes table that stores primitive date time types SearchableItem.Ulongs table that stores primitive Ulong types SearchableItems.Ints table that stores primitive integer values SearchableItem.Floats table that stores primitive floating point types and SearchableItem.Blob table that stores blobs or references to blobs.

Item table comprises a private key Id FlagCount field IsPayloadRequired field IsPayloadUploaded field PayloadSize field QualityFlag field ReviewedState filed SubmissionTime field and SubmittedXuid field. Payload field comprises private key Id Date field ExpectedSize field and UploadedSize field. ItemRatings table comprises private key Id private key Id Ratings Key field and Value field.

SearchableItem table comprises a private key Id and Modeld field. SearchableItem.Ulongs table comprises private key Id private key Id Ulongs Key field and Value field. SearchableItem.Ints table comprises private key Id private key Id Ints Key field and Value field. SearchableItem.Tags field comprises private key Id field private key Id Tags field Key field and Value field. SearchableItem.DateTimes table comprises private key Id private Id DateTimes Key field and Value field. SearchableItem.Floats table comprises private key Id private key Id Floats Key field and Value field. SearchableItem.Bloblds table comprises private key Id private key Id Bloblds Key field and Value field. SearchableItem.Blob table comprises private key Id and Blob field.

According to one embodiment the five tables SearchableItem.Ints SearchableItem.Ulongs SearchableItem.Tags SearchableItem.DateTimes SearchableItem.Floats are used in a star join pattern to create metadata for arbitrary content types as described below.

For example a user might define their SearchableItem s metadata to have 2 integers no floats 3 bigints 1 string and 2 DateTime values and no blobs for example. In that event a single record when created would contain 2 rows in the integer table 0 rows in the float table 3 rows in the bigint table 1 row in the string table and 2 rows in the DateTime table. This type of content has a variable amount of data spread out among 4 tables. Another SearchableItem defined by a user might contain 1 float and a single preview blob. In that event even though the system has 6 tables available for use that type of SearchableItem when created only uses 2 tables a single entry in the float table and a single blob entry in the blob table per SearchableItem record.

According to one embodiment RDBMS utilizes a star join table design pattern for storing SearchableItem data . The star join pattern distributes a definition of a customer content type or model among a fixed number of thin name value pair tables based on a primitive type each with exactly one index. depicts the use of a star join pattern. An arbitrary complex table may be built by repeated multiple joins of a set of primitive data types . For example if a piece of searchable content contained 5 integers those 5 integer values could be stored in the same table as 5 separate rows but with each having the same owner id that maps back to an ORM object that unifies those rows as a single record.

An advantage of the star join arrangement is that each record doesn t use tables or consume storage space that is not required. In addition the star join provides a predictably efficient indexing model because each primitive table has exactly one index and every metadata property receives the same priority index. This fact should allow a database server to maximize cache efficiency and maximize indexing efficiency which should translate into very consistent query performance over time.

Generated Wrapper APIs also comprise logic for resolving calls to friendly APIs to actual underlying API calls for example in XTS ContentServer as shown in . In order to facilitate this functionality upon uploading of content schema via administrator page schema tables are populated based upon the received model definitions. According to one embodiment the following schema tables may be defined 

Populating schema tables based upon a received content schema allows any calls friendly APIs to create search get and update methods to be resolved. For example if a user were to upload a schema that includes a search query a new row is automatically generated in the schema query table defining details for that query row such as a query name schema version corresponding model ID for content etc. The row ID for the query information stored in the query table in RDBMS then becomes a query ID which may be returned in generated wrapper code as described in detail above.

As noted a user may be provided access to the query stored in query table via a friendly API achieved via the automatic generation of Wrapper API rather than having to know the more cumbersome query ID or row ID for the query the user desires. For example assuming the row ID were for example the generated Wrapper API provides logic for mapping the from the API call to a query ID corresponding to row . This allows the query ID corresponding to row be sent to static web methods in web application layer based upon the wrapper and schema version automatically when a user makes the call the friendly API so that information on the query can be validated the query created using query arguments that are also provided to the static web methods and executed against schema tables RDBMS .

Thus a developer may be afforded the opportunity to use a friendly looking API that is generated called SearchForCars and the body code inside that call provides a mapping between for the SearchForCars API call and a particular schema version to a particular query ID .

The following code segment shows how the schema shown above is processed by CodeGen layer to generate wrapper code containing a Create and Update API as follows 

A content schema may comprise one or more models which may further comprise one or more updates blocks . According to one embodiment regardless of whether a user specifies any blocks for any given model an UpdateAll update all method is created which is used to update an entire record.

Each model may also comprise one or more queries blocks . However query blocks are not required in a model depending upon the developer needs. A queries block defines how a user intends to do searches against the content metadata. Queries will translate to client side Search APIs that the developer can call to execute those queries on the server.

For each query in the schema all related developer defined details about it are stored in schema tables along with a schema version id and a QueryId. When called the search web API method described below constructs a dynamical SQL command from this stored information in schema tables along with the arguments sent from the game such as search filter values and sort order values. Once validated and constructed it executes the dynamic SQL command against the database it generates C arrays containing the data from each row in the result set back to the client wrapper . The client wrapper which was generated by CodeGen layer pieces back all of those array values into an array of client side data structures and then hands back that array to the caller in an asynchronous manner.

From the game developers point of view they call a easy to understand method like SearchForCars and eventually get back an array of client side data structures that contain all of the information they asked for in the query schema for that query. All of the details on how that call connects to the game servers transmits the data validates the query and arguments builds the query executes the query returns the data and reconstructs the data is all abstracted from the game developer.

According to one embodiment a query comprises 3 sections and . The section determines what fields gets returned by this query. This can be a subset of the fields in the primary model or all fields specified by a wildcard i.e. name . The section describes how to filter the data. And the section describes how to sort the data. The following portion of a content schema illustrates a structure of a queries block .

A user can specify the fields from the model to be returned in a query as in the above query example SearchForCarByColor or they can specify to return all fields by specifying a wild card character like the SearchAll query does in the XML schema sample above.

For example the portion in the above example asks for all rows where Color equals a value specified in the generate wrapper API. The above query would generate a client data structure called the wrapper struct and a Search API as follows 

As shown in the above example a ColorEqual argument was generated according to both its name Color and its operator eq or Equal . The game developer could then call this method by passing in some value for ColorEqual and then setting the filterMask equal to an enum value which may also be generated for the developer that indicates to the search web method method that the query must consider the ColorEqual argument when it constructs its dynamic SQL command on the server. According to one embodiment a 0 value may be passed for the filterMask to this API and regardless if the ColorEqual argument is specified or not it will not be considered by the dynamic SQL on the server which will return a different query result. In this way the same API can represent many different queries simply by toggling different bit masks in the filterMask. This simplifies coding required for a developer 

According to one embodiment operators for each where clause may be specified contains like. The content schema may specify a number of expected arguments which will translate to how many inputs in the generated Search API.

In this case the query argument is never supplied in the generated API as it is always assumed to be this exact value.

According to one embodiment a query may specify multiple query filers. This translates into operators on the server e.g. color 1 AND price 25000.

According to one embodiment a user may specify up to 3 fields to sort the result with in priority order . The sort fields can be either a user defined field from their model schema or a base content field SubmitterXuid SubmissionTime DownloadCount AverageRating . In the above code schema example the result will be sorted by Price ascending and then by Make descending.

According to one embodiment when a user uploads a content schema the XML is parsed and any errors reported. If there are no errors the schema is stored in schema tables and associated with a schema version number. The generated APIs in the generated .h and .cpp files will have the appropriate schema version ids passed on automatically. The schema version ID may be used to segregate multiple clients on multiple versions in the same database.

According to one embodiment search results are returned as primitive type arrays rather than arrays of structures. For example according to one embodiment search results are returned as 

Thus according to this embodiment every primitive type is returned in an array of its own type as opposed to returning a single of array of structures. This allows only desired data members of the struct to be returned allowing significant bandwidth savings.

Search method enables a user of ECM to query ECM for content based on specific search criteria and obtain an array of metadata records that match criteria in a single asynchronous download. According to one embodiment each metadata record has a unique id that can be used to subsequently retrieve a payload via another asynchronous web method via a DownloadPayload web method. Get method retrieves all the metadata not in the payload for a single content item that was initially created using the create method .

According to one embodiment a get method receives several primitive type arrays along with 3 optional preview blob byte arrays that any user can use to create an almost limitless number of searchable content types for a game.

According to one embodiment create method receives a modelId parameter that always must reference a model for the game that was created in the schema model table for that game during the content schema upload stage on the game s administrator page . The generated wrapper code will always send the correct modelId on behalf of the caller. The caller can therefore call their own wrapper methods like XLS CreateCar and their modelId and metadata arguments will be preprocessed and transmitted correctly on the caller s behalf.

According to one embodiment search API method allows a user to provide complex questions about the data queries as well as provide flexible instructions on what data should be returned to the client. A which fields should this query return question is consolidated with a single argument the queryId . During the content schema upload blocks tags tags and tags are created in rows in the schema tables for each query. In particular according to one embodiment all of the information for each query is added to the Schema.Query Schema.Query.Parameters Schema.Query.SelectFields Schema.Query.SortList Schema.Query.Parameter and Schema.Query.Sort tables.

Each query may be assigned a queryId based on its primary key in the Schema.Query table and that query id is returned to the user in their generated wrapper code. The wrapper code need only transmit a single argument the query id that the server can use to look up what fields it should return for that query.

According to one embodiment an update method call may be utilized to modify an existing object by updating any number of predetermined fields for its contented and or one of the blobs that it contains in the SearchableItemBlob table for that object.

A user may invoke the update method using a generated friendly API call such UpdateCarColor which ultimately will call update method supplying it the content id of the car to update the field id of the Color field which among other things knows what data type the field is for that id which in turn knows which array to get the updated value from in this case the rgInts array since the type of the Color field is int .

According to one embodiment the get method call accepts a content id to retrieve and then return all of the metadata for that content item in the returned primitive type for example in an array.

According to one embodiment each content schema uploaded is compared with a previous schema upload. All generated headers always contain a schema version stamp automatically. If any changes are detected then the header file generated will reflect an increment in this schema version value. The schema versioning may be transparent to the user. According to one embodiment the code that is generated for a title that wraps underlying web methods always send up the correct ids for each web method on behalf of the title. In this way different versions of the title s schema in different builds can still work while acting on the same database. This feature allows rapid iteration over a feature or group of features for user generated content because it doesn t slow an existing development or test effort down while changes to past schemas are made and tested. According to one embodiments a Schema ID is provided in generated source code. According to alternative embodiments the Schema ID is not required as the ids for model query parameter update etc. are unique in and amongst themselves to perform name resolution.

The example embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the example embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers embedded systems distributed computing environments that include any of the above systems or devices and the like.

The example embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The example embodiments also may be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules and other data may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the example embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to processing unit . Processing unit may represent multiple logical processing units such as those supported on a multi threaded processor. System bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus . System bus may also be implemented as a point to point connection switching fabric or the like among the communicating devices.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

System memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

Computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. Hard disk drive is typically connected to system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

Computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . Remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment computer is connected to LAN through a network interface or adapter . When used in a WAN networking environment computer typically includes a modem or other means for establishing communications over WAN such as the Internet. Modem which may be internal or external may be connected to system bus via user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Computing environment typically includes at least some form of computer readable media. Computer readable media can be any available media that can be accessed by computing environment . By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computing environment . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

Although the subject matter has been described in language specific to the structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features or acts described above are disclosed as example forms of implementing the claims.

The inventive subject matter is described with specificity to meet statutory requirements. However the description itself is not intended to limit the scope of this patent. Rather it is contemplated that the claimed subject matter might also be embodied in other ways to include different steps or combinations of steps similar to the ones described in this document in conjunction with other present or future technologies.

