---

title: Interceptor framework using java dynamic proxies
abstract: Disclosed herein is a method and system for isolating business logic from system operations by attaching and organizing a set of java interceptor components, using XML configuration and java dynamic proxy functionality, around an existing standard software java business component. The interceptor components are configured by pre-configuring a set of interceptor classes in an XML configuration file. An interceptor framework is provided which configures, initializes and maintains the interceptor classes. A proxy of the business component is created and returned to a calling client program. The interceptor framework parses the XML configuration file for initializing all the interceptor classes. An interceptor chain is created associated with the business component, when the client program invokes the methods on the proxy business component. Each interceptor acts as a proxy to a previous interceptor in the interceptor chain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07984456&OS=07984456&RS=07984456
owner: Ketera Technologies Inc.
number: 07984456
owner_city: Santa Clara
owner_country: US
publication_date: 20080222
---
This invention in general relates to proxy interceptor components and specifically relates to arranging java interceptor components in a plug and play mode using extensible markup language XML configuration and Java dynamic proxies over an existing java business component such that the underlying business logic is separated from the system operations.

Business components are primarily written for addressing business functionalities. The software business components encapsulate the business logic. These business components are deployed in a Java server environment that provides system functionalities like transaction management security management etc. For example an enterprise java bean EJB component is deployed in an application server environment that provides the system functionalities. The business components i.e. the EJB components encapsulating the business logic depend on the application server s system functionalities to complete business objectives. The business components depend on the application server s transaction service to manage its transactions and the application server s security services to provide security. The naming service of the application server may expose the business component in which case the business component may be accessed as remote components by external systems.

In order to avoid exposing underlying business logic or other data layers a business component needs to be made independent of the server environment in which the business component is deployed. The system functionalities and environment functionalities need to be outside the scope of a business component. Furthermore it is desirable if the components that provide the system functionalities could be organized i.e. added and or removed around an existing business component in a plug and play mode.

Existing methods employ interceptors to intercept communication between a client program and the business components. However the need to organize the interceptor components and separate the business logic from the system functionalities is unaddressed.

In view of the foregoing discussion there is an unaddressed need for separating business logic from system functionalities in an environment and minimizing the dependence of these business components on the system functionalities.

Disclosed herein is a method and system that addresses the above mentioned needs for isolating business logic from system operations by attaching and organizing interceptor components around a business component. The interceptor components are configured by pre configuring a set of interceptor classes in a configuration file. An interceptor framework is provided that configures initializes and maintains the interceptor classes. A proxy of the business component is created and returned to a calling client program. The interceptor framework parses the configuration file for initializing all the interceptor classes. An interceptor chain associated with the business component is created using java dynamic proxies based on the number of interceptors initialized in the interceptor framework. Each interceptor acts as a proxy to a previous interceptor in the interceptor chain.

The interceptor framework enables the organization of dynamic proxy interceptors over a business component that is deployed in a java virtual machine JVM or any other virtual machine that supports generation of dynamic proxies. The interceptor classes are configured in a predefined file that is sent as an input to the framework. The framework reads the predefined file and initializes all the interceptor classes and creates an interception chain around the business component. The technique of creating an interception chain without modifying the business component is the highlight of the invention. The approach is to isolate the common system functionalities from the business functionalities.

Java dynamic proxies provide a means to create wrapper classes on the fly wherein the wrapper classes act as interceptors over a business component. The proxy wrappers isolate the business logic from the system operations they perform such as maintaining transaction integrity authentication performance matrix calculation etc.

The interceptor components are arranged and may be configured to operate in a plug and play mode. Depending on the system requirements an interceptor component providing the desired system functionality may be added on or removed from an existing business component. The order of the interception in a list of interceptors may be changed without changing the business component. A client program need not be aware of the interceptors and may directly call the interface methods published by the business component. When the client program executes any of the exposed methods on the interface published by the business component the framework dynamically initializes the interceptors around the business components.

The interceptor framework is a Java software framework. This Java framework initializes the individual interceptor components and creates a chain of interceptors based on the configuration in the configuration file. Generated interceptor components are interposed between the client program and the business component such that the client program is unaware of the separation of the business logic and the system functionalities in the business component.

An interceptor chain associated with the business component is created using java dynamic proxies based on the number of interceptor components initialized in the interceptor framework . Each interceptor component acts as a proxy to a previous interceptor component in the interceptor chain. The interceptor components are interposed between a client program and the business component . The interceptor components perform various system functionalities without any dependence on the business logic of the business component . The business component is thus rendered independent of the system functionalities. The system functionalities include security services transactional services remote services Java naming and directory interface JNDI services etc. The proxy interceptors isolate the business component from the system operations such as maintaining transaction integrity authentication and performance matrix calculation etc.

Using the interceptor framework a set of java interceptor classes is automatically initialized over a business component in a plug and play mode. An interceptor component may be introduced removed and or replaced over a business component . The order of the intercept calls may be changed by configuring the changes in the standard XML document referred to as the XML configuration file . The interceptor framework may configure initialize and maintain the wrapper interceptor classes in a plug and play environment. The client programs that access the business components are rendered unaware of the interceptors and when the client program executes any of the exposed methods on the interface published by the business component the framework delegates method calls to the interceptors pre configured in the XML configuration file .

The interceptor framework has standard published application programmer interfaces APIs that needs to be implemented by the intended wrapper interceptor classes. The behavior of the interceptor classes are described in the abstract base class com.ketera.invoice.service.proxy.BaseHandler.

The abstract methods in the base class that needs to be implemented by all the interceptor classes that are used in the interceptor framework are given below 

protected abstract void preInvoke Object proxy Method method Object args throws InvoiceBusinessException 

protected abstract void postInvoke Object proxy Method method Object args throws InvoiceBusinessException 

The interceptor framework comprises a configuration factory that is a software component. The configuration factory is used by the interceptor framework to read an XML configuration file that contains the list of interceptors for a business component . The configuration factory initializes each of interceptor components after reading the XML configuration file and creates an interceptor chain. The responsibility of the configuration factory also includes attaching the interceptor chain to a business component .

1. The XML configuration file i.e. PROXY FACTORY CONFIG.XML file may be corrupted. In this case the configuration factory would not be able to read the interceptors and the interceptor chain will not be created.

2. The factory class may not be available in the class path in that case the factory instance would not be created.

3. Individual interceptor classes may not be in the class path in that case the corresponding interceptor would not be initialized.

If no errors are detected the custom factory class name is read from the XML configuration file and the custom factory class is loaded . All the interceptor class names in the XML configuration file are read parsed and loaded in a map. When the client program invokes a business method the classes corresponding to the class names listed in the map are read from the loaded factory class. The first interceptor component is initialized as a proxy by passing the constructor of the business component to the base proxy factory class. A chain of interceptor components is created wherein the constructor parameter of a previous interceptor component is passed to a current interceptor component. As a result the current interceptor acts as a proxy for the previous interceptor components . If all the interceptors are initialized by the interceptor framework according to the needs based on the client program execution the proxy generated that is the final interceptor component in the chain is returned to the client.

The interceptor components are portable and reusable. For example access control check could be written as an interceptor component and the same component could be used across different business functions. The interceptor components may be reconfigured by reconfiguring the entries of the interceptor classes in the XML configuration file . The configuration factory now initializes the reconfigured interceptor component when a client program executes. For example an interceptor component may be removed from a business component without modifying the business component . The removal of the interceptor component is determined by the PROXY FACTORY CONFIG.XML file. If the entry of an interceptor class is removed from the XML configuration file the configuration factory would not initialize the corresponding interceptor.

A utility called schema2beans is software that takes descriptions of XML files in document type definitions DTDs or XML Schemas and generates java beans to automatically deal with the XML. Details of this utility package are available at http schema2beans.netbeans.org docs.html. The schema2beans utility is used by the interceptor framework to read the configuration details specified in the XML configuration file i.e. the proxy factory config.XML file. The bean classes are packaged in the package com.ketera.invoice.service.proxy.config.beans in the interceptor framework . The framework is initialized in the com.ketera.invoice.service.proxy.BaseProxyFactory class.

The method public static Object getInstance Object myobj String factoryClassName throws InvoiceBusinessException in the BaseProxyFactory class implements the logic for initializing the wrapper interceptor adapter classes.

Another example of a system functionality developed using the interceptor framework is an invoice management system . The invoice management system receives invoices as commerce extensible markup language cXML documents from external systems. Several validation checks are performed on the documents before the documents are approved by the system. These validation checks are organized as wrapper classes interceptors. The main business logic is isolated from the validation checks by saving these documents as relational entities in the database. The validation wrappers are organized using the interceptor framework . The proxy functionality of the interceptor components is achieved by passing a constructor as a parameter from the previous interceptor to a subsequent interceptor.

1. XML Configuration file This xml file is used by the interceptor framework to initialize all the client proxy factories and to associate the client proxy factories handlers. The interceptor framework reads from this XML configuration file and initializes the proxy chain and associates the chain with the business component.

2. Base proxy factory The base proxy factory component is the main component in the interceptor framework . The base proxy factory component reads the XML configuration file and initializes the proxy chain for each of the custom proxy factories. All custom proxy factory components extend the base proxy factory component and inherit the base proxy factory s proxy handler initialization function.

3. Base proxy handler This component provides the interface methods that are invoked when a business component is invoked by a client. The base proxy handler has two exposed methods preInvoke that is invoked before the business method is called and postInvoke that is called after the business method invocation is completed.

Step 1 A custom factory class and a set of invocation handlers or listeners or interceptors is defined in the XML configuration file as shown in the example of . In this example invocation handler factory class name element holds the custom factory class name. The fully qualified name of the custom factory is com.ketera.invoice.service.proxy.factory.RemitRecordProxyFactory.

The element invocation handler list holds the list of invocation handlers or listeners or interceptors. The name of the fully qualified class names are defined inside element invocation handler invocation handler class name . In the example of the class names of the handlers are 

The first step of the interceptor framework is to configure the proxy factory class and the handler classes in the XML configuration file as mentioned above.

Step 2 A custom factory component defined in the XML configuration file is created by extending the base proxy factory component. In this custom factory instantiate the business component that is going to be called by the client program. The getInstance method defined in the base proxy factory class is called to initialize the interceptor chain by passing the following parameters 

Business component instance this parameter is used to create the proxy chain and the business component is attached at the end of the chain.

Fully qualified name of the custom factory class name This name will be configured in the XML configuration file . The base factory class would read the invocation handlers configured for the factory and initializes them.

Step 3 The invocation handlers defined in the configuration xml are created. The invocation handlers need to extend the base handler class and implement the abstract methods defined in the abstract methods

 protected abstract void preInvoke Object proxy Method method Object args throws InvoiceBusinessException and

 protected abstract void postInvoke Object proxy Method method Object args throws InvoiceBusinessException .

The preInvoke method is called before the business method of the business component is invoked. The postInvoke method is called after the business method of the business component is invoked.

Step 4 The proxy factory is instantiated from the client program by invoking the getInstance method described in Step 2. The getInstance method would return the business component as proxy to the calling client program. When the client invokes any method in the proxy component the proxy delegates calls to all the interceptors handler before calling the business method.

It will be readily apparent that the various methods and algorithms described herein may be implemented in a computer readable medium e.g. appropriately programmed for general purpose computers and computing devices. Typically a processor for e.g. one or more microprocessors will receive instructions from a memory or like device and execute those instructions thereby performing one or more processes defined by those instructions. Further programs that implement such methods and algorithms may be stored and transmitted using a variety of media for e.g. computer readable media in a number of manners. In one embodiment hard wired circuitry or custom hardware may be used in place of or in combination with software instructions for implementation of the processes of various embodiments. Thus embodiments are not limited to any specific combination of hardware and software. A processor means any one or more microprocessors Central Processing Unit CPU devices computing devices microcontrollers digital signal processors or like devices. The term computer readable medium refers to any medium that participates in providing data for example instructions that may be read by a computer a processor or a like device. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media include for example optical or magnetic disks and other persistent memory volatile media include Dynamic Random Access Memory DRAM which typically constitutes the main memory. Transmission media include coaxial cables copper wire and fiber optics including the wires that comprise a system bus coupled to the processor. Transmission media may include or convey acoustic waves light waves and electromagnetic emissions such as those generated during Radio Frequency RF and Infrared IR data communications. Common forms of computer readable storage media include for example a floppy disk a flexible disk hard disk magnetic tape any other magnetic medium a Compact Disc Read Only Memory CD ROM Digital Versatile Disc DVD any other optical medium punch cards paper tape any other physical medium with patterns of holes a Random Access Memory RAM a Programmable Read Only Memory PROM an Erasable Programmable Read Only Memory EPROM an Electrically Erasable Programmable Read Only Memory EEPROM a flash memory any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read. In general the computer readable programs may be implemented in any programming language. Some examples of languages that can be used include C C C or JAVA. The software programs may be stored on or in one or more mediums as an object code. A computer program product comprising computer executable instructions embodied in a computer readable medium comprises computer parsable codes for the implementation of the processes of various embodiments.

The foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present method and system disclosed herein. While the invention has been described with reference to various embodiments it is understood that the words which have been used herein are words of description and illustration rather than words of limitations. Further although the invention has been described herein with reference to particular means materials and embodiments the invention is not intended to be limited to the particulars disclosed herein rather the invention extends to all functionally equivalent structures methods and uses such as are within the scope of the appended claims. Those skilled in the art having the benefit of the teachings of this specification may effect numerous modifications thereto and changes may be made without departing from the scope and spirit of the invention in its aspects.

