---

title: Systems and methods for optimal memory allocation units
abstract: Methods for determining an optimal memory allocation unit size for a framebuffer in a single memory pool comprising frame buffer memory and display list memory on printing devices are presented. In some embodiments, a method for determining an optimal allocation unit size for memory allocation units allocated from a memory pool in response to a memory allocation request for a pixmap comprises determining the amount of unutilized memory when the pixmap is stored using a plurality of memory allocation unit sizes, wherein the memory allocation unit sizes are an integral multiple of a base memory allocation unit; and selecting a memory allocation unit size from the plurality of memory allocation unit sizes based on criteria related to the amount of unutilized memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08854680&OS=08854680&RS=08854680
owner: Konica Minolta Laboratory U.S.A., Inc.
number: 08854680
owner_city: San Mateo
owner_country: US
publication_date: 20080911
---
The present disclosure pertains to the field of printing and in particular to systems and methods for determining optimal memory allocation units to facilitate memory management in framebuffers.

Document processing software allows users to view edit process store and print documents conveniently. However before a document can be printed pages in the document are often described in a page description language PDL . As used in this document PDL s include languages used to describe pages in a document such as PostScript Adobe PDF HP PCL Microsoft XPS and variants thereof. PDL descriptions provide a high level portrayal of each page in a document and are often translated to a series of lower level printer specific commands when the document is being printed a process termed rasterization. Although the rasterization process may be complex and depend on the features and capabilities offered by a particular printer flexible and portable general purpose rasterization schemes may allow printer performance optimizations based on available memory desired print speed cost and other criteria.

Traditionally memory in printing systems has been organized in two distinct pools comprising display list memory and frame buffer memory. Display list memory typically holds display list objects for rasterization while the frame buffer memory typically holds image data specifying marks to be made on a printed page. A bitmap is a type of memory organization used to store digital images in which each pixel is assigned a single bit i.e. the pixel is either on or off . The term pixmap or pixel map is used to denote a raster image that can exist at a number of bit depths. Because of the separate nature of the two pools display list memory cannot typically be used for frame buffer purposes and vice versa. Therefore print failures can occur due to insufficient memory in one pool even if there is sufficient available memory in the other pool. Moreover the use of separate routines to manage the two distinct pools may make it difficult to modify and maintain the code used to manage memory across a product family because different strategies and optimizations may be used in individual products.

Memory resource optimizations may be important even in situations where the entire memory is treated as a single pool. For example pixmaps in frame buffers have traditionally used variable sized contiguous chunks of memory which leads to memory fragmentation. Fragmentation causes available memory to be scattered in small unusable blocks preventing satisfaction of some memory allocation requests even though the aggregate of the available memory in the small blocks could have satisfied the memory request if the small blocks were contiguous.

Where the memory is shared between the display list and frame buffer memory optimizations become important in ensuring that each pool has adequate available memory during printer operation and that potentially available memory is not lost due to inefficiencies in allocation. At a global level the optimization strategies may ensure that memory is allocated between display list and framebuffer memory to meet printer design goals such as cost and or print speed. In addition localized display list and framebuffer specific optimizations ensure that optimizations available at a lower level are exploited. In inexpensive printers efficient memory resource may allow design functionality to be achieved using relatively lower memory. In high end printers efficient use of memory may allow for greater real time availability of memory for printing applications and lead to performance improvements.

Thus there is a need for systems and methods to manage memory on printers for rasterization including framebuffer memory that would allow an optimal use of memory resources while providing a seamless upgrade path.

Consistent with disclosed embodiments systems and methods for selecting an optimal memory allocation unit size to facilitate frame buffer memory management are presented. In some embodiments a method for determining an optimal size for memory allocation units allocated from a memory pool in response to a memory allocation request for a pixmap wherein the memory pool comprises frame buffer memory and display list memory comprises determining the amount of unutilized memory when the pixmap is stored using a plurality of memory allocation unit sizes wherein the memory allocation unit sizes are an integral multiple of a base memory allocation unit and selecting a memory allocation unit size from the plurality of memory allocation unit sizes based on the amount of unutilized memory.

Embodiments disclosed also relate to methods created stored accessed or modified by processors using computer readable media or computer readable memory.

In accordance with embodiments reflecting various features of disclosed embodiments systems and methods for the automatic storing manipulating and processing of a second or intermediate form of printable data generated from a first printable data are presented. In some embodiments the first printable data may take the form of a PDL description of a document and the intermediate printable data may take the form of a display list of objects generated from the PDL description.

As shown in exemplary system includes computers including a computing device and a server . Further computing device and server may communicate over a connection which may pass through network which in one case could be the Internet. Computing device may be a computer workstation desktop computer laptop computer or any other computing device capable of being used in a networked environment. Server may be a platform capable of connecting to computing device and other devices not shown . Computing device and server may be capable of executing software not shown that allows the printing of documents using printers .

Exemplary printer includes devices that produce physical documents from electronic data including but not limited to laser printers ink jet printers LED printers plotters facsimile machines and digital copiers. In some embodiments printer may also be capable of directly printing documents received from computing device or server over connection . In some embodiments such an arrangement may allow for the direct printing of documents with or without additional processing by computing device or server . In some embodiments documents may contain one or more of text graphics and images. In some embodiments printer may receive PDL descriptions of documents for printing. Note too that document print processing can be distributed. Thus computing device server and or the printer may perform portions of document print processing such as half toning color matching and or other manipulation processes before a document is physically printed by printer .

Computing device also contains removable media drive . Removable media drive may include for example 3.5 inch floppy drives CD ROM drives DVD ROM drives CD RW or DVD RW drives USB flash drives and or any other removable media drives consistent with disclosed embodiments. In some embodiments portions of the software application may reside on removable media and be read and executed by computing device using removable media drive .

Connection couples computing device server and printer and may be implemented as a wired or wireless connection using conventional communication protocols and or data port interfaces. In general connections can be any communication channel that allows transmission of data between the devices. In one embodiment for example the devices may be provided with conventional data ports such as parallel ports serial ports Ethernet USB SCSI FIREWIRE and or coaxial cable ports for transmission of data through the appropriate connection. In some embodiments connection may be a Digital Subscriber Line DSL an Asymmetric Digital Subscriber Line ADSL or a cable connection. The communication links could be wireless links or wired links or any combination consistent with disclosed embodiments that allows communication between the various devices.

Network could include a Local Area Network LAN a Wide Area Network WAN or the Internet. In some embodiments information sent over network may be encrypted to ensure the security of the data being transmitted. Printer may be connected to network through connection . In some embodiments printer may also be connected directly to computing device and or server . System may also include other peripheral devices not shown according to some embodiments. A computer software application consistent with the disclosed embodiments may be deployed on any of the exemplary computers as shown in . For example computing device could execute software that may be downloaded directly from server . Portions of the application may also be executed by printer in accordance with disclosed embodiments.

In some embodiments CPU may be a general purpose processor a special purpose processor or an embedded processor. CPU can exchange data including control information and instructions with memory and or firmware . Memory may be any type of Dynamic Random Access Memory DRAM such as but not limited to SDRAM or RDRAM. Firmware may hold instructions and data including but not limited to a boot up sequence pre defined routines memory management routines and other code. In some embodiments code and data in firmware may be copied to memory prior to being acted upon by CPU . Routines in firmware may include code to translate page descriptions received from computing device to display lists and image bands. In some embodiments firmware may include routines to rasterize display lists to an appropriate pixmap and store the pixmap in memory . Firmware may also include compression routines and memory management routines. In some embodiments data and instructions in firmware may be upgradeable.

In some embodiments CPU may act upon instructions and data and provide control and data to ASICs FPGAs and print engine to generate printed documents. In some embodiments ASICs FPGAs may also provide control and data to print engine . FPGAs ASICs may also implement one or more of translation compression and rasterization algorithms. In some embodiments computing device can transform document data into a first printable data. Then the first printable data can be sent to printer for transformation into intermediate printable data. Printer may transform intermediate printable data into a final form of printable data and print according to this final form which may take the form of a pixmap. In some embodiments the first printable data may correspond to a PDL description of a document. In some embodiments the translation process from a PDL description of a document to the final printable data comprising of a series of lower level printer specific commands may include the generation of intermediate printable data comprising of display lists of objects.

In some embodiments display lists may hold one or more of text graphics and image data objects. In some embodiments objects in display lists may correspond to similar objects in a user document. In some embodiments display lists may aid in the generation of intermediate or final printable data. In some embodiments display lists and or pixmaps may be stored in memory or secondary storage . Exemplary secondary storage may be an internal or external hard disk memory stick or any other memory storage device capable of being used in printer . In some embodiments the display list may reside on one or more of printer computing device and server . Memory to store display lists and or pixmaps may include dedicated memory or may form part of general purpose memory or some combination thereof according to some embodiments. In some embodiments memory may be dynamically allocated to hold display lists and or pixmaps as needed. In some embodiments memory allocated to store display lists and or pixmaps may be dynamically released after processing.

On one hand memory manager allows memory allocation in blocks to prevent fragmentation abstracts away implementation details pertaining to memory management and provides a standard interface through memory management Application Programming Interface API for access to its routines. On the other hand pixmap code allows pixmaps to be viewed logically as an integral unit while permitting pixmaps to occupy discontiguous memory blocks in memory pool by leveraging the functionality provided by memory manager through memory management API and frame buffer management library .

As shown in language server engine server and raster server may communicate with each other. In addition language server engine server and raster server may invoke routines and communicate with RDL library . The system may also include frame buffer management library which communicates with pixmap code and with raster server and engine server through memory management API .

Memory manager allocates and manages memory. Routines in memory manager may be accessed using memory management API . Thus details of memory management code can be abstracted away from program code used to manage and or manipulate the display list or frame buffer. Similarly in some embodiments pixmap code may allow the use and manipulation of pixmaps as a single logical entity while permitting pixmaps to extend over one or more discontiguous memory blocks. This abstraction can be achieved using frame buffer management library to manage block and pointer allocation and deallocation for pixmaps state information pertaining to pixmaps and to track processes utilizing pixmaps. In some embodiments pixmap code may enable access to memory blocks for pixmaps. Each memory block or memory allocation unit is a chunk of contiguous memory. Memory blocks may contain one or more scanlines. A scanline is one row of pixels in the image.

In some embodiments frame buffer management library may allocate memory in blocks. In one embodiment the blocks may be of equal size. In another embodiment memory may be allocated either as a block or as an integral multiple of one or more blocks called a super block. A super block is a set of contiguous blocks. For example frame buffer management library may allocate memory in blocks and super blocks where a super block may comprise four blocks. Super blocks may be useful to hold larger pixmaps and also facilitate support for different paper sizes resolutions and orientations. For a specific product where paper sizes and other parameters are known block sizes can be changed to an optimal number that reduces wasted memory.

In some embodiments use of functionality provided by memory manager may occur through a memory management application API . For example frame buffer management library may use memory manager to obtain blocks and pointers using interfaces specified in the memory management API . Memory manager defines the functions of the memory management API . In some embodiments code pertaining to display lists and the frame buffer such as code in frame buffer management library interface with memory manager through memory management API . Accordingly in these embodiments the memory manager can be replaced or easily modified by a product specific memory manager without changing program code used to manage and or manipulate the display list or frame buffer.

In some embodiments the display list may include commands defining data objects and their contexts within a document or a page within the document to be printed. These display commands may include data comprising characters or text line drawings or vectors and images or raster data.

In some embodiments the display list may be dynamically reconfigurable and is termed a Reconfigurable Display List RDL . In one embodiment an RDL may be implemented using a data structure that allows certain display list objects to be stored in a manner that allows their manipulation dynamically. For example image objects may be compressed in place to increase the amount of available memory and decompressed when referenced and or used. In some embodiments an RDL may also permit RDL objects to be stored in memory and or secondary storage by holding pointers offsets or addresses to the actual locations of RDL objects which can then be retrieved when referenced and or used. In general the RDL allows display list objects to be flexibly stored and manipulated based on system constraints and parameters.

In one embodiment the translation of a PDL description of a document into a display list and or RDL representation may be performed by language server using routines in RDL library and memory manager . For example language server may take PDL language primitives and transform these into data and graphical objects and add these to the reconfigurable display list using the capability provided by functions in RDL library and memory manager . In one embodiment the display list may be stored and manipulated in a dynamically allocated memory pool such as exemplary memory pool which may be part of memory .

In some embodiments creation of the RDL may be an intermediate step in the processing of data prior to actual printing. The RDL may be parsed before conversion into a subsequent form. In some embodiments the subsequent form may be a final representation and the conversion process may be referred to as rasterizing the data. For example rasterization may be performed by raster server using routines in frame buffer management library and pixmap code . Upon rasterization the rasterized data may be stored in frame buffer which may be part of memory pool using routines in memory manager which may be accessed through memory management API . In one embodiment the rasterized data may take the form of a bitmap or pixmap that specifies the marks to be made on a printed page.

In one embodiment routines in memory manager may manage some subset of available memory in memory as memory pool and allocate memory from memory pool to requesting processes through memory management API . When memory is no longer needed by the requesting processes the memory may be de allocated and returned to memory pool where it can be made available to other processes. Thus exemplary memory manager may also provide various other memory management functions including routines to free memory routines to recover memory and swapping routines that can swap memory to secondary storage .

In some embodiments frame buffer may also be a part of memory pool and may be managed by memory manager . For example calls to functions in frame buffer management library may result in calls to functions in memory management API . Memory management API may then invoke one or more functions in memory manager . Results of the actions taken by memory manager may be routed back to the calling process. In one embodiment frame buffer may be allocated an initial contiguous block of memory and subsequent memory blocks may be allocated to frame buffer when requested. Memory blocks may also be allocated for other non frame buffer purposes from memory pool . In some embodiments distinct memory blocks assigned to the frame buffer or to other processes may occupy non contiguous memory locations in memory .

Print engine may process the rasterized data in frame buffer and form a printable image of the page on a print medium such as paper using routines in frame buffer library . In some embodiments raster server and engine server may also use routines in RDL library and pixmap code to perform their functions. For example routines in pixmap code may provide raster server with access to pixmap routines to support rasterization. In one embodiment routines in pixmap code may permit a final pixmap comprising one or more color plane components and an alpha plane component to be utilized by print engine through engine server .

In some embodiments engine server may provide control information instructions and data to print engine . In some embodiments engine server may invoke routines that lead to freeing memory used by framebuffer objects after processing for return to memory pool using functionality provided by memory manager through pixmap code frame buffer library and memory management API . Routines in pixmap code may provide engine server with access to scanlines for a pixmap. In some embodiments portions of memory pool and or frame buffer may reside in memory or secondary storage .

In some embodiments routines for language server raster server and engine server may be provided in firmware or may be implemented using ASICs FPGAs .

When memory is requested for use by frame buffer such as for storing a pixmap a block or super block may be allocated. Super block is a contiguous chunk of memory comprising an integral multiple of one or more blocks . When memory is requested for an RDL or for temporary storage and processing purposes a block may be allocated. As shown in pixmaps A B and C are dispersed among discontiguous memory blocks scattered throughout memory . In some embodiments memory defragmentation routines may be employed periodically or when available memory is below some threshold or as a strategy to free memory in order to create new super blocks from disparate scattered blocks in memory pool . For example objects in memory may be rearranged and disparate scattered blocks combined to create larger contiguous memory sections.

In some embodiments defragmentation may also be decreased through the use of super blocks . In some embodiments the size of super block allocation units may be varied to optimize memory utilization. For example as shown in pixmap D uses allocation units comprising super blocks where each super block is the size of two blocks. Similarly pixmap E uses allocation units comprising super blocks where each super block is the size of six blocks.

In some embodiments super block can be allocated when memory is requested so that when a single block is requested a super block may be allocated instead. Accordingly one or more blocks that constitute allocated super block may be unused initially. As additional single blocks are requested any unused blocks from the previously allocated super block can be provided to the requester until none remain at which time another super block can be allocated. In some embodiments the breaking up of framebuffer into discontiguous allocation units permits the efficient use of memory. For example when a single scanline is accessed allocation units in the pixmap that do not contain the scanline of interest can be subjected to memory conservation or recovery schemes to increase the amount of available memory. For example allocation units may be swapped to disk or compressed to increase the availability of memory.

Pixmap object may also include block list which can hold information pertaining to blocks or super blocks corresponding to a given pixmap. Exemplary block list may comprise one or more block handles shown as block handle  through block handle n. In some embodiments each block handle may provide access to one or more scanlines in block or super block . Block list may also include data fields that hold pointers to blocks in the list. For example a data structure associated with each block may hold pointers to the immediately succeeding and or preceding block. In some embodiments block list may also be implemented as a dynamic array which can be resized and also allows elements to be added or removed.

In some embodiments the number of scanlines held by block or super block may be determined by the size of the allocated unit and other system parameters. For example each block corresponding to a pixmap may comprise Sscanlines. However the last block for the pixmap may hold less than Sscanlines. As shown in each block holds five S 5 scanlines. In some embodiments a scanline may be divided further into components including one or more of component planes an alpha component etc. For example a pixel for a color image may comprise Cyan Magenta Yellow and Black CMYK components.

For a given size super block may be capable of holding a maximum of Sscanlines of S bytes each. Because the size of super block may not be an integral multiple of scanline size S some memory Wmay not be utilized in each super block with the possible exception of the last super block Z where a different amount of memory may remain unutilized . shows exemplary super block comprising of Sscanlines through S. Since super blocks may be allocated as a unit the last super block Z may contain less than Sscanlines and therefore contain an amount Wof unutilized space. Thus depending on the size of scanline and size of super block pixmap P may use more than S M bytes of memory. Routines in memory manager frame buffer management library and pixmap code may be used to manage the allocation of superblocks to optimize memory usage by pixmap P.

In step the algorithm may determine a value for N where N is the smallest integral multiple of blocks capable of holding pixmap P. Accordingly in step N may be computed as

However depending on system parameters it may be advantageous to restrict the maximum size of a superblock i.e. place an upper limit Non the number of contiguous blocks N that may comprise super block . Accordingly in step the value of N computed according to equation 1 is compared with N. If N N then the algorithm proceeds to step where the size of superblock is set as N B.

If the value of N computed according to equation 1 exceeds N then in step the value of an iteration counter i may be initialized to N and the value of a variable W which keeps track of lowest amount of unutilized space for superblock sizes already considered by the algorithm can be initialized to N B or some other sufficiently large number.

In routine the algorithm may calculate the unutilized space Wfor superblock size i B . Next in step Wmay be compared with the current value of W. If the current value of Wis less than that of W then Wmay be assigned the value of W and the current value of i may be assigned to i.

Next in step the current value of Wcan be compared to W. Wmay hold a threshold value that corresponds to a maximum value of allowable unutilized space. The value of Wmay vary among printing systems and may depend on system parameters. For example a low value of Wmay be set if memory available on printer is limited. In some embodiments the value of Wmay be based on heuristic data that may be collected by experimentation. In some methods an initial value for Wmay be updated based on information collected during the operation of printer . For example Wmay be set to the average unutilized memory in pixmaps or to the average unutilized memory for the last five pixmaps or to other values using various statistical and heuristic techniques. In some embodiments the user may be able to specify the value of Wthrough a user interface that provides a menu of available optimizations. In step if the value of Wis below the value of W the algorithm may proceed directly to step where N is assigned the value of i. Setting an appropriate value for Wallows the algorithm to converge faster to choose an optimal superblock size.

If Wexceeds W then the value of i may be decremented in step and checked to see if i exceeds zero in step . If i equals zero the algorithm proceeds to step where N is assigned the value of i. If in step i is greater than 0 then the algorithm iterates through steps .

In step the size of superblock is set as N B. Note that algorithm may be modified to handle a variety of situations. For example when the memory manager is structured to use either block size B or some predetermined superblock size N B then Wmay be calculated for these two values and no calculation may be performed for other block sizes. Further when superblocks can be allocated in various integral multiples of block size the size of the last superblock Z may be different from the size of the earlier superblocks to minimize wastage. For example if the last superblock Z comprises a single scanline then a block may be allocated to hold the last scanline thereby reducing unutilized memory. A variety of the other schemes will be apparent to one of reasonable skill in the art and the algorithm depicted in exemplary flowchart may be modified appropriately.

In step the algorithm calculates the maximum number of scanlines Sthat can be held by superblock of size i B. Smay be calculated as the highest integer that satisfies 

In step the unutilized space at the end of each superblock is calculated as mod 3 where mod refers to the modulus operator which yields the remainder after division. In step the minimum number of superblocks Z capable of holding the entire pixmap P is calculated as the smallest integer Z such that 

Next in step the unutilized space in the last superblock Z is calculated by subtracting the bytes occupied by scanlines in the last block from the size i B of superblock Z. The number of bytes occupied by scanlines in the last block may be determined by subtracting the size of pixmap P M S from the bytes used by scanlines in first Z 1 blocks which is Z 1 S S. Accordingly the unutilized space Win the last block may be calculated as 1 max 5 .

Next in step the total unutilized space Wis calculated as the sums of unutilized space in individual superblocks which is Z 1 W and the unutilized space Win the last superblock L. Therefore 1 6 .

Other implementations will be apparent to those skilled in the art from consideration of the specification and practice of disclosed embodiments. It is intended that the specification and examples be considered as exemplary only with its true scope and spirit being indicated by the following claims.

