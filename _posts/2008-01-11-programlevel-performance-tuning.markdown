---

title: Program-level performance tuning
abstract: A method, apparatus, system, and signal-bearing medium that in an embodiment request a program or programs to tune themselves to run faster or slower if a service class is not meeting its performance goal. In an embodiment, the program is repeatedly requested to incrementally tune itself until the performance goal is met or until no further improvement occurs. In various embodiments, the programs to be requested to tune themselves are selected based on whether the programs are bottlenecks for the service class, whether the programs do the majority of work for the service class, whether the programs easily meet their own performance goals, or whether the programs are low priority. In this way, the programs may be performance tuned in a way that is more effective and less intrusive than by adjusting global, system-level resource allocations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161462&OS=08161462&RS=08161462
owner: International Business Machines Corporation
number: 08161462
owner_city: Armonk
owner_country: US
publication_date: 20080111
---
This is a continuation application of U.S. patent application Ser. No. 10 664 546 filed Sep. 19 2003 to David G. Herbeck et al. issued as U.S. Pat. No. 7 350 195 on Mar. 25 2008 entitled Selecting a Program to Improve a Service Class by Requesting the Program to Incrementally Self Tune which is herein incorporated by reference.

A portion of the disclosure of this patent document contains material to which the claim of copyright protection is made. The copyright owner has no objection to the facsimile reproduction by any person of the patent document or the patent disclosure as it appears in the U.S. Patent and Trademark Office file or records but reserves all other rights whatsoever.

This invention generally relates to computers and more specifically relates to tuning performance at a program level in a computer.

The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time computer systems have evolved into extremely sophisticated devices and computer systems may be found in many different settings. Computer systems typically include a combination of hardware such as semiconductors and circuit boards and software also known as computer programs. Although advances in semiconductor processing and computer architecture have pushed the performance of the computer hardware higher more sophisticated and complex computer programs also continue to evolve which can rapidly consume the increased hardware capabilities. Thus the performance and response time of computer systems continues to be a problem.

These performance problems can be especially acute when a computer system has multiple computer programs executing concurrently and competing for the same limited global physical resources which must be shared among the computer programs. Examples of such global resources are the processor or processors and memory of the computer system.

In attempt to address these performance problems some computer systems assign the work of computer programs to service classes and give the service classes priorities and performance goals. The computer systems then monitor the performance of the work and adjust the allocation of global computer resources among the service classes based on the priorities and whether the work is meeting the goals. For example if work in a high priority service class is not meeting its goal the computer systems may give work in that high priority service class more access to the processor and more memory perhaps at the expense of work in a lower priority service class.

Switching processors and memory between service classes can result in several problems. First switching processors and memory are global system level adjustments that can drastically impact the performance of all computer programs on a system wide basis. Second it is difficult to predict how such gross adjustments will impact performance and there may be errors and unintended side effects. Third some programs attempt to manage their own resources and tune themselves but they are unaware of how other programs are performing so their local self tuning efforts can conflict with the system wide performance tuning efforts. Finally a temporary spike in the workload of a program may cause it to tune itself to use more resources but it may not release those resources when the spike subsides because the program is unaware of how its use of the resources impacts other programs. For example a database application may increase its pool of database connections in response to a temporary spike in database transactions but it might then keep those database connections indefinitely.

Without a better way to tune the performance of programs and service classes the performance of computer systems will continue to suffer.

A method apparatus system and signal bearing medium are provided that in an embodiment request a program or programs to tune themselves to run faster or slower if a service class is not meeting its performance goal. In an embodiment the program is repeatedly requested to incrementally tune itself until the performance goal is met or until no further improvement occurs. In various embodiments the programs to be requested to tune themselves are selected based on whether the programs are bottlenecks for the service class whether the programs do the majority of work for the service class whether the programs easily meet their own performance goals or whether the programs are low priority. In this way the programs may be performance tuned in a way that is more effective and less intrusive than by adjusting global system level resource allocations.

Various embodiments of the invention provide a workload manager that monitors the performance of service classes into which transactions associated with self tuning programs are allocated. If a service class is not meeting its performance goal the workload manager selects a self tuning program and requests that program to tune itself to run faster if that program is a bottleneck or is initiating the majority of the work for the service class. Alternatively the workload manager may also request the self tuning program to run slower if the self tuning program is low priority or is easily meeting its individual performance goal. The self tuning program can accomplish this self tuning by modifying its use and allocation of associated resources. After the workload manager has made the request the workload manager determines the effect of the request and may repeatedly request the self tuning program to tune itself until the performance goal is met or until progress is not being made toward the performance goal. The workload manager may notify the self tuning program of the availability of resources e.g. the availability of global resources such as processor s and memory which allows the self tuning program to perform the tuning request while alleviating resource contention between competing self tuning programs.

The electronic device includes a processor a storage device an input device and an output device all connected directly or indirectly via a bus . The processor represents a central processing unit of any type of architecture such as a CISC Complex Instruction Set Computing RISC Reduced Instruction Set Computing VLIW Very Long Instruction Word or a hybrid architecture although any appropriate processor may be used. The processor executes instructions and includes that portion of the electronic device that controls the operation of the entire electronic device. Although not depicted in the processor typically includes a control unit that organizes data and program storage in memory and transfers data and other information between the various parts of the electronic device . The processor reads and or writes code and data to from the storage device the network the input device and or the output device .

Although the electronic device is shown to contain only a single processor and a single bus other embodiments of the present invention apply equally to electronic devices that may have multiple processors and multiple buses with some or all performing different functions in different ways.

The storage device represents one or more mechanisms for storing data. For example the storage device may include read only memory ROM random access memory RAM magnetic disk storage media hard disk media floppy disk media tape media CD compact disk media DVD digital video disk media optical storage media flash memory devices and or other machine readable media. In other embodiments any appropriate type of storage device may be used. Although only one storage device is shown multiple storage devices and multiple types of storage devices may be present. Further although the electronic device is drawn to contain the storage device the storage device may be external to the electronic device and or may be distributed across other electronic devices such as devices connected to the network .

The storage device includes a workload manager a self tuning program and service classes . The workload manager monitors the performance of work in the service classes and requests the self tuning programs to tune themselves so that the service classes can meet their performance goals. In an embodiment the workload manager includes instructions capable of executing on the processor or statements capable of being interpreted by instructions executing on the processor to carry out the functions as further described below with reference to . In another embodiment the workload manager may be implemented either partially or completely in hardware via logic gates and or other appropriate hardware techniques in lieu of or in addition to a processor based system.

The self tuning program may be any software or computer program capable of tuning itself to increase and or decrease its performance. In an embodiment the self tuning program tunes a resource associated with the self tuning program to affect the performance of the self tuning program . Although only one self tuning program is illustrated in other embodiments any number of self tuning programs may be present. In an embodiment the self tuning program is an application provided by a user or a vendor. In another embodiment the self tuning program is part of the operating system of the electronic device . In another embodiment the self tuning program may have any appropriate origin. In an embodiment the self tuning program includes instructions capable of executing on the processor or statements capable of being interpreted by instructions executing on the processor to carry out the functions as further described below with reference to . In another embodiment the self tuning program may be implemented either partially or completely in hardware via logic gates and or other appropriate hardware techniques.

In various embodiments the resource may be a thread pool size a number of database connections a number of network connections network parameters an internal buffer or cache size or any combination thereof but in other embodiments any appropriate resource capable of being tuned or adjusted to affect the performance of the self tuning program may be used. Although only one resource is illustrated in other embodiments any number of resources may be present. Although the resource is illustrated as being included within the self tuning program in other embodiments the resource may be external to the self tuning program . For example the resource may be a global resource such as a processor memory or any other resource that may be allocated among different programs.

Although the workload manager and the self tuning program are both illustrated as being contained within the storage device in the electronic device in other embodiments they may be on different storage devices and or on different electronic devices and may be accessed remotely e.g. via the network . For example in an embodiment the workload manager is on one electronic device and multiple self tuning programs are distributed across other electronic devices connected via the network . In this way in an embodiment the workload manager may performance tune a distributed system.

The service classes categorize transactions issued by or associated with the self tuning program into classes. The transactions may be units of work whose performance is capable of being measured. In various embodiments the transactions may be database operations e.g. a database read or update network requests or any other appropriate unit of work. The service classes may have associated priorities and or performance goals. The priority and performance goals may be aggregate for the entire class or individual for transactions within the class. The priority of a service class is with respect to the priority of other service classes and in various embodiments may reflect the order in which the transactions within the service class are performed or the relative amount or timing of resources allocated to the transactions in the service class . The service classes may have any number of priorities which may be expressed as a range of numbers as low medium high or via any other appropriate technique.

In various embodiments the performance goal may be expressed in terms of a desired response time for a transaction or a group of transactions a desired rate of speed or any other appropriate expression of the performance goal. The relationship of the self tuning programs the transactions and the service classes is further described below with reference to .

In an embodiment the workload manager or other program categorizes transactions from the self tuning program into the service classes . In another embodiment the self tuning program categorizes its transactions into the service classes . In another embodiment a user system administrator or other human determines how transactions are assigned to the service classes .

The input device may be a keyboard mouse or other pointing device trackball touchpad touchscreen keypad microphone voice recognition device or any other appropriate mechanism for the user to input data to the electronic device and or to manipulate the user interfaces of the electronic device . Although only one input device is shown in another embodiment any number including zero and type of input devices may be present.

The output device is that part of the electronic device that presents output to the user. The output device may be a cathode ray tube CRT based video display well known in the art of computer hardware. But in other embodiments the output device may be replaced with a liquid crystal display LCD based or gas plasma based flat panel display. In still other embodiments any appropriate display device may be used. In other embodiments a speaker or a printer may be used. In other embodiments any appropriate output device may be used. Although only one output device is shown in other embodiments any number including zero of output devices of different types or of the same type may be present.

The bus may represent one or more busses e.g. PCI Peripheral Component Interconnect ISA Industry Standard Architecture X Bus EISA Extended Industry Standard Architecture or any other appropriate bus and or bridge also called a bus controller .

The electronic device may be implemented using any suitable hardware and or software such as a personal computer. Portable computers laptop or notebook computers PDAs Personal Digital Assistants pocket computers telephones pagers automobiles teleconferencing systems appliances client computers server computers and mainframe computers are examples of other possible configurations of the electronic device . The hardware and software depicted in may vary for specific applications and may include more or fewer elements than those depicted. For example other peripheral devices such as audio adapters or chip programming devices such as EPROM Erasable Programmable Read Only Memory programming devices may be used in addition to or in place of the hardware already depicted.

The network may be any suitable network or combination of networks and may support any appropriate protocol suitable for communication of data and or code to from the electronic device . In various embodiments the network may represent a storage device or a combination of storage devices either connected directly or indirectly to the electronic device . In an embodiment the network may support Infiniband. In another embodiment the network may support wireless communications. In another embodiment the network may support hard wired communications such as a telephone line or cable. In another embodiment the network may support the Ethernet IEEE Institute of Electrical and Electronics Engineers 802.3x specification. In another embodiment the network may be the Internet and may support IP Internet Protocol . In another embodiment the network may be a local area network LAN or a wide area network WAN . In another embodiment the network may be a hotspot service provider network. In another embodiment the network may be an intranet. In another embodiment the network may be a GPRS General Packet Radio Service network. In another embodiment the network may be any appropriate cellular data network or cell based radio network technology. In another embodiment the network may be an IEEE 802.11B wireless network. In still another embodiment the network may be any suitable network or combination of networks. Although one network is shown in other embodiments any number of networks of the same or different types may be present.

The various software components illustrated in and implementing various embodiments of the invention may be implemented in a number of manners including using various computer software applications routines components programs objects modules data structures etc. referred to hereinafter as computer programs or simply programs. The computer programs typically comprise one or more instructions that are resident at various times in various memory and storage devices in the electronic device and that when read and executed by one or more processors in the electronic device cause the electronic device to perform the steps necessary to execute steps or elements embodying the various aspects of an embodiment of the invention.

Moreover while embodiments of the invention have and hereinafter will be described in the context of fully functioning electronic devices the various embodiments of the invention are capable of being distributed as a program product in a variety of forms and the invention applies equally regardless of the particular type of signal bearing medium used to actually carry out the distribution. The programs defining the functions of this embodiment may be delivered to the electronic device via a variety of signal bearing media which include but are not limited to 

 1 information permanently stored on a non rewriteable storage medium e.g. a read only memory device attached to or within an electronic device such as a CD ROM readable by a CD ROM drive 

 2 alterable information stored on a rewriteable storage medium e.g. a hard disk drive or diskette or

 3 information conveyed to an electronic device by a communications medium such as through a computer or a telephone network e.g. the network including wireless communications.

Such signal bearing media when carrying machine readable instructions that direct the functions of the present invention represent embodiments of the present invention.

In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. But any particular program nomenclature that follows is used merely for convenience and thus embodiments of the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The exemplary environments illustrated in are not intended to limit the present invention. Indeed other alternative hardware and or software environments may be used without departing from the scope of the invention.

Although illustrates three self tuning programs and and two service classes and in other embodiments any number of self tuning programs and service classes may be present. Further a self tuning program may have any number of associated transactions and the transactions may be categorized across any number and combination of the service classes .

In an embodiment the self tuning program notifies the workload manager via an extension to the Application Response Measurement ARM Application Programming Interface API . The ARM API is a standard promulgated by the ARM Working Group for monitoring application performance and measuring IT Information Technology service levels. The following is example pseudo code for the portion of the self tuning program that notifies the workload manager of a desire to receive tuning requests 

 TuneApplicationStart allows the self tuning program to notify the workload manager that the self tuning program is capable of tuning itself and supports the throttle up throttle down and reset requests as further described below with reference to .

 Arm init defines the application name and optionally a user ID. In an embodiment the self tuning program acts as the application which is the terminology used in ARM. Arm init is typically executed once while the application initializes. The main reason for defining an application is to help organize the information and to minimize the problem of having duplicate transaction names defined in different applications. The return code from arm init is a unique identifier generated by the agent it is passed as a parameter on arm getid and arm end calls. In an embodiment the workload manager acts as the agent which is the terminology used in ARM.

 Arm getid defines the transaction name and optionally details about each transaction. Arm getid is called once for each transaction name and is typically executed while an application is initializing. There can be any number of transaction names defined for each application. A transaction name is unique within an application. The combination of application name and transaction name uniquely identify a transaction class. The identifier returned on the arm init call is passed as a parameter on arm getid so the transaction name will be associated with the correct application. The return code from arm getid is a unique identifier generated by the agent. It is passed as a parameter on arm start calls. This identifier is unique for all transaction classes within a system.

 Arm start indicates that an instance of a transaction has begun execution. Contrast this with arm getid which defines the name of the transaction class during initialization but does not actually indicate that a transaction is executing. The identifier returned on the arm getid call is passed as a parameter on arm start so the agent knows which type of transaction is starting. There can be any number of instances of the same transaction class executing simultaneously on the same system. To identify each one the return code from arm start is a unique handle generated by the agent. This handle is unique within a system across all instances of all transactions of all applications. The transaction instance is the fundamental entity that the ARM API measures.

 Arm stop indicates that an instance of a transaction has completed. The handle returned on the arm start call is passed as a parameter to indicate which instance of a transaction is ending. Arm stop may be issued from a different thread or process from which the arm start was issued. The transaction status is also passed.

 Arm end indicates that the application will not be making any more calls to the ARM API. It is typically used when an application is shutting down. Any information about transactions that are in process an arm start has been issued but not yet a corresponding arm stop is discarded.

 TuneApplicationEnd allows the self tuning program to notify the workload manager that the self tuning program will no longer support the throttle up throttle down and reset requests.

In another embodiment of the invention the ARM API is extended so that the arm init and arm end calls have an additional parameter indicating that the self tuning program wishes to implement tuning requests such as in the following example pseudocode 

Although various extensions to the ARM API are illustrated above in other embodiments the self tuning program may use other standards protocols parameters message passing interrupts or any other suitable technique for communication between the self tuning program and the workload manager .

Control then continues to block where the workload manager determines whether any of the service classes are not meeting their performance goals. If the determination at block is false then all of the service classes are meeting their performance goals so control continues to block where the workload manager waits for a period of time before returning to block as previously described above. Thus in an embodiment the workload manager periodically performs the check at block .

If the determination at block is true then at least one of the service classes has failed to meet its performance goal so control continues from block to block where the workload manager sets a current self tuning program to be a first self tuning program to be processed. In an embodiment the self tuning programs have associated priorities and the workload manager processes them in priority order so the first self tuning program at block is the highest priority program. In another embodiment the workload manager processes the self tuning programs in any appropriate order. In an embodiment the workload manager processes all self tuning programs having transactions associated with the service class that is not meeting its performance goal previously determined at block . In another embodiment the workload manager processes all self tuning programs from which notifications were received at block regardless of with which service class the self tuning programs are associated based on their transactions.

Control then continues to block where the workload manager determines whether any self tuning program remains to be processed and the service class performance goal has not yet been met. If the determination at block is true then control continues to block where the workload manager determines whether the current self tuning program is a bottleneck for the service class that is not meeting its performance goal.

In an embodiment the workload manager makes the determination at block by checking whether the response time for the transactions in the service class that are associated with the current self tuning program divided by the response time for all transactions in the service class is greater than a threshold value. In another embodiment the workload manager makes the determination at block by checking whether the response time for the transactions in the service class that are associated with the current self tuning program is greater than a threshold value. In another embodiment at block the workload manager may use any appropriate check or calculation to determine whether the current self tuning program is a bottleneck for the service class that is not meeting its performance goal.

If the determination at block is true then the current self tuning program is a bottleneck for the service class that is not meeting its performance goal so control continues to block where the workload manager throttles up the current self tuning program as further described below with reference to . Control then continues to block where the workload manager sets the current self tuning program to the next self tuning program to be processed. Control then returns to block as previously described above.

If the determination at block is false then the current self tuning program is not a bottleneck for the service class that failed to meet its performance goal so control continues to block where the workload manager determines whether the current self tuning program is associated with the majority of work in the service class that failed to meet its performance goal.

In an embodiment the workload manager makes the determination at block by checking whether the current self tuning program currently is associated with the majority of transactions in the service class. In another embodiment the workload manager makes the determination at block by checking whether the current self tuning program has initiated the majority of transactions associated with the service class within a time period. In another embodiment the workload manager makes the determination at block by checking whether the current self tuning program has initiated transactions within a time period whose aggregate response time is greater than half of the response time for all transactions in the service class during that time period. In another embodiment the workload manager may use any appropriate technique for making the determination of block . In another embodiment the check at block is optional or not used.

If the determination at block is true then the current self tuning program is associated with the majority of work in the service class that failed to meet its performance goal so control continues to block where the current self tuning program is throttled up as previously described above.

If the determination at block is false then the current self tuning program is not associated with the majority of work in the service class that failed to meet its performance goal so control continues to block where the workload manager determines whether the current self tuning program easily meets its performance goal or the current self tuning program has a low priority.

In an embodiment the workload manager determines whether the current self tuning program has a low priority by comparing the priority of the self tuning program to a threshold. In another embodiment the workload manager determines whether the current self tuning program has a low priority by comparing the priority of the self tuning program to the average of priorities of other programs associated with the service class. In an embodiment the workload manager determines the priority of the self tuning program by inspecting the priority of the transactions associated with the self tuning program. In another embodiment the workload manager may use any appropriate technique for determining whether the current self tuning program has a low priority.

In an embodiment workload manager determines whether the current self tuning program easily meets its goal at block by checking whether the response time of transactions in the service class that were initiated by the current self tuning program is less than a threshold percentage of the goal for the current self tuning program. In another embodiment the workload manager determines whether the current self tuning program easily meets its goal at block by checking whether the response time of all transactions initiated by the current self tuning program is less than a threshold percentage of the goal for the current self tuning program regardless of with which service class the transactions are associated. In another embodiment the workload manager may use any appropriate technique for determining whether the current self tuning program easily meets its goal.

If the determination at block is true then control continues to block where the workload manager throttles down the current self tuning program as further described below with reference to . Control then continues to block where the workload manager sets the current self tuning program to be the next self tuning program to be processed. Control then returns to block as previously described above.

If the determination at block is false then control continues to block as previously described above.

If the determination at block is false then either no self tuning program remains to be processed or the performance goal for the service class has now been met so control continues to block where the workload manager determines whether the performance goal for the service class is now met. If the determination at block is true then the service goal is met so control continues to block where the function returns. If the determination at block is false then the service goal is not met so control continues to block where the workload manager optionally tunes the electronic device globally using resources of the electronic device that may be common to some or all of the self tuning programs . In various embodiments the global resource may be the allocation of processor time or memory among the self tuning programs but in other embodiments any appropriate global resource may be tuned.

Although illustrates the workload manager tuning the electronic device globally only at block in other embodiments the workload manager may perform global tuning at any time in lieu of or in addition to the program level tuning described in . For example in some embodiments the workload manager performs global tuning first and then requests the self tuning programs to tune themselves. This approach may work well in the following example. In a partitioned system programs A B are running in partition and programs C D are running in partition . If partition is busy and partition is idle the workload manager globally shifts resources from partition to partition prior to requesting programs A B C and D to tune themselves.

In another example of global tuning the workload manager predicts whether the performance goal of a service class will be met in the future and globally shifts resources among the service classes to anticipate workload changes. For example if partitions and are associated with different time zones and their transaction volumes fluctuate throughout the day being greater during waking hours and less at night the workload manager predicts the resource needs of the partitions based on the known fluctuations in transactions and the time zone difference and globally tunes resources between the partitions prior to requesting the programs A B C and D to tune themselves.

If the determination at block is false then the performance goal for the service class is still not met so control continues to block where the workload manager determines whether the performance of the service class has improved since the current self tuning program was requested to tune itself at block . If the determination at block is true then performance has improved so control continues to block where the workload manager determines whether the performance of any service class that has a higher priority than the current service class was impaired since the request at block . If the determination at bock is true then performance of the current service class was improved via the request at block at the expense of a service class with a higher priority than the current service class so control continues to block where the workload manager requests the self tuning program to reset itself to its previous state prior to the most recent request at block as further described below with reference to .

If the determination at block is false then the performance of the current service class was improved but not at the expense of a higher priority service class so control returns to block where the workload manager once again requests the current self tuning program to tune itself as previously described above.

Although the determination at block is illustrated as being performed if the performance of the service class has improved but the goal is not met in another embodiment if the goal for the service class is met at the expense of a higher priority service class the self tuning program is also reset to its previous state.

If the determination at block is false then the tuning previously requested at block either made no difference to the performance of the service class or the tuning actually made the performance worse so control continues to block where the workload manager requests the self tuning program to reset itself to its previous state prior to the most recent request at block as further described below with reference to . Control then continues to block where the function returns.

If the determination at block is false then control continues to block where the workload manager determines whether the performance of the service class has improved since the current self tuning program was requested to tune itself to run slower at block . If the determination at block is true then the performance of the service class has improved so control continues to block where the workload manager determines whether the performance of any service class that has a higher priority than the current service class was impaired since the request at block . If the determination at block is true then performance of the current service class was improved via the request at block at the expense of a service class with a higher priority than the current service class so control continues to block where the workload manager requests the self tuning program to reset itself to its previous state prior to the most recent request at block as further described below with reference to .

If the determination at block is false then the performance of the current service class was improved but not at the expense of a higher priority service class so control returns to block where the workload manager once again requests the current self tuning program in the self tuning programs to incrementally tune itself as previously described above.

Although the determination at block is illustrated as being performed if the performance of the service class has improved but the goal is not met in another embodiment if the goal for the service class is met at the expense of a higher priority service class the self tuning program is also reset to its previous state.

If the determination at block is false then the tuning previously requested at block either made no difference to the performance of the service class or the tuning actually made the performance worse so control continues to block where the workload manager requests the current self tuning program in the self tuning programs to reset itself to its previous state prior to the most recent tuning request at block as further described below with reference to . Control then continues to block where the function returns.

Control begins at block . Control then continues to block where the self tuning program receives a request from the workload manager . Control then continues to block where the self tuning program determines whether the request previously received at block is a throttle up request.

If the determination at block is true then the request is a throttle up request so control continues to block where the self tuning program saves the state of the resource . Control then continues to block where the self tuning program incrementally tunes the resource to increase the performance of the self tuning program . Control then continues to block where the function returns.

If the determination at block is false then the request is not a throttle up request so control continues to block where the self tuning program determines whether the request previously received at block is a throttle down request. If the determination at block is true then the request is a throttle down request so control continues to block where the self tuning program saves the state of the resource . Control then continues to block where the self tuning program incrementally tunes the resource to decrease the performance of the self tuning program . Control then continues to block where the function returns.

If the determination at block is false then the request is not a throttle down request so control continues to block where the self tuning program determines whether the request is a reset request. If the determination at block is true then the request is a reset request so control continues to block where the self tuning program tunes the resource to the saved resource state. Control then continues to block where the function returns.

If the determination at block is false then control continues to block where the self tuning program processes any other request that the self tuning program optionally supports. Control then continues to block where the function returns.

In the previous detailed description of exemplary embodiments of the invention reference was made to the accompanying drawings where like numbers represent like elements which form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments were described in sufficient detail to enable those skilled in the art to practice the invention but other embodiments may be utilized and logical mechanical electrical and other changes may be made without departing from the scope of the present invention. Different instances of the word embodiment as used within this specification do not necessarily refer to the same embodiment but they may. The previous detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

In the previous description numerous specific details were set forth to provide a thorough understanding of the invention. But the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown in detail in order not to obscure the invention.

