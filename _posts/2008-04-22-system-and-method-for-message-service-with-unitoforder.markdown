---

title: System and method for message service with unit-of-order
abstract: The present invention enables “unit-of-order”, which allows a message producer to group messages into a single unit. It guarantees that messages are not only delivered to consumers in order, they are also are processed in order. The unit-of-order will be delivered to consumers as one unit and only one consumer will process messages from the unit at a time. The processing of a single message is complete when it is acknowledged, committed, recovered, or rolled back. Until message processing for a message is complete, the remaining unprocessed messages for that unit-of-order are blocked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954994&OS=08954994&RS=08954994
owner: Oracle International Corporation
number: 08954994
owner_city: Redwood Shores
owner_country: US
publication_date: 20080422
---
This application claims priority from the following application which is hereby incorporated by reference in its entirety 

U.S. Provisional Application No. 60 913 518 entitled SYSTEM AND METHOD FOR MESSAGE SERVICE WITH UNIT OF ORDER by Sal Gambino filed on Apr. 23 2007.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

A messaging service for a non limiting example Java Messaging Service JMS is an application program interface API that supports the formal communication known as messaging between computers in a network. Here messaging is the creation storage exchange and management of messages between producers who send publish the messages to a queue of a destination and consumers who receive subscribe and browse the messages from the queue of the destination. Here a message can be but are not limited to text image voice telex fax e mail paging and other suitable electronic data describing events requests and replies over a communications network. A distributed destination is a set of destinations queues or topics that are accessible as a single logical destination to a client. The destinations can be hosted on a messaging server.

The JMS specification specifies ordered message delivery in a very strict sense by defining order between a single instance of a producer and a single instance of a consumer. It does not take into account that there may be multiple producers within a single application acting as a single producer. The case where there are multiple consumers acting in concert is even more common. Moreover when consumers reject messages recover or transaction rollback other messages from the same producer can be delivered to another consumer for processing.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to an or one or some embodiment s in this disclosure are not necessarily to the same embodiment and such references mean at least one.

Various embodiments of the present invention enable unit of order which allows a stand alone message producer or a group of producers acting as one to group messages into a single unit. It guarantees that messages are not only delivered to consumers in order they are also are processed by the consumers in order. The unit of order is delivered to consumers as one unit and only one consumer can process messages from the unit at a time no parallel delivery . Messages of a unit of order sent to a distributed destination are on physical member of the distributed destination only one at a time i.e. the messages will not reside at more than one member at any given time. The only mandatory property of the feature is ordered processing which requires that messages from a unit of order can only be processed sequentially in the order they were created. The processing of a single message is complete when it is acknowledged committed recovered or rolled back. Until message processing for a message is complete the remaining unprocessed messages for that unit of order are blocked.

The current JMS specification however cannot guarantee ordered message processing due to these reasons 

An online bookstore implements a simple processing design that uses JMS to process customer orders. The JMS processing system is composed of 

A client logs into the online bookstore account and searches his favorite book topics. He chooses a book proceeds to the checkout and completes the sales transaction. Then the client realizes he has previously purchased this same item so he cancels the order. One week later the book is delivered to him.

In the client s ordering scenario his cancel order message was processed before his purchase order message. Consequently he received a book he did not wish to purchase. The following steps and the diagram shown in demonstrate how the client s order was processed 

In addition although the Java Message Service Specification provides an ordered message delivery it only provides ordered message delivery between a single instance of a producer and a single instance of a consumer. In the case above multiple MDBs where available to consume messages from Queue and the processing order of the messages was no longer guaranteed.

Referring to a producer can create a plurality of messages in order sorted by for non limiting examples time and or priority. These messages can then be grouped together as a single unit of order and be delivered as a unit to a queue on a destination . If the destination is a distributed destination the unit of order will be delivered to a single member of the distributed destination. A consumer for a non limiting example a Message Driven Bean can then process the messages in the unit of order sequentially in the order they are created one at a time. Any unprocessed messages in the unit of order will be blocked until the processing of the current message is completed. Finally the processing result of the messages can be saved into a database .

Referring to a plurality of messages can be created in order at step . These messages can then be grouped a single unit of order at step and delivered as one unit to a queue in a destination at step . Once delivered the messages in the unit of order will be processed sequentially one at a time in the order they were created at step and any unprocessed messages will be blocked until the processing of the current message is completed at step . The processing result of the messages can be saved into a database at step .

The simple case study depicted in can again be used to illustrate how message unit of order can solve the problem previously discussed. To ensure that all messages in Joe s order are processed correctly the system administrator for XYZ Bookstore can configure a message unit of order based on a user session such that all messages from a user session have a unit of order name attribute with the value of the session id. All messages created during Joe s user session are processed sequentially in the order they were created because messages in a Unit of Order are not processed in parallel. The diagram in and corresponding actions below demonstrate how the client s order was processed using message unit of order.

In some embodiments messages on the same queue can belong to different unit of orders as shown in . Green Group messages and and Blue Group messages A B and C are on the same queue but they are two different unit of orders can are processed by different transactions or session one at a time respectively.

In some embodiments unit of order requires that messages to be delivered in accordance with the following rules 

In some embodiments destination sort keys control the order in which messages are presented to consumers when messages are not part of a unit of order or are not part of the same unit of order. For a non limiting example messages A and B are in the same unit of order on a queue that is sorted by priority and the sort order is descending where message B has a higher priority than A. Even though message B has a higher priority it is still not deliverable until message A has been processed because they are in the same unit of order. If a message C arrives and either does not have a unit of order or is not in the same unit of order as message A the priority setting of message C and the priority setting of message A will determine the delivery order.

In some embodiments the ordered processing feature guarantees that messages with the same unit of order name within a single destination are processed in the order they arrive at the queue. This is a stronger guarantee than the ordered delivery guarantees defined by the JMS specification. To guarantee ordered processing delivery of messages in the same unit of order to consumers at a destination can be controlled in the following way 

In some embodiments processing a single message in a unit of order is complete when it has been acknowledged committed recovered rolled back or removed due to expiration or redelivery limit. A consumer that has several messages from the same unit of order must complete processing all of them before another can be delivered to any queue consumer if all previous messages have been processed.

In some embodiments acknowledgement mode can be defined to indicate whether messages are processed in the unit of order. No messages from a unit of order are processed in parallel in the acknowledgement mode when the consumer is closed the current message processing is completed regardless of the session s acknowledge mode 

In some embodiments the unit of order feature will not limit parallel processing of the same unit of order by two subscribers on the same topic. The message delivery model for a topic subscriber is the same as that of a queue with exactly one consumer because individual subscribers for a topic are considered to have their own destination message list. In case unit of order messages are sent to a distributed topic the order of the messages on a particular physical member is defined by the order the messages arrive at the member. In another word the orders of the messages at different members of the distributed topic may be different.

Every unit of order has a name. In some embodiments the messages with equal unit of order names belong to the same unit of order within a destination. The name can either be provided by the system or the application. Messages in the same unit of order all share the same name. System generated unit of order names can be timestamp based and statistically unique. This allows the application to have unit of order that are uniquely named.

In some embodiments applications can also supply their own unit of order names. They can be referenced through various mechanisms that allow multiple producers and even multiple clients to share them. Applications will take advantage of Ordered Processing by this name so it can be significant to the application. Unit of order can also have their own namespace and do not need to be unique with respect to other named objects. For instance it is perfectly valid to have both a unit of order named Foo and a Queue named Foo . The scope of a Unit of Order name is limited to a single destination and two different Units of Order on two destinations may have the same name.

In some embodiments one or more producers may send messages with the same unit of order by using the same string to create the unit of order. Alternatively the unit of order name may be extracted from a delivered message so that a system generated unit of order name can be used on more than one producer. This sharing paradigm works just as well for application assigned unit of order names. It will be most efficient if the information is serialized in only one place so a property like Conversation Id may wish to be stored only as the unit of order name.

In some embodiments messages in a unit of order can be created programmatically through an Application Programming Interface API of the JMS message producer. With this programmatic approach a method will be called to associate the producer with a unit of order name. Once a producer is associated with a unit of order all messages sent by this producer are processed as a unit of order until either the producer is closed or the association between the producer and the unit of order is dissolved. The following code provides a non limiting example of how to associate a producer with a unit of order 

In some embodiments messages in a unit of order can be created demonstratively through a JMS connection factory. With this administrative approach a factory can be configured with unit of order enabled and optionally a name provided. As a result all sessions created from connections created from this factory will have unit of order enabled. All messages produced from the same session will belong to the same unit of order and messages from different sessions belong to different unit of order. The connection factory approach also has the advantage of enabling unit of order for legacy JMS applications without any code change. A connection factory can be configured via one of the following methods to enable message unit of order 

In some embodiments JMS message management allows a JMS administrator to move and delete most messages in a running JMS server and thus violating the delivery rules for unit of order. For a non limiting example if messages A B C and D are produced and sent to destination D and belong to unit of order foo 

In some embodiments unit of order can be supported by store and forward function. For a non limiting example a store and forward producer sends messages with a unit of order named Foo. If the producer disconnects and reconnects through a different connection the producer creates another unit of order with the name Foo and continues sending messages. All messages sent before and after the reconnect are directed through the same store and forward agent.

In some embodiments all messages with the same unit of order and having a distributed destination target such as a queue can be directed to a single member of the distributed destination to preserve order. For a non limiting example all messages of the unit of order will be sent to one physical queue member at a time if a message is sent to a distributed queue. If the message is sent directly to a distributed queue member no routing will be performed 

In some embodiments the routing of unit of order to the destination can be controlled by path service which stores a map from unit of order name to distributed destination member. It makes the routing of unit of order transparent to configuration changes and still works if one member is down. However new unit of order messages cannot be sent if path service cannot be reached.

In some embodiments path service can be configured to provide a persistent map that can store the path information application names required to route the messages contained in a unit of order to its destination resource a member of a distributed destination. If the path service is configured for a distributed destination the routing path to a member destination is determined by the server using the run time load balancing heuristics for the distributed queue. Path Service can be defined at top level and only one path service is allowed per cluster which can be shared among multiple entities within a server.

In some embodiments path service requires configuration by the administrator. When a unit of order does not have a path entry a distributed queue unit of order name physical queue member path entry mapping is created. The path entry is deleted when the last producer and last message reference are deleted. After the path entry is deleted the same unit of order name may be sent to a different distributed queue physical member. The member can be chosen based on run time distributed queue load balancing information which are persisted. Subsequently one or more producers can send messages to the same unit of order in the same distributed queue sharing the path entry. Eventually no more producers or queue messages are using that unit of order name and that path entry can be deleted. Queue members deleted from the distributed queue will have their corresponding routing entries deleted from the path service as well. There can be a path service configured for the cluster and or for a specific distributed queue. Regardless of whether the path service is configured the required route for a unit of order name may be unreachable and a producer sending to an unreachable route results in an exception.

In some embodiments the default routing path to a member destination queue can be chosen by the server based on the hashing of the message unit of order name and the distributed queue members if path service is not configured. This routing mechanism is scalable with no single point of failure since routes to a distributed queue member can be calculated quickly and do not require persistent storage in a cluster. On the other hand the routes in the hash table needs to change if the configuration changes. The following factors can be considered the implementation of unit of order in conjunction with Hash based routing 

One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor s programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

One embodiment includes a computer program product which is a machine readable medium media having instructions stored thereon in which can be used to program one or more computing devices to perform any of the features presented herein. The machine readable medium can include but is not limited to one or more types of disks including floppy disks optical discs DVD CD ROMs micro drive and magneto optical disks ROMs RAMs EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data. Stored on any one of the computer readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly while the concept bean is used in the embodiments of the systems and methods described above it will be evident that such concept can be interchangeably used with equivalent concepts such as class method type interface component object model and other suitable concepts. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application thereby enabling others skilled in the art to understand the invention the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.

