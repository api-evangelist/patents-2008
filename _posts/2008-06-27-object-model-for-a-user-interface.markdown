---

title: Object model for a user interface
abstract: Various embodiments provide techniques and processes for defining elements of a user interface (UI) using a tree of objects created based on a markup language. In some embodiments, a client application provides markup that defines one or more aspects of a UI to an application programming interface (API). The API parses the markup to determine a namespace and one or more UI elements defined by the namespace. Instances of the UI elements are created, and properties of the UI elements are set on the instances. A user interface may then be displayed that includes the instances of the UI elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08245144&OS=08245144&RS=08245144
owner: Microsoft Corporation
number: 08245144
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
Object oriented programming OOP provides techniques for creating binary software components objects that can interact with each other. One example of OOP is the Component Object Model COM . COM specifies an object model and programming requirements that enable this object interaction. A COM object can be created using one of a variety of different programming languages e.g. C Visual Basic and so on . The flexibility and simplicity of COM have enabled it to become a widely adopted and long lived standard. However certain aspects of COM present challenges when creating a graphical user interface GUI .

First COM typically lacks the ability to support a new object class which extends from a base class. As a result a first party is unable to create a COM object that derives from and extends a COM object that is created by another party. Second it is difficult to interface COM objects with declarative markup languages e.g. XAML to specify layouts appearances behaviors of a particular part or parts of a GUI. These particular challenges can make it difficult for COM to be used to implement a GUI.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Various embodiments provide techniques and processes for defining elements of a user interface UI using a tree of objects created based on a markup language. In some embodiments a client application provides markup that defines one or more aspects of a UI to an application programming interface API . The API parses the markup to determine a namespace and one or more UI elements defined by the namespace. Instances of the UI elements are created and properties of the UI elements are set on the instances. A user interface may then be displayed that includes the instances of the UI elements.

Various embodiments provide a user interface UI platform that implements aspects of a markup language e.g. XML XAML and so on and object oriented programming methods to provide flexible and customizable ways of defining and or generating a graphical UI. While the UI platform is discussed with reference to component object model COM methodology and terminology this is not intended to be limiting and any suitable object oriented programming methodology may be utilized without departing from the spirit and scope of the claimed embodiments.

The UI platform includes a User Interface Object Model UIOM that enables developers to create new object class types that inherit and or override functionality from base classes. UIOM also enables objects and or object properties to be referenced by name e.g. within a namespace such that objects and or properties can be coded in a markup language to specify the layout appearance and or behavior of one or more aspects of a UI. In some embodiments UIOM includes an application programming interface API that manages the loading registration instantiation and or initialization of UIOM classes. A UIOM class may also inherit properties and or behavior from a base class defined by UIOM.

In an implementation example the UI platform receives markup from a client application that defines one or more aspects of a UI. The UI platform then parses the markup looking for a namespace and a class name of a UI object within the namespace. In some embodiments a namespace comprises multiple class type objects with each class type object representing one or more UI elements such as a button a textbox a banner and so on. In this example if the platform encounters the markup acme textbox the platform recognizes that the markup designates the namespace acme and the textbox class name within the acme namespace. The UI platform then creates a tree of one or more COM objects that correspond to the namespace acme and class name textbox and sets properties e.g. visual attributes such as size color and so on on the object s within the tree. The tree includes a textbox node with particular properties and the textbox node is used to display a textbox in a UI. As discussed above the textbox node may inherit properties and or functionally from a UIOM base class.

In the discussion that follows a section entitled Operating Environment is provided and describes an environment in which one or more embodiments can be employed. Following this a section entitled Example Architecture is provided and describes one example of an object oriented architecture that can implement various principles and techniques discussed herein. Next a section entitled Example Processes discusses a few examples of processes that may implement various techniques discussed herein for defining and or generating various aspects of a user interface. Following this a section entitled Implementation Specifics discusses a variety of implementation details for implementing the UIOM architecture in one or more embodiments. Finally some example object interfaces are provided that implement a variety of UI creation methods that utilize the UIOM architecture.

Stored on computer readable media are one or more client applications and a UI platform . Examples of client applications include a web browser a media rendering application an instant messaging client a web development application and so on. As part of UI platform are markup parser a User Interface Object Model UIOM framework and UI customization features . Markup parser processes markup code and converts the markup into a form that can be utilized by the UI platform. The UIOM framework is an object model that provides among other things the ability for class types to extend and or override functionality in base classes as well as functionality for creating and initializing instances of classes based on markup namespace identifiers. The UI customization features enable developers and other parties to create custom UI objects and or properties that can be used by the UIOM framework to create a UI.

Each of the objects in architecture includes one or more interfaces that can expose functions and or methods that can be accessed by applications objects and or processes to implement the techniques for UI creation discussed herein. In this particular example the double headed arrows indicate that a particular object is created and or owned by another object application and or process. For example Type Manager object may be created by client application . The single headed arrows indicate that one object is holding a reference to another object. Implementation examples of architecture and its interfaces and methods are discussed below.

In example architecture the Type Manager object is a top level interface to the UIOM framework. The Type Manager manages loading and creation of classes of objects for one or more namespaces. In some embodiments a namespace represents one or more sets of related classes of UI elements that are defined by the same party e.g. a software developer . One or more of the namespaces are represented by the Namespace Manager object which handles communication with one or more Namespace Type Factory objects provided by an entity that creates custom types e.g. custom UI objects . A custom type is represented by the Class Type object which specifies a base class type and provides a factory for creating instances of the class. In some embodiments the Class Type object provides functionality to query for class specific interfaces to set properties subscribe to events and access other functionality that may be exposed by an interface.

At the UIOM framework determines a namespace and a class name from the parsed markup. In one example the UIOM framework receives the markup acme textbox from which it determines that the namespace is acme and the class name is textbox . At the UIOM framework creates a tree of objects that includes one or more class types and class instances that correspond to the namespace and the class name. In the current example the class instances include a textbox instance of the textbox class. At one or more properties are set on the objects of the object tree which may include the class instance s . Continuing the current example the size and color of the textbox are specified. At one or more of the class instances are displayed. In the current example this can include displaying the text box in a UI.

At a client application creates a type manager. In one example the client application calls a CoCreateInstanceo API that creates an instance of the type manager. At to register a namespace with the type manager the client application calls a method on the type manager e.g. the RegisterNamespace method discussed below in the Interfaces section and provides a string name of the namespace and an identifier e.g. a class identifier for a namespace type factory for the namespace. At the type manager associates the string name with the identifier and a pointer to a namespace manager. Initially the pointer value is set to null. At the client application provides markup to the type manager and requests that the type manager parse the markup and create a tree of objects from the markup. At the type manager parses the markup and determines one or more namespaces from the markup. The type manager may implement its own markup parser or it may send the markup to an external parser to be processed. At a class in the namespace is determined from the markup and in response a method is called that creates a namespace manager. In one or more embodiments the namespace manager is not created until a class in the namespace is encountered and or the client application calls an API to access a class in the namespace. This on demand aspect provides a more efficient and economical way of generating a UI and UI elements.

The type manager calls a method on the namespace manager that requests that a namespace type factory be created for the namespace block . According to some embodiments the type manager provides a globally unique identifier GUID to the namespace manager and requests that the namespace manager create a namespace type factory that is associated with the GUID. For example a developer may create a namespace type factory and register the namespace type factory using the GUID. The namespace manager handles communication with the namespace type factory.

At the namespace type factory is created and the namespace manager calls a method on the namespace type factory that asks the namespace type factory for its identifier e.g. its namespace its GUID and so on . If the namespace type factory returns the identifier that the namespace manager used to request the creation of the factory this verifies that the correct namespace type factory has been created. At the client application calls a method that creates a class type manager. The class type manager provides one or more interfaces to class type objects that are to be created. At the client application calls a method that creates a class type object. Using the example discussed above in the client application calls a method on the namespace type factory that creates a class type object with the class name textbox .

To create an instance of the class at a method is called that creates a class instance. Using the example from the class instance would comprise a textbox object. As one example of the creation of a textbox object the class type manager includes an IUIClassFactory interface that provides a method for creating an instance of a class. This interface is accessible to one or more of the objects in the UI architecture as well as the client application. The object s and or the client application may call the method to initiate the creation of the class instance. At one or more base class instances for the class instance are created. In one or more embodiments the base class instances include functionality and or properties that the class instance inherits from the base classes. A base class instance may include one or more interfaces for registering properties for the base class. The class instance may also override and or extend properties and functionality of one or more of its base classes. At properties are set on the class instance and or its base class instance s . Properties may include visual aspects e.g. size color and so on as well as behavior and functionality.

This example process is effective to create a tree of objects that are used to define one or more aspects of a UI. For purposes of simplicity this example process discusses the creation of a tree that includes a single instance of a single class and one or more base classes i.e. the text box instance of the text box class . However in many implementation scenarios a tree of objects will be created with multiple different class types class instances and base classes.

The following sections discuss particular UIOM implementation specifics according to one or more embodiments.

In some embodiments the UIOM framework utilizes a DependencyObject base class from which one or more class types may inherit properties and or functionality. The DependencyObject type exposes interfaces for accessing properties and for subscribing to and raising UIOM events. For generating a UI a hierarchy of objects that define different aspects of the UI may descend from the DependencyObject type.

In some embodiments the UIOM framework utilizes COM based aggregation techniques such as blind aggregation. The following pseudo code illustrates one example of a ToggleButton class that inherits properties and or functionality from a Button class using COM based aggregation 

In some embodiments IUINamespaceTypeFactory is used for creating ClassTypes and ClassFactories are used for creating instances. The following is some sample UIElement Code that blind aggregates a TreeElement which it creates by calling pClassFactoryTreeElement CreateBaseInstance.

Creating a New Type and Overriding a Base Class ImplementationIn some embodiments COM based containment may be used to override a base class implementation. The following pseudo code illustrates a new class WrapPanel that inherits from a Panel base class. In this example the WrapPanel class overrides the IUILayout interface implementation utilized by the Panel base class. As illustrated below new logic is provided by the new WrapPanel class for Measure and Arrange functions indicated in bold below of the Panel base class. Other interfaces implemented by the Panel base class may be blind aggregated by the WrapPanel class.

In some embodiments UIOM elements are COM objects but are not necessarily created using the CoCreateInstance API. One or more DLLs may be utilized to provide UIOM functionality and the DLLs may provide one or more element factories such as the namespace type factory which are logically mapped to a markup namespace and include functionality to create instances of UIOM elements e.g. a class instance using an element name string e.g. acme textbox from the example given above . Utilizing these techniques a tree of UI elements may be created starting with an outer object e.g. a UI window frame and creating internals for the outer object e.g. a button and a textbox for the UI window frame . The element factories may also provide class type information and one or more interfaces for setting object dependency properties and subscribing to events. Pseudo code for creating an UIOM element utilizing an element factory is provided below 

In some embodiments the UIOM framework utilizes a DependencyObject base class as the ultimate base class for UIOM objects. An IUIDependencyObject interface includes methods for obtaining and setting properties on UIOM objects. The pseudo code illustrated below presents one implementation of the IUIDependencyObject as an implementation of IUITreeElement and or IUITreeContainer interfaces which define methods for object tree traversal including references to one or more child nodes in an object tree and or one or more pointers to a parent node.

In some embodiments retrieving and setting object properties uses a pair of Get Set methods associated with one or more object interfaces. This is illustrated in the following pseudo code 

Underlying storage for property values can be implemented in a property system. In some embodiments a property system stores property values for a variety of UI elements. When a value for a property is requested for a UI element e.g. a width value for a text box the value can be retrieved from the property system. For example the DependecyObject may store property values for one or more object UI element properties. Further to the ToggleButton example discussed above the property accessors may be strongly typed wrappers for DependencyObject properties. This is illustrated below is pseudo code 

In some embodiments properties are set according to their string name and with a string value. This may be accomplished by accessing the UIOM element s IUIDependencyObject interface as illustrated in the following pseudo code 

Properties may be set on one or more elements in a tree of objects even if an element is of an unrelated type. Thus in some embodiments property values can be considered to be inherited by one or more descendent tree elements. In some embodiments an ancestor element on a tree e.g. a parent node does not know the set of properties for a child element. In these embodiments a child element s properties are set on the node s namespace type factory object. The following example of pseudo code sets the TextBox FontSize property on an ancestor element higher up in a tree of elements 

Properties may also be set on a descendant element based on one or more of its ancestor elements. These are known as attached properties. Properties may be set on the descendent element s namespace type factory object. The following pseudo code sets a Panel ZIndex property on a child element 

Client applications may use CoCreateInstanceo to obtain a factory for one or more core UIOM classes and may also use CoCreateInstanceo to obtain a factory for a third party component that is developed outside of the core UIOM architecture. One example of a client application startup utilizing the core UIOM architecture and one or more third party components is illustrated in the following pseudo code. The following pseudo code 

 3 instantiates IUINamespaceTypeFactory if this has not already been done . In some embodiments this is implemented before a class type is used in a namespace 

This section presents several interfaces that may be implemented to generate a UI using the UIOM architecture. The interfaces are explained in Interface Design Language IDL and include an explanation of the functionality of each interface.

These interfaces are part of a UIOM API that controls the loading registration instantiation and initialization of UIOM classes which in some embodiments inherit properties and or functionality from the DependencyObject base class.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines computer executable instructions programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media .

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

The above described principles and techniques provide for user interface creation using markup language and object oriented programming techniques. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

