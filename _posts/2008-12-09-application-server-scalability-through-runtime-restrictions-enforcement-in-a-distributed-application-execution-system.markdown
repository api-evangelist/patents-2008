---

title: Application server scalability through runtime restrictions enforcement in a distributed application execution system
abstract: In an application execution system having a plurality of application servers, each application server includes non-volatile storage for storing a plurality of applications, volatile storage and computational resources for executing applications in response to requests received by the application execution system and for returning results to the requestors. In addition, each application server includes instructions for conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits: number of applications that can be executed and number of requests that can be processed per period of time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08005950&OS=08005950&RS=08005950
owner: Google Inc.
number: 08005950
owner_city: Mountain View
owner_country: US
publication_date: 20081209
---
This application is related to U.S. patent application Ser. No. 12 060 798 filed Apr. 1 2008 entitled Efficient Hosting in a Distributed Application Execution System which is incorporated by reference herein in its entirety.

The disclosed embodiments relate generally to methods and systems sometimes called application servers for hosting and executing large numbers of heterogeneous applications.

In general increases in an application s popularity could present a variety of scalability problems that negatively impact a user s experience. For example users could experience slower response times slower page loading and increased time outs on page requests. These scalability problems are typically alleviated by allocating additional capacity to the application such as more storage more memory more CPUs and more machines in general.

Allocating or installing more computing capacity may be a reasonable solution when increases in an application s popularity are experienced over a prolonged period of time or when usage of the application is predictable. Similarly when an application experiences a decrease in usage removing computing capacity previously allocated to the application may be a reasonable solution especially when the decrease is experienced over a prolonged period of time or when the decrease is predictable. However the popularity of an application is often unpredictable due to a variety of factors e.g. time of day current events advertising trends and fluctuates to a large extent which creates load spikes and dips in the application execution or hosting system.

Predefined allocations of computing resources are inefficient solutions for handling temporary load spikes and dips. Increasing or installing more computing resources to handle a load spike is inefficient since the additional pre allocated resources go unused when the spike disappears e.g. when the spike in demand subsides or the application s popularity dips . Similarly decreasing computing resources allocated to an application when its popularity declines is also inefficient since future usage spikes will require the re allocation of previously removed resources back to the application.

To complicate matters further application systems may host a large number of heterogeneous applications each with its own set of fluctuating resource requirements. Pre allocation of resources for the reasons discussed above is often an inefficient solution for ensuring consistent positive user experiences among heterogeneous applications hosted on an application system.

In an application execution system having a plurality of application servers each application server includes non volatile storage for storing a plurality of applications volatile storage and computational resources for executing applications in response to requests received by the application execution system. Each application server also includes instructions for storing in non volatile storage applications distributed to the application server for loading a plurality of respective applications into volatile storage for executing a respective application in response to a respective received request from a client and for returning a result to the request. In addition each application server includes instructions for conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions include two of more of the following a response time limit an average response time limit over multiple executions of the respective application a volatile memory usage limit that limits how much volatile memory can be used by each execution of the respective application a restriction on using non volatile storage of the application server and a requirement that any state information to be retained after returning the result is either sent to the client for storage or retained in a datastore accessible by all the application servers. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits number of applications that can be executed and number of requests that can be processed per period of time.

In another aspect of the invention a method of operating an application server in a system having a plurality of application servers is disclosed. The method comprises storing in non volatile storage applications distributed to the application server loading a plurality of respective applications into volatile storage executing a respective application in response to a respective received request from a client and returning a result to the request. In addition the method includes conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions include two of more of the following a response time limit an average response time limit over multiple executions of the respective application a volatile memory usage limit that limits how much volatile memory can be used by each execution of the respective application a restriction on using non volatile storage of the application server and a requirement that any state information to be retained after returning the result is either sent to the client for storage or retained in a datastore accessible by all the application servers. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits number of applications that can be executed and number of requests that can be processed per period of time.

In some embodiments the application execution system include a front end server which receives application execution requests from clients and returns results to the requesting clients. The front end server receives from the application master an application distribution map which may include resource usage information that can be used to route requests received from client s . More information regarding the application distribution map is provided in U.S. patent application Ser. No. 12 060 798 filed Apr. 1 2008 entitled Efficient Hosting in a Distributed Application Execution System which is incorporated by reference herein in its entirety.

The application execution system include a plurality of application servers e.g. through . As described in more detail below with reference to FIG. each of the application servers includes non volatile storage for storing a plurality of applications in a local library volatile storage and computational resources for executing applications in response to requests received by the application execution system . The application servers may include a runtime manager which as further discussed below with reference to enforces resource limits and restrictions for various resources consumed by an application during execution. In some embodiments the application execution system includes a quota system which in conjunction with the runtime manager implements a plurality of application restriction limits as further discussed below.

The application execution system also includes an application master that distributes applications from a main library having a plurality of applications among the application servers . In the embodiment shown in the main library is stored in the application master . Alternately the main library may be stored remotely from the application master such as in a datastore . In some embodiments each application of the plurality of applications in the main library is a web application that is responsive to HTTP requests. However the present invention can also be used in non web based environments in which case the applications need not be web based applications.

In some embodiments the application execution system also includes a datastore accessible to at least the application master and the front end server for sharing information about the location of applications among the application servers and resource usage or loading information with respect to the application servers .

Optionally the distributed system includes additional resources which may be located either internally or externally to the system for use when executing applications in the application execution system . For example an application executed by the application execution system may access information in one or more of the additional resources in order to process a request received from a respective client . These additional resources may include one or more of other applications and data provided by web services e.g. web feed data from sources such as blog entries headlines podcasts etc. .

The application server may remove one or more applications from volatile memory before performing operation when there is insufficient volatile memory to process the request. Alternatively the application server may automatically remove applications from volatile memory when the amount of available volatile storage is below a predefined threshold.

In some embodiments after returning the result to the request the application server can either remove the respective application from volatile storage or retain the respective application in volatile storage for responding to future requests by determining whether predefined criteria has been met . In some embodiments the predefined criteria used by the application server include usage level criteria which may include the number of requests for the application processed per period of time. The predefined criteria may also include caching criteria which may include the number of respective application instances in volatile storage available for handling new requests and the number of respective application instances handling active requests and therefore not available for handling new requests. Cached application instances are discussed in more detail below with reference to . The predefined criteria may also include error criteria which may be based on the number of errors encountered during execution of the application and the type of errors encountered. For example the application server may remove the respective application from volatile storage if severe errors are encountered during N e.g. 5 10 or 20 consecutive executions of the application.

For applications that fail to meet the predefined criteria No the application server removes the respective applications from volatile storage upon returning the result to the request . In some embodiments the application server may remove the respective applications from volatile storage according to a predefined order for removal. For example the application server may remove the least recently used application.

In some embodiments when determining which application instance to remove from volatile storage the application servers may take into account the service quality levels of the applications for which instances are stored in volatile memory. The service quality level of each application may be based on the level of service requested or paid for. Various forms of preferences for retention of application instances in volatile memory may be given to applications with high service quality levels compared to applications with lower service quality levels. For example lower service quality level application instances may be evicted before higher service quality level application instances whenever a predefined condition is true. The predefined condition may relate to numbers or ratios of lower and higher service quality level application instances loaded in volatile memory. Alternately scores may be computed to determine which application instances to unload from volatile memory and computation of the scores may take into account the service quality levels of the applications.

For applications that meet the predefined criteria Yes the application server retains the respective applications in volatile storage for responding to future requests for the application . In some embodiments the application server retains more than one application instance of the respective application in volatile storage in accordance with predefined caching criteria. In some embodiments the application server limits the number of application instances in volatile storage. For example the application server may limit the total number of application instances in volatile memory to ensure that there is sufficient volatile memory for other processing tasks. Alternatively the application server may limit the number of instances of a respective application to ensure that other requested applications have access to sufficient volatile memory to service their requests.

In some embodiments the application server may terminate execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. These execution restrictions may include application resource limits for limiting an application s consumption of system resources during runtime e.g. a response time limit an average response time limit over multiple executions of an application a volatile memory usage limit that limits the amount of volatile memory used by each execution of an application . In some embodiments the same application resource limits are applied to all applications e.g. the volatile memory usage limit is the same for all applications . For example the application execution system may terminate execution of an application if the application s run time or execution time exceeds the response time limit. Alternatively the application resource limits may vary between applications. Optionally in embodiments where the average response time for an application is frequently or periodically updated the application execution system may terminate execution of the application if the application s average response time exceeds the average response time limit e.g. 0.5 seconds . For example multiple instances e.g. all instances being executed of the same application may all be terminated if for some reason the average response time of the application extends beyond the applicable resource limit. The application execution system may also restrict the number of requests processed per period of time for an application the number of CPU cycles per period of time the stack size associated with the execution of an application and other resource usage data as further discussed with reference to Resource Usage Data .

The execution restrictions may also prohibit certain actions performed by applications using one or more predefined application programming interfaces APIs . These execution restrictions may restrict the use of non volatile storage of the application server by an application during execution by preventing the application code from reading or accessing data stored in non volatile storage. In addition the execution restrictions may govern the storage of state information by requiring state information to be retained after returning the result to either be sent to the client for storage or retained in a datastore accessible by all application servers in the application execution system. Other execution restrictions may include restrictions on opening network connections creating new processes by an application including the creation of threads by the application making system calls by an application and other system function calls. In some embodiments to maintain scalability of the application execution system with respect to number of applications that can be executed and number of requests that can be processed per period of time the execution restrictions include a restriction requiring all applications to execute within a secure execution environment. In these embodiments external access to memory locations within the application servers is prohibited. The application execution system may also monitor and enforce restrictions on the frequency of certain actions performed by the applications that impact system performance by monitoring the frequency of calls made by an application to APIs associated with these restricted actions e.g. number of times per period of time that the application calls the API s for accessing a datastore number of times per period of time that the application calls the API s for accessing an external web service .

As previously discussed with reference to in some embodiments the application execution system includes a quota system . The monitoring and enforcement of certain execution restrictions described above may involve the quota system which maintains aggregate quota information for each application. When an application needs to consume a system resource the application execution system may consult the quota system to ensure that the application has not exceeded quota or threshold limits. For example the system may include a restriction on the number of times per day the application can access the datastore e.g. 2 000 000 calls per day using the associated API e.g. the Datastore Interface . Before the application can call the Datastore Interface the system checks the number of calls to the Datastore Interface made by a respective application on all application servers to ensure that the application is still within its quota limit e.g. 2 000 000 calls per day .

In the application server loads the code for App into a generic instance in response to a request received for App . The App instance may be referred to as live or alive since it contains code that is readily executable by the application server. The App instance is loaded into a cache e.g. Live Process Cache . The cache may contain other instances of App as well as instances of other requested applications e.g. App . . . AppN . These application instances in the Live Process Cache are either busy or available although other transitional states could be used in addition in other embodiments. A busy application instance is one that is processing a current request and therefore cannot process another incoming request until it finishes processing the current request. The available instances are ready to process any received request for the respective application.

Resource usage data which allows the system to monitor the amount of system resources consumed by an application may include any combination of the following per period of time number of CPU megacycles number of HTTP requests amount of bandwidth consumed by incoming requests for the application bandwidth in and amount of bandwidth consumed by transmission of outgoing results to requests for the application bandwidth out . In addition resource usage data may also monitor the frequency of certain activities such as accessing a datastore accessing internal or external application resources e.g. web services web feeds news feeds and sending email from the application. These monitored activities are further discussed above with reference to .

Response time data includes data indicating the amount of time it takes the application to issue a response to serve a request. Violations data may include data indicating the frequency of restriction violations associated with the application e.g. number of response time violations over a period of time type of violated restriction s aggregate number of violations . In some embodiments violations data is updated during application execution. For example during execution of an application the application server executing the application may monitor and update violations data to ensure compliance with application restrictions.

In some embodiments the application master interface module includes procedures for adding or removing applications from the non volatile storage of the application server. The application master interface module may also include procedures for sending usage information on application resources and server resources to the application master. In some embodiments the front end interface module includes procedures for handling application requests forwarded from the front end . More information regarding the application master and the front end is provided in U.S. patent application Ser. No. 12 060 798 filed Apr. 1 2008 entitled Efficient Hosting in a Distributed Application Execution System which is incorporated by reference herein in its entirety.

Procedure s Live Process Cache Monitor Control for managing application instances in the live process cache may include procedures Load and Remove Application Instance Module for loading and removing application instances into the live process cache in accordance with application usage and available volatile memory as previously discussed with reference to procedures Execute Application Instance Module for executing application instances when processing application requests. The Execute Application Instance Module may also include procedures Resource Limit Enforcement for limiting resource consumption of a particular application. For example an application that consumes more resources than a limit or threshold may be terminated Terminate App Instance as previously described with reference to . The resource limit may be a predefined amount or the threshold may vary depending on factors such as the number of requests for the application. For example applications that receive higher numbers of requests may have a higher threshold before the application instance is terminated. Alternatively the threshold may also depend on the amount of processing resources e.g. one or more of CPU time wall clock time i.e. total elapsed real time memory communication bandwidth and number of system function calls made consumed by the application. The threshold s may be applied per execution of an application or to a running average of resources used over multiple executions of the application. An application instance that consumes resources above a corresponding threshold may be terminated.

The procedures Live Process Cache Monitor Control may also include application programming interfaces APIs that enable and restrict activities that applications may engage in during execution. The APIs may include any combination of the following a Datastore Interface for interfacing with a datastore e.g. the datastore a Cache Memory Interface for interfacing with shared Cache Memory and an External Resources Interface for interfacing with external resources e.g. other applications other websites web services . In embodiments having the Cache Memory and the Cache Memory Interface an application instance can store data e.g. data copied from a datastore for high speed access by all instances of the same application. The application must not rely upon retention of data by the Cache Memory for example the data stored in the Cache Memory for a respective application may be deleted whenever there are no longer any active instances of the application. The Datastore and Cache Memory mechanisms for sharing information between instances of the same application are accessibly only through the APIs provided by the application execution system which facilitates enforcement of application restrictions associated with both durable and temporary storage of data that can be shared between application instances.

The live process cache monitor control module may also include procedures for monitoring the status of application instances Monitor Application Instance Status Module . For example the status of the application instances may be busy available or any transitional state in between see .

Each of the above identified elements in may be stored in one or more of the previously mentioned memory devices and corresponds to a set of instructions for performing a function described above. The above identified modules or programs i.e. sets of instructions need not be implemented as separate software programs procedures or modules and thus various subsets of these modules may be combined or otherwise re arranged in various embodiments. In some embodiments Memory may store a subset of the modules and data structures identified above. Furthermore Memory may store additional modules and data structures not described above.

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated.

