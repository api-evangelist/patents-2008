---

title: Automatic code transformation with state transformer monads
abstract: Stateful computations are transformed into stateless computations automatically to facilitate scalability. Programmers can write code in a traditional imperative stateful style, which is subsequently transformed automatically into a stateless, state transformer monadic style. After the transformation, state is passed as an additional argument in a call and returns as a new state as an additional result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09317255&OS=09317255&RS=09317255
owner: Microsoft Technology Licensing, LCC
number: 09317255
owner_city: Redmond
owner_country: US
publication_date: 20080328
---
A system whose performance improves proportionally to added hardware capacity is said to be scalable. Scalability is an important property for distributed applications such as web services because it is desirous to scale such systems as the number of users grows. In this context developers are particularly interested in scale out which means scaling a system by adding more resources as opposed to scale up which means increasing the capacity of existing resources in a system.

Scalability is usually inhibited due to bottlenecks or parts of the system that are inherently slow. For example Amdahl s law states that if N is the number of processors s is the amount of time spent by a serial processor on serial parts of a program and p is the amount of time spent by a serial processor on parts of the program that can be done in parallel the speed up of the total system is given by Speedup s p s p N . That is scalability is fundamentally inhibited by the serial parts bottlenecks of the system.

A significant tension in making systems scalable is removing bottlenecks while keeping the overall system easy to use. For example for programmers it is convenient and commonplace to use session state across several interactions. Session state refers to a set of conditions valid for a particular user session. Consider a virtual shopping chart for instance. Here a user adds items in sequence to the cart until the session ends with a final purchase. However if a web service is stateful this introduces a bottleneck into the system since each additional web server needs to access a central store where the state of all running sessions on all servers is stored. Alternatively each server has to maintain local storage of its running sessions which means that each session must run on the server that maintains its state thus preventing scale out.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the disclosed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to code transformation to facilitate scalable programming. In accordance with an aspect of the disclosure a mechanism is provided to transform stateful code into stateless code. Programmers can write code in a traditional stateful style which can then be transformed automatically into stateless code in a state transformer monad style for instance. In this manner state can be made explicit and subsequently threaded across operations behind the scenes. As a result code can be made scalable while not burdening a programmer with generation of counterintuitive stateless code. According to another aspect state can be stored in a location or locations that maximize code scalability and or where it is most appropriate in a given context.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods pertaining to automatic code transformation from stateful to stateless are described in detail hereinafter. The most scalable system occurs where code is stateless. This eliminates serial parts of computations and hence scale out can be achieved by adding more servers for instance. However statelessness is counterintuitive to a vast majority of programmers. In fact most programmers prefer to utilize languages that are inherently stateful. For example that is the point of objects in object oriented languages which encapsulate implicit state and behavior as objects.

In accordance with an aspect of the disclosure automatic code transformation can be employed to create scalable applications while maintaining an illusion of statefullness. Programmers can write code in a convenient traditional imperative style which can be transformed into stateless code in a state transformer monadic style subsequently and automatically. Furthermore intermediate state can be stored at location s that further enhance scalability and or locations that are otherwise appropriate in a given context.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a code transformation system is illustrated in accordance with an aspect of the claimed subject matter. As shown the system includes an interface component and a transform component to facilitate transforming stateful code to stateless code.

The interface component provides a mechanism to receive retrieve or otherwise obtain or acquire stateful code. Stateful code is a type of code in which state pertaining to previous interactions is maintained. Such code can be associated with programs written in traditional imperative languages in which state is inherent or otherwise made special for example. In an object oriented language for instance object state is maintained inherently and includes an initial state in addition to any modification made thereto up until a time of observation.

The transform component transforms stateful code to stateless code. In contrast to stateful code stateless code does not maintain any state. Each transaction is independent and unrelated to any previous transaction. That does not mean however that stateful transactions cannot be captured. In accordance with an aspect of the claimed subject matter the stateful code is automatically transformed into a stateless state transformer monadic style. More specifically state can be made explicit and threaded through a sequence of operations in the same way arguments or results are passed. This enables scalability since state is not confined to a single centralized location.

The code transformation system can be embodied as a backend tool to aid programmers in production of scalable code among other things. As previously mentioned stateless code provides for the most scalable system yet for programmers this is counterintuitive as well as inconvenient. As a result a tension exists between scalability and ease of use. The code transformation system addresses this issue by allowing users to write code in traditional imperative stateful style which is subsequently and automatically transformed into a stateless implementation. After this transformation each request logically can take current state as an additional argument and returns a new intermediate state as an additional result.

By way of example consider a situation in which a programmer desires to produce scalable server executable code. A programmer can write code in an imperative stateful language. The transformation system can subsequently be employed to transform that code into a scalable form. More specifically stateless code can be generated in a state transformer monad style. However the statefulness is not lost in the transformation but rather it has changed forms. In particular the transformation provides for threading of state through stateless code as arguments and or results. In effect the code transformation system provides an illusion of statefulness for a programmer while providing an illusion of statelessness for an executing server. In any event since the code is stateless it can be distributed across additional resources when added. In other words it is scalable.

Here state and transformation thereof are explicitly visible. Rather than modifying an implicit ambient state while executing a sequence of statements or operations code that employs a state transformer monad pattern accepts a state as an additional argument and returns modified state as an additional result. This explicit state is then threaded across invocations of subsequent operations. In accordance with the previous example an initialized object is received by the first operation that adds a name. This object including the added name is threaded to the next operation that adds an address is threaded to the next operation that adds a phone number. This approach is much more scalable since the program is not dependent upon access to a single implicit state.

Turning attention to a representative transform component is illustrated in accordance with an aspect of the claimed subject matter. The transform component is responsible for converting stateful code to stateless code. This can be accomplished in one of at least two different ways. First rewrite component can rewrite the stateful code in a stateless form. More specifically use of implicit state is removed and replaced with an explicit representation of state that can be received by an operation as just another argument and output as another result. Alternatively wrapper component can be employed to transform code from stateful to stateless. Stated differently a wrapper can be applied to stateful code to make it function like stateless code. In effect the wrapper acts as a stateless interface to allow passing and receiving of state.

Referring to a programmatic assistance system is illustrated in accordance with an aspect of the subject mater claimed. Tier split component provides a mechanism to rewrite or refactor single tier applications into multiple tier applications. Tier split component broadly encompasses dividing applications for execution across different execution contexts. In one specific implementation the tier split component can generate what is conventionally known as a distributed or multi tiered application such as an application that runs across a client and server. Refactoring can be performed as a function of metadata. For example custom attributes can be attached to classes methods or the like identifying which tier certain code should execute. In addition to refactoring the tier split component can also create and deploy marshalling code to facilitate execution of code on multiple tiers.

The system also includes transform component or system which can correspond to transform component of alone or in conjunction with interface component . The transform component receives or retrieves tier split application code and transforms it into scalable code. As previously described this can be accomplished by transforming stateful code to stateless code in accordance with a state transformer monad pattern for example. In particular intrinsic ambient state can be replaced with explicit visible state which can be threaded from statement to statement. In this manner programmers can design code using inherently stateful objects that can be split by the tier split component for distributed execution and also transformed to scale by the transform component .

Policy component provides supplies information to the transform component regarding intermediate state storage. Intermediate state refers to state that is likely to be needed or desired for subsequent processing. For example an operation can output a new or intermediate state in conjunction with other results that may be threaded to another operation immediately or some time later. In accordance with an aspect of the disclosure this intermediate state can be saved or store to enable or facilitate subsequent processing. The particular storage location can vary as a function of a variety of factors. These factors or contextual information can be received retrieved or otherwise obtained by the policy component and utilized to produce a suggested storage location to the transform component . In one instance the policy component can seek to maximize scalability. Accordingly it can analyze tier split code to determine upon which tier or other location that intermediate state should be stored to maximize scalability. In another instance a factor such as security can trump scalability as a primary concern in the storage of intermediate data. For example the policy component can decide as a function of the code and or potential use preferences or policies that a client cannot be trusted to include intermediate state data and as such the intermediate state can be stored on a server even though scalability may be hindered in that instance. Alternatively it may be determined by the policy component that offline processing is desired so at least a portion of state can identified for storage on a client.

Referring to numerous exemplary architectures are depicted in accordance with aspects of the claimed subject matter. illustrates a client server architecture including a clients and servers . Moreover in this instance state is stored in a client side database . At each interaction with the server the current state is fetched from a local database serialized and sent with the request to a server . The server deserializes the state performs the requested action serializes the resulting state and sends it back to the client with the computed result.

In any case note that both the client and the server are logically decoupled from where the state is actually stored. This flexibility allows tuning of the system to different parameters. For instance when the client is a mobile phone the bottleneck is the limited bandwidth of the connection over a network and the lack of storage on the device. In other words it is impractical to send large amounts of data over the network. In that case the best scalability can be achieved by storing the data close to the server. On the other hand for rich clients or web browsers the most scalable solution is to store the state on the client. Of course there is nothing to prevent a hybrid solution where some state is stored on the client perhaps based on trust while some other state is stored on the server.

What follows are a series specific examples of aspects of the claimed subject matter. These examples are provided solely to aid clarity and understanding. Hence they are not meant to limit the scope of the claims in any way. In particular the examples pertain to specific instances of code transformation in a state transformer monad style.

Consider the following class C with a single instance field of type Z and a single method X F Y y as follows 

In contrast to the above management of session state the disclosed transformation utilizing state transformer monadic style appears below. If state is stored on the client the client code is modified to get the state from the local database and send it with the regular arguments to the server and store the new state in the database upon return 

Unlike conventional models where session state is implicitly serialized programmers have full control over state serialization. More importantly the same serialization mechanism can be used for intermediate state as for service arguments and results. It is this uniformity that allows movement of state storage between client and server. There is no distinction between regular arguments and results and the additional argument and result inserted by the state transformer monad transformation.

As previously mentioned when state is stored locally on the client it becomes possible to support offline operation in a seamless way with minimal changes to the client side code since all necessary state to perform the computation is available on the client. The client code can be specified as follows 

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

In accordance with an aspect of the claimed subject matter it is to be noted that illusions can be provided with respect to both a client side and server side. In particular client programmers are provided an illusion of statefulness to ensure ease of use and server programmers are afforded an illusion of statelessness to enable scalability. This is achieved by performing program transformation on both client and server based on the categorical notion of state transformer monads.

Furthermore as will be appreciated various portions of the disclosed systems above and methods below can include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation the policy component can employ such mechanism to infer locations for state storage given context information.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a code transformation method is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral a stateful computation is received retrieved or otherwise identified. For instance the computation can be or form part of a computer program specified in an imperative language. At numeral the stateful computation is transformed automatically into a stateless computation for example in accordance with a state transformer monadic pattern. Stated differently a computation that employs inherent or ambient state can be transformed such that is state visible or explicit and passed in a similar manner as arguments and results. The transformation can take the form of a rewrite of the actual code or injection of a wrapper interface or the like such that a stateful item can be interacted with as if it we stateless.

Turning attention to a method of code transformation is is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral contextual information is acquired concerning application code. This can be obtained or inferred from the code itself or outside factors. Such outside factors can be information regarding a target execution environment and or specified developer preferences or policies. At numeral an appropriate location for storage of state is determined or inferred as a function of the contextual information. The appropriate location can refer to that which maximizes scalability where possible. For example where it can be determined that code will be executed on a mobile device with corresponding limited bandwidth storage capacity and processing power the state can be stored on a server or other dedicated subsystem. Similarly if it can be determined or inferred that a client cannot be trusted with state then it can be stored external thereto. At reference numeral code is transformed from stateful to stateless where the explicit state or intermediate state is stored in accordance with the identified location.

The word exemplary or various forms thereof are used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit or restrict the claimed subject matter or relevant portions of this disclosure in any manner. It is to be appreciated that a myriad of additional or alternate examples of varying scope could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

Client server interactions can be utilized with respect with respect to various aspects of the claimed subject matter. As previously described code can be split and executed across one or more clients and servers which communicate via the communication framework . Furthermore state can be stored in either client data store s and or server data store s .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes contains has having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

