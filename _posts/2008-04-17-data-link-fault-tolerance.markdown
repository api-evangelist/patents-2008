---

title: Data link fault tolerance
abstract: A method is provided for automatically generating code to define and control a system of connected hardware elements. The method comprises: accepting a system configuration macro with sub-macros for system elements, subsystem elements, and connections there between; accepting a plurality of tables with a plurality of system element behaviors, a plurality of subsystem element behaviors, and a plurality of connection options; defining the system of connected elements in response to selecting sub-macros; defining the physical links between the system elements and the behavior of the system and subsystem elements in response to populating the selected sub-macro parameters; expanding the selected sub-macros; generating executable code; and, accessing the tables in response to parameters in the executable code. Advantageously, the form and function of the system can be defined with programming, or writing application specific code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07965624&OS=07965624&RS=07965624
owner: Qualcomm Incorporated
number: 07965624
owner_city: San Diego
owner_country: US
publication_date: 20080417
---
This application is a Continuation of a pending application entitled METHOD FOR AUTOMATICALLY GENERATING CODE TO DEFINE A SYSTEM OF HARDWARE ELEMENTS invented by Ripa et al. Ser. No. 10 400 380 filed Mar. 26 2003 which is a Continuation of the following applications 

SYSTEM AND METHOD FOR SWITCHING VARIABLY SIZED INFORMATION GROUPS invented by Yun et al. Ser. No. 10 023 266 filed Dec. 14 2001 now abandoned 

SYSTEM AND METHOD FOR SIMULTANEOUS DEFICIT ROUND ROBIN PRIORITIZATION invented by Yun et al. Ser. No. 10 022 673 filed Dec. 17 2001 now U.S. Pat. No. 7 079 545 

SYSTEM AND METHOD FOR GRANTING ARBITRATED BIDS IN THE SWITCHING OF INFORMATION invented by Yun et al. Ser. No. 10 029 581 filed Dec. 20 2001 now U.S. Pat. No. 7 424 013 

SYSTEM AND METHOD FOR HIERARCHIAL SWITCHING invented by Yun et al. Ser. No. 10 035 835 filed Dec. 24 2001 now U.S. Pat. No. 7 020 131 and 

SYSTEM AND METHOD FOR TOLERATING DATA LINK FAULTS IN A PACKET COMMUNICATIONS SWITCH FABRIC invented by Clovis et al. Ser. No. 10 373 139 filed Feb. 24 2003 now U.S. Pat. No. 7 352 694. All the above referenced applications are incorporated herein by reference.

This invention generally relates to software programming and more particularly to a method for automating generating code that defines and controls a system of network connected hardware elements.

Conventionally software can be generating by using macros to construct calls to a particular interface in the effort of promoting hardware independent software. However the interfaces so constructed are not configuration independent. If the system hardware connections are modified the macros must also be modified. This can be very difficult to for a chip vendor to manage as new customers decide to use a chipset of complex programmable devices especially if the original design team has been redirected to other projects.

There is industry demand for integrated circuits ICs switching systems that can be easily scaled for Network Access the Network Edge or a Core Switch Router at the high end. SCSA Signal Computing System Architecture defines a switch fabric to be the facility for connecting any two or more transmitting or receiving Service Providers.

Packets are converted into frames by ingress traffic managers iTMs . A frame is a logical unit of data which is often a small piece of a much larger data set such as a file or image. The iTMs feed the ingress side of the fabric. The switch fabric might convert the frame format to a native format and then on egress convert the data back into the TM frame format before sending the data to the egress traffic managers eTMs . If the frames are fixed size for example 53 bytes 64 bytes or 80 bytes the frames are often called cells.

A switch fabric can be protocol specific or protocol agnostic. An example of a protocol specific switch fabric would be a system designed and optimized specifically for asynchronous transfer mode ATM traffic. Another example would be a switch that handles only TCP IP traffic. The obvious disadvantage of a switch fabric hardwired to handle a specific protocol is lack of flexibility. Service providers want to sell services to a variety of customers in various industries. Protocols vary from industry to industry.

Even within one protocol type there can be protocol upgrades. For example TCP IP the machine language of Internet routers now runs primarily IPv4. This protocol successful as it has been has a lack of available addresses poor security features and no quality of service QoS provisions. The next generation Internet protocol is IPv6. It provides solutions to these limitations.

A protocol agnostic switch fabric works equally well with all protocol types however the traffic manager must be responsible for recognizing specific protocol types. The disadvantage of a protocol agnostic switch fabric is that it may be more complicated and perhaps slower than a switch fabric dedicated to a particular protocol.

The simplest way for a traffic manager to transmit a packet into a switch fabric is to transmit the packet serially along one line. Striping is a way of achieving higher bandwidth by transmitting a single packet across multiple ingress egress lines. For example a TM can transmit a packet into a switch fabric eight times as fast if the packet is sliced into eight pieces stripes by the TM and conveyed into the fabric along 8 parallel lines simultaneously. The fabric captures the packet in memory routes it to the required egress destination and slices the packet into 8 parallel lines before transmitting the packet to the egress TM.

The upside to packet striping is the potential for lower latency. There are several negative aspects of packet striping 

if one of the links is damaged 1 of 8 in the example above the entire channel is out of service degrading fault tolerance and 

the interface between the TM and switch fabric is more complicated. Circuitry must be used to slice the packet into stripes and reassemble it into packets.

Many switch fabrics now deployed and passing revenue traffic especially in wide area networks WANs use asynchronous transfer mode ATM packets. ATM packets are single cell packets with a fixed cell size of 53 bytes 48 bytes of which is the information payload. The ATM specification evolved in the 1980s and early 1990s. It was then believed that variable length multi cell packets would be too difficult to implement at rates needed for wire speed traffic. The single cell solution was a compromise that would work for voice data video data multimedia data email data file data etc. With a fixed frame size switch designs are simplified and ultimately faster.

However files are better sent in large frames. Voice switching performs better with small bursts of data corresponding to analog to digital converter time slots. Large frames and concomitant switching latencies can render a switch useless for most 2 way voice applications. Voice communications require low latency time delay . Since ATM had to work for all network data the small payload voice requirements prevailed at the expense of the large frame applications.

For large frames or packets it is much more efficient to establish a path from an ingress port card to the required egress destination and then leave this path undisturbed until the packet is completed. With single cell packets the ingress port card must bid for accept grants and then schedule each cell of a multi cell packet.

There are also Frame Relay switch fabrics. Frame Relay is a single cell protocol albeit with frame size ranging from 6 to 4096 bytes. Such switch fabrics have been deployed and passing revenue traffic since the early 1990s. These switch fabrics have generally not been used for voice data because of the large latency. Only highly compressed voice traffic works well over frame relay. Voice over frame relay was added as an afterthought by network engineers. Frame relay excels at data communications such as local area network internetworking LAN to LAN . Such communications are very high speed and bursty with non critical latency constraints.

The conventional method of switch fabric packet routing is called Store and Forward. In this method the switch fabric accepts an input packet and buffers the packet on the ingress side of the fabric making sure the packet was received intact knowing the exact number of cells in the packet. The problem with the store and forward method is the added latency of buffering the packet. In Cut through Packet Routing CPR a switch fabric is able to send the incoming packet cells to the correct egress port as soon as the destination address is known.

A switch fabric can use memory based crossbars or arbitrated crossbars. A memory based crossbar is sometimes called a shared memory switch. Ingress packets flow from the port cards into a huge memory bank which serve as the switch. From the memory bank the destination address is determined from egress port destination information in the cell headers. The problem with these switch fabrics is that they become prohibitively expensive and large from all the required high speed memory. Such fabrics cannot be used to reach terabit total switching speeds with technology available today.

It would be advantageous if new firmware executable code could be easily created for new customers by field application engineers FAEs . Preferably such code generation could occur without the need for delving into the finer details of the firmware knowing the chipset register definitions or modifying the source code. If the firmware generation process could be highly automated customers could even learn how to deploy a wide variety of system configurations themselves with little FAE support after receiving training for the chipset and its firmware environment.

It would be advantageous to deploy a new system by running a graphical user interface GUI on a workstation with the GUI prompting the user s through a process that automatically defines the form and function of the system without the usual arduous and expensive programming. Using drag and drop mouse commands pull down menus and icons the customer or FAE could create a completely new firmware build customized for a completely new hardware configuration.

It would be advantageous if the maintenance of the system firmware could be focused on the code generation system as well as the algorithmic code without the drudgery of starting from scratch for each new system or customer.

A good example of a candidate chipset for employing the method described above is the Cyclone Switch Fabric. This set of four chips has thousands of registers and 100 s of millions of logic gates. A huge and steep learning curve must be overcome for even the most seasoned firmware engineer to master the multiplicity of register settings system configuration options and complex algorithms used in the firmware. It would be advantageous of the Cyclone chipset firmware can developed for new systems with the help of automated tools.

It would be advantageous if the automatic system definition process could also be applied to a broader range communications chipsets. Other examples chipsets might include framers media access controllers MACs PHY devices used in the OSI Physical layer Physical Medium Dependent PMD devices framers network processors and traffic managers. All such devices have registers which must be loaded to configure the devices and registers which must be read to monitor the health and status of the devices. All such devices also must be connected together in a specific manner in a newly proposed system the form of the system . And all such devices have a multiplicity of parameter selections the function of the system . The system engineer solutions architect or FAE could use the automated firmware tools on customer visits to propose new solutions to customer needs.

A method is provided for automatically generating code to define and control a system of connected hardware elements. The method comprises accepting a system configuration macro with sub macros for system elements subsystem elements and connections there between accepting a plurality of tables with a plurality of system element behaviors a plurality of subsystem element behaviors and a plurality of connection options defining the system of connected elements in response to selecting sub macros defining the physical links between the system elements and the behavior of the system and subsystem elements in response to populating the selected sub macro parameters expanding the selected sub macros generating executable code and accessing the tables in response to parameters in the executable code. Alternately stated the expansion of the sub macros defines the form and the function of the network hardware with programming.

Step generates a system configuration macro. Step generates tables defining a plurality of system element behaviors a plurality of subsystem element behaviors and a plurality of connection options.

Step accepts the system configuration macro with sub macros for defining system elements subsystem elements and connections there between. Step selects sub macros. Step populates parameters in the selected sub macros. Step accepts the plurality of tables defining a plurality of system element behaviors a plurality of subsystem element behaviors and a plurality of connection options. Step expands a plurality of sub macros with populated parameters. In some aspects Step expands the parameters of the selected sub macros. Step generates executable table indexing code. For example the code can be generated by means of a complier specific to the target processor. Step elaborates the executable code. Step accesses the tables in response to parameters in the executable code. The above mentioned steps describe the steps that a user would perform to define compile and run the code.

In some aspects of the method elaborating the executable code in Step includes differentiating the executable code into code sections corresponding to system and subsystem elements. Then accessing the tables in response to the parameters in the executable code in Step includes loading accessed tables into corresponding subsystem element memories.

In other aspects accepting the system configuration macro with sub macros for defining system elements subsystem elements and the connections there between in Step includes accepting a hierarchical set of fields with subsystem elements being indentured to system elements. Then accessing the tables in response to the parameters in the executable code in Step includes substeps. Step accesses a sub table in response to indexing a table. Step loads values from the sub table in chip registers.

In some aspects expanding the plurality of sub macros with populated parameters in Step includes generating C language code. Then generating executable code in Step includes generating machine code.

To better illustrate the invention the above mentioned steps can be understood as a process of configuring a switch fabric of cards including firmware enabled chips. Then accepting the system configuration macro with sub macros for defining system elements subsystem elements and the connections there between in Step includes accepting a switch fabric configuration macro for defining switch fabric cards firmware processing integrated circuits chips on the cards and the connections between the cards. Further Step may include accepting sub macros to hierarchically define the system level slot number the slot level card type card level chip type and chip level link types and endpoint .

In some aspects accepting sub macros to hierarchically define the system level the slot level card level and chip level Step includes differentiating at the slot level between port cards to manage traffic flow in and out of the switch fabric and switch cards to manage backplane traffic flow between the port cards. In other aspects Step includes differentiating at the port card level between memory subsystems MSs and queuing scheduling QS devices. In yet other aspects Step includes differentiating at the switch card level between arbiter and crossbars. Further Step may include defining MS chip level data link connections.

Defining MS chip level data link connections may further include defining input port card ingress data links backplane data links and output port card egress data links. In other aspects accepting sub macros to hierarchically define the system level the slot level card level and chip level in Step includes defining PQ chip level control link connections. That is defining grant bid control links between input port card ingress QS devices and switch card arbiters and defining grant bid control links between output port card ingress QS devices and switch card arbiters.

In other aspects accepting sub macros in Step includes defining the chip level. Then accessing the tables in response to parameters in the executable code in Step includes accessing tables to define chip default register settings and chip modes.

Some aspects of the method include further steps. Step following the elaboration of the executable code monitors system performance. Step compares the system performance to a standard. The standard may be that the data and or control links merely interface. Alternately the standard may be a bit error rate for example or an information bandwidth. Step in response to sub standard system performance automatically repopulates selected parameters in the selected sub macros accesses tables in response to the repopulated parameters and instantiates new executable code. Note Step through may be preformed iteratively until a minimum level the standard of system performance is obtained. In other aspects the method may shut to system down if a minimum level of performance is not eventually achieved.

In some aspects elaborating the executable code in Step includes differentiating the executable code into code sections corresponding to cards and chips. Then indexing the tables in response to calling the parameters Step includes loading accessed tables into corresponding card chip memories.

In other aspects Step following the elaboration of the switch fabric with the executable code monitors switch fabric performance. Step compares the switch fabric performance to a standard. Step in response to sub standard switch fabric performance automatically repopulates selected parameters in the selected sub macros indexes tables in response to the repopulated parameters and instantiates new executable code.

The present invention methods use C macros to define the physical configuration of a multi processing packet switch fabric system in a hierarchical manner that includes automatic code generation and chip register programming.

The System Configuration File is a human readable configuration file and a C source file containing C macros combine to expand into executable code that forms the run time implementation of the a packet switch fabric system for example. The system configuration file is a human readable text file that defines the hardware layout in its entirety and performs initial programming of the chips for a discovered hardware configuration.

The present invention method is different from conventional system configuration macros in that the form and function of an entire physical subsystem is described and defined in a text file consisting of C language macros and hierarchical data tables. Typically a conventional Element Management System EMS maintains a provisioning database that describes cross connect configurations equipment and facility states. Various layers of system code use this database to program the hardware. The physical configuration of the system is opaque to this software. The physical layout connectivity is manifest only when viewed by an operator through the use of a graphical user interface GUI that creates a diagram or as a result of a report output.

The present invention system configuration file and tables makes the firmware agnostic of the complete subsystem enabling it to autonomously reconfigure itself based on its own discovery. A complex system is modeled as a hierarchy of autonomous subsystems managed by a high level communication protocol. The approach is also flexible practically every physical parameter of the system is captured in the configuration tables. For ease of use human readable macro text is pre processed not interpreted. Therefore any ANSII C preprocessor can process it. A special program is not required for interpretation as an interpreter need not be created to process the file. The invention is useful in that the tables that drive the configuration file can be used as input to a GUI that can graphically diagram how the system is configured both physically and functionally. That is the combination of system configuration file and the tables completely describe both the physical and functional aspects of the switch subsystem.

The present invention method is enabled in one specific embodiment as the Cyclone Firmware Subsystem CFS System Configuration mechanism that encapsulates the form and function of an entire physical Cyclone Switch Subsystem CSS in a text file consisting of C language macros and hierarchical data tables.

The configuration system is key to ease of use and flexibility capturing every physical parameter of the CSS in human readable tables and macros that can be processed by any ANSII C preprocessor to generate the code required to run on any variant of a Cyclone switch system. No special interpreters or proprietary pre processors are required. The CFS configuration mechanism is not hardware independent but configuration independent meaning the CFS can re program the Cyclone chips to accommodate all possible system configurations.

The configuration table approach to system programming is more useful than modifying source code because the tables can alternatively serve as input to a Graphical User Interface GUI tool that generate a picture of the system graphically diagramming how the system is configured both physically and functionally.

This section describes the purpose structure and function of the configuration table module. The Configuration Table Module consists of the system configuration files and associated methods. This architectural feature of the CFS abstracts the entire Cyclone switch fabric into one central configuration file. The configuration table allows a complete Cyclone fabric subsystem to be defined and modified without the need to re program greatly simplifying the system management overhead required to provision monitor and upgrade the packet fabric subsystem.

The SystemConfiguration.cfg file contains macros that describe the hardware configuration to the Cyclone firmware. The macros expand into object code that executes on the switch card CPU. For example the SWITCH CARD macro will be replaced by code that upon execution elaboration will instantiate a switch card object. The System Configuration File is a human readable configuration file and a C source file containing C macros combine to expand into executable code that forms the run time implementation of the Cyclone packet switch fabric system. It defines the hardware layout in its entirety and performs initial programming of the cyclone chips for a discovered hardware configuration. The format of the configuration file is itself hierarchical indentured to reflect higher and higher specificity of the system.

SystemConfiguration.cfg as described above provides the initial overall slot layout that defines which card type occupies what slot and what chips are configured on each card. The macros in this file are expanded into code by the compiler to make up methods in the ConfigTable object. At startup these methods verify the hardware configuration and read values from the tables described below to program the Cyclone chips on the cards that are found.

The System Configuration file SystemConfiguration.cfg is modified by the system designer at build time to reflect the hardware layout of the Cyclone fabric. The contents are used at compile time to generate methods that make up the Configuration Table object which is instantiated at run time to verify the hardware configuration and to program default values into the chips. The configuration information and the class methods that operate upon this information are included in the boot image that is present in the persistent store of the primary switch card either hard disk or some type of EPROM . A configuration table can also be downloaded to the primary card from the host during startup.

For each chip in addition to the chip ID there are three modes which are numbers that point to a section in the register tables. For each chip type there is a set of four register tables. The first table is simply a base table that contains an initial value for each register. The other three tables contain the mode specific values and these tables are used to modify the base tables at runtime i.e. the relevant entries in the mode tables are merged with the base tables . At runtime the firmware starts with a copy of the base tables and successively merges in the appropriate entries from the other tables. The final result is programmed in the chips. The following header files contain tables that are hierarchical with the first configuration file having the broadest scope for a particular chip type and successive files having more resolution into the settings of individual chips.

Self healing is a process by which the firmware dynamically changes system configurations to overcome system failures. Once corrected the system brings itself back to a new standard of performance. In performing self healing the firmware monitors the health of control and data links between switch chips and dynamically re routes data and control information when links fail in order to maintain optimum performance levels. Data and control traffic loading is also re balanced when cards are inserted or removed from the system. Multiple levels of control performance is supported if the number of control links limits credit bandwidth automatically switching to dual credit mode to preserve credit bandwidth. The mode changes are the result of selecting different mode tables and re programming the chip registers with values from those tables.

One aspect of Self Healing is Load Balancing. In the example system of the Cyclone Switch Fabric Load Balancing would equally balance the load of port cards being configured and monitored by a processor on a switch card. Each such processor through its dedicated Arbiter can supervise up to 32 port cards. But if there are four working switch cards in the system each processor would supervise 8 port cards in a load balanced system. If one switch card were then to fail the self healing firmware would detect this failure and a load balancing routine might reallocate ports to switch cards such that 11 port cards are each supervised by switch cards and and the remaining 10 port cards are supervised by switch card .

The Cyclone firmware is a collection of task objects that execute on the switch card CPUs. Communicating through a TCP IP connection the Cyclone firmware can be controlled by any host processor through a supplied Application Programming Interface API . Configurable entirely through the use of configuration files the Cyclone firmware is a distributed system providing fault tolerant control of up to 16 switch cards and 32 port cards to program monitor and control the Cyclone chips in a Cyclone switch fabric system. Typically a switching subsystem contains multiple intelligent switch cards that are connected through an internal network in a loosely coupled fashion.

A Cyclone Switch Subsystem CSS is generally distributed among the port cards and the switch cards. The port cards contain input and output queue chips 8505 iPQ and oPQ 8805 EDFQ and memory subsystem chips 8905 iMS and eMS . The switch cards contain an Arbiter 8605 and up to five Crossbar chips Arbiters and Crossbars are both 8605 parts but are configured by a jumper to operate in either Arbiter or Crossbar mode . Included in the CSS is a controlling CPU that is resident on every switch card.

The firmware provides the capability to resynchronize individual credit counters in the PQ chips on a periodic basis or on demand in case errors are detected by the firmware. The firmware will re synchronize the appropriate flow control counters of those particular ports for which an error was detected. Typically credit resync is the result of detecting a status flag set by the S8605 Arbiter chip indicating either a soft or permanent link error or by the system detecting that a switch card has failed. If a credit carrying control link goes down the link will be re assigned and the credit counters resynchronized.

The failure of a control link between an Arbiter and PQ indicates to the firmware that backplane tokens cannot be reliably communicated over the failed link. The port card may need to be managed by a different switch card in order to re establish connectivity to the chips on the port card. Once the self healing is complete the BP CBFC configuration of the switch may need to be updated. To update the BP CBFC configuration the register settings of the appropriate Arbiter chips must be updated followed by those on the MS chips and ultimately those on the PQ chips. Reconfiguration of the control links is performed by selecting an appropriate map from the PQ chip configuration file.

The Chip Configuration Mode is used as an index into the configuration tables to select the appropriate tables containing the chip register values for a given Chip Configuration Mode. The Family Mask defines alternate configurations to support load balancing and self healing. Family Mask is combined with Chip Configuration Mode to find compatible modes for alternate credit transmission reception. The search is done in the order that the various configurations occur in the configuration file with the most optimal configurations occurring first followed by less optimal configurations. At some point the number of links becomes small enough to change the credit mode to dual mode so that each credit returned to an iPQ is counted as two credits to halve the number of credits that are needed to keep the switch running.

When the firmware detects a control or data link error during polling it sends an internal system error message to the system error handler on the primary switch card. At the same time an error message is sent to the user. The system error handler reconfigures the switch when it receives a control link failure error and synchronizes the credit counters of all PQ s when it receives a data link failure error.

The failure of a control link between an Arbiter and PQ indicates to the firmware that tokens cannot be reliably communicated over the failed link. The port card may need to be managed by a different switch card in order to re establish connectivity to the chips on the port card this is referred to as self healing from the Firmware perspective as opposed to load balancing from the switch s perspective which balances cell traffic load among the available links . Once the load balancing is complete the Credit Based Flow Control CBFC configuration of the switch may need to be updated. To update the CBFC configuration the register settings of the appropriate Arbiter chips updated followed by those on the MS chips and ultimately those on the PQ chips.

Data link failures are detected on the receive side of the ingress MS during register polling. The Host is notified of these failures. A data link failure detected on the receive side of the ingress MS indicates that there s an error on the data link between the traffic manager and the iMS. The firmware has a map of how the TM links map between the ingress MS and egress MS chips. Using this map the system error handler will disable the data link in the eMS Output Link Enable bit mask that corresponds to the failed data link detected by the ingress MS.

Data link failures are detected on the receive side of the Crossbar during register polling. The Host is notified of these failures. Each link is monitored for 8 B 10 B violations frame misalignment byte misalignment loss of CDR lock and FIFO overflow underflow. When the link error threshold is exceeded for a link the Crossbar will initiate a report to the Arbiter over the token bus. The result is that the Arbiter will no longer grant transmissions over that link. An idle cell is automatically generated by the Crossbar for those outputs that have no corresponding valid input. The errored link is detected during register polling and the Host is notified. Disabling a link reduces switch performance and should be cause for removal of the offending card s .

Data link failures are detected on the receive side of the egress MS from backplane or another MS during register polling. The Host is notified of these failures. Failed backplane links between the Crossbar and receiving eMS are communicated to the iPQ on the same port card by the MS2PQ LINK FC signal which communicates all receive link status in round robin order. Once the iPQ gets a failed link notification it passes the information to the Arbiter during bids byte bit so that the Arbiter will stop using that link to grant connections to the respective egress port and channel and subchannel .

The iPQ indicates a credit counter timeout error in bit of its High Priority Message register register . The error is detected by a polling task which reports it to its local XbarCard task. This task does not report the error to the user nor to the system error handler task. Instead the XBarCard task intercepts the error and sends the NOT SYNCH TIMED OUT COUNTERS message to the local CreditResync task. The local CreditResync task detects which specific counter or counters have timed out by reading the timed out counters bit mask from the iPQ. The CreditResync task resets each timed out counter to the maximum number of credits depending on the current CBFC mode.

A plurality of backplane data links transfers packets between port cards. Backplane data links through k are shown connected to lines and respectively. The value of k is not limited to any particular value and may even be 1 .

Each port card includes at least one priority queue PQ having a control port on line to accept faulty packet error messages to send transfer messages line reselecting intra port card connections between ports and the backplane data links in response to error messages. The control port also communicates messages line controlling the inter port card transfer of packets on the backplane data links.

Returning the the system includes at least one crossbar having a control input on line operatively connected to accept control signals from the PQ see . As used herein the term operatively connected means indirectly connected or connected through an intervening element. The crossbar selectively connects crossbar inputs and crossbar outputs in response to the PQ control signals.

The port cards serially transfer packets on connected ingress data links through and egress data link . The port card backplane data links and serially transfer packets. More particularly the port cards receive the packets serially as each packet is received on a single link and transmit the packets serially. However the port cards typically buffer the received packets in parallel between reception and transmission. Likewise the crossbar serially transfers packets between port cards and .

The crossbar input and output interfaces are fixedly connected and selectively enabled to a backplane data link from each port card. As used herein the term fixedly connected means hardwired. When enabled the crossbar interface is enabled for the duration of the packet being serially transferred through the crossbar. Alternately stated although the backplane link on line for example is hardwired between the first port card and the crossbar packets that are received by the first port card on line for example need not necessarily be passed on backplane link as other backplane data links are typically available. The redundancy in backplane links is one of the features that permits the system to tolerate backplane data link faults. For example if backplane data link is faulty packets can be transferred from the first port card on backplane data link .

Returning briefly to in the event of a backplane data link failure on line for example the PQ selects backplane data link k line for example. Following such a reselection of intra port card connections between the ports and the backplane channels the PQ sends transfer messages on line suspending use of the backplane data link in this example data link on line .

Returning the the system further comprises a clock having a cell cycle output connected to each port card and crossbar on line . Each port card serially transfers packets on the backplane data links at the rate of one cell per cell cycle. The PQ see sends a transfer message reselecting intra port card connections within two cell cycles of receiving an error message.

Each crossbar crossbar for example includes a first plurality of crossbar input ports connected to ingress backplane data links. Shown are input ports through r. The crossbar also includes a first plurality of crossbar output ports connected to egress backplane data links. Shown are crossbar output ports through s. Again r and s are not limited to any particular value but the values of r and s are typically the same. As explained in detail below each crossbar input or output is typically to a different port card in the system.

Each port card may include an ingress memory system iMS having inputs connected to a sixth plurality of ingress ports 1 through m to receive packets for storage. The iMS has an input on line connected to the iPQ to accept transfer commands and outputs connected to a second plurality ingress backplane data links 1 through k to supply stored packets in response to the transfer commands on line . The iMS stores the received packets received from ingress ports 1 through m and can supply the stored packets to any of the 1 through k backplane data links. It is the selective connectivity between the iMS and the backplane data links that provides the system tolerance to ingress backplane data link failures.

Thus link division including backplane data link on line is associated with iMS and link division including backplane data link k on line is associated with iMS.

Returning to each port card may include egress as well as ingress characteristics. An egress PQ oPQ reselects intra port card connections on line in response to receiving an error message indicating a fault between a port card egress backplane data link and a crossbar output. Note that the error message is first received by an iPQ and the iPQ relays the message to the oPQ. A second plurality of egress backplane data links through t are represented with data links on lines through respectively. The value of t is not limited to any particular value.

An egress memory system eMS has inputs connected to the egress backplane data links through t to receive packets for storage. The eMS has an input on line connected to the oPQ to accept transfer commands and outputs connected to a sixth plurality of egress ports through u on lines and respectively to supply stored packets in response to the transfer commands. The value of u is not limited to any particular value.

The eMS includes a monitor having an input on line to accept cells received on the backplane data links a connection to backplane data link is shown. The monitor has an output on line to supply error messages to the oPQ in response to the received cells exceeding an error threshold. The crossbar may supply the packets in a sequence of cells coded in an 8 B 10 B algorithm. Then the eMS monitor would decode the received cells using the 8 B 10 B algorithm.

When cards in a switch plane fail or are removed the iPQs automatically distribute the traffic across the remaining switchplanes. Since there is a speedup across the backplane the loss or removal of a card would cause a decrease in the amount of switching resources but would not cause any traffic to stop being switched. In the case of a link failure the crossbar informs its arbiter and the arbiter ceases to grant connections for that link.

A method has been provided for automatically generating code to define and control a system of hardware elements. A switch fabric embodiment of the invention has been presented for illustration. However the invention is not limited to merely this example. Other variations and embodiments of the invention will occur to those skilled in the art.

