---

title: Extensible verification system
abstract: An extensible design verification system and methods thereof are disclosed. Pre-defined constraints from an integrated verification application are registered with a core which manages the verification system. The core is utilized by the integrated verification application to execute one or more verification tasks to generate a result. The result can be captured by a user interface. Constraints and the user-interface can be either pre-defined or user-defined. User-defined constraints and interface are managed in the same manner as those that are pre-defined. The user-defined constraints and interface are exportable for reuse by other designs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08209647&OS=08209647&RS=08209647
owner: Cadence Design Systems, Inc.
number: 08209647
owner_city: San Jose
owner_country: US
publication_date: 20080220
---
As electronic design complexity increases in many design domains including signal integrity SI electromagnetic interference EMI manufacturing and power the number and type of constraints imposed on a design has grown substantially. It is now clear that a single out of the box computer aided design CAD verification solution or application is not sufficient to accurately validate all design requirements for today s complex designs. Most companies have unique requirements based upon their design practices and products they are trying to deliver. Solution providers have not been able to support all these requirements due to the diverse range of customer needs and narrow applicability of each. Users have had to add extensions to their applications to cover their new design constraints. Adding user defined extensions to verification testing has required users to either create a standalone verification test or request the solutions provider to update a built in verification application system to include the new test.

Standalone design specific verification has historically been left to the end user to develop and deploy using a mix of applications previously delivered by the solutions provider. Most applications have an extension language and or a mechanism to access design data. The user would typically write a complete program which extracts the data computes the results based on the data and then optionally determines if the results represent a violation. The results violations are presented in a report that rarely has links back to the actual design data which is being verified. The overall solution is not well integrated to the original application so its usefulness is limited and not very modular so reuse is difficult.

One prior approach to generate needed extensions was a request made by the end user for the solutions provider to update the user s existing system to support a new verification requirement. This approach only works if 1 the new verification system fits cleanly into the existing system and 2 it applies to many customers to justify the solutions provider s costs. Even if the verification system meets these two criteria it may still not be delivered for a significant time due to resource or scheduling issues. This delay may not be acceptable in today s consumer driven marketplace.

Other factors effecting today s systems create difficulties for users requiring custom extensions. A constraint s behavior is defined in the check itself that is the code which computes the results also codes the constraint s behavior which necessitates running the application to access the constraint. These systems capture the constraints in a separate user interface through a separate file or injected via other custom software. Systems do not do a good job keeping measurements simple and coding them using a proven set of lower level functions or predicates. The verification checks provide only lengthy batch reports that can be used to review the current implementation. In certain situations the report may be too late and can result in significant design re work. In situations where batch verification is necessary and acceptable the reports generated by today s systems can be disjoint not providing an adequate level of integration.

The present invention is a computer aided design verification system. The invention includes an integrated application an editor a constraint database and a central core. The integrated application has a pre defined constraint. The editor is used for creating and viewing a user defined constraint which is provided by an external user. The constraint database is used for storing the user defined constraint and the pre defined constraint. The central core is used for centrally managing the computer aided design verification system. The central core is also used for initiating and executing a verification task generating a result and communicating the result to the integrated application.

Reference now will be made in detail to embodiments of the disclosed invention one or more examples of which are illustrated in the accompanying drawings. Each example is provided by way of explanation of the present technology not limitation of the present technology. In fact it will be apparent to those skilled in the art that modifications and variations can be made in the present technology without departing from the spirit and scope thereof. For instance features illustrated or described as part of one embodiment may be used on another embodiment to yield a still further embodiment. Thus it is intended that the present subject matter covers such modifications and variations as come within the scope of the appended claims and their equivalents.

The present invention includes an eXtensible Verification System XVS which can be configured to validate a product across all unique design challenges based upon any specific set of requirements or constraints. User defined extensions may be required for various aspects of design validation. Unlike other CAD systems XVS includes the necessary infrastructure for users to extend the built in verification system to meet all of their design needs. At the core XVS allows the user to manage the design specific constraints and the predicates measurements needed to validate them. XVS manages all new constraints enabling the user to define and capture each unique requirement. XVS manages all measurements and their association with the constraints. Once configured XVS provides seamless application integration to drive the application s implementation and provide feedback on the correctness of the design across the required domains. Thus XVS gives the end user control over the resources required for timely execution of the design verification.

With reference to a simplified data flow diagram of an embodiment of an eXtensible Verification System XVS is illustrated for verifying a computer aided design . The XVS includes an XVS core module to centrally manage all validation system operations. All constraints that are stored in a pre defined and user defined constraints definitions database are managed by the XVS core and can be accessed by a verification application module through an XVS integration module.

The creation and editing of user defined constraints are performed through an XVS constraint definition editor module and an XVS function editor enabling the user to fully model the behavior of user defined constraints.

Application a verification application initializes the XVS core by registering pre defined constraints for example measurements and predicates stored in a pre defined constraints database upon initialization of the XVS core. The XVS core dispatches manages and implements the verification tasks requested by verification application . The system is thus able to characterize and register functions and characteristics that are pre defined.

All associated data stored in a user defined syntax comparison predicate and measurement functions data base is edited and viewed with the XVS function editor module under management by the XVS core . The XVS function editor module provides an environment for the user to characterize create edit and test user defined functions to support design specific verification. A function is a pre defined operation or a user defined operation including syntax check comparison predicate and measurement which are defined in Table 1.

All constraints and their verification results are edited viewed and validated through an XVS constraint capture editor module. Any specific editing and viewing configurations are stored in a user interface UI configurations database and can be shared with all design starts. The XVS constraint capture editor module and the UI configurations database are also managed by XVS core .

The XVS thus delivers a novel fully extensible verification platform since both user defined and pre defined operations are supported and plugged into the application seamlessly for verification. The XVS methodology and infrastructure ensures all extensions have substantially identical behavior to all built in validations. The user does not need to create and manage a separate environment for design specific requirements. By providing this infrastructure XVS promotes a better integrated single less complex validation strategy that is less likely to miss violations than present extension creation approaches. Thus the XVS strengthens the correct by design philosophy.

XVS core manages all constraint definitions to ensure it has the necessary characteristics for all verification checks. The definition models the behavior of the constraint. An example of a constraint definition is The constraint is a minimum requirement used for controlling spacing and is associated with the Embedded Resistor measurement. Table 1 defines the constraint and lists a set of example characteristics and functions for a pre defined or user defined constraint. The characteristics are stored in pre defined and user defined constraints definitions database. The constraint definition will reference functions which are stored in user defined syntax comparison predicate and measurement functions database and in pre defined constraints database. It should be obvious to one skilled in the art that many of the data elements stored in databases of the invention may have equivalent meaning or use whether referenced in the singular or plural form and may thus be used interchangeably. For example a single constraint or multiple constraints may be stored and a single constraint may reference a single or multiple functions.

Modeling a constraint s behavior is done by providing access to all of its characteristics and functions. Referring to an embodiment of a constraint modeling data flow diagram is illustrated. A XVS constraint definition editor and a XVS function editor modules are illustrated providing the same functions and features as described with reference to . A set of characteristics and functions of a constraint definition data substantially corresponding to the characteristics and functions listed in Table 1 is illustrated in . The set of characteristics of the constraint definition include an ID description a data type a category units a range valid objects miscellaneous parameters a domain and an analysis flags . These characteristics are accessed by XVS constraint definition editor and are stored in pre defined and user defined constraints definitions database referenced in . Also included in the set of functions of constraint definition illustrated in are a syntax function a comparison function a measurement function and a predicate function . User defined functions are accessed by XVS function editor and are stored in user defined syntax comparison predicate measurement functions database referenced in . illustrates pre defined functions are accessed by XVS constraint definition editor and are stored in predefined constraints database also referenced in . Once a pre defined function is edited selected using XVS constraint definition editor the function is then accessible for customization in XVS function editor . Analysis flags illustrated in may include the individual flags listed in Table 1. Thus each characteristic and function of a constraint definition is supported through one of the XVS editors.

With reference to an embodiment of a managing functions data flow diagram is illustrated. An application using XVS integration and a XVS function editor modules are illustrated providing the same functions and features as described with reference to . A syntax function a comparison function a measurement function and a predicate function data are illustrated providing the same functions and features as described with reference to . Application via XVS integration and XVS function editor access the following syntax function comparison function measurement function and predicate function data. These may each include both predefined and user defined functions. also illustrates the characteristics associated with each of the functions which are described in greater detail below.

XVS core referenced in manages functions. This management includes the registration of functions the dispatching of functions that are needed for verification and the creation of user defined functions. As illustrates pre defined functions are registered with the XVS core by application through XVS integration . User defined measurement predicate syntax and comparison functions will be viewed and edited in XVS function editor . The XVS function editor provides an environment for the user to characterize create edit and test custom software to support design specific verification.

Measurement function includes a category characteristic. When associating a measurement with a constraint the categories of each will preferably match. For instance a time related constraint can only be associated with a measurement from the same time category. Predicate function includes an input parameter and a return type characteristics. The parameter defines the input to the function. When inserting a predicate into a measurement or higher level predicate XVS Editor automatically fill ins the parameter names. The user can then ensure that these parameters are populated. The return type defines what type of value is returned. The return type helps the user decide how to handle the returned value.

As referenced in Table 1 along with a constraint definition may require up to four user defined functions if the pre defined ones provided by XVS are insufficient. For example syntax function for checking the constraint value measurement function for computing results predicate function for building measurements and comparison function for determining if a violation exists can all be created by the user and managed by XVS core . The XVS core supports a common paradigm in XVS function editor to capture all of these functions using the application s extension language. The extension language may be interpretive such as List Processing Language LISP or Tool Command Language configurable graphical UI framework toolkit Tcl Tk so that the four functions can be built interactively and loaded when XVS core is initialized.

XVS function editor includes a template for the functions. Note that the template is unique for each different type of function. The XVS function editor allows the user to create edit and test a function. Unique editor features include the auto insertion of functions which return values for other objects insertion of lower level predicates which are used to build up higher level function and the ability to test a function before using it. The test command will execute the function prompting the user for input as required. For instance a syntaxCheck1 function requires a constraint value. Output from the test command will include the function s return value if successful any programming suggestions that find portability problems and certain types of coding errors similar to the results of a static analysis tool known to those skilled in the art and called lint LINT like and any intermediate results as generated by the function . Table 2 includes a LISP pseudo code type listing template for syntax function . Syntax function will validate a constraint value for a specific object and return success or fail with an error message for the later. As with all the example programming structures presented herein Table 2 is not intended as a compilable or executable portion of code but as an example programming or other structure that reflects a non limiting implementation of a process or method consistent with the present invention.

Table 3 includes a LISP pseudo code type listing template for measurement function . The measurement function will compute and return populate a unique result for an object. If the result cannot be populated the reason will be populated and an error will be returned.

Table 4 includes a LISP pseudo code type listing template for comparison function . The comparison function is used to determine if the constraint and results represent a violation. If a violation is found a negative margin is populated and the appropriate code is returned.

The ability to completely define a constraint s behavior is the first critical step in supporting design specific requirements. The definition promotes consistent behavior and provides the necessary foundation for the correct by design philosophy. XVS provides support for reusing all constraint definitions through export and auto loading for all new design starts. Thus XVS allows the user to capture all characteristics and functions necessary to model the behavior of the design specific constraints. This critical advantage ensures all constraints behave consistently by forcing a somewhat strict methodology.

XVS core will manage measurement functions which are used to compute result s for an object being validated. In this example measurement functions are either pre defined or user defined. Pre defined measurement functions are supported by application and are provided as common computations which may be reused or assist in the construction of different user defined constraints. For example the length of an object. During XVS core initialization application will register all application supported measurement functions . Thus XVS splits the constraint definition from the measurement and final validation. This new approach promotes more consistent constraint behavior between checks with fewer false or missing violations and better performance than prior tools with their constraints embedded within the application. XVS also provides easier maintenance as constraints and measurements evolve over time independent of the software that is computing the results.

User defined measurement functions are created by the user and compute a unique verification result for an object. For example the distance of an object to its nearest plane. XVS core supports the creation of user defined measurement functions as introduced above. The XVS core promotes a somewhat strict methodology for coding user defined measurement functions which is aligned with many common programming practices. Measurement functions are preferably built on common proven lower level functionality. Similar to most high level programs measurement functions should call functions predicates for example IsComponentPlaced or GetDistanceBetween2Objects that have been previously validated for both correctness and performance. If a pre defined predicate does not exist XVS core also allows the user to create new user defined predicates using function editor . To assist the user with the construction of user defined constraints XVS core provides a mechanism for application to register its pre defined constraints . For example any of the registered pre defined predicates can then be inserted into user defined measurement function by the user through XVS function editor . Unlike measurement function syntax function check or comparison function the template for predicate function requires that input parameters and return type also be defined by the user. Table 5 includes a LISP pseudo code type listing template for predicate function . XVS thus provides an environment which guides users during measurement coding and provides easy access to the necessary functionality which is an improvement over older systems.

XVS core provides support for reusing user defined measurement functions and predicates function . A large amount of work goes into building a company s specific validations portfolio. All of this work can be reused by exporting all pertinent information and configuring XVS core to load it for new design starts. XVS manages all predicates and measurements which are used to compute intermediate values and final results respectively. Thus by providing the necessary infrastructure and a somewhat strict methodology XVS delivers measurement programs that are managed to optimize both reuse and performance which is an advantage as customers validate their current and future designs.

Referring again to constraints and their verification results can be edited viewed and validated through XVS constraint capture editor . XVS core supports UI configuration database which can be configured for pre defined and user defined constraints and their associated results. XVS constraint capture editor provides the user with a consistent methodology for managing and reviewing their constraint information. Specific UI configurations can be shared with other design starts. XVS constraint capture editor provides an environment for constraint capture that ensures design specific requirements can be viewed and edited using the same functionality as any built in constraint. Consistent constraint management is necessary to ensure these new requirements can be applied to the current design and reused in the future. XVS constraint capture editor allows the user to organize UI configuration so that the new user defined constraints and their verification results are presented in the appropriate domain. For example a new electrical requirement would be added to the SI domain. Thus XVS provides standard mechanisms for constraint capture. Once UI configuration is setup the configuration can be exported for reuse with any other design.

In this embodiment of the invention XVS core supports two mechanisms to export import constraint information for a design. The first mechanism enables the user to export import all constraint information thus providing a way to backup restore an entire design. The second mechanism allows the user to export import generic constraint information. Generic constraints are those objects constraints which are not design specific. For example Net Class ECL is generic but Net ABC is not. Generic constraint information can be easily reused between designs and is more commonly referred to as a technology file. Thus XVS supports a common archiving mechanism when creating a backup or saving the requirements for reuse. The key advantage to these common capture mechanisms is that usability adoption and reuse of design specific constraints are greatly improved.

Providing implementation support is critical to ensure the application can utilize extensibility while creating the design. Referring to Application will utilize XVS core for verification validation tasks needed to optimize the implementation of a computer aided design . XVS includes an application integration model described below and illustrated in .

Referring to a data flow diagram is illustrated of an embodiment for clearing existing results to ensure stale results are removed when they are no longer valid. The same elements of verification application an XVS integration module and an XVS core are shown providing the same functions and features as described with reference to . Referring to in a first step application through XVS integration informs the XVS core of an implementation change to trigger cleanup. Then at a step the XVS core clears results for the object s affected by the implementation change . The Application Programming Interface API for clearing existing results supports a mode which controls which kinds of results are removed. The modes supported that may be applied are for example clear all results clear results in domain XYZ or clear results for constraint ABC. Then in a step the XVS core informs application via XVS integration module of violations which have been cleared in step . The verification application may be managing all violations and as such needs to be informed if any are removed.

XVS provides various mechanisms to support implementation and feedback of correctness in an integrated application. Once the constraints are defined and captured application can utilize XVS core to ensure the implementation meets these requirements. If not validated online during design implementation the constraints can be batch checked so feedback is provided on the design s overall correctness.

To supports online and batch verification XVS includes the following three API s. The first API is to clear the current results for an object according to the model referenced in . XVS core considers all results for an object up to date unless told otherwise by application . When an object changes this API is called to clear the current results. XVS core clears differently based upon the object being processed. For example if a higher level parent object is being cleared then the results on the children of the object are also cleared. The second API is to verify an object according to the model referenced in . During implementation or batch reporting the application calls the XVS core to validate an object and determine its correctness. This API allows the application to verify a single constraint or a set of constraints based upon their domain and online status. For example validate all online routing constraints. If the object has no results XVS core will trigger the appropriate measurements to generate them. For each result XVS core will then determine if a violation exists and will return an overall status after all verification has been performed. The third API also according to the model referenced in is to query an object s violation status. Using the object s current results this API can be used by the application to determine which constraints are failing and which are not. This API also allows the application to query for a single constraint or a set of constraints based upon their domain. For example a query may be directed to the violation status for all SI constraints.

When a violation occurs application is informed by XVS core using an API callback. This API enables the application to respond to each violation. Each violation will have a unique ID so that XVS core can be queried for more details. The application may respond by adjusting its implementation according to the constraint s definition. For example if a constraint is defined with a category of length and uses a minimum comparison function a violation would imply that the length needs to be increased. Alternatively application may respond by simply reporting the violation on its canvas or in a violation window. Thus XVS is tightly integrated to the application through a simple API so that the application can utilize XVS core to control the application s implementation. This tangible advantage ensures that design re work is minimized since the correct by design philosophy is optimized.

Feedback of all constraints and results is critical in understanding the design s overall wellness. XVS provides a configurable spreadsheet interface that provides the user control to organize the objects and constraints for each domain. Each spreadsheet displays the appropriate constraints and results and rolls up the worst case for easy review and correction. As with the extensions the user defined spreadsheet display can be exported for reuse in other designs. Thus XVS provides concise feedback on the design s overall wellness for requirements in each domain online or in batch mode. This is an improvement over the lengthy batch reports used to review the current implementation in prior systems. The ability to review multiple verification results in a common integrated environment means that debugging and violation resolution are improved compared to prior systems.

Although the examples and terminology used to describe the present invention have been drawn from the field of electronic design it should be obvious to one skilled in the CAD art that the programming architecture and system embodiments of this invention can be applied to any CAD verification application or suite of applications. The present invention is applicable to any design field where extensibility of verification tool features by the user is desirable including but not limited to the fields of architecture engineering bioengineering genomics graphic design and web design.

Various embodiments of the present invention have been described in the context of an application database or core that performs product validation functionalities and an editor interface operable to access and view those functionalities. An example computer system on which such functionalities can be implemented is now described with reference to . Numerous features described with reference to can be omitted e.g. a server will generally not include video display unit . Computer system may be used to perform one or more of the operations described herein. In alternative embodiments the computer system environment may comprise a server network router a network switch a network bridge Personal Digital Assistant PDA a cellular telephone a web appliance or any other machine capable of executing a sequence of instructions that specify actions to be taken by that machine.

The computer system includes a processor a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alpha numeric input device e.g. a keyboard a cursor control device e.g. a mouse a disk drive unit and a network interface device .

The disk drive unit includes a machine readable medium on which is stored a set of instructions i.e. software embodying any one or all of the methodologies described above. The software is also shown to reside completely or at least partially within the main memory and or within the processor . The software may further be transmitted or received via the network interface device . For the purposes of this specification the term machine readable medium shall be taken to include any medium that is capable of storing or encoding a sequence of instructions for execution by the computer and that cause the computer to perform any one of the methodologies of the present invention. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic disks and carrier wave signals.

In the description above for the purposes of explanation numerous specific details have been set forth. However it is understood that embodiments of the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Embodiments of the present invention include various processes. The processes may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause one or more processors programmed with the instructions to perform the processes. Alternatively the processes may be performed by a combination of hardware and software.

Embodiments of the present invention may be provided as a computer program product that may include a machine readable medium having stored thereon instructions which may be used to program a computer or other electronic device to perform a process according to one or more embodiments of the present invention. The machine readable medium may include but is not limited to floppy diskettes optical disks compact disc read only memories CD ROMs and magneto optical disks read only memories ROMs random access memories RAMs erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs magnetic or optical cards flash memory or other type of media machine readable medium suitable for storing instructions. Moreover embodiments of the present invention may also be downloaded as a computer program product wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link e.g. a modem or network connection .

While the specification has been described in detail with respect to specific embodiments of the invention it will be appreciated that those skilled in the art upon attaining an understanding of the foregoing may readily conceive of alterations to variations of and equivalents to these embodiments. These and other modifications and variations to the present invention may be practiced by those of ordinary skill in the art without departing from the spirit and scope of the present invention which is more particularly set forth in the appended claims. Furthermore those of ordinary skill in the art will appreciate that the foregoing description is by way of example only and is not intended to limit the invention.

