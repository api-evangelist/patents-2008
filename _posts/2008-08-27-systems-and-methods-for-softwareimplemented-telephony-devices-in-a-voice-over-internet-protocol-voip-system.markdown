---

title: Systems and methods for software-implemented telephony devices in a voice over internet protocol (VoIP) system
abstract: Systems and methods for providing configurable, reusable software-implemented telephony devices for use in a voice over Internet protocol (VoIP) system. A device platform data store associates account owners with information identifying at least one instance of a telephony device provided on behalf of the account owner. The instances are implemented via a computer program component which comprises (a) reusable device logic (in a CCXML document) defining the behavior of the telephony device and (b) configuration information (also in a CCXML document) comprising specific device properties for the telephony device. In response to an incoming communication, a processor accesses the device platform data store to identify the device logic of a telephony device that is to be activated, and (b) executes the device logic in accordance with the configuration information to provide the specific telephony function of the telephony device for a communication session on behalf of the account owner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08467354&OS=08467354&RS=08467354
owner: Vocalocity, Inc.
number: 08467354
owner_city: Atlanta
owner_country: US
publication_date: 20080827
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever.

The present invention s relate generally to telephony and more particularly relate to the provision of telephony functionality via configurable reusable software implemented telephony devices that provide specific telephony functions particularly useful in a digital media communication system such as a voice over Internet protocol VoIP system.

The widespread availability of the global and public computer network called the Internet has spawned a huge explosion of uses for many purposes by many people. The Internet is now used for communicating all sorts of media signals including video telephony music file sharing advertising social networking and myriads of other things. The Internet is often depicted in diagrams and drawings as a cloud because of the idea that a computing capability or web site is out there somewhere and not necessarily nearby to the actual computer user. The actual location is often not knowable to the average Internet user.

Prior to the explosion of Internet usage the most common person to person electronic communication for decades was the plain old telephone system POTS . Now even telephone communications are migrating towards digital implementations on the Internet. Telephone calls on the Internet is often called voice over Internet protocol VoIP telephony because of the usage of packet communications using the known Internet protocol IP and its variations such as TCP IP UDP and the like.

Telephone service is often implemented for businesses and other entities by use of equipment known as private branch exchanges PBX . A PBX is typically an electronic device that connects individual telephone users with handsets to other telephone users. Such connections can be within the business for intra PBX communications or with other telephony users outside the business for extra PBX communications typically via the known public switched telephone network PSTN operated by the known telephone company system operators as of 2008 such as AT T Verizon Qwest Corporation Windstream Communications and also mobile cellular service providers such as AT T Verizon Sprint T Mobile etc. Such entities are also often called telcos.

The growing capability and presence of Internet based computing communication and data storage has led to the creation of distributed computing facilities all over the world. Internet based computing need not be centrally located and with the advent of multi core computer chips and virtualization of computers a computing or communication or data storage function can now be dispersed among a number of different physical facilities often miles apart but usually invisible to the end user. Virtualization of a computer resource means that the resource need not have a single physical location for its implementation on a single physical computer but can be split into different pieces or parts run on different computers or within different processes in the same computer perhaps in different physical locations. The rise of virtualization has led to a phenomenon known as cloud computing which means that a computer or communication or data storage resource is merely out there in the cloud. In other words the resource has no readily identifiable location as far as the user is concerned but the resource is provided as a service on behalf of the user by some kind of service provider such an Internet service provider ISP .

Some PBX and call routing equipment is now being made with software components that run on a computer instead of with discrete electronics. One example is shown in U.S. Pat. No. 7 035 935 to Voois et al. Communications Service Provider Network. This patent describes a system for routing of telephony data in a private branch exchange PBX arrangement adapted to route IP telephony data. The routing arrangement includes a call control application having an object oriented programming OOP telephony interface and programmed to control the routing of calls. A device control application is adapted to provide telephony communication signals for the routed calls and to interface between the call control application and a plurality of telephony devices. Configuration information for the call control application is provided via a configuration manager. In this manner voice and data networks are allegedly effectively fused purportedly allowing the easy integration of computer telephony applications.

There is however a need for more flexible and robust implementation of various forms of telephony devices within PBX equipment and for use by telephony service providers. Many telephony functions are complex and require the coordination of different functions sometimes as ancillary or child functions and sometimes as handed off from one device to another. For example a PBX provides various related telephony functions such as voice announcement signals an answering machine announcement specific to a particular end user music on hold signals filtering of signals conferencing capability follow me capability to route calls to handsets then mobile devices then answering machines connecting to an outside PSTN line and the like. Functions such as filtering conferencing and music on hold are ancillary functions that are provided during the processing of a particular call. But functions such as follow me capability connecting to an outside POTS line and connecting to answering machine are essentially handoff type functions. Even telephone handsets have basic functions such as last number redial memory dialing conferencing selection call hold transfer call to another extension and the like. Various telephony capabilities and functions can be collected or assembled into groups or kits of related functionality but each group or kit requires complex circuitry or programming to implement.

Given the rise of ubiquitous computing communication and data storage facilities in the Internet cloud and the growing popularity of VoIP for telephony purposes on the Internet there is a need for a more robust and easily configurable arrangement for providing telephony functions for PBX and telephone service provider equipment without dedicated electronics and using the widespread availability of computing resources in the cloud.

The present inventions provide such a robust expandable and easily configurable solution and an architecture for providing PBX and other complex telephony functions of telephony service providers. The advantages of the inventions result in part by the discovery by the inventors that a number of complex telephony functions have certain aspects that are common to many users within a distributed system. By leveraging that commonality of function with reusable and universally available software components customized by configuration parameters that are specific to particular users service providers PBX operators and others a new architecture is provided that allows provision of reusable readily configurable telephony devices that can be assembled into kits or other collections. Further through the extensive use of markup languages the inventions provide for an easy and quick way for future developers to build more devices for purposes as yet not thought of

Briefly described the present inventions provide aspects of systems and methods for providing configurable reusable software implemented telephony devices particularly useful for use in a voice over Internet protocol VoIP system. A typical system in which such various inventions are useful involves the processing of digital voice and other media signals between end users often using telephone handsets or similar media devices and generally with the media signals communicated in packets via a wide area distributed communications network such at the Internet. The following described aspects are equally applicable to methods for implementing the various inventions as well as systems constructed to provide the benefits disclosed herein.

According to one aspect there is described a voice over Internet protocol VoIP system in which media signals are processed in communication sessions between an originating system and a destination system by use of at least one software implemented configurable telephony device comprising at least logic defining a behavior and configuration parameters specific to the telephony device and its behavior. Such an exemplary system comprises a device platform data store associating a information corresponding to an account owner and b information identifying at least one instance on behalf of the account owner of a telephony device provided in the VoIP system. In a preferred system each instance is identified by a distinct device identifier and preferably a globally unique identifier.

The disclosed system further comprises a computer program component corresponding to the software implemented telephony device identified by the device identifier the component comprising a reusable device logic defining the behavior of the telephony device to provide a configurable telephony function and b configuration information comprising specific device properties for an instance of the telephony device. According to one aspect the configuration information of the program component when utilized with the device logic defines a specific configured instance of the telephony device in the VoIP system that provides a specific telephony function.

Finally in this aspect the system comprises a processor responsive to an incoming request from an originating system for conducting a communication session for the purpose of processing signals between the originating system and a destination system. The processor is operative for a accessing the device platform data store to determine the device identifier of a telephony device that is to be activated on behalf of the account owner for the communication session and b executing the device logic of the computer program component in accordance with the configuration information to provide the specific telephony function of the telephony device for the communication session on behalf of the account owner.

According to another aspect a system in accordance with these inventions further comprises a document store for storing a computer executable device logic document comprising the definition of a behavior of a telephony device that provides a specific telephony function. The device logic document comprises code for effecting predetermined device functions required for implementing the specific telephony function. Further still the system preferably comprises a document store for storing a computer executable device properties document containing configuration information comprising specific properties for an instance of a telephony device. When utilized with a device logic document the device properties document defines a specific instance of the telephony device in the VoIP system. The device properties document is preferably stored in association with a globally unique device identifier device GUID for the telephony device as the device identifier

In an aspect as described with discrete device logic documents and discrete device properties documents the processor of the disclosed system is operative to effect instances of the telephony device on behalf of an account owner by carrying out the steps of 

According to another aspect the processor is further operative based upon a the properties of the device as specified in the device properties document in conjunction with b logic of the device as specified in the device logic document for determining to invoke a subsequent child telephony device for the communication session and provide a further telephony function for the child telephony device. In such an aspect the processor is preferably operative for executing the above steps recursively to invoke a plurality of subsequent child telephony devices to thereby provide the telephony functions of a plurality of related telephony devices.

In yet another aspect the processor is further operative for receiving input from an end user and carrying out the steps based on end user input in conjunction with the properties of the device and the logic of the device. The end user input may be provided via one or more of the following dual tone multifrequency DTMF signals a keypad voice signals recognized by a voice recognition telephony device.

In a further aspect in addition to the logic defining a behavior and configuration parameters specific to the device and its behavior a telephony device comprises a resource external to the device. The resource may comprise one or more of the following a telephony function provided by another telephony device voice announcement signals an answering machine announcement specific to a particular end user music on hold signals VoiceXML functions other data content signals stored in a resource storage device.

In another aspect of the disclosed system the device properties document and the device logic document are processed by a document interpreter. The document interpreter is provided as a computing function integrated with other computing functions for the VoIP system such other functions including one or more of the following a VoiceXML interpreter a SIP handling stack media signal processor.

According to another aspect the device platform data store further stores information identifying predetermined services provided in the VoIP system on behalf of an account owner the predetermined services comprising one of more device kits provided by a system operator on behalf of the account owner. In this aspect the processor of the system is further operative for in connection with providing predetermined services on behalf of an account owner for providing device kit information in the system comprising the definition of a device kit comprising a collection of a plurality of software implemented telephony devices. The device kit information is stored in association with a device kit type identifier device kit type ID corresponding to a particular kit of telephony devices. Further configuration information is stored comprising specific properties for an instance of a particular device kit that when utilized with device kit type information defines a specific instance of a device kit in the VoIP system. The configuration information is stored in association with a device kit identifier device kit ID for the device kit. Further in accordance with this aspect a kit comprises one of a plurality of different kit types.

For various aspects of the systems and methods disclosed herein the originating system may be selected from the group comprising a SIP handset an external switch connected to the PSTN network and an Internet router providing an incoming VoIP call. Further the destination system may be selected from the group comprising a SIP handset an external switch connected to the PSTN network and an Internet router for transmitting out a VoIP call.

Also in various aspects of the disclosed systems and methods the device logic document and the device properties documents are markup language ML documents and in the preferred embodiment CCXML documents. According to this aspect the device logic document and the device properties document are processed by a CCXML interpreter and the CCXML interpreter is also operative to process other resources required for implementing the specific instance of the telephony device. In accordance with markup language document processing techniques the CCXML interpreter assigns a session identifier sessionid to each of one or more resources required for implementing the specific instance of the telephony device.

According to yet another aspect the computer program component comprises code for effecting predetermined device functions including but not limited to one or more of the following event processing code scripting code session maintenance code database access database logic in stored procedures triggers for functions variable definitions URI s to other information code for executing VoiceXML documents logical expressions. Specific telephony functions include but are not limited to the following providing a telephone handset a PBX a music on hold function call transfer signal filtering call groups fax routing call forwarding call conferencing a follow me function a recording function a voice message function a message playback function a call queue function an automatic attendant function an announcement function a switching function a timer function a phone menu function a name dialer function a billing function a custom third party provider telephony function.

In the preferred system and method each account owner has a plurality of customers each of which has one or more telephony devices. Customers can be end users or can be other entities such as further dependent account owners service providers and the like.

In many aspects the incoming request from an originating system comprises a SIP message. A typical SIP message includes a SIP message identifier of a destination system comprising a DID number for a call external to the originating system and a DID number or an extension number for a call within a system associated with the originating system. Variations however of incoming requests can occur. For example the message identifier of the originating system can be one or more of the following SIP ID of the originating system DID number caller ID the MAC address of a physical handset or other identifier.

According to yet another aspect the telephony device further comprises a resource required for implementing a specific instance of the telephone device. Such a resource may comprise one or more of the following references to another telephony device one or more VoiceXML documents a URI to particular audio content a URI to multimedia content external code in an application server to perform functions of the telephony device other than those provided in the device logic or the device properties database logic relating to the telephony device s function.

According to yet another aspect the device platform data store further stores information identifying at least one instance of a telephony device as constituting a root telephony device that is to be initially activated on behalf of an account owner. In one embodiment the root telephony device is a root switch that is activated on behalf of the account owner in response to an incoming call from an external source and wherein the root switch is operative for routing the incoming call to a subsequent telephony device associated with the account owner. In an aspect involving routing the processor is further operative for determining a routing for the communication session to an ordered sequence of telephony devices and successively instantiating further telephony devices in accordance with the ordered sequence. In such an aspect a subsequent telephony device immediately following the root switch can be a PBX telephony device or a provider level root switch.

According to another aspect the root telephony device is a SIP handset that is activated on behalf of the account owner in response to activation of a physical handset by an end user associated with the account owner. According to yet another aspect the incoming request represents a call originating from a physical SIP handset that is associated with the account owner and is to be routed to an external destination. In this and other cases one exemplary telephony device comprises operational code for software implementable functions of the physical handset and another telephony device comprises operational code for software implementable functions for a switch that is connected to the PSTN network as an outbound call.

According to yet another aspect the incoming request represents a call originating from a first physical SIP handset that is associated with the account owner and is to be routed to a second physical SIP handset that is associated with the account owner. In this and other cases the incoming request represents a call originating from an external source intended for a destination equipment within the VoIP system as an inbound call.

In yet another aspect the incoming request represents a call originating from a handset of an end user of an account owner within the VoIP system intended for a destination within a PBX associated with the account owner intra PBX .

In a further aspect the incoming request represents a call originating from a handset of an end user of an account owner within the VoIP system intended for a destination within a PBX associated with another account owner inter PBX .

Turning to a further aspect involving the instantiation of child telephony devices to construct complex interconnected and related telephony functions the device logic document for the telephony function corresponds to a parent telephony device that invokes a child telephony device. In such aspects the processor is further operative for determining that the telephony function provided by the telephony device calls for the invocation of a related child telephony device as reflected by the presence of a GUID of a child telephony device. The processor is then operative for retrieving the corresponding device properties document for the identified child telephony device that is to be activated on behalf of the account owner. Thereafter the processor is operative for utilizing the configuration information in the retrieved device properties document to determine specific operational properties of the child telephony device. Next the processor is operative for determining from the device properties document a corresponding device logic document for the child telephony device. Then the processor is operative for retrieving the corresponding device logic document for the child telephony device. After these steps the processor is operative for executing the predetermined device functions of the retrieved device logic document in accordance with the configuration information from the retrieved device properties document to provide the specific telephony function for the child telephony device.

In an exemplary parent child device aspect the GUID of the child telephony device may be provided in the device properties document of the parent telephony device. In another exemplary aspect the GUID of the child telephony device is provided from routing information obtained by the parent telephony device the routing information comprising a subsequent telephony device in sequence of related telephony devices. Preferably in many aspects of the inventions the invocation of a child telephony device is recursive so as to allow construction of complex and related functions.

According to yet another aspect involving reusability a single device logic document is utilized in connection with all instances of a corresponding telephony device type for all account owners and is referenced by all corresponding device properties documents for that type. In such an exemplary case there is distinct device logic document for each telephony device type.

In yet another aspect the processor is further operative for providing a network accessible user interface for allowing a user authorized by an operator of the VoIP system to access and change configuration information of one or more telephony devices by accessing and changing the information of the device properties documents such that configuration information changes take effect in the VoIP system in real time.

In another but related aspect the processor is further operative for providing a network accessible application programming interface for allowing a user or developer authorized by an operator of the VoIP system to access and change configuration information of one or more telephony devices by accessing and changing the information of the device properties documents such that configuration information changes take effect in the VoIP system in real time.

In yet another but related aspect the processor is further operative for providing a network accessible graphical user interface GUI for allowing a user or developer authorized by an operator of the VoIP system to access and change configuration information of one or more telephony devices by accessing and changing the information of the device properties documents such that configuration information changes take effect in the VoIP system in real time. In such an exemplary aspect certain configuration information is represented as a graphical tree. Changes are effected by dragging representations of devices in the GUI on specific locations of the tree and drawing and moving lines between devices to establish device connections. In such an embodiment the task of configuring aspects of the VoIP system is made user friendly and available to a non technical common user.

A further aspect of the disclosed methods and systems involves provision of telephony services on behalf of multiple telephony service providers. In such an aspect the device platform data store stores information corresponding to a plurality of telephony service providers wherein each one of the plurality of telephony service providers has a plurality of account owners. In such a system an account owner may be any one of the following a service provider a direct customer of the VoIP system operator a customer of a service provider a branded reseller of services a private label reseller of services a PBX operator. In such a multiple service provider aspect an in other aspect a single device logic document may be utilized in connection with all instances of a corresponding telephony device type for all account owners of the plurality of telephony service providers and is referenced by all corresponding device properties documents for all customers of such account owners.

Another aspect of the disclosed systems and methods involves a marketplace and exchange for third party developers of telephony devices constructed as described herein. In such an aspect a telephony device database stores information corresponding to one or more telephony devices provided in the VoIP system by a third party device developer. In this exemplary aspect the processor is further operative for providing access to the VoIP system by the third party developer to create new telephony devices and or customize extend and or integrate existing telephony devices with additional functionality to thereby provide a third party device marketplace.

In another aspect of the third party developer involvement a telephony device database stores information associating a information identifying one or more telephony devices provided in the VoIP system by a third party device developer and b telephony device usage information identifying the usage of the one or more telephony devices provided by the third party device developer by account owners. In such an aspect the processor is further operative for tracking the usage of one or more of the telephony devices provided by the third party device developer by a particular account owner storing telephony device usage information in the telephony device usage database corresponding to usage of one or more of the telephony devices provided by the third party device developer by the particular account owner and providing a financial credit to the third party device developer in accordance with the telephony device usage information. In such a system an account owner that utilizes a telephony device provided by a third party device developer can be charged a fee for the utilization according to a usage schedule.

Yet another aspect of the disclosed systems and methods relates to high speed caches of certain data involved in implementing the telephony devices for performance and reliability purposes. In one such embodiment a system includes a high speed cache for storing of device properties documents SIP identifiers SIP ID and SIP handset device GUIDs. In such an embodiment the processor is further operative in response to the incoming request from the originating system represented by the SIP ID in the SIP message for accessing the high speed cache to extract a corresponding SIP handset device GUID and accessing the high speed cache using the extracted SIP handset device GUID to retrieve the corresponding device properties document for an initiating SIP handset.

According to another aspect a system comprises a high speed cache for storing a device properties documents b target phone numbers associated with an account owner c the GUID of a telephony device associated with each phone number of the account owner including a root telephony device that is first invoked in response to an incoming call and d the route in the form of an ordered sequence of device GUIDs of the list of telephony devices that have to be invoked to reach the telephony device associated with the phone number of the incoming call. In such an exemplary embodiment the processor is further operative in response to an incoming request from the originating system represented by an incoming call directed to a target phone number associated with the account owner for extracting the route to a telephony device GUID associated with the account owner that responds to the incoming call and accessing the high speed cache using the root telephony device GUID to retrieve the corresponding device properties document for a subsequent telephony device as specified by a retrieved route retrieved from the high speed cache.

In exemplary aspects relating to caching there is provided primary and secondary redundant parallel caches for the high speed cache and an external database as a tertiary redundant cache. In such an exemplary embodiment the processor is further operative for 

In many of the disclosed embodiments a plurality of telephony devices is associated into a predetermined kit. The data store in such a system stores information also associating one or more kits of devices provided on behalf of the account owner.

Yet another aspect of the disclosed systems and methods involves the provision of the telephony services in a cloud computing environment. In such an exemplary aspect storage for device logic documents storage for the device properties documents the device platform data store and processing functions for effecting telephony devices are implemented by different processes on different computer servers in a cloud computing environment. In such an embodiment customers resellers and private labelers of a VoIP system do not need to manage the functioning scalability reliability performance and capacity planning of the infrastructure underlying the VoIP system as these aspects are implicitly outsourced to the operator of the cloud based VoIP system.

It will by now be appreciated that the telephony devices as implemented as described herein may be of various forms and natures to provide connected related and complex functions. For example specific contemplated telephony functions include the provision of functionality for one or more SIP handsets for use in connection with the function of a PBX provided on behalf of an account owner having multiple customers each customer having multiple associated SIP handsets. Further still the device logic document is stored in association with a device type identifier device type ID corresponding to a particular telephony device type. The device properties document contains configuration information comprising specific properties for an instance of a telephony device type that when utilized with a device logic document defines a specific instance of the telephony device type in the VoIP system. In such an aspect the device platform data store further associates with the account owner device type information identified by a unique device type ID corresponding to the identification of one or more types of different telephony devices provided in the VoIP system.

It will also be appreciated that in various exemplary aspects there is a device logic document stored corresponding to each device type ID provided in the VoIP system on behalf of the account owner and wherein there is a device properties document stored corresponding to each device GUID provided for each instance of the one or more types of different telephony devices provided in the VoIP system on behalf of the account owner. In such an exemplary aspect the operation of determining from the device properties document a corresponding device logic document for the telephony device comprise a determining from the device properties document a corresponding device logic document for the device type represented by the device type ID b determining the corresponding device logic document by a universal resource locator URL contained in the device properties document and c retrieving the corresponding device logic document by the URL of the device logic document.

These and other aspects features and benefits of the present invention s will become apparent from the following detailed written description of the preferred embodiments taken in conjunction with the following drawings although variations and modifications therein may be effected without departing from the spirit and scope of the novel concepts of the disclosure.

Reference is now made in detail to the description of the embodiments of systems and methods for providing telephony functionality via configurable software implemented telephony devices between originating systems and destination systems using a session control protocol and a communication content protocol as illustrated in the accompanying drawings. The inventions may however be embodied in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are intended to convey the scope of the inventions to those skilled in the art. Furthermore all examples given herein are intended to be non limiting.

Prior to a detailed description of the invention s and aspects thereof the following definitions are provided as an aid to understanding the subject matter and terminology of aspects of the present invention s are exemplary and not necessarily limiting of the invention s which are expressed in the claims. Whether or not a term is capitalized is not considered definitive or limiting of the meaning of a term. As used in this document a capitalized term shall have the same meaning as an uncapitalized term unless the context of the usage specifically indicates that a more restrictive meaning for the capitalized term is intended. A capitalized term within the glossary usually indicates that the capitalized term has a separate definition within the glossary. However the capitalization or lack thereof within the remainder of this document is not intended to be necessarily limiting unless the context clearly indicates that such limitation is intended.

ASIC Application Specific Integrated Circuit an integrated circuit customized for a particular use. Early VoIP used ASICs and other hardware for digital signal processing specifically constructed for processing voice.

Caching a scheme whereby a copy of critical data that is accessed frequently is kept in a location that allows high speed access to it while maintaining synchronization between this copy of the data and the underlying slower source.

Call group a telephony feature whereby calling a number results in ringing several phones simultaneously thus increasing the chances that the call will be answered.

CCXML Call Control eXtensible Markup Language provides declarative markup to describe telephony call control. CCXML is a language that is based on XML and ECMA script and can be used with a voice user interface dialog specification language such as VoiceXML.

CCXML document a collection of information and computer commands contained in a file in the known CCXML format.

CCXML interpreter a computer implemented process or computer program that parses operates upon and executes the functions of a CCXML document.

CCXML properties document a CCXML document that provides information variable values and other information for creating a specific instance of an associated component e.g. a device a kit that is represented by CCXML.

Child device The device following the current device in the chain of processing a call. The child device has been launched by the current device.

Cloud a system environment to which access is provided over the internet that allows developers to deploy their applications to this environment without concern for the routine management upkeep uptime and capacity planning and growth of the infrastructure.

Computer executable document. Self contained file or other unit that can be processed by a computer to extract its components and operations and can include logic scripts pointers to other information configuration parameters variables etc. The logic and resources are common to a particular telephony function.

Configurable software implemented telephony device also device A device is specified by a CCXML document and a set of properties. It contains logic properties and resources and performs a telephony function through software.

Connection a specific instance of a lifetime of a communication between two particular identified communicating elements for example a call between two telephones a single call into a conference call that includes multiple telephones the time during which a message recorder component is storing signals represented a saved voice message etc. A connection almost invariably has a lifetime shorter than that of a session as a session is required to hold together the various resources e.g. devices memory allocations etc. required to make a connection. A connection is necessarily associated with a session but a connection can be transferred or handed off to a different session. The variable connectionid is used in the disclosed embodiments to represent and reflect a connection.

Customer a consumer of the services provided by the disclosed embodiments. The consumer may be a multi user business made up of many individual end users or a single user entity. Each customer is represented by an Account in the database.

Database a repository of information which provides means to retrieve find update delete backup and copy such information using standard languages such as Structured Query Language or SQL.

Device CCXML logic document a CCXML document that provides the core functionality computer program instructions in the CCXML format of a particular component in the disclosed embodiments such as a device or a kit. A device CCXML logic document does not contain specific parameters for an instance of a device or a kit. A specific instance of a device or a kit is created instantiated when the data of a particular CCXML properties document typically but not necessarily associated with a particular account or a particular customer or a particular service provider is processed by a CCXML interpreter and combined with the functionality of the device CCXML logic document becomes a particular instance of the device.

Device See configurable software implemented telephony device. An instance of a Device Type on behalf of an Account. Identified by Device GUID.

Device kit A collection of device instances that together fulfill the functionality of a purchased Account Service. Identified by Device Kit ID.

Device Kit Type Device types that are commonly used together are bundled together to serve a common more complex function. Identified by Device Kit Type ID.

Device type A definition or template for the device. Devices are instances of device types. Identified by Device Type ID.

GUID Globally Unique Identifier an identifier that is designed to be universally unique used to identify a specific object instance in the system in the case of the disclosed embodiment the device .

HDAP Hosted Device Applications Platform A component based environment that promotes rapid reuse for VoiceXML and CCXML compliant applications that have been built using the framework.

HDAP server a server on which a copy each of the voice server and the application server are deployed and executing.

Load balancing a technique to spread work between two or more computers network links CPUs hard drives or other resources in order to get optimal resource utilization throughput or response time.

Media file A resource managed by HDAP that is used in the execution of a device. A media file is typically an audio file but may also be an image file or a video file.

Memcache a general purpose distributed memory caching system that is often used to speed up dynamic database driven websites by caching data and objects in memory to reduce the number of times the database must be read. A giant hash table is distributed across multiple machines and when full subsequent inserts cause older data to be purged in least recently used order.

PBX Private Branch Exchange A telephone exchange that serves a particular location business or office as opposed to one operated by a common carrier or telephone company for many locations general public . PBXs connect internal telephones of a private organization and also connect them to the PSTN.

Provider An organization that sells VoIP services to its customers and uses the system described by the disclosed embodiments to provide those services. A single instance of the system described by the disclosed embodiments can include many providers. Each provider has an account of their own under which are the accounts of its customers. The database can hold a hierarchy of providers. Providers may be White Labelers ones who hide the name of original operator of the system and brand the product under their own name and Resellers who sell the product under the name of the original operator of the system. Provisioning Server A server from which an IP phone can remotely download the configuration that it needs to connect to a VoIP system and make and receive calls.

PSTN Public Switched Telephone Network The PSTN is the network for the world s public circuit switched telephone networks. These systems predate VoIP systems.

RTP Real time Transport Protocol A standardized packet format for delivering audio and video over the Internet.

Root CCXML document a CCXML document that provides the core functionality computer program instructions in the CCXML format of a particular component in the disclosed embodiments such as a device or a kit. A root CCXML document does not contain specific parameters for an instance of a device or a kit. A specific instance of a device or a kit is created instantiated when the data of a particular CCXML properties document typically but not necessarily associated with a particular account or a particular customer or a particular service provider is processed by a CCXML interpreter and combined with the functionality of the root CCXML document be become a particular instance of the device.

Service A product feature or set of features provided by devices that can be purchased provisioned and consumed. Services are purchased by customers and customers are billed for the Services that they have purchased. Identified in the database by Service Id.

Session a specific instance of a lifetime of particular components of the system identified during processing by a session identifier. The variable sessionid is used in the disclosed embodiments to represent and reflect a session. Once a session is ended by natural expiration or termination the resources associated with that session are released by the system s operating system or controller. A session can live before and after any associated active connections or no connections at all. Termination of a session necessarily ends any associated connections.

Session border controller a device used in VoIP networks to exert control over the signaling and usually also the media streams involved in setting up conducting and tearing down calls. SBCs are inserted into the signaling and or media paths between the calling party and the called party in a VoIP call.

SIP Session Initiation Protocol a signaling protocol widely used for setting up and tearing down multimedia communication sessions such as voice and video calls over the Internet. Other uses include video conferencing streaming multimedia distribution and instant messaging.

Telephony the use of equipment to provide voice communication over distances specifically via connecting telephones together.

UDP User Datagram Protocol sometimes called the Universal Datagram Protocol is one of the core protocols of the Internet Protocol Suite allowing programs on networked computers to send short messages or datagrams to one another. UDP does not guarantee reliability or ordering and datagrams may arrive out of order appear duplicated or go missing without notice. Any reliability checks of the transmitted information is performed in upper layers. Common network application that use UDP include the Domain Name System DNS and streaming media applications such as IPTV VoIP TFTP and online games.

URI Uniform Resource Identifier a compact string of characters used to identify or name a resource on the Internet or on an IP network.

Vocal OS the name of a voice server that includes a SIP stack CCXML interpreter a VoiceXML interpreter media handling capabilities ability to interface with text to speech and speech recognition systems.

VoIP Voice over Internet Protocol a protocol optimized for transmission of voice through the Internet or other packet switched networks. VoIP is often used abstractly to refer to the actual transmission of voice rather than the protocol that implements the voice transmission.

A hosted voice application for providing telephony functionality can be viewed as a group of devices connected to serve the same purpose as the hosted application. A call would then be passed from one device to another. Each device individually has enough intelligence to evaluate the call provide the telephony functionality that is expected of it for the particular nature of the call and determine the next device destination for the call. This approach also allows end users to select these devices and place them together in various other ways as desired using for example a wysiwyg what you see is what you get graphical configurator.

Turning attention to the drawings is a diagram of a VoIP system that illustrates the use of configurable software implemented telephony devices within a hosted device applications platform HDAP a device platform to provide telephony functionality. The VoIP system provides telephony functionality from the device platform between customers connected to the Internet and PSTN phones connected to a public switched telephone network PSTN . The PSTN is connected to the Internet through VoIP PSTN gateway and or VoIP trunk providers .

The device platform enables rapid reuse for VoiceXML and CCXML compliant applications that have been built using its framework. Each discrete functionality is serviced by a telephony device that is dedicated to that particular type functionality. The device platform connects this group of components together into a specific application. For example one telephony device could handle recording another handles switching based on an input for routing a call in a particular fashion another receives audio and another sends audio. Of course much more complicated telephony devices could be used also. Any desired phone functionality can be implemented by some particular collection of these telephony devices .

Customers use the Internet to connect to outside telephone systems. At their premises they typically have IP phones connected to a Local Area Network LAN that is connected to the Internet through some combination of routers and firewalls. The IP phones use the Session Initiation Protocol SIP for signaling and use the Real time Transport Protocol RTP for audio. IP phones can automatically provision or configure themselves by fetching provisioning files through the Internet . Various types of IP phones use protocols ranging from FTP File Transfer Protocol and TFTP Trivial File Transfer Protocol to HTTP Hypertext Transfer Protocol .

Telephony devices within the device platform may also access subscriber PSTN phones that are connected to the PSTN . When a PSTN phone desires to talk to someone on a customer s IP phone the PSTN provider routes the call to the CLEC Competitive Local Exchange Carrier that owns the customer phone number and in turn the call is routed to a VoIP PSTN gateway and or VoIP trunk provider .

The PSTN accesses the Internet through VoIP PSTN gateway and or VoIP trunk providers that provide either PSTN VoIP gateway services SIP trunks or both. Larger providers sometimes have both services. It is not unusual for a VoIP PSTN gateway provider to also be a CLEC. For purposes of the inventions described herein it is sufficient that calls from PSTN phones are converted to VoIP external to the device platform and that calls that are received into the device platform arrive as VoIP calls. Similarly outgoing calls from the device platform use VoIP.

SIP and RTP traffic goes through the Session Border Controllers SBC . The SBCs perform registration authentication routing NAT network address translation traversal media anchoring load balancing and prevention of denial of service attacks. Registration keeps track of the IP address and SIP port for each customer phone. Authentication ensures that only authorized phones can send calls from the device platform . Routing ensures that calls are sent to the correct providers based on the information from to in the SIP header. NAT traversal handles issues stemming from network address translation at the on premise router firewall. Media anchoring provides that for certain types of calls the audio is anchored at the SBC rather than forwarded to the voice servers thus allowing the calls to pass directly to the other party via the SBC. Load balancing ensures that calls are balanced relatively equally across the available voice servers . Prevention of denial of service attacks provides protection against malicious calls or hack attempts through calls that can overwhelm and or bring down the system.

Firewalls receive the non call traffic such as for example HTTP from browsers that are being used to configure the phone system and FTP TFTP or HTTP from phones retrieving their provisioning files. The firewalls send the HTTP web traffic to the load balancers and send other traffic to the respective destinations.

As noted above the load balancers receive HTTP web traffic and balance the load across a bank of web application servers .

The voice server also referred to as a voice application server includes functionality provided by different components which may also be independent modules including a SIP stack a CCXML interpreter a VoiceXML interpreter a media processor and a TTS ASR engine . The voice server executes the aspects of the device platform that are directly telephony related.

The SIP stack receives processes generates and sends SIP messages compliant with the W3C SIP standard. To facilitate call control events are sent to the CCXML interpreter .

The CCXML interpreter interprets CCXML documents. CCXML is a W3C draft standard for an XML and ECMAscript based language for exercising call control. CCXML absolves the programmer from dealing with direct protocol level programming and provides a flexible and rapid mechanism for call control i.e. establishing joining un joining conferencing holding un holding transferring tearing down calls etc. The CCXML interpreter sends events to the SIP stack based on the directives in the CCXML documents. The CCXML interpreter also maintains and tracks sessions connections and channels and provides the abstraction layer between CCXML and the communications protocol in this case SIP.

The VoiceXML interpreter interprets VoiceXML documents and works closely with the CCXML interpreter . VoiceXML is another W3C standard for an XML and ECMAscript based language and is used for creating dialogs that control voice user interfaces. VoiceXML dialogs can be used to program complex interactions between an automated phone system and a user by using DTMF digits speech recognition and text to speech synthesis. VoiceXML enables the developer to program these interactions without the need for the programmer to understand and master the underlying telephone and communications protocols.

The voice server uses the media processor to handle media RTP audio . The media processor is able to receive and transmit media as well as mix audio for conferences. The media processor is also capable of handling multiple codecs and converting from one codec to another.

The TTS ASR engine uses text to speech TTS synthesis to create automated prompts and greetings and uses advanced speech recognition ASR to recognize speech for user input in the place of DTMF digits. The TTS ASR engine uses industry standard protocols for processing text to speech synthesis and speech recognition. Requests to the TTS ASR engine originate in VoiceXML documents that are interpreted in the VoiceXML Interpreter .

A database holds customer data device definition data device configuration data call usage log data state information for certain complex types of calls conferencing call queues user permissions data billing data and many other configuration parameters that drive and control the behavior of the system. The primary interface into the database is from the application server .

The application server is actually a bank of servers that perform several functions including 1 execution of those aspects of the device platform that are not directly telephony related 2 serving the CCXML and VoiceXML documents requested by the CCXML interpreter and VoiceXML interpreter 3 dynamically generating CCXML and VoiceXML documents in response to certain requests 4 managing access to the database and converting data as appropriate into object oriented objects or CCXML properties documents as appropriate and 5 serving the web user interface application through which customer users and administrators can configure and manage the phone services offered by the telephony devices in the device platform .

The device platform is the engine that enables and supports the telephony device technology by providing the services necessary for telephony devices to exist and execute. The key functions provided for by the device platform include service provisioning real time configuration device lifecycle management permissions monitoring alerting device caching loop detection and usage tracking. It should be noted that some functionality of the device platform is executed within the voice server whereas other functionality is executed in the application server and some functionality is executed in both servers.

The service provisioning function of the device platform is performed in the application server and involves the creation of the correct number and type of telephony devices when a customer purchases a new service. Further the telephony devices need to be initialized with the correct properties and hooked together in the correct manner by default so that the service is plug and play therefore being useful and usable immediately following the purchase time provisioning.

The real time configuration function of the device platform is performed at the application server and refers to the ability provided by the device platform for device properties to be configured on the fly a key benefit of the software telephony device architecture. Users and administrators or developers can make changes to the configuration through a user interface or Application Programming Interface API and these changes take effect immediately so that on the very next call any changed telephony devices follow the new configuration.

The device lifecycle management function of the device platform refers to the core of device execution. The device platform has the capability to perform 

The permissions function of the device platform is handled at the application server and includes enforcement of rules on which users can configure and use each telephony device .

The monitoring and alerting function of the device platform is handled at the voice server and the application server . The device platform tracks the progress of telephony devices and exposes that information from the voice server . The application server pulls this information and can display it and provide alerts accordingly.

The device caching function of the device platform is performed at the voice server and the application server . Device logic CCXML documents are parsed cached and reused. Device properties CCXML documents are generated once and then used repetitively from cache. Other critical information including device routes and relationships between phone numbers SIP ID and telephony devices is stored in fast caches. These caches then have to be kept in sync with the master copy of data usually in the database and this is done by the device platform .

The loop detection function of device platform is performed by the voice server . Bad device configurations can sometimes lead to loops. The device platform detects such conditions has configurable thresholds for different kinds of loops and kills the loop when the thresholds are exceeded. The condition is reported via an automated email to the system administrator.

The usage tracking function of the device platform is performed by the voice server and the application server . The device platform at the CCXML level emits critical log information that is sent to the application server which collates and processes these logs according to complex logic rules to track and bill usage.

Telephony devices are written by device developers and deployed on the device platform much like Java code is written and deployed into a Java Virtual Machine. A telephony device typically comprises many discrete elements as shown in and as further explained in detail in . Telephony devices work with each other to process calls. The device developer does not need to know how the device platform is built but rather just needs to know what the telephony device is desired to do. Telephony devices are discussed in further detail below.

The device platform provides an environment where a software implemented configurable telephony device performs a particular function over and over regardless of the context and thus where different telephony devices can be configured in multiple ways and used together or separately for any conceivable telephony functionality.

For example a filter device is provided with certain rules and then accepts or reject calls according to those rules. Additionally it can be configured to drop the call or forward the call to another device. A filter device would be useful for enabling disabling call recording enabling a supervisor to listen in on a call to a call center agent or to route all international calls to a special call center in a different time zone. Rather than recreating these functions in different places a single telephony device can be configured to do different things at different times and can be placed in the path of the call through software configurable connections.

Based on this paradigm the basic reusable building block component of any voice application running on the device platform is a software device. A simple telephony device performs an atomic function that is essentially the same regardless of the context in which it is invoked. An example of a simple telephony device might be a voicemail device that in its default configuration plays a greeting records the message and notifies the voicemail owner that messages are waiting. Runtime property values can be used to influence specific actions of a device instance. So for example each person using the voicemail device may play a different greeting. Other examples of basic devices are a SIP handset device a PSTN device a switch device etc. Examples of more complex devices are a PBX and an auto attendant. Device Kits are groups of telephony devices made up of other simple or complex devices. For example an extension device kit may be made up of a follow me device a SIP handset device a PSTN device and an answering machine device. Telephony devices are hooked up together much like they would be if they were physical devices that make up an office phone network. A diagram showing the logical connection between telephony devices is a configuration graph.

According to aspects of the described inventions the best mode currently contemplated for implementing certain functions described herein is CCXML the Call Control eXtensible Markup Language. CCXML provides declarative markup to describe telephony call control. CCXML is a language that can be used with a dialog system such as VoiceXML. Details of CCXML and its implementation are provided by W3C World Wide Web Consortium http www.w3c.org and can be found at http www.w3.org TR ccxml the contents of which are incorporated herein by reference and made a part hereof.

As will be known to those skilled in the art CCXML can be employed to provide a complete telephony service application comprised of Web server CGI compliant application logic one or more CCXML documents to declare and perform call control actions and to control one or more dialog applications that perform user media interactions. CCXML as expressed in CCXML documents that are executed by a CCXML interpreter is utilized in the disclosed embodiments and aspects to store locate and implement root device types devices kits types kits and instances of such root device types devices kits types kits as well as properties of such items.

Also as will be known to those skilled in the art CCXML documents contain scripts for executing specific computational and control functions namely via the known ECMAScript variable definitions specific values for variables in accordance with the definitions handles events that occur during the operations of the function. The main aspects of a CCXML implementation include a event processing b scripting logic and control c maintenance of a life cycle of a session or connection d definitions of variables expressions and other data required to provide the function and e if provided signal processing functions such as conferencing bridging filtering setting up and breaking down connections etc.

The configuration graph has the appearance of a hierarchy or an inverted tree. At the root of the tree is the root switch . The root switch is responsible for making calls to destinations outside the system as well as routing inbound calls to the right next device. The root switch is directly connected to one of two kinds of devices either provider root switches such as root switch or PBX devices of direct customers such as PBX . The PBX device usually is the entry point into the phone system device kit and is usually accompanied by an announcement device that can play recordings a name dialer that can list the names of all the users within the PBX and allow them to be reached by extension number of phone menu option and a music on hold device that plays the chosen audio file that the customer has chosen for their hold music for their company s phone system. All calls into customer go through the customer PBX device and likewise all calls into customer go through the customer PBX device . The focus of configuration graph is customer so the only third level of devices shown are the ones for customer but it should be noted that provider root switch and customer PBX will normally have a number of similar devices underneath them in the tree as well.

A PBX device is usually connected directly to other devices that have an extension number. Accordingly customer PBX is shown to be connected to an auto attendant device kit to a call group device kit to an extension device kit a call queue device kit and through a filter to another extension device kit . When a call comes into the PBX device from the root switch the PBX looks first to see if the dialed digits match any of the extension numbers known to it. If so the PBX routes the call to the device that the extension number points to. If there is no match then the PBX device makes a getroute call to the application server passing the dialed digits. The application server returns a route to the number in the form of a list of devices to traverse. The PBX hands the call off to the first device in the list.

The auto attendant device kit is made of an auto attendant device a time switch device and a call tree device . The detailed functions performed by these are illustrated further in configuration graph but in summary an auto attendant answers a call plays a phone menu takes user input and routes the call based on the input.

The call group device kit has a follow me device at its entry point. The follow me device first sends the call to the call group device next to it and if there is no answer then moves on to the answering machine device . The call group device in turn is connected to two PSTN devices that it calls simultaneously. One of the PSTN devices is connected to extension device kit and the other through a filter to extension device kit . These are the two extensions that will be rung if a call reaches the call group .

Note that the two extension device kits are not identical. Extension device kit is configured to received calls into the follow me device which in turn will first try a SIP handset device which will ring employee A s desk phone and if no answer then call a PSTN device which routes back to the customer PBX to make an outbound call to a cell phone. If there is no answer from the cell phone within a certain amount of time then the follow me sends the call to the answering machine

Extension device kit is configured slightly differently. It will receive calls into its follow me device which in turn will first try a SIP handset device which will ring employee B s desk phone and if no answer then call a PSTN device which routes back to the customer PBX to make an outbound call to employee B s home phone. If there is no answer from the home phone then the follow me device will send the call to the next PSTN device which forwards to employee A s follow me through PBX within a certain amount of time. Still if there is no answer then the follow me device sends the call to the answering machine device . This example shows how the same device kit type extension in this case can be configured differently with different numbers of devices within to serve slightly different functionality.

All calls to extension device kit pass through the filter . The filter device evaluates each call against its set of configured rules such as block international outbound or block all inbound calls and decides whether to let the call through or not.

The call queue device kit is made of two devices call queue device and call queue music on hold . When a call comes into the call queue device it determines if any agents assigned to the queue are logged in and is so are they available. If so it sends the call to the first available agent based on the chosen algorithm if not it connects the caller to the call queue music on hold device . It then keeps checking for available agents and as soon as one becomes available it moves the call to the available extension through the PBX

Note that at a given moment in time any number of calls can be going on through this configuration graph and indeed through any one device. For each call going through a device a separate copy of the device executes. Generally speaking all upstream parent devices stay running while the call is being processed by downstream devices until the call ends. In most cases upstream devices do not do anything active after passing the call but in some cases they might do some tasks such as in the call queue device case where it continues to look for available agents.

The power of the configuration graph is not the specific configuration that is depicts but the flexibility that it represents and illustrates.

A call is received from an outside system for a phone number associated with an auto attendant for customer . The auto attendant answers the call and plays a phone menu for the caller. The phone menu is dependant upon the time of day and provides messages such as Thank you for calling Acme Computers. For sales press one for support press two . . . and the like.

After the caller makes a choice pressing phone button one for example the call is transferred to a sales call group. A sales call group is a telephony function that simultaneously rings all phone extensions in the sales call group. The first to answer is connected to the caller and the remaining extensions stop ringing. In this instance the sales group has two members employee A and employee B that are associated with sales.

Employee A has follow me functionality set to prioritize the ringing of various phones. Employee A s office IP desk phone is to ring first followed by their mobile phone and then their answering machine. Similarly employee B has follow me functionality set to ring their office IP desk phone first followed by their home phone followed by employee A s office IP desk phone and finally to employee B s answering machine. The time allowed for each phone to be answered before ringing the next phone is configurable and may be different for each phone.

Additionally a filter is set up to block certain kinds of calls for employee B. The filter might be set up to prevent employee B from making international calls and also from receiving calls from toll free numbers.

Further details of the configuration graph show that the outside calls are received from an external source by the root switch at step 1. The outside call is received from a phone that is not known to the system and may for example be received from a home phone a business phone a cell phone an IP phone PSTN phone or any other type telephone.

At step 2 the root switch performs a route lookup based on the destination phone number and determines that the phone number is owned in the system by customer . The call is then routed to a PBX device for customer .

Next at step 3 it is determined that the phone number does not match an extension number known to the customer PBX device . The PBX device performs a route table lookup on the destination phone number and determines that the phone number is owned within its account by an auto attendant device within an auto attendant device kit . The call is then routed to the auto attendant device . A device kit is a grouping of multiple telephony devices that are often used together for a common complex function. The auto attendant device kit includes the auto attendant device a time switch device and a call tree device .

At step 4 the auto attendant device determines that there are time of day related rules to be followed for this call and the call is sent to a time switch device .

At step 5 the time switch device determines that for the current time slot the call needs to be sent to a specific call tree device . An example would be if a customer has one phone menu for business hours a second phone menu for non business hours and a third phone menu for holiday periods. A time switch device routes calls to different devices according to time considerations.

The call tree device that services the particular time period receives the call and plays a phone menu message to the caller at step 6. An example phone menu message might be Thank you for calling Acme Computers. For sales press 1 for support press 2 . . . In actuality the call tree device uses an announcement device not shown in to play the message. After playing the phone menu message the call tree device waits for a response input from the caller. After receiving the caller response input i.e. caller presses key one on their phone for sales the call tree device s properties indicate that for this response the call goes to a particular extension. The extension in this example applies to the sales call group however the call tree does not and need not know this particular information. The call tree device sends the call back to the customer PBX device with the particular extension number corresponding to option one from the phone menu s properties.

The customer PBX device performs a lookup from its extension routing table to find the device GUID of the device that owns the received extension number. The call is then sent to that device at step 7. As far as the PBX device is concerned the call is routed to an extension while in actuality the extension number applies to a call group device kit . Again the PBX device does not and need not know that it is a call group device kit rather than an actual extension.

The call group device kit includes a follow me device entry point device a call group device an answering machine device and PSTN devices . A call is received by the follow me device and is first sent to the call group device at step 8. Optionally and based upon configuration an unanswered call may be sent to the local answering machine device of the call group rather than to an answering machine corresponding to one of the member extensions.

The remaining steps in and are executed in two parallel threads of execution that do not depend on nor wait on the other thread. Steps in the first thread are numbered normally while steps in the second thread are numbered with a prime indicator. It is not necessary unless specifically indicated that a step number with no prime indicator and the same step number with a prime indicator occur at the same exact moment in time. The timing depends on the number and length of execution of each of the preceding steps for each thread of execution. Each pair of steps below is described together merely for convenience and do not represent concurrent timing. Of course it will be apparent to those of skill in the art that many and different additional threads both concurrent and not could also be included in this configuration graph .

The call group device performs a look up on its extensions property to determine which device or devices are to ring simultaneously for the call. It should be noted that a call group device can ring the extensions in the same account but also any other number including outside numbers. PSTN devices are used to send calls to extensions and also to outside numbers. Thus the call group extensions property has a list of PSTN device GUIDs. In this example the call group device initiates simultaneous calls at step 9 to PSTN device corresponding to employee A and at step 9 to PSTN device corresponding to employee B each of which are listed in its extensions property. Of course if there were more PSTN devices listed in the extensions property each would also be called.

Each of the PSTN devices has an outbound device property denoting what next device to send the call to. If the phone number to be forwarded is a DID the outbound device is the PBX device whereas if the phone number is an extension number the outbound device is the extension s follow me device or filter device. One PSTN device is configured to send its calls to employee A s follow me device at step 11. The other PSTN device is configured to send its calls to a filter ahead of employee B s follow me device

The filter corresponding to employee B evaluates its rules for handling calls at step 12 and determines that this call should not be blocked. The call is then sent to employee B s follow me device . Filters are typically used to block certain kinds of calls for example to prevent employee B in this instance from making and or receiving certain kinds of calls.

A follow me device typically has a list of telephony devices to be tried in sequence with a configurable amount of time between each and after which it moves on to try the next telephony device in the chain until a telephony device answers. In this example both employee A and employee B have set their follow me devices to first attempt to ring their IP desk phone at their respective desk. Employee A s follow me device sends its call to the SIP handset at step 13. Employee B s follow me device sends its call to the SIP handset at step 13 . It should be noted again that these are independent actions and can happen at slightly different times for each of the follow me devices.

At step 14 upon receiving a call employee A s SIP handset device makes a call sending an SIP INVITE message to its corresponding SIP phone device identified by the device ID property. The invite is actually sent to a session border controller not shown which knows the IP address for each phone when given the Device ID also called the SIP ID . The Device ID is not to be confused with the GUIDs that identify the software implemented configurable telephony device disclosed in the present invention. Similarly at step 14 upon receiving a call employee B s SIP handset device makes a call to its corresponding SIP phone device

At step 15 the IP desk phone at employee A s desk rings. Employee A is not at the desk and the phone is not answered. After the configured delay the follow me device cancels the ringing. Similarly at step 15 employee B s IP desk phone rings is not answered and the follow me device cancels the ringing after the configured delay.

Employee A s follow me device then sends the call to the next device in its list. Employee A has set his follow me device to forward the call to a mobile phone upon no answer at his her desk. Since a mobile phone is an outside number the call is sent to a PSTN device at step 16. Similarly employee B s follow me device is set to forward the call to his home phone number again an outside number and the call is sent to a PSTN device at step 16 .

A PSTN device uses the account s PBS to forward calls to outside numbers. At step 17 employee A s PSTN device sends the call to the customer PBX device along with the phone number. Similarly at step 17 employee B s PSTN device sends its call to the PBX device along with the phone number. It should be noted that these are two separate calls and further that each PSTN device creates its own copy of the PBX device and hands off the call its respective instance.

Each independent instance of the PBX device receives a call then looks up the destination number a 10 digit DID in its extension routing table. Since the numbers are not extension numbers no match is found. Each PBX device instance makes a request to the application server to retrieve a route for the call the phone number is passed with the request . Upon determining that the phone number is not known and is therefore an outside number the application server returns a message indicating that the route failed i.e. it does not have and cannot determine a route for the call. Each PBX device has no way to route the call within the system so the call is sent to its outbound device the root switch at step 18 for employee A and at step 18 for employee B. It should be noted again that these are two separate device instance copies of the PBX device performing this logic independently of the other. If there were ten employees with similar configurations then there would be ten copies of the PBX device that would execute whenever the respective calls reach the PBX.

Upon receiving the call the root switch also attempts to acquire a route for the call with the received number and also concludes that the call is for an outside number and then sends an INVITE to the phone number in the outside world outside the system through the session border controller not shown . The session border controller sends the call to a SIP trunk provider having access to a CLEC for resolving the number to the final destination employee A s cell phone . Similarly the other call is routed to employee B s home phone . Since these are two separate calls both phones ring. Whichever of employee A and employee B first answers is connected to the caller. Assuming that employee A answers first the call is established caller and employee A are connected and media audio in this instance being flowing in both directions.

Since the caller is connected to employee A the call group device sends a message to terminate the other call that is in process of trying to be established if employee B answers . A CANCEL SIP message is sent through the session border controller to the VoIP provider that passes on the equivalent signal to employee B s home phone and employee B s home phone stops ringing.

The call processing is initiated when employee A picks up his IP phone handset and enters a 10 digit phone number. Employee A hears ringback to indicate that the call is being processed and that the outside phone is ringing. The target phone rings and the cell phone subscriber answers the call whereupon employee A and the cell phone subscriber begin to talk.

Further details of the configuration graph show that employee A initiates a call process by dialing a 10 digit phone number on the IP desk phone at step 1.

At step 2 the call comes in from the handset and is detected as such by the system due to the presence of the known SIP ID in the from field of the SIP message header. The SIP ID is passed to the application server to obtain the device GUID of the SIP handset device which represents this phone in the system. The SIP handset device is then invoked.

The SIP handset device determines that this is an outbound call and hands off the call to the device identified by its outbound call property at step 3. The outbound call device is a follow me device within the extension device kit that includes the SIP handset device . Again it should be noted that when a device hands off a call to another device the first device does not know and does not need to know the type of the second device. Thus the call connection is sent to the follow me device

At step 4 the follow me device determines that the call is an outbound call and sends the call to the device specified in its out device property the PBX device of the account in which the follow me is a part. Thus the call is sent to the customer PBX device

The PBX device receives a call then looks up the destination number a 10 digit DID in its extension routing table. Since the numbers are not extension numbers no match is found. The PBX device makes a request to the application server to retrieve a route for the call the phone number is passed with the request . Upon determining that the phone number is not known and is therefore an outside number the application server returns a message indicating that the route failed i.e. it does not have and cannot determine a route for the call. The PBX device has no way to route the call within the system so the call is sent to its outbound device the root switch at step 5.

Upon receiving the call the root switch also attempts to acquire a route for the call with the received number concludes also that the call is for an outside number and then sends an INVITE to the phone number in the outside world outside the system through the session border controller not shown . The session border controller sends the call to an SIP trunk provider having access to a CLEC for resolving the number to the final destination target cell phone . The phone rings and the cell phone user answers the call. The call is established employee A and the cell phone user are connected and media audio in this instance being flowing in both directions.

The call processing is initiated when employee A customer uses an IP phone handset and enters a 10 digit number. The number being called is the toll free support line at customer . Employee A receives hears a ringback briefly followed by a phone menu message indicating that it may be a few minutes before the call is answered. After the phone menu message plays the hold music begins as employee A is waiting on hold. Employee A is placed on hold because the only agent on duty to receive the call employee B of customer is busy on another call. Employee B s phone rings once he she becomes available. Once employee B answers the call is connected.

Further details of the configuration graph show that employee A initiates a call process by dialing a 10 digit phone number on the IP desk phone at step 1.

At step 2 the call comes in from the handset and is detected as such by the system due to the presence of the known SIP ID in the from field of the SIP message header. The SIP ID is passed to the application server to obtain the device GUID of the SIP handset device which represents this phone in the system. The SIP handset device is then invoked.

The SIP handset device determines that this is an outbound call and hands off the call to its outbound call property at step 3. The outbound call device is a follow me device within the extension device kit that includes the SIP handset device . Thus the call connection is sent to the follow me device

At step 4 the follow me device determines that the call is an outbound call and sends the call to the device specified in its out device property the PBX device of the account in which the follow me is a part. Thus the call is sent to the customer PBX device

At step 5 the PBX device receives a call then looks up the destination number a 10 digit DID in its extension routing table. Since the numbers are not extension numbers no match is found. The PBX device requests a route for the call from the application server the phone number is passed with the request . The application server determines that the number is known and calculates the route from the customer PBX to the device within the system that owns the number customer s call queue device . The route is returned to the customer PBX which then hands the call of to the first device in the route which is the root switch .

Upon receiving the call the root switch also attempts to acquire a route for the call at step 6. The root switch receives back a route for the call from itself to the device in the system that owns the number. The call is then handed off to the first device in the route the customer PBX

The customer PBX receives the call and looks up the destination phone number in its extension routing table. Since the phone number is not an extension number it does not find a match. The PBX device requests a route for the call from the application server the phone number is passed with the request . The application server determines that the number is known and calculates the route from the customer PBX to the device within the system that owns the number customer s call queue device . This route is returned to the customer PBX . At step 7 the PBX hands the call off to customer s call queue device the first device in the calculated route.

Upon receiving the call the call queue device determines whether any agents are logged in and available. It finds that employee B is logged in but unavailable as employee B is on another call. The call queue device then connects the call to the call queue music on hold device at step 8. The call queue device subsequently continues to monitor the availability of agents so that the call may be transferred once an agent becomes available. The call queue music on hold device answers the call at which point the caller stops hearing ringback and instead hears the music on hold phone message.

Upon employee B ending his current call the next call will be received after a set amount of time. This set time is configurable as a property of the call queue device as down time. Once this down time has elapsed the call queue device initiates the process of transferring the call to employee B at step 9 by sending the call back to the customer PBX along with employee B s extension number.

The customer PBX receives the call and looks up the extension number in its extension routing table property. At step 10 once the match is found the call is handed off to the filter device listed for employee B s extension.

The filter corresponding to employee B evaluates its rules for handling calls at step 11 determines that this call should not be blocked and then sends the call to employee B s follow me device . As noted above filters are typically used to block certain kinds of calls for example to prevent employee B in this instance from making and or receiving certain kinds of calls.

At step 12 the follow me device sends the call to the SIP handset device the first device in its list.

At step 13 upon receiving the call employee B s SIP handset device sends an SIP INVITE message to its corresponding SIP phone device identified by the device ID property. The invite is actually sent to a session border controller not shown which knows the IP address for each phone when given the Device ID also called the SIP ID . The SIP phone device is not to be confused with the software implemented configurable telephony device disclosed in the present invention.

At step 14 the IP desk phone at employee B s desk rings and employee B answers the phone. The call queue device determines that the phone has been answered sends an exit message to the call queue music on hold device and connects the call to the new channel established with the IP desk phone . The caller no longer hears music and is connected to employee B.

The call between the two employees of the respective companies is therefore completed without leaving the device system.

The device platform allows customers to configure their PBX by using and connecting a series of configurable software implemented telephony devices. Design details of several exemplary telephony devices as well as design details for the interaction of those telephony devices is now presented. Additionally device to device transitions are presented.

One embodiment of a configurable software implemented telephony device is specified by a CCXML document and a set of properties. As part of a device additional CCXML VXML the supporting resources pre recorded audio grammar files script files etc application server code that generates one of the above and configuration screens as well as application server code that provides an API to control or monitor the device at runtime in special or custom ways can be included.

A call is handled by a number of telephony devices. When the call is first presented to a device platform it is handled by the HDAP CCXML document which then passes control to either the root device for externally initiated calls or to the SIP handset device corresponding to the phone that is initiating the call. Control is then passed on to the next device as its configuration of the first device determines. At any point a telephony device can fully handle the call itself rather than passing it along. An exemplary HDAP CCXML document is shown in .

In the context of the device platform a telephony device is a collection that includes a device logic CCXML document that includes event handlers a properties CCXML document that contains descriptors including properties name of root document other information needed for configuration UI VoiceXml documents a configuration UI supporting resources application server code and test scripts. An exemplary device logic CCXML document is shown in .

Application server code could include software for special billing monitoring implementations that cannot be performed in CCXML or code that generates dynamic VoiceXML for example. The test scripts could be used to test the functionality of the telephony device .

During call processing a telephony device may be or have a parent device and or a child device. A parent device is the device immediately prior to the current device in the chain of processing a call. The root switch and handset devices when initiating a call have a parent CCXML session that is the HDAP CCXML however they don t have a parent device. A child device is the device following the current device in the chain of processing a call. This device has been launched by the current device.

Telephony devices have properties and every telephony device has a universe of properties that it can ever have. These properties usually have default or initial values. If a specific value is not prescribed a device normally functions in a certain way based on the default properties. However in each instance of a telephony device when a device is used for a particular function the default properties can be overridden with specific values. Values can include such information as 1 how long the call rings before it gets picked up 2 how long the call rings before it gets transferred to the next device 3 which is the next device to which the call should be sent and 4 under what conditions should a device be sent a call.

In a dynamic fashion when a telephony device is instantiated it provides a context and then inquires of the HDAP engine to determine what it is supposed to do. The engine looks up the information and provides the telephony device with the properties and logic to perform its functionality.

Each type of telephony device has a device logic CCXML document that contains the CCXML logic that specifies the repeatable behavior of the telephony device . The device logic CCXML document is referenced by the device properties CCXML document and is interpreted by the CCXML interpreter when a properties document invokes it by reference. As noted above the CCXML interpreter is part of the voice server . An exemplary device properties document is shown in .

The device properties CCXML document is the first CCXML document that executes for a telephony device . It sets all the dynamic and static properties of the telephony device into session variables and then invokes the device logic CCXML document . The properties document is automatically generated by and kept in sync with the changing properties by the application server .

VoiceXML Dialog documents are an optional part of a telephony device . If the device logic relies on user interaction such as playing a menu getting DTMF input or doing text to speech synthesis then VoiceXML is used. The name and location of the VoiceXML dialog documents are usually properties referenced in the device properties CCXML document . The VoiceXML dialog documents are interpreted by the VoiceXML interpreter . As noted above the VoiceXML interpreter is part of the voice server .

A general purpose shared and fast document store stores and serves up all of the device logic CCXML documents device properties CCXML documents and VoiceXML dialog documents .

Device configuration and state data are the properties and configuration information that make a particular telephony device instance different from another instance. The properties are stored in the database before being copied into the generated device properties CCXML document . State data is another distinguishing part of a telephony device . In a call queue state device for example the state data might include the list of workers logged in the list of callers holding in the queue the list of callers talking to agents the last agent that was sent a call etc. This data is held in memory but is also persisted to the database so that it is available across multiple servers.

In addition to storing telephony device data the database also stores account data and static definitions of device types and device kit types.

The device management API is the Application Programming Interface provided by the device developer to create manage query configure and delete the telephony device . Telephony device properties are set through this API. It runs in the application server and works on data in the database .

The application server is a multi purpose off the shelf platform that serves many purposes including a web server. While the application server is off the shelf the logic that it runs is either part of the device platform or telephony devices .

Device state management logic refers to the application logic that accompanies more complex telephony devices such as call queue devices and conference devices for example to maintain and manage their state from multiple servers and to use that state in making run time decisions. An example of such logic for a conference device might be the logic that executes when a conference device is first invoked to query the state and determine if any other callers are already in the conference and if so determine which server is acting as the master server for the conference. This logic executes in the application server .

The device developer provides the web user interface through which the telephony device is manipulated configured created and deleted. The web user interface UI must conform to certain architectural requirements so that it fits in seamlessly with and works in conjunction with the UI for the rest of the telephony devices . The web UI is served up by the application server .

Finally a telephony device includes media . These media elements might include static media files dynamically recorded greetings files that need to be played back or the ability to receive and mix media such as in a conference. A common media store provides storage for any media that is stored. The media is handled played mixed relayed codec translated and or recorded at the media processor see .

At step a call comes in to the SIP stack . The SIP stack then sends an event to the CCXML interpreter at step and includes information from the incoming call which triggers the invocation of the root bootstrapping CCXML document of the system HDAP.CCXML in the CCXML interpreter .

At step the CCXML interpreter requests the HDAP.CCXML from the web server component of the application server . The web server responds by serving up HDAP.CCXML at step .

Next the HDAP.CCXML pulls from to subject information from the SIP header and at step sends a request to the device renderer in the application server to serve up the first telephony device .

At step the device renderer evaluates the from to and determines whether this call is from a SIP phone known to the system or is from a source external to the system . At step the device renderer determines which telephony device to serve up first. If it is a call from a SIP phone known to the system it serves up the appropriate SIP handset device. Otherwise it serves up the root switch device.

The device renderer requests the web server for the first device s properties CCXML document at step and the web server at application server returns the first device s properties CCXML document . At step the device renderer returns this properties document to the CCXML interpreter and the CCXML interpreter begins interpreting the properties document.

After setting the properties the CCXML interpreter encounters a reference to the device logic CCXML document . It requests this document from the web server at step . The web server returns the requested device logic CCXML document at step and the CCXML interpreter begins interpreting the first telephony device s logic CCXML document at step using the properties previously set.

In some instances there might optionally be a need for VoiceXML execution. Should that be the case the ongoing CCXML session calls the VoiceXML interpreter at step . The VoiceXML interpreter requests the referenced VoiceXML dialog document from the web server at step and the web server returns the document requested at step .

Meanwhile independently the CCXML interpreter and the SIP stack may be exchanging a series of events and call control commands . At step the VoiceXML interpreter interprets the VoiceXML document returned to it by the web server. This may involve user interaction. Independently the CCXML interpreter and the SIP stack may again be exchanging a series of events and call control commands . After all user interaction is complete the VoiceXML interpreter exits the dialog and lets the CCXML interpreter know that it is finished at step .

The CCXML interpreter carries on with the execution of the device logic and may encounter the need for the next telephony device . In such an occurrence a new CCXML session is started. The new CCXML Session requests the device renderer to render this next device.

Eventually all CCXML sessions exit as in step the SIP stack is asked to end the call at step and ends the call at step .

The database entities shown in boxes such as and are relational tables. The table name is shown at the top of each box. The items in the lower section of the box are the columns or attributes. The PK in parenthesis signifies Primary Key. No two rows in the table can have the same exact values in the primary key columns. The FK in parenthesis signifies that the column is part of a Foreign Key. A foreign key always points to a primary key on a parent table. The relationship between the parent and the child is shown as a line between them. The foreign key on the child table ensures and enforces that no child row can be inserted without a corresponding row in the parent table. The value of the foreign key column in every row of the child table must match the value of the primary key in a row of the parent table. The parent row cannot be deleted unless the child is deleted first. There can be many children rows to the one parent row. A PFK in parenthesis signifies that the column is part of both a primary key and a foreign key of the table.

A description of each of the tables shown in follows. Note that a static lookup table is one that is populated once at the time the system is deployed and only changed occasionally when the system is upgraded with new values for the static lookup table. A dynamic table one that is not a static lookup table is one that is actively inserted into updated or deleted from during the course of the system s routine activities.

Description Static Lookup table that holds the list of types of accounts that exist in the system such as Direct Customers of the operator of the system White Labelers of the operator who present the system as their own to their customers and Resellers who sell the system under its original branding. This is a parent to the Accounts table.

When does this table change Hardly ever. Only if system is upgraded to support new types of providers or customers

Description Holds one row for each Account in the system. Accounts may be of the different types specified in Account Types. This is a parent to the Account Services table.

When does this table change Every time a new customer or provider comes on board a new row is inserted into this table. Also when a customer cancels or is suspended the table is updated.

Description Static lookup list of all services sold by operator of the system. The Device Kit Type ID column points to the Device Kit Type in Device Kit Types that fulfills the feature functionality of the specific service. The Device Kit Type ID tells the system what type of Device Kit to create in the account when this service is purchased

When does this table change When new services are added to the list of what is available for sale and also when a service is to be supported by a different Device Type than earlier.

Description Lists the services purchased by each account. One row for every service purchased by every account. The Device Kit ID points to the specific Device Kit in Device Kits that was created at the point of purchase

Description A Device Type is the template for a reusable building block component that provides a specific atomic telephony function using CCXML VoiceXML Java media files and data. This is a static lookup table of all the Device Types in the system. Example Device Types are Root Switch PBX Follow Me Sip Handset etc. Using Object oriented terminology A Device Type is like a Class while a Device is like an object.

Description A Device is a created executable instance of a Device Type. Each Device is of a type as specified by its Device Type ID. A Device is controlled through its properties. Example Two accounts that have a PBX Device Type get two different devices each with its own properties. This table holds the list of all Devices in the system for all customers of all providers.

Description A Device Kit Type is a collection of Device Types that when created into Devices provide a complex reusable functionality. Examples include Extension Device Kit Phone System Device Kit Call Group Device Kit etc

When does this table change Only if the system is upgraded and new types of Device Kits are introduced or old ones retired.

Description Device Kit is a created instance of a Device Kit Type. Each Device Kit is of a type as specified by its Device Kit Type ID. A Device Kit does not actually execute its component Devices execute. This table holds the list of all Device Kits in the system for all customers of all providers.

Description This table specifies what Device Types make up a Device Kit Type. The Device Count indicates how many instances of each Device Type are needed to make up the given Device Kit Type. This static lookup table is used at the time of service purchase to determine what Devices need to be created in order to create a particular Device Kit of the Type specified in Device Kit Type ID on Services .

When does this table change Only if the system is upgraded and a change is made to the composition of a Device Kit Type

Description Static lookup table that lists all the different TYPES of properties that the system supports for Devices. Type examples are String Numeric DeviceConnection etc. The Property validator column specifies the name of the java method that is to be used to validate the property value thus allowing for custom property types to be introduced without a change to the existing system

Description Static lookup table that specifies what properties each Device Type can and must have. A Device can only have those properties that this table specifies for its Device Type. Examples of Properties might be OutboundCallingDevice TimetoRingBefore VoceiMail etc.

Description Static lookup table that specifies the DEFAULT property values that are to be assigned to Devices when created as part of a given Device Kit. This table is used at purchase time when new Devices are created. Device Type Instance Num is needed to identify which of several of the same Device Type the property value applies to. Data Index is there to support array type properties.

Description This all important table stores every property of every Device. These properties determine the behavior of each Device.

A device type is a definition or template for the device and is similar to a make and model of a physical device.

Devices that are commonly used together in a particular configuration can be bundled into a device kit. A device kit is a number of device types connected together to serve a common function. The two primary uses of device kits are 1 easier service provisioning and 2 configuration. Customers may purchase device kits rather than having to buy the individual component devices. This simplifies the purchase for the customer and allows device vendors to offer packaged groups of devices that are pre connected to perform a specific larger function. At configuration an administrator may add a device kit to the configuration graph which essentially results in the pre connected group of devices to be added to the graph. Once added the device kit ceases to exist as a device kit except for the purposes of relating the devices together for billing and instead becomes just a set of independent connected devices similar to others on the configuration graph.

Device Kit Type Members are the list of Device Types that make up each Device Kit Type. When a Device Kit is created one or more devices of each of the member types is created.

A device property has a type that defines the data format of the underlying value. All device properties must conform to one of these Device Property Types. The different data types available include string number device connection phone DID duration boolean FAX DID and media file.

A string value is any sequence of characters. To format the string value for CCXML single quotes are put around the value. There is no validation of the string value.

A number value is a numeric value and may optionally include a floating point component. The number value is formatted for CCXML as is with no additional markup or processing. This type can be validated with the regular expression d . d .

A device connection is a link connecting two devices together. The value stored in the database is the device GUID of the other device being connected to. This value is formatted for CCXML by appending the Device GUID to the URI for the DeviceRenderer. This value is verified first that it s a numeric value and the value is a Device GUID in the database.

A phone DID is a phone number that can be dialed to reach a telephony device from anywhere in the device platform not an extension id but the 10 digit phone number . The value is formatted for CCXML like a String value. The value is considered valid if it can be typed on a standard phone keypad with the regular expression d 

A duration represents a length of time. The value in the database is formatted according the CCXML spec s description of durations which it gets from the Cascading Style Sheets specification. This value is formatted for CCXML by placing single quotes around the text. This value is a number optionally followed by white space and the ms or s identifiers as specified in the regular expression d s ms s .

A Boolean value represents a true or false value. This value is stored in the database as the text true or false. The value is formatted for CCXML as it is stored in the database without quotes. The validation verifies that it is one of the two literal values in lower case.

A FAX DID is a DID number that is routed to an external fax provider for processing. The value is formatted for CCXML as a String value. The validation for this type is the digits on the keypad 0 9 and .

A media file is a file resource managed by device platform that is used in the execution of a telephony device . Typically this will be an audio file but the Announcement device allows this to be a VoiceXML file and other embodiments of the system might allow this to be image or video files. The value stored in the database is the result of asking the media manager class in the application server to store the file. The value is formatted by CCXML by appending the value in the database to the path to the HDAP Servlet s media URL appserver hdap media and putting quotes around it. Users can not edit these fields directly instead a user interface prompts the user for a file to upload pass that file to the media manager and store the result. The media manager has a validation method that given a value it can verify that a file exists.

The device type of a telephony device defines the properties that are allowed to be set for a given device. For example the announcement device type defines the device type properties of AnnouncementURL and DID. When a new device of type announcement is created the instantiated device then is allowed to have values for the fields AnnouncmentURL and DID.

A device type property declares the names of the properties their types and a flag indicating the type of list the property is. The device platform supports three types of lists none list and map as 

Combinations of list types are not supported. Thus a list of maps or a map having a value that is a list is not allowed.

The properties of the telephony device determine how the device behaves at run time. There are some properties that every device must have in order for the device to work properly and consistently within the device platform framework and take advantage of common services like monitoring or call log generation. A list of required and immutable properties that every device must have includes 

Since these properties exist for every device they are stored on the Devices table rather than as properties. Other properties may be used by the device developer to influence the behavior of the device at run time.

Some properties cannot be modified in any device copy of a device type whereas others are allowed to be modified.

In one embodiment devices are deployed as a Java standard Web Archive WAR file. Within the WAR file is packaged all the CCXML VXML and associated resources needed for device execution. Also in the WAR file in the WEB INF directory adjacent to the web.xml file is a device.xml file. This file includes the details of the device s properties and its CCXML documents.

A new type of device is added to the system through the configuration application programming interface. After a device has been installed the configuration database has been updated so that the data in the device.xml file have been loaded. Additionally the WAR file has been distributed to all the application server instances.

At step a customer purchases a service. Purchases can be made through a web based user interface or through an API. Under the covers the web based user interface uses the same API.

After purchase the application server validates the data in the purchase and creates an account for the customer at step . An account ID and service ID are created and are passed through to the next step.

At step the service ID is used by the API in the application server to perform a lookup on the services table and identify the Device Kit Type ID of the device kit type that fulfills the telephony function associated with that service. The Device Kit Type ID is passed through to the next step.

The Device Kit Type ID from step is used to determine the member device types of the device kit type by accessing the Device Kit Type Members table at step . Not only does this table indicate which device types Device Type ID make up the given device kit type but also indicates the quantity of each device type Device Count that are part of the device kit type. A Device Type ID list and the Device Count are passed through to the next step.

Each member device type of a device kit type has certain default properties and these are specified in the Device Kit Type Member Properties table. These default properties are designed so that when the devices are created they will function in a useful manner even before the user customizes them for their specific needs. At step these default properties are retrieved and passed through to the next step.

At step the device kit is created by the API in the application server . A new Device Kit ID is generated and a new row with this ID is inserted into the Device Kits table. The newly generated Device Kit ID along with the Device Type ID list the Device Count and the default initial properties are passed through to the next step.

Next at step Device GUIDS are generated for the new telephony devices to be created one for each telephony device . Rows are then inserted into the Devices table with these Device GUIDS. Each row is assigned the appropriate Device Type ID so that when the telephony device is invoked the system knows which device type s CCXML logic document to serve up. The Device GUIDS and the default initial properties are passed through to the next step.

Once the telephony devices are created the Device Properties table is populated with the default properties at step . The account ID and service ID are passed through to the next step.

At step a row is now inserted into the Account Services table to relate the account with the new instance of the service that the customer has now acquired. This row also includes the Device Kit Id of the new device kit that was just created. These relationships are necessary to a bill the right customer for the usage of the devices underlying the purchased feature b to be able to invoke the right devices for the right feature of the right customer c to be able to configure the right devices through the API and user interface and d to be able to disable the right devices when the customer s account needs to be suspended. The Device Kit ID to Account Services relationship relates the business of running a telephony system to the technology underlying the system.

At step the pieces are in place for the customer to make use of the newly acquired features in plug and play fashion.

The core purpose of the Permissions framework of the device platform is to ensure that a customer accounts are only able to use the devices that they have purchased the rights to use and b customer account administrators have the ability to limit what their staff members end users can change or do with each device.

The device platform supports an account hierarchy where the operator of the system is at the top of the hierarchy. Below the operator are the different types of accounts such as White Labelers Resellers and Direct Customers. Every account can have one and only one parent. At every level every account can have users. At every level every account also has telephony devices. The device permissions subsystem specifies enables and enforces authorized and organized access to devices by users. At each level of the account hierarchy there is a need for users to 

The device developer can specify whether a device property is modifiable or not. If it is any user with access to the device can modify it for himself and if he is an administrator do it for all those in his account. Properties that are defined as immutable cannot be modified by anyone through an API or UI not even the super user. They will have to be modified manually by a developer. A super user can grant access to any device to any direct child account of the system owner. When granting access to a device the super user can specify whether the grantee has read or modify privilege on the device. Any administrator type user in an account can grant access to devices in his account to any user in his account. When granting access to a device the administrator can specify whether the grantee has Read or Modify privilege on the device.

An Administrator can take away a device from any user in the account. Taking away a device in this situation means removing the access that the end user had to the telephony device resetting the properties of the device to the default values from the corresponding device type. A super user can similarly take away a device from any direct child of the system owner.

When an end user is deleted all his devices remain. This is akin to an employee leaving but their telephone staying. When an account is canceled all its devices cease to be functional.

Permissions are restrictive and cannot be expanded going down the hierarchy this means that if the account was given only Read privilege on a device an account administrator can not grant modify privilege on it to another user.

Permissions are mainly used during the building of a configuration graph and specifying device connections.

There are many telephony devices that do some processing early and then don t need to remain involved. An example would be the filter device that either allows a call to pass through or terminates. Another example is the switch device once a child device is found the switch does not have any further function. As an optimization in these cases the device filter or switch could pass its child session to its parent in the hdap.ready event that it relays on. This would cause the device s parent to move the connection directly to its child device and send the start message to the child reducing the number of times the connection must be moved and the number of events that must be generated and processed.

Telephony devices that use this optimization should still implement the hdap.start event in case their parent device does not use the session id passed in the hdap.ready event.

An event structure specifies the data that must be passed when sending an event from one CCXML session to another. This section defines the event structures for the event handlers for the hdap. events.

When a telephony device needs to hand off the current call to another device for processing the device currently processing the call creates a new CCXML session using a URL provided by the application server . This session will start with the application server generating a dynamic CCXML document that assigns the properties the administrator user set for the device when it was configured including setting the URL for any of the child s child devices grandchildren to the current device . These properties will be stored in the application scope. This dynamic document will then use CCXML fetch and goto elements to transfer execution to the CCXML document for the device.

The CCXML interpreter will send the parent session a ccxml.created event. The parent device will send a hdap.receivecall message to its child device. The child device can then begin processing. Once the device is ready to assume control it will send an event to its parent named hdap.ready . It is possible that a device never sends its parent device a hdap.ready event because it can not assume control i.e. a SIP handset device that the user does not answer .

The device that is currently in control and started the new device will receive this hdap.ready event. Once it is ready to delegate control to the new device it will first move the connection the user is attached to into the child s session and then send an event named hdap.start . This event will include two attributes named connectionid and conferenceid. One of the attributes will be undefined and the other will be for the connection or conference the user is connected to.

The parent device can send a ccxml.kill event to a child device at any time including before sending the hdap.start event. Once a child device receives this event it must kill any child devices move the connection object if any to its parent session and exit.

Once a device has received the hdap.start the device can continue its business processing. Once the device is done processing the call it exits using the CCXML exit element. This causes the parent device to receive a ccxml.exit event. The parent device can then continue its processing.

There are likely to be cases in which a device s functionality requires listening on the connection after it has transferred control to another device. One example would be a company PBX that wishes to transfer any user who presses zero at any time to the operator regardless of where they are in the system including while talking to an actual person. This behavior would also be necessary when the users wishes to have separate music on hold for the same extension depending on how the caller connected to the extension through the main switch board or through a call queue.

The flow is the same as that of a normal device until the point where the child device has signaled it is ready with a hdap.ready event. Normally the parent would issue a move on the connection and then send the child a hdap.start event.

When a parent device wishes to continue to receive input from the connection and the child device has signaled its ready the parent device will use the CCXML createconference element to create a new conference with a unique name created by using the device s GUID and a random identifier based on the current time. Once this conference has been created it would join the current call to the conference and pass the conference id and not the connection id to the child device in the hdap.start event.

At times a device might need to initiate an outbound call. For instance a user might want to configure call forwarding to a phone number not terminated within the device platform or a user might pick up a handset and dial a number that might be another extension in their company or the number of an outside phone.

To initiate an outbound phone call the device follows the process laid out in the previous section but instead of sending an event hdap.receivecall it sends a message hdap.makecall. This event has an attribute named dialdigits which are the digits of the phone number and will be passed on unmodified.

At step a parent device determines that control of a connection must be transitioned to another device a child device . The parent device creates a session at step by making a call to the CCXML interpreter engine with the createsession call. The URL of a CCXML document is provided as the parameter. At step the CCXML interpreter then makes a doGet call to an HDAPServlet object to fetch the document. The document is provided to the CCXML interpreter by an application server and the CCXML session is created.

The CCXML interpreter sends a ccxml.created event back to the parent device at step and the parent device is informed that a CCXML session has been created. At this point the CCXML document has been retrieved in memory and is in a CCXML session that is running in a session inside the CCXML interpreter .

The parent device next sends a hdap.receivecall message to that session dynamic property CCXML at step .

After the hdap.receivecall message is sent the properties of the device are assigned values as CCXML variables inside the session at step . Multiple assign statements are actually executed to assign the values. The values come from the dynamic property CCXML that has been fetched and is inside the CCXML session. The values are assigned as a result of parsing the property CCXML document.

After all properties have been assigned a fetch statement is issued to retrieve the root CCXML for this device at step . The path of the root CCXML is thus retrieved with the business logic of the device i.e. the logic that determines the function of the previously assigned variables.

It should be noted that there is only one CCXML document business logic document for a device type. Though there are many devices for a particular device type each device has a distinct GUID and a distinct property CCXML document. However there is only one device type CCXML document. For example a SIP handset device type has one root CCXML document. Thousands of customers may each have five SIP handset devices and so there would be five thousand SIP handset devices each of which has one property CCXML document.

The CCXML interpreter then sends an hdap.initialized event to the parent device at step thus informing the parent device that the child device has been initialized. The CCXML interpreter also sends a fetch.done event to the properties CCXML at step after which the properties CCXML sends a goto to the CCXML interpreter at step to transfer control of the CCXML document. The CCXML interpreter can thus start executing the contents of the CCXML document.

The CCXML interpreter then sends a ccxml.loaded event message to the child CCXML at step and the child device begins performing the logic that was loaded. Once the loaded message is received the child CCXML then receives the hdap.receivecall message from the CCXML interpreter at step . At step then the child device begins executing its primary business logic. The child device begins to execute its logic after the loaded message is sent to the body of the child s CCXML document.

After performing its logic the child device sends an hdap.ready back to the parent device . The hdap.ready is actually sent to the CCXML interpreter at step via a send statement that requests the CCXML interpreter to forward the hdap.ready to the parent device . Subsequently the CCXML interpreter sends the hdap.ready to the parent device at step .

The call has thus been sent and the child device has executed its functionality on the hdap.receivecall and has sent an hdap.ready back to the parent device . The parent device knows that the child has performed its initial functionality and that the child device is running

Next the parent device moves its session along with a connection object to the CCXML interpreter which in turn sends the session to the child. At step the connection object is moved via a move command to the CCXML interpreter . The connection that was originally held by the parent device is thus moved to the child device . At step a send command forwards the connectionid to the child device . No return message is received though of course error handling logic not shown is present in this and the other executed commands as well. After sending the connectionid to the child device the CCXML interpreter informs the parent device of success by sending a move.successful message to the parent device at step .

At step the parent device issues an hdap.start command to the child CCXML with the connection id parameter to indicate the call to start. It will be noted that an optional conference id parameter may also be included if the call is a conference call. In this nominal case example only the connection id is passed since it is not a conference call.

At step the child CCXML may perform more activity via its business logic. Once the child CCXML has finished its activity it issues an exit to the CCXML interpreter at step to indicate that all activity is done. The CCXML interpreter then sends an exit back to the parent device at step so that the parent knows that the child device no longer exists and the call is finished.

At step the parent device determines that a conference call is to be created and that a child device is to be invoked. The parent device sends a hdap.receivecall to the child device s CCXML . At step the child device does its necessary processing and sends a hdap.ready event to the parent device. The parent device now knows that the child device is running

At step the parent device executes a create conference element by sending a createconference call to the CCXML interpreter . The confname attribute is the GUID for the current device appended with a random identifier. The CCXML interpreter creates the conference and then indicates completion by sending the event conference.created to the parent device at sep .

At step the parent device then executes a join element in response to the conference. created event. The attributes for the join are the conference id corresponding to the conference that was just created and the connection id passed in from the hdap.start event that invoked the parent. At step the CCXML interpreter joins the two objects together and signals completion by sending the conference.joined event to the parent device .

If the conference requires any inputs from the user such as pin ids conference bridge numbers that additional logic is handled by a VoiceXML document. The CCXML Interpreter performs any necessary logic at step for creating dialogs to accept user input or setting states to know how to process signaling events if inputs are necessary. Dialog handling for input is done through VoiceXML. User interaction or input is handled by VoiceXML.

At step the parent device sends the hdap.start event to the child device s CCXML with an undefined connectionid and the conferenceid corresponding to the conference created. The hdap.start command starts the conference.

It is important to note that the parent device did not use the move element to pass the connection object to its child session the parent device continues to own the connection and will receive signaling events. In addition to instantiating the child device a conference was started via the CCXML interpreter and then the parent device joined the call that was on going to the conference device. Thus the connection is now in the conference device.

As opposed to handing off the connection to another child device the parent device started a conference and then added the call into the conference.

The CCXML interpreter determines at step that a transition is needed and issues a doGet request for a properties document of a telephony device .

At step the CCXML Interpreter performs an HTTP GET request to the HDAPServlet . The servlet receives the request determines that it s a render request and sends it to the RendererRouter . The router then sends it to the HDAPDeviceRenderer renderer which extends IDocumentRenderer.

The renderer asks the ISecurityManager at step if the transition is allowed. The map of request parameters received as a parameter to the render request is passed to the ISecurityManager . One of the request parameters contains the previous session GUID. The current request GUID is also be passed.

At step the renderer passes request map the requested GUID and a blank response Map to the ISecurityManager .

The servlet delegates to the JSP page specified in the renderer s return value the page was found by setting the parameter in the Spring configuration file .

At step the JSP writes the CCXML header to the HttpResponse s output stream or writer. This header includes the XML prologue CCXML root element eventprocessor element and event handler for error.semantic and fetch.done.

The JSP iterates over the list of configured properties outputting the CCXML generated by the formatters.

At step the JSP appends CCXML fetch element to the CCXML with an attribute for the device s root CCXML page.

It should be noted that the action between ConfigurationManager and deviceProperties.jsp is significant where getFormatter PrefValue is retrieving the properties back and emits it as a configuration ccxml document see box . thus the CCXML document goes back from the application server to the CCXML interpreter .

HDAP CCXML is the CCXML document that is typically configured as the default CCXML document for the CCXML interpreter supporting the device platform . shows the event handlers that HDAP CCXML must support. The HDAP CCXML document is responsible for receiving standard CCXML events and transforming them into the HDAP events described previously. Thus the HDAP CCXML is responsible for starting execution of the correct configurable software implemented telephony device . For calls initiated from SIP Handsets registered with the system the execution is started in the SIP Handset CCXML. For all other devices the execution is started at the root switch.

It should be noted that since the HDAP CCXML document is configured as the default CCXML document for the CCXML interpreter all calls begin by executing this document.

Some telephony devices need the ability to interact with databases file systems or perform processing that isn t easily accomplished in a computer executable document such as the CCXML document. For actively executing CCXML documents this is accomplished with event handlers. The CCXML session sends an event to the application server which then routes the call to the registered event handler for the component. The event handler can then perform whatever processing is needed.

If a response needs to be sent to the CCXML session the event handler can return a ResponseEvent object that will be routed back to the originating CCXML session.

This section describes how the application server will deal with CCXML both handling events from the sessions and generating any dynamically needed resources.

Devices should be built of a single CCXML script. When a script needs additional data at runtime available from the CCXML server it will send an event to the application server from which it was loaded that is routed to the appropriate handler. This event will have the ability to route an event back to the CCXML session containing the data needed.

Transitions between CCXML pages should only happen when the structure of the CCXML must dramatically change based on actions that happen during runtime.

The CCXML document for a device should be in a static CCXML file if at all possible. If the contents of the CCXML document must change at runtime then the CCXML document will be generated in the application server using a renderer and JSP page for the actual rendering.

The HDAP device platform has one servlet that services requests of both types. Based upon the request the servlet will determine either the event handler or renderer to execute and pass the request off to that object.

The doEventHandlerRequest method finds the EventRouter from Spring . At this point it completes the HTTP request with an OK status. It then delegates the request to the EventRouter object.

The doRendererRequest method finds the RendererRouter from Spring . It then invokes the render method which returns a RendererOutput object. The method copies the values of the RenderOutput s requestAttributes map to the HttpServletRequest object using the setAttribute method. It then uses the servlet s RequestDispatcher to include the contents of the rendererPage value specified in the RendererOutput object.

The EventRouter is responsible for sending requests to the appropriate event handler. The EventRouter has one method handleEvent that is responsible for finding the appropriate event handler configured in Spring and invoking it.

The event handler is found by creating a string with the component name found from the request context passed in servlet sends its path info . It then appends the event name from the request found in the name attribute in the parameter map. It uses this as a key to find the appropriate event handler in the Spring configuration.

The bean returned from Spring should be a transaction proxy to the actual event handler. The proxy will delegate to the actual event handler which will perform the logic necessary to handle the event.

It is likely that the event handler will want to respond with an event. The event handler can return a ResponseEvent . This object will then be used by the EventRouter to invoke the IEventDispatcher not shown to send the event to the CCXML session that sent the event.

The RendererRouter is responsible for sending requests to the appropriate renderer. The RendererRouter has one method render that is responsible for finding the appropriate renderer configured in Spring and invoking it.

The renderer is found by examining the request context passed in the servlet sends its path info . It uses this to find the appropriate bean from Spring . The bean returned from Spring should be a transaction proxy to the actual renderer. The proxy will delegate to the actual renderer which will perform the logic necessary to load the data needed to renderer the page. The renderer will return an instance of RendererOutput. This object holds a map of objects that are needed to renderer the request and the name of the resource for the view engine in the default case the servlet engine to invoke to render the actual request. This value will be set through the Spring configuration and isn t hard coded into Java. The RendererRouter is responsible for sending requests to the appropriate renderer. The RendererRouter has one method render that is responsible for finding the appropriate renderer configured in Spring and invoking it.

The renderer is found by examining the request context passed in the servlet sends its path info . It uses this to find the appropriate bean from Spring . The bean returned from Spring should be a Transaction Proxy to the actual renderer. The proxy will delegate to the actual renderer which will perform the logic necessary to load the data needed to renderer the page. The renderer will return an instance of RendererOutput. This object holds a map of objects that are needed to renderer the request and the name of the resource for the view engine in the default case the servlet engine to invoke to render the actual request. This value will be set through the Spring configuration and isn t hard coded into Java.

A CCXML script invokes a send element in the script. The target type is basichttp and the target destination is hdap device component. The data is the event name and any parameters for the event are passed in the namelist. For this exemplary sequence a component of callqueue and an event name of worker login are used. At step the CCXML interpreter sends an HTTP POST request to the server that it loaded the page from as determined by the base URL of the CCXML document.

At step the HDAPServlet receives the request because it is registered to intercept all requests to hdap event. It examines the requested URL and determines that it is a request for the eventing function and invokes its doEventHandler method. At step The doEventHandler method invokes the handleEvent method on the EventRouter that it loaded at the servlet s startup time.

After finding a valid event router the doEventHandler method sets the response s status code to OK and then ends the response. It passes the path info for the servlet request as the request context trimming any leading slashes and converts the request parameters into a map of strings.

At step the EventRouter determines the component for the request by using the request context passed it. It then determines the event name from the request map passed in. It combines these two by placing a dot between them to form one string. In this would be callqueue.worker login.

Spring returns the bean registered at the name which should be a transaction proxy that delegates to the actual event handler.

The EventRouter calls the handleEvent on the proxy that it received which then delegates to the actual event handler at step . Then the event handler performs its work needed to process the event at step . If a response event is necessary the event handler returns a ResponseEvent object.

At step the EventRouter eventually receives the ReposeEvent . It then takes the fields in this object and passes them to the IRequestDispatcher which sends an event to the CCXML session.

Some devices need to perform actions when its configuration changes and not wait until the next call invocation. One example would be the music on hold device when the audio files are updated and possibly removed the music on hold device must be notified of the change since the device s conference might be long running servicing multiple calls. Another example would be the SIP handset device that needs to update the provisioning system anytime its properties are changed.

A device can optionally declare in its DeviceType a configuration listener object. This configuration listener will be notified whenever the configuration graph changes. It is important to note that the listener is associated with the device type and not the individual devices.

Configuration listeners allow devices to register for notifications when the configuration of any device changes.

Steps 3 3a and 3b are included to prevent possibly malicious devices from being able to receive update data that contains potentially sensitive information from the entire system. The general approach here is if a user has installed a malicious device in their configuration graph then that device can see all your information and potentially grab the information. However if the user hasn t installed the device in their graph then they are not at risk unless their provider or provider s provider etc has installed the device.

The device platform is designed to support multiple providers servicing multitudes of customers each all out of a single cloud based system. The key design features that are implemented in order to support multiple providers are 

The cache is built so that it can hold different types of data. In its first implementation usages it will hold the DID Route Cache used for finding the set of devices to process a call as well as a DID s status and the SIP ID Cache used to find the SIP Handset for a given SIP ID.

The contents of the cache DID Route or SIP ID are stored in a database table in addition to the cache. This information is pushed into a third party component memcache by executing a stored procedure to get the updated data and passing it back to the invoking Java code that then updates memcache. Each server consults with memcache when it needs the cached data.

More specifically a database trigger runs whenever the data changes. This populates a dirty table with the details of the change. A Java thread running on one or more servers in the JBoss HDAP process wakes up and finds all the dirty entries. It removes the dirty entries calculate new routes for them and then update both the cache table and memcache.

Memcache is installed onto several servers that hold the cached data. On process startup all of the cache data is put into the cache by invoking a stored procedure in the database that retrieves the data and a command line application that performs a bulk load of the memcache server.

A generic CacheManager object has been created that manages loading cache data from a memcache client connected to the memcache server. This manager adds a different prefix to the key requests based on parameters set via Java Spring injection The memcache client then contacts the server and retrieves the requested value. The various places in the code that need to access the cache data SwitchEventRouteHandler and DevicePropertiesRenderer then receive via Spring an instance of CacheManager configured for their cache.

Triggers are installed on the appropriate database tables and insert an entry into a dirty table when a cache entry might have become invalid. Periodically HDAP device platform executes a stored procedure that based on data in the dirty table removes the old cached data and inserts new cache data as necessary. After updating the cache table the stored procedure returns the new routes and the Java code updates the memcache server.

There is more than one memcache server each with its own entire contents of the cache. Each HDAP server has one primary and one or more secondary memcache servers. The stored procedure update procedure needs to update each server.

At step a user makes a change in the UI causing device.device properties to be changed by the API in step . At step the Trigger fires. If the change is to a property whose property type is not device Connection or Phone DID return and the sequence completes. At step the trigger puts an entry in the Dirty Routes table for the device GUID that was changed the property value target device of the original value and if the change was for a Connection Insert Update Delete or Phone DID Insert Update Delete.

At step Java timer fires and invokes the CacheManager s updateCache method. At step CacheManager invokes the IbatisCacheManager s getNewCache entry method passing the iBatis statement set at startup from Spring. At step IbatisCacheManager invokes the stored procedure identified by the statement passed in. At step the Stored procedure checks the Dirty Routes table. For changes because of a Phone DID change the route for the Phone DID is removed from the cache table. For changes because of a device GUID change at step invoke get route to find all routes that include both devices and remove them from the cache table. At step For all DIDs found in the above process invoke the get route stored procedure and put the results into the cache table. At step in the case get route doesn t return a route check the DID s status and insert that into the cache table. Stored procedure returns all the new cache data to the invoking Java code. At step Java puts the result gathered into ALL configured memcache servers.

NOTE This process will be duplicated on one or more but not all HDAP servers to allow for servers to be restarted or fail

NOTE If the put into a memcache server fails the DID is placed back into the dirty table at step so its processed later

At step SwitchEventRouteHandler receives a request for a route. At step Read configuration and determine if caching is enabled. Scenario assumes caching is enabled. At step SwitchEventRouteHandler invokes the getCacheValue method in the CacheManager passing the fully qualified DID. CacheManager requests the CacheValue from the memcache based on the cache key it was passed prepending the CacheManager s key prefix. CacheManager invokes the asynchronous asyncGet method on memcache client passing the CacheManager transcoder. The CacheManager then calls the Future s get method passing in the configured timeout timeout is in milliseconds default is 100 ms . Memcache determines the value communicating with the server and returns this value to the CacheManager. CacheManager using the transcoder converts the String value to a Java object. CacheManager receives the value back from memcache and returns it back to the caller. SwitchEventRouteHandler continues functioning as it does today determining the next device and result codes.

It should be noted that if caching had been disabled the code would have executed as it does today invoking get route and if necessary get phone number with status beta.

Additionally it should be noted that if an error had been thrown by the Memcache client or if the read had timed out in the period configured then the CacheManager would have thrown a CacheException.

At step SwitchEventRouteHandler receives a request for a route. At step read configuration and determine if caching is enabled. Scenario assumes caching is enabled. At step SwitchEventRouteHandler invokes the getCacheValue method in the CacheManager passing the fully qualified DID. At step CacheManager tries to get the value from the primary memcache server. The server fails or the read times out. At step CacheManager tries to get the value from the secondary memcache server. The server fails or the read times out. CacheManager throws a CacheException. At step SwitchEventRouteHandler invokes the get route method in the database to calculate the route again.

The getCacheValue method gets the CacheValue associated to a value. The returned value is the live CacheValue object and should not be modified. The getCacheValue throws an exception if none of the cache servers are enabled or if there is an error during the cache retrieval.

The getValue method gets the CacheValue associated to a value. The returned value is the live CacheValue object and should not be modified. This method throws an exception if none of the cache servers are enabled or if there is an error during the cache retrieval.

The getCacheStatus method returns the current status of the enabled cache servers. The result of this call is global i.e. all CacheManagers using the same server list have the same value 

The is Enabled method returns the current status of the enabled cache servers. The result of this call is global i.e. all CacheManagers using the same server list have the same value 

The setCacheValue method puts a cache value into the cache. It accepts the value in the raw format stored in the cache. This method throws an exception if one of the cache servers is disabled or if there is an error during the cache storage.

The ICacheValueTranscoder is used by the CacheManager to convert the string values held in the cache into actual values.

The decode method converts a string value retrieved from Memcache and converts it into a CacheValue object holding a domain specific cache value. The format of the string in the cache will vary based on the cache type and are covered in the individual transcoders.

It should be noted that since the cache is populated from a database stored procedure a corresponding stored procedure needs to be created to encode the value.

This MemCacheManager class implements the caching infrastructure. The methods implemented by this class that conform to the contract from the interface or are setters used by Spring and aren t repeated.

The start method is called by Spring to complete initialization of this class. Create the memcache client based on configured servers and adds a preference listener to detect config file changes. The listener will stop and start the MemCacheManager when a change is detected. If the server is configured to update the cache it will add a task to the GlobalTimer to invoke the updateCache at the appropriate time. If the creation of the memcache client fails it will add a task to the GlobalTimer to reattempt its creation after the duration specified in the preferences file.

The stop method is called by Spring when the application is being shutdown. This method stops the memcache client. This removes the preference listener.

The is Enabled method returns the current cache enabled property. A cache is considered enabled if it has any sources that are enabled.

The StringValueTranscoder class is used for single cache values like SIP ID. The in cache encoded value is long string the long is the last updated time .

The DID ValueTranscoder is used to convert a cached string value into a DID route value. The cache stored value is long int int . . . string for last updated time device guid device guid . . . status.

The DIDRouteValue class is the value object used in the cache for the DID Route cache. These objects are created by iBatis based on the sql mapping file and are used in the SwitchEventRouteHandler as the result of the getCacheValue.

The Cache.Dirty Sip Ids table holds all the SIP ID to device GUID that are no longer valid and need to be updated.

The top level node of the Caching configuration will be CacheManager. The CacheManager will be a parent to one node per CacheManager instance. Within each CacheManager section will be a list of sources that specify the memcache server to utilize. For each source node a list of servers and an enabled disabled flag can be set. Also within the CacheManager section will be the settings for updating the cache. A cacheUpdateFrequency is the number of milliseconds to wait between cache updates. A zero or negative value indicates the cache shouldn t be updated from this server. The cacheUpdateSQLStatement is the SQL statement used to retrieve the cached value.

If might become necessary on occasion to determine the status of the cache from one script. One example would be a manually run script similar to numcalls.

This script executes a wget against each server s routeCache X or sipIdCache X URL to retrieve the current cache value and date of the last cache entry update. This script also uses psql to execute a database query to get the value currently in the database cache and a second query to get the current actual value. The results are then be presented in a table.

This section describes the different ways that the cache can be cleaned up in case issues are encountered in production.

The design of the device platform enables a third party device marketplace. All of the benefits described in section 4.0 that enable multiple providers to provide services through one cloud based system also enable those providers to develop their devices. The modular design of a telephony device allows for easy extension customization and integration. The data model supports the ability to add new device types device kits and services without any changes to the device platform . The design of the device concept wherein each device knows nothing of the larger application that it is a part of means that devices can easily be retooled and reconfigured into new applications with minimal additional coding.

These attributes of the architecture of the device platform enable third parties to create and sell their devices and services thereof on the device platform .

Although the disclosed embodiments and aspects of a VoIP system constructed in accordance with the various inventions are preferably and advantageously implemented with discrete computer executable device properties documents in association with discrete reusable and universal computer executable device logic documents it will be understood and appreciated that alternative embodiments within the scope of the invention can be constructed with other forms of reusable code. For example computer executable documents in CCXML are not required but believed preferable. By further example the configuration information could be provided in a database high speed cache or other storage and used to access a reusable universal device logic document or other form of reusable universal code. Alternatively the configuration information could be provided and integrated with reusable device logic to provide a self contained device properties and device logic document or other form of program module. Other arrangements will occur those skilled in the art.

Further details and descriptions of the disclosed embodiments and aspects of the claimed inventions are found in the accompanying Appendix A which is incorporated herein by reference and made a part hereof.

The foregoing description of the exemplary embodiments of the invention has been presented only for the purposes of illustration and description and is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in light of the above teaching.

The embodiments were chosen and described in order to explain the principles of the invention and their practical application so as to enable others skilled in the art to utilize the invention and various embodiments and with various modifications as are suited to the particular use contemplated. Alternative embodiments will become apparent to those skilled in the art to which the present invention pertains without departing from its spirit and scope. Accordingly the scope of the present invention is defined by the appended claims rather than the foregoing description and the exemplary embodiments described therein.

