---

title: Method and system for device independence in storage device wear algorithms
abstract: A device, methods and systems that provide device independence in storage device wear algorithms are disclosed. A storage device that provides such device independence includes a device-specific wear algorithm, and may also include an integrated wear algorithm. The device-specific wear algorithm is configured to be loaded into a wear algorithm space and is at least a portion of a wear algorithm. The device-specific wear algorithm is stored in the storage device. The integrated wear algorithm, if employed, is resident in the storage device. A method that provides such device independence is also disclosed. The method includes loading a device-specific wear algorithm from a storage device into a wear algorithm space. The device-specific wear algorithm is configured to be stored in the storage device and loaded into the wear algorithm space. The device-specific wear algorithm is at least a portion of a wear algorithm.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08626984&OS=08626984&RS=08626984
owner: Cisco Technology, Inc.
number: 08626984
owner_city: San Jose
owner_country: US
publication_date: 20081024
---
This invention relates to the field of storage devices and more particularly to device independence in wear algorithms for storage devices.

As electronic devices have continued to shrink in size such devices have become increasingly popular and so ubiquitous. The desire for smaller devices has necessitated smaller storage devices. Smaller storage devices have a tendency to use their storage media more intensively from a physical perspective. Intensive use of only a portion of the storage device s storage media can cause premature failure in certain storage devices. One solution is to more evenly distribute accesses to the storage device through the use of wear leveling algorithms.

For example such wear leveling algorithms are important in the operation of semiconductor memories. One example of a memory type that benefits from the use of wear leveling algorithms is a type of Electrically Erasable Programmable Read Only Memory EEPROM known as flash memory. Flash memory can be used for example in memory cards and Universal Serial Bus USB storage devices for the general storage and transfer of data between computers and other digital products.

Endurance is one of the key aspects of flash memory technology describing the number of program and erase cycles that can be performed on a given physical block of the flash memory before that physical block wears out. The goal of wear leveling algorithms is to evenly spread the program and erase cycles among the available blocks in the flash memory s memory array. Such wear leveling avoids a worn out block compromising the reliability of the entire storage device. By spreading out the locations at which the program and erase cycles occur such failures can be minimized. This is of importance for example in applications that treat such storage devices as fixed media devices e.g. the use of flash memory as a hard disk drive . Such applications will typically attempt to localize read and write operations with the intention of improving a hard disk drive s performance and efficiency while reducing the physical stress experienced by the hard disk drive. In a flash memory device however this has the opposite effect on reliability while offering no particular benefits with regard to efficiency.

Wear leveling algorithms thus seek to prevent the early deterioration of flash memory blocks hosting dynamic data due to the high cell stress induced by the frequent program and erase cycles that would otherwise be performed repeatedly on such blocks. This can be achieved for example by maintaining a block mapping table in the flash memory controller s memory. The block mapping table implementing the wear leveling algorithm employed dynamically binds the block logical address to an alternative physical address. Of necessity the wear leveling algorithm or more simply the wear algorithm is generic in nature as a given flash memory device may be used in any one of a number of applications. Moreover the wear algorithm used in a given device is designed to provide only a certain level of reliability and thus a given wear algorithm may not achieve the highest possible reliability for the given device particularly when used in a specific application .

As a result the wear algorithm provided in a given flash memory is likely to be less than optimal than for one or more specific applications accessing the storage device. However it will be appreciated that neither the manufacturer s creation nor their implementation of multiple wear algorithms for a given storage device is practical or even possible alternative given the wide array of uses to which such a storage device might be put. There is no way for the manufacturer to determine the manner in which a given storage device will be used nor is it possible for the manufacturer to determine the optimal wear algorithm for each such use.

Equally difficult is the position of the original equipment manufacturer OEM . Having multiple sources of storage devices for a given piece of equipment being manufactured the OEM must provide some large number of device drivers if the optimal lifetime is to be coaxed from the storage device actually installed in the equipment. This situation leads to bloating of the operating system s software. Moreover the use of a new storage device and or application will likely entail the addition of yet more device drivers in order to maintain the storage device s lifetime. The need for device driver installation is particularly untenable in an end user environment and may well be either impractical or impossible in such circumstances. This situation leaves the OEM in a predicament make no changes to the storage device and its use or change the operating system software as needed. A solution to the dilemma presented by the desire for optimal storage device lifetime with flexibility in the use and replacement of such storage devices is therefore desirable.

The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather any number of variations may fall within the scope of the invention which is defined in the claims following the description.

Embodiments of the present invention provide a method and system that provide an operating system with access to a given storage device while improving the storage device s wear characteristics beyond that typically provided by integrated wear algorithms. Embodiments of the present invention provide this and other advantages by employing a device specific wear algorithm or portion thereof such as one or more sub algorithms parameter sets or the like stored in the storage device. Such a device specific wear algorithm can be stored for example in either a dedicated storage area or in the storage device s main storage area. The device specific wear algorithm is then loaded into the operating system device driver or the like. The loaded device specific wear algorithm can then be used to access the device. The storage of a device specific wear algorithm DSWA in the given storage device allows an operating system typically a device driver thereof to maintain code that is generic to the storage device while being able to access the storage device in a manner that provides an improved lifespan as compared to simply performing such accesses using the integrated wear algorithm resident in the storage device.

Embodiments of the present invention provide several advantages. One advantage is device independence. Embodiments of the present invention provide wear algorithms optimized for a given storage device and even application while simplifying the operating system and obviating the need for operating system device driver upgrades to support different storage devices. Wear performance is improved even in systems supporting a variety of applications high availability systems and the like. Moreover storage devices having a wide range of reliability can be used by allowing the designer or system to employ a variety of wear algorithms in order to tailor the wear algorithm employed to the application at hand. Further if a generic portion of a wear algorithm is maintained in a device driver for example only device specific portion sub algorithm s parameter s or the like need be maintained in the storage device. In one scenario a number of storage devices can be supported using the same generic wear algorithm but different parameters. In this case the requisite parameters are retrieved from the storage device in use and the loaded wear algorithm employed to good effect in accessing the given storage device.

It will also be appreciated in light of the present disclosure that not only the lifespan but also the performance of a storage device can be improved by changing the manner in which the storage device is accessed. For example an improved sector selection algorithm can improve wear algorithm performance. Using embodiments of the present invention such alternate algorithms can be incorporated in device drivers or other software modules loaded from the storage device. Such algorithms enable the operating system and other software in the computer system to remain unchanged and so storage device independent. As will be appreciated from the discussions that follow the present invention is not restricted to wear algorithms. Software components whether or not stored in the storage device can be employed to enhance and or change other storage device characteristics once loaded. These and other advantages will be apparent from the following examples.

Storage device includes a storage area that is made available to operating system via device driver for purposes of storing and retrieving information for use by operating system . Typically a storage device such as storage device will include a wear algorithm provided by the manufacturer of storage device . Such a wear algorithm is depicted in as an integrated wear algorithm . Integrated wear algorithm is stored in storage device in an integrated wear algorithm storage area . As will appreciated in light of the present disclosure integrated wear algorithm storage area can in fact be subsumed in storage area . Integrated wear algorithm is resident in storage device and so is configured to operate from within storage device .

Integrated wear algorithm can for example reduce or partially offset the effects of multiple program and erase cycles on a given block or sector by counting the number of program and erase cycles and dynamically remapping the block s or sector s in order to spread the write operations between the sectors. Another approach is to perform write verification and remapping to spare sectors in case of a write failure a technique called bad block management BBM . For portable consumer devices these wear management techniques can extend the life of the flash memory beyond the life of the device itself. Moreover a given amount of data loss may be more acceptable in certain applications thereby making failures more tolerable. For data storage however such failures are typically catastrophic. Thus simply using the storage device OEM s wear algorithm e.g. integrated wear algorithm is not advisable particularly if the storage device will be subject to a relatively large number of program and erase cycles.

Storage device also provides a storage area for a device specific wear algorithm depicted in as a device specific wear algorithm storage area . As will be appreciated in light of the present disclosure device specific wear algorithm storage area can subsumed in storage area . A device specific wear algorithm DSWA is stored in DSWA storage area . This can be for example a modified sector or block selection algorithm or other algorithm. In fact it will be appreciated that while integrated wear algorithm is a complete wear algorithm and so ready for use in accessing storage device DSWA need not necessarily be a complete wear algorithm. Although DSWA can be a complete wear algorithm DSWA can also be only a portion of a wear algorithm or simply one or more of the parameters used in a wear algorithm.

As noted the result of loading of a wear algorithm e.g. DSWA or generic WA into wear algorithm space is depicted as loaded wear algorithm . In a similar manner a generic WA portion can be loaded into wear algorithm space using loader . This results in a loaded generic WA portion . The loading of generic WA portion may be necessitated for example by DSWA being something less than a complete wear algorithm e.g. resulting from a generic WA portion being employed . This may be the case for example when a wear algorithm needs only parameters to provide support for the various devices to be employed. Thus loaded wear algorithm can be a portion of a wear algorithm or one or more parameters in which case generic WA portion is needed. In the alternative loaded wear algorithm can be a complete wear algorithm and once loaded obviate the need for any generic WA portion. It will also be appreciated that in the alternative generic WA portion can be executed from its initial location.

Operating system is able to access loaded wear algorithm in wear algorithm space via wear algorithm application programming interface API . Operating system is also able to access and control loader via WA API in order to control the loading of one or more wear algorithms e.g. loading a wear algorithm into wear algorithm space . Once the wear algorithm s have been loaded operating system is also able to control their operation via WA API .

In an example of the operation of storage architecture device driver loads DSWA into WA space and thus the copy of DSWA loaded into WA space is thus loaded WA . However if storage device does not contain a device specific wear algorithm or device specific wear algorithm is corrupted a generic wear algorithm can be provided for example as part of device driver . In the situation in which DSWA does not exist or cannot be loaded for some reason generic WA is loaded into WA space a copy of which then exists in WA space as loaded WA . One of skill in the art will appreciate that in light of the present disclosure device driver can be characterized as including a generic portion of the software needed to provide wear leveling capabilities to operating system . This makes operating system and device driver device independent by allowing generic portions of one or more wear algorithms to be included as part of the operating system device driver employed. By contrast the device dependent device specific portion of the wear algorithm can be stored on the storage device and retrieved when this portion is needed. The device dependent device specific portion of the software needed to provide wear leveling capabilities to operating system is represented by DSWA . It will be appreciated that as noted elsewhere this device specific portion can in fact be the entire wear algorithm a portion thereof or simply one or more parameters.

In fact as will be appreciated in light of the present disclosure it is possible to download loaded wear algorithm and or loaded generic WA portion to storage device and more specifically to DSWA storage area . For example certain embodiments allow loaded wear algorithm and loaded generic WA portion to be treated as a single complete wear algorithm. Such might be the case for example if loaded wear algorithm included only parameters for the wear algorithm employed. In that case loaded generic WA portion would be updated with the parameters from loaded wear algorithm and then downloaded to storage device . In operation the wear algorithm thus stored in storage device would be an updated version of loaded generic WA portion . Alternatively if loaded wear algorithm and loaded generic WA portion we portions of a wear algorithm e.g. the code representing one or more formulas and the code for the remaining portion of the wear algorithm for example these separate portions can be merged with one another and the resulting wear algorithm downloaded to storage device . It will be appreciated however that if DSWA storage area were subsumed in storage area DSWA storage area could be exposed to the risk of failure comparable to that of the blocks sectors of storage area .

In certain situations applications uniformly update data in the given storage device e.g. the storage of photographs in a digital camera which are subsequently downloaded from the storage device and then deleted . In this case the storage device is more evenly worn than might otherwise be the case and the device specific optimizations of the selected device specific wear algorithm will take this into consideration. Non volatile memory devices e.g. flash memory devices have also come into widespread use in laptop and desktop computers for example to the point of completely replacing hard drives in some systems. In such systems a variety of applications will potentially make use of such storage devices e.g. the operating system word processing applications spreadsheet applications database applications and so on . Such applications can cause a variety of wear patterns particularly when such storage devices are dealt with as hard drives by operating systems. The selected device specific wear algorithm will take this into account by more aggressively spreading out the program erase cycles. Such effects can be even more pronounced in specific applications dedicated systems e.g. network devices high availability systems and other such applications. In such applications the storage device s lifespan can be unexpectedly short in light of the workloads placed on the storage device. By loading a storage device with multiple device specific wear algorithms the storage device can provide a lifespan optimized for the given application s .

In fact multiple device specific wear algorithms can be stored in the storage device and given one of the device specific wear algorithms loaded based on the age of the storage device e.g. the number of program erase cycles to which the storage device has been subjected . In this scenario each of the device specific wear algorithms is optimized for a given range of program erase cycles. As will be appreciated in light of the present disclosure a wide variety of effects can be taken into consideration in creating the device specific wear algorithms and their combination e.g. using multiple device specific wear algorithms is contemplated hereby.

A device specific wear algorithm can be fashioned in a number of ways. Wear algorithms in common use can be divided for example as follows. It will be apparent in light of the present disclosure that other alternatives can be devised both for the wear algorithms discussed below as well as other wear algorithms. In hot cold swapping one can load the predefined threshold that is used to determine when oldest and youngest blocks are swapped. In static dynamic swapping the predefined threshold used in the HC swapping can be loaded for use in static mode while the round robin parameters used in the dynamic mode can also be made loadable. In a two level replacement scheme the predefined threshold used in the second level of replacement can be made loadable. With a replacement by formula scheme the parameters for the given formula used or even the entire formula can be made loadable. In a CAT approach the parameters for the pre tuned aging function and or the pre tuned aging function itself can be made loadable. For turn based selection values for the x and y parameters used in selecting a block sector can be loaded as can the decision to select blocks sectors randomly or by selecting the next block sector with all live data or some other selection scheme . With old block protection the predefined threshold employed can be made loadable. These and other alternatives will be apparent in light of the present disclosure.

More generally the selection of the next sector to be used by the operating system can be altered in order to more evenly distribute program erase cycles. This holds true not just for sector selection but also by incrementing the sector number in a write block in the device. For writes to small blocks then the writes are packed in one after the other and thus do not use a larger write block for small files. Another alternative is to read wear statistics if available from the device and then write to less worn areas or move blocks which are read only to high wear areas.

Of course it will be apparent in light of the present disclosure that a given wear algorithm can be loaded in whole or in part along with the parameters discussed herein. Moreover not only can the device specific wear algorithm be loaded in toto but may also have one of several sub portions and or parameter sets loaded. Further still the wear algorithm employed can be selected from a number of such wear algorithms and then a specific parameter set loaded for the given application. Many such permutations will be apparent in light of the present disclosure.

It will also be appreciated in light of the present disclosure that the storage device s integrated wear algorithm and a device specific wear algorithm for the storage and application s if such is the case need not employ the same wear algorithm. Conversely the device specific wear algorithm and the integrated wear algorithm can employ the same wear algorithm albeit with different parameters. Also the device specific wear algorithm will typically be designed such that the use of the storage device s integrated wear algorithm and other effects are taken into account. As noted elsewhere herein such effects include which of the integrated wear algorithm and the device specific wear algorithm are invoked first.

It will be noted that variable identifiers e.g. N are used in several instances in the figures described herein to more simply designate the final element of a series of related or similar elements. The repeated use of such variable identifiers is not meant to necessarily imply a correlation between the sizes of such series of elements although such correlation may exist. The use of such variable identifiers does not require that each series of elements has the same number of elements as another series delimited by the same variable identifier. Rather in each instance of use the variable identified e.g. by N or any other such identifier may represent the same or a different value than other instances of the same variable identifier.

Moreover regarding the signals described herein those skilled in the art will recognize that a signal may be directly transmitted from a first block to a second block or a signal may be modified e.g. amplified attenuated delayed latched buffered inverted filtered or otherwise modified between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and or functional aspect of the signal is transmitted between blocks. To some extent a signal input at a second block may be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved e.g. there will inevitably be some attenuation and delay . Therefore as used herein a second signal derived from a first signal may be the first signal or a modification of the first signal whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and or final functional aspect of the first signal.

Another determination is made as to whether or not to load a generic WA portion step . If a generic WA portion is to be loaded e.g. DSWA is only a portion of the given wear algorithm a generic WA portion is loaded into the device driver s wear algorithm space step . Such is the case if for example the generic WA portion is complete except for the parameters to be used. The DSWA loaded in such a scenario will provide the requisite parameters. Alternatively it may be determined that a generic WA portion need not be loaded step . This may be the case if for example the DSWA loaded is a complete algorithm. The operations performed closely parallel those of save for the fact that the generic WA portion is loaded from within the device driver.

A number of permutations with thus be evident in light of the present disclosure. Though not shown in it will be appreciated that multiple DSWA s can be provided within and for a given storage device. This allows the appropriate DSWA to be selected and loaded as part of the process depicted in . In so doing optimized storage device lifetime can be maintained in a multi application environment while supporting access to the storage device by these various applications.

Another possibility is maintaining and or determining information regarding the state of the storage device s memory blocks sectors either individually or by grouping the memory blocks sectors and then using that information to determine which of a number of DSWA s to use. Such a determination can be based on the age of the device or memory blocks e.g. in terms of program erase cycles for an individual memory block sector a group of memory blocks sectors or the storage device the difference between most and least worn memory blocks sectors the amount of data held in each such memory block sector or group thereof or through the use of other such metrics. A variety of adaptive techniques can thus be implemented in embodiments of the present invention. Moreover these and other metrics can also be used as an input to a given wear algorithm allowing for the implementation of self adapting wear algorithms. In light of the present disclosure these and other alternatives will be apparent to one of skill in the art.

The wear algorithm thus loaded is then integrated into the device driver operating system and so made available for use by the operating system in accessing the storage device step . The process of integrating the wear algorithm into the device driver operating system is discussed in greater detail in connection with . If the device specific wear algorithm is not complete it is at this point that the device specific wear algorithm and generic wear algorithm portion can also be integrated with one another. For example the device specific wear algorithm can simply provide parameter values for the generic wear algorithm portion. Integration of the device specific wear algorithm and generic wear algorithm portion can be accomplished by inserting the parameter values into the generic wear algorithm portion resulting in a wear algorithm that is complete. The device driver is then able to provide the operating system with access to the storage device in a manner that provides improved lifespan as compared to such access without the use of such a wear algorithm. In accessing the storage device then the operating system employs the wear algorithm loaded into the wear algorithm space of the device driver step .

If a device specific wear algorithm is unavailable for some reason step a determination is made as to whether a generic wear algorithm is available e.g. generic wear algorithm step . Though not shown it will be appreciated that in light of the present disclosure a determination can also be made to always use a generic wear algorithm regardless of the availability of a DSWA. If a generic wear algorithm is available step the generic wear algorithm is loaded into the wear algorithm space of the device driver step . The process of loading a generic wear algorithm is described in further detail in connection with .

If neither a device specific wear algorithm step nor a generic wear algorithm step are available a determination is made as to whether the user should be notified as to the lack of a wear algorithm that can be loaded into the wear algorithm space of the device driver step . If such notification is desired the user is notified that neither a generic nor a device specific wear algorithm is available step . Though not shown it will be appreciated that such notification can be provided as to the unavailability of the generic wear algorithm or device specific wear algorithm taken alone. Otherwise no such notification is provided. If operating the storage device without either a generic wear algorithm or a device specific wear algorithm is acceptable step access to the storage device is provided using only the integrated wear algorithm that is provided with the storage device or without if no such integrated wear algorithm is provided step . Otherwise access to the storage device is not permitted. In fact though not shown it will also be appreciated that in light of the present disclosure a determination can be made not to use either a generic wear algorithm or a device specific wear algorithm and so always rely on whatever integrated wear algorithm is stored within the storage device.

As noted depicts a flow diagram illustrating a process according to an embodiment of the present invention as do other of the figures depicting flow diagrams that are discussed herein. It will be appreciated that operations discussed herein may consist of directly entered commands by a computer system user or by steps executed by application specific hardware modules. The functionality of steps referred to herein may correspond to the functionality of modules or portions of modules.

The operations referred to herein may be modules or portions of modules e.g. software firmware or hardware modules . For example although the described embodiment includes software modules and or includes manually entered user commands the various example modules may be application specific hardware modules. The software modules discussed herein may include script batch or other executable files or combinations and or portions of such files. The software modules may include a computer program or subroutines thereof encoded on computer readable media.

Additionally those skilled in the art will recognize that the boundaries between modules are merely illustrative and alternative embodiments may merge modules or impose an alternative decomposition of functionality of modules. For example the modules discussed herein may be decomposed into submodules to be executed as multiple computer processes and optionally on multiple computers. Moreover alternative embodiments may combine multiple instances of a particular module or submodule. Furthermore those skilled in the art will recognize that the operations described in example embodiment are for illustration only. Operations may be combined or the functionality of the operations may be distributed in additional operations in accordance with the invention.

Alternatively such actions may be embodied in the structure of circuitry that implements such functionality such as the micro code of a complex instruction set computer CISC firmware programmed into programmable or erasable programmable devices the configuration of a field programmable gate array FPGA the design of a gate array or full custom application specific integrated circuit ASIC or the like.

Each of the blocks of the flow diagram may be executed by a module e.g. a software module or a portion of a module or a computer system user. Thus the above described method the operations thereof and modules therefor may be executed on a computer system configured to execute the operations of the method and or may be executed from computer readable media. The method may be embodied in a machine readable and or computer readable medium for configuring a computer system to execute the method. Thus the software modules may be stored within and or transmitted to a computer system memory to configure the computer system to perform the functions of the module.

The software modules described herein may be received by a computer system for example from computer readable media. The computer readable media may be permanently removably or remotely coupled to the computer system. The computer readable media may non exclusively include for example any number of the following magnetic storage media including disk and tape storage media optical storage media such as compact disk media e.g. CD ROM CD R DVD etc. and digital video disk storage media. nonvolatile memory storage memory including semiconductor based memory units such as FLASH memory EEPROM EPROM ROM or application specific integrated circuits. volatile storage media including registers buffers or caches main memory RAM and the like. In a UNIX based embodiment the software modules may be embodied in a file which may be a device a terminal a local or remote file a socket a network connection or other expedient of communication or state change. Other new and various types of computer readable storage media may be used to store and or convey the software modules discussed herein.

Next a determination is made as to whether the selected device specific wear algorithm is present in the storage device step . If the device specific wear algorithm is present in the storage device step an indication is made as to the availability of the selected device specific wear algorithm for loading into the wear algorithm space of the device driver step . However if the selected device specific wear algorithm is not present in the storage device step an indication is made as to the unavailability of the selected device specific wear algorithm step . If the selected device specific wear algorithm is not available step a determination is made as to the availability of a generic wear algorithm step . If a generic wear algorithm is available step an indication is made with regard to the availability of the generic wear algorithm for loading into the wear algorithm space of the device driver step . However if a generic wear algorithm is also unavailable step an indication is made with regard to the unavailability of the generic wear algorithm step .

The device driver invokes the loaded wear algorithm via the wear algorithm API which allows the device driver to access the storage device in a manner consistent with the wear polices implemented in the loaded wear algorithm. As will be appreciated in light of the present disclosure accessing the storage device can be performed in the normal course in the case in which only one of a device specific or generic wear algorithm is loaded into the device driver. It will be further appreciated that the use of a generic wear algorithm and a device specific wear algorithm can also be combined. Either of the wear algorithms can be accessed before the other as appropriate. For example in the case in which several given applications access the storage device a generic wear algorithm can be employed with a device specific wear algorithm specific to the application and storage device accessed prior to accessing the generic wear algorithm. In such a scenario the generic wear algorithm provides a generally better wear pattern than the storage device s integrated wear algorithm while the device specific wear algorithm fine tunes the wear pattern for the given application and storage device. Moreover it will be noted that a device driver can change the write sector number and store this information locally as shown in . It will be appreciated that in light of the present disclosure such an operation performs a read translation. Alternatively the operating system device driver can be instructed to convert the sector number to the selected sector number. Using the latter approach a read mapping is unnecessary.

Once invoked the loaded wear algorithm calculates the address es at which to perform the write operation step . Using the address es thus calculated the device driver performs the requested write operation to the storage device step . The storage device then receives the write command calculated address es and data from the device driver step . Using its integrated wear algorithm the storage device calculates the internal address es from the calculated address es step . The storage device then performs the requested write operation by storing the data sent by the device driver at the internal address es calculated from the calculated address es received from the device driver step . The write operation is then complete.

In the case in which the requested operation is a read operation step the device driver is called to perform a read operation from the storage device step . As will be appreciated in light of the present disclosure the address translations that occur in performing a read operation are similar to those that occur in performing a write operation according to embodiments of the present invention. Once the device driver is called to perform a read operation the device driver invokes the loaded wear algorithm to perform certain of the address translation operations necessary to performing the read operation step . As before the device driver invokes the loaded wear algorithm stored in the wear algorithm space of the device driver via a wear algorithm API which allows the device driver access to the functionality provided by the loaded wear algorithm. The loaded wear algorithm then calculates address es at which the read operation is to be performed in the storage device step . The device driver then performs the read operation using these calculated address es step . The storage device receives the read command and calculated address es from the device driver step . Using its integrated wear algorithm the storage device calculates internal address es from the calculated address es received from the device driver step . The storage device then performs the requested read operation using the internal address es calculated from the calculated address es received from the device driver step . The storage device then returns the data retrieved by the read operation to the device driver step . The read operation is then complete.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the scope of this invention. Moreover while the invention has been particularly shown and described with reference to these specific embodiments it will be understood by those skilled in the art that the foregoing and other changes in the form and details may be made therein without departing from the scope of the invention.

