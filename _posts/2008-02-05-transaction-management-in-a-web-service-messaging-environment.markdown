---

title: Transaction management in a web service messaging environment
abstract: A method and apparatus for managing database transactions in a web service messaging environment. In one embodiment, the method includes receiving a web service call indicating a beginning of a database transaction from a client, and creating a database transaction in response to this web service call. The method further includes receiving subsequent web service calls from the client, and for each subsequent web service call, associating a corresponding web service call with the database transaction, and performing the corresponding web service call. Afterwards, the database transaction is terminated upon committing or rolling back data resulting from the subsequent web service calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732709&OS=08732709&RS=08732709
owner: Red Hat, Inc.
number: 08732709
owner_city: Raleigh
owner_country: US
publication_date: 20080205
---
Embodiments of the present invention relate to database transactions and more specifically to transaction management in a web service messaging environment.

A web service is typically hosted by a web server or a web application server that provides the HTTP connection between the client software and the server side software handling the implementation of application programming interfaces APIs . The server manages a pool of threads to process concurrent web requests thereby providing parallel processing of those requests. Additionally servers that manage a pool of database connections typically bind an open database connection to the current thread for use during the entire HTTP transaction freeing it back into the pool upon completion.

A web service API call typically is stateless and therefore not conductive to transactions across multiple invocations. For example an API call performed via the XML RPC protocol remote procedure call protocol utilizing XML to encode its calls includes no information that would tie the current API call to previous API calls during the same client session. Accordingly client software lacks the ability to request that multiple units of work that are part of a single logical database transaction be committed or rolled back depending on some client determined final status.

Described herein is a method and system for managing database transactions in web service messaging environment. A transaction manager hosted by a server may receive from a client a web service call indicating the beginning of a database transaction. In response the transaction manager may create a new database transaction and may associate each subsequent web service call received from the client with the new database transaction. The transaction manager may terminate the database transaction upon committing or rolling back data resulting from the subsequent web service calls.

In the following description numerous specific details are set forth such as examples of specific systems languages components etc. in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that these specific details need not be employed to practice the present invention. In other instances well known materials or methods have not been described in detail in order to avoid unnecessarily obscuring the present invention.

The present invention includes various steps which will be described below. The steps of the present invention may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the steps. Alternatively the steps may be performed by a combination of hardware and software.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The present invention may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

The network architecture may also include a pool of servers e.g. web servers or web application servers that host web service instances . The web service instances or simply web services perform operations requested by clients . These operations involve database activities add delete update . Each server may represent a single computing device or multiple servers may represent a single computing device. Each server may host a transaction manager that provides application programming interfaces APIs for managing database transactions and for invoking a corresponding web service to perform database operations that are part of a database transaction.

Each server maintains an HTTP connection between the client software and the transaction manager and manages a pool of threads to process concurrent web requests of clients thereby providing parallel processing of those requests. Additionally the servers can manage a pool of connections with a database and can bind an open database connection to the current thread for use during the HTTP transaction.

Clients may issue web requests using the XML RPC protocol SOAP simple object access protocol JSON RPC Java script object notation remote procedure call protocol or any other protocol facilitating stateless web service calls calls having no knowledge about prior calls from the same client session . Web requests of clients are assigned to individual servers by a load balancer . The load balancer may reside on a separate machine and may be implemented in software hardware or a combination of both. Alternatively the load balancer may reside on the same machine as one or more servers . As will be discussed in more detail below the load balancer ensures that client is bound to a specific server for the duration of the client s session. This allows one server to maintain the state of the client s session rather than inefficiently sharing that information across all servers.

In another configuration the network architecture may not include the load balancer . Rather one or more of the servers may perform the functionality of the load balancer or the functionality of the load balancer may not be provided at all e.g. if there is only one instance of server .

As will be discussed in more detail below the transaction manager allows client software to issue several calls of the web service and to request that multiple database changes resulting form these web service calls be part of a single database transaction and take effect all at once or none at all depending on the final state of the transaction. A database transaction may consist of a connection to the database and a transaction identifier tied to that connection. When the transaction manager causes the database changes associated with a database transaction to be committed or rolled back the transaction manager terminates the database transaction by releasing the database connection back to the pool.

Next the client module issues another web service API call to start a database transaction. The client module sends the cookie with the start transaction API call. The load balancer intercepts this API call and directs it to the designated server based on the cookie .

The transaction manager receives the start transaction API call ensures that the sender has been previously authenticated and creates a new database transaction. In particular the transaction manager opens a database connection creates unique transaction ID and associates it with the caller ID received via the cookie . Upon exit of the API call the transaction manager does not close the database connection but rather saves it in the state of the calling client.

Subsequently the client module issues a web service API call to request an operation that is part of the database transaction. Again the web service API call is send with the cookie and is intercepted by the load balancer to determine which server should process this request using the cookie .

When the transaction manager receives the web service API call it ensures that the caller has been previously authenticated and determines the transaction ID based on the caller ID from the cookie. Then the transaction manager restores the database connection and pending transaction onto the current thread and performs the web service API call. If the web service performs the requested operation successfully the transaction manager notifies the client module about it. If not the transaction manager sends an error message to the client module . Data resulting from the operation performed by the web service remains uncommitted in database e.g. it is not seen by other callers .

The client module repeats web service API calls until it decides that the database transaction is completed. At this point the client module issues an API call to commit or roll back data associated with the pending database transaction. This API call is passed to the transaction manager in the manner discussed above. The transaction manager then causes the data associated with the pending database transaction to be committed or rolled back and terminates the database transaction by releasing the database connection back to the pool.

Alternatively the transaction manager may terminate the database transaction without receiving a commit or rollback API call from the client module . Instead the transaction manager may determine that a time period elapsed since the last API call received from client module exceeds a predefined threshold or the duration of the database transaction exceeds a predefined time interval and may assume that the database transaction is no longer valid. The transaction manager may then cause the data associated with the pending database transaction to be rolled back and may terminate the database transaction by releasing the database connection back to the pool.

The session API is responsible for setting up a stateful session by creating a unique identifier and sending it back to the client software via a cookie e.g. an HTTP cookie such as cookies created for use by web browsers . This may be configured as the same cookie name used by any load balancer in the environment to bind an inbound client connection to a specific web server and function as a point of unique identification inside the API software for the caller. This cookie will be passed back transparently to all API calls for the life of the client software run cycle. The session API establishes a logical connection between the client software and a specific web server instance and also establishes a stateful session identifier.

The start transaction API creates a unique transaction ID and associates it with the caller ID from the cookie. Use of a separate distinct caller ID allows for parallel independent transactions from the client. Exiting an API call does not cause the database connection to be closed. Instead the database connection is saved in the state of the calling client. Since all subsequent calls to the API framework will be directed back to the same server via the cookie the transaction manager then detects a pending transaction and restores the database connection and pending transaction onto the current thread before continuing to process the API call.

The commit transaction API causes the data associated with the pending database transaction to be committed to the database and terminates the database transaction by releasing the database connection back to the pool. The rollback transaction API causes the data associated with the pending database transaction to be rolled back deleted from the database and terminates the database transaction by releasing the database connection back to the pool.

Referring to method begins with processing logic receiving a web service call from a client block and determining whether the web service call was issued to authenticate the client block . If the web service call was issued to authenticate the client processing logic authenticates the client credentials included in the client request block and determines whether the credentials are satisfactory block . If not processing logic returns an error message to the client block . If so processing logic creates a session using a caller ID assigned to the client block and sends the caller ID to the client via a cookie block .

If the web service call was not issued to authenticate the client processing logic determines whether the client has been previously authenticated using the caller ID included in the cookie passed with the web service call block . If not processing logic returns an error message to the client block . If so processing logic determines whether the current web service call is a call to start a new database transaction block . If it is a call to start a new database transaction processing logic creates a new database transaction block associates the database transaction ID with the caller ID block saves the database connection in the state of the calling client and exits the web service call.

If the current web service call is not a call to start a new database transaction processing logic determines whether the current web service call is a call to commit or rollback a pending database transaction. If so processing logic causes the data associated with the pending database transaction to be committed or rolled back block and terminates the database transaction. If the current web service call us not a call to commit or rollback the pending database transaction processing logic detects the pending transaction restores the database connection and pending transaction onto the current thread and performs the web service call block .

Referring to method beings with processing logic sending an API call to authenticate the client block . In response processing logic receives a cookie with a caller ID assigned to the client by the server block and stores the cookie locally for the life of the client run cycle block .

At block processing logic sends a start transaction API call with the cookie to the server. At block processing logic sends a web service API call with the cookie to the server to request an operation that is part of the new database transaction. At block processing logic receives a response from the server indicating whether the requested operation was performed successfully and determines whether the database transaction should continue block . If so processing logic returns to block . If not processing logic sends a commit or rollback API call with the cookie to the server block .

The exemplary computer system includes a processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device which communicate with each other via a bus .

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processor is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine readable storage media. The software may further be transmitted or received over a network via the network interface device .

While the machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

