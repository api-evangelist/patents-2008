---

title: Container for disparate software components
abstract: A computer readable medium embodying instructions executable by a processor to perform a method for hosting components implemented in different computer readable languages within one process. The method includes instantiating a container within a single process, creating a hosting environment for each of a plurality of components, and wherein loading the components by respective environments and wherein the hosting environments are objects instantiated within the container and within the one process, and wherein the plurality of components are implemented in respective a computer readable language, and instantiating a container communication framework object within the container and the one process for processing serialized messages of the components, wherein specific language adapters convert data types of the components to a common implementation, wherein the messages of the plurality of components are processed within the container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08365191&OS=08365191&RS=08365191
owner: Siemens Corporation
number: 08365191
owner_city: Iselin
owner_country: US
publication_date: 20080916
---
This application claims the benefit of Provisional Application No. 60 976 812 filed on Oct. 2 2007 in the United States Patent and Trademark Office the contents of which are herein incorporated by reference in its entirety.

The present disclosure relates to software frameworks and more particularly to a system and method for enabling software components implemented in different technologies running within one process.

A container is a runtime entity that provides services to specialized components e.g. lifecycle management dependency management and configuration. The container is an application that can host components and provides special services to this components.

Containers are technology specific for example written for Java .NET etc. For example an OSGi Java container specified by the OSGi Alliance formerly known as the Open Services Gateway initiative is a Java based service platform that can be remotely managed. The OSGi specification is a framework that defines an application lifecycle model and a service registry. The OSGi container natively supports loading and hosting of Java components but has no support for other technologies.

In a Java Framework implementation the Java SDK allows hosting C components DLLs in a Java Virtual Machine JVM process. A java function call loads this DLL via the Java Native Interface JNI the components of which can be activated and interact with each other. The Java Framework allows only C DLLs to be loaded.

Referring to the .NET Framework The .NET Framework has a function call that loads a C component into the .NET virtual machine process. Via PInvoke the two components can interact with each other. The .Net Framework from Microsoft supports only the loading of C DLLs.

In each of these technologies OSGi Java and .Net loading and hosting of different technologies in a single process is not supported.

While communication between processes is possible it introduces inefficiencies and additional resource overhead. For example for components hosted in separate application processes inter process communication uses for example sockets remote procedure calls RPC etc.

Therefore a need exists for a system and method for enabling software components implemented in different technologies to be hosted in a container implemented as a single process.

According to an embodiment of the present disclosure a computer readable medium is provided embodying instructions executable by a processor to perform a method for hosting components implemented in different computer readable languages within one process. The method includes instantiating a container within a single process creating a hosting environment for each of a plurality of components wherein the hosting environments are objects instantiated within the container and within the one process and wherein the plurality of components are implemented in respective a computer readable language and instantiating a container communication framework object within the container and the one process for processing serialized messages of the components wherein specific language adapters convert data types of the components to a common implementation wherein the messages of the plurality of components are processed within the container.

According to an embodiment of the present disclosure a method for creating a device for hosting software components implemented in different computer readable languages includes instantiating a container within one process executing on a processor creating a hosting environment for each computer readable language wherein the hosting environments are objects instantiated within the container and wherein each the hosting environment supports at least one software component within the one process loading the components by respective environments and instantiating the components within the container and instantiating a container communication framework object within the container for processing serialized messages of the components wherein specific language adapters convert data types of the components to a common implementation within the container and wherein the container manages the components through the container communication framework.

According to an embodiment of the present disclosure a computer readable medium is provided embodying instructions executable by a processor to perform a method for hosting components implemented in different computer readable languages within one process. The method includes instantiating a container within one process creating a hosting environment for each of a plurality of components wherein the hosting environments are objects instantiated within the container and within the one process and wherein the plurality of components are implemented in respective a computer readable language and instantiating a container communication framework object within the container and the one process for processing messages of the components wherein language adapters associated with respective hosting environments convert messages of the components to a common implementation for inter component communication wherein the conversion of the messages includes serializing the messages passed to the container communication framework object and deserializing replies to the messages received from the container communication framework object.

According to an embodiment of the present disclosure a multi technology container herein after container implemented as a single process allows for the hosting of software components implemented in different technologies including C C .Net Java etc. According to an embodiment of the present disclosure a container is technology independent. A separate hosting environment is created for each technology needed by the software components. A container may be implemented in for example an environment for migrating software written in different technologies into one process. In other exemplary implementations a container can be used for Supervisory Management Control Systems supporting human resource applications implemented in different technologies Service Oriented Architecture SOA for business processes implemented in different technologies etc. Further legacy software can be wrapped as component and hosted within one process and used with new components written in different technologies. Different implementations can be written in various technologies using container concept.

According to an embodiment of the present disclosure a process is an instance of a computer program that is being sequentially executed by a processor see . The process is an execution of the computer program. Different processes may share the same set of instructions in memory. Each execution of the computer program is an instance.

A service manager associates a list of component managers for a service. A configuration manager determines which component belongs to a service. There is one service manager object for every service.

Each component manager represents and holds all resources for one deployed component. The component manager is responsible for loading unloading initializing uninitializing and activating deactivating one component. The component manager object contains a component instance configuration for its corresponding deployed component instance e.g. a component among components and the description of the component type. The component instance configuration contains information in which technology a component is written. For every configured component in a container configuration one component manager instance is created.

A component frame provides a generic framework to host a component for a specific technology and hides technology specifics from the component manager and service manager and lifecycle manager . For example the component frame for Java manages loads instantiates deletes unloads a JVM JavaVirtualMachine which is the runtime environment needed to execute Java code. Another task of the component frame is to manage a component frame stub a component frame skeleton and a component frame service . The component frame is instantiated once per technology e.g. C or CPP Java .Net etc. during a startup phase of the container . There is one object instance for each technology.

The component frame stub serializes API Application Programming Interface calls and parameters and uses the component frame to send messages to a service skeleton . In general stubs and skeletons define interfaces for applications and services which allow other applications services to interact with them. The stub and skeleton files are generated automatically in C .Net and Java whereas the definition of such an interface is described with an service interface description language. The generator can be extended to generate stubs and skeletons for other technologies. The stubs are created in the same technology as the container e.g. C .

Return messages are received from the container communication framework deserialized by the stub and given back to the caller. The component frame stub is instantiated once per technology like the component frame during the startup of the container .

The component frame skeleton deserializes the messages and calls the component frame service implementation . The return values are also serialized by the skeleton and sent back as messages to the component frame stub . The skeleton is written in a specific technology and instantiated once per technology during the startup of the container .

Serialization converts an object message data type file etc. for transmission across a the container communication framework in binary form. When the resulting series of bytes is received across the container communication framework according to the serialization format it can be deserialized to a form appropriate to the side of the container communication framework e.g. for a certain component or the common implementation.

The component frame service is the command handler of the lifecycle manager for every component. The component frame service loads activates deactivates and unloads the hosted components . The component frame service hosts all components for a specific technology. The component frame service is written in a specific technology and instantiated once per technology.

The container communication framework is the transport component for serialized messages. The container communication framework decouples technologies offering technology specific language adapters LAs which handle the technology specific conversion of data types. The container communication framework in the container decouples the component written in a specific technology from the container core. For inter technology communication the container communication framework may use a shared memory. The data is only copied into a shared memory buffer and copied back from the shared memory into data. There is no change of the data during this process. The specific language adapter is handles the technology specific conversion.

A configuration parser reads the container configuration. The container configuration contains the component that the container will host. Referring to each component description contains a tag indicating in which technology the component is written.

The container instantiates the lifecycle manager one component frame for each technology one component frame stub for each technology the container communication framework one component frame skeleton for each technology and the component frame service for each technology. The container reads the container configuration . The container configuration contains information about which component will to be hosted by the container . The container configuration contains information about what interfaces are provided by such a component which interfaces the components use and in which technology the components are written.

For every configured component in the container configuration a component manager object is created. The component manager knows from the configuration in which technology the hosted component is written. To load and start a component the component manager initiates a start command to the respective component frame . The component frame forwards the call to its associated component frame stub . The component frame stub uses the communication framework language adapter to serialize and send the message from a client side to a service side of container communication framework . The communication framework language adapter performs the data type conversion in the respective technology on both sides of the container communication framework .

In case of the container the message gets written into the C Language Adapter assuming the container is written in C . On the service side of the container communication framework the component frame skeleton receives the message. In case of a Java component the component frame skeleton Java receives the message and reads the message data from the Java language adapter of the container communication framework . The component frame skeleton deserializes the message and passes the call to the component frame service . The component frame service loads and activates the Java component natively.

In each of the environments through its component frame service component frame skeleton component frame stub component frame the cross environment container communication framework instantiates objects and manages the loading of the hosted components using for example Jar files DLL files Assembly DLL files etc.

During the container startup the container reads the configuration using a getTechnology method e.g. and configures the lifecycle manager accordingly with AddComponentFrame method . All enabled component frames are added to the lifecycle manager .

The lifecycle manager distinguishes different interface instances with the help of the technology name. The lifecycle manager loads a component DLL creates an instance adds the instance to a set of known instances and initializes the instance . The lifecycle manager then starts a component frame skeleton and component frame service see .

Note that there is no configuration item needed for component frame CPP because component frame CPP will be loaded with the container . This can be seen in where loading the component frame C uses only the AddComponentFrame method without an accompanying getTechnology method.

The container configuration can be extended to support the container to check whether the corresponding component frame should be loaded or a corresponding stub should be connected.

Referring to after the activate method of component frame skeleton Java in this example is invoked the container communication framework is registered with its interface. The container service manager can now delegate the component frame stub for Java to let the component frame service load initialize configure and activate the Java components via component frame skeleton

The lifecycle manager is not restricted to the three described technologies C Java .Net and can be extended by other technologies. The component frame implements the interface which will be called by the container lifecycle manager to instantiate the component frame .

It is to be understood that the present invention may be implemented in various forms of hardware software firmware special purpose processors or a combination thereof. In one embodiment the present invention may be implemented in software as an application program tangibly embodied on a program storage device. The application program may be uploaded to and executed by a machine comprising any suitable architecture.

It is to be understood that embodiments of the present disclosure may be implemented in various forms of hardware software firmware special purpose processors or a combination thereof. In one embodiment a software application program is tangibly embodied on a program storage device. The application program may be uploaded to and executed by a machine comprising any suitable architecture.

Referring now to according to an embodiment of the present disclosure a computer system for enabling software components in a container that are implemented in different technologies inter alia a central processing unit CPU a memory and an input output I O interface . The computer system is generally coupled through the I O interface to a display and various input devices such as a mouse and keyboard. The support circuits can include circuits such as cache power supplies clock circuits and a communications bus. The memory can include random access memory RAM read only memory ROM disk drive tape drive etc. or a combination thereof. The present invention can be implemented as a routine that is stored in memory and executed by the CPU to process the signal from the signal source . As such the computer system is a general purpose computer system that becomes a specific purpose computer system when executing the routine of the present disclosure.

The computer platform also includes an operating system and micro instruction code. The various processes and functions described herein may either be part of the micro instruction code or part of the application program or a combination thereof which is executed via the operating system. In addition various other peripheral devices may be connected to the computer platform such as an additional data storage device and a printing device.

It is to be further understood that because some of the constituent system components and method steps depicted in the accompanying figures may be implemented in software the actual connections between the system components or the process steps may differ depending upon the manner in which the system is programmed. Given the teachings of the present disclosure provided herein one of ordinary skill in the related art will be able to contemplate these and similar implementations or configurations of the present disclosure.

Having described embodiments for enabling software components implemented in different technologies in a container it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in embodiments of the present disclosure that are within the scope and spirit thereof.

