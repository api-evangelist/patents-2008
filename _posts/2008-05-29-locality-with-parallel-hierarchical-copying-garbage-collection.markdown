---

title: Locality with parallel hierarchical copying garbage collection
abstract: A garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. More specifically, the present invention provides a garbage collection method and system for copying objects from a from-space to a to-space. The method comprises the steps of (a) having multiple threads that simultaneously perform work for garbage collection (GC), (b) examining the placement of objects on blocks, and (c) changing the placement of objects on blocks based on step (b). Preferably, the method includes the additional step of calculating a placement of object(s) based on step (b), and using the result of the calculation for step (c). For example, the calculation may be used to increase the frequency of intra-block pointers and/or to increase the frequency of siblings on the same block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024379&OS=08024379&RS=08024379
owner: International Business Machines Corporation
number: 08024379
owner_city: Armonk
owner_country: US
publication_date: 20080529
---
This application is a continuation application of application Ser. No. 11 450 946 filed Jun. 9 2006 now abandoned.

This invention generally relates to automatic memory management and more specifically the invention relates to methods and systems for copying garbage collection.

In operation computer programs spend a lot of time stalled in cache and Translation Lookaside Buffer TLB misses because computation tends to be faster than memory access. For example Adl Tabatabai et al. report that the SPECjbb2000 benchmark spends 45 of its time stalled in misses on an Itanium processor Ali Reza Adl Tabatabai Richard L. Hudson Mauricio J. Serrano and Sreenivas Subramoney. Prefetch injection based on hardware monitoring and object metadata. In PLDI 2004 . Better locality reduces misses and thus improves performance. For example techniques like prefetching or cache aware memory allocation improve locality and can significantly speedup the performance of a program.

Locality is in part determined by the order of heap objects in memory. If two objects reside on the same cache line or page then an access to one causes the system to fetch this cache line or page. A subsequent access to the other object is fast. Copying garbage collection GC can change the order of objects in memory. To improve locality copying GC should strive to colocate related objects on the same cache line or page.

Copying GC traverses the graph of heap objects copies objects when it reaches them and recycles memory of unreachable objects afterwards. Consider copying a binary tree of objects where each cache line can hold three objects. When the traversal uses a FIFO queue the order is breadth first and results in the cache line layout in . When the traversal uses a LIFO stack the order is depth first and results in the cache line layout in . In both cases most cache lines hold unconnected objects. For example breadth first order colocates oand owith o even though owill usually not be accessed together with oor o.

Intuitively it is better if an object occupies the same cache line as its siblings parents or children. Hierarchical copy order achieves this . Moon invented a hierarchical GC in 1984 and Wilson Lam and Moher improved it in 1991 Paul R. Wilson Michael S. Lam and Thomas G. Moher. Effective static graph reorganization to improve locality in a garbage collected system. In PLDI 1991 calling it hierarchical decomposition . The algorithms by Moon and by Wilson Lam and Moher use only a single GC thread. Using multiple parallel GC threads reduces GC cost and most product GCs today are parallel.

An object of this invention is to reduce cache and TLB misses by changing the order in which a parallel garbage collector copies heap objects.

Another object of the present invention is to provide a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads.

A further object of this invention is to improve locality with parallel hierarchical copying garbage collection.

Another object of the invention is to provide a garbage collection algorithm that both reduces cache and TLB misses through hierarchical copying and also maintains good scaling on multiprocessors.

These and other objectives are attained with a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. More specifically the present invention provides a garbage collection method and system. The term block as used herein refers to a cache line or page or other unit of OS HW support for memory hierarchy.

The preferred embodiment of the invention described in detail below reduces cache and TLB misses and in this way improves program run time. Also parallel garbage collection improves scaling on multi processor machines.

Further benefits and advantages of the invention will become apparent from a consideration of the following detailed description given with reference to the accompanying drawings which specify and show preferred embodiments of the invention.

In accordance with the present invention a garbage collection algorithm is provided that achieves hierarchical copy order with parallel garbage collection threads. illustrate as an example one suitable computer system in which the present invention may be used. This computer system according to the present example includes a controller processor which processes instructions performs calculations and manages the flow of information through the computer system . Additionally the controller processor is communicatively coupled with program memory . Included within program memory are a garbage collector operating system platform Java Programming Language Java Virtual Machine JVM glue software a memory allocator Java application a compiler and a type profiler . It should be noted that while the present invention is demonstrated using the Java Programming Language it would be obvious to those of ordinary skill in the art in view of the present discussion that alternative embodiments of the invention are not limited to a particular computer programming language.

The operating system platform manages resources such as the data stored in data memory the scheduling of tasks and processes the operation of the garbage collector in the program memory . The operating system platform also manages a graphical display interface not shown that directs output to a monitor having a display screen a user input interface not shown that receives inputs from the keyboard and the mouse and communication network interfaces not shown for communicating with a network link not shown . Additionally the operating system platform also manages many other basic tasks of the computer system in a manner well known to those of ordinary skill in the art.

Glue software may include drivers stacks and low level application programming interfaces API s and provides basic functional components for use by the operating system platform and by compatible applications that run on the operating system platform for managing communications with resources and processes in the computing system .

Each computer system may include inter alia one or more computers and at least a computer readable medium . The computers preferably include means for reading and or writing to the computer readable medium . The computer readable medium allows a computer system to read data instructions messages or message packets and other computer readable information from the computer readable medium. The computer readable medium for example may include non volatile memory such as Floppy ROM Flash memory disk drive memory CD ROM and other permanent storage. It is useful for example for transporting information such as data and computer instructions between computer systems.

The present invention as mentioned above provides a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. The prior art has not been able to achieve this. In order to best understand the significance and advantages of the present invention several prior art garbage collection algorithms shown in are discussed below.

Cheney s algorithm copies in breadth first order see because it scans gray objects first in first out. One advantage of Cheney s algorithm is that it requires no separate stack or queue to keep track of its progress saving space and keeping the implementation simple. Cheney s algorithm uses only one thread for garbage collection it is not parallel.

Moon modified Cheney s algorithm to improve locality by copying in hierarchical order instead of breadth first. illustrates Moon s algorithm David A. Moon. Garbage collection in a large Lisp system. In 1984 . To space is now divided into blocks. As before objects are copied by bumping the free pointer which separates gray objects from empty space. But instead of just one scan pointer Moon maintains two scan pointers. The primary scan pointer is always in the same block as the free pointer. For example in both the primary scan pointer and the free pointer point into block D.

If there are gray objects at the primary scan pointer Moon scans them. If the free pointer reaches the next block for example E Moon advances the primary scan pointer to the start of that block even though there may still be gray objects in the previous block for example D . The secondary scan pointer keeps track of the earliest gray objects for example in block B . If the primary scan pointer catches up with the free pointer Moon scans from the secondary scan pointer until the primary scan pointer points to gray objects again. If the secondary scan pointer catches up with the free pointer as well GC is complete.

Moon s algorithm copies objects in hierarchical order. For example in Moon s algorithm first copies oand its children oand o into the same block. Next it copies o the first child of o into a different block. At this point the block with ohas a gray object at the primary scan pointer so Moon proceeds to copy the children of ointo the same block as o. Only when it is done with that block does it continue from the primary scan pointer which still points into o.

The mutator is the part of an executing program that is not part of the GC the user program and run time system components such as the JIT compiler. Moon s GC is concurrent to the mutator but there is only one active GC thread at a time no parallel GC threads.

One problem with Moon s algorithm is that it scans objects twice when the secondary scan pointer advances through already black objects for example in block C in .

Wilson Lam and Moher Paul R. Wilson Michael S. Lam and Thomas G. Moher Effective static graph reorganization to improve locality in a garbage collected system In 1991 improve Moon s algorithm by avoiding re scanning of black objects. illustrates Wilson Lam and Moher s algorithm. It keeps track of the scan pointers in all partially scanned blocks. When the block with the free pointer contains gray objects for example block D scanning proceeds in that block otherwise it proceeds from the earliest block with gray objects for example block B . The copy order of Wilson Lam and Moher s algorithm is identical to that of Moon s algorithm see . The hierarchical copying GC algorithm by Wilson Lam and Moher is neither parallel nor concurrent.

In 1985 Halstead published the first parallel GC algorithm Robert H. Halstead Jr. Multilisp A language for concurrent symbolic computation. 7 4 1985 . It is based on Baker s GC Henry G. Baker Jr. List processing in real time on a serial computer. 21 4 1978 which is an incremental variant of Cheney s GC C. J. Cheney. A nonrecursive list compacting algorithm. 13 11 1970 . Halstead s GC works on shared memory multiprocessor machines with uniform access time to the shared memory. The garbage collector works in SIMD single instruction multiple data style each worker thread performs the same GC loop on different parts of the heap. The mutator may be SIMD or MIMD multiple instruction multiple data . As illustrated in at any given point in time either GC threads are running or mutator threads are running but not both. The GC is parallel but not concurrent.

Halstead s algorithm partitions to space into n equally sized parts on an n processor machine. illustrates the heap organization for n 2. Worker thread i has a scan pointer scans and a free pointer frees which point to gray objects and empty space in their respective parts of to space. Termination detection is simple when scan freefor all i then there are no more gray objects to scan anywhere. Since each thread has its own private part of to space the threads do not need to synchronize when scanning objects in to space or allocating memory in to space. But they do need to synchronize on individual objects in from space if two worker threads simultaneously encounter pointers to the same object in from space only one of them should copy it and install a forwarding pointer.

Like Cheney Halstead has the advantage of requiring no separate queue or stack to keep track of gray objects because within the part of to space that belongs to a thread the objects themselves are laid out contiguously and form an implicit FIFO queue. The algorithm therefore copies in breadth first order . Unfortunately the static partitioning of to space into n parts for n processors leads to work imbalance. This imbalance causes two problems overflow and idleness. Overflow occurs when a worker thread runs out of empty space to copy objects into. Halstead solves this problem by providing additional empty space to worker threads on demand. Idleness occurs when one thread runs out of gray objects to scan while other threads are still busy. Halstead does not address the idleness problem caused by work imbalance.

In 1993 Imai and Tick published the first parallel GC algorithm with load balancing Akira Imai and Evan Tick. Evaluation of parallel copying garbage collection on a shared memory multiprocessor. 4 9 1993 . Their algorithm extends Halstead s algorithm by over partitioning on an n processor machine it partitions to space into m blocks where m n.

The aliasing between copy and scan blocks avoids a possible deadlock where the only blocks with gray objects also have empty space. In addition it reduces contention on the shared work queue when there are many GC threads. Imai and Tick s GC only checks for an aliasing opportunity when it needs a new scan block because the old scan block is completely black. Inai and Tick evaluated their algorithm on 14 programs written in a logic language. They report parallel speedups of 4.1 to 7.8 on an 8 processor machine. Their metric for speedup is not based on wall clock time but rather on GC work number of cells copied plus number of cells scanned it thus does not capture synchronization overhead or locality effects. The present invention effectively achieves hierarchical copy order with parallel GC threads.

The implementation of parallel hierarchical copying GC is based on the generational GC implemented in the International Business Machines Corporation s IBM s J9 Java Virtual Machine JVM . It uses parallel copying for the young generation and concurrent mark sweep with occasional stop the world compaction for the old generation. This is a popular design point in products throughout the industry. The baseline GC has exactly two generations and young objects remain in the young generation for a number of birthdays that is adapted online based on measured survival rates. We are only concerned with copying of objects within the young generation or from the young generation to the old generation.

The baseline GC uses Imai and Tick s algorithm for the young generation. To accommodate tenuring each worker thread manages two copy blocks one for objects that stay in the young generation and another for objects that get tenured into the old generation. Either block may be aliased as scan block.

Parallel hierarchical GC achieves hierarchical copy order by aliasing the copy and scan blocks whenever possible. That way it usually copies an object into the same block that contains an object that points to it. This is the parallel generalization of the single threaded algorithm by Wilson Lam and Moher that uses the scan pointer in the block with empty space whenever possible. Blocks serve both as the work unit for parallelism and as the decomposition unit for hierarchical copying. It may be noted that the term block as used herein including the claims refers to a cache line or page or other unit of Operating System OS and Hardware HW support for memory hierarchy.

For example a copy block must have room to copy objects into therefore all incoming transition labels to state copy are at least partially empty. If the copy block has some gray objects and some empty space then it can serve both as copy block and as scan block simultaneously and the GC aliases it therefore the transition from state copy to state aliased is labeled with colorings that include both gray and empty. The state machine in is non deterministic the state and coloring of a block alone do not determine which transition it takes. Rather the transitions depend on the colorings of both the copy block and the scan block of the worker thread.

Table 1 shows the actions that the GC thread performs after scanning a slot in an object. For example if the copy block contains both gray slots and empty space and the scan block is already aliased with the copy block column scan aliased no action is necessary before the next scanning operation. If the copy block contains gray and black and no empty space or is completely gray and the scan block is not aliased the thread transitions the copy block to the aliased state and either puts the scan block back on the scanlist if it still has gray slots or transitions it to the done state if it is completely black.

As described in Table 1 parallel hierarchical GC leads to increased contention on the scanlist. To avoid this the preferred implementation caches up to one block from the scanlist with each thread. Thus if there is a cached block the action scanlist scan really obtains that cached block instead. Likewise the transition scan scanlist really caches the scan block locally possibly returning the previously cached block to the scanlist in its stead.

Presented below is an evaluation of parallel hierarchical copying GC PH compared to parallel breadth first copying GC BF .

Like Cheney s algorithm and the other Cheney based algorithms parallel hierarchical GC requires no separate mark stack or queue of objects. Instead the gray objects are consecutive in each block thus serving as a FIFO queue. On the other hand like Imai and Tick s algorithm the GC of this invention requires a shared work pool of blocks to coordinate between GC threads. In addition it requires per block data to keep track of its state and coloring.

After scanning a gray slot parallel hierarchical GC checks immediately whether it became possible to alias the copy block and the scan block. Since this check happens on the innermost loop of the GC algorithm it must be fast. The immediacy of this check is what leads to hierarchical order like in the algorithms by Moon and by Wilson Lam and Moher.

The goal of hierarchical copy order is improved mutator locality. But of course it also affects GC locality and load balancing. This effect can be positive or negative.

As mentioned earlier in the preferred implementation each GC thread actually manages two copy blocks one each for young and old objects. Only one of them can be aliased at a time.

Experiments were conducted with a modified version of the International Business Machine Corporation Java 2 Platform Standard Edition J2SE 5.0 J9 GA Release IBM s product Java Virtual Machine running on real hardware in common desktop and server operating systems. This section discusses the methodology.

The platform for the following four sections was a dualprocessor IA32 SMT system running Linux operating system. The machine has two 3.06 GHz Pentium 4 Xeon processors with hyperthreading. The memory hierarchy consists of an 8 KB L1 data cache 4 way associative 64 Byte cache lines a 512 KB combined L2 cache 8 way associative 64 Byte cache lines a 64 entry data TLB 4 KB pages and 1 GB of main memory. The platforms for other sections are described there.

Table 2 shows the benchmark suite consisting of 26 Java programs SPECjbb2005 the 7 SPECjvm98 programs the 10 Da Capo benchmarks 2 Ashes benchmarks and 6 other big Java language programs. Column MB gives the minimum heap size in which the program runs without throwing an OutOfMemoryError. The rest of this discussion reports heap sizes as nx this minimum heap size.

To reduce the effect of noise on the results all experiments consist of at least 9 runs Java Virtual Machine process invocations and usually several iterations application invocations within one Java Virtual Machine process invocation . For each SPECjvm98 benchmark a run contains around 10 to 20 iterations at input size 100. Each run of a DaCapo benchmark contains two or more iterations on the largest input.

This section shows the effect of hierarchical copying on runtime for 25 Java programs. A 26th program SPECjbb2005 is discussed in more detail below.

The speedup columns of Table 3 show the percentage by which parallel hierarchical copying PH speeds up or slows down run time compared to the baseline parallel breadth first copying BF . They are computed as

None of the benchmarks experienced speedups at some heap sizes and slowdowns at others. The benchmarks are sorted by their maximum speedup or slowdown at any heap size. Out of these 25 programs 13 speed up 4 are unaffected and 8 slow down. The discussion below will show that SPECjbb2005 also speeds up. While speedups vary across heap sizes we observed no pattern. The program with the largest slowdown is ipsixql which maintains a software LRU cache of objects. Because the objects in the cache survive long enough to get tenured but then die ipsixql requires many collections of the old generation. The program with the largest speedup is db which experiences similar speedups from depth first copy order. Depth first copy order requires a mark stack hence it is not considered further herein.

Parallel hierarchical copy order speeds up the majority of the benchmarks compared to breadth first copy order but slows some down. It may be possible to avoid the slowdowns by deciding the copy order based on runtime feedback.

Parallel hierarchical copying GC tries to speed up the mutator by improving locality. The discussion above showed that most programs speed up but some slow down. The discussion immediately below explores how mutator and garbage collection contribute to the overall performance.

Table 4 breaks down the results of running in 4 the minimum heap size into mutator and collector. The Time columns show improvement percentages of parallel hierarchical copying PH compared to breadth first BF higher numbers are better negative numbers indicate degradation. The TLB misses columns show miss rates per retired instruction in percent lower is better which TLB and other hardware characteristics will be discussed below in more detail . A indicates that PH has a higher miss rate than BF a indicates that it has a lower miss rate and a 0 indicates that there is no statistically significant difference. The benchmarks are ordered by the total speedup from Table 3.

When there is a measurable change with few exceptions the mutator speeds up and the collector slows down. Even fop and kawa which experienced no overall speedup experience a small mutator speedup. Usually TLB miss rates decrease both in the mutator and in the GC. For the mutator this explains the speedup for the GC this does not prevent the slowdown caused by executing more instructions to achieve hierarchical order. The large reduction in mutator TLB misses for db from 7 to 5.5 leads to an overall speedup despite having the largest GC slowdown of 37.6 . Hierarchical copying only slows down collections of the young generation but since most objects in db die young collections of the young generation dominate GC cost.

To conclude parallel hierarchical copying trades GC slowdown for mutator speedup. This is a reasonable tradeoff as long as GC scaling on multiprocessors is not impacted.

The discussion herein shows how to achieve hierarchical copy order in a parallel GC. The goal of parallel GC is to scale well in multi processor systems by using all CPUs for collecting garbage. This is necessary to keep up with the mutator since it uses all CPUs for allocating memory and generating garbage. The present discussion investigates how well parallel hierarchical copying GC scales.

All numbers in are mutator transactions per GC time. Higher numbers indicate that the mutator gets more mileage out of each second spent in GC indicating better GC scaling. There are curves for parallel breadth first BF copying parallel hierarchical PH copying and PH with no cached block PHNCB . All numbers are normalized to BF at 1 thread. The error bars show 95 confidence intervals. With 8 GC worker threads both BF and PH run around 3 times faster than with 1 thread. Without the cached block optimization from the above section PH would not scale it would run 46 slower with 8 threads than with only 1 thread PHNCB .

Whereas shows how SPECjbb2005 s GC time scales shows how its total throughput scales on three hardware platforms. SPECjbb2005 measures throughput as transactions per second which should increase with the number of parallel mutator threads warehouses . The three platforms are 

In each of the graphs the x axis shows the number of warehouses parallel mutator threads and the y axis shows the throughput transactions per second relative to the BF throughput with 1 warehouse. Higher is better in these graphs because it means that more transactions complete per second.

On all three platforms throughput increases until the number of warehouses reaches the number of logical CPUs which is twice the number of physical CPUs due to hyperthreading. At that point parallel hierarchical GC has a 3 8 and 5 higher throughput than the baseline GC. Increasing the number of threads further does not increase the throughput since there are no additional hardware resources to exploit. But hierarchical GC sustains its lead over the baseline GC even as threads are increased beyond the peak.

To conclude parallel hierarchical copying GC scales no worse with increasing load caused by parallel applications than parallel breadth first copying GC. A single threaded GC on the other hand would have a hard time keeping up with the memory demands of several parallel mutators.

In a small heap GC has to run more often because the application exhausts memory more quickly. This increases the cumulative cost of GC. On the other hand in a small heap objects are closer together which should intuitively improve locality. This section investigates how these competing influences play out.

This confirms the conclusions from above parallel hierarchical GC performs well in both small and large heaps.

The goal of hierarchical copying is to reduce cache and TLB misses by colocating objects on the same cache line or page. This section uses hardware performance counters to measure the impact of hierarchical copying on misses at different levels of the memory subsystem.

Pentium processors expose hardware performance counters through machine specific registers MSRs and many Linux operating system distributions provide a character device dev cpu msr to access them. Doing modprobe msr ensures the presence of this device for experiments in user mode the files must be readable and writeable for users. The JVM sets up the registers for collecting the desired hardware events at the beginning of the run and reads them at the beginning and end of GC accumulating them separately for the mutator and the GC.

To conclude parallel hierarchical copying GC reduces TLB misses most while also reducing L1 and L2 cache misses significantly. These reduced miss rates translate into reduced run time.

The above section already demonstrated that hierarchical copying reduces cache and TLB misses. This section validates that it achieves that by colocating objects on the same cache line or page.

For this experiment the GC records the distance between the address of a pointer and the address of the object it points to just after a copying or forwarding operation. Pointers with an absolute distance under 64B are classified as Line and pointers with an absolute distance between 64B and 4 KB are classified as Page . The numbers only consider pointers from objects in the young generation to other objects in the young generation and from newly tenured objects in the old generation to other newly tenured objects in the old generation. Among other things this disregards pointers between young and old objects those have longer distances but are rare and hierarchical copying cannot colocate them on the same page.

Table 5 shows pointer distances. For example db with breadthfirst copying yields 9.4 pointers that are longer than 64 bytes but under 4 KB whereas parallel hierarchical copying improves that to 65.1 . Except for SPECjbb2005 all runs used heaps of 4 the minimum size.

These numbers show that parallel hierarchical copying succeeds in colocating objects on the same 4 KB page for the majority of the pointers. This explains the reduction in TLB misses observed in Table 4. Also parallel hierarchical copying colocates objects on the same 64 byte cache line much more often than the baseline garbage collector. This explains the noticeable reduction in L1 and L2 cache misses observed above.

While hierarchical copying is tremendously successful at improving spatial locality of connected objects wall clock numbers from a real system Table 3 paint a more sober picture. This discrepancy underlines three points i Hierarchical copying trades GC slowdown for mutator speedup. The result of this tradeoff is determined by the concrete benchmark GC implementation and platform. ii Hierarchical copying aims at decreasing TLB and cache miss rates. When the application working set is small compared to the memory hierarchy of the machine miss rates are already so low that decreasing them further helps little. iii Hierarchical copying optimizes for the hierarchical hypothesis that connectivity predicts affinity. In other words it assumes that objects with connectivity parents or siblings in the object graph also have affinity the application accesses them together . Not all applications satisfy the hierarchical hypothesis.

It should be noted that the present invention or aspects of the invention can be embodied in a computer program product which comprises all the respective features enabling the implementation of the methods described herein and which when loaded in a computer system is able to carry out these methods. Computer program software program program or software in the present context mean any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation and or b reproduction in a different material form.

While it is apparent that the invention herein disclosed is well calculated to fulfill the objects stated above it will be appreciated that numerous modifications and embodiments may be devised by those skilled in the art and it is intended that the appended claims cover all such modifications and embodiments as fall within the true spirit and scope of the present invention.

