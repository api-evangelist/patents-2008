---

title: Functional updates for tree processing
abstract: An API for functionally updates to data represented in trees, such as XML trees, is provided. Functional updates can be implemented using an update combinator to search for matching nodes and apply an indicated function to those matching nodes. This API can be used in non-functional languages, such as procedural languages or scripting languages. Updates are performed without side effects since a shallow clone is created for at least a portion of a tree. Nodes of the tree can be streamed into memory so that only a portion of a large tree is present in memory at any time. Artificial intelligence can be used by the API to optimize performance under the circumstances, such as optimizing based on node type that is to be updated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370391&OS=08370391&RS=08370391
owner: Microsoft Corporation
number: 08370391
owner_city: Redmond
owner_country: US
publication_date: 20080325
---
The subject disclosure relates to updates of computer application data sources represented in a tree such as functionally updating deleting and replacing nodes in an XML tree.

Structured data is often used to store large amounts of data for enterprise class applications and systems. The structured data often contains data related to an organization such as the organization s inventory product catalogs sales payroll employees accounts locations customers vendors. This structured data is increasingly being stored and manipulated in trees such as XML trees. Unlike relational databases traditionally used to store and manipulate structured data trees offer a significant number of advantages. For example trees can better represent hierarchal relationships and are often more portable across different computer platforms and or different software systems. Moreover trees unlike relational database tables also facilitate transformation into different data representations such as an alternative representation of the data in the tree. However unlike relational databases trees are often not associated with a database server and lack a standard Application Programming Interface API such as SQL that allows both querying and data manipulation e.g. updating deleting inserting and transforming data.

Traditionally tree processing APIs are inefficient in meeting programmer s needs which in turn creates problems for developing enterprise class applications that use trees as a data source. For example a dichotomy often exists between querying and transformation of data represented in a tree even though transformations and queries are often used together. As an example a single transformation often performs one or more queries while transforming the input tree such as to find those elements and attributes to include in the transformed tree.

As an example a number of different XML APIs are available for querying such as Xquery and Linq for XML and XML transformation such as XSLT. These XML APIs are often lazy and impure when performing imperative operations meaning that undesirable side effects or obscure problems often occur.

For example when imperative updates are performed on multiple nodes during a transformation an instance of the Halloween problem occurs. In particular when the first node is deleted or updated the internal query for matching nodes ceases because the node list is cut off as seen by the ongoing query. Fortunately APIs calls such as Linq for XML s ToList function call are available to take a snapshot of query results before any updates are performed so that the query can continued to be performed on that copy. However a programmer needs to explicitly call the API function to allow pure updates and many end user programmers are unaware of the need as evidenced by numerous bug reports. In addition creating a snapshot is expensive in performance and memory to perform in every transformation especially if only a few nodes are updated.

In addition many tree based APIs are designed to be in memory APIs such as a DOM based API and are unable to handle extremely large tree datasets that an enterprise class application would be expected to handle. Complexity is added to an application when more than one API is used depending on the amount of data to be processed. Accordingly programmers may choose to use slower non in memory APIs even when the tree being processed is small enough to be manipulated using an in memory API.

Furthermore many tree processing APIs are not strongly typed. As a result API implementations are often unable to catch errors early or optimize their implementations for the input data.

The above described deficiencies of tree processing APIs are merely intended to provide an overview of some of the problems of today s tree processing APIs and are not intended to be exhaustive. Other problems with the state of the art may become further apparent upon review of the description of various non limiting embodiments of the invention that follows.

A simplified summary is provided herein to help enable a basic or general understanding of various aspects of exemplary non limiting embodiments that follow in the more detailed description and the accompanying drawings. This summary is not intended however as an extensive or exhaustive overview. Instead the sole purpose of this summary is to present some concepts related to some exemplary non limiting embodiments of the invention in a simplified form as a prelude to the more detailed description of the various embodiments of the invention that follows.

An API for functionally updates to data represented in trees such as XML trees is provided. This API can be used in languages with side effects such as object oriented languages procedural languages or scripting languages. For example the API can be used in C C C VISUAL BASIC Pascal JavaScript or Java.

In one aspect update combinators are used that parallel XPath like query axes. These update combinator can be used to search for an indicated element attribute comment processing instruction text node or descendant. The matching node can then be updated using an indicated function as part of the update combinator. The update can include deleting the matching node or conditional deleting the matching node.

In at least one embodiment the API is integrated into and or extends part of a more general XML processing API such as XSLT Xquery or LINQ to XML. Advantageously this facilitates the use of the API by programmers that are already familiar with the more general XML processing API.

In one aspect updates are performed without side effects since a shallow clone is created for at least a portion of a tree. Advantageously the shallow clone can reduce memory requirements and the nodes of the tree can be streamed in memory so that only a portion of a large tree is present in memory at any time.

According to one aspect artificial intelligence AI can be used by the API to enhance its functionality. For example AI can be used determine whether or not to use an in memory API depending on various factors e.g. the size of the tree memory currently available number of processes running etc. . AI can be used to determine how much of the tree to clone when updating. Moreover AI can be used to optimize the functional update based on the node type being searched for and or the XML schema XML document type definition DTD being used.

According to one aspect the API can implement both synchronous and asynchronous calls to the API. However in other embodiments only one type of call can be available. Moreover the API can be used in distributed applications where the call is made in a client application and the functional update is performed on a server.

As discussed in the background imperative updates of trees often are associated with undesirable side effects. Hence functional updates are used to update one or more nodes of a tree. Since the API automatically clones at least a portion of the tree an end user programmer does not need to explicit create a copy or create a list of the nodes as a programmer does in imperative updates to avoid the Halloween problem.

Referring to a development environment in which a programmer uses an Application Programming Interface API that provides functional updates is illustrated. The illustrated environment includes various APIs as well as an integrated development environment . The integrated development environment includes various development tools such as compilers interpreters debuggers a text editor a make utility and a project manager used to write source code build the application and test the application.

A programmer writes source code using various APIs that will be compiled or interpreted to provide various functionality. The APIs can be associated with a particular programming language e.g. Visual Basic C Javascript Pascal C C or managed code environment e.g. .NET Java virtual machine . In the illustrated environment there is the tree processing API a user interface API and an input output API . The user interface API creates a user interface that is displayed to a user and responds to the user s input. The input output API controls provides access to various input output devices such as the printer or a network card. Additional functionality is written by the programmer using the language constructs of one or more programming languages used to develop the application. For example the business logic of an application is typical written using language constructs in combination with API calls. One will appreciate additional APIs can be used by the programmer such as a data access API e.g. SQL ODBC ADO etc. or a shell API e.g. to execute programs create shell extensions etc. . Furthermore one will appreciate that functionality can be combined in different manners to produce more or less APIs.

After the programmer develops the application the application can be used by computer users. illustrates an example enterprise class application that uses the described functional updates according to one embodiment. The application comprises one or more tree data sources such as XML files that store data being manipulated using the application. Data can be also be optionally stored in one or more relational data sources . The user interface provides the user with an interface to interact with the application. For example a graphical user interface command line interface or speech recognition text to speech interface can be presented to the user. The business logic provides logic for performing the functionality associated with the application. This business logic can include querying and updating the tree data sources.

One will appreciate that an enterprise application can be a distributed multi tiered application that distributes its functionality between different components that can be one or more computers. For example the enterprise application can be a client server application. In this case in at least one embodiment although the API call to update can be executed on the client the functional update can occur on a software component on the server. As an example the update combinator can be sent to the server for update processing ala SQL updates .

In particular the XML file in is an XML file that represents the organizational structure of a company. One will realize that this is only an exemplary scenario and any XML vocabulary can be used with the functional update API. Each employee or manager has various elements associated with them namely an element named name and salary. illustrates a tree representation of a portion of the XML file of .

According to one scenario it is desired to increase all salaries by a predetermined factor. Since the salary elements can be contained within multiple elements e.g. manager and employee there is no easy manner of encoding the problem using traditional query oriented transformation style without recursive functions.

Using functional updates this can be performed using x.Updatedescendants n f where n is the element label to match and f is a function to apply to a matched node. The function with the parameters filled in is called an update combinator. Other update combinators include x.UpdateElements n f x.UpdateTopMost n f or x.UpdateArguments n f . Some update combinators UpdateElements f match all nodes and be used to apply a function to all nodes. In each case the update combinators reconstruct the input tree as they descend into the tree.

Update combinators for descendants recurse into the incoming element while searching for matching nodes. In the case of an optimized UpdateDescendants the recursion performs a full traversal. In the case of UpdateTopMosts recursion ceases if a suitably named element is encountered.

For some or all of the combinators the argument function can express deletion by returning null for a given element or node . Insertion can be allowed by creating a new XElement object with the appropriate children nodes and attributes if any. The definition of the functional update combinator for descendants can assume a bottom up order or top down order and can be optimized at run time depending on the input tree. Other variations and controls can be useful as known from the art of generic functional programming.

Update combinators can align with important XPath like query axes. Just as much additional query axes can be introduced or prioritized additional functional combinators can be defined in reply.

In one embodiment the functional update API can be built on top of the LINQ to XML functions that generally perform imperative updates. However update combinators can be built on top of other tree processing APIs.

Sharing and optimization techniques can be also be used to enhance performance. For instance when node identity is not observable not observed by the queries and transformations then optimizations can actually avoid cloning for arbitrarily large subtrees along functional updates if no changes are performed. Also when the parent axis is not observable not observed by the queries and transformations then identical subtrees can be shared for their occurrences in the input and the output of the transformation.

Functional updates can be used while streaming an input tree. If a given transformation is assembled from functional updates that only point downward as all of the exemplary combinators then the cloning part of the functional updates can be directly mapped to copy semantics on serialized input and output.

Functional updates also provide a discipline for the XSLT style of programming. XSLT templates directly encode recursion on the input tree without any use of combinators. Thus XML query language like XQuery can be enhanced to cover the key expressivity of XSLT by incorporating functional updates. It is important to notice that the XSLT style of transformation is indeed functional as opposed to imperative updates of LINQ to XML or the Update Facility under way for XQuery.

Although simple functions are used for the sake of clarity one will appreciate that more complex function can be utilized. For example a function can raise salaries by different factor in various tiers.

Advantageously the function update API can be implemented as an enhancement to a more general XML or SGML processing API such as XQuery or XSLT. One will also appreciate that the API can be implemented in other programming languages including object oriented procedural declarative scripting compiled or interpreted programming languages.

The described tree manipulation API is not limited to XML trees. For example an SGML tree can also be manipulated using the API. In addition trees can be created from external data such as a configuration file that specifies different hierarchical settings e.g. global and local settings . As an example a non XML configuration file for a web server with different inherited settings for different directories or domains can be transformed into a tree that can then be updated using functional updates.

An optional streaming component can be used to limit the amount of memory used such as to a predetermined amount . The optional streaming component can limit the memory used by streaming the tree rather than placing the entire tree in memory.

One will appreciate that other components not shown can be used to optimize the search or applying the function. For example if the indicated function is complex and there are many nodes to updates the output value for the function for a given input can be cached. Although this takes additional memory if the same input value occurs many times e.g. salaries are being updated and all employees for a given job and experience level are paid the same and the function is sufficiently complex the running time of the update can be reduced.

An optional artificial intelligence component can be used to further optimize the search and or the functional updates. illustrates the artificial intelligence component of . Specifically artificial intelligence engine and evaluation components can optionally be provided to implement aspects of the subject invention based upon artificial intelligence processes e.g. confidence inference . For example the artificial intelligence component can use artificial intelligence to optimize the query for matching nodes or applying the indicated function. For example the artificial intelligence component can utilize the XML schema and or XML DTD associated with the XML tree being processed to determine whether an element can be a descendant of another element and if not the search of that subtree can be skipped. Moreover artificial intelligence can be used to determine whether and how much memory to use given the size of the tree and the expected number of updates. As yet another example AI can be used to determine if additional updates will later be performed on the tree and thus the tree should remain in memory.

The use of expert systems support vector machines greedy search algorithms rule based systems Bayesian models e.g. Bayesian networks neural networks other non linear training techniques data fusion utility based analytical systems systems employing Bayesian models etc. are contemplated by the AI engine . These training techniques can be calibrated using exemplary operations that are periodically performed.

In addition the AI component can be utilized at run time to perform these operations or during compilation of the source code or any combination thereof.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it should be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flowcharts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

One will appreciate that when the tree being manipulated is relatively small the entire tree can be cloned and updates performed on the cloned tree. Moreover the tree can be kept in memory if this known that additional updates will be performed on the tree.

One will appreciate that illustrates only an example application that uses the described tree manipulation API. As described previously the tree manipulation API can be used in an enterprise class application that use XML data sources directly and thus there is no need to create the tree representation and or re create the non tree representation.

The invention applies to any device wherein it may be desirable to manipulate data represented in a tree. It should be understood therefore that desktop handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the present invention i.e. anywhere that a device may process or store data represented in a tree. Accordingly the below general purpose remote computer described below in is but one example and the present invention may be implemented with any client having network bus interoperability and interaction.

Although not required the invention can partly be implemented via an operating system virtual machine or browser environment for use by a developer of services for a device or object and or included within application software that operates in connection with the component s of the invention. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that the invention may be practiced with other computer system configurations and protocols.

With reference to an exemplary computing device for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer . By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media.

The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up may be stored in memory . Memory typically also contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation memory may also include an operating system application programs other program modules and program data.

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example computer could include a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and or an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. A hard disk drive is typically connected to the system bus through a non removable memory interface such as an interface and a magnetic disk drive or optical disk drive is typically connected to the system bus by a removable memory interface such as an interface.

A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through user input and associated interface s that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A graphics subsystem may also be connected to the system bus . A monitor or other type of display device is also connected to the system bus via an interface such as output interface which may in turn communicate with video memory. In addition to a monitor computers may also include other peripheral output devices such as speakers and a printer which may be connected through output interface

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such as a personal area network PAN a local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter. When used in a WAN networking environment the computer typically includes a communications component such as a modem or other means for establishing communications over the WAN such as the Internet. A communications component such as a modem which may be internal or external may be connected to the system bus via the user input interface of input or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in a remote memory storage device. It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.

While some exemplary embodiments herein are described in connection with software such as an application programming interface API residing on a computing device one or more portions of the invention may also be implemented via an operating system or a middle man object a control object hardware firmware intermediate language instructions or objects etc. such that the methods for tree data manipulation in accordance with the invention can be included in supported in or accessed via all of the languages and services enabled by a managed code framework such as .NET code and in other computing languages frameworks as well.

The word exemplary is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used in either the detailed description or the claims for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements.

While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of writing code and nomenclature that achieves the same similar or equivalent functionality achieved by the various embodiments of the invention.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the tree manipulation functionality of the present invention e.g. through the use of a data processing API reusable controls or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer etc. the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.

Furthermore the disclosed subject matter can be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term article of manufacture or alternatively computer program product where used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick . Additionally it is known that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN .

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments can be produced or modifications and additions can be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example while exemplary network environments of the invention are described in the context of a networked environment such as a client server networked environment one skilled in the art will recognize that the present invention is not limited thereto and that the methods as described in the present application can apply to any computing device or environment such as a mainframe laptop desktop server etc. whether wired or wireless and can be applied to any number of such computing devices connected via a communications network and interacting across the network.

While exemplary embodiments refer to utilizing the present invention in the context of particular programming language constructs the invention is not so limited but rather may be implemented in any language to provide methods for functional updating trees.

Still further the present invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

