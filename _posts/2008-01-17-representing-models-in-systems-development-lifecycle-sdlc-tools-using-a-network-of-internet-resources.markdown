---

title: Representing models in systems development lifecycle (SDLC) tools using a network of internet resources
abstract: In the present solution, as set of SDLC resources can be established, where each is separately addressable through a unique URL and is able to be managed through a simple set of operations. For example, a set of RESTful operations (GET, POST, PUT, and DELETE) can be used for the operations. Database management technologies can be leveraged for storing and indexing resources, but the underlying database schema for the solution can operate on a resource level, which results in the resources being stored as-is. Thus, storage (even when database based) of resources for the solution can be considered an Internet server exposing a space of URL addressable objects. Because the solution leverages Internet technologies and standards, it is scalable, standards based, extensible, and traceable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122422&OS=09122422&RS=09122422
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09122422
owner_city: Armonk
owner_country: US
publication_date: 20080117
---
The present invention relates to the field of software development tooling and more particularly to representing models in SDLC tools using a network of Internet resources.

A Systems Development Life Cycle SDLC is a collection of process methods and tools used by various roles to develop an information system including requirements validation training and user ownership through investigation analysis design implementation and maintenance. Required artifacts in the SDLC can be modeled using a variety of software modeling tools and standards such as the Systems Modeling Language SysML Integrated DEFinition IDEF Entity Relationship Diagrams E R Unified Modeling Language UML processing modeling tools and the like. Each of these tools manage a set of associated artifacts where an artifact is a software construct that represents any logical or physical asset created or maintained through a SDLC. For descriptive purposes a model is a type of artifact with a structured representation used by modeling tools.

SDLC tooling can be analyzed in terms of the following general requirements scalability interoperability extensible model representations and traceability within and between models. Scalability refers to an ability of a solution to support hundreds of thousands if not millions or artifacts in its repository without unreasonable measures being taken. Interoperability which can be realized in a SDLC context through open APIs ensures that users are not locked into a specific tooling provided by a repository vender which can increase purchase and maintenance costs can be limiting in terms of utilization of emerging technologies and can result in other problems typical of a lock in situation. An extensible model representation describes models in a manner that permits them to carry and utilize additional information such as information contributed by an additional tool or end user. Extensible tools should have an ability to validate added content. Traceability within and between models refers to an ability of an approach to satisfy user needs to express and understand relationships between models and other SDLC artifacts. Relationships can include peer relationships e.g. a customer having multiple accounts for which particular SDLC artifacts relate temporal relationships e.g. an artifact was created from another artifact and trace relationships e.g. showing which SDLC artifacts are associated with which sets of requirements .

Conventional SDLC modeling tools manage artifacts using either a database storage approach or a file system and version control system approach each of which has significant shortcomings. Prior Art illustrates a conventional database storage approach and a conventional model file approach for storing and managing SDLC artifacts.

The database storage approach provides tools that operate in a client server configuration where information is stored in tables of a server database . An underlying schema for artifacts is fixed in advance and tools read write to specific tables in a shared database . Since approach relies upon a database foundation it is as scalable as the underlying database upon which it is constructed. Similarly API s used for approach depend upon those of an underlying database. Extensibility and traceability of approach can require a restructuring of underlying database structures which can be expensive and time consuming. Additionally many database implementations include proprietary codes and structural constraints which can make user desired modifications difficult. Further user interfaces built on top of a database can require changes as a database structure changes.

A file and version control system VCS approach can create artifacts on the file systems of the user s machines which results in artifacts being stored in a set of storage spaces . These storage spaces can be nested by designating a set of spaces usually geographically grouped at a location having a primary function related to the type of artifact being stored. Within any set of spaces numerous sub spaces can exist. Searching for a given artifact can require searching through all the storage spaces . This searching can be optimized by grouping different types of artifacts so that only a subset of the storage spaces need be searched for a given type of artifact such as searching space . This optimization assumes that a user s search criteria matches criteria through which the artifacts are grouped. Sometimes a complete index of files in spaces is maintained by a set of one or more servers. Approach generally scales poorly and performance degrades quickly as an overall artifact quantity increases. Approach often uses proprietary code and APIs with variable extensibility characteristics depending upon coding practices used to implement an instance of approach . Most conventional solutions following approach have limited to no traceability within and between models.

The present invention discloses a solution for designating software resources as URL addressable objects. Software resources can include Systems Development Life Cycle SDLC artifacts. Relationships and linkages among the resources can be established using the URLs. Each individual resource can be defined using standard Web based languages such as using XML or any other HTML based derived language. Additionally the resources can be stored in a manner that maintains their internal structure. That is when stored in a database each resource is able to be stored as is without breaking down the internal structure into multiple tables or into a database schema where an atomic unit is less than the resource level. Servers for managing the various resources can be established which accept Representational State Transfer REST based commands. Thus operations against resources can occur in a stateless fashion using a set of simple operations e.g. GET PUT POST and DELETE . The disclosed solution is able to leverage tools and technologies used for storing searching and manipulating Web documents since each SDLC resource is considered a URL addressable object. Optionally database technologies can be leveraged in the solution which is able to maintain a separate set of indexes for managed resources to optimize search times and performance.

The present invention can be implemented in accordance with numerous aspects consistent with the materials presented herein. One aspect of the present invention can include a repository server for managing a network of individual resources each of which is associated with an information technology IT asset. The server can include a data store and a REST Application Program Interface API . The data store can store a set of SDLC resources each resource having a unique addressable Uniform Resource Identifier URI associated with it. Each of the SDLC resource can represent a physical or logical IT asset. Each resource can utilize a standardized markup language to specify asset details. The network of individual resources can be linked to other resources using messages conforming to at least one standard network messaging protocol. The REST API can be configured for submitting resource related requests to the data store. The REST API can receive and respond to an HTTP GET command an HTTP PUT command an HTTP POST command and an HTTP DELETE command.

Another aspect of the present invention can include a software object representing a information technology asset from which models are able to be built. The software object can represent a physical or logical IT asset. The software object can also include an addressable URI and at least one additional attribute. The URI is uniquely associated with the asset. The attribute is used to specify a value for the represented asset. The software object is able to be linked to other software objects having unique URI addresses using HTTP based links.

Still another aspect of the present invention can include a method for specifying IT assets that includes storing and managing a set of SDLC artifacts as a network of individual resources. Each individual resource can have a unique and addressable URI associated with it. Each of the SDLC artifacts can represent a physical or logical information technology asset. Each resource can utilizes a standardized markup language to specify asset details wherein said network of individual resources are linked to other resources using messages conforming to standard network messaging protocols.

It should be noted that various aspects of the invention can be implemented as a program for controlling computing equipment to implement the functions described herein or as a program for enabling computing equipment to perform processes corresponding to the steps disclosed herein. This program may be provided by storing the program in a magnetic disk an optical disk a semiconductor memory or any other recording medium. The program can also be provided as a digitally encoded signal conveyed via a carrier wave. The described program can be a single program or can be implemented as multiple subprograms each of which interact within a single computing device or interact in a distributed fashion across a network space.

Each resource can include a unique identifier which can be an addressable Uniform Resource Identifier URI . Each resource can use standardized languages such as extensible Markup Language XML a Hypertext Markup Language HTML or any other language markup based or otherwise to specify asset details. Resources can be linked to other resources using standard messages conforming to standard network messaging protocols. A set of resources can be stored and managed within an open Internet repository of resources based upon Hypertext Transfer Protocol HTTP and Representational State Transfer REST principles.

In terms of scalability approach leverages the scalability model employed by the Internet today which is almost endlessly scaleable. Each resource is separately addressable and is managed through a simple set of operations. In one embodiment database management technologies can be leveraged for storing and indexing resources . Unlike conventional database implementations however a database schema for the resources is intended to store the resources as is rather than having specific tables established for different resource types and resource attributes. Thus storage even when database based of resources for approach can be considered an Internet server exposing a space of URL addressable objects. Links between resources are only of concern to the client navigating a network of resources .

In terms of using open Application Program Interfaces APIs approach uses a REST style of HTTP usage which is a foundational concept of the Internet architecture. Interactions with resources can occur statelessly through a set of basic primitive commands such as HTTP GET HTTP POST HTTP GET and HTTP DELETE. REST commands able to be handled by many Web browsers. That is most Web browsers can retrieve review resources directly without a need for specialized tooling. Additionally any REST based tool can used for retrieving adding updating and deleting resources which makes API considerations for approach a non issue.

Unlike conventional approaches which rarely permit SDLC artifacts to be extended with additional content in approach resource formats become part of the contract between servers and client tools. In other words formats for SDLC can be standardized in any manner. A base standard can be established by a standardizing organization such as the World Wide Web Consortium W3C for example which can be extended at will. In one embodiment resource representations can be defined using XML and can specifically require namespace aware processors such that extensions to resource formats can be defined in different XML namespaces and can therefore be mixed in to resources in ways that do not affect the client processing of the resources .

In terms of traceability the resources are each treated as separate objects able to be linked to using URLs. This approach works by providing a very simple and extensible REST messages mechanism for both intra and inter resource links. In one embodiment traceability relationships with resources can be indexed so as to be able to produce resources to reverse queries. Traceability operations can be handled in the same manner as other linkages to the resources even when traceability or other operations represent actions not known a priori by a resource designer. New functionality can even be added post deployment so long as the standard conventions for URL referencing of the resources are utilized.

It should be appreciated that the approach is vastly different from conventional systems that either don t implement traceability capabilities or that implement them with separate and distinct tools. Use of separate tool can result in fragmentation of information and fragile links. Other conventional approaches attempt to define a single model that describes a set of concepts in a domain and the set of relationships among them. These approaches suffer from a closed world view where the model becomes hard to extend and is often too rigid to accommodate new concepts and operations.

As shown in system a repository server can maintain a database of resources that are currently being managed by the server . The resources can be stored in a data store database local to server or can be stored in a more distributed fashion where server maintains a set of URLs for the stored resources which are used to reference the resources regardless of their actual storage location. Server can also maintain a set of indexes for the resources which permits queries to be executed against the resources . In one embodiment the indexes can be stored in a relational database so that standard queries can be efficiently executed against the indexes such as SQL queries and commands.

The server can include an auditing component a reporting component and or a search component each of which can utilize information stored in repository and or . The auditing component can provide traceability capabilities for the resources can show a change and usage history for the resource and the like. Version control functions such as check in and check out functions can also be performed handled by auditing component . The reporting component can permit any type of report involving the resources to be generated. Reports of component can include SQL based reports standard system provided reports and user customized reports. Dynamic report generation and or an ability to save and re use previously created reports can be included in component . The search component can permit cross repository text searches and or intra repository searches. Database and Web searching technologies can both be implemented within search component to provide robust extensible and responsive search capabilities.

All the capabilities of server can be accessed through REST API . That is HTTP requests e.g. HTTP GET HTTP POST HTTP PUT and HTTP DELETE can be used to communicate with server . Server communications can originate from a SDLC specific tool from more generic tools from any REST interface and even from a standard or enhanced browser .

The server can be any computing device or set of computing devices able to manage resources as described. In one embodiment the server can represent a physical server having installed software that executes locally. In another embodiment the server can also represent a virtual server or a distributed server which is physically implemented by one or more hardware devices that may be distributed from each other. In still other embodiments server can further be implemented as a cluster of servers or as a resilient set of servers linked in an autonomic manner. Use of REST standards and Internet protocols makes it easy implement functions of server is a highly configurable and flexible manner.

The indexes and resources can each be data stores configured to maintain digitally encoded information. Each of the data stores can be physically implemented within any type of hardware including but not limited to a magnetic disk an optical disk a semiconductor memory a digitally encoded plastic memory a holographic memory or any other recording medium. Each data stores can be a stand alone storage unit as well as a storage unit formed from a plurality of physical devices. Additionally information can be stored within each of the data stores in a variety of manners. For example information can be stored within a database structure or can be stored within one or more files of a file storage system where each file may or may not be indexed for information searching purposes. Further each data store can utilize one or more encryption mechanisms to protect stored information from unauthorized access.

In diagram an HTTP POST command can be sent from tool to REST API where the command creates a new resource. The new resource can be validated then inserted into storage using a database insert command . A command to update indexes associated with the new resource can be conveyed to an indexer . The indexer can be a full text search engine such as APACHE LUCENE. When the new resource is successfully created a created response e.g. HTTP 201 code can be returned to the SDLC tool . Otherwise an appropriate error code can be returned to tool .

In diagram a HTTP GET command can be sent from tool to REST API where the command attempts to retrieve an existing resource. The request can be first validated . If valid a retrieval request can be sent to storage for the resource. The request can for example be a database select query. A series of conditional actions can then occur based upon requests of the resource request to storage . If the requested resource is not found in storage then a Not Found message e.g. HTTP 404 code can be conveyed from REST API to SDLC tool . The requested resource can be found in storage but marked as deleted in which case a Gone message e.g. HTTP 410 code can be returned to tool . The requested resource can be of an incompatible type compared to the stored resource format determined based upon the Accepts request header for example in which case a Forbidden response e.g. HTTP 403 code can be sent to tool . If the discovered resource has not been changed since the client last attempted to access it determined using HTTP entity tags and conditional requests for example the server can return a Not Modified response e.g. HTTP 304 code to tool . If everything succeed a Success message e.g. HTTP 200 code can be conveyed.

In diagram a HTTP PUT command can be sent from tool to REST API where the command is for updating an existing resource. The request can be validated which is followed by a database query . The query can be for example a SQL select command from API to storage for finding the existing resource. If the requested resource is not found in storage then a Not Found message e.g. HTTP 404 code can be conveyed from REST API to SDLC tool . The requested resource can be found in storage but marked as deleted in which case a Gone message e.g. HTTP 410 code can be returned to tool . The requested resource can be of an incompatible type compared to the stored resource format determined based upon the Accepts request header for example in which case a Forbidden response e.g. HTTP 403 code can be sent to tool . If the discovered resource has not been changed since the client last attempted to access it determined using HTTP entity tags and conditional requests for example the server can return a Not Modified response e.g. HTTP 304 code to tool . If everything succeeds an update SQL action can be performed. Indexes for the resource can then be updated via command after which a Success indicator can be sent to the tool .

In diagram a HTTP DELETE command can be sent from tool to API to remove an existing resource from storage the request can be validated and the resource to be deleted can be searched for in storage . Various checks i.e. Not Found Gone can be performed to ensure the resource exists in storage . If so a SQL delete command can be issued to storage to delete the resource and indexes can be updated. A suitable response depending upon whether the delete operation was successful can be sent to the SDLC tool .

The diagram is expressed in approximately third normal form as is standard for database schema representations. As shown a many to many relationship can exist between resource collection table and resource table which are joined by resource collection associative table . This indicates that a resource can be part of many collections and that each collection can include many resources. A many to many relationship also exists between the resources and users linked through resource user table . This indicates that resources can be accessed updated created deleted by many different users and that users can manipulate many different resources.

As shown each resource of table can be uniquely identified by a URL which serves as a primary key for table . Other attributes of table can include a body a content type a modification id a last modified value an etag a status and the like. A set of table attributes can be tailored optimized for the HTTP protocol which allows for efficient protocol operations while provisioning for protocol specific capabilities such as write contention detection and deletion reporting. The body of a resource is a stored software object not having a specific shape type or structure. Thus structured XML files word processor documents image files and the like can be equally well stored and managed by this schema.

In one contemplated derivation of schema different types of resource body objects can be stored in different tables along with content type specific attributes in which case the body and content type can together serve as a foreign key relating table to these remote tables. This emphasizes that the schema of diagram can be easily adapted by skilled database designers to handle an arbitrary level of complexity.

Resources of table can be structured to create models which can each be a collection definable by table entries. Resource structure within a model can be indicated by attribute values of the resource collection associative table . For example a structure level can indicate a resource s position in a hieratical structure. When resources are able to be structured in a parent child relationship structural table can be used to denote these relationships where each child and parent element is a foreign key to an entry of the table . Different structural attributes can be included in structure table to indicate structural characteristics important to the associated model. The schema of diagram can be modified to include any number of structure defining tables and attributes. Thus derivative schemas can be constructed to characterize any desired software model formed from structuring a set of resources.

Code of Prior Art shows a representation of the use case of using a commonly modeling format e.g. OMG s XML Metadata Interchange XMI . demonstrates a closed world view implemented by many conventional modeling tools. The assumption of code is that there is a root model element that contains everything needed for all SDLM artifacts. In code links within a model are separate and distinct from links to external resources which are links that use proprietary URL formats. Also tools associated with code do not expect arbitrary extension data to be included in the artifact which limits their extensibility. Instead the tools at best discard or ignore extension data. At worse extension data can render a related artifact unusable. Code is an XMI representation of a UML model and an associated tool can only permit extensions if they use standard UML extension capabilities which SDLM tools for the model may or may not completely support depending upon how strictly they conform to UML standards.

Code of and code of conform to standards of approach where every major concept is separated into its own resource type. So implementing the use case of using concepts of approach actors and processes are all individual resources each having its own unique URL. Resources can be linked together using these URLs.

Code specifically represents the use case resource. It should be noted that links shown in code are relative links which use whatever protocol and server path that was used to retrieve the use case itself.

Code represents code for one of the actors referenced by the use case of . Code demonstrates a use of XML namespaces to mix in content that is not part of the core model but that is defined by an external party e.g. the creator title description and data elements . Code also demonstrates a use of an absolute URL in referencing the stakeholder resource of the use case of upon which the resource associated with code is logically based.

The present invention may be realized in hardware software or a combination of hardware and software. The present invention may be realized in a centralized fashion in one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for a carrying out methods described herein is suited. A typical combination of hardware and software may be a general purpose computer system with a computer program that when being loaded and executed controls the computer system such that it carries out the methods described herein.

The present invention also may be embedded in a computer program product which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computer system is able to carry out these methods. Computer program in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

