---

title: Apparatus, system and method for caching writes by multiple clients to a virtualized common disk image
abstract: An apparatus, system, and method are disclosed for storage write caching. A storage address translation table is used to overlay a user image and a common image. A storage driver stack module receives a storage access call and generates a storage access request with a requested file path and a requested storage address. A storage mapper module receives the storage access request, accesses the storage address translation table, and looks up a matching entry in the storage address translation table where the requested file path matches a saved file path and the requested storage address matches a saved common storage address, and maps a saved user storage address from the matching entry if a match exists.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08131765&OS=08131765&RS=08131765
owner: Lenovo (Singapore) Pte. Ltd.
number: 08131765
owner_city: Tech Park
owner_country: SG
publication_date: 20081014
---
This invention relates to shared virtual storage and more particularly relates to storage write caching.

Computer system virtualization derives its efficiency from the sharing of common physical resources among multiple virtual computers such as diskless user clients sharing a common disk image on a storage area network SAN . However it has proven difficult to preserve the coherency of the shared resources in the face of local user modifications and global maintenance updates without significantly degrading the efficiency of the overall system.

Common image solutions today are typically implemented in one of two ways. One is to allow read only access to the common image. Any writes or changes are cached in memory and lost when the user shuts down. These solutions require s SAN or a network attached storage NAS to allow the end user to access a location on the SAN or NAS to store their data.

The second method is to separate the writes from the reads at a block or sector level. This relies on a rigid block structure arrangement which negates any user changes when the common image is updated such as by applying a patch.

Some vendors propose application streaming as a method for applying a patch to the operating system OS image for the second method. Application streaming is a method to dynamically apply an overlay to the common image to allow that application or patch to run. This approach has the disadvantage that each application or patch that is streamed imposes overhead above the application or patch itself. This merely delays the need to update the common image. Eventually the point is reached where there is such a large amount of streaming that it overwhelms the system and hinders performance.

Thus it can be seen that high overhead inefficiency and the resulting overall poor performance have been the perennial challenges for storage write caching in a shared virtual storage environment.

From the foregoing discussion it should be apparent that a need exists for an apparatus system and method that streamlines storage write caching to a virtualized common disk image. Beneficially such an apparatus system and method would handle both user modifications and maintenance updates.

The present invention has been developed in response to the present state of the art and in particular in response to the problems and needs in the art that have not yet been fully solved by currently available common disk image technology. Accordingly the present invention has been developed to provide an apparatus system and method for storage write caching that overcome many or all of the above discussed shortcomings in the art.

The present invention utilizes a table driven approach embedded in the storage virtualization layer of a hypervisor control domain. It may be implemented at the firmware level for minimum overhead.

The apparatus to cache storage writes is provided with a plurality of modules configured to functionally execute the necessary steps of mapping a requested storage address to either the common or locally cached user copy of the requested data by accessing an efficiently indexed look up mechanism. The user image and the common image are congruent so as to simply overlay each other to yield a virtual drive image. These modules in the described embodiments include a storage address translation table module a storage driver stack module and a storage mapper module. The storage mapper module receives a storage access request from the storage driver module in response to a storage access call via an application programming interface and looks up a matching entry in the storage address translation table.

The apparatus in one embodiment is configured to divide the user image into a common area and a user local area which respectively overlay the common data and a free area comprising the common image yielding the user s virtual drive image.

The storage driver stack module of the apparatus is further configured in one embodiment to comprise at least one of a file system driver module a filter driver module and a device driver module. At the highest level the file system driver module receives a storage access call via an application programming interface and maps the requested file path to a virtual storage address. The filter driver module then maps the virtual storage address to the requested storage address within the common storage address range if the requested file path is an operating system file path and within the user storage address range if otherwise. In an embodiment the common storage address range and the user storage address range comprise disjoint ranges within a single physical storage address space. Corresponding virtual address ranges within a virtual storage address space may be similarly disjoint and thus may be distinguished on the basis of the virtual storage address thereby determining whether or not the requested file path is an operating system file path. Lastly a device driver module generates device specific commands in response to the storage access request.

In a further embodiment the apparatus may be configured for example to generate a hash of the file path to improve the efficiency of the storage mapper module look up operation. There are other efficient lookup data structures known in the art that could be employed. Additional efficiency may be achieved for the Windows operating system by providing a Master File Table MFT flag to indicate whether the requested file path specifies a file that is MFT resident rather than actually residing at the requested storage address.

A system of the present invention is also presented to cache storage writes. The system may be embodied as a plurality of computers upon which to run the foregoing modules and a storage subsystem comprising the foregoing storage areas. In particular the system in one embodiment includes a virtual drive image for each computer corresponding to its user storage area overlaid on the common storage area.

The system may further include a storage subsystem such as a SAN. The plurality of computers may be comprised of blades diskless workstations call center workstations thin clients hybrid clients and POS terminals. A hybrid client is one which possesses a small amount of onboard storage such as might be provisioned for the user common storage area but otherwise operates as a diskless client relying upon the storage subsystem to provide the more voluminous common storage area and user local storage area.

A method of the present invention is also presented for storage write caching. The method in the disclosed embodiments substantially includes the steps necessary to carry out the functions presented above with respect to the operation of the described apparatus and system. In one embodiment the method includes receiving the storage access request accessing the storage address translation table looking up a matching entry and mapping or passing through the request accordingly. The method also may include checking whether the requested storage address falls within the user local storage address range thereby implying that the matching entry does not exist without having to perform the step of accessing the storage address translation table.

In a further embodiment the method includes reading or writing the data as requested. In the case of a write a matching entry in the storage address translation table may be created if none exists as well as provisioning and allocating a thin region of physical storage as needed.

A physical update intended for all users may be applied to the common image without first overlaying any user image. To perform such a global update in virtual mode would be very cumbersome requiring each user s virtual image to be updated separately. To support the maintenance of the common image in physical mode a storage address update table may be provided having a format like that of the storage address translation table for recording the maintenance updates. Intersections between the two tables are then indicative of needed repairs to the user image and the storage address translation table. Once the repairs are accomplished the storage address update table may be deleted.

Reference throughout this specification to features advantages or similar language does not imply that all of the features and advantages that may be realized with the present invention should be or are in any single embodiment of the invention. Rather language referring to the features and advantages is understood to mean that a specific feature advantage or characteristic described in connection with an embodiment is included in at least one embodiment of the present invention. Thus discussion of the features and advantages and similar language throughout this specification may but do not necessarily refer to the same embodiment.

Furthermore the described features advantages and characteristics of the invention may be combined in any suitable manner in one or more embodiments. One skilled in the relevant art will recognize that the invention may be practiced without one or more of the specific features or advantages of a particular embodiment. In other instances additional features and advantages may be recognized in certain embodiments that may not be present in all embodiments of the invention.

These features and advantages of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

Many of the functional units described in this specification have been labeled as modules in order to more particularly emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like.

Modules may also be implemented in software for execution by various types of processors. An identified module of executable code may for instance comprise one or more physical or logical blocks of computer instructions which may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose for the module.

Indeed a module of executable code may be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices and may exist at least partially merely as electronic signals on a system or network. Where a module or portions of a module are implemented in software the software portions are stored on one or more computer readable media.

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus appearances of the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment.

Reference to a computer readable medium may take any form capable of storing machine readable instructions on a digital processing apparatus. A computer readable medium may be embodied by a transmission line a compact disk digital video disk a magnetic tape a Bernoulli drive a magnetic disk a punch card flash memory integrated circuits or other digital processing apparatus memory device.

Furthermore the described features structures or characteristics of the invention may be combined in any suitable manner in one or more embodiments. In the following description numerous specific details are provided such as examples of programming software modules user selections network transactions database queries database structures hardware modules hardware circuits hardware chips etc. to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention may be practiced without one or more of the specific details or with other methods components materials and so forth. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

The schematic flow chart diagrams included herein are generally set forth as logical flow chart diagrams. As such the depicted order and labeled steps are indicative of one embodiment of the presented method. Other steps and methods may be conceived that are equivalent in function logic or effect to one or more steps or portions thereof of the illustrated method. Additionally the format and symbols employed are provided to explain the logical steps of the method and are understood not to limit the scope of the method. Although various arrow types and line types may be employed in the flow chart diagrams they are understood not to limit the scope of the corresponding method. Indeed some arrows or other connectors may be used to indicate only the logical flow of the method. For instance an arrow may indicate a waiting or monitoring period of unspecified duration between enumerated steps of the depicted method. Additionally the order in which a particular method occurs may or may not strictly adhere to the order of the corresponding steps shown.

The hardware platform may be of any form factor or type including an embedded system a handheld a notebook a personal computer a minicomputer a server a mainframe a supercomputer and the like.

The processor s may be present in any quantity including a uniprocessor and may have any instruction set architecture. In an embodiment the processor s may have one or more levels of dedicated or shared caches. Possible physical implementations may include multi chip single chip multi core hyperthreaded processors and the like.

The memory may be of any size or organization and may include both read write and read only sections. It may also include both global and local sections and may support both uniform and non uniform access. It may incorporate memory mapped I O and direct memory access. It may support cache coherency including directory based and snoop based protocols.

The network interface may support any network protocol or architecture. It may support both wireless and hard wired network connections. It may comprise Ethernet Token Ring System Network Architecture SNA and the like. In one embodiment it may be integrated with the input output device interface .

The input output device interface may be driven primarily by the processor s or may incorporate an independent I O processor subsystem. It may comprise Peripheral Component Interconnect PCI Small Computer System Interface SCSI Fiberchannel FC Enterprise System Connection ESCON ESCON over Fiberchannel FICON and the like. In an embodiment it may include dedicated local I O devices.

The bus may comprise one or more of a variety of physical and logical topologies. It may be parallel or serial. It may be unidirectional or bidirectional. It may be flat or hierarchical. It may comprise a full or partial crossbar. It may comprise multiple bridged busses. In an embodiment the bus may comprise a high speed internal network.

The task s may include both user and system level tasks. They may be interactive or batch. They may run in the foreground or background. User level task s may include applications programs jobs middleware and the like. System level task s may include services drivers daemons utilities and the like.

The operating system may be of any type and version and in any state. Types may include Unix Linux Windows Mac MVS VMS and the like. Versions may include Windows XP Windows Vista and the like. States may include a degree of customization a mode of operation a system preparation for setup and the like. The operating system may be single user or multi user. It may be single tasking or multi tasking. In an embodiment the operating system may be real time. In another embodiment the operating system may be embedded.

The firmware may comprise microcode which may reside in a microstore of the processor s . In an embodiment the firmware may comprise low level software which may reside in memory . In one embodiment the firmware may comprise a rudimentary operating system . In a further embodiment the firmware may support virtualization so as to permit the concurrent operation of multiple operating systems on a hardware platform .

A free storage area congruent to the user local storage area may also be provided in the common image . The free storage area is contiguous with the common storage area which together comprise an extended common storage area . One purpose of the free storage area is to allow for updating and expanding the common storage area such as for patching an operating system as shared by all user clients. Another purpose may be to allow a single descriptive table such as a Windows Master File Table MFT to describe both the common image and the user image

There are two types of update intersections between the extended common storage area and the user storage area . The two cross hatch shaded blocks within the original user common storage area represent user modifications that must be moved as a result of the update. The two black shaded blocks within the original user local storage area represent user local data that must be relocated to make room for common update data to take its place. The latter situation arises due to the fact that the update is made directly to the common image in physical mode with the free storage area being seen as available space whereas the user local storage area overlays the same space in virtual mode.

A saved MFT flag indicates whether the modified block is part of an MFT file that is a file which is small enough to be stored directly in the MFT rather than at the nominal storage address indirectly pointed to by the MFT.

A saved file path indicates the file to which the block belongs. For more efficient table look up purposes a saved hash function of the saved file path is also provided. If the hash function does not match then there is no need to match on the saved file path .

A saved common storage address indicates the block within the common storage area that was modified by the user and the saved user storage address indicates where within user common storage area the modified copy of the block is cached. Note that a range of saved storage addresses may be specified to allow the specification of a contiguous range of modified blocks in a single entry. As can been seen the six blocks in this example have been specified by four entries given that there are two contiguous pairs of blocks.

A more detailed diagram of the related apparatus is shown for computer M being representative of each of the computers . A single storage mapper module running in the system wide hypervisor control domain within the firmware serves the entire system . The storage mapper module accesses the storage address translation table corresponding to computer M from among the storage address translation tables maintained by the storage address translation table module in order to map storage access requests from a storage driver stack module running in the user operating system to the storage subsystem via a mount point .

The storage driver stack module comprises several levels of drivers. At the highest level a file system driver module receives a storage access call via an application programming interface and maps the requested file path to a virtual storage address. A filter driver module then maps the virtual storage address to the requested storage address within the common storage address range if the requested file path is an operating system file path and within the user storage address range if otherwise. In an embodiment the common storage address range and the user storage address range comprise disjoint ranges within a single physical storage address space. Corresponding virtual address ranges within a virtual storage address space may be similarly disjoint and thus may be distinguished on the basis of the virtual storage address thereby determining whether or not the requested file path is an operating system file path. Lastly a device driver module generates device specific commands in response to the storage access request.

The device as seen by the device driver module is a virtual drive image comprised of the common image overlaid by the user image of the corresponding computer . One common image is shared by the entire system . A significant savings in physical storage is thus obtained because the user images are thinly provisioned to store only their respective individual differences from the common image while presenting the appearance of multiple full size virtual drive images .

If the requested storage address is common then the storage address translation table is accessed . If an entry matches wherein the requested file path matches the saved file path and the requested storage address matches the saved common storage address then the saved user storage address is mapped in place of the requested storage address and the method proceeds as described above wherein the requested storage address is not common . In further embodiment the saved hash function may be matched against a hash function of the requested file path thereby avoiding the need to match the requested file path against the saved file path if the hash function did not match.

If no entry matches then if the storage access request is a read the data is read from the common storage area and the method ends . If the storage access request is a write then the data is written to the user storage area and the method ends . If the storage access request is a write then a matching entry is created in the storage address translation table . If needed a thin region of physical storage is provisioned and allocated and the data is written to the user storage area and the method ends .

A boot sequence of the operating system is initiated for each user client. If the storage address update table does not exist then the method ends . Otherwise the boot sequence is suspended . The storage address update table is compared with the storage address translation table to determine any intersection between them. Any intersections thus defined are then moved to the user locations specified in the storage address update table and any user data displaced thereby to alternate locations available in the user storage area . The storage address translation table is then updated to reflect the data movement and the storage address update table is deleted . The boot sequence is resumed and the method ends .

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

