---

title: Collection with local lists for a multi-processor system
abstract: A method includes providing a collection that includes a plurality of local lists. Each local list is associated with a different processor or thread in a multi-processor system. An interface to the collection is provided for adding elements to and removing elements from the collection. An add operation is performed with a first processor in the multi-processor system using the interface to add a first element to the collection. The interface is configured to cause the first element to be added to the local list associated with the first processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607237&OS=08607237&RS=08607237
owner: Microsoft Corporation
number: 08607237
owner_city: Redmond
owner_country: US
publication_date: 20080602
---
Software programs have been written to run sequentially since the beginning days of software development. Steadily over time computers have become much more powerful with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever increasing single processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware software developers arrange for one or more tasks of a particular software program to be executed in parallel also referred to as concurrently so that for example the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

One embodiment uses local lists e.g. processor local lists or thread local lists to build a collection for a multi processor system that is scalable and that provides lock freedom or limited lock freedom to reduce or eliminate contention between processors.

In one embodiment a collection is provided that includes a plurality of local lists. Each local list is associated with a different processor or thread of execution in a multi processor system. An interface to the collection is also provided for adding elements to and removing elements from the collection. An add operation is performed by a processor or thread in the multi processor system using the interface to add an element to the collection The interface causes the element to be added to the local list associated with the processor or thread. A remove operation is performed with a processor or thread using the interface to remove an element from the collection. The interface causes the element to be removed from the local list associated with the processor or thread or if the remove is not successful the interface causes the element to be removed from the local list associated with another processor or thread.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

One embodiment provides an application that generates and uses concurrent collections for a multi processor system but the technologies and techniques described herein also serve other purposes in addition to these. In one implementation one or more of the techniques described herein can be implemented as features within a framework program such as MICROSOFT .NET Framework or within any other type of program or service.

Data parallel systems typically operate by partitioning input data into disjoint subsets partitions so that independent tasks of execution may process the separate subsets in isolation. The partitions are processed in parallel by multiple processors to generate a plurality of output sets. The output sets are merged back into a merged output set.

Lock freedom is often useful in parallel programs because it offers 1 Increased scalability due to the fine granularity of synchronization often just a single atomic write 2 better reliability because failure inside of the critical region will not happen 3 typically no blocking meaning that the failure of one thread is caused directly by the success of another thread. The lack of blocking can mean that there are fewer induced context switches which are pure overhead and are known to lead to increased convoys in lock based systems.

Various collection types include stacks queues sets dictionaries dequeues as well as others. However these collections are typically ordered and some do not permit duplicates. In addition these structures typically take a standard approach to building a collection e.g. using a shared list or array to store elements . The use of a central list inherently limits scalability by forcing all threads to fight for the same elements and because the cache lines for the storage are typically shared among all threads. Also when locks are used to provide thread safety the threads are forced to contend for the same locks. One embodiment uses local lists e.g. processor local lists or thread local lists to diminish these problems. In one embodiment lock freedom is used to build an unordered duplicate allowing collection which includes local lists to reduce or eliminate contention. One embodiment provides a scalable lock free unordered concurrent collection using work stealing queues.

Computing device may also have additional features functionality. For example computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and non volatile removable and non removable media implemented in any suitable method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can be accessed by computing device but excludes any transitory signals. Any such computer storage media may be part of computing device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Computing device may also include input device s such as keyboard pointing device e.g. mouse pen voice input device touch input device etc. Computing device may also include output device s such as a display speakers printer etc.

In one embodiment computing device includes concurrent collection application . Concurrent collection application is described in further detail below with reference to .

Concurrent collection application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for generating a concurrent collection that includes a plurality of local lists interface logic for converting interface commands into corresponding local list commands interface logic for adding elements to and removing elements from the concurrent collection interface logic for determining whether identified elements are contained in the concurrent collection interface logic for determining a total number of elements in the concurrent collection interface logic for providing random access to elements in the concurrent collection and other logic for operating the application.

Turning now to methods for implementing one or more embodiments of concurrent collection application are described in further detail. In some implementations the methods illustrated in are at least partially implemented in the operating logic of computing device .

At the interface to the collection is accessed by a second processor in the multi processor system. At the second processor performs a Remove operation using the interface to remove a second element from the collection wherein the interface is configured to cause the second element to be removed from the local list associated with the second processor. In one embodiment the interface is configured to cause the second element to be removed from the local list associated with the second processor in a lock free manner. At it is determined whether the second element was successfully removed from the local list associated with the second processor. At the interface causes the second element to be removed from a local list associated with another one of the processors in the system if it is determined at that the second element was not successfully removed from the local list associated with the second processor. In one embodiment the interface is configured to cause the second element to be removed from the local list associated with another one of the processors at using a lock on the local list.

In one embodiment each of the local lists is a queue that operates in a first in first out FIFO manner. In another embodiment each of the local lists is a stack that operates in a last in first out LIFO manner. In another embodiment each of the local lists is a work stealing queue that for example supports LIFO operations e.g. push and pop at the top of the queue and supports a steal operation at the bottom of the queue. In yet another embodiment the local lists include any combination of a FIFO queue a LIFO stack and a work stealing queue.

As shown in access to concurrent collection is provided through interface . In one embodiment interface is configured to receive concurrent collection interface commands convert the interface commands into corresponding local list commands and provide the local list commands to concurrent collection . In one embodiment the format for the local list commands varies depending upon the type of data structure used for local lists e.g. FIFO queue LIFO stack or work stealing queue . For example if the local lists are implemented as FIFO queues interface according to one embodiment converts Add and Remove interface commands to enqueue and dequeue local list commands respectively. As another example if the local lists are implemented as LIFO stacks interface according to one embodiment converts Add and Remove interface commands to push and pop local list commands respectively.

In one embodiment when the locals lists are implemented with work stealing queues the interface is configured to perform lock free Add operations on the work stealing queues for all of the processors or threads e.g. in one embodiment Add operations for each work stealing queue are only performed for the processor or thread associated with that work stealing queue and the Add operations are performed in a lock free manner and perform lock free Remove operations on each work stealing queue only for the processor or thread associated with that work stealing queue. In one form of this embodiment the interface is configured to perform lock based Remove operations on each work stealing queue for processors or threads that are not associated with that work stealing queue. In one embodiment the work stealing queues are optimized for Add Removes from opposite ends of the lists so that Add operations remain lock free.

In one embodiment the interface is configured to perform a Contains operation that determines whether an identified element is contained in the collection and a Count operation that determines a total number of elements in the collection . In one embodiment the interface supports random access to elements in the collection .

In one embodiment collection uses thread local lists rather than processor local lists for situations in which a thread using collection can migrate between processors in mid operation. In another embodiment such migration issues are addressed by preventing migration of threads among the processors. For operating system code migration may be prevented by disabling interrupts. For user mode code migration may be prevented by affinitizing the threads to run on only specific ones of the processors.

In one embodiment interface is implemented with an application programming interface API such as that shown in the following Pseudo Code Example I 

In Example I ConcurrentBag corresponds to the concurrent collection shown in . The interface supports an Add operation i.e. Add T elem for adding an element to the collection a Contains operation i.e. Contains T elem that returns a boolean to indicate whether an identified element is contained in the collection a TryRemove operation i.e. TryRemove out T elem that returns a boolean to indicate whether the identified element was successfully removed and that returns the removed item in the parameter out T elem if the removal was successful and a Count operation i.e. Count get that indicates the number of elements that are currently in the collection . Example implementations of these operations are described in further detail below with pseudo code examples. In one embodiment the interface is configured to hide the fact that the concurrent collection actually contains a plurality of local lists . In one form of this embodiment the interface includes a private field such as that shown in the following Pseudo Code Example II 

In Example II ProcessorCount represents the number of processors in the multi processor system and lists correspond to the local lists shown in . Thus the number of lists that are included in collection according to one embodiment is the same as the number of processors in the multi processor system with each list corresponding to or associated with one of the processors.

In one embodiment collection is an unordered collection and because order does not matter in this embodiment interface is free to store elements anywhere in the overall collection e.g. in any of the local lists without the entity that is using the collection knowing where within the collection the elements were stored. For example when an Add operation is performed by a processor in one embodiment interface will add the element to the local list associated with that processor as shown by the following Pseudo Code Example III 

As shown in Example III the Add operation adds an element elem to the list associated with the current processor MyProcessor . Performing Add operations in this manner avoids contention issues between processors. When a Remove operation is performed by a processor according to one embodiment interface will prefer to take the element from the local list for that processor but in the case that the local list for that processor is empty the interface will search the local lists for the other processors in order to find an element to remove as shown by the following Pseudo Code Example IV 

In Example IV interface first attempts to take an element from the local list for the current processor MyProcessor and then if that fails walks through the rest of the local lists . In one embodiment interface is configured to lock a local list if the list is not associated with the current processor. In one embodiment the Contains operation in Pseudo Code Example I is implemented similarly to the TryRemove operation given in Pseudo Code Example IV except the Contains operation looks through all of the local lists for a specific element rather than removing the next element from whichever list has one. In one embodiment if an element is not within the local list for a given processor interface begins looking outside of this list by first going to a neighboring processor e.g. for processor interface next looks at the list for processor instead of for example always beginning at the same processor e.g. processor which helps to distribute the workload more evenly.

In one embodiment interface supports random access to the elements stored in collection and the local lists also support random access which provides the ability to search for and remove specific elements. In one embodiment interface implements a random access Find and Remove operation as shown in the following Pseudo Code Example V 

The pseudo code given in the above examples may vary depending upon the type of data structure used for the local lists . For example if the local lists are implemented with stacks the code in Pseudo Code Example II might be changed to that given in the following Pseudo Code Example VI 

The code for the operations e.g. Add Remove etc. may also be changed to be appropriate for the underlying stack data structures. For example the Add operation given in Pseudo Code Example III might be changed to that given in the following Pseudo Code Example VII 

As another example if the local lists are implemented with queues the code in Pseudo Code Example II might be changed to that given in the following Pseudo Code Example VIII 

The code for the operations e.g. Add Remove etc. may also be changed to be appropriate for the underlying queue data structures. For example the Add operation given in Pseudo Code Example III might be changed to that given in the following Pseudo Code Example IX 

While the number of processors in a system may not change at runtime the number of threads could. Thus if thread local lists are being used in one embodiment the system will be configured to support storing an arbitrary number of lists and having that set of lists be mutated in a thread safe manner. For example instead of using an array the system can use a thread safe dictionary mapping thread ID to the thread s list. In one form of this embodiment when a thread adds to the concurrent collection for the first time a new list is created and added to the dictionary. In one embodiment threads retrieve their list from the dictionary by thread ID in order to add and remove elements and threads enumerate the dictionary s list looking for items to remove when their own list is empty. When a thread goes away it can remove its list from the dictionary to help with memory management so that the dictionary does not increase dramatically in size over time as threads come and go .

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

