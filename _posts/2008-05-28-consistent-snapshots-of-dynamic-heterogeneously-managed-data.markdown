---

title: Consistent snapshots of dynamic heterogeneously managed data
abstract: A system and method for providing a consistent view of data stored therein, which can change dynamically in an uncoordinated way, includes a client program and a snapshot server program. The snapshot server program permits one or more client programs to request snapshots of data from the snapshot server program such that the data included in or referenced by a snapshot originates from one or more host server programs and the data is accessible to the snapshot server program, but is managed independently of the snapshot server program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08832310&OS=08832310&RS=08832310
owner: International Business Machines Corporation
number: 08832310
owner_city: Armonk
owner_country: US
publication_date: 20080528
---
This application is a Continuation application of allowed U.S. patent application Ser. No. 10 918 070 filed on Aug. 13 2004 now U.S. Pat. No. 7 392 324 incorporated herein by reference in its entirety.

Exemplary embodiments presented herein relate to distributed computing and more particularly to providing a consistent view of data that resides on a network and that can change dynamically in an uncoordinated way.

The following is a survey of concepts systems and protocols used in the prior art to provide background for the present invention.

Domain Name System DNS is an instance of a distributed database enabling local control of segments of the overall database and global access to the aggregate data in a client server scheme. The servers in a DNS system are called name servers the clients are called resolvers.

Name servers are delegated responsibility for a zone the part of the total data they are controlling authoritatively. To increase availability of DNS data and achieve scalability DNS deploys primary and secondary master name servers. The primary master loads the data the primary master is responsible for from files while the secondary master obtains and updates data from the primary master in an action called zone transfer.

Request for Comments document for Tokyo Institute of Technology in the category of Standards Track 1995 describes an incremental zone transfer protocol which permits a secondary master to pull only those zone changes it needs to synchronize its copy of the zone with the source maintained by the primary master. Versions of zone data are identified by serial numbers. These numbers are exchanged as part of the SOA start of authority record.

If the serial number for the zone at the primary master is greater than at the requesting secondary master the transfer includes only those changes to RRs resource records for each incremental version of the zone. The primary master must maintain a history of incremental zone changes to be able to compute the proper set of RR updates between the current version and the version of the requesting secondary master.

Control Version System CVS is a version control system that supports the recording of file change histories. CVS maintains a repository of all files under version control. CVS users may retrieve check out versions of files store them in a working directory in the local file system modify the copies and commit check in the modified files to the repository. The repository is physically separate from the working directory. The repository may reside on the local machine or on a remote CVS server.

Rather than storing all different versions of a file the repository stores all versions in a single file and only records the differences between versions. CVS assigns a version number of each committed version of a file. A particular version of a file may be extracted from the repository using either its version number or the date when it was checked in. CVS supports team programming by insulating developers from each other. Developers may simultaneously edit local copies of the same file. CVS merges the work when the local copies are checked in.

OSGi s Open Services Gateway Initiative primary goal is to define and foster rapid adoption of open specifications for the delivery of managed broadband services to networks in homes cars and other environments. The OSGi Service Platform is a JAVA framework for developing remotely deployed service applications. OSGi provides life cycle management for services installed on the platform services can be installed started stopped updated and removed without disturbing other services within the platform. Services can locate each other and advertise their services through the registry. A service can also request that the framework notify it when another service becomes available or another state change occurs. Version management is provided by the platform and the platform itself can be controlled remotely.

OSGi SPR3 defines specifications and JAVA application programming interfaces APIs that define the core functions of the platform and an application lifecycle and provide a service registry package and version management and remote management ability. These APIs are then implemented by OSGi Service Platform implementations such as SMF Service Management Framework . SHF is IBM s OSGi implementation SMF 3.5 implements OSGi Service Platform Release 3 SPR3 .

OSGi and SMF applications are called bundles. A bundle is a JAR file containing the resources to implement services and a manifest file with bundle information. A bundle can also act as a library and only export JAVA packages. Bundles are stored in a SMF bundle server and are deployed from the server to the SMF runtime. The SMF platform can install update and uninstall bundles dynamically. Code within bundles can execute searches to find services registered by other bundles. The bundle lifecycle contains six states installed resolved starting active stopping and uninstalled.

The SMF bundle server maintains a bundle catalog and can be shared by multiple developers. The SMF bundle server interacts with a management agent for the SMF runtime and provides bundle snapshots and dependency checking for loading bundles. Snapshots are a way to store the current state of the runtime for later use such as during recovery or reset. A typical use for snapshots is for developers to load all of the bundles needed on a particular target runtime and then to save the snapshot so that they can test different configurations and still be able to return to the previous state.

The bundle developer uses the Safe Bundle Install Protocol to install bundles into the runtime. The runtime provide the SMF bundle server with its configuration data and a list of currently installed bundles. The bundle server then determines the correct version of a bundle resolves the bundle before it is downloaded by determining whether all the required packages and services are available in the runtime and provides a list of prerequisite bundles needed by the runtime.

Although SMF uses bundle snapshots they are unrelated to bundle updates but store the current state of the SMF Runtime. Thus using the snapshot a particular runtime environment can be restored. Particular bundles are updated by downloading the latest version from the bundle server upon user request.

Tightly Integrated Client Server Systems are systems in which a client program executes a private protocol with a server program which requires tight integration between these two communicating components. Typically the client and server components are developed together and are intended to run together. For performance or other reasons data that resides on the server is often replicated on the client as part of the client server protocol. Similarly for recovery or other reasons data that resides on the client may be replicated on the server.

LOTUS NOTES is an example of a client server system in which the protocol between the client and server components implements data replication. In LOTUS NOTES databases that reside on either the client or the server can be replicated elsewhere on the network. For example a person s e mail database usually resides on a Notes server and is often replicated on the Notes client. This replication allows fast access to e mail documents on the client platform whether or not the client is connected to the network.

Distributed server systems and distributed multiple server systems often require closely coordinated server execution and explicitly synchronized server data. Distributed Database Management Systems DDBMS for example replicate databases according to well defined protocols for performance and availability reasons.

Standard web browsers such as INTERNET EXPLORER or MOZILLA allow web applications to store data in cookies that reside on the client machine that runs the browser. These cookies usually store a small amount of application data such as user preferences or session identifiers which the browser will send on future requests to the application server.

The present invention provides a number of differences from the prior art concepts systems and protocols. For example there are a number of differences between incremental zone transfer of the prior art and the present invention. Unlike the primary master in DNS the snapshot server in present invention operates as an intermediary between heterogeneous and distributed data sources and the client. Snapshot updates do not occur on a regular basis but only as requested by the client. The snapshot server does not need to maintain the history of changes rather the digests submitted by the requesting client enable the snapshot server to compute the difference between the client s copy of the data and the current source data. A further difference is that the client can narrow the scope of data for which an update is requested.

In addition there are differences between CVS and the present invention. The snapshot server in the present invention operates as an intermediary between heterogeneous and distributed data sources and the client. Because clients never need to roll back to earlier versions of the data the snapshot server does not maintain any change history. Version numbers are also not required by the present invention though they can be used. The digests submitted by the requesting client enable the snapshot server to compute the difference between the client s copy of the data and the current source data. No state is maintained at the server.

There is no intermediary comparable to the snapshot server in the present invention and there are no snapshots in the prior art as in present invention for computing the sets of added deleted or modified bundles on the bundle server. The present invention differs from tightly integrated client server systems like LOTUS NOTES in several ways. For example a snapshot server does not need to coordinate versioning or updating with host servers. This loose coordination means that host servers do not have to support versioning and that they do not have to be aware of the consistency requirements of clients. In addition an inventory delta in present protocol has no analog in tightly integrated client server systems. The inventory delta provides a complete inventory of changes that have occurred since the client s last snapshot which allows clients to inspect changes before they are accepted.

Unlike distributed server systems the present invention does not require close coordination among servers and this allows a snapshot server to access a wide variety of host servers using any published protocol. For instance a snapshot server can use HTTP FTP or Java RMI protocols to read data from host servers and make that data available to its clients. Using the present invention clients can determine exactly what updates they receive and when they receive them which is a capability not provided in distributed server systems with automatic replication.

In the present invention digests act as specialized cookies that include versioning information. The present invention differs from web browser cookies in that it provides a protocol for supporting static snapshots of server data it allows client programs to choose when to update their snapshots it provides an inventory delta that describes the differences between snapshots and it permits data to be versioned even if that data resides on servers that do not explicitly support versioning.

A system and method of the present invention for providing a consistent view of data stored on host servers which can change dynamically in an uncoordinated way includes a client program and a snapshot server program. The snapshot server program permits one or more client programs to request snapshots of data from the snapshot server program such that the data included in or referenced by a snapshot originates from one or more host server programs and the data is accessible to the snapshot server program but is managed independently of the snapshot server program.

A system and method for providing a consistent view of data stored therein which can change dynamically in an uncoordinated way includes a snapshot server program that permits one or more client programs to request snapshots of data from the snapshot server program. The snapshot server program responds to a request by providing a digest with each snapshot created by the snapshot server program. The digest includes information that describes a version of each datum included in or referenced by the snapshot associated with the digest. A snapshot inventory delta is created by the snapshot server program using the snapshot digest. The snapshot inventory delta describes what data has changed since the snapshot associated with the digest was created and classifies each such change as either an insertion a deletion or an update and associates the snapshot inventory delta with the digest and with the digest s associated snapshot.

These and other objects features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

The present invention provides systems and methods by which one or more client programs can acquire consistent static snapshots of dynamic heterogeneously managed data that are exported by one or more server programs and acquire all data changes that have occurred since the creation of those snapshots through the use of snapshot specific digests.

There currently exist many techniques to distribute data replicate data or to synchronize databases but these techniques either require a tight integration of code that runs at each replication site or they require strict consistency between replicas. The present invention permits programs that manage distributed data to be loosely coupled or even unaware of each other. The present invention also relaxes the requirement for data consistency across a distributed system by allowing the data viewed by different clients to be consistent within themselves but independent of each other. This weaker notion of consistency is appropriate in heterogeneously managed networks like the Internet.

It should be understood that the elements shown in the Figures may be implemented in various forms of hardware software or combinations thereof. Preferably these elements are implemented in software on one or more appropriately programmed general purpose digital computers having a processor and memory and input output interfaces. Referring now to the drawings in which like numerals represent the same or similar elements and initially to a set of entities are shown that include a set of client programs a snapshot server and a set of host servers . These entities may be arbitrarily distributed across a set of nodes in a network or they may be collocated on a single node. Host servers or collectively servers store data items. These data items may change over time. A client s accesses a version of the data items via the snapshot server .

The snapshot server communicates with one or more host servers using any mutually acceptable communication protocol. The snapshot server often caches data items that originate on host servers . This cached data can be preprocessed by the snapshot server so that the data items can be efficiently transmitted and efficiently used by clients . The snapshot server identifies each data item by a unique key not shown . When a client requests a snapshot of data from the snapshot server the snapshot server computes a digest over the data by computing a signature for each datum. The snapshot server then returns the snapshot and the snapshot digest to the client .

The client can query returned snapshots for the list of data keys that the snapshot s includes. In addition clients can access a particular data item in the snapshot by using the data item s key.

Referring to an overview of protocol exchanges between a client a snapshot server and several host servers and which are equivalent to host servers in is shown. illustrates which parties communicate and what messages they exchange in accordance with an exemplary embodiment of the present invention. The Legend describes the symbols that are used in and in subsequent Figures to simplify the understanding of the embodiments. The symbols in the Legend include a snapshot a digest a host datum a snapshot server cached datum a snapshot inventory delta a removed watch list and a change threshold specification .

In time progresses from the top of to the bottom. Initially the snapshot server manages snapshot and its associated digest . Host server includes two data items host server includes two data items and host server n includes a single data item . The first event in time order in is the creation of new data item on host server . This creation event triggers a push transaction from host server to the snapshot server . This push protocol allows host server to automatically initiate the transmission of updates to the snapshot server . After the push transaction the snapshot server has access to all data from host server .

The second event in time order in is the initiation by the snapshot server of asynchronous transaction with host server . When this transaction completes with response the snapshot server will have received all data updates from host server . The third event in time order in is the initiation by the client of a new snapshot request with the snapshot server . The parameters of this request include digest removed watch list and a change threshold . When the snapshot server receives the client request the snapshot server initiates a synchronous transaction with host server n to retrieve any updates that may exist on that host server . After the synchronous transaction completes the snapshot server has access to data which includes data that originated on host server and on host server n .

The fourth event in time order in is the completion of asynchronous request with response . After the asynchronous response completes the snapshot server has access to data which includes data that originated on host server host server and host server n .

The fifth event in time order in is the sending of response from the snapshot server to the client to complete client request . This response includes snapshot associated digest and associated snapshot inventory delta .

Referring to data exchange between a snapshot server and a host server is illustratively described in greater detail. The snapshot server communicates with the host server via some underlying protocol which can be any protocol that a snapshot server and a host server agree to use. Data items that originate on the host server are accessible to the snapshot server using such a communication protocol. These communication protocols include but are not limited to the synchronous protocol the asynchronous protocol and the push protocol used in to describe data transfer between host servers and the snapshot server .

The snapshot server maintains an internal state including a collection of cached data items and a digest . The digest includes a set of signatures computed over the set of data items accessible to the snapshot server . Each signature e.g. in the digest is associated with its corresponding cached data item e.g. . The snapshot server internal state defines the current version of data available to clients from the snapshot server. A preferred embodiment of a snapshot server caches host server data that could change but only caches references to host server data that could not change. Also a preferred embodiment of a snapshot server preprocesses cached data to improve the performance of client requests.

Referring to a simple protocol exchange between the client and the snapshot server . This exchange may be used for the initial handshake between client and server since the client has no prior snapshot and hence does not include any parameters digest watch list or change threshold in its request . When the snapshot server receives request the snapshot server computes a new snapshot its associated digest and its associated inventory delta . The inventory delta indicates all data items in the snapshot as being newly inserted.

Referring to another protocol exchange between the client and the snapshot server is illustratively depicted. This exchange may be used after the initial handshake described in . In this case the client has previously obtained a snapshot e.g. and the digest e.g. associated with that snapshot. When the client makes a request for a new snapshot the client sends the digest associated with the previous snapshot to the snapshot server as part of the request. When the snapshot server receives this request the snapshot server computes a new snapshot its associated digest and its associated inventory delta . Using the previous snapshot digest the snapshot server precisely reflects in the inventory delta which data items have been added which data items have been modified or which data items have been removed since the client s previous snapshot was created.

Referring to yet another protocol exchange between the client and the snapshot server is illustratively depicted. This exchange may be used after the initial handshake described in . In this case the client has previously obtained a snapshot e.g. and the digest e.g. associated with that snapshot. When the client makes a request for a new snapshot the client sends the digest associated with the previous snapshot to the snapshot server as part of the request . The client also sends a removed watch list as part of the request . When the snapshot server receives this request the snapshot server computes a new snapshot its associated digest and its associated inventory delta . Using the previous snapshot digest the snapshot server precisely reflects in the inventory delta which data items have been added which data items have been modified or which data items have been removed since the client s previous snapshot was created. In addition the inventory delta removed list will include only those data keys that were specified in the removed watch list .

Referring to still another protocol exchange between the client and the snapshot server is illustratively depicted. This exchange may be used after the initial handshake described with reference to . In this case the client has previously obtained a snapshot e.g. in and the digest e.g. associated with that snapshot. When the client makes a request for a new snapshot the client sends the digest associated with the previous snapshot to the snapshot server as part of the request. The client also sends a change threshold as part of the request. When the snapshot server receives this request the snapshot server determines whether the change threshold specified by the client has been reached. If the change threshold has not been reached then the snapshot server returns to the client an indication that the threshold has not been reached. Otherwise normal processing occurs in which the snapshot server computes a new snapshot its associated digest and its associated inventory delta . Using the previous snapshot digest the snapshot server precisely reflects in the inventory delta which data items have been added which data items have been modified or which data items have been removed since the client s previous snapshot was created.

In one embodiment change thresholds e.g. permit change threshold parameters to be defined in terms of the total number of insertions updates and deletions since the snapshot associated with digest was created. Another embodiment of change thresholds includes change threshold parameters to be defined in terms of the number of insertions the number of updates and the number of deletions since the snapshot associated with digest was created. Another embodiment of change thresholds includes change threshold parameters to be defined in terms of the recentness of insertions updates and deletions since the snapshot associated with digest was created. Other threshold parameters are also contemplated.

Referring to an exploded view of an iconic snapshot is illustratively shown. One function of a snapshot is to provide access to key value pairs where keys are unique and values associated with each key are either included in the snapshot or referenced by the snapshot. In either case these values are guaranteed not to change during the lifetime of the snapshot . indicates the words key and value for clarity which may be meta information and may not actually be part of the snapshot content.

The example snapshot shown includes four key value pairs e.g. and . Pair shows key id1 which uses the URL http mycompany.com snapshot id1.jpg to refer to its value. Pair shows key id2 which uses the URL http mycompany.com snapshot id2.pdf to refer to its value. The snapshot server guarantees that the data referenced by both these URLs will not change during the lifetime of the snapshot. Pairs and show keys id3 and id4 respectively. The values associated with both of these keys are included in the snapshot .

Snapshot can provide access to key value pairs using any API chosen. In one embodiment a snapshot implements a getKeys method which returns the collection of unique keys included in the snapshot and a getvalue key method which returns the value of the key specified in the input parameter. One important characteristic of this embodiment is that the snapshot manages the location of its value data in a manner that is transparent to any code that uses the snapshot. In addition snapshot implementations can maintain descriptive data that permits the efficient retrieval and storage of value data.

Referring to a high level representation of the contents of an example snapshot digest is illustratively shown. An exploded view of the iconic snapshot digest provides version information for each key value pair in the snapshot associated with the digest . indicates the words key and signature for clarity which may be meta information and may not actually be part of the snapshot digest.

The example snapshot digest shown in includes version information for the four key value pairs defined in the snapshot in . In the case shown digest includes keys and signatures . Key signature pair specifies the version information for the key id1 as a timestamp. Pair specifies the version information for the key id2 as a release number. Pair specifies the version information for the key id3 as a hash of its value. Pair specifies the version information for the key id4 as the value itself. In general a digest can use any method or any plurality of methods to distinguish between different versions of snapshot data.

One embodiment of a snapshot digest packages the digest with its associated snapshot. In this embodiment the snapshot provides a method getDigest that allows the digest to be retrieved. This retrieved digest is opaque to all code outside of the snapshot server though the digest can be serialized to disk and deserialized from disk by any code that has access to the digest.

Referring to a high level representation of the contents of an example snapshot inventory delta is illustratively shown. An exploded view of the iconic snapshot inventory delta shows that the inventory delta characterizes the changes in the snapshot associated with the inventory delta with regard to some previously retrieved snapshot. indicates the words inserts updates and deletes for clarity which may be meta information and may not actually be part of the delta inventory.

The example snapshot inventory delta object shown in includes three lists in which the elements in the lists are snapshot keys. List is a list of inserted keys list is the list of updated keys and list is a list of deleted keys.

To better understand the function of snapshot inventory deltas assume that a client has retrieved a snapshot snapshot and its associated digest digest at some point in time. At some subsequent point in time the client requests a new snapshot and passes digest as an input parameter on this request. The reply to this latter request includes a new snapshot snapshot a new digest digest and an inventory delta delta. This delta object describes 1 all new key value pairs that have been inserted into snapshot since snapshot was created 2 all key value pairs that have been modified in snapshot since snapshot was created and 3 all key value pairs that have been deleted from snapshot since snapshots was created.

Using and the example from the preceding paragraph list includes three new keys id5 id6 and id7 that were inserted into snapshot since snapshot was created. List includes two keys id1 and id2 whose values have changed since snapshots was created. In addition includes one key id3 that was deleted along with its value from since snapshot was created.

Referring to a block flow diagram is shown for a system method for requesting snapshots of data from a snapshot server program. In block the client makes a request for a snapshot. The snapshot server program may respond in block in a plurality of ways.

In block a snapshot server checks to determine in a threshold has been met. If the threshold has been met then the program path continues with block . This threshold type may include a client supplied threshold such that a snapshot is taken if the threshold has been met otherwise a snapshot would not be taken. If this type of threshold is not employed block is skipped. In block a snapshot is created by a snapshot server program by calculating a current version of data which is up to date to within a well defined propagation delay. The data in or referenced by the snapshot is in a consistent state and unchanged after the snapshot is created.

In block a snapshot digest is associated with each snapshot created such that the snapshot digest includes information that describes the version of each datum included in or referenced by the snapshot associated therewith.

In block using the snapshot digest a snapshot inventory delta which describes what data has changed since the snapshot associated with the digest was created is created and classifies each such change as an insertion a deletion or an update and associates the inventory delta with said digest and with said digest s associated snapshot. If the client sends a digest as an input in a request then this input digest is used when the inventory delta is created in subsequent steps. If the client sends a removed watch list as an input in a request then this input list is also used when the inventory delta is created in subsequent steps.

In block a change threshold parameter may be provided which is sent with the digest to the snapshot server program such that the snapshot server program responds with a triple e.g. snapshot digest and inventory delta only if an amount of change in the snapshot server program s data since the snapshot associated with the digest was created exceeds a threshold. The amount of change of the threshold may include for example a number of insertions deletions and updates. Note that this type of threshold is checked after the delta has been created as opposed to the threshold type checked before the snapshot is created see block .

The data included in or referenced by a snapshot may originate from one or more host server programs such that the data is accessible to the snapshot server program but that the data is managed independently of the snapshot server program. The snapshot may include some or all of the data described in the digest associated with the snapshot or include references to some or all of the data described in the digest associated with said snapshot. The referenced data may reside on a host server.

In block a host server program may permit the snapshot server program to read the host server program s data but that the host server program may or may not coordinate changes to the host server program s data with the snapshot server program or alternately the host server program may permit the snapshot server program to read the host server program s data and the host server program notifies the snapshot server program of changes to the host server programs data.

In block the snapshot digests may be saved to and read from persistent storage and the snapshot digests may be exchanged between programs. Note that clients may also save digests to persistent storage.

Other responses to requests may include the following under given conditions. In block a triple is sent to the client including a snapshot digest and inventory delta. For example if the client program sends a snapshot digest to the snapshot server program the snapshot server program responds by sending to the client program a triple that includes a snapshot of the current version of the server program s data the snapshot s associated digest and the snapshot s associated inventory delta.

If the client program sends a pair that includes the snapshot digest and a removed watch list to the snapshot server program the snapshot server program responds by sending to the client program a triple that includes a snapshot of the current version of said server program s data the snapshot s associated digest and the snapshot s associated inventory delta such that only data that appears in the removed watch list is described as removed in the inventory delta.

In block the snapshot server program may support a publish subscribe interface that permits client programs to be notified when the current version of said snapshot server program s data has changed.

Having described preferred embodiments for consistent snapshots of dynamic heterogeneously managed data which are intended to be illustrative and not limiting it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in the particular embodiments of the invention disclosed which are within the scope and spirit of the invention as outlined by the appended claims. Having thus described the invention with the details and particularity required by the patent laws what is claimed and desired protected by Letters Patent is set forth in the appended claims.

