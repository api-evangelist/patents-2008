---

title: Transaction aware, flexible interface for a state correlation and transition execution engine
abstract: The subject matter disclosed herein provides methods and apparatus, including computer program products, for state alignment and transaction coupling to enable reliable communication between an application, such as a backend system, and a correlation engine (or rules engine). In one aspect there is provided a method. The method may provide a first interface to receive information from an adapter for an application separate from a state correlation engine and provide a second interface to receive information from the state correlation engine to the adapter. The first and second interfaces may provide state alignment between the application and the state correlation engine. Related systems, apparatus, methods, and/or articles are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09058572&OS=09058572&RS=09058572
owner: SAP SE
number: 09058572
owner_city: Walldorf
owner_country: DE
publication_date: 20081204
---
This disclosure relates generally to data processing and more particularly to aligning states of applications.

Event Condition Action ECA is an example of a rules based approach used in an event driven system. Typically the ECA rule includes an event part for specifying what triggers the invocation of the ECA rule a condition part which is a logical test that if satisfied to true causes the action to be carried out and an action part which includes updates or invocations on the local data at the database. In a database system the condition could simply be a query to the database with the result set being passed to the action part. Actions could also be calls to external programs or remote procedures. ECA rules can be used for activities such as automatically enforcing document constraints maintaining repository statistics facilitating publish subscribe applications and executing business processes.

The subject matter disclosed herein provides methods and apparatus including computer program products for aligning states between the internal state of an ECA rules engine and external state held by components that interact with the ECA rules engine with the alignment occurring transactionally i.e. different transaction models are synchronized .

In one aspect there is provided a method. The method may provide a first interface to receive information from an adapter for an application separate from a state correlation engine and provide a second interface to receive information from the state correlation engine to the adapter. The first and second interfaces may provide state alignment between the application and the state correlation engine.

Articles are also described that comprise a tangibly embodied machine readable medium embodying instructions that when performed cause one or more machines e.g. computers etc. to result in operations described herein. Similarly computer systems are also described that may include a processor and a memory coupled to the processor. The memory may include one or more programs that cause the processor to perform one or more of the operations described herein.

The details of one or more variations of the subject matter described herein are set forth in the accompanying drawings and the description below. Other features and advantages of the subject matter described herein will be apparent from the description and drawings and from the claims.

The state correlation engine may execute models of a business process or other high order paradigms that are represented by event condition action rules. The model represents a set of ECA rules derived from a particular source model which may be a business process. For example business processes may be specified using different modeling languages such as Business Process Modeling Notation BPMN BPEL Business Process Execution Language EPC event driven process chains UML activity diagrams and the like. The model for a correlation engine may be mapped from other paradigms due to its use of basic building blocks from which modeling constructs of other modeling paradigms may be mapped.

The state correlation engine also referred to as a correlation engine or a rules engine as described herein may be a component of a system that processes event condition action ECA rules that represent a business process. The state correlation engine may process the ECA rules also referred to herein as rules to effectively correlate a state of execution of the process represented by results of execution of rules with new events e.g. new incoming events . For example the state correlation engine may be a component of a business process management BPM system a complex event processing CEP a business activity monitoring BAM system a business rules management BRM system and any other system whose operational semantics can be natively represented as ECA rules.

In some implementations the state correlation engine may provide for continuous execution of rules by being continuous in the sense that execution of rules may be triggered by the execution of earlier rules which may result in further execution of rules. For example a first rule R having a first action A may be executed as a result of a first event E. Execution of the first rule R may result in the execution of the action A where the action A involves changing a state variable V from a value to another value. The event E is the change of the state variable V. The event E may be flooded in all rules which may cause a second rule R to be executed where the second rule R requires the event E before it is executed. As a result of the execution of R a second action A may be executed which may result in an event E which may in turn cause another rule to be executed.

The state correlation engine may further provide for stateful execution of rules in the sense that a state of execution may be retained across execution of rules e.g. information about state may be retained across execution of rules and changed according to actions of rules or otherwise as a result of events .

Although the term event may be used in the following description to refer to an event object which may be an object of an object oriented or other type of data structure of another type of computer implemented language where the event object may be implemented as a combination of images of objects of a type language the term event may also refer to an event in a broader sense which may be an occurrence or happening. For example an event may be the receipt of a message that may cause the generation of an event object which may also be referred to as an event . Specifically adapter and the rules engine operate on different event types. That is the rules engine exclusively processes events which are changes of state variables e.g. before after image pairs as opposed to adapter which processes external events originating from the backend application .

In general operation of the system may be as follows. The state correlation engine may take the model for a correlation engine as input and execute the model with use of the adapter that may provide connectivity to a backend application e.g. an enterprise resource planning ERP system a task management system a radio frequency identifier RFID system an email server and any other application . The model for the state correlation engine includes a combination of type definitions configurations for adapters and rules which are executed at runtime within transactions .

The adapters such as adapter may connect the state correlation engine with applications such as backend application e.g. there may be an adapter to send and receive electronic mail or an adapter to consume web service calls . The adapter adapts in the sense that it may provide a layer to transform communications between a correlation engine e.g. state correlation engine and outside components such as other systems e.g. application .

The adapter may implement a corresponding adapter API B and the state correlation engine may implement a dock API A. The dock API A is responsible for communications from the adapter to the state correlation engine and the adapter API B is responsible for communications from the state correlation engine to the adapter .

The APIs A B each provide a flexible interface such as an application programming interface API to allow the state correlation engine to align its state to the state of so called external applications such as backend application and to allow the external application to align its state with the state correlation engine . For example the adapter may call dock API A to provide state alignment by creating state variables deleting state variables setting attribute values of state variables getting attribute values of state variables and the like e.g. calls such as createStateVariable deleteStateVariable setAttributeValue and getAttributeValue . The state correlation engine may call adapter API B to signal construction of state variables destruction of state variables changing of state variable attribute values and also to invoke callbacks from within rule actions e.g. calls such as onConstruction onDestruction valueChanged and invokeCallback .

The APIs A B also facilitate lifecycle alignment. For example the dock API A may be used by the adapter to call the state correlation engine to align lifecycles. Specifically an adapter may use the dock API A to notify the state correlation engine that the adapter is available or unavailable for receiving the signals such as state variable construction destruction and the like. The dock API A calls may specifically include one or more of the following calls dock and undock denoting that the adapter is available and unavailable respectively. For example the adapter API B may be used by the state correlation engine to call the adapter to align lifecycles with application and may also include a mechanism to notify the adapter that the state correlation engine is temporarily unavailable to receive events. The adapter API B calls may include enterRuntimeMode slumber wakeup and shutdown to notify the adapter of a certain operational mode of the state correlation engine such as recovery deployment or normal operations to ask the adapter to temporarily cease its operations due to a non permanent unavailability of the state correlation engine and to resume its normal operations afterwards and to permanently shut down all operations as part of a complete shutdown of the state correlation engine respectively.

The APIs A B also facilitate transactional configuration. For example the adapter API B may be used by the state correlation engine to call the adapter to configure the adapter and the calls may include one or more of the following configure and unconfigure. Moreover the calls may transactionally push fragments of the adapter configuration model data to the adapter . The adapter may then use this configuration data to further configure the connected backend application .

The APIs A B may also be used to provide transaction coupling. For example the adapter may call the dock API A to control the lifecycle of an internal transaction e.g. begin a transaction to commit it or roll it back etc. at state correlation engine and to couple to an external transaction initiated by the connected backend application . The dock API calls may include one or more of the following calls beginTransaction commit rollback and setPersistent to start a new internal transaction commit or forcefully abort a running internal transaction respectively. The state correlation engine may call the adapter API B to couple internal transactions i.e. internal to the state correlation engine with the adapter and corresponding application . In particular the state correlation engine will also transparently couple an external adapter side transaction to the state correlation engine and invoke callbacks on the adapter to store delete and retrieve external state within that transaction. The adapter API calls may include one or more of the following persist eradicate recover evict depart and arrive to store delete or retrieve external state in an external database transaction and to displace external state from main memory prepare external state for being relocated to another node in a distributed cluster environment respectively.

Moreover the state correlation engine may provide transaction coupling. For reliable execution of business logics operations involving multiple components e.g. a backend application and state correlation engine may be executed with transactional guarantees. Specifically transactional guarantees are provided in connection with bidirectional communication between state correlation engine and backend application s involving different data models and type systems for the affected state and different transaction models.

Execution of the model for a correlation engine may be prompted by events received by an adapter or in response to other stimuli e.g. after start up of the state correlation engine as part of a recovery procedure and as a result of continuous execution of rules although there is no explicit start operation per se which an adapter is aware of e.g. the adapter is generally concerned with managing events and even if a particular event delivered by an adapter through the dock API A to the rule engine causes rule s to be triggered the adapter is typically unaware of this effect . Execution of the model by the correlation engine may include evaluating conditions of the rules to determine actions to be performed and performing actions of the rules that correspond to conditions that are successfully evaluated.

As discussed above the model for a state correlation engine may include a combination of ECA rules type definitions and configurations for adapters and rules . A combination of condition networks type definitions and configurations for adapters and rules may represent elements of a workflow model or another higher order paradigm from which the model for a correlation engine is derived. The type definitions may be defined in accordance with an object oriented language type system where different types of objects represent different types of events. For various reasons such as performance reasons the language may be limited with non nested tuples e.g. shallow structures of atomic values . Type definitions may be adapter governed such that a type definition may correspond to a type of event received by an adapter. However the adapter may perform other actions upon receiving an event though the adapter API which includes constructing a new instance of some type . The event itself denotes some change e.g. creation removal attribute value update and the like of an object. Events are implicitly generated by the correlation state engine or rules engine if an adapter or a rule action performs an action through the dock API A to change an object. An adapter may optionally register to those events and perform custom actions. For instance if an instance of some type of message is deleted the adapter governing that type is notified and may then delete externally held data which is associated to the particular message object instance which was deleted. If that involves communicating to some backend application e.g. a messaging system the adapter will have to synchronize the different transaction models of the rule engine and the backend application via the dock API A.

The state correlation engine offers an asynchronous stateful execution mode operating on state changes e.g. events rather than the state variables itself. For events each event may include a before image and an after image that reflect a committed state and a to be committed state. There are typically three types of events namely create or generate delete and alter events. These events correspond to the information that a state variable was created removed or has changed its value.

An adapter configuration included in component may define a customization of an adapter to influence aspects of an adapter s runtime behavior. An adapter configuration may be a semi structured data for custom interpretation by an adapter. As examples an adapter configuration may include an address to which emails have to be sent a web service endpoint and operation that is to be used in a web service call mapping instructions e.g. an extensible Stylesheet Language Transformation script that are to be performed in a mapping step and type information e.g. as eXtensible Markup Language Schema Definition that is used to hold business data.

The action scripts which are part of the ECA rules may result in events that update information of instances of types where the events may include creating deleting or altering information of a type instance. In addition to updating information of instances of types the transactions may invoke functions on instances of types which may include calling a custom functionality in an adapter that governs a type. Function invocations are part of rule actions e.g. scripts . Functions that are part of transactions may be extension points e.g. for adapters to implement custom operations e.g. these custom actions typically reflect functionality of the backend system to which the adapter connects to . Examples of custom operations that may be implemented as part of a function might include sending emails invoking web services delegating tasks performing mappings data transformations and the like.

As discussed above the state correlation engine may execute the model in response to an event generated by an adapter or in response to other events representative of state change e.g. the action part of another event condition action rule may cause an event . In addition to adapters receiving information to generate an event of state correlation engine the adapter and APIs A B may be used to generate output and otherwise perform operations for the correlation engine . For example execution of an action of a rule may cause an adapter to generate a web service call to another system. Specifically a function invocation as part of a rule action script performs a callback to the adapter which may then perform that web service call or any other operation .

As discussed above the instances of objects are instances of objects of an object oriented language where different types of objects may represent different types of events or state attributes. The state of the state correlation engine is the entire set of state variables with their current attribute value. The instances may be used to make up computer implemented events of the state correlation engine where the computer implemented events may have a combination of images including a before image of an instance including attributes of the instance before a change of state of the instance and an after image including attributes of the instance after a change of state of the instance. Events in the sense of the rules engine denote changes to state variables and exist for the duration of the transaction the change was made in. When the transaction is committed the rules engine consults the events which were implicitly constructed when the state variables were updated to re evaluate the conditions and disable rule actions whose condition is no longer valid and enable rule actions whose condition has become valid due to the state variable change. An event may be generated as part of a transaction or in response to the receipt of outside information that causes an event to be generated e.g. an adapter may make changes to instances through the dock API resulting in events and events may include generating altering or deleting an instance. For example upon receiving a message from an external business system a new instance of a type e.g. a type Message defined as part of the type definitions may be generated and a corresponding create event for the type may be generated which may happen implicitly and no special activities apart from constructing the Message instance using the dock API is carried out by the adapter to have an event generated where the event includes empty attributes for a before image and non empty attributes for the after image and where all or some of the attributes of the instance of Message type are transposed to the after image and only those attributes that change may be transposed to an image .

As an example of implementation of a business process to be executed by the state correlation engine the state correlation engine may perform a correlation between subscribers and published messages which may be referred to as message correlation. In particular multiple consumers may receive a message based on individual correlation criteria. For example each party of a messaging system including one or more enterprise systems may specify messages it wants to receive by using a Subscription object having a customer id attribute whose value must match a respective counterpart in the Message objects.

The subject matter described herein relates to a transactional state correlation for continuous evaluation of event condition action ECA rules which offers the expressiveness to support diverging business scenarios such as business process management BPM complex event processing CEP business activity monitoring BAM business rules management BRM and so forth. These scenarios rely on externalized events to trigger evaluation of an ECA rule or to propagate the result of these rules to another software component. Specifically each of the business scenarios may interact with heterogeneous backend systems such as enterprise resource planning ERP applications radio frequency identification RFID readers task management software email servers and the like to receive and or provide events. Moreover the interaction between business applications needs to be safeguarded by transactional guarantees to enforce ACID compliant business transactions. However it may be problematic to interface to the state correlation engine to exchange events with arbitrary heterogeneous backend applications. To that end the subject matter described herein provides in some implementations interfaces such as APIs A B to provide a mechanism for mediating between internal state variables of the state correlation engine and external events e.g. from the backend application which may rely on different data models and type systems e.g. a relational model vs. an object oriented data model etc .

Moreover the subject matter described herein provides in some implementations a mechanism for aligning the different models of the state correlation engine with the external applications such as backend application . For example internal transactions e.g. internal to a state correlation engine and external transactions of the backend applications are synchronized which may include joint save points and recovery of internal states and external backend system states as a prerequisite for supporting failover and cluster awareness protocols of a state correlation engine. Although a state correlation may be part of a BPM system or an ERP system the state correlation may be implemented independently of the BPM and ERP systems as well.

The subject matter described herein may also provide a protocol to make that alignment. For example an alignment of the lifecycle of the state correlation engine with the connected backend application may be implemented and the internal external state alignment may be performed as well.

Furthermore the subject matter described herein may provide a way of propagating a configuration e.g. included component of model to an adapter which may wrap a backend application . The adapter and backend application configuration is part of a complex scenario potentially involving rules and configurations for multiple adapters and backend applications. The adapter API B provides a way of handing over the relevant piece of configuration to the respective adapters and establishing transactional guarantees i.e. establishing atomicity and consistency around it. That is if one adapter or the state correlation engine including rule engine fails to accept a given piece of configuration the remaining adapters will not adopt their configuration fragments which were handed over in the same transaction either i.e. the configuration transaction aborts and its effects roll back.

Generally the subject matter described herein may provide a connectivity framework i.e. system for the state correlation engine . This connectivity framework provides adapters such as adapter to the state correlation engine e.g. to connect make a call to and the like . Specifically the adapter may implement a standardized adapter API B to receive events from the state correlation engine to one or more of backend applications and invokes functions of the standardized dock API A which is implemented by the state correlation engine to push events from the one or more backend applications to the state correlation engine .

Moreover system may include an internal type module to uniquely assign a type to a single adapter. For example the adapter controls e.g. is responsible for events related to the assigned type which includes 1 propagating events to the state correlation engine when triggered from a backend application e.g. using the dock API interface A and 2 propagating the events to the backend application when raised in the state correlation engine e.g. received through the adapter API interface B . A feature in some implementations of the subject matter described herein is performing these event mediations in a transactional e.g. ACID compliant manner. Moreover the alignment e.g. synchronization of transactions between a backend application and a state correlation engine works in both directions e.g. if the adapter receives an event from a backend system the adapter transforms the event into an instance of an internal type system and opens a new state correlation engine transaction to deliver this event to the correlation engine . The adapter also needs to mark the newly opened internal engine transaction as persistent to enforce the transaction coupling. The latter is of course only necessary if the backend application has invoked the adapter within an external transaction. In some boundary use cases e.g. best effort message delivery backend applications may interact with adapters in a non transactional manner.

The APIs A B described herein are thus implemented to enable state correlation engine transactions to participate in the backend application transactions and vice versa.

In addition the APIs A B described herein are each configured to support state displacement e.g. eviction of state variables from main memory and recovery e.g. re entry of state variables into main memory which is a pre requisite for failover guarantees and cluster awareness. For example the state correlation engine may mark a transaction as persistent e.g. where the default for a transaction is transient only execution enforcing thus a database save point where both the internal state e.g. internal to state correlation engine and external state e.g. of backend application is written to a database although this is a side effect of transaction synchronization. Moreover the state correlation engine may autonomously open an external database transaction thus having the same effect as in transaction coupling.

Moreover the state correlation engine may include multiple triggers to trigger a save point. As opposed to adapters requiring a save point through transaction coupling these triggers are internal i.e. the rules engine itself initiates coupling an internal transaction to an external database transaction thus enforcing a save point which aids to support transactional coupling. These triggers may include one or more of the following eviction e.g. displacement of state from main memory to disk to save resources state transport across a cluster and failover e.g. persist the effects of transactions which interact with a backend application and cannot thus be repeated . In addition the state correlation engine may access the adapter to which is linked to an internal state variable e.g. of a backend application and to re establish the complete system state based on a save point.

The adapter may also handle lifecycle events of the backend application s and the state correlation engine. The adapter may register at and un register from the state correlation engine if the backend system starts up or e.g. shuts down . Likewise the adapter is notified if the rule engine is temporarily unable to serve requests such as receive events through the dock API A.

The subject matter described herein also supports setting up an entire scenario which may be required i.e. besides declaring the types and deploying the ECA rules to the engine itself to configure the connected backend application to a particular scenario e.g. a complex event processing scenario where incoming RFID signals are tracked and aggregated requiring an adapter to the backend application which sends the RFID signals to configure the RFID readers from which signals are received . The configuration e.g. included in module of an adapter is part of a transactional deployment mechanism enabling the adapter to autonomously rollback deployment if the received configuration cannot be handled by the connected backend system.

At an interface is provided. The dock API A is provided by the state correlation engine and used e.g. called by the adapter and the adapter API B is provided by the adapter and used by the state correlation engine . That is the dock API A may act as an abstraction of the state correlation engine to the adapter whereas the adapter API B may act as an abstraction of the adapter to the state correlation engine . The dock API A passes information to the state correlation wherein the state correlation engine passes information to the adapter and indirectly also to the external application via adapter API B. Backend application is separate from applications associated with the state correlation engine . For example the backend application may be an email server and the state correlation engine may be associated with a BPM system. The backend application and state correlation engine are de coupled components with different lifecycles. The adapter is another so called in between application potentially having even another lifecycle than the backend application which bi directionally interfaces the state correlation engine and the backend application through protocols represented by the dock API and the adapter API. Moreover the adapter may implement the adapter API B and docks in into the state correlation engine using the dock API A to be operational.

At an interface such as adapter API B receives from the state correlation engine information to alter a state of the application . For example adapter API B associated with adapter may receive information such as a transaction ticket e.g. a technical representative of an internal transaction state information of e.g. a fragment of the system of state correlation engine calls to invoke one or more methods at the adapter and the like. In the case of the adapter configuration case i.e. transactional deployment the state correlation engine may provide semi structured configuration data to the adapter via adapter API B which is usually some technical configuration that customizes existing functionality of the adapter or the connected backend application .

At an interface such as dock API A receives information from the adapter which wraps the backend application . The received information is used to alter a state of the state correlation engine e.g. create a new instance of a state variable . In the case of this so called in flight use case i.e. transaction synchronization and state coupling this step may denote a case where the backend application first accesses the adapter to signal a event that has happened on the backend application side. The adapter then re formulates and filters the received information to fit the state correlation engine type system and then passes on the adapted information to the state correlation engine through the dock API A.

At the state of the application and or the state correlation engine are configured to provide an alignment. For example the adapter may change state variables internal to the state correlation engine through dock API A to correspond reflect changes on the external state and the adapter changes external state when changes to internal state variables are received through adapter API B.

An adapter may be responsible for a single backend application. The adapter may also include one or more of the feature described below. To illustrate these features the following provides an example which refers to an adapter for a task inbox e.g. a task inbox adapter . The task inbox refers to a task list e.g. of work items which is presented via a user interface to a user. A work item may be represented by an object which includes attributes such as a due date a subject a processor role assignment etc. For example the object may include the state information of the task itself e.g. a new task an in progress task a completed task and so on and who is actually supposed to carry out the task. In some implementations the primary if not the only purpose of the task inbox adapter which would be implemented as an adapter is to synchronize these states with the task inbox which acts as backend application regardless of whether the change to that state occurs in the state correlation engine or in the task inbox application . Specifically if an state variable representing the task is created within the state correlation engine the task inbox must be notified to create a corresponding work item. Similarly if the task state variable is removed the task in box work item would also be deleted. In that sense the task adapter aligns the external state e.g. work items held by the task inbox and corresponding internal state variables of the state correlation engine .

The adapter B manages outgoing web service calls. Specifically the adapter B governs the type Call which represents an outgoing web service call and connects to an Enterprise Resource Planning ERP backend application system B and invokes asynchronous reliable web service to deliver the call parameters.

The BPM adapter also includes a runtime node notification method e.g. called as enterMode RuntimeMode mode . For example this method may be used for notifying the adapter of a runtime mode switch. There may be runtime modes of the state correlation engine denoting certain operational states such as normal recovery deployment etc. The state correlation engine may indicate to the adapter to be unavailable or available.

The BPM adapter may also include a configuration method and a un configuration method. This configuration method and or the un configuration method may be called whenever necessary but is typically called at least once during the docking of the adapter to the BPM application. These are functions of the adapter API B e.g. the configure methods hands over semi structured configuration data to the adapter API B as part of a scenario deployment and vice versa and the unconfiguration method revokes this data by notifying the adapter that this piece of configuration is no longer valid .

The BPM adapter may also include other lifecycle controls. For example the BPM adapter may couple to a state correlation engine of BPM application . The BPM adapter may function in conjunction with the two lifecycles of the internal BPM side and the adapted external side of backend application which is a business process administration system in this case . These lifecycles are normally controlled by a framework i.e. a system and the BPM adapter is started when both internal and external systems are running. The BPM application runtime offers an optional third lifecycle which originates from the fact that the state correlation engine may replace its own internal states at runtime e.g. as part of its cluster enablement protocols without triggering a full lifecycle management restart.

Examples of the lifecycle control methods include the adapter indicates to the state correlation engine to be available or unavailable e.g. through a dock call or an undock call of the dock API A the state correlation engine indicates to the adapter to forcefully shut down e.g. using a shutdown call of the adapter API B or notifies the adapter to be unavailable e.g. through an enterRuntimeMode call of the adapter API B and the state correlation engine notifies the adapter to temporarily sign off e.g. using a slumber call and a subsequent wakeup call of the adapter API B without needing to fully restart the adapter during the slumber . . . wakeup call sequence although the state correlation engine may itself restart. To adhere to these transient restarts the BPM adapter typically includes a slumber method and a wakeup method.

The slumber method call represents that the BPM application runtime will go away temporarily e.g. stop serving or responding to requests so that the adapter can undock itself and a shutdown of the BPM application will be called in a controlled manner in the same call stack which can be detected or the adapter can ignore the slumber method and the adapter shutdown will be called at a later point. The wakeup method call represents that the runtime of the BPM application has returned and the BPM application is configured to service docking requests. In most cases nothing e.g. interfaces objects etc may be cached between slumber and wakeup as these are no longer valid when the runtime returns.

Docking the BPM adapter to the BPM application runtime is the first contact between BPM adapter and BPM application . A so called docking port which is implemented by the dock API A may be found in a Java Naming and Directory Interface JNDI registry. The dock API A includes a method referred to as dock which takes the BPM adapter as a parameter. After a successful docking procedure which may include zero to many configuration calls which the state correlation engine does on the newly docked adapter through the adapter API B a handle object will be returned which allows the BPM adapter to further access BPM application and its module or subsystems such as a transition manager through the dock API A. In this regard the dock API A is used in a way that the dock call is the first thing which happens before other functionality of the dock API may be invoked. During the call to dock the BPM adapter a configuration method at BPM adapter is called with one or more of the following parameters the types the adapter governs which have been assigned to the BPM adapter a specific configuration for the BPM adapter a transaction ticket representing the transactional context of the configuration procedure and the reason the configuration procedure is being called. The BPM adapter would also have checks to confirm the BPM adapter configuration so that only acceptable configurations would be allowed. If the BPM adapter configuration is not allowed and thus invalid the BPM adapter may send a message which raises an exception which implicitly lets the internal transaction roll back . The adapter exception message may thus cause a transaction to rollback.

Moreover the BPM adapter configuration can be called or invoked multiple times during a given docking operation. In addition the configuration method may also be called for the reason of a deployment e.g. whenever new information has been deployed new types deployed and or new configurations deployed . The transactional context of the state correlation engine is typically handled during the configuration calls. During the call the kernel execution system of BPM application may and most likely will continue process execution during which adapters may be called via adapter API B. Therefore executional parts of the BPM adapter may not operate on not yet committed BPM types of BPM application or on not yet committed configurations . There are different transactional contexts also referred to as transition ticket for configure calls. In other words the dock API A provides means to handle the configuration call transactionally. Specifically the dock API A allows for implementing a two phase commit strategy which will only let the adapter materialize e.g. make visible for other concurrently running transactions the received configuration data once other affected adapters have successfully prepared the commit.

Moreover in some implementations BPM application may include a set of BPM types which may be examined and checked by BPM adapter for required attributes such as names types and the like methods including e.g. parameters return type names etc or other features used during operation. This is an adapter side validation of types which requires the adapter to check types and configuration received during the configure call. If one of those does not match the adapter s expectations the transaction is ultimately rolled back. Each type may also be supplied with an invocation handler and a persistency handler which are a flexible part of the adapter API for state alignment and transaction coupling purposes.

Furthermore BPM application may include a persistency handler which may be called whenever an object is being persisted e.g. to allow the BPM adapter to have its own supplemental persistence to persist externally held state which is associated to particular internal state variables . The adapter may either persist the external state on its own or alternatively leverage other functionality of the wrapped backend system to invoke the persistence. The persistence handler may be used by the BPM adapter to recover its adapter held external state if any from persistence.

In some implementations the BPM adapter includes an adapter specific configuration see e.g. type definitions and configurations for adapters . The configuration specific to an adapter may be presented through a tree based structure where each level has a set of key value pairs as well as a set of named substructures.

In some implementations the BPM adapter may support recovery. When that is the case if the BPM adapter maintains its own external state which depends on a set of objects. The BPM adapter may also register during configuration a displacement handler which is also part of the adapter API B tailored for transactional coupling in the context of a cluster enablement protocol where both internal state variables and associated external state may need to be moved from one cluster node to another. After configuration of the BPM adapter the displacement handler s arrive method may be called for the extension of a type all instances of the type which is governed by the adapter for that particular class at which point the BPM adapter rebuilds the external state associated to those state variable instances. During these calls the BPM adapter queries any database tables related to the BPM adapter s internal structure so that the adapter is free to query a database or any other data source to build up the external state associated to an internal state variable which has arrived at this cluster node. In the case of a state variable e.g. a BPM object sent from a given cluster node due to a request by another node the displacement handler s depart method is called. In the case of a given object becoming inactive and the resources are released for this an evict method is called. The persistence handler s methods are called when for example objects take part in persistence actions such as when the object becomes persisted or eradicated to free up resources currently occupied by this state variable and the associated external state.

The adapters such as BPM adapter which have registered persistence handlers may have its persist method and eradicate method called with an open external database transaction e.g. a JPA transaction that is automatically opened and coupled to the internal transaction by the rule engine when objects are persisted and deleted respectively to let the adapter maintain separate supplementary database tables which includes the externally held state . If the internal transaction is opened by the adapter itself e.g. as opposed to being invoked through the invocation handler with an already open transaction a persistency callback may be registered as well. This persistency callback will be called during the prepare phase with an open database transaction although not necessarily in the same thread of control or other like lightweight process . In some if not all implementations externally held state may be persisted to a database if the rule engine does not decide to do so otherwise the adapter s state may become out of synch with the state of the kernel which may cause errors if a recovery occurs .

As described above triggering events are done in an internal e.g. to main memory transaction which is accessible through the dock API at dock time. The opposite form of persistency synchronization is demonstrated in the send message method realized through a function callback as part of the adapter API. In this case the messaging layer expects an open transaction to synchronize to ensure that a reliable path is maintained.

The systems and methods disclosed herein may be embodied in various forms including for example a data processor such as a computer that also includes a database digital electronic circuitry firmware software or in combinations of them. Moreover the above noted features and other aspects and principles of the present disclosed embodiments may be implemented in various environments. Such environments and related applications may be specially constructed for performing the various processes and operations according to the disclosed embodiments or they may include a general purpose computer or computing platform selectively activated or reconfigured by code to provide the necessary functionality. The processes disclosed herein are not inherently related to any particular computer network architecture environment or other apparatus and may be implemented by a suitable combination of hardware software and or firmware. For example various general purpose machines may be used with programs written in accordance with teachings of the disclosed embodiments or it may be more convenient to construct a specialized apparatus or system to perform the required methods and techniques.

The systems and methods disclosed herein may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

Although ordinal numbers such as first second and the like may in some situations relate to an order as used in this document ordinal numbers do not necessarily imply an order. For example ordinal numbers may be merely used to distinguish one item from another. For example to distinguish a first event from a second event but need not imply any chronological ordering or a fixed reference system such that a first event in one paragraph of the description may be different from a first event in another paragraph of the description .

The foregoing description is intended to illustrate but not to limit the scope of the invention which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims.

