---

title: System and method for enabling scene program functionality
abstract: One embodiment of the present invention sets forth a technique for specifying scene programs, where the effect of executing a particular scene program is to generate a sequence of graphics commands. The application programming interface is extended to include calls used to specify a high-level scene program. Upon receiving a high-level scene program, the graphics driver generates a machine code scene program. When an application program emits a call to execute one or more machine code scene programs, the graphics driver transmits corresponding scene programs execution commands to the graphics pre-processing unit. For each scene program execution command, the graphics pre-processing unit processes instructions, programmatically reconfigures the graphics pipeline based on the execution of the machine code scene program, and launches one or more parallel threads that execute commands within the graphics pipeline. Advantageously, using scene programs, application developers may tailor application programs to more effectively dispatch tasks to the GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218691&OS=09218691&RS=09218691
owner: NVIDIA CORPORATION
number: 09218691
owner_city: Santa Clara
owner_country: US
publication_date: 20080522
---
The present invention relates generally to the field of graphics processing and more specifically to a system and method for enabling scene program functionality.

A typical computing system includes a central processing unit CPU and a graphics processing unit GPU . Some GPUs are capable of very high performance using a relatively large number of small parallel execution threads on dedicated programmable hardware processing units. The specialized design of such GPUs allows these GPUs to perform certain tasks such as rendering 3 D scenes much faster than a CPU. However the specialized design of these GPUs also limits the types of tasks that the GPU can perform. The CPU is typically a more general purpose processing unit and therefore can perform most tasks. Consequently the CPU usually executes the overall structure of software application programs and configures the GPUs to perform specific graphics related tasks in the graphics pipeline.

To fully realize the processing capabilities of advanced GPUs GPU functionality may be exposed to graphics application developers through an application programming interface API of calls and libraries. Among other things doing so enables graphics application developers to tailor their application programs to optimize the way GPUs process graphics scenes and images. For example in some GPUs the API may allow the hardware processing units to be configured as shading engines e.g. vertex geometry and fragment that include geometry shaders operating in parallel.

More recently the performance of advanced CPU processing cores has not been increasing as quickly as the performance of advanced GPUs. Consequently there is a disparity in computing systems between the performance of the CPU processing core that is generating graphics rendering commands and the GPU that is processing these graphics rendering commands. Thus in some computing systems the CPU may not be able to generate and transmit graphics rendering commands at the speed with which the GPU can accept and process these commands. As a result the CPU may become a bottleneck in the execution of the graphics calls issued by application programs thereby hindering the performance of the GPU.

In one approach to increasing the performance of CPUs CPU designers have been attempting to integrate more processing cores into the CPU. However in current graphics APIs the interface between the application programs and the GPU is usually single threaded. In other words the graphics calls emitted by the application programs are generated and transmitted to the GPU serially. As a result the application programs cannot take advantage of the additional cores in the CPU to increase the speed at which the CPU generates and transmits graphics rendering commands to the GPU. Consequently the CPU is still a bottleneck in the graphics pipeline.

As the foregoing illustrates what is needed in the art is a technique that allows an application program to more effectively dispatch tasks to a GPU.

One embodiment of the present invention sets forth a method for rendering a graphics scene. The method includes the steps of receiving a call from an application program to execute one or more instances of a first scene program wherein each instance of the first scene program is associated with a sequence of graphics commands identifying a machine code version of the first scene program and a corresponding high level version of the first scene program determining an execution order of the one or more instances of the first scene program based on state information associated with the high level version of the first scene program and launching one or more threads for executing one or more instances of the machine code versions of the first scene program.

One advantage of the disclosed method is that high level scene programs and corresponding machine code scene programs allow application developers to leverage the API to offload graphics processing tasks from the CPU to the graphics processing subsystem. Advantageously calling machine code scene programs mitigates the serialized nature of the API and therefore reduces the likelihood of the CPU creating a bottleneck in the graphics pipeline.

As shown the CPU connects to the input devices the system memory and the graphics processing subsystem via the system bus . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM used to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions that are transmitted by the CPU and processes the instructions in order to render and display graphics images on the display devices .

The system memory includes one or more application programs an application programming interface API high level shading programs high level scene programs and a graphics driver . The application programs generate calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application programs also transmit one or more high level shading programs and one or more high level scene programs to the API for processing within the graphics driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shaders within the graphics processing subsystem . Similarly the high level scene programs are typically source code text of high level programming instructions that are designed to programmatically execute and operate on various components within the graphics processing subsystem . The API functionality is typically implemented within the graphics driver .

The high level scene programs are specified using a text language that includes constructs such as looping and branching. Further each high level scene programs includes one or more calls to the API . The API includes a variety of calls designed to specify the high level scene programs and to execute instances of the machine code versions of the high level scene programs . For example the API may include calls used to specify import state and export state for the high level scene programs . Moreover the API may include calls to execute one or more instances of one or more of the machine code versions of one or more high level scene programs where the export state from each instance is to be applied to the current state before the next instance is executed. The state may include a variety of settings that affect the rendering and display of images such as the current color and texture. For each high level scene program defining the import state and the export state encapsulates the effects of executing instances of the machine code version of that particular high level scene program . Advantageously encapsulating the state for each high level scene program enables the graphics driver to determine any dependencies between the machine code versions of the high level scene programs .

As discussed in greater detail in conjunction with after evaluating the dependencies the graphics driver determines whether to execute one or more instances of the machine code versions of one or more high level scene programs in parallel serially or a combination thereof. TABLE 1 sets forth some examples of API calls that may be used to specify or call high level scene programs.

The API also enables each high level scene program to hierarchically call instances of machine code scene programs. Components within the graphics processing subsystem use the import state and the export state of the machine code scene programs to determine any dependencies. Components within the graphics processing subsystem then use the dependencies to schedule the execution of the hierarchically called instances of the machine code scene programs in parallel serially or a combination thereof.

In alternative embodiments the high level scene programs may be generated using any technically feasible method. For example one or more of the high level scene programs may include exclusively static constructs. Such a high level scene program may be generated using a prior art API conversion. In the API conversion technique one or more API calls may be recorded and subsequently a conversion program may convert each API call into a corresponding line of text.

The graphics processing subsystem executes the commands transmitted by the graphics driver to render graphics data and images. These commands may include calls to execute instances of machine code scene programs and calls to reconfigure the graphics processing subsystem to implement machine code shading programs. Subsequently the graphics processing subsystem may display certain graphics images on the display devices that are connected to the graphics processing subsystem via the video cables . Each display device is an output device capable of emitting a visual image corresponding to an input graphics image. For example each display device may be built using a liquid crystal display LCD a cathode ray tube CRT monitor or any other suitable display system.

The graphics driver receives the high level shading programs not shown generates the machine code shading programs and stores the machine code shading programs as machine code shading programs in the local memory . The shading program compiler linker is configured to convert the high level shading programs into machine code shading programs that are optimized to operate on one or more programmable shading engines within the GPU .

In alternate embodiments the shading program compiler linker may be configured to convert the high level shading programs into intermediate assembly language programs and then generate the machine code shading programs based on the assembly language programs. In other embodiments the shading program compiler linker may not be included in the graphics driver. Instead the machine code shading programs may be generated using any technically feasible off line method and then transmitted to the graphics driver via the system bus . Further in some embodiments the machine code shading programs may be stored in the system memory or in on chip GPU memory instead of the local memory .

The graphics driver also receives the high level scene programs not shown generates the machine code scene programs and stores the machine code scene programs as machine code scene programs in the local memory . The scene program compiler linker is configured to convert the high level scene programs into machine code scene programs that are optimized to operate within the GPPU .

In some embodiments the scene program compiler linker may be configured to convert the high level scene programs into intermediate assembly language programs and then generate the machine code scene programs based on the assembly language programs. In other embodiments the scene program compiler linker may not be included in the graphics driver. Instead the machine code scene programs may be generated using any technically feasible off line method and then transmitted to the graphics driver via the system bus . Further in some embodiments the machine code scene programs may be stored in the system memory or in on chip GPPU memory instead of the local memory .

The graphics driver is also configured to receive calls to the API that are emitted from the application programs . These calls may include calls to execute one or more instances of one or more machine code scene programs . Upon receiving such a call the graphics driver evaluates the import state and export state of the corresponding high level scene programs to identify any dependencies amongst the instances of the applicable machine code scene programs . After identifying any such dependencies the graphics driver determines which if any instances of the machine code scene programs may be executed in parallel without corrupting the execution of the application program . For example the machine code version of any high level scene program that does not specify either an import state or an export state may be executed in parallel.

Once that determination is made the graphics driver transmits one or more execution threads in parallel serially or any combination thereof to the GPPU . Each of these threads includes one scene program execution command that executes a particular instance of a particular machine code scene program . Together the threads execute all of the instances of the machine code scene program that are specified in the call. Advantageously although the API between the application programs and the graphics processing subsystem is single threaded when a particular API call indicates that one or more instances of one or more machine code scene programs should be executed the graphics driver may launch multiple parallel execution threads to achieve such an outcome.

In alternate embodiments the graphics driver may be configured to determine and use the optimal resource available in the computing system for compiling scene programs and executing instances of machine code scene programs. For example some graphics processing subsystems may not include a graphics pre processing unit that is capable of implementing the high level instruction set that may be used by the scene programs. If the graphics driver does not identify an appropriate resource within the graphics process subsystem to implement the scene programs then the graphics driver may compile the high level scene programs to machine code scene programs targeted for execution by the CPU. Subsequently the graphics driver may attempt to configure an available core of the CPU to receive the scene program execution commands. If no core is available then the graphics driver may process the scene program execution commands itself. In this fashion the graphics driver may be configured to take advantage of whatever hardware exists in a computing system to implement the scene program functionality.

The graphics pre processing unit GPPU includes one or more pre processors . Each of the pre processors is capable of processing one or more execution threads concurrently. Further each of the pre processors implements a high level instruction set that enables the pre processor to execute instances of the machine code scene programs . The instruction set supports constructs such as branching control calls to machine code shading programs hierarchical calls to machine code scene programs and the like. The GPPU uses the pre processors to execute the instructions in the machine code scene programs . Moreover the GPPU is configured to identify and exploit opportunities to concurrently execute the instructions in the machine code scene program in any technically feasible fashion. The GPPU may be provided with any amount of local memory and may use local memory and or system memory in any combination for memory operations.

Upon receiving a scene program execution command the GPPU executes an instance of the specified machine code scene program . In so doing the GPPU executes any number of scene program instructions within the GPPU and launches any number of threads in parallel serially or any combination thereof to execute graphics commands within the graphics pipeline. Further based on the execution of the instances of the machine code scene program the GPPU may conditionally reconfigure the graphics pipeline. For example the GPPU may evaluate the import state to dynamically select a particular vertex shading program configure components within the GPU as a vertex shading engine that implements the selected vertex shading program and process a set of vertices using the vertex shading engine.

As previously described herein the API includes constructs used to define the import state and export state for each machine code scene program . The GPPU uses the import state in conjunction with a default state to execute the instructions in the machine code scene program within a known environment. For example the import state and export state calls may enable one instance of a particular machine code scene program to set up the state for a subsequent instance of another machine code scene program . Furthermore defining execution state for each machine code scene program enables the GPPU to identify any dependencies amongst instances of machine code scene program that are called hierarchically during the execution of a particular machine code scene program . After identifying any such dependencies the GPPU determines which if any of these child instances are amenable to being executed in parallel without corrupting the execution of the parent machine code scene program . The GPPU then spawns one or more execution threads in parallel serially or a combination thereof to execute the child instances of the machine code scene programs .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as a programmable shading engine that can execute a particular machine code shading program to perform image rendering operations. The GPU may be provided with any amount of local memory and may use local memory and or system memory in any combination for memory operations.

The local memory is used to store data and programming used by the graphics processing subsystem and may include machine code shading programs machine code scene programs and a frame buffer . The machine code shading programs and the machine code scene programs may be transmitted from the graphics driver to the local memory via the system bus of . The machine code shading programs may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The frame buffer stores data for at least one two dimensional surface that may be used to drive the display devices not shown . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is used to drive the display devices .

The data assembler is a fixed function unit that collects vertex data from the application program for high order surfaces primitives and the like and passes the vertex data to the vertex shading engine . The data assembler may gather data from buffers stored within the system memory and the local memory as well as from API calls from the application program used to specify vertex attributes. The vertex shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code vertex shading program processing vertex data as specified by the vertex shading program. For example the vertex shading engine may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex shading engine may access data that is stored in local memory .

The primitive assembler is a fixed function unit that receives processed vertex data from the vertex shading engine and constructs graphics primitives e.g. points lines triangles or the like for processing by the geometry shading engine . In alternative embodiments a second primitive assembler not shown may be included subsequent to the geometry shading engine in the data flow through the GPU . The geometry shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code geometry shading program processing graphics primitives received from the primitive assembler as specified by the geometry shading program. For example in addition to well known per primitive operations such as clipping the geometry shading engine may be programmed to generate one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. The geometry shading engine may access data that is stored in the local memory . The geometry shading engine outputs the parameters and new graphics primitives to the rasterizer . The rasterizer is a fixed function unit that scans the new graphics primitives and outputs fragments each containing fragment data which may include raster position depth or interpolated vertex attributes such as texture coordinates and opacity to the fragment shading engine .

The fragment shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code fragment shading program processing fragments received from the rasterizer as specified by the machine code fragment shading program. For example the fragment shading engine may be programmed to perform operations such as perspective correction shading blending and the like to produce shaded fragments that are output to the raster operations unit . The fragment shading engine may access data that is stored in buffers in the local memory . The raster operations unit optionally performs fixed function computations such as near and far plane clipping and raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in a buffer in the local memory .

Upon receiving a single call from an application program to execute instances of machine level scene programs the graphics driver may spawn multiple parallel threads to be processed by the GPPU . Further for each of these threads the GPPU may spawn multiple parallel threads for execution within the GPU . In this fashion the scene program functionality optimizes the graphics pipeline that exists within the GPU . Moreover the programmable domain existing inside the GPU is further abstracted to include the programmable domain existing inside the GPPU . Using the machine code scene programs and the machine code shading programs the graphics pipeline may be dynamically reconfigured within the graphics processing subsystem . Enabling dynamic reconfiguration of the graphics pipeline without intervention from the CPU further optimizes the performance of the computing system .

As shown the method begins at step where the graphics driver receives and processes a call from an application program to execute two instances of a first machine code scene program that renders and displays a molecule i.e. the molecule machine code scene program . Each instance is configured to operate on a different molecule. The graphics driver evaluates the import state and the export state of the molecule high level scene program and determines that the two instances of the molecule machine code scene program have no dependencies. Subsequently the graphics driver launches two parallel execution threads for processing by the GPPU . Each of these threads contains a scene program execution command that executes the molecule machine code scene program on a different one of the two molecules. At step the GPPU concurrently processes the two threads launched by the graphics driver . Thus the GPPU begins executing two instances of the molecule machine code scene program the first instance operating on molecule one and the second instance operating on molecule two.

At step the GPPU performs setup calculations as specified by the instructions in the molecule machine code scene program. For each molecule these calculations include computing the number and type of atoms included in the molecule and the import state for rendering and displaying each of these atoms. For example for a particular atom the import state may include the location and the color to display for the atom. Again the GPPU concurrently processes the two molecules. As part of step the GPPU may determine that the molecule one includes one hundred atoms. Similarly as part of step the GPPU may determine that the molecule two includes fifty atoms. At step the GPPU evaluates the import state and export state a second machine code scene program that renders and displays an atom i.e. the atom machine code scene program . The GPPU determines that the instances of the atom machine code scene program have no dependencies. Subsequently as part of step the GPPU spawns one hundred parallel threads that execute one hundred instances of the atom machine code scene program one instance on each of the atoms in molecule one. Concurrently to step as part of step the GPPU spawns fifty parallel threads that execute fifty instances of the atom machine code scene program one instance on each the atoms in molecule two. Again each of the instances includes a distinct import state that defines per atom information such as the location and the color. Based on the execution of the instances of the atom machine code scene program the GPPU conditionally and dynamically configures the graphics pipeline within the GPU as one or more shading engines.

At step the GPPU launches one hundred and fifty parallel threads for processing by the GPU . Each of these threads executes atom graphics commands within the graphics pipeline of the GPU rendering and displaying a particular atom that is included in either molecule one or molecule two. At step the thread associated with molecule one within the GPPU waits for the one hundred parallel threads that are processing the atoms included in molecule one to complete executing in the GPU . Then the GPPU continues processing molecule one executing instructions specified by the molecule machine code scene program. Based on the execution of these instructions the GPPU reconfigures the graphics pipeline within the GPU . The GPPU then launches a thread for processing molecule level graphics commands on the GPU . The execution of this thread on the GPU completes the rendering and display of molecule one.

Concurrently to step at step the thread associated with molecule two within the GPPU waits for the fifty parallel threads that are processing the atoms included in molecule two to complete executing in the GPU . Then the GPPU continues processing molecule two executing instructions specified by the molecule machine code scene program. Based on the execution of these instructions the GPPU reconfigures the graphics pipeline within the GPU . The GPPU then launches a thread for processing molecule level graphics commands on the GPU . The execution of this thread on the GPU completes the rendering and display of molecule two. Again steps and are conducted using parallel threads within the GPPU and parallel threads within the GPU .

As shown the method begins at step where the application program emits a single call to execute one or more instances of one or more machine code scene programs . At step the graphics driver receives the call. At step the graphics driver identifies the one or more machine code scene programs specified in the single call received at step and the one or more corresponding high level scene programs . The graphics driver may accomplish this identification in any technically feasible manner. For example the graphics driver may identify the machine code scene programs and the high level scene programs by name identifier or pointers to memory.

At step the graphics driver uses the import state and the export state of the identified high level scene programs to determine any dependencies amongst the corresponding machine code scene programs . As previously described herein the graphics driver is configured to schedule the execution of the instances of the machine code scene program to exploit any opportunities for concurrency while ensuring the integrity of the graphics processing of the application program . At step the graphics driver launches one or more execution threads in parallel serially or any combination thereof for processing by the GPPU . Each of these execution threads includes one scene program execution command that executes a specific instance of a particular machine code scene program . Together these threads configure the GPPU to execute all the instances of the machine code scene programs specified in the single call that was received by the graphics driver at step .

As shown the method begins at step where the GPPU receives a scene program execution command and initiates the execution of an instance of a specified machine code scene program . At step the GPPU uses the import state of the machine code scene program in conjunction with a default state to create a known environment within which to execute the instructions specified by the machine code scene program . At step the GPPU executes one or more instructions within the GPPU as specified by the machine code scene program . As detailed above in conjunction with these instructions may include conditional branching hierarchical calls to execute one or more instances of machine code scene programs and the like. At step the GPPU programmatically configures the graphics pipeline within the GPU based on the execution of the machine code scene program . At step the GPPU launches one or more execution threads in parallel serially or any combination thereof for processing by the GPU . Each of these threads executes graphics commands within the graphics pipeline .

At step if the GPPU determines that the instance of the machine code scene program specified in step has not finished executing then the method returns to step . The method continues in this fashion looping through steps until the GPPU finishes executing the instance of the machine code scene program specified in step . If at step the GPPU determines that the instance of the machine code scene program specified in step has finished executing then the method proceeds to step . At step if the machine code scene program defines an export state then the GPPU exports the state settings thereby enabling subsequent rendering programs to use the export state.

Again as detailed above in conjunction with the GPPU is configured to identify and exploit opportunities to execute the instructions in the machine code scene program using parallel execution threads. Consequently throughout the steps of method the GPPU may execute any number of parallel threads and any number of serial threads.

In sum scene programs provide a new mechanism for application developers to efficiently specify and dispatch sequences of graphics tasks to the graphics processing subsystem. In one embodiment the application programming interface API the graphics driver and the graphics processing subsystem are enhanced to enable the specification and execution of scene programs. The API is extended to include calls that are used to specify and invoke high level scene programs. Some of the capabilities that these calls enable include branch control and hierarchical execution of scene programs import state specification and export state specification.

Upon receiving a high level scene program the graphics driver generates a machine code version of the scene program and transmits this program to the local memory within the graphics processing subsystem. When the application program emits a call to execute one or more machine code scene programs the graphics driver evaluates the import state and the export state to identify opportunities for parallelism within the graphics pre processing unit. The graphics driver then dispatches one or more threads each containing scene program execution commands to the graphics pre processing unit within the graphics processing subsystem for execution. Upon receiving a scene program execution command the graphics pre processing unit executes the appropriate machine code scene program. While executing the machine code scene program the graphics pre processing unit may programmatically reconfigure the graphics pipeline based on the execution of the machine code scene program and launch one or more parallel threads that execute graphics commands within the graphics pipeline. Further still while executing the machine code scene program the graphics pre processing unit may hierarchically execute instances of machine code scene programs. Again the graphics pre processing unit uses the import states and the export states to identify opportunities for parallelism within both the graphics pre processing unit and the GPU.

High level scene programs and the corresponding machine code scene programs allow application developers to leverage the API to offload graphics processing tasks from the CPU to the graphics processing subsystem. Advantageously calling machine code scene programs mitigates the serialized nature of the API and therefore reduces the likelihood of the CPU creating a bottleneck in the graphics pipeline. Furthermore since high level scene programs may include branching and control instructions each high level scene program may be used to implement a variety of algorithms that require dynamic reconfiguring of the graphics pipeline. Finally specifying import states and export states within high level scene programs allows the graphics driver and graphics pre processing unit to identify and exploit opportunities for executing instances of machine code scene programs in parallel thereby further optimizing the graphics pipeline.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the above examples embodiments and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

