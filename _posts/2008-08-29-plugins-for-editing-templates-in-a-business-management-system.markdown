---

title: Plug-ins for editing templates in a business management system
abstract: A template authoring method and system includes an application business component view that provides an interface to a user to select templates. A dialog provides a wrapper for each template to be edited by launching a server page and a host using controls provides authoring abstractions for selected authoring applications to edit the templates.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08806357&OS=08806357&RS=08806357
owner: SAP AG
number: 08806357
owner_city: Walldorf
owner_country: DE
publication_date: 20080829
---
U.S. Application entitled Integrated Document Oriented Templates filed Aug. 29 2008 and given U.S. application Ser. No. 12 202 039 and

U.S. Application entitled Generic Data Retrieval filed Aug. 29 2008 and given U.S. application Ser. No. 12 202 056.

Templates are commonly provided for many different types of documents. The templates facilitate batch processing that may pull information from a database to fill in placeholders of a template and result in customized documents. Some examples include a mailing to multiple customers. The address field and salutation may be placeholders in a template of the mailing and when filled in with data from a customer database each customer may be mailed a letter that is personalized. Other examples may include invoices purchase orders and many other types of business documents produced by many different types of programs from word processors to spreadsheet programs.

In server oriented business management systems many different clients may be served by a single system which may consist of multiple computers and storage devices coupled to the clients via network. Templates in such systems may be treated as a development object. Development objects are available across all clients while the data to populate the templates for each client is separated between clients. Since the development objects have global aspects which means that they are available to all the clients a template change instigated by one client will show up in the template for all clients. Such a change may not be desired by all clients.

In the following description reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific embodiments which may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that structural logical and electrical changes may be made without departing from the scope of the present invention. The following description of example embodiments is therefore not to be taken in a limited sense and the scope of the present invention is defined by the appended claims.

The functions or algorithms described herein may be implemented in software or a combination of software and human implemented procedures in one embodiment. The software may consist of computer executable instructions stored on computer readable media such as memory or other type of storage devices. The term computer readable media is also used to represent any means by which the computer readable instructions may be received by the computer such as by different forms of wired or wireless transmissions. Further such functions correspond to modules which are software hardware firmware or any combination thereof. Multiple functions may be performed in one or more modules as desired and the embodiments described are merely examples. The software may be executed on a digital signal processor ASIC microprocessor or other type of processor operating on a computer system such as a personal computer server or other computer system.

In various embodiments a system includes a server that provides a business management service to multiple independent customers. The server has a template repository having predefined templates that may be used by customers for tasks such as a mass mailings. The templates are stored as content and not as development objects. A configuration storage stores customer changes to the predefined templates to provide customized templates. A user interface facilitates selection of customized templates as a function of scope of work and customized templates available for fine tuning corresponding to the scope of work. In this manner customers may create customized templates that need not be shared across the entire set of customers using the system. A common base for templates like Adobe print forms Excel download templates text templates and many other types of templates may be provided.

Business objects as described above are a technical representation of a concept that includes data and logic. In some embodiments a business object has a structure that includes a root node and sub nodes. The nodes hold information such as data and logic corresponding to various business processes that can be modified in a design time environment.

Placeholders may be thought of as variables in a template that refer to data to be looked up in a database when documents are created based on template . One way to represent the placeholders is in a well structured XSD XML schema. Such a schema may be used to represent data which is organized in a hierarchical way with dependencies and different multiplicities. Placeholders provide for customization of the documents. In one example template is a template for a word processing application spreadsheet application or other application that can be used for mass mailing via an output management function or to create reports via a spreadsheet application integrated with preconfigured content.

A document template as indicated at a document template node contains meta information such as type and description and template content. Elements located at the document template node are defined by data type DocumentTemplateElements and may include a UUID universally unique identifier for a document template a MIMECode that specifies the MIMECode for a document template a GroupCode that is a coded representation of a document template group according to their business content and VersionEnabledIndicator that indicates whether versioning has been enabled for the document template. These elements may be used to respond to queries to provide a list of all document templates that meet selection criteria specified by query elements.

Document template has further subordinate nodes such as a language variant and some language variant filter elements including a language variant schema name and description . These are identified as nodes in . Template is a simplified template illustrating only a language variant for one template. In further embodiments many different types of variants may be handled by the document template node structure.

Schema contains binding information which describes how placeholders in a document template are replaced by real business object data for a language variant of the document template . The elements located directly at the node Schema are defined by the data type DocumentTemplateSchemaElements. These elements may include a language independent name of the schema MainIndicator that specifies whether schema is the main schema. In one embodiment the schema MainIndicator can only be set for one schema. The main schema is the schema that is loaded first by an application which is responsible for placeholder substitution. Schema may also include a BinaryObject that describes the unstructured data in binary form.

Node name is a language dependent name of a document template . Elements located directly at the node Name are defined by the data type DocumentTemplateNameElements. These elements may include a name specifying the name of a document template. Node description provides a language dependent description of document template . The elements located directly at the node Description are defined by the data type DocumentTemplateDescriptionElements. These elements may include a description that specifies the description of the document template.

Node language variant is a language specific variant of a document template . The elements located directly at the node language variant may be defined by the data type DocumentTemplateLanguageVariantElements. These elements may be a UUID a VersionID that is a unique identifier of a document template variant and a SystemAdministrativeData that is stored in a system. In one embodiment CreationDateTime and LastChangeTime are relevant and used by the Template Language Variant. A LanguageCode may also be included that defines the language in which the Document Template Variant is specified a CountryCode defines the country for which the document template variant is specified and a RegionCode defines the region for which the document template variant is specified.

The following composition relationships to subordinate nodes include a language variant predecessor version node at and a language variant content node at .

From a business object identity node a last change identity identifies the identity that changed the language variant . A creation identity identifies the identity that created the language variant .

Language variant predecessor version is a list of all predecessing versions of a language variant . The elements located directly at the node language variant predecessor version may be defined by the data type DocumentTemplateLanguageVariantElements. These elements may include a UUID for a document template variant a versioned that is a unique identifier of a document template variant and SystemAdministrativeData that is administrative data that is stored in a system. CreationDateTime and LastChangeTime are relevant and may be used by the Template Language Variant. Further elements may include a LanguageCode that defines the language in which the Document Template Variant is specified a CountryCode that defines the country for which the document template variant is specified and a RegionCode that defines the region for which the document template variant is specified. From the business object document template node language variant language variant is an explicit version of a language variant.

In one embodiment language variant content is the binary content of the document template language variant. In one embodiment the node is provided due to potential large quantities of data the determination of which may have lead to performance problems. The elements located directly at the node Language Variant Content may be defined by the data type such as BinaryObject that describes the unstructured data in binary form. Such unstructured data has also been referred to as binary large objects or BLOBs and may include data such as image data.

In further embodiments many other attributes of the template may be defined. Such attributes may be added as additional metadata in one embodiment. Time dependency template is eventually valid for a period of time like a fiscal year or paper size as a print form might be designed only for A4 or Letter US are just a few examples of such attributes.

In one embodiment things directly influencing parameters may be included as attributes on the language variant or template header node which are in common for different kinds of templates. In yet further embodiments the attributes may be related to industry or layer ID which gives the opportunity to abstract from vendor specific industry solutions.

In one embodiment soft attributes may be included. Soft attributes are specific to a template type or business context stored in a kind of property bag attached to the template. For example papersize might only be applicable for print forms and therefore could go into such a property bag. The template infrastructure would still need to expose such soft attributes via query services by the application context using this templates e.g. to query for a template variant in papersize Letter US .

Design time system provides for scope selection at . In one embodiment scope selection provides a list of areas such as marketing sales after sales service procurement supply chain control financials etc. Each of these groups may be broken out into smaller groups. For example financials may be subdivided into general ledger which may be further subdivided into GL Accounts set of books etc. Other areas may also be listed.

When a customer selects one of the areas at a work item list of predefined templates for the customer is displayed. The list may be generated as a function of a customer profile that specifies the business objects of the customer that are available to that customer including templates from the business configuration objects. In this manner a customer will only see templates that may be needed based on the scope selection. At this point the customer may select one of the templates for use or may also select a template for further modification.

When the customer has selected a template or has modified an existing template decisions and changes are stored as indicated at storage and are provided to the server for storage at and use by the run time system . The decisions and changes are also provided to run time system via a storage . Run time system includes a test tenant and a production tenant . The decisions and changes are run through a run time checklist to ensure that they are valid for live operation and also through a production unit and a continuous change component which provides the modified templates back to the work item list for future selection by the customer. In one embodiment the moving of the templates from development objects to business configuration objects may be done with only very few changes in the runtime . The runtime is switched to retrieve from a new persistency the business configuration document template object but the complete output process in printing need not be fundamentally changed.

One result of the selection of a template or modifying a template is that the template may be associated with a business task. When that business task is next run during run time the associated template will be used obtained by the runtime and documents will be produced and mailed or sent to an outside mailing service to be mailed in one embodiment involving mass mailings. The runtime may utilize the schema associated with the content of the template and customize the appropriate placeholders. This is one approach which enables dynamically changing the schema to fetch other or more different data from business object models. A further approach involves the use of a development object defining the interface for data retrieval. Changing the development object may involve adaptation of a static interface and messages types. The schema in the latter case is just a proxy representation of the form message type where as in the first approach the schema is defining on its own how data is to be read.

In further embodiments a postal service may be utilized for the mailing or email or fax may be used. In still further embodiments an interactive form may be utilized that is sent to a supplier. It may be a purchase order in one embodiment. The business task may than retrieve the data from the form when it is returned and store the data. The use of a template for such tasks may simplify dealing with different message formats as it may include appropriate logic for interacting with the form.

A logical component view of handling document templates is illustrated in block form in . The components are divided into design time generally at and run time generally at . At design time template authoring may occur when a template is selected from a list of templates at that are listed under a particular selected scope such as an invoice template under a finances invoices scope. When an Excel based template is selected template authoring Excel at is selected to allow the customer to further customize the template. If it is so customized the changes will be stored and a new template reflecting those changes will be created and stored. Further authoring may be provided for Adobe based templates at and text template authoring at . The authoring blocks and may be integrated editors and the resulting templates are stored in fine tuning .

A business configuration block is used to deploy the template in the form of a business configuration object. As a business object the template includes business data that is exposed by one or more methods such as queries and other actions to use and manipulate the business data.

In runtime the templates are stored at and queries and services may be provided at on such templates. In some embodiments an additional layer may be provided which allows end user related templates which are not present in the designtime. This additional layer provides further flexibility.

An example of processing an Adobe formatted template is illustrated by ABAP forms processing block an Adobe document service block and a system template retrieval and pre processing block . These blocks provide rendering of the template and a callback into the runtime system when completed. The runtime also includes office integration business task management BTM and other system functions at .

The application screen quotes comparison is highlighted in the list at . A corresponding list of actual templates corresponding to this quotes comparison scope is shown at . The list at includes a first master template that is provided by the maker of the business management system. This master template may be available to all customers of the business management system but it should be noted that the master template may be designed for the particular scope quotes comparison in this embodiment. Following the master template are several customized templates. The templates each have an associated creator date of modification and a selection button to indicate whether the template is to be included as an available template for that scope. This provides the ability to present an uncluttered interface back in the business configuration screens allowing for easier navigation for users of the customer when setting up mass mailing or performing other tasks that utilize customized templates. For instance a template may be obsolete. By not setting that template as available it will not be mistakenly used. However it may still be retrieved to re create prior documents if desired.

In one embodiment an active flag may be used to indicate whether a template is available. One use for the active flag is to allow for resolving conflicting attribute combinations. A customer may decide which of eventually concurring variants should be the active one. This could happen if different ISVs ship the same templates for a given attribute context. Or if a new language is shipped and the customer already has created a language variant in a previous version.

The ability to abstract the schema or data structure from the user enables the user to focus on the format of the actual resulting documents as reflected in the template being edited. The template authoring user interface thus provides an editor which abstracts completely from the schema. Word based templates appear as flowing text and paragraphs. The resulting printed page of a document derived from the template is the result of the same flow of text.

In one embodiment a template authoring abstraction is provided. The templates are represented in XML format by the abstraction interfacing with the abstraction provided via requests from an Adobe type component Excel component text email component and InfoPath component . Other components may also be provided. The XML abstraction is provided to the template authoring UI such that a common set of editing functions may be provided for every template regardless of the original source of the template. The editing functions may be fairly limited to ensure that they operate on each type of template in the same way. For instance some templates may utilize a pixel based approach. It may not be easy in all cases to just convert between pixel and text formats.

In one embodiment the templates to select from at are provided from business configuration sets . Configuration data is bundled together in one embodiment to form a container of data. The templates are schema based as indicated at and may be built on top of a database table. A business configuration workspace holds business configuration data for one customer going through configuration. The modification of templates may be just one part of the configuration occurring. Constraints on branches of business processes may also be used to determine which business configuration sets are needed.

On completion of the business configuration efforts a request is made to a deployment engine in a run time environment and the templates are stored at for use when performing business management functions. Each modification of a template in design time leads to a new version of the template. In the run time the versions may be persisted separately. The run time can thus make the template or different versions of the templates accessible from applications. The desired template can be retrieve by a special identifier.

In one embodiment a template may have one or more schemas. These schemas may be associated with different message types such as one for printing or output one for VC visual composer and business object adaption which is a way to build views on business object models. The ability to have multiple schemas for a template removes prior limitations of using merges to obtain the different message types.

If output manager determines that the request is not for output service the request is routed to a template resolution component at . Template resolution component will find an appropriate template for use to perform the function that appears to be desired by a user. For instance a user may not know the exact template to use but does know that they want to print a purchase order in English. Using this information the template resolution component obtains the proper template and forms a request to either a FTG management component at or template management component at both corresponding to business object document templates.

In a further embodiment requests may be generated by a pattern user interface at . The requests may be to an output manager print preview component or an output manager export component . These components generate requests to a form generator . Form generator then makes requests to one or more other components. One such request may be made to a generic data provider component which in turn makes a request to outbound agent component . Form generator may also make a request to the template resolution component which handles such request in the same manner as request from output manager . In one embodiment form generator operating in a Java environment may make a request to a second renderer which also provides for abstraction of various different types of documents as indicated at . In non Java environments such requests may not be necessary. Renderer component may also make a request to a template preprocessor which can make a request to a common form configuration management component or to the template management component as desired. In a further embodiment the form abstraction component via an Adobe component may make a request to an adobe document server which also makes request to template preprocessor component .

The document template is viewed as a logical concept with a unique identifier. In one embodiment document template has a name which may be a short description visible to the user. The description may be language dependent and stored in a separate table. A description of the document template may be used to describe the purpose of the template and is visible during business configuration. This description may also be language dependent and stored in a separate table. For one logical template there may be variants for languages industries countries regions and versions as indicated at node . Some example variants are shown in table in . A variant may have an internal GUID which can be used to directly access the specific variant version. This may be useful for reprinting documents if needed. If some of the variants such as industry country etc. are not used by an application they can be left as empty or null. One template is persisted for each variant in one embodiment. In further embodiments a mime type such as XDP XLS plain text xhtml etc. may be provided in a variants node.

Table may be used by template resolution component in to find an appropriate template variant when a user does not uniquely specify the variant to use. Using information including context information about the user and the user request a best fit may be found in the table. If insufficient information is provided to uniquely identify a variant a fall back sequence may be used to revert back to the template having matching information deemed more important. This is easily done if the templates are hierarchically arranged. For example if language is not specified the fall back may be an English language persisted template or other predetermined language template.

Design may also include variant content such as a binary large object as indicated at node . In one embodiment a schema is provided at . As previously noted there may be more than one schema for each variant. All schemas may be related to a main schema root node shown. Each schema has a file name schema content and a main schema flag which is set if the schema is the main schema.

A query application programming interface API may be provided to provide several different queries. A GetAllTemplatesByTemplateContainer query may be used to retrieve all templates in a template container. It may be used to fill a dropdown list in a user interface so that the user can choose a specific template. A GetDefaultTemplateInTemplateContainer query may be used to retrieve a default template within a template container. In one embodiment a filtered association may be used in a query to retrieve a variant for a template starting from the root node of the template at . Language industry country region may be used as inputs and a variant ID is provided as an output. In one embodiment a version is not part of the filter association query interface. Versions may be retrieved directly for special use cases with an internal shortcut ID.

The exposed nodes may be generated from a runtime template store business object document template indicated at the same as shown at in . The template is translated into AP runtime schemas as indicated at document template schema template variants schema template schema and schemas . In one embodiment one schema is provided for each table in the schema node representation. Transformation rules may be applied to expose the design time schema and other nodes used during business configuration. Such transformation may transform the run time versions to provide an XML version fur such use.

The selection of option A results in a configuration workspace having multiple templates associated with a selected business configuration set loaded as indicated at and in a global fine tuning set . The loaded sets correspond to sets assigned to the selected options.

Fine tuning may occur where a customer starts fine tuning via a fine tuning context this is assigned to a fine tuning relevant option. Context allows a customer to select templates. An application specific business configuration view will thus select templates from the workspace . From the view a customer can check and change the configuration data. A delta of the configuration made by the customer may be saved in the global fine tuning set.

In one embodiment application specific business configuration view includes a template business configuration reuse user interface as indicated at in . A global fine tuning set is indicated at and comprises a representation of templates by business configuration set and template group. The templates are stored in an abstract format to allow invoking of a correct editor.

In one embodiment reuse user interface is invoked with a template group as a context filter for the global fine tuning set in the business configuration workspace . The templates selected by this context may be displayed in the reuse user interface . If a template is added anew it exists in the business configuration template reuse user interface . It may still not be persisted in the business configuration workspace . Therefore the user interface offers a function to send a notification after something has changed along with the current ids and template names. When the business configuration view data is saved it also invokes a save on the business configuration template reuse user interface.

Template content may be content of a runtime schema so it is not part of a business configuration schema. The reuse user interface will have to deal with two separate schemas internally in addition to the schema of the surrounding application business configuration view. In one embodiment for transaction reasons all content for the reuse user interface may be stored in a separate buffer within the reuse user interface because multiple business configuration sets of the two schemas could be manipulated and potentially re changed. Such sets may be managed via hashed object lists in one embodiment.

The surrounding business configuration view may call a save function for its content and than call save in the reuse user interface and afterwards may call a do save to commit the changes to ensure that all changes are stored at the same time. In one embodiment the reuse user interface provides the information if unsaved data is available and the surrounding business configuration view can ask the user if save should be applied.

In further embodiments a cancel request results in a reversion back of the changes and initializes the reuse user interface again from the workspace global fine tuning content. In one embodiment XML template descriptions may be compressed prior to saving.

A template authoring architecture is shown generally at in . The architecture invokes editors for authoring templates as well as editing existing templates using plug ins corresponding to the native editor for the template being edited. An application business configuration view includes the template business configuration reuse user interface that may be used to invoke a modal dialog at so that a wrapper is provided for each template to be edited. The modal dialog launches a server page such as a Java server page JSP at with a universal resource locator URL plus SSO single sign on . At authoring is invoked through a host such as by ActiveX type controls. Such controls allow developers to create software components that perform a particular function or a set of functions. Software may encapsulate functionality as controls so that the functionality can be embedded in other applications such as on web pages. In further embodiments editing functions may be seamlessly integrated in a host application.

Several different authoring abstractions are provided for native programs such as Adobe Designer Excel and many word processing programs indicated at and respectively. Data from the authoring abstraction may be passed back to the JSP page at and may be temporarily stored at a temp store at . A returned storage ID may be provided by the temp store as indicated at . A portal event may be invoked as indicated at from JSP page and the dialog may be closed as indicated at . Template business configuration reuse user interface may access the temp store to retrieve data corresponding to the edited template. A save may be invoked at and the template business configuration set data may be saved to configuration workspace . In embodiments where communication is permitted back and forth between external components direct back eventing or notification to the main and original application user interface may be used in place of the temp store .

In one embodiment template authoring as illustrated at is a business configuration view reuse plug in which may be plugged into an existing business configuration view. There are at least three modes for different use cases. In a first mode a list reuse user interface illustrated at in provides a list of templates within a container or a fixed passed list of template ids is provided. An overview of the templates may be provided in the list mode user interface and templates or language versions may be edited added or deleted as indicated at and respectively. Different regions and industry variants of the templates may also be added or deleted in various embodiments. A language selector is provided in one embodiment along with region and industry selector lists from which template variants and context attributes may be selected.

In a further embodiment a single view mode of one template instance may be provided to support BTM cases fax cover letters for output management or other situations where a list of templates is not required but the application context knows already of one template. In a third mode a list of template and single edit details for text support is provided. Multiple templates in a template group may be listed to allow in place editing. In these different modes blank templates may be provided for copying and schema storage. Existing templates may be edited and stored as variants or as new templates.

In one embodiment the business configuration template authoring architecture or framework TAF provides a mechanism to register plug in authoring user interfaces for specific mime types. The plug ins may contain controls such as ActiveX controls to embed native design tools such as Adobe Designer Excel Word etc. For a plug in TAF provides a base implementation with functions to invoke modal dialog with parameters from the generic TAF business configuration view to pass templates schemas etc. Further communications back to the generic TAF business configuration view are provided via events to pass changes to templates and schemas back. In one embodiment the functions are JSP based allowing the use of such controls.

Template authoring using Adobe plug ins inherits from the TAF plug in base implementation. Multiple schema files may be passed to the Adobe Designer and hook in to close save of the Adobe Designer to return changed templates. With respect to template authoring using Excel uploads and downloads in the generic TAF business configuration view are provided. Automation of Excel is similar to the Adobe TAF plug in as is automation of text based editors such as Word.

Templates use schemas which may be considered as binding information which describes how placeholders in a document template are replaced by real business object data for a language variant of the document template. The schemas take into account the organization of the database and identify how to retrieve data for the placeholders. In one embodiment the data is stored in business objects in a backend that utilizes multi node hierarchical deep schemas to identify fields in a database. The deep schema is hierarchical in nature and works well at the database level to access data. However when creating templates in a design time environment such deep schemas are not conducive to being easily understood by users and also may have structures which vary with different database implementations.

In one embodiment a schema transformation is utilized to convert from the deep schema to a flat schema and back. The flat schema may be used in the design time environment while the deep schema remains intact for the database or what is referred to as the back end of a business management system. An example of a schema builder that provides schema transformations is illustrated in block form at in . A read service and a write service are used to read and write data to and from a backend database. The read and write services and work with deep schemas as indicated at actions such as response request and confirmation . In one embodiment a root level node has three next levels A B and C. Node C has three further nodes at yet a further level labeled a b and c. Thus the deep schema structure in this simple example has three levels a root and two deeper levels.

Several XML transformation modules and are coupled to the actions for providing transformation back and forth between a flat schema representation and the deep schema structures. The transformation modules are labeled as XSLT Extensible Stylesheet Language Transformation modules and operate to track the path in the original deep schema and exposes a as belonging to C and is a sub element. Thus when a deep schema is transformed to a flat schema meta data is tracked to expand the flat schema back out to the deep schema. The flat schema may be easily converted to an XML map as indicated at and to various other formats for use in editors such as a spreadsheet allowing users to view the data in a very user friendly manner and as a resulting document produced from a template may appear.

In one embodiment response action interfaces with read service to retrieve data from a database using a deep schema. The data is then transformed at to the flat schema. Similarly when a write request is processed the flat schema is transformed into the deep schema at and upon confirmation by the write service the deep schema is transformed back into the flat schema at .

Schema builder operates to build a simplified flat schema out of a potentially complex enterprise service repository business object model for use in design time. Such complex object models can be very difficult to comprehend by ordinary users. Vertical schema reduction allows the inclusion or exclusion of associations nodes and data structures of the complex object model while keeping track of metadata to enable conversion back and forth. In one embodiment the data is pushed up to consolidate all the levels on a single node level. A horizontal schema reduction allows the simplification of complex nested structures. The results of the schema transformations may be provided as re usable net components in one embodiment. Hooks may also be provided for applications to enrich schema nodes with custom markups. The generated schemas may be used by a generic data provider to retrieve business object instances at run time.

A schema building process is illustrated in flow chart form at in . At a business object model is selected. In one embodiment the business object structure is visualized illustrating internal and external associations to enhance the visual representation at . A top level of the data structure definition of the business object nodes may be included in the visual representation. Nodes may be selected for inclusion at . As indicated in in vertical schema building each node of the visual representation of a business object node is associated with a checkbox. Only checked nodes are included in the custom schema in one embodiment. With respect to horizontal schema building nested complex structures may be collapsed by virtually inserting them at a higher level of the business object structure as indicated at . Such an operation is also indicated at request in . Cardinality constraints may be automatically enforced. Meta data is kept as indicated at to identify where data was in the original deep schema tree structure. The schema building process assists in optimization and providing a simplified view of the data.

In one embodiment XSD XML schema definitions annotations are used to deliver the transformation. Other notations such as SAP notations may be used to mark the transformations as indicated in at and at which are example schema definitions. The transformation may be generated at run time. In further embodiments a creator of the schema may mark the transformation. For simple scenarios such mark ups may be considered in normal services such as read and write services and respectively in .

In at an element Customer is shown for a flat to deep transformation. A root in a target is identified at and a destination element is indicated at at the same level as the root. In at an element Telephone1 is shown for a flat to deep transformation to A which is a child node of Telephone. The destination which may be at a different level is identified at .

The Abstract is provided to comply with 37 C.F.R. 1.72 b to allow the reader to quickly ascertain the nature and gist of the technical disclosure. The Abstract is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims.

