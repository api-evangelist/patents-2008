---

title: Navigating a software project respository
abstract: A system for analyzing a document in a repository is provided. The system receives a document that includes data and a document type. The document type has an associated physical structure. The system determines a logical structure of the document based in part on the data and selects a subset of the data based on at least one of the group including the associated physical structure and the logical structure. The system also stores a document segment that includes the selected subset of the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07853556&OS=07853556&RS=07853556
owner: Accenture Global Services Limited
number: 07853556
owner_city: Dublin
owner_country: IE
publication_date: 20080502
---
The present patent document is a divisional of application Ser. No. 10 661 805 filed Sep. 12 2003 now U.S. Pat. No. 7 383 269 which is incorporated herein in its entirety by this reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. The following notice applies to any software and data as described below and in the drawings hereto Copyright 2003 Accenture All Rights Reserved.

The present invention relates generally to an improved method for organizing and presenting complex detailed information stored in electronic form. The invention may find particular use in organizations that have a need to manage large repositories of documents containing related information. Typically such organizations require changes in one document to be reflected in other related documents.

Many complex projects for example software development drug development and clinical trials product development and testing etc. involve the management of large heterogeneous document repositories. These repositories may contain thousands of documents of various types text spreadsheets presentations diagrams programming code ad hoc databases etc that have been created during different phases of the project lifecycle. Although the documents may be related to each other the fact that they are of different formats and created during different phases of the project lifecycle makes it difficult to uncover the inter relationships among the documents.

For a software project a document repository may contain documents created throughout the project lifecycle. A typical software project lifecycle may be divided into at least four stages. First project requirements are defined. The requirements relate to project goals capabilities and limitations of the software system which the software project is to implement. Second designs are built around the requirements. Design specifications form a plan for actually implementing a system which achieves the requirements previously defined. Next the software code is written to reflect the design. Finally testing is performed to verify the execution of the code and to determine if the requirements and design specifications are incorporated into the final application.

Therefore the documents in the software project repository may detail project requirements design criteria programming code test data defect reports code review reports and the like. Furthermore these documents are typically of varying types such as the document types described above. Although many of these documents are inter related the size and heterogeneity of a typical repository make it difficult to find these inter relationships. Technical problems also arise when attempting to find these inter relationships across various types of files. In other words typical document repositories do not allow for a high level of traceability.

Traceability is important to software project managers for two reasons. First traceability allows a development team to quickly and easily perform impact analysis. Impact analysis is the process of determining which additional documents may be affected by a change in a given document. Second traceability allows the project team to perform coverage analysis. Coverage analysis is the process of verifying that the design specification implements the project requirements and that the code in turn implements the design specification.

A lack of traceability leads to two types of business problems. One problem is poor software quality. This problem may occur because developers cannot easily determine if the software fulfills all requirements and has been tested against all test conditions or because the repository contains incompatible versions of requirements design code etc as the project evolves. A second problem is increased time and effort as the developers must manually determine the interrelations among documents.

Maintaining a consistent software project repository is a critical and well researched problem in software engineering. In the past systems have been created that allow developers in a large software project to manually create the inter relationships among the various elements in the project repository. These commercial software development systems Integrated Development Environments or IDEs provide facilities for manually linking related items in the repository via explicit references. However such an approach is not feasible in many cases for the following reasons First it is very time consuming. A typical repository may have thousands of documents each covering multiple topics. Manually creating each link can cost a considerable number of man hours. Second a large software project may involve multiple teams each focusing on different aspects of the project. For example one team may determine the project requirements another team may create the design specifications a third team may build the code a fourth team may develop test scripts and a fifth team may perform testing and quality assurance. These teams may be working in different locations and may be affiliated with different companies. When creating a link in the code the code builder may not realize the complete extent of his or her involvement in relation to the other teams. Thus relevant links may never be created. Third manually creating references causes the links to be brittle. Although a link may be accurate when created later changes in the requirements or design specifications may create a need for new links or render old links dead. Fourth many large software projects evolve over a period of time with new functions built over much older legacy components and technologies. In such cases a manual process is infeasible as there are few or no individuals who have a working knowledge of the older legacy components.

A second approach to maintaining a consistent software project repository has been to enforce a rigid development process and a rigid repository structure. While such an approach is applicable for a single team building the software system from start to finish under a single development methodology it is impractical when the above team dynamics are present or when legacy systems are linked to current development projects. The present invention provides a robust technique for automatically discovering inter relationships among the various elements in a large software repository that may contain thousands of documents of different formats created at various stages of the project lifecycle.

In one embodiment a system including a document repository is provided. The system determines automatically a level of similarity between at least two of a plurality of discrete elements stored in the document repository. The system then stores data representative of a link between the elements based in part on the level of similarity.

In another embodiment a system including a document repository is provided. The system determines a relationship between documents by retrieving a plurality of documents from a document repository. The system segments at least two documents of the plurality of documents into a plurality of conceptually meaningful segments. The system determines if a segment of one document is related to a segment of another document and stores data representative of the relationship.

In a third embodiment system for analyzing a document is provided. The system receives a document that includes data and a document type. The document type has an associated physical structure. The system determines a logical structure of the document based in part on the data and selects a subset of the data based on at least one of the group including the associated physical structure and the logical structure. The system also stores a document segment that includes the selected subset of the data.

These and other embodiments and aspects of the invention are described with reference to the noted Figures and the below detailed description of the preferred embodiments.

Referring now to the drawings and particularly to there is shown an embodiment of a back end system for a repository navigation tool in accordance with the present invention. While the preferred embodiments disclosed herein contemplate a software development project and the documents created therein the present invention is equally applicable to any document files created during the course of any project that has similar characteristics including multiple teams multiple phases and a large volume of documents and interrelationships among those documents to manage. Examples of such projects include software development drug development and clinical trials product development and testing managing a complex branding and marketing campaign etc.

The back end system in the embodiment of includes an extraction tool a classification tool a segmentation tool and a linking tool . The extraction tool extracts relevant files from a plurality of project repositories and . Optionally the extraction tool may store the extracted files in a file store or other temporary storage means. Optionally the classification tool may classify the documents according to one or more predetermined categories. Once relevant files are extracted the segmentation tool segments the files into one or more segments. Finally the linking tool is provided to analyze the segments for inter relationships. The linking tool may store this information about segment inter relationships in a link repository .

In one embodiment a plurality of project repositories and are provided. As stated above each repository may contain thousands of documents of various types text spreadsheets presentations diagrams ad hoc databases programming code etc that have been created during different phases of a project lifecycle. In the embodiment of each repository and may contain documents of any type created during any stage of a project. A repository may also include files not created during a project lifecycle. It should be apparent to one of ordinary skill in the art that other repository structures are contemplated by the present invention. For example one repository may be provided containing every document to be analyzed. In other embodiments a plurality of repositories may be provided where each repository may contain only documents of certain types created during certain phases of the project or created at a certain geographical location.

The extraction tool extracts relevant files from the various project repositories and . In one embodiment each repository has an associated repository type. The repository type defines the structure of the repository such as the underlying directory structure for the repository. Additionally the repository may be a simple repository consisting of a single directory or a complex repository that may store metadata associated with each file kept in the repository. In one embodiment the extraction tool connects to each of the repositories and through repository adapters and . An adapter acts as an Application Programming Interface or API to the repository. For complex repositories the repository adapter may allow for the extraction of metadata associated with the document.

A typical software project may involve requirements documents that are usually formatted text files that may be stored in a file structure design and programming code may be stored within an Integrated Development Environment IDE such as Visual Source Safe produced by Microsoft Corporation test data may be stored within a test data management system such as Test Director produced by Mercury Interactive corporation defect reports and change requests may be stored in a change tracking system such as Clear Quest by Rational Software Corporation . Although each of these systems constitutes a physically separate repository the information in each repository has strong interrelationships to information in others. The repository adapters are interfaces to each physical repository that enables the extraction tool to obtain the files and other meta data from each physical repository and treat them as a single logical repository .

Optionally the extraction tool may include various parameters used to determine whether a document is relevant. These parameters may be predefined or configurable by a user. For example a user may configure the extraction tool to only extract files from specified directories. It should be apparent to one of ordinary skill in the art that many other relevance parameters for example only certain file types or only files that have changed after a certain date are contemplated by the present invention.

Referring now to one embodiment of the classification tool is described in more detail. In the illustrated embodiment the classification tool implements several operational stages including a storage hierarchy analyzer document name analyzer and document category analyzer . First the classification tool analyzes the structure of the various repositories and at the storage hierarchy analyzer . Then the classification tool analyzes the name of the particular document being classified at the name analyzer . The document is then classified as belonging to one of a plurality of categories of documents according to classification heuristics at the document category analyzer . In the embodiment of exemplary categories include documents relating to requirements design specifications source code testing defects outstanding issues and additional requests.

As stated above the repositories and may be simple or complex and may be used to store only certain types of documents. A particular repository or particular directories in a repository used to store particular documents is known as a rigidly structured repository. Preferably the repositories and are rigidly structured. The use of rigidly structured repositories reduces the number of assumptions made by the classification tool . For example if all documents of a particular category are only stored in one repository the classification tool will only classify documents in that repository as belonging to that category. Similarly the classification tool will more consistently categorize documents when strict document naming conventions are used. For example category codes may be embedded into the name of a document.

Referring now to the segmentation tool is described in more detail. The segmentation tool analyzes the structure of the extracted documents and isolates conceptually meaningful segments in the document at box . Then the extraction tool creates segments and for further analysis. Segmentation is the process of analyzing the structure of the extracted documents and breaking it into conceptually meaningful segments . The term conceptually meaningful segment as used herein refers to a subset of information in a document that is grouped together in some way and is well delineated from surrounding information signaling the author s intent to communicate to a reader that the subset is a single discrete piece information. For example a requirements document may use a series of Sections with numbers and titles to record each discrete requirement a document containing test data may use rows or columns in a spreadsheet to represent discrete test conditions or test scripts design of different subsystems may be represented as individual slides of a presentation document. Real world documents may also contain many other features to organize a document into discrete conceptually meaningful pieces of text. These features may include for example hierarchically organized chapters and sections sidebars embedded tables and so on 

As stated above each document in the various repositories has an associated type. The type of document is determined in one embodiment by the program used to create the document . For example a document may be created by Microsoft Word provided by Microsoft Corporation of Redmond Wash. Each document created by Microsoft Word contains the same physical structure or format. Each Word document also contains a collection of metadata detailing various properties of the document for example the author of the document creation date and other editing information. In other embodiments or using other types of documents the type of the document may be defined differently.

Each document also contains data elements such as text characters embedded images formulas and the like. These data elements define the content of the document . For example a document created by Microsoft Word may contain textual characters forming three sections. The first section may discuss topic A the second section may discuss topic B and the third section may discuss topic C.

The structure of a document is determined at box by analyzing the document type the data elements or both. Referring to the example above the document created by Word will have a standard format structure common to all documents created by Word and a three section structure determined by the data elements. In one embodiment the segmentation tool will create three segments to reflect this structure. The structure of other types of document may be attributable solely to that document s type. For example a presentation document may be segmented by pages or slides or a database file by individual records.

The segmentation process is now illustrated using an example document shown in Table 1. This document titled Requirements for a Loan Servicing Application is formatted using Microsoft Word a word processing application developed by Microsoft Corporation of Redmond Wash. . The segmentation tool accesses the document from the logical repository . It first determines the document s file type as corresponding to that of Microsoft Word. Next it uses Component Object Model COM Interface APIs for Microsoft Word to access the content and structure of the document. The tool retrieves the document s paragraph collection using the Document.GetParagraphs method. Each paragraph in the collection is then accessed using the Paragraphs.Item method and its relation to the outline structure of the document is determined by the Paragraph.GetOutlineLevel method. The segmentation tool now analyses the data from all of the paragraphs to determine that the outline consists of a document title and three sections each section consisting of a section title and associated text. The segmentation tool now concludes that the document contains three conceptually meaningful segments each segment consisting of the section title and the section body. In one embodiment the segmentation tool stores each of these segments as a text file that contains the overall document title the section title and the text in the section body.

It should be apparent to one of ordinary skill in the art that more complex document analysis is contemplated by the present invention. For example a document may be structured into five sections each of which has several subsections. The segmentation tool may be configured to create a segment for each section or subsection of the document . The structure of other types of document may be attributable solely to that document s type. For example a presentation document may be segmented by pages or slides or a database file by individual records.

The process of segmentation is crucial for linking related pieces of information within a project repository. Since individual documents may be large and contain many discrete pieces of information large documents will typically have some relationship to most other documents in the repository. In the worst case a repository containing mostly large documents will exhibit relationships among every document. The process of segmentation isolates discrete pieces of information within a document so that only related pieces of information from different documents are linked to each other. This increases the specificity of the links and makes the links more accurate and useful for traceability and impact analyses.

Preferably all documents in the repositories and are created using document templates. Templates are document files with a preset format. Templates help the performance of the segmentation tool by eliminating some uncertainty for the segmentation process. Where templates are used to create a document the determination of a conceptually meaningful segment is more consistent. Templates allow the segmentation tool to make assumptions about the document that may not always be determined by analysis of the document type and data elements alone. For example a requirements template may provide a table in which each requirement is represented as a row. In such a case every row in a requirement document that uses the template constitutes a separate segment.

In one embodiment the segmentation tool analyzes the documents through a document adapter. The document adapter acts as an API for a particular type of document and facilitates the extraction of that document s data elements. For example an adapter for Microsoft PowerPoint produced by Microsoft Corporation uses the published API to access information within PowerPoint documents. The API consists of a set of Component Object Model COM interfaces that can be instantiated and queried to retrieve sets of slides figures shapes and text. The adapter uses these COM objects to retrieve the collection of slides in the presentation. From that collection individual slides can then be analyzed. On a given slide text within shapes or other embedded figures is extracted from the document using the appropriate interfaces. For instance the Shape.GetTextFrame method returns the interface to a frame containing text. The TextFrame.GetTextRange method returns a range of text and the TextRange.GetText method returns the actual text contained within the shape. In this embodiment the adapter treats individual slides as conceptually meaningful segments. Another exemplary adapter for Java code performs simple textual parsing of code documents and extracts class dependencies methods variables and developer comments creating conceptually meaningful segments from individual classes.

Referring now to one embodiment of the linking tool is described in more detail. It is preferred that linking tool performs cosine similarity analysis on the segments. However it should be apparent to one of ordinary skill in the art that any alternate method of similarity analysis is contemplated by the present invention such as KL Kullback Leibler divergence Jaccard similarity Euclidean similarity Dice coefficients and Information theoretic similarity.

After the documents have been segmented the linking tool automatically determines relationships between the segments. In the embodiment of the linking tool includes a term extractor a frequency table a vector mapping function and a confidence filter . The term extractor extracts all terms simple words as well as complex hyphenated words except stopwords from a segment. Words that do not differentiate documents or that do not identify the information in a document are known as stopwords and include commonly occurring English words such as the and or but and so forth. The term extractor generates a list of segments and a list of terms . The list of terms defines the vocabulary. In some embodiments term extraction may be performed by an open source program. Once the segment list and the term list are complete the frequency table is created. The frequency table contains information representative of the number of times each term is found in each segment.

Once the tables and have been created vectors are mapped onto an n dimensional coordinate system by the vector mapping function where n represents the vocabulary. A vector is created for each segment. The magnitude of each vector in a given direction m is determined by the frequency of that particular term m within the corresponding segment. The cosine of the angle between two vectors representing two segments determines the similarity between the two segments. The smaller the angle between the two vectors and hence the larger the cosine the more similar the segments. Two segments are considered identical if the angle between their vectors is 0 or the cosine is 1 . Two segments that have no common terms have an angle of 90 or cosine of 0. Cosines of the angles are calculated between every pair wise combination of vectors. In one embodiment the values of these cosines are stored in a cosine table.

The confidence filter is then applied. The confidence filter acts to eliminate the statistically insignificant results. In one embodiment the confidence filter will eliminate entries that do not meet a threshold value. Optionally the confidence filter may include parameters that define threshold values. These parameters may be predefined or user configurable. If the cosine of the angle between two vectors exceeds the threshold the corresponding segments are deemed related and data representative of a link between the two segments is stored in a link repository .

Referring now to an exemplary physical architecture for a front end system in accordance with the present invention is shown. The architecture includes a database a file store a web server an internet or intranet and a web browser . In this embodiment the database contains the table of links generated by the back end system of and the file store contains the documents extracted from the various repositories and documents comprising a user interface for the front end system. The web server is configured to make the database and the file store accessible via the Internet or a corporate intranet . Users wishing to access the front end system can do so by opening a web browser and accessing it through the Internet or a corporate Intranet .

Referring now to it shows an exemplary logical architecture for a front end system in accordance with the embodiment of . As discussed above users access the system by loading various documents in a web browser . In the embodiment of the navigator host page acts as an HTML container for the navigator applet . Preferably the navigator applet is a Java applet downloaded by a user and run from the web browser . The navigator applet acts as a user interface for the back end system of . The navigator applet provides access to the linked documents provides search capabilities and presents the results to the user. In other embodiments the capabilities of the navigator applet are incorporated into other types of web accessible documents or programs such as HTML documents ASP documents and the like.

Once a user selects a particular document the navigator applet displays the segments linked to the selected segment by calling the Get Related Nodes Servlet . As known in the art a servlet is a Java application that runs in a Web server or application server and provides server side processing. The Get Related Nodes Servlet queries the database which stores the automatically determined links between the various segments and information tracking the document from which each segment was extracted. Once the necessary information is retrieved from the database the Get Related Nodes Servlet sends the information to the navigator applet which displays the results to the user. The interface of the navigator applet is discussed in more detail below in reference to .

The navigator applet also allow a user to search for documents by search terms or browse through the directory structure of a repository and select a specific document. A user accesses the search tool to search for a document by keyword. The search page collects search terms from the user and calls the SearchResults servlet . The SearchResults servlet queries the database based on the collected search terms. The results are then passed to a Results Renderer component which generates an html list of the results and sends this document to the user s web browser.

Similarly a user accesses the browse tool to browse a repository for a document. The browse tool allows a user to access the file structure of a repository. The user then selects a document from the repository. Once a document is selected the BrowseResults servlet is called. The BrowseResult servlet then queries the database for documents related to the selected document. Once again the results of the query are passed to the Results Renderer component which generates an html list of the results and sends this document to the user s web browser. The interface for these features will be discussed below in reference to .

Referring now to an exemplary screen shot for an embodiment of a keyword search tool for the embodiment of is shown. The search tool includes a text box a search button checkboxes and results window . A user enters keywords into the text box and activates the search button to begin the search. Optionally a user may limit the search to certain categories of documents by selecting the appropriate checkbox . Once the search button is activated the SearchResults servlet is invoked as discussed above. The results of the search are then displayed in results window as a list of segments and the documents that contain them. Each segment listed is capable of being activated.

Referring now to an exemplary screen shot for an embodiment of a results page for the embodiment of is shown. The results page displays the segments related to an activated segment. Upon activating a segment from the results window the results page is displayed. In the embodiment of the results page includes nine windows. The selected segment is displayed in the center window. The remaining eight windows are used to display related segments classified under a particular category . In other embodiments the number of windows is adjusted so that a window exists for each document category.

In one embodiment related segments are displayed by document name. Where multiple related segments have been extracted from a single document it may appear as if the same related segment is being displayed multiple times. In other embodiments a segment identifier may be displayed to differentiate between related segments extracted from the same document. Optionally the calculated similarity of each related segment to the selected segment may be displayed. Where the total number of related segments in a category exceeds the size of a window navigation buttons may be provided to allow a user to scroll through the list of related segments . Each related segment is capable of being activated. Upon activation the activated related segment is displayed in the center window the database is queried for those segments related to the activated related segment and the results are displayed accordingly. Additionally navigation buttons may be provided to allow a user to revisit previously activated segments and jump to a predetermined start page.

Referring now to an exemplary screen shot for an embodiment of a directory browser tool for the embodiment of is shown. The directory browser tool includes a browse window a search tool access link and a results window . The browse window displays the directory structure for a particular repository. A user can navigate through the directory and select a document. Once selected the segments of that document are displayed in the results window . Optionally a link may be provided to allow a user to access the search tool . As above each segment is capable of being activated. Upon activation the segment is displayed in the results page as described above.

From the foregoing it can be seen that the embodiments disclosed herein provide an improved system and method for navigating a document repository in order to perform impact and coverage analysis. This system and method are particularly well adapted to situations where multiple teams located at various locations are working on a single project. The process of determining inter relationships among the documents is automated so that even in a project in which documents are created by multiple teams that do not employ consistent naming or storage conventions the process can proceed without substantial involvement by technically trained personnel. The disclosed system discovers inter relationships among the various elements in the repository and displays these relationships in an easy to use web page which may readily be operated by non technical individuals. As a result manually defined links among documents and the programmers required to create these links are obviated. This substantially reduces the cost and time required for performing impact and coverage analysis.

It is therefore intended that the foregoing detailed description be regarded as illustrative rather than limiting and that it be understood that it is the following claims including all equivalents that are intended to define the spirit and scope of this invention.

