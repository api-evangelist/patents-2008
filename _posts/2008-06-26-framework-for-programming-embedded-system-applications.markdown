---

title: Framework for programming embedded system applications
abstract: The disclosure describes a method for programming applications for embedded systems such as sensor nodes. In an embodiment, this comprises writing embedded system applications in a high-level language such as C# or Java using a software development framework which includes a set of tools and class libraries. The class libraries contain pre-written code to carry out tasks which may be required of an embedded system. The class libraries may be extended following identification of a need for a particular function in an embedded system. Developed applications may be subsequently stored on the embedded system but executed on a gateway computing device which interacts with the embedded system. This means that the application(s) can be executed without requiring the presence of a virtual execution system located on the embedded system while allowing a high-level programming model for application programmers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08661407&OS=08661407&RS=08661407
owner: Microsoft Corporation
number: 08661407
owner_city: Redmond
owner_country: US
publication_date: 20080626
---
An embedded system is an example of a specialized computer system which may be part of a larger system or machine. Embedded systems usually have limited resources such as memory and processing capability and are programmed with software to carry out one or a limited number of tasks. The software is typically written in low level languages like C C or domain specific languages. Programming in these languages requires a specialized skill set. One example of an embedded system is a sensor node. A sensor node has one or more sensors which is are capable of gathering information about the sensor node s environment. A sensor node may perform basic processing of this information or may supply the information to another computing device which may have greater processing capabilities.

The embodiments described below are not limited to implementations which solve any or all of the disadvantages of known embedded system application programming techniques.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

The disclosure describes a method for programming applications for embedded systems such as sensor nodes. In an embodiment this comprises writing embedded system applications in a high level language such as C or Java using a software development framework which includes a set of tools and class libraries. The class libraries contain pre written code to carry out tasks which may be required of an embedded system. The class libraries may be extended following identification of a need for a particular function in an embedded system. Developed applications may be subsequently stored on the embedded system but executed on a gateway computing device which interacts with the embedded system. This means that the application s can be executed without requiring the presence of a virtual execution system located on the embedded system while allowing a high level programming model for application programmers.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However the same or equivalent functions and sequences may be accomplished by different examples.

Although the present examples are described and illustrated herein as being implemented in a sensor node the system described is provided as an example and not a limitation. As those skilled in the art will appreciate the present examples are suitable for application in a variety of different types of embedded systems. In addition in the examples below wireless networks are used. However the present invention can also apply to embedded systems connected over wired connection such as Ethernet power line or other networks.

The term framework as used herein refers to a software development aid which provides a code library and a set of tools for guiding the software development process. The term embedded system as used herein refers to hardware components which are dedicated to performing one or limited computing task s . Embedded systems comprise a memory in which software which allows that or those computing tasks to be carried out is stored. The term gateway computing device is used to refer to a computing device which communicates with embedded systems.

In other examples programming computing device may also act as a gateway computing device and or the software application may not be stored on the embedded system the embedded system may for example instead supply information over the communication network to the gateway computing device about where the application is located for example by providing an IP address or the like. A number of different communication networks may be utilized.

The programming computing device has access to a framework which can be used by a programmer to simplify the development of an embedded system software application. This software application contains all the information necessary to allow the gateway computing device to interact with a specific embedded system and therefore the gateway computing device need not contain any software which is specific to that embedded system ab initio instead it simply has access to an execution environment arranged to retrieve and execute the software application received. As the software received by the gateway computing device can be executed thereon it can make use of the capabilities of the gateway computing device which may be superior to the capabilities of the embedded system .

An example of an embedded system is shown in and examples of computing devices are shown in . Processes of writing an embedded system software application using a framework are described in and . outlines an example of a method for extending a framework and a representation of the framework available on the programming computing device is shown in . shows an example of the process of executing an embedded system application on a gateway computing device .

The disclosure describes examples of methods and tools for exposing a high level programming model for embedded system applications and examples of methods for system integrators to access and extend a programming framework.

In this example the microcontroller operates TinyOS. As will be familiar to the skilled person TinyOS is an open source embedded operating system and platform for wireless sensor networks. TinyOS is written in the nesC Network Embedded Systems C programming language which is an extension of the programming language C. TinyOS is a popular OS for sensor nodes and other embedded systems but other examples may employ a different OS or employ a scheduler. In other examples the sensor node may run applications using a model that does not rely on an OS or a scheduler.

In other examples other computing based devices may act as a gateway computing device for example Personal Digital Assistants laptop or notebook computers PCs servers or the like. Gateway computing devices may communicate with embedded systems using any wired or wireless communication interfaces such as IEEE 802.15.4 Zigbee IEEE 802.11 or Ethernet. It is also possible that a backend computing device such as a server runs a browser which is capable of interacting with embedded systems and which provides an execution runtime and hosting environment for applications which may have been developed using the framework described below. A gateway computing device may forward communication packets from one or multiple embedded systems to the backend computing device.

The sensor node is a resource constrained device of the type where applications are typically implemented using low level languages such as C C or domain specific languages. However in the example now described the sensor node software applications are programmed in a high level language such as C or Java which will be more readily understood by programmers and which is arranged to be executed on a gateway computing device such as the mobile phone . Therefore the sensor node does not require a resource hungry virtual execution system. For the programmer the use of a high level language may offer an improved development experience. In addition the method may make use of a framework including class libraries and a set of tools to further simplify the programming process.

A process of writing an application for the sensor node using class libraries and a set of provided tools is now described with reference to the flow diagram of and the framework shown in . Such a sensor node application developed with a high level programming language is termed a senslet herein. As with an applet a senslet is designed to be executed from within an execution environment which in the example now described is provided by a gateway computing device . Rather than executed directly by the TinyOS operating system of the sensor node the senslet in this example is instead executed in the execution environment on the mobile phone and can utilize the resources of the mobile phone such as its screen and its network or processing capabilities.

In some examples described below system integrators expose functionalities of embedded systems by flagging functions in native code with metadata. This functionality is then exposed as one or more services and classes in a high level language are generated automatically for accessing this functionality from within the programming framework. This allows the framework to be developed and new embedded system application assemblies in a high level language to be generated.

With reference to in order to develop the senslet a programmer subscribes to a software framework block . This subscription may be for example a license to access the framework or may be a license to use software or some other form of subscription. An example of a framework is shown schematically in and is housed on a programming computing device such as the device shown in . This may be a server for example which the programmer can connect to via the internet or the like. In other examples the framework may be provided on a programmer s personal computer and the subscription may comprise use of the software providing the framework and in some examples receiving updates to the framework when these are available. As will be familiar to the skilled person software frameworks aid software development by providing a code library and a set of tools for guiding the software development process.

In this example the framework is based on the NET framework provided by Microsoft and is specific to senslets. The framework comprises a set of pre coded solutions to known computing problems which are stored in managed class libraries for example .NET class libraries. As with existing class libraries they simplify the work of the programmer who can use established pre tested code instead of having to write and test new code. The framework also comprises a software execution environment which provides a runtime and hosting environment in which applications are executed and which provides services such as security memory management and exception handling. The framework also comprises a binarizer the function of which is expanded upon hereinafter some extensibility support tools and a set of native senslet libraries . For the end application programmer these parts of the framework are sufficient for developing senslets if a senslet enabled sensor node is available to the programmer. System integrators and in some examples end application programmers can make use of tools and the native senslet libraries to develop sensor nodes which are capable of executing senslets. The native senslet libraries contain native support functionality for handling senslets on a sensor node and which are intended to be executed by the sensor node itself rather than being transmitted any executed on the gateway computing device . For example the native senslet libraries may comprise i low level communication support for transmitting senslets to a gateway computing device such as the mobile phone ii support for advertising the presence of senslets on a sensor node iii drivers for accessing basic sensors on a sensor node and iv simple senslet communication support.

The senslet framework class library includes software classes for carrying out core senslet tasks such as i communicating with sensor nodes which in this example takes place based on an event based interface for querying and retrieving sensory data or via a service based interface ii enabling discovery and description of the senslets and iii Graphical User Interface GUI support for senslets. Carrying out these tasks allows data which has been acquired by a sensor to be for example retrieved and displayed on the screen of the mobile phone . In this example the functionality is initially accessible from two classes which are called BasicSenslet and Senslet herein.

The programmer creates a new senslet by writing a new class that is based on the BasicSenslet or Senslet class. The methods Init Run and Exit can serve as entry points for a hosting process to control the execution of a senslet. The programmer may then add application specific code to this class.

The execution environment is arranged to execute senslets. It may be remotely accessible from a gateway computing device or provided on the gateway computing device as a separate application. It may be provided as part of the complete framework or independently from the other framework components. It may also be available to programmers to allow testing of senslets and the like.

The execution environment for executing senslets on a gateway computing device such as the mobile phone allows the application of security policies. A security policy could for example specify that a senslet may not allowed to access one or more of the gateway computing device s facilities. For example. The execution environment may be arranged to prohibit access to the mobile phone s cellular network connection perhaps to prevent unexpected cost in call charges to a user. Another example security policy could specify that a senslet is may not access the file system of the gateway computing device or limit the computing resources available to the senslet so as to prevent a senslet from monopolizing for example a processor of the gateway computing device . Alternatively or additionally to protecting the gateway computing device a security policy could specify for example that all data exchanged must be encrypted. The execution environment in this example is also responsible for discovering senslets and handling the senslet downloading process.

For example if the senslet has been downloaded onto the mobile phone the execution process calls Init to signal to the senslet that the senslet has now been loaded and is ready to start. If the senslet programmer decides so he or she can also make use of the Init method to notify a sensor node which provided the senslet that the senslet execution on the mobile phone is now about to start. The Run method contains the senslet application logic. The Exit method is called by the senslet execution environment to notify the senslet that its execution has been externally stopped. This can happen for example if the user of the mobile phone uses the user interface of the runtime and hosting environment to stop all running senslets. By receiving this signal the senslet can stop its execution in a controlled manner.

In this example the basic senslet class also comprises some low level functions as follows. The SendData method and the ReceiveData event are low level calls for sending and receiving data. SendData sends a number of bytes to the embedded system which provided the senslet and the ReceiveData event is called whenever new data is received. SendData and ReceiveData are low level calls that may be extended to higher level Application Programming Interfaces APIs .

Alternatively or additionally embedded systems and gateway computing devices hosting senslets may communicate using a service model for calling services provided by an embedded system and thus exchanging data as is set out in greater detail below.

The Senslet class is similar to the BasicSenslet class but additionally provides support for integrating Graphical User Interfaces GUIs into a senslet e.g. buttons scroll bars icons and windows. Because senslets are executed on a device other than a sensor node the senslets can exploit the GUI features or other capabilities of this gateway computing device to display sensory data for gathering user input as appropriate for carrying out computations for communicating data to a backend system making use of the communication interfaces of the hosting device or in some other way. As a GUI or other interface is available senslets may be event driven for example reacting to user inputs.

After the programmer has implemented a senslet block by making use of the classes in the senslet class libraries the next step is to compile the senslet with a compiler associated to the high level language used to program the senslet block . In this example C is used as a high level language for developing senslets and thus a C compiler is executed to compile the application developed by the programmer.

After the senslet has been compiled the next step is to utilize the binarizer block . The binarizer in this example makes use of the fact that a modern high level programming language has been used for developing embedded system applications. When writing programs in a modern high level language such as Java and .NET enabled languages compilers not only create pure object code as a result of a compilation process but also include extensions for example further so called metadata which describes the compiled code for example providing information about classes and structuring.

Using a process called reflection the binarizer evaluates a compiled senslet and extracts metadata about the senslets. As will be familiar to the skilled person reflection is a mechanism to access metadata in compiled software. As a result the binarizer generates a senslet description which can be used for example in a senslet discovery process to advertise the presence and the properties of a senslet.

By way of example if a senslet programmer assigned a public key to an element called m sensletDescriptor of the BasicSenslet class the BasicSenslet could be adapted by the programmer as follows in order to integrate the provided public key 

In the same way other properties of a senslet can be indicated directly by the application programmer. The senslet binarizer uses reflection to extract these values and to create a senslet description as a separate file. In this example the senslet description file is an XML file containing the properties of all the senslets processed by the binarizer . In this example the binarizer generates native code header files that contain a binarized version of the compiled senslet and of the senslet description block . In the example of a TinyOS node the binarizer generates nesC header files containing a binarized version of the senslets including of the extracted senslet description. The senslet description is later used in the process of discovering senslets on sensor nodes to allow a gateway computing device to obtain information about the senslets hosted on a sensor node without needing to download a senslet.

The compiled senslet and the senslet description are then stored as a senslet assembly on a sensor node . More generally speaking an embedded system application assembly is stored on an embedded system . There are a variety of ways to achieve this. In one example a sensor node is equipped with a separate flash memory chip. This is sometimes the case on sensor nodes which store large amounts of sensory data. In such an example the support tools comprise a tool for storing the senslet assembly in external flash memory. In another example the senslet assembly is stored in RAM for example if a sensor node has an insufficient amount of flash memory . As on some known sensor nodes the program flash memory on the sensor node s microcontroller may provide the only place that provides sufficient memory for storing senslets.

In this example where senslets are stored in the flash memory of the microcontroller the native sensor node application is recompiled including the generated nesC header files in the compilation process block . Over a linking process which includes accessing the native senslet libraries an embedded system image is created. This embedded system image can be uploaded to the sensor node block . An image is the byte sequence that is written to the microcontroller on the sensor node which specifies where which bytes are stored on that specific microcontroller . The image includes the result of the compilation process and of the linking and may be given in a specific format e.g. a hex file for a specific microcontroller .

In the above examples an end application programmer developed embedded system applications for highly resource constrained devices in a high level language. The application programmer used only managed code to write an embedded system application and did not have to deal with native embedded system programming for resource constrained platforms as it utilized native senslet libraries to deal with low level senslet support. The sensor node contained a senslet assembly which is intended to be transmitted to and executed on a more powerful computing device. The sensor node also contains native senslet support as provided by the senslet libraries that handle low level senslet tasks e.g. discovery and communication and sensor access on the sensor node in native code.

In some examples the framework may be extensible which may allow it to be used with a potentially unlimited variety of embedded systems . System integrators i.e. a person or entity which develops a new embedded system or extends an existing embedded system may take advantage of the framework extensibility. Given the example of a sensor node that is running TinyOS as an operating system a range of functionalities could be provided. Additional functionalities may fall into two classes 

 i new hardware on sensor nodes which was not initially foreseen. For example sensor nodes may be designed with customizable hardware e.g. new sensors or IO interfaces can be added.

 ii new services related to the proposed use of the sensor node e.g. new uses or processing of sensor data .

The framework provider will not be able to know in advance what functionality may be required for existing future sensor nodes and therefore will not support every possible function that could be carried out. For example the native senslet libraries and the senslet class libraries might contain the functionality for accessing temperature sensors but not for accessing light sensors. Additionally the framework provider will not be able to provide a priori every possible processing requirement for data retrieved from a sensor node . The framework provider can however respond to requests for the code and can enter the necessary code into the framework .

By way of example a healthcare application provider may develop a new sensor node for tracking the medical condition of patients after surgery by tracking their activity level. The system integrator adds an accelerometer to an existing sensor node for measuring the activity level of patients. The system integrator also might add native algorithms to the sensor node that derive the activity level of patients based on accelerometer readings. Once such a sensor node has been developed the system integrator may wish to ensure that the functionality can be readily utilized. One way to do this is by integrating new native functionality as implemented by the system integrator into the senslet framework . A process for achieving this is described below with reference to the sensor node of and the flow diagram of .

In this example a system integrator develops a new sensor node which is able to switch on and off its LED block . In order for this function to be executed by a senslet the framework is extended to include a new class as part of the senslet class libraries and native support for exposing the LED functionality to remotely executed senslets as follows.

The system integrator introduces metadata into the operating system or adds metadata to other pieces of native code block . As nesC is used for programming in this example metadata is indicated by the sign. Metadata is inserted into native code which is recompiled block . Triggered by this recompilation the extensibility support tools analyze the metadata provided in native code and generate a new native service that is exposed by the sensor node . This new service may then be used by a senslet when it is executed on a gateway computing device to make use of the new sensor node functionality. In order to allow end application programmers to access this functionality from native code a new C class that extends the senslet class library is also created. In this example the name of the new service is Leds .

As an example the LED functionality in TinyOS is now discussed in more detail. The Leds interface in TinyOS is as follows 

If it is assumed that the initial senslet framework did not expose this LED functionality a system integrator may add metadata to this interface. The metadata service and operation in the following example specify which functions ought to be exposed as a service and be made accessible for senslet programmers 

When the native code and in this example the OS as the Leds interface is part of the TinyOS operating system implementation is recompiled a corresponding service description is generated block . This is carried out by the extensibility support tools . Specifically the nesC compiler generates an XML file containing information about metadata. The extensibility support tools have a tool that parses this XML file analyzes the metadata tags added by the system integrator to the native code and generates a service description out of this. This service description can be sent to or retrieved by other systems. The tools generate service code from the metadata that exposes the operations redOn and redOff as a native service on the sensor node . Service models such as Web Services Microsoft s Decentralized Software Services DSS or other lightweight service models may be used to describe how data are represented and exchanged between devices. A senslet running on a gateway computing device may make use of these services. In the example above the OS is TinyOS but other in examples metadata data may be added to a different OS or to sensor code that does not use an OS.

Given the generated service description the extensibility support tools included in the senslet framework can generate a new class for the senslet class library block . This generated code is typically referred to as a stub by those skilled in the art. In this example the service description might use the Web Service Description Language WSDL for describing the service and for generating the stubs. However senslets may use other protocols for interacting with the native services provided by a sensor node possibly using more lightweight protocols.

In this example a lightweight service grounding is used within the stubs to communicate with sensor nodes in order to reduce the communication overhead when interacting with sensor nodes . As will be familiar to the skilled person a service grounding provides a specification of service access information building on WSDL by defining a message structure and a physical binding layer and specifying communication protocols transport mechanisms agent communication languages and the like. A lightweight service grounding has modest resource requirements. Sensor nodes typically do not support Simple Object Access Protocol SOAP or XML parsers which may be required by non lightweight services.

The generated public class Leds on off program for turning the red LED on and off in this example takes the form 

This class is then inserted into the framework as Leds block as is shown in . A senslet programmer can use this class in applications using C and the senslet class library to call native functionality i.e. in this example functionality of the LED on the sensor node from a senslet application as is now described with reference to the flow diagram of .

First the programmer writes a senslet for a sensor node and in this example the Run method of the senslet contains a reference to an object of the Leds class generated as described above and arranged to switch on the red LED block 

The Run method of a senslet is called by the execution environment after the senslet s Init method has been successfully completed. Therefore including reference to an object of the Leds class with the Run method allows the senslet programmer to make use of the generated class and to call the method redOn which in turn allows the programmer to transparently access the LED functionality on the sensor node . When the senslet is executed on a gateway computing device it will call new Leds .redOn which will switch on the red LED on the sensor node .

This new senslet is collected together with any other senslets to be stored on the sensor node block and these are processed by the programmer using the binarizer block . The binarizer uses reflection to identify all the senslets and extracts the properties from all of these senslets. Given the extracted properties the binarizer generates the senslet discovery descriptor and includes it with the senslets in an assembly block . Once the assembly has been installed on a sensor node the sensor node may advertise the presence of senslets by exchanging the discovery descriptor with other devices as is explained in greater detail below.

The senslet assembly including the generated discovery descriptor is stored on a sensor node as described above block . Therefore the programmer writes code in nesC compiles and links the program and transforms it into a file that can be deployed on a sensor node using binarizer to embed the assembly into a nesC header file.

The generated nesC header files are included in the compilation process of the application normally running on the sensor node block . When recompiling the original application the senslet assembly is therefore included in an image that is deployed on the sensor node . While it is possible to access services on a sensor node using the runtime environment which may be accessed by the browser on the mobile phone the services on the sensor node are provided in native code by the system integrator. As can be appreciated from the foregoing when the system integrator flags the OS interface with metadata the functionality of this interface may be automatically provided as a service. By use of the extensibility support tools there is relatively little overhead in running a function as a service for the system integrator. The service is implemented in native code on the sensor node . The senslet in this example contains the stubs for calling the service. When a senslet is transmitted to a gateway computing device such as a mobile phone the stubs are used from within the execution environment available on the mobile phone to call the services on the sensor node .

Service descriptions may contain a specification of the functional interfaces of services provided by a sensor node . If a sensor node exposes a description of its services these functional interfaces can be used to dynamically generate code in the framework and for generating new classes. In such examples rather than flagging an interface with the addition of metadata generating a service description therefrom and using the service description to generate a class which calls the service remotely the process can be automated. This may comprise querying a sensor node for the services it provides. The sensor node may return a set of service descriptions which can be utilized as above to generate the corresponding classes for the framework .

The process of utilizing a senslet is now briefly described with reference to the flow diagram of . Before a senslet is downloaded from a sensor node the mobile phone may search for available senslets block . In other examples a sensor node may search for execution environments senslets may already be known to gateway computing devices or may become known to gateway computing devices in some other way. The sensor node returns a description of the senslets including a name a human readable description and specific properties block . In this example this information is available without requiring download of the senslet. The screen displays the list of senslets and the user therefore can choose to execute one or more of these. If the user chooses to execute a senslet a request for that senslet is sent to the sensor node block . The sensor node returns the senslet block which is then executed within the browser providing access to an execution environment which is available on the mobile phone block . A more detailed description of the execution of senslets may be found in a co pending patent application Ser. No. 12 146 882 entitled Execution of Embedded Systems Applications which is incorporated herein by reference.

The computing based device comprises one or more inputs which are of any suitable type for receiving inputs such as an input from a sensor node or another embedded system . The device also comprises a communication interface for communicating with other entities such as other communications network nodes gateway computers or backend systems.

Computing based device also comprises one or more processors which may be microprocessors controllers or any other suitable type of processors for processing computing executable instructions to control the operation of the device in order to carry out the functions required to carry out the functions of a gateway computer or a backend device. Platform software comprising an operating system or any other suitable platform software may be provided at the computing based device to enable application software which may include software arranged to provide the framework and or the execution environment to be executed on the device .

The computer executable instructions may be provided using any computer readable media such as memory . The memory is of any suitable type such as random information memory RAM a disk storage device of any type such as a magnetic or optical storage device a hard disk drive or a CD DVD or other disc drive. Flash memory EPROM or EEPROM may also be used.

An output may also be provided such as an audio and or video output to a display system integral with or in communication with the computing based device . The display system may provide a graphical user interface or other user interface of any suitable type although this is not essential.

The term computer is used herein to refer to any device with processing capability such that it can execute instructions. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term computer includes PCs servers mobile telephones personal digital assistants and many other devices.

The methods described herein may be performed by software in machine readable form on a tangible storage medium. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order or simultaneously.

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Any range or device value given herein may be extended or altered without losing the effect sought as will be apparent to the skilled person.

It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to an item refers to one or more of those items.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. Additionally individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought.

The term comprising is used herein to mean including the method blocks or elements identified but that such blocks or elements do not comprise an exclusive list and a method or apparatus may contain additional blocks or elements.

It will be understood that the above description of a preferred embodiment is given by way of example only and that various modifications may be made by those skilled in the art. The above specification examples and data provide a complete description of the structure and use of exemplary embodiments of the invention. Although various embodiments of the invention have been described above with a certain degree of particularity or with reference to one or more individual embodiments those skilled in the art could make numerous alterations to the disclosed embodiments without departing from the spirit or scope of this invention.

