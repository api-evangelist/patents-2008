---

title: Method and system for a database to monitor and analyze performance of an electronic design
abstract: Various methods and apparatuses are described that provide instrumentation and analysis of an electronic design having one or more bus interconnects. A relational database may have defined tables designed for interconnect analysis of transactions occurring between initiator intellectual property (IP) cores and target IP cores of the electronic design. A query tool may be configured to format input data to be stored in the defined tables, and have application programming interfaces to retrieve data from the defined tables based on performing a query. The query tool executes an algorithm based on the query to provide the interconnect analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08073820&OS=08073820&RS=08073820
owner: Sonics, Inc.
number: 08073820
owner_city: Milpitas
owner_country: US
publication_date: 20080407
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the software engine and its modules as it appears in the Patent and Trademark Office Patent file or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the invention generally relate to electronic design automation. An aspect is related to monitoring and analyzing an electronic design with a hardware performance monitor.

Many electronic designs are written at a register transfer level RTL description of a circuit or system in a hardware description language. Generally a RTL description describes what intermediate information i.e. information stored between clock cycles in an electronic circuit is stored in registers where it is stored within the design and how that information moves through the design as it operates. The RTL description of an electronic design is a functional description at least one level of abstraction higher than the individual gate layout of the electronic design system e.g. gate level implementation Netlist . The RTL description fully and explicitly describes virtually all of the logic and sequential operations of the circuit. RTL descriptions are commonly written in standard languages such as Verilog or VHDL and are intended for logic synthesis and mapping with a commercial logic synthesizer.

One prior approach for performance analysis of an electronic design may include using a hardware performance monitor located at a fixed location in a processor which is located within the electronic design. The hardware performance monitor can be monitoring on chip in silicon or with a RTL description as described above. The hardware performance monitor has a limited number of fixed non configurable parameters to be monitored. These prior approaches are not able to quickly and efficiently monitor and analyze various parameters associated with electronic design performance early in the design cycle resulting in a longer design cycle and slower time to market for the design.

Various methods and apparatuses are described that provide instrumentation and analysis of an electronic design having one or more bus interconnects. A relational database may have defined tables designed for interconnect analysis of transactions occurring between initiator intellectual property IP cores and target IP cores of the electronic design. A query tool based front end may be configured to format input data to be stored in the defined tables and have application programming interfaces to retrieve data from the defined tables and execute an algorithm to perform the specific performance analysis requested by the query tool. The query tool may perform further analysis on the retrieved results as part of performance analysis.

While the invention is subject to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention.

In the following description numerous specific details are set forth such as examples of specific data signals named components connections etc. in order to provide a thorough understanding of the present invention. It will be apparent however to one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Further specific numeric references such as a first model may be made. However the specific numeric reference should not be interpreted as a literal sequential order but rather interpreted that the first model is different than a second model. Thus the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention.

In general various methods and apparatuses are described that provide instrumentation and analysis of an electronic design having one or more bus interconnects. A relational database may have defined tables designed for interconnect analysis of transactions occurring between initiator intellectual property IP cores and target IP cores of the electronic design. An application programming interface API suite is provided to format the input data to be stored in the tables and support a set of algorithms to enable the performance analysis of the interconnect. A front end query tool may invoke one or more APIs from the suite for performance analysis. Further the query tool may execute other algorithms based on the results obtained from the APIs for specific performance analysis requirements. The relational database has data derived from a first performance simulation of the interconnect being modeled with a first software model written in a first programming language having a first level of abstraction as well as data derived from a second performance simulation of the interconnect being modeled written in a hardware description language model having a second level of abstraction. In one embodiment the performance data of the interconnect between the two models can be compared to verify and debug the system design.

As shown in the the framework can be used in four example different approaches. Going from the left to right the first approach is to directly load performance data obtained from execution of a simulation having an instrumented design into the relational database . The second approach is to load the performance data in a different format such as the SystemC Verification SCV format and load the performance data into the relational database as a post processing step through a front end query tool that uses the API suite . In the third approach the simulation framework also performs the functions of the query tool and performance analysis is done during simulation. Finally in the final approach performance data is stored in a relational database format which is loaded into the database as a post processing step using the front end query tool and the API suite .

The API suite performs four main functions the API suite converts the observed data from a given format to a relational database specific format the API suite establishes a connection with the database the API suite performs a set of simple queries that involve retrieving the data from the relational database based on filters and finally the API suite performs a set of complex queries that operate on multiple simple queries to execute a complex algorithm.

The relational database may have defined tables designed for interconnect analysis of transactions occurring between initiator intellectual property IP cores and target IP cores of the electronic design of an integrated circuit such as a System on a chip. The relational database may store the formatted data into defined tables. The defined tables may be defined in the database prior to the simulation generating the performance data or defined during the simulation itself by code in the simulation creating temporary files in the database to keep track of specific information for that simulation. Each defined table is associated with an instrumentation test point type such as a collection Performance Observation Point s POP located in the interconnect of the electronic design to monitor transactions occurring between initiator intellectual property IP cores and target IP cores of the electronic design. The defined tables may include the following a transaction table a queue monitor table a latency table a thread arbitration table a link arbitration table a DL monitor table a topology specification class table a tracking table and other similar tables.

In an embodiment the SCV database receives SCV data files from the simulation in its native format. As a post processing step a front end query tool invokes certain API from the relational DB API suite to convert the native format into a relational database specific format and to store the data in the database as tables. The SystemC verification database receives SystemC verification SCV data generated from a performance simulation of the interconnect being modeled with a SystemC model having a first level of abstraction. The SCV database receives SCV data from the performance simulation of the interconnect and sends the SCV data in the form of the input data to the API . The SCV database collects data based on the execution of the simulation the SystemC and or RTL model of the interconnect of an electronic design .

The front end query tool utilizes a relational database application programming interface to communicate with the database. The query tool calls an API from the relational database API suite to format input data for storing in the database defined tables. The input data can include SystemC verification SCV data received directly from a performance simulation of an interconnect being modeled with a SystemC model having a first level of abstraction a second performance simulation of the interconnect being modeled with a register transfer level RTL model having a second level of abstraction a performance of a fabricated interconnect or similar data. The query tool invokes one or more of the supported query APIs in the API suite for performance analysis. In addition the tool may execute additional algorithms for specific performance analysis of the design under test.

The query tool may invoke multiple user defined queries and one or more pre specified standard queries from the set of two or more pre specified standard that are specified during design time of the apparatus. The pre specified standard queries can include simple query primitives that allow a user to load and store data from and to the relational database and complex queries that are algorithms to perform complex calculations.

The database API provides a tool to store the SystemC verification data in a relational database format. The advantage of using a relational database is that it has inherent support for queries. The DB API suite is built by utilizing the query support in the relational database framework to generate a set of standard simple and complex queries. While the primitive queries filter data as per given conditions the complex queries invoke several primitive queries and an analysis algorithm to answer a specific performance analysis requirement. Further the query front end may employ its own analysis algorithms that operate on the results obtained from the invocation of different APIs from the API suite for further performance analysis.

The fabricated or simulated pre instrumented interconnect collects in the POPs and sends the data into a SystemC verification database . Based on one or more of the embodiments described in the API stores the SystemC verification data in the relational database . The front end query tool provides interconnect specific analysis framework that uses the query support provided by the APIs. The APIs provide a user interface for querying the database with a set of standard queries that are either primitive queries such as retrieving data subject to filters or complex queries such as determining the average backpressure experienced by response path mergers.

Note the query tool can be the simulation itself. The query tool allows analyzing data retrieved with the query by executing an algorithm for interconnect analysis. The algorithm compares data from for example the SystemC simulation associated with a first model and the RTL simulation associated with a second model having a second level of abstraction that models an interconnect in order to determine if the interconnect is functioning properly during run time of the first and second simulations. These are example models and other can be compared. Each model has instantiated POPs in the simulated interconnect. Likewise synthesized instantiated POPs may be located within one or more bus interconnects in the fabricated prototype . The simulated models have run time processing of the performance data in order to optimize simulation speed and analysis database size. The raw data collected correlates to measurements of performance parameters on particular instrumented points to track things such as end of the boot sequence core initialization beginning of DMA transfers.

The query tool and instrumentation points enable users to analyze and debug their design for all the different phases of the product development. In an architecture phase a SystemC model is instrumented with instrumentation test points and performance counters to provide the data to the databases. A RTL model may be instrumented with hardware performance monitors to provide the data to the databases. In silicon one or more on chip synthesized hardware performance monitors in the integrated circuit provide the data to the databases. The consistent instrumentation and common post processing infrastructure allow easy comparisons between the different phases SystemC vs. RTL vs. Silicon .

A utility application of the query tool loads the SystemC verification data into the relational database . The utility also provides extensive query support that is capable of executing both primitive and complex query algorithms for performance analysis. The query tool is used to query the database for functionality validation debugging and performance analysis.

In addition to the standard SystemC verification format the Performance Analysis query tool also provides a framework to load data directly into a relational database. The relational database is kept open such that they can design database queries specific to their requirements. Visibility to the database may exclude certain types of users. Internal and external types of users will be discussed as the way system treats these example types of users. Instead the query tool provides a set of query Application Programming Interfaces access the relational database with the predefined queries.

Referring to the standard queries and the SystemC verification database are external user visible entities. The external user is provided access to the standard queries and the SystemC verification database. However the user is not provided any visibility into the Application Programming Interface and the relational database . The merely way the user can access the relational database is through the standard queries. For internal users the relational database and the Application Programming Interface are made visible. Thus users can design personalized queries to suit their specific performance analysis requirements. The standard queries include simple query primitives and complex queries.

Query primitives are simple queries that allow the user to load and store data from and to the database. As shown in the figure these queries merely need the mysql C Application Programming Interface to perform the necessary processing. On the other hand complex queries are algorithms to perform complex operations. They are typically composed of multiple calls to other primitive queries and the mysql Application Programming Interfaces.

Query primitives include at least the following example query primitives a select transaction query to select a transaction s details based on one or more constraints a queue details query to enqueue and dequeue time in different queues a boundary cross query to determine all transactions that cross a channel boundary a get initiator query to get the initiator of a given transaction a get end time query to get an end time of a given transaction a thread arbitration query to check the arbitration states of different units and a thread busy query to monitor different thread busy signals.

Complex queries include at least the following example complex queries a track transaction query to track a transaction s life in an interconnect associated with the interconnect an overall latency query to determine an average peak and optimum latency of transactions over a time window a latency distribution query to determine a distribution of latency over time a response reorder query to check if responses are reordered correctly a merger backpressure query to determine an average backpressure at response mergers an address distribution query to determine a distribution of addresses per input sequence file a channel processing query to processing input sequence file s for channel crossing and channel distribution a page hit statistic query to obtain page hit statistics per burst transaction and a page miss statistic query to obtain page miss statistics per burst transaction. A standard complex query can require the Application Programming Interface and a set of primitive queries to perform its function.

Queries may also be broadly classified into two major categories Standard queries and user defined queries.

The table below defines the queries and categorizes the queries into primitive and complex queries. The third column in the table lists the performance objectives that are catered to by the specific query.

All queries return a data structure that can be manipulated as per the user s preference. These data structures can be output to a file or standard I O based on the user s preference. The data structure is of type string where string i j depicts the word at row i and column j. The format of the data structure returned is query specific and is listed below. In the tables below the first column specifies the table and the second column specifies the options that can be used to exercise the query. The options are annotated with R  for required O  for optional. On presenting the optional fields the query is filtered by that particular field. For example if the user desires to select all transactions that originated from initiator X the select transaction query with an option of initiator X would filter merely those transactions originating from X. The third column describes the fields of the data structure that is output. Note that the fields are described for merely one row. The format of the remaining fields is identical.

Referring to the following two requirements should be satisfied before the Application Programming Interface can be used 

DB API performs translation from SystemC verification to relational database format. As mentioned before the relational database has two potential user groups Internal and external. For external and internal users the Performance Analysis environment provides a translator to store the SystemC verification data in a relational database format. In addition for internal users merely the infrastructure provides an option of loading the POP data directly into a relational database during simulation. The following are the differences between the two approaches 

When dumping data from the simulation to relational database the data is stored in ASCII format thus providing full visibility to the user. On the other hand translation from SystemC verification to relational database format stores data in a binary format and users do not have visibility into the relational database .

Since the relational database is visible for internal users they can develop personalized queries on the database that suit their specific needs. On the other hand external users can merely access the relational database through pre specified standard queries.

In an embodiment the SystemC verification format may consist of streams generators and attributes. For a detailed explanation of the format please refer to existing literature on SystemC verification format. The Performance Analysis system may use an example hierarchy as the following.

A new SystemC verification stream is created for each POP type that has been enabled. An example for the queue POP type is shown below.

A SystemC verification generator is associated with each instance of a POP type at different locations in the IP. The name field identifies the location and the thread that is of interest. In order to avoid ambiguity the location is specified hierarchically. The generator is also associated with the stream that it belongs to by recording the stream s ID as part of the generator s definition. Finally a set of attributes denoted by begin attribute and end attribute are associated with the generator.

Two examples are presented below The first one is a queue POP for thread 0 of the embedded register point in the IA. The second is that of thread 0 in the DRL queue at the register point. Both POPs belong to the same stream identified by queue POP type 

As mentioned above the name field in the two generators is identified by the hierarchical name of the module. In the second example the DRL queue does not have an associated hierarchical name. Therefore the hierarchical name is appended with an extra identifier drlQ .

The begin attribute field indicates the data that is recorded at the beginning of the generator. Similarly the end attribute field denotes the data recorded at the end of the generator. The name field consists of the transaction ID of the transfer at the resource and the transfer number of the transaction on the resource. For example a burst with transaction ID 1 and four transfers at a particular resource would have four attributes 10 11 12 13. The transaction ID helps us identify individual transactions. Multiple attributes for the same generator denote several transfers of the same transaction and transfers of different transactions passing through the resource. Finally the type of the transaction is defined by a user defined class object that is specific to the POP type. An example of Queue POP type at the embedded register point of an IA is shown below.

For all POP types other than the QUEUE POP type the begin attribute and end attribute of the generator occur together and hence at the same simulation time. In other words the end attribute of the POP is present merely to satisfy the format of the SystemC verification. On the other hand the QUEUE POP types are organized not merely to observe the queue utilization but also the time spent by a transfer inside the queue. Therefore for this POP type the begin attribute captures the enqueue operation on the transfer and end attribute captures the dequeue operation. Therefore the time spent in the queue is easily calculated as the difference between the dequeue and enqueue times.

In the relational database the data is organized in the form of tables. In the Performance Analysis framework the data is organized in the form of a table per POP type. Further in order to improve the performance of queries an additional table is maintained to keep track of the transaction specific information such as end to end latency. The following is the description of example tables in the database.

The tracking table tracks transaction specific information and improves performance of queries. Transaction tracking Table 3.

The number of fields N for Path Resource type Resource SimTime is set to a maximum value depending on the configuration of the design. If the number of fields M required to load the data specific to a particular transaction is less than the available number of fields N the last N M fields are left blank.

The latency table is optionally loaded if the burst specific information such as its end to end latency and the memory channels the burst is routed to. In order to load this table the transaction inject table and the transaction propagate tables must be loaded. In addition the RTL conf file should also be specified.

In the table described above fields 4 through 10 are specified per IP and exchange as well as for the entire product. When the values are specified for the entire product the terms endToend are used in the IP and the exchange fields.

In an embodiment much of the internal configuration of the interconnect in the simulation model is derived from the rtl.conf file. Many of the internal components and connections are not easily determined by the user. For this reason the user can query the SQL database to get an ordered list of agents components and links on a path.

The performance database makes available a set of methods that allow an internal external user to query the performance database for performance data captured during simulation. These methods are made available as a C C library which allows the basic primitives to be aggregated in an arbitrary fashion so that more complex performance analysis programs can be automated and re used. Additionally the database makes available all rtl.conf information via a set of queries.

The rtl.conf contains information about which clock domain each exchange agent belongs to. However clock frequencies may be varied dynamically and in the future asynchronous crossings will be permitted in Interconnect. For this reason the API for the relational database has a set of algorithms to translate back and forth between simulation time and cycle time in each clock domain.

The DB API sends the raw data in the form of the input data to the query tool for post processing and analysis of the performance data from the simulation. Performance analyzers PAs analyze the simulation time information captured by the software instrument test points from the System on a Chip design under test DUT . PAs may have two forms Regular PAs and derived PAs. Regular PAs return data recorded at simulation time. On the other hand derived PAs are calculated from one or more regular PAs. For example observing the enqueue and dequeue times of a given queue would be a regular PA. A more complex PA would be to check if the responses from different channels are re ordered properly at the response path mergers.

The database Application Programming Interface Db Application Programming Interface consists of the basic framework to connect to the database and store and load data. On loading from the database Application Programming Interface returns the elements of the row of the table in the database as a data structure. Consider an example with mysql database . The connectivity is established as follows 

Once the mysql database connection is established a database query to load or store data can be formulated as a string and sent to the mysql database . The Db Application Programming Interface thus provides a data structure which can be used to output the required data. A few examples follow.

A user may use the select clause of the mySql database query framework to tracking a transaction by selecting all lines of the transaction propagate table with the specified transaction ID and send the query to the database using the Application Programming Interface.

A user may use the select clause of the mySql database query framework to select a transaction by selecting all lines of the latency table with the specified filters and send the query to the database using the Application Programming Interface.

A user may use the select clause of the mySQL database query framework to obtain queue details by selecting the select clause to select the queue along with the filters.

A user may use the select clause of the mySQL database query framework to obtain queue utilization recursively over time windows similar to latency distribution and average the queue utilization over time windows.

A user may use the select clause of the mySQL database query framework to select the transaction ID from the latency table where the filters corresponding to the query are applied to determine backpressure occurring at merger units in the interconnect.

Aspects of the above design may be part of a software library containing a set of designs for components making up the Interconnect and associated parts. The library cells are developed in accordance with industry standards. The library of files containing design elements may be a stand alone program by itself as well as part of the EDA toolset.

The EDA toolset may be used for making a highly configurable scalable System On a Chip SOC inter block communication system that integrally manages input and output data control debug and test flows as well as other functions. In an embodiment an example EDA toolset may comprise the following a graphic user interface a common set of processing elements and a library of files containing design elements such as circuits control logic and cell arrays that define the EDA tool set. The EDA toolset may be one or more software programs comprised of multiple algorithms and designs for the purpose of generating a circuit design testing the design and or placing the layout of the design in a space available on a target chip. The EDA toolset may include object code in a set of executable software programs. The set of application specific algorithms and interfaces of the EDA toolset may be used by system integrated circuit IC integrators to rapidly create an individual IP core or an entire System of IP cores for a specific application. The EDA toolset provides timing diagrams power and area aspects of each component and simulates with models coded to represent the components in order to run actual operation and configuration simulations. The EDA toolset may generate a Netlist and a layout targeted to fit in the space available on a target chip. The EDA toolset may also store the data representing the interconnect and logic circuitry on a machine readable storage medium.

Generally the EDA toolset is used in two major stages of SOC design front end processing and back end programming.

Front end processing includes the design and architecture stages which includes design of the SOC schematic. The front end processing may include connecting models configuration of the design simulating testing and tuning of the design during the architectural exploration. The design is typically simulated and tested. Front end processing traditionally includes simulation of the circuits within the SOC and verification that they should work correctly. The tested and verified components then may be stored as part of a stand alone library or part of the IP blocks on a chip. The front end views support documentation simulation debugging and testing.

In block the EDA tool set may receive a user supplied text file having data describing configuration parameters and a design for at least part of an individual intellectual property IP block having multiple levels of hierarchy. The data may include one or more configuration parameters for that IP block. The IP block description may be an overall functionality of that IP block such as an interconnect. The configuration parameters for the interconnect IP block may be number of address regions in the system system addresses how data will be routed based on system addresses etc.

The EDA tool set receives user supplied implementation technology parameters such as the manufacturing process to implement component level fabrication of that IP block an estimation of the size occupied by a cell in that technology an operating voltage of the component level logic implemented in that technology an average gate delay for standard cells in that technology etc. The technology parameters describe an abstraction of the intended implementation technology. The user supplied technology parameters may be a textual description or merely a value submitted in response to a known range of possibilities.

The EDA tool set may partition the IP block design by creating an abstract executable representation for each IP sub component making up the IP block design. The abstract executable representation models TAP characteristics for each IP sub component and mimics characteristics similar to those of the actual IP block design. A model may focus on one or more behavioral characteristics of that IP block. The EDA tool set executes models of parts or all of the IP block design. The EDA tool set summarizes and reports the results of the modeled behavioral characteristics of that IP block. The EDA tool set also may analyze an application s performance and allows the user to supply a new configuration of the IP block design or a functional description with new technology parameters. After the user is satisfied with the performance results of one of the iterations of the supplied configuration of the IP design parameters and the technology parameters run the user may settle on the eventual IP core design with its associated technology parameters.

The EDA tool set integrates the results from the abstract executable representations with potentially additional information to generate the synthesis scripts for the IP block. The EDA tool set may supply the synthesis scripts to establish various performance and area goals for the IP block after the result of the overall performance and area estimates are presented to the user.

The EDA tool set may also generate an RTL file of that IP block design for logic synthesis based on the user supplied configuration parameters and implementation technology parameters. As discussed the RTL file may be a high level hardware description describing electronic circuits with a collection of registers Boolean equations control logic such as if then else statements and complex event sequences.

In block a separate design path in an ASIC or SOC chip design is called the integration stage. The integration of the system of IP blocks may occur in parallel with the generation of the RTL file of the IP block and synthesis scripts for that IP block.

The EDA toolset may provide designs of circuits and logic gates to simulate and verify the operation of the design works correctly. The system designer codes the system of IP blocks to work together. The EDA tool set generates simulations of representations of the circuits described above that can be functionally tested timing tested debugged and validated. The EDA tool set simulates the system of IP block s behavior. The system designer verifies and debugs the system of IP blocks behavior. The EDA tool set tool packages the IP core. A machine readable storage medium may also store instructions for a test generation program to generate instructions for an external tester and the interconnect to run the test sequences for the tests described herein. One of ordinary skill in the art of electronic design automation knows that a design engineer creates and uses different representations to help generating tangible useful information and or results. Many of these representations can be high level abstracted and with less details or top down views and can be used to help optimize an electronic design starting from the system level. In addition a design process usually can be divided into phases and at the end of each phase a tailor made representation to the phase is usually generated as output and used as input by the next phase. Skilled engineers can make use of these representations and apply heuristic algorithms to improve the quality of the final results coming out of the final phase. These representations allow the electric design automation world to design circuits test and verify circuits derive lithographic mask from Netlists of circuit and other similar useful results.

In block next system integration may occur in the integrated circuit design process. Back end programming generally includes programming of the physical layout of the SOC such as placing and routing or floor planning of the circuit elements on the chip layout as well as the routing of all metal lines between components. The back end files such as a layout physical Library Exchange Format LEF etc. are generated for layout and fabrication.

The generated device layout may be integrated with the rest of the layout for the chip. A logic synthesis tool receives synthesis scripts for the IP core and the RTL design file of the IP cores. The logic synthesis tool also receives characteristics of logic gates used in the design from a cell library. RTL code may be generated to instantiate the SOC containing the system of IP blocks. The system of IP blocks with the fixed RTL and synthesis scripts may be simulated and verified. Synthesizing of the design with Register Transfer Level RTL may occur. The logic synthesis tool synthesizes the RTL design to create a gate level Netlist circuit design i.e. a description of the individual transistors and logic gates making up all of the IP sub component blocks . The design may be outputted into a Netlist of one or more hardware design languages HDL such as Verilog VHDL Very High Speed Integrated Circuit Hardware Description Language or SPICE Simulation Program for Integrated Circuit Emphasis . A Netlist can also describe the connectivity of an electronic design such as the components included in the design the attributes of each component and the interconnectivity amongst the components. The EDA tool set facilitates floor planning of components including adding of constraints for component placement in the space available on the chip such as XY coordinates on the chip and routes metal connections for those components. The EDA tool set provides the information for lithographic masks to be generated from this representation of the IP core to transfer the circuit design onto a chip during manufacture or other similar useful derivations of the circuits described above. Accordingly back end programming may further include the physical verification of the layout to verify that it is physically manufacturable and the resulting SOC will not have any function preventing physical defects.

In block a fabrication facility may fabricate one or more chips with the signal generation circuit utilizing the lithographic masks generated from the EDA tool set s circuit design and layout. A prototype of an integrated circuit with an interconnect having one or more performance monitors may be fabricated. Fabrication facilities may use a standard CMOS logic process having minimum line widths such as 1.0 um 0.50 um 0.35 um 0.25 um 0.18 um 0.13 um 0.10 um 90 nm 65 nm or less to fabricate the chips. The size of the CMOS logic process employed typically defines the smallest minimum lithographic dimension that can be fabricated on the chip using the lithographic masks which in turn determines minimum component size. According to one embodiment light including X rays and extreme ultraviolet radiation may pass through these lithographic masks onto the chip to transfer the circuit design and layout for the test circuit onto the chip itself.

The EDA toolset may have configuration dialog plug ins for the graphical user interface. The EDA toolset may have an RTL generator plug in for the SocComp. The EDA toolset may have a SystemC generator plug in for the SocComp. The EDA toolset may perform unit level verification on components that can be included in RTL simulation. The EDA toolset may have a test validation testbench generator. The EDA toolset may have a dis assembler for virtual and hardware debug port trace files. The EDA toolset may be compliant with open core protocol standards. The EDA toolset may have Transactor models Bundle protocol checkers OCPDis2 to display socket activity OCPPerf2 to analyze performance of a bundle as well as other similar programs

As discussed an EDA tool set may be implemented in software as a set of data and instructions such as an Instance in a software library callable to other programs or an EDA tool set consisting of an executable program with the software cell library in one program stored on a machine readable medium. A machine readable storage medium may include any mechanism that provides information in a form readable by a machine e.g. a computer . For example a machine readable medium may include but is not limited to read merely memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices DVD s EPROMs EEPROMs FLASH magnetic or optical cards or any other type of media suitable for storing electronic instructions. The instructions and operations also may be practiced in distributed computing environments where the machine readable media is stored on and or executed by more than one computer system. In addition the information transferred between computer systems may either be pulled or pushed across the communication media connecting the computer systems.

Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

The modeling tool may have its instructions executable code sequences data files etc stored on a machine readable storage medium. A machine readable storage medium may include any mechanism that provides information in a form readable by a machine e.g. a computer . For example a machine readable medium may include but is not limited to read merely memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices DVD s electrical optical digital signals EPROMs EEPROMs FLASH magnetic or optical cards or any other type of media suitable for storing electronic instructions.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussions it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

While some specific embodiments of the invention have been shown the invention is not to be limited to these embodiments. For example most functions performed by electronic hardware components may be duplicated by software emulation. Thus a software program written to accomplish those same functions may emulate the functionality of the hardware components. SystemC was used as an example software programming language that could be used but others could also be used. RTL was used as an example hardware description language that was used but others could be used as well. The hardware logic consists of electronic circuits that follow the rules of Boolean Logic software that contain patterns of instructions or any combination of both. The invention is to be understood as not limited by the specific embodiments described herein but merely by scope of the appended claims.

