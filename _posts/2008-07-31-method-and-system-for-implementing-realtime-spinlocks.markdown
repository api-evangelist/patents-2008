---

title: Method and system for implementing realtime spinlocks
abstract: A system and method for receiving a request from a requester for access to a computing resource, instructing the requester to wait for access to the resource when the resource is unavailable and allowing the requester to perform other tasks while waiting, determining whether the requester is available when the resource subsequently becomes available, and granting access to the resource by the requester if the requester is available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08707315&OS=08707315&RS=08707315
owner: Wind River Systems, Inc.
number: 08707315
owner_city: Alameda
owner_country: US
publication_date: 20080731
---
Locks are mechanisms used to control access to computing resources with limited capacity. Spinlocks enable requesters that are waiting for access to an occupied resource to execute other threads while they are waiting. However spinlocks may incorporate delays and inefficiencies if the locked resource is assigned to a requester that is executing other threads and unable to immediately begin using the resource.

A method for receiving a request from a requester for access to a computing resource instructing the requester to wait for access to the resource when the resource is unavailable and allowing the requester to perform other tasks while waiting determining whether the requestor is available when the resource subsequently becomes available and granting access to the resource by the requester if the requester is available.

A system having a computing resource a plurality of requesters having controlled access to the resource and a spinlock controlling access by the plurality of requesters to the resource the spinlock receiving a request from a first requester for access to the resource instructing the first requester to wait for access to the resource when the resource is unavailable and allowing the first requester to perform other tasks while waiting determining whether the first requester is available when the resource subsequently becomes available and granting access to the resource by the first requester if the first requester is available.

A system having a processor and a set of instructions executing on the processor the set of instructions operable to receive a request from a requester for access to a computing resource instruct the requester to wait for access to the resource when the resource is unavailable and allow the requestor to perform other tasks while waiting determine whether the requester is available when the resource subsequently becomes available and grant access to the resource by the requester if the requester is available.

The exemplary embodiments of the present invention may be further understood with reference to the following description and the appended drawings wherein like elements are referred to with the same reference numerals. The exemplary embodiments of the present invention describe methods and systems for optimally implementing realtime spinlocks.

In software development a lock is a mechanism for enforcing limits on access to a resource in an environment where there are multiple concurrent threads of execution. Locks may be advisory wherein each executing thread acquires the lock before accessing the corresponding data or may be mandatory wherein an attempt to make unauthorized access to a locked resource will force an exception.

Some software locks are binary or semaphore locks which make no distinction between shared i.e. read only or exclusive i.e. read and write access to locked data. Other locks may implement a shared mode wherein several threads may simultaneously access a shared lock for read only data access. Other data access modes may also be implemented.

In addition to the above categories locks may also be categorized in terms of what happens when a lock prevents the progress of a thread. Many locking designs block execution of a thread requesting access to a locked resource until the thread is allowed to access the resource. In contrast a spinlock is a lock in which the thread simply waits or spins until the locked resource becomes available. Once acquired a spinlock will usually be held until it is explicitly released although in some implementations it may be automatically released if the thread blocks.

Spinlocks are efficient if threads are only likely to be prevented from accessing locked resources for a short period of time as they avoid the processing overhead that results from rescheduling processes. Thus spinlocks are often used to control access to resources within operating system kernels. However they may be wasteful if a lock remains in place for a long period of time because other threads are prevented from running and require rescheduling. The longer a lock is held the greater the risk that it will be interrupted by the O S scheduler. If this happens other threads that are attempting to access the resource will continue spinning i.e. trying to obtain access to the locked resource despite the fact that no progress is being made towards releasing the resource. This problem is exacerbated for single processor systems wherein each waiting thread having the same priority for access to the locked resource is likely to waste its entire allotted time slice spinning until the thread that has access to the locked resource is rescheduled.

The exemplary embodiments of the present invention provide realtime spinlocks that include policy based access to the resource controlled by the spinlock. Each spinning processor is capable of running interrupts while spinning. Access to an available spinlock by a third party processor is not delayed while a requesting processor is busy running interrupts.

The system may also include a resource access to which is controlled by a spinlock . The resource may be any resource that has limited capacity and thus may have its accessibility limited. Examples of shared resources that may have their access controlled by spinlocks may include shared memory space peripherals e.g. device drivers etc. The spinlock may operate in accordance with the exemplary method described below and illustrated in .

In step the spinlock receives a request for access to the resource which it controls. The request may be made by for example the processor . In step the spinlock determines whether the resource is available e.g. is the resource currently being accessed by either one of processors or . Those of skill in the art will understand that since the spinlock controls access to the resource the spinlock is the programming entity that is aware of whether the resource is available. If the resource is available the method proceeds to step where the spinlock grants access to the resource by the requesting processor . Access may be granted for as long as the processor needs to use the resource for a fixed period of time for a predetermined amount of time after the spinlock receives a subsequent request for access to the resource or for any other desirable period of time. After the access has been granted the spinlock locks the resource in step so that additional processors or execution threads may not gain access to the resource . Thus if the resource is currently available and only a single processor has requested access to the resource the spinlock will grant the requested access.

However referring back to step if the resource is not available when the processor makes the access request the spinlock in step will instruct the processor to spin and or run interrupts e.g. another task the processor needs to perform that does not require access to the resource . For example if processor already has access to the resource when the request from processor is received the spinlock will instruct processor that the resource is not available and that the processor may run interrupts while it is waiting for the resource to become available. In some embodiments the spinlock will only instruct the processor to run interrupts if the processor has previously requested access to the resource and been denied a number of times which is fewer than a predetermined value this may insure that the amount of time a given processor waits for access to the resource does not become excessive. It should be noted that while this exemplary method refers to the processor s running an interrupt task they may also perform multiple interrupt tasks while waiting for access to the resource .

In step the spinlock will make a continuous determination as to whether the resource has become available e.g. has processor released the resource . When the spinlock determines that the processor has released the resource the spinlock determines whether there are multiple outstanding requests for access to the resource in step .

If there is only a single request e.g. the single outstanding request from the processor the method continues to step where the single outstanding request is granted and the processor gains access to the resource and the spinlock then locks the resource in step . It should be noted that as will be described in more detail below if the processor is busy running an interrupt when the resource becomes available the spinlock may delay granting access to the processor until the processor becomes available even if it is the only outstanding request because there may be subsequent requests received from other processors prior to the processor becoming available.

However if in step it is determined that there are multiple outstanding requests for access to the resource e.g. both processors and have an outstanding request to access the resource the method continues to step where the spinlock may grant access based on a desired policy implemented in the spinlock .

For example a first policy may be to grant access to a processor or execution thread that is currently available e.g. that is not currently running an interrupt . As described above if the requested resource is not available the spinlock may instruct the requesting processor that it is able to run interrupts while the processor is waiting for the resource . Thus in the present example where both processors and are currently waiting for access to the resource the spinlock may have instructed the processors and that they may run interrupts while waiting for access to the resource . However when the resource became available step the processor may still have been running an interrupt while the processor may have completed running one or more interrupts or may not have run any interrupts. Thus the processor may be immediately available to gain access to the resource . If such a policy for immediate access is set in the spinlock the spinlock may grant access to the resource by the processor even though the request by processor may have been received earlier. Thus in this exemplary embodiment the policy rule is that a processor or execution thread that is immediately available will be granted access to the resource when it becomes available.

It can be seen from the above example that the exemplary embodiments of the present invention allow each spinning processor to run interrupts while spinning thereby allowing the processor to be more efficient. In addition with the example policy described above a processor that is ready to gain access to a resource does not have to wait for access while another requesting processor is busy running interrupts.

A further exemplary policy that may be implemented in the spinlock is that if a requesting processor is skipped because it was not available when the resource previously became available that processor may be granted priority the next time the resource becomes available. For example continuing with the example from above if the processor was skipped in favor of processor the spinlock may include a policy that favors processor the next time that the resource becomes available e.g. if processor is available the next time the resource becomes available the processor receives access because it was skipped last time.

In another example a policy may be set that if a requesting processor is skipped e.g. processor from the above example the outstanding request may be deleted or removed from a request queue and the processor may be required to resubmit a new request for access to the resource.

Those skilled in the art will understand that the exemplary embodiments of the present invention allow for any number of access policies to be implemented in the realtime spinlocks depending on the needs or desires of the system in which the spinlock is operating. In addition to the examples provided above additional examples of access policies may include fairness e.g. access to the resource may be provided on a round robin basis priority based e.g. processors or execution threads may have priority values and access to the resource may be based on the priority value or any combination thereof.

Those skilled in the art will understand that other exemplary systems of the present invention may incorporate more elements. For example other exemplary systems may include multiple resources controlled by spinlocks. In such a system a processor may be able to wait for more than one spinlock at a time or may be limited to waiting for a single spinlock. Further other exemplary systems may include more processors which may be concurrently waiting for a single locked resource. Systems including a large number of processors may require policies beyond those described above for determining how to handle multiple processors concurrently running interrupts while waiting for access to the same resource.

The following illustrates code in the C programming language for implementing an exemplary realtime spinlock according to the present invention.

Those of skill in the art will understand that this code is merely exemplary and that other programming code in both C and other programming languages may also be written to implement realtime spinlocks according to the present invention.

Those skilled in the art will understand that the above described exemplary embodiments may be implemented in any number of manners including as a separate software module as a combination of hardware and software etc. For example the method may be a program containing lines of code that when compiled may be executed by a processor.

It will be apparent to those skilled in the art that various modifications may be made in the present invention without departing from the spirit or the scope of the invention. Thus it is intended that the present invention cover modifications and variations of this invention provided they come within the scope of the appended claims and their equivalents.

