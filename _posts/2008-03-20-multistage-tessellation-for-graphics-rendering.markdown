---

title: Multi-stage tessellation for graphics rendering
abstract: This disclosure describes a multi-stage tessellation technique for tessellating a curve during graphics rendering. In particular, a first tessellation stage tessellates the curve into a first set of line segments that each represents a portion of the curve. A second tessellation stage further tessellates the portion of the curve represented by each of the line segments of the first set into additional line segments that more finely represent the shape of the curve. In this manner, each portion of the curve that was represented by only one line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. In some instances, more than two tessellation stages may be performed to tessellate the curve.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08643644&OS=08643644&RS=08643644
owner: QUALCOMM Incorporated
number: 08643644
owner_city: San Diego
owner_country: US
publication_date: 20080320
---
This disclosure relates to computing devices and in particular to graphics rendering by computing devices.

Computing devices are increasingly requiring advanced two dimensional 2D and three dimensional 3D graphics applications. For example computing devices are increasingly offering games character animations graphical menu systems and other applications that require advanced graphics rendering. This advanced graphics rendering especially with 3D graphics involves a substantial amount of data processing. The quality of the advanced graphics rendering may be limited by the amount of processing resources the capability of the available processing resources the amount of available power and the like.

For example applications requiring advanced graphics rendering at a high rendering rate e.g. measured as frames per second may place a significant strain on the available computing resources. The strain on the available computing resources may result in a reduced performance in other applications low quality graphics rendering or both due to the heavy load placed on the computing resources. In the context of mobile computing devices such as personal digital assistants PDAs wireless communication devices global positioning devices and the like the computationally intensive data processing required for graphics rendering may consume a significant amount of the available power of the mobile computing device.

A multi media processor may include a general purpose central processing unit CPU coupled to a graphics processing unit GPU . The GPU is dedicated to perform graphics rendering operations to display computerized graphics on a display. GPUs are built with a highly parallel structure that provides more efficient processing than conventional general purpose CPUs for a range of complex graphic related algorithms. When the graphic related algorithms executing on the CPU requires graphics processing the CPU tessellates the graphics and provides the tessellations to the GPU for rendering to the display. The highly parallel nature of the GPU allows the GPU to create complex three dimensional images on the display more quickly than drawing the images directly to the display with the CPU. GPUs may be used in a wide variety of applications and are very common in graphic intensive applications such as video games applications complex graphical user interface applications computer aided design programs for engineering or artistic applications or any other type of software application that uses 2D or 3D graphics.

This disclosure describes a multi stage tessellation technique for tessellating a curve during graphics rendering. The curve is tessellated in at least two tessellation stages. A first tessellation stage tessellates the curve into a first set of line segments that each represents a portion of the curve. A second tessellation stage further tessellates the portion of the curve represented by each of the line segments of the first set into additional line segments that more finely represent the shape of the curve. In this manner each portion of the curve that was represented by only one line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. In one example the first tessellation stage may for example be performed by a central processing unit CPU and the second tessellation stage may be performed by a tessellation component such as a graphics processing unit GPU or dedicated tessellation hardware. In some instances the multi stage tessellation technique may involve more than two tessellation stages.

In one aspect a method comprises tessellating a curve to divide the curve into first line segments with a first computing unit and tessellating a portion of the curve represented by one of the first line segments into second line segments with a second computing unit.

In another aspect a device comprises a first computing unit that tessellates a curve to divide the curve into first line segments and a second computing unit that tessellates a portion of the curve represented by one of the first line segments into second line segments.

In another aspect a device comprises first means for tessellating a curve to divide the curve into first line segments and second means for tessellating a portion of the curve represented by one of the first line segments into second line segments.

The techniques described in this disclosure may be implemented in hardware software firmware or any combination thereof. If implemented in software the software may be executed in a processor which may refer to one or more processors such as a microprocessor application specific integrated circuit ASIC field programmable gate array FPGA or digital signal processor DSP or other equivalent integrated or discrete logic circuitry. Software comprising instructions to execute the techniques may be initially stored in a computer readable medium and loaded and executed by a processor. Accordingly this disclosure also contemplates computer readable media comprising instructions to cause a processor to perform any of a variety of techniques as described in this disclosure. In some cases the computer readable medium may form part of a computer program product which may be sold to manufacturers and or used in a device. The computer program product may include the computer readable medium and in some cases may also include packaging materials.

The details of one or more aspects are set forth in the accompanying drawings and the description below. Other features objects and advantages of the techniques will be apparent from the description and drawings and from the claims.

This disclosure describes techniques for tessellating a curve during graphics rendering. In particular this disclosure describes a multi stage tessellation technique that tessellates the curve into a plurality of line segments during two or more tessellation stages. A first tessellation stage tessellates the curve into a first set of line segments that each represents a portion of the curve. The first tessellation stage may in some cases tessellate the curve into enough line segments to coarsely represent a shape of the curve. In one example the first tessellation stage may be performed by a first computing unit of a computing device such as a central processing unit CPU or a graphics processing unit GPU of the computing device.

A second tessellation stage further tessellates the curve into additional line segments. In particular the second tessellation stage tessellates the portion of the curve represented by each of the line segments of the first set into additional line segments that more finely represent the shape of the curve. In other words each portion of the curve that was represented by only one line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. The second tessellation stage may be performed by a second computing unit of the computing device. In some aspects the second computing unit may be the GPU that is dedicated to performing graphics operations including the second tessellation stage. The GPU may in some instances have a highly parallel structure that may be used to tessellate multiple portions of the curve in parallel. In another aspect the second computing unit may be dedicated tessellation hardware circuitry that performs the second tessellation stage. As will be described below the multi stage tessellation may include more than two tessellation stages.

As illustrated in the example of computing device includes a user input interface a CPU a device memory a GPU a GPU memory a display interface and a display . User input interface CPU device memory GPU and display interface may communicate using a bus . Bus may be any of a variety of bus structures such as a third generation bus e.g. a HyperTransport bus or an InfiniBand bus a second generation bus e.g. an Advanced Graphics Port bus a Peripheral Component Interconnect PCI Express bus or an Advanced eXentisible Interface AXI bus or another type of bus or device interconnect.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include a word processor application a spread sheet application a media player application a video game application a graphical user interface application or another end user program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user input interface .

Device memory may store device configuration information that may be used at start up or reset to configure computing device . Device memory may also store data and or program modules that are immediately accessible and or presently being operated on by CPU . Device memory may additionally store information from other components of computing device such as information output by GPU . Device memory may be one or more volatile or non volatile memory or storage device such as random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be dedicated to performing graphics operations to render computerized graphics on display . Thus when one of the software applications executing on CPU requires graphics processing CPU provides the graphics information to GPU for rendering to display . GPU may in some instances be built with a parallel structure that provides more efficient processing of complex graphic related operations than CPU . The parallel nature of GPU may allow GPU to create complex two dimensional 2D or three dimensional 3D images on display more quickly than drawing the images directly to display with CPU . In some instances GPU may be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . GPU may be one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

GPU may be directly coupled to GPU memory . Thus GPU may read data from and write data to GPU memory without using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate memory but instead utilize device memory via bus . GPU memory may be one or more volatile or non volatile memory or storage device such as random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may provide image information to display interface for presentation via display . In the case of complex 2D and 3D graphics the image information is typically generated by GPU for display . Display may comprise a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

When one of the software applications executing on CPU desires to present a complex 2D or 3D graphics image CPU and GPU operate together to render the graphics to display . In the case of a video game application for example the software application may desire to present a series of video frames in a sequence to provide the video gaming experience to the user. The software application includes commands that define one or more curves that form the graphics image to be displayed. In the case of a video game application for example the video game application may include commands that define curves of a graphical image of a scene of the video game. The commands may for example define a number of curves that define boundaries of a character and objects within a background.

In one example the software application may include commands that define a plurality of paths i.e. curves in accordance with OpenVG as defined in a document OpenVG Specification Version 1.0 Jul. 28 2005. OpenVG is a set of commands that allow for the specification of graphical images in 2D or 3D using one or more segment commands. In accordance with the OpenVG Specification the segment commands may define straight line segments Bezier curve segments or elliptical arc segments. Extensions of OpenVG may specify other types of segments. Therefore the techniques of this disclosure are not limited to the segment commands currently defined in the OpenVG specification. Moreover although the techniques of this disclosure are described in the context of OpenVG the techniques may be used in the context of other graphics authoring standards such as OpenGL Direct3D Graphics Device Interface GDI Quartz QuickDraw or the like.

To render a curve to display CPU and or GPU tessellate the curve into line segments using the multi stage tessellation techniques described in this disclosure. In one aspect CPU may perform a first tessellation stage to divide the curve into line segments and GPU may perform a second tessellation stage to further divide the curve into additional line segments. In this example CPU tessellates the curve into a first set of line segments that coarsely represent a shape of the curve during the first tessellation stage. Each of the line segments of the curve represents a portion of the curve. During the second tessellation stage GPU tessellates the portion of the curve represented by each of the line segments into additional line segments that more finely represent the shape of the curve. In other words each portion of the curve that was represented by only one line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. GPU may utilize a parallel structure to tessellate multiple portions of the curve represented by two or more line segments in parallel. In this manner in some aspects computing device may utilize the acceleration capability of GPU to simultaneously operate on multiple portions of the curve in full parallel thus resulting in improved rendering performance.

The amount of tessellation performed by CPU may vary as a function of a processing load on CPU and or a processing load on GPU . As described above CPU may execute multiple software applications at a time each of which uses processing resources of CPU to perform computational tasks. If CPU is lightly loaded with other computational tasks when the graphics related application desires graphics processing e.g. when the processing load of CPU is less than or equal to a threshold CPU may tessellate the curve into more line segments. This will result in a reduced tessellation workload for GPU as the GPU will have to tessellate the portions of the curve into fewer additional line segments.

If CPU is heavily loaded with other computational tasks when the graphics related application desires graphics processing e.g. when the processing load of CPU is greater than a threshold CPU may tessellate the curve into a fewer number of line segments. CPU may for example be heavily loaded when a game application is executing on the CPU that requires CPU to run tasks such as artificial intelligence that makes the computer play against a human player compute physical effects in the game provide sound effect display game graphics and the like. This will result in a reduced tessellation workload for CPU but increase the tessellation workload of GPU as GPU will have to tessellate the portions of the curve into more additional line segments. The tessellation processing workload may likewise be balanced based on the load of GPU or a combination of the load on CPU and GPU . In this manner computing device may dynamically balance the tessellation workload between CPU and GPU as a function of the available processing resources.

In another example the multi stage tessellation of the curve may occur within GPU . In this example CPU does not perform any tessellation of the curve. Instead a first computing unit within GPU performs the first tessellation stage to divide the curve into first line segments and a second computing unit with GPU performs the second tessellation stage to further divide the portion of the curve represented by the first line segments into additional line segments. In this example computing device may utilize the acceleration capability of GPU to simultaneously operate on multiple portions of the curve in full parallel during both tessellation stages.

In some instances the multi stage tessellation of the curve may include more than two tessellation stages. For example a first tessellation stage may tessellate the curve into a first set of line segments that each represent a portion of the curve. During a second tessellation stage the portion of the curve represented by each of the first line segments is tessellated into a second set of line segments such that each portion of the curve that was represented by only one of the first set of line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. During a third tessellation stage the portion of the curve represented by each of the second line segments is tessellated into additional line segments. Any number of tessellation stages may be performed. The tessellation stages may be performed by CPU GPU and or dedicated tessellation hardware not illustrated in .

A number of other elements may also be included in computing device but are not specifically illustrated in for simplicity and ease of illustration. For example computing device may include dedicated tessellation hardware such as tessellation hardware illustrated and described in detail in below. Moreover the architecture illustrated in is merely exemplary as the techniques described in this disclosure may be implemented with a variety of other architectures.

As described above software application may include commands that define one or more curves that form the graphics image to be displayed. The instructions may conform to any of a variety of graphics authoring standards i.e. application programming interfaces APIs such as OpenVG OpenGL Direct3D Graphics Device Interface GDI Quartz QuickDraw or the like. In the case of OpenVG for example a curve is defined by a sequence segment commands. Each segment command of OpenVG may specify a move a straight line segment a quadratic or cubic Bezier curve segment or an elliptical arc segment. Thus each segment command may define a portion of the curve. Software application may include a sequence of segment commands to generate a curve of any shape.

To prepare the curve for rendering to display CPU and or GPU tessellate the curve into line segments using the multi stage tessellation techniques described in this disclosure. In one aspect CPU performs a first tessellation stage and GPU performs a second tessellation stage. Software application may invoke a graphics API that interacts with a GPU driver to cause CPU to perform the first tessellation stage. In particular GPU driver calls a tessellation module within GPU driver to tessellate the curve during the first tessellation stage. Tessellation module may tessellate each segment i.e. command of the curve individually. In other words tessellation module may operate on one segment of the curve at a time to divide that segment of the curve into line segments. In other instances tessellation module may tessellate the entire curve. Therefore the term curve as used herein may refer to a curve or a segment of a curve of an object.

Tessellation module tessellates the curve into a first set of line segments. Each of the line segments represents a portion of the curve. In some instances the first set of line segments may approximate at least the general shape of the curve. However the first set of line segments do not need to provide a high resolution approximation of the shape of the curve. Tessellation module may for example tessellate the curve into a minimum number of line segments needed to conserve the general shape of the curve. In other words tessellation module may tessellate the curve to produce as few line segments as possible while still preserving the general shape of the curve. In another example tessellation module may not perform any tessellation of the curve when CPU is heavily loaded e.g. when the processing load of CPU exceeds a threshold. Instead CPU may provide the curve information to GPU for multi stage tessellation. However this results in an increased work load on GPU . Therefore CPU may be configured to balance the tessellation load between CPU and GPU .

To generate the first set of line segments tessellation module computes one or more vertex points that lie on the curve. Tessellation module may for example generate the one or more vertex points using a mathematical representation corresponding to the particular command segment which may be specified in the graphics authoring specification e.g. OpenVG . In the case of a curve that is defined using OpenVG as an elliptical arc curve for example tessellation module may compute the vertex points using the equations cos 1 sin 2 where x y is a positional coordinate of a vertex point on the curve in the object space a is a semi major axis of the ellipse b a semi minor axis of the ellipse and 0 2 . Each of the first set of line segments is a straight line segment that connects each vertex point to its neighboring vertex point. In some instances tessellation module or other component of CPU may compute an expanded polynomial representation of the curve as described in detail with respect to .

Tessellation module may tessellate the curve to equally divide the curve into the first set of line segments. For example tessellation module may equally divide the curve into N line segments where N is equal to any positive integer value. In the elliptical arc curve example above for instance tessellation module may incrementally increase the value of from a starting angle to an ending angle in step sizes of N to equally divide the elliptical arc curve into N equal line segments. If the elliptical arc curve is a full ellipse with a starting angle of 0 and an ending angle of 2 and N 8 for example tessellation module may generate eight line segments that connect vertex points located at 0 4 2 3 4 5 4 3 2 7 4 2 . In other instances tessellation module may adaptively tessellate the curve to divide the curve into more line segments for portions of the curve where the curvature of the curve is bigger and fewer line segments for portions of the curve where the curvature of the curve is smaller. In this manner the step sizes are non linear such that tessellation is denser where the curvature of the curve is bigger. Again with reference to the ellipse curve example tessellation module may generate the step sizes of based on the ratio b a such that more line segments are generated near 0 and i.e. step size of is smaller and less line segments are generated near 2 and 3 2 i.e. step size of is larger .

Tessellation load controller of GPU driver may compute the number of line segments N based on a load of CPU and or the load of GPU . Tessellation load controller may for example receive data regarding the load of CPU from an operating system not shown that monitors the load of CPU . Thus CPU may monitor its own work load. Tessellation load controller may additionally monitor the load of GPU . Because CPU controls GPU by sending tasks to GPU and monitoring the progress of GPU tessellation load controller can determine the load based on the number of commands sent to GPU .

Tessellation module may generate a list of drawing primitives using the generated line segments. Tessellation module may for example form the list of drawing primitives using the vertex points of the line segments as at least a portion of the vertex points for the primitives. Tessellation module may generate any of a number of drawing primitives including points line strips line loops separate lines triangle strips triangle fans separate triangles quadrilateral strips separate quadrilaterals or other types of polygons.

CPU may invoke graphics API to communicate the list of drawing primitives e.g. triangles to GPU via GPU driver . Graphics API may comprise a set of software instructions that provide an interface between CPU and GPU . In particular GPU driver may formulate and issue one or more commands that cause GPU to render to drawing primitives to displayable graphics information. The commands may include vertex points of the primitive color information associated with each vertex point of the primitive texture information associated with each vertex point of the primitive scaling information for the primitive rotation information for the primitive and the like. GPU driver may formulate a command that specifies an operation to perform on the primitive. For example GPU driver may formulate a command that indicates to GPU to perform tessellation and or rendering of the curve.

When GPU receives a command from CPU command decoder decodes the command and configures one or more processing elements of GPU to perform the operation specified in the command. Command decoder may additionally store information e.g. primitive or curve information contained within the command in GPU memory or within one or more buffers not shown within GPU . Command decoder may load into each of the processing elements of GPU a set of instructions that cause the processing elements to perform particular graphics processing operations. In the example illustrated in the processing elements of GPU include a vertex shader a geometry shader a rasterizer and a pixel shader . In some instances GPU may also include dedicated tessellation hardware . Other processing elements may also be included in GPU but are not specifically illustrated in for simplicity and ease of illustration.

Vertex shader geometry shader rasterizer and pixel shader operate as a graphics pipeline. When operating as a graphics pipeline vertex shader performs a first set of one or more graphics operations on a first set of input data received from command decoder or GPU memory and outputs a first set of intermediate results to geometry shader . Geometry shader performs a second set of one or more graphics operations on the intermediate results received from vertex shader and outputs a second set of intermediate results to rasterizer . While geometry shader performs the second set of graphics operations vertex shader performs the first set of graphics operations on a second set of initial input data received from command decoder . Graphics processing continues in a similar manner until the graphics image is generated for display.

Moreover GPU may have a highly parallel structure that provides more efficient processing of complex graphics related operations than CPU . Although only one graphics pipeline is illustrated in GPU may include a plurality of similar graphics pipelines that operate on multiple data primitives in parallel. In other words GPU may include a plurality of vertex shaders geometry shaders rasterizers and pixel shaders that may operate on several data primitives in full parallel. Thus highly parallel nature of GPU may in some instances allow GPU to create complex 2D or 3D graphics images on display more quickly than drawing the graphics images directly to display with CPU .

Vertex shader operates on a single vertex at a time. Vertex shader may be configured to receive a sequence of one or more vertex attributes that define a single vertex. Conventional vertex attributes include a position attribute a normal attribute one or more color attributes one or more texture attributes one or more lighting attributes and the like. Moreover vertex shader may be configured to receive one or more custom vertex attributes depending on the graphics operations for which vertex shader is being used. In some instances the number of vertex attributes that can be used to define each vertex may be limited to a particular maximum number of attributes.

Vertex shader may perform a number of graphics operations on the vertex. For example vertex shader may be configured to transform the input vertex into a different coordinate system. In particular vertex shader transforms the position attribute of the vertex received as input from an object coordinate space to a device coordinate space. The object coordinate space represents how a graphics image is defined by the instructions of software application . The device coordinate space represents how the graphics image will be displayed on a device e.g. display . Vertex shader may for example transform the vertex coordinates using affine operations such as rotation translation scaling and the like. In one example vertex shader may transform the vertex coordinates using the equation 

In some instances vertex shader may compute the transform once for the curve. In other words vertex shader may compute the transformation of the equations used to define the curve instead of computing the transformation for every vertex point through the path. In the case of the elliptical arc curve example above vertex shader may transform the curve to define a mathematical representation of the elliptical arc curve after transformation as cos 4 sin 5 where x y is a positional coordinate in the device coordinate space xis a translation along the x axis yis a translation along the y axis and Sf is a scale factor of the transformation. Equations 4 and 5 assume that vertex shader only translates and scales the curve i.e. no rotation of the curve . In some instances CPU may perform the transformation instead of vertex shader .

Vertex shader may perform a number of other operations on the input vertex attributes. Vertex shader may perform one or more operations to change one or more of the color attributes of the vertex one or more of the texture attributes of the vertex one or more of the lighting attributes of the vertex or the like. Vertex shader may be configured to change every vertex in the same way or change only vertices that have certain properties. Thus vertex shader may be configured to perform one set of operations on one vertex and then re configured to perform a different set of operations on the next vertex.

Geometry shader operates on primitives instead of individual vertex points. Geometry shader receives a string of vertex points or attributes that define vertex points and forms the primitives. In the case of a triangle primitive geometry shader may input three sets of vertex attributes that define three vertex points of the triangle primitive. In some cases geometry shader may additionally input vertex attributes for vertex points of adjacent primitives. Geometry shader may discard the primitive or generate one or more new primitives using the vertex attributes of the vertex points of the input primitive. In some cases GPU may not include geometry shader .

Rasterizer converts the primitives output by geometry shader or vertex shader in the case in which there is no geometry shader into pixels based on the vertex attributes. Rasterizer may perform clipping operations on the primitives and prepare the primitives for pixel shader . Rasterizer may determine which of the pixels in the screen are within the geometry of the object and therefore need to be drawn. Additionally rasterizer performs interpolation of the vertex data to generate the pixel data. The output of rasterizer is provided to pixel shader . Pixel shader sometimes referred to as a fragment shader performs graphics operations on each pixel to be displayed on display . Pixel shader may for example perform per pixel texturing fog and coloring operations to generate a color value to display at each pixel location.

In accordance with the techniques of this disclosure GPU may be configured to perform at least a second tessellation stage to tessellate the curve into additional line segments. For example shader or may perform the second tessellation stage to sub divide the portions of the curve represented by the line segments from CPU into additional line segments that more accurately represent the portion of the curve. As another example dedicated tessellation hardware may perform the second tessellation stage to sub divide the portions of the curve represented by the line segments from CPU into additional line segments that more accurately represent the portion of the curve. In either case the second tessellation stage results in the portion of the curve represented by each of the line segments generated by CPU being subdivided into a second set of more detailed line segments or sub segments . Shader or or tessellation hardware tessellates the original curve into additional line segments. In other words shader or or tessellation hardware does not divide the line segments produced by CPU into additional line segments but the actual curve defined by software application . In this manner each portion of the curve that was represented by only one line segment after the first tessellation stage is represented by more than one line segment after the second tessellation stage. The additional line segments result in a better representation of the curve e.g. a higher resolution representation of the curve.

Shader or or tessellation hardware may perform the second tessellation stage based on the amount of scaling performed during the transformation. In particular the number of additional line segments into which shader or or tessellation hardware tessellates the portion of the curve represented by each of the line segments is a function of a scale factor. The scale factor is an approximation of the amount of scaling that occurred during the transformation of the vertex points from the object coordinate space to the device coordinate space. CPU may compute the scale factor and provide it to one or more components of GPU for use in determining the number of additional line segments for the second tessellation stage. CPU may compute the scale factor using any of a variety of different techniques. The techniques may result in different values for the scale factor but all of the resulting values generally represent the amount of scaling performed during the transformation. CPU may compute the scale factor using the transformation matrix. For example CPU may compute the scale factor as a multiplication of Scale x and Scale y i.e. the scaling variables used during the transformation of coordinate spaces. In another example CPU may compute the scaling factor as a maximum value of Scale x and Scale y. In the case of 3D CPU may compute the scale factor by a viewport scale factor and or the transformation matrix.

Shader or or tessellation hardware subdivides the portion of the curve represented by the line segments into more additional line segments as the scale factor increases. Thus the number of additional line segments or sub segments M to tessellate each portion of the curve may be computed as a function of the scale factor. Subdividing the portion of the curve as a function of the scale factor allows shader or or tessellation hardware to preserve more detail of the curve when the curve is scaled heavily while allowing for less detail of the curve when the curve is not scaled or only lightly scaled. In this manner the multi stage tessellation techniques described in this disclosure allow for dynamic tessellation that is adaptive to a resolution requirement of the graphics image. When high resolution is needed e.g. large scaling shader or or tessellation hardware tessellates the curve more and when high resolution is unnecessary e.g. little or no scaling shader or or tessellation hardware tessellates the curve less and GPU processing resources are saved. Thus instead of over tessellating the curve to ensure quality the techniques of this disclosure produce the additional line segments as needed based on the scaling. Therefore no extra line segments are sent through the graphics pipeline thereby improving pipeline performance and power consumption by utilizing the computing resources in a more efficient way.

The number of additional line segments or sub segments to tessellate each portion of the curve into may be loaded into shader or or tessellation hardware as a global constant. Shader or or tessellation hardware tessellates the portion of the curve represented by one of the line segments provided by CPU into M additional line segments. The M additional line segments generated by shader or or tessellation hardware represent a further tessellation of the original curve. Thus instead of representing the portion of the curve with a single line segment generated by CPU the portion of the curve is represented by the M line segments. Again the M sub segments represent tessellations of the original curve and not tessellations of the line segments provided by CPU . In this manner shader or or tessellation hardware further approximates the curve instead of further approximating the line segments provided by CPU .

With respect to the elliptical arc curve defined by equations 1 and 2 above shader or or tessellation hardware may divide the portion of the curve represented by one of the line segments from CPU into additional line segments. For example shader or or tessellation hardware may divide the portion of the curve corresponding with the line segment from the vertex located at 0 to the vertex located at 4 into M additional line segments. If M 4 for example shader or or tessellation hardware further tessellates the portion of the curve from the vertex located at 0 to the vertex located at 4 into four additional line segments. In particular in this example shader or or tessellation hardware may generate four additional line segments that connect vertex points located at 0 16 8 3 16 4. The vertex points of the four additional line segments may be computed using a mathematical representation of the elliptical curve after transformation as provided in equations 4 and 5 above.

GPU may tessellate the other portions of the curve represented by the other seven line segments generated by CPU in a similar manner in full parallel. Thus GPU performs the second tessellation stage on multiple portions of the curve simultaneously. In this manner computing device may utilize a parallel structure of GPU to perform the second tessellation stage for the portions of the curve represented by other ones of the line segments produced by CPU in full parallel. Doing so results in GPU acceleration of the tessellation of the curve thereby improving the rendering performance.

In one instance geometry shader may perform the second tessellation stage of the portions of the curve. As described above geometry shader operates on multiple vertex points e.g. primitives at a time instead of individual vertex. As such geometry shader may output multiple vertex points thereby tessellating the portion of the curve into M additional line segments in a single step. In some cases geometry shader may be configured such that each different portion of the curve is divided into a different number of additional line segments and thus may dynamically tessellate the portion of the curve based on shape of the portion of the curve. Tessellation of the portion of the curve into additional line segments using geometry shader is described in more detail with respect to .

In another instance vertex shader may perform the second tessellation stage of the portions of the curve. This may be the case for example when GPU does not include geometry shader . As described above vertex shader operates on a single vertex at a time and is therefore typically unable to generate additional vertices. Vertex shader may be configured however to input one or more custom vertex attributes to perform the second tessellation stage. In particular vertex shader may be configured such that the vertex attributes that are input to define a vertex actually define a line segment instead of a single vertex of the line segment. In this manner vertex shader may be viewed as inputting a virtual vertex since it does not actually represent a single vertex. For example vertex shader may be configured to input vertex attributes that include a start vertex attribute and an end vertex attribute of the line segment. The start vertex attribute represents the vertex at which the line segment begins and the end vertex attribute represents the vertex at which the line segment ends. Vertex shader operates on the start vertex attribute and the end vertex attribute to tessellate the portion of the curve into additional line segments. An example of tessellation of the portion of the curve into additional line segments using vertex shader is described in more detail with respect to .

In another instance pixel shader may perform the second tessellation stage of the portions of the curve. Like the vertex shader pixel shader operates on a single pixel at a time. Thus pixel shader is configured to input one or more custom pixel attributes that define a line segment instead of a single pixel of the line segment. Pixel shader generates additional pixel attributes that further define additional line segments.

In another instance tessellation hardware may perform the second tessellation stage of the portions of the curve. Tessellation hardware may for example include one or more multiply and accumulation MAC operation units to perform the second tessellation stage. In one instance tessellation hardware may be formed of a pipelined array of MAC operation units that are configurable to compute polynomials of different degrees as described in detail below. In this case tessellation hardware inputs polynomial coefficients and at least one location along the curve at which to generate vertex points from CPU . The locations along the curve at which to generate vertex points may for example be a value of t in the case of Bezier curves or a value of in the case of elliptical arc curves. The MAC operation units of tessellation hardware operate on the polynomial coefficients to generate one or more coordinates of vertex points at the particular locations. Operation of tessellation hardware is substantially similar to that of tessellation hardware circuitry described in detail below.

Although the multi stage tessellation described above is distributed between CPU and GPU the multi stage tessellation may be performed within GPU and or distributed between GPU and dedicated tessellation hardware e.g. tessellation hardware illustrated in . Thus CPU does not have to perform any tessellation of the curve. Instead a first computing unit within GPU performs the first tessellation stage to divide the curve into line segments and a second computing unit with GPU performs the second tessellation stage to further divide the curve into additional line segments. For example the tessellation may be divided between any combination of vertex shader geometry shader pixel shader and tessellation hardware or between those components and dedicated tessellation hardware e.g. tessellation hardware .

Although the multi stage tessellation technique is described above as including two stages the multi stage tessellation technique may include more than two stages. For example the multi stage tessellation may include a first tessellation stage may tessellate the curve into a first set of line segments a second tessellation stage that tessellates the portion of the curve represented by each of the first set of line segments into second sets of line segments and a third tessellation stage that tessellates the portion of the curve represented by each of the second set of line segments into additional line segments. Any number of tessellation stages may be performed. The tessellation stages may be distributed between any of CPU vertex shader geometry shader pixel shader and or tessellation hardware .

The architecture illustrated in is merely exemplary as the techniques described in this disclosure may be implemented with a variety of other architectures. For example GPU may utilize a single shader core that may perform the functions attributed to vertex shader geometry shader and pixel shader . The single shader core may for example be configured by command decoder to function as vertex shader geometry shader and pixel shader based on the stage of the pipeline at which the graphics operations are at. As another example tessellation hardware may not be located within GPU but instead be a separate component of computing device and coupled to GPU via bus as illustrated in . Moreover the features illustrated in may be realized by any suitable combination of hardware and or software components.

A first computing unit tessellates Bezier curve segment A i.e. the portion of curve between point A and point B into a plurality of line segments A G collectively line segments . illustrates Bezier curve segment A after tessellation by the first computing unit. In one instance the first computing unit that performs the first tessellation stage may be tessellation module of CPU . In other instances the first computing unit may be one of shaders or or tessellation hardware . In the example illustrated in the first computing unit tessellates Bezier curve segment A into seven line segments . In particular the first computing unit computes vertex points along Bezier curve segment A using equations 6 and 7 above.

When the first computing unit is tessellation module tessellation load controller may configure tessellation module to tessellate the curve into a particular number of line segments as a function of the load of CPU the load of GPU or a combination thereof. Tessellation load controller may for example increase the number of line segments generated by tessellation module when the load of CPU is less than or equal to a threshold and decrease the number of line segments when the load of CPU exceeds the threshold. In the example illustrated in tessellation load controller configures tessellation module to tessellate Bezier curve segment A into seven line segments . Tessellation load controller may configure tessellation module to tessellate Bezier curve segment A into more line segments or less line segments using the tessellation load balancing techniques described above. In the example of line segments coarsely represent the shape of the curve i.e. Bezier curve segment A.

To tessellate Bezier curve segment A into line segments the first computing unit computes one or more vertex points between start point x y which is equal to vertex point A and end point x y which is equal to vertex point A. To do so the first computing unit may use the equations that represent Bezier curve segment A i.e. equations 6 and 7 to compute the vertex points between A i.e. A and A i.e. B . In the example illustrated in the first computing unit computes vertex points A A. Aand Aare already known as they are equal to start point x y and end point x y respectively.

The first computing unit then represents Bezier curve segment A as a plurality of line segments between the generated vertex points. In particular the first computing unit represents Bezier curve segment A as line segment A from vertex point A which is the same as point A of to vertex point A line segment B from vertex point Ato vertex point A line segment C from vertex point Ato vertex point Aand so on.

In the example illustrated in the first computing unit equally divides Bezier curve segment A into line segments . In other words the first computing unit incrementally increases t by a constant step size. In some instances however the first computing unit may use adaptive tessellation techniques to tessellate Bezier curve segment A based on a shape of the curve i.e. with different step sizes for each line segment. For example the first computing unit may increment t with a smaller step size when the curvature of the curve is bigger e.g. between vertex points Aand Ain the example and increment t with a larger step size when the curvature of the curve is smaller e.g. between points Aand A .

Rendering line segments without any further tessellation may result in a poor image quality for some portions of Bezier curve A especially between vertex point Aand A. This is particularly true when the curve is zoomed in to a high resolution e.g. upon application of a large scale factor during transformation by GPU into the device coordinate space. Therefore a second computing unit performs a second tessellation stage to tessellate Bezier curve segment A into additional line segments. The second computing unit may for example be one of shaders or or tessellation hardware . As will be described in more detail below the second tessellation stage tessellates the portions of Bezier curve segment A represented by line segments instead of actually tessellating line segments . Tessellation of Bezier curve segment A into additional line segments will be described with respect to tessellation of a portion of the Bezier curve segment A represented by line segment A for example purposes. However the second computing unit may tessellate line segments B G in a similar fashion in full parallel.

Prior to performing the second tessellation stage vertex shader of GPU or CPU transforms the curve from an object coordinate space to a device coordinate space. Vertex shader or CPU may for example transform the points defining the curve using the equation 3 above instead of converting each vertex point of each line segment. Vertex shader or CPU may transform the start point x y the end point x y and internal control points x y and x y into the device coordinate space x y x y x y and x y . In this manner the portion of Bezier curve A is transformed into the device coordinate space and can be defined as 1 3 1 3 1 8 1 3 1 3 1 9 

After the transformation the second computing unit performs a second tessellation stage to tessellate the portion of Bezier curve segment A represented by line segment A i.e. the portion of Bezier curve segment A from Ato A into additional line segments. The portion of Bezier curve segment A represented by line segment A is the portion of Bezier curve segment A between vertex points Aand A. In the example illustrated in the second computing unit tessellates the portion of Bezier curve segment A between vertex points Aand Ainto four line segments. In particular the second computing unit generates vertex points A Aand Abetween vertex points Aand A. The second tessellation stage results in the portion of Bezier curve segment A between vertex points Aand Abeing represented by four line segments instead of only a single line segment thus providing more detail with respect to the portion of the curve. As illustrated in the additional line segments generated during the second tessellation stage provide a better representation of the curve particularly between vertex point Aand A.

In one aspect the number of additional line segments into which the second computing unit tessellates the portion of the curve represented by each of the line segments may be a function of a scale factor. The second computing unit subdivides the portion of the curve represented by the line segments into more additional line segments as the scale factor increases. Subdividing the portion of the curve as a function of the scale factor allows the second computing unit to preserve more detail of the curve when the curve is scaled heavily while allowing for less detail of the curve when the curve is not scaled or only lightly scaled.

The techniques may be applied in a similar manner to other curves defined in OpenVG such as elliptical arc curves defined in accordance with equations 1 and 2 or quadratic Bezier curves that include a start point at x y an end point x y and a control point x y and can be defined in the object coordinate space as 1 2 1 10 1 2 1 11 Moreover the techniques may be utilized with any curve definitions that are added to the OpenVG standard through any extensions. Likewise the techniques may be used to tessellate curves defined using other graphics authoring standards.

A first computing unit tessellates Bezier curve segment A i.e. the portion of curve between point A and point B into a plurality of line segments A G collectively line segments . In one instance the first computing unit that performs the first tessellation stage may be tessellation module of CPU . In other instances the first computing unit may be one of shaders or or tessellation hardware . illustrates Bezier curve segment A after tessellation by the first computing unit. In the example illustrated in the first computing unit computes vertex points A Ato tessellate Bezier curve segment A into seven line segments A G that connect each of the vertex points with neighboring vertex points.

As described above in rendering line segments without any further tessellation may result in a poor image quality for at least some portions of Bezier curve A especially between vertex point Aand A. Therefore a second computing device performs a second tessellation stage to tessellate Bezier curve segment A into additional line segments. Tessellation of Bezier curve segment A into additional line segments will be described with respect to tessellation of a portion of the Bezier curve segment A represented by line segment A for example purposes. However the second computing device may tessellate the portions of Bezier curve segment A represented by line segments B G in a similar fashion in full parallel.

Prior to performing the second tessellation stage vertex shader or some other component of GPU or CPU transforms Bezier curve segment A from an object coordinate space to a device coordinate space to generate the mathematical representations defined in equations 10 and 11 above. After transformation into the device coordinate space a second computing unit performs a second tessellation stage to tessellate the portion of Bezier curve segment A represented by line segment A i.e. the portion of Bezier curve segment A from Ato A into additional line segments.

In the case of a vertex shader for example vertex shader may be configured to input vertex attributes that actually define a line segment instead of a single vertex of the line segment. For example vertex shader may be configured to input vertex attributes that include a start vertex attribute e.g. A and an end vertex attribute e.g. A of the line segment that represent the vertex at which the line segment begins and ends respectively. Vertex shader may compute at least one additional vertex between vertex Aand A. As described above the number of vertex attributes that can be used to define each vertex may be limited to a particular maximum number of attributes. Therefore vertex shader may only be able to compute a limited number of additional vertex points in a single pass. illustrates Bezier curve segment A after the second tessellation stage. In the example illustrated in vertex shader may only be able to compute one additional vertex attribute representing a new vertex point A. Therefore vertex shader may only tessellate the portion of Bezier curve A into one additional set of line segments. In other instances however vertex shader may compute more than one additional vertex attribute per pass.

In some cases the maximum number of available vertex attributes may be sufficient to fully tessellate the portion of Bezier curve segment A. If the maximum number of available vertex attributes is not sufficient however vertex shader may compute more additional line segments recursively i.e. by performing a third tessellation stage. In other words vertex shader may perform more than one tessellation stage recursively i.e. a second tessellation stage followed by a third tessellation stage. For example after the second tessellation stage vertex shader may input a new set of vertex attributes that include a start vertex attribute Aand an end vertex attribute Athat represent the line segment generated during the second tessellation stage. Vertex shader computes at least one additional vertex between vertex Aand Aduring the third tessellation stage. illustrates Bezier curve segment A after the third tessellation stage by vertex shader . In the example illustrated in vertex shader has now tessellated the portion of Bezier curve A between Aand Ainto four line segments instead of one line segment. In this manner vertex shader may recursively tessellate the portion of the curve into additional line segments that provide a better representation of curve A particularly between vertex point Aand A. Although in the example described above vertex shader performs the second and third tessellation stages other computing units of GPU may perform the second and the third tessellation stage. For example the second and third tessellation stages may be performed by any combination of vertex shader geometry shader pixel shader and tessellation hardware .

The first computing unit provides the line segments to a second computing unit . When the first computing unit is tessellation module for example tessellation module may generate a list of drawing primitives using the vertex points of the line segments and provide the drawing primitives to GPU via graphics API and GPU driver . Tessellation module may generate any of a number of drawing primitives including points line strips line loops separate lines triangle strips triangle fans separate triangles quadrilateral strips separate quadrilaterals or other types of polygons.

The first or second computing unit transforms the curve from an object coordinate space to a device coordinate space . For example vertex shader of GPU may transform the curve into the device coordinate space using equation 3 above. The transformation may be computed once per curve. In other words the transformation may be computed at each of the points used to define the curve instead of computing the transformation for every vertex point through the path. The first or second computing unit computes a scale factor that represents the amount of scaling performed in the transformation . The scale factor may be computed based on the scaling variables used in the transformation e.g. Scale x and Scale y of equation 3 .

The second computing unit performs a second tessellation stage to tessellate the portions of the curve into additional line segments . The second computing unit may for example be one of the components of GPU . Thus GPU computes additional vertex points between each of the vertex points of each line segment computed by the first computing unit. The additional vertex points may be computed using a mathematical representation of the curve in the device coordinate space e.g. after transformation. GPU therefore represents each of the portions of the curve represented by the line segments produced by the first computing unit with a plurality of line segments instead of the single line segment generated by the first computing unit. In this manner the second tessellation stage performed by GPU produces additional line segments of the curve to more accurately represent the curve. In some instances the number of additional line segments generated for the portions of the curve may be a function of the scale factor such that as the scale factor increases more additional line segments are computed to preserve more detail.

GPU may perform the second tessellation stage using one or more shaders e.g. vertex shader geometry shader or pixel shader . The shaders of GPU may tessellate more than one portion of the curve in parallel. Thus GPU performs the second tessellation stage on multiple portions of the curve simultaneously. Doing so results in GPU acceleration of the tessellation of the curve thereby improving the rendering performance. In other instances tessellation hardware within GPU may perform the second tessellation stage. In other instances tessellation hardware external to GPU may perform the second tessellation stage e.g. tessellation hardware of . After performing the second tessellation stage GPU renders the curve to the display using the tessellated line segments . Although the flow diagram of is described as a two stage tessellation the techniques may be expanded to include more than two tessellation stages.

Vertex shader computes coordinates of an additional vertex point between vertex Aand Ato tessellate the curve into an additional line segment . Vertex shader may compute the additional vertex point as another vertex attribute. Vertex shader may compute the coordinates of the additional vertex point between vertex point Aand Ausing a mathematical representation of the curve in the device coordinate space e.g. after transformation. Vertex shader determines whether vertex shader has tessellated the portion of the curve into the desired number of additional line segments M .

If the desired number of line segments generated by vertex shader during the first pass is less than M vertex shader determines whether a maximum number of vertex attributes has been reached . As described above the number of vertex attributes may be limited to a particular maximum number of vertex attributes. Therefore vertex shader may only be able to compute a limited number of additional vertex points in a single pass.

If the maximum number of vertex attributes has not been reached vertex shader computes another coordinate of an additional vertex point . If the maximum number of vertex attributes has been reached however vertex shader outputs the computed vertex attributes . Vertex shader may input a new set of vertex attributes that represents one of the additional line segments generated during the first pass . In other words the maximum number of available vertex attributes was not sufficient to generate enough additional vertex points to fully tessellate the portion of curve. Vertex shader may therefore computes more additional line segments recursively i.e. by performing more than one tessellation stage.

If the desired number of line segments generated during the first pass is greater than or equal to M vertex shader outputs the computed vertex attributes . In other words the maximum number of available vertex attributes was sufficient to generate enough additional vertex points to fully tessellate the portion of curve. Vertex shader then inputs a plurality of vertex attributes that represents another line segment generated by CPU .

To render a curve to display CPU performs a first tessellation stage to divide the curve into a first set of line segments that each represents a portion of the curve as described in detail above. In particular CPU computes vertex points along the curve that define the line segments. CPU may compute the vertex points using equations associated with the type of curve e.g. using equations 1 and 2 in the case of an elliptical arc curve equations 6 and 7 in the case of a cubic Bezier curve or equations 10 and 11 in the case of a quadratic Bezier curve. The amount of tessellation performed by CPU during the first tessellation stage may vary as a function of a processing load on CPU . CPU may include all features of CPU illustrated in .

During a second tessellation stage tessellation hardware circuitry tessellates the portion of the curve represented by each of the line segments into additional line segments that more finely represent the shape of the curve. Tessellation hardware circuitry may for example include one or more multiply and accumulation MAC operation units to perform the second tessellation stage. In one instance tessellation hardware circuitry may be formed of a pipelined array of MAC operation units that are configurable to compute polynomials of different degrees as described in detail below. In this case tessellation hardware circuitry inputs polynomial coefficients and at least one location along the curve at which to generate vertex points from CPU . The locations along the curve at which to generate vertex points may for example be a value of t in the case of Bezier curves or a value of in the case of elliptical arc curves. The MAC operation units of tessellation hardware circuitry operate on the polynomial coefficients to generate one or more coordinates of vertex points at the particular locations.

CPU may compute an expanded polynomial representation of the curve to determine the polynomial coefficients to load into tessellation hardware circuitry . In other words CPU may represent the curve as expanded polynomial p x 12 where Kis the polynomial coefficient of the idegree term of the polynomial x is a variable i 0 1 . . . n 1 n and n is the degree of the polynomial. CPU may compute the expanded polynomial representation of the curve using polynomial expansion. For example CPU may perform polynomial expansion on equations 10 and 11 to compute an expanded polynomial representation of a quadratic Bezier curve as 13 14 where P P P P P and Pare polynomial coefficients defined as P x 2 x x P 2 x x P x P y 2 y y P 2 y y and P y. In other instances CPU may compute the polynomial representation using any of a number of polynomial approximation algorithms. In the case of an elliptical arc curve defined using equations 1 and 2 CPU may compute a polynomial representation using Taylor expansion least squares approximation or another approximation technique. For example CPU may compute an expanded polynomial representation for the elliptical arc curve by approximating sin with the polynomial S S Sand cos with the polynomial C C C where S S S C Cand Care polynomial coefficients computed using the particular approximation technique.

In addition CPU may transform the curve from the object coordinate space to the device coordinate space in accordance with equation 3 above. CPU may transform the curve from the object coordinate space to the device coordinate space either prior to computing the polynomial representation of the curve or after computing the polynomial representation of the curve. As described above CPU may compute the transformation once per curve. In other words CPU may compute the transformation at each of the points used to define the curve instead of computing the transformation for every vertex point along the curve. In the case of a quadratic Bezier curve for example CPU may compute the transformation of the start point x y end point x y and control point x y instead of computing the transformation for each of the computed vertex points of the first set of line segments. In other instances tessellation hardware circuitry or some other component of computing device may perform the transformation.

During the transformation CPU may determine a scale factor that approximates the amount of scaling performed during the transformation. In some instances the degree of tessellation that occurs during the second tessellation stage may be a function of the scale factor. For example CPU may compute the number of additional line segments to tessellate each portion of the curve into based on the scale factor. After CPU computes the number of additional line segments to tessellate each portion of the curve into CPU determines locations along the portion of the curve at which to generate a new vertex point. For a portion of an elliptical curve from 0 to 4 that is to be divided into four additional line segments for example CPU may determine that new vertices need to be computed at locations 16 8 3 16 to equally divide the portion of the curve from 0 to 4 into four additional line segments.

CPU provides tessellation hardware circuitry with the polynomial coefficients for the expanded polynomial representation of the curve and one or more locations on the curve at which to generate coordinates of vertex points. In the elliptical arc curve example described above the locations on the curve at which to generate coordinates of new vertex points are the values of and or a decimal approximation of those values. CPU may directly load the computed polynomial coefficients and the locations into tessellation hardware circuitry or program a pointer into tessellation hardware circuitry in which case tessellation hardware circuitry loads the polynomial coefficients and the locations. In either case the polynomial coefficients and locations are dynamically loaded into tessellation hardware circuitry based on the type of curve that is being tessellated.

As will be described in detail below tessellation hardware circuitry computes the coordinates of the vertex points at the specified locations using the polynomial coefficients and the locations specified by CPU . In this manner computing device may utilize tessellation hardware circuitry to offload a portion of the tessellation workload from CPU to tessellation hardware circuitry . In some instances tessellation hardware circuitry may perform all of the tessellation e.g. when CPU is experiencing high processing load. Tessellation hardware circuitry may output the coordinates of the vertex points to CPU which may perform additional graphics rendering operations for presentation of the curve on display . Alternatively CPU or tessellation hardware circuitry may store the new vertex points in device memory for later processing. In instances in which tessellation hardware circuitry is within GPU such as illustrated in tessellation hardware circuitry may output the coordinates of the vertex points to other components such as vertex shader geometry shader or pixel shader of GPU .

A number of other elements may also be included in computing device but are not specifically illustrated in for simplicity and ease of illustration. For example computing device may include a GPU such as GPU of coupled to the other components via bus . Moreover the architecture illustrated in is merely exemplary as the techniques described in this disclosure may be implemented with a variety of other architectures.

MUXs provide tessellation hardware circuitry with configurability. In particular MUXs may be configured to output one of two inputs. The input represented by the solid line to each of the MUXs corresponds to the input that MUXs will pass through. In other words the value of each of the inputs that is shown in a solid line is the value that each of the MUXs will respectively output. The input represented as the dotted line to each of the MUXs corresponds to the input that the MUXs will not pass through. Tessellation hardware circuitry may therefore be configured by changing the MUX inputs that will be passed through by MUXs as described in more detail with respect to .

Tessellation hardware circuitry illustrated in is a six stage configurable MAC array that may be configured to compute up to a sixth degree polynomial. Tessellation hardware circuitry may be configured into multiple shorter pipelines that compute polynomials of smaller degrees. For example the six stage configurable MAC array illustrated in may be configured to operate as two parallel three stage MAC arrays that each computes a third degree polynomial three parallel two stage MAC arrays that each computes a second degree polynomial or the like. In this manner tessellation hardware circuitry may be configured to provide hardware acceleration during the tessellation process thus resulting in improved rendering performance. Although illustrated as a six stage configurable MAC array tessellation hardware circuitry may include more or fewer configurable pipelined MAC stages.

Tessellation hardware circuitry may be dynamically re configured in run time based on the type of curve being tessellated. For example when tessellating a quadratic Bezier curve or an elliptical arc curve which are represented as second degree polynomials CPU may configure tessellation hardware circuitry to operate as three parallel two stage MAC arrays. When tessellating a cubic Bezier curve which is represented as a third degree polynomial CPU may configure tessellation hardware circuitry to operate as two parallel three stage MAC arrays.

Tessellation hardware circuitry receives from CPU polynomial coefficients P P for use in computing vertex points. The polynomial coefficients may be either polynomial coefficients for computing an x coordinate of the vertex point or the polynomial coefficients for computing a y coordinate of the vertex point. In instances in which tessellation hardware circuitry operates as more than one multi stage MAC array the polynomial coefficients may polynomial coefficients for computing the x coordinates and the y coordinates of the vertex point. As described above CPU computes the polynomial coefficients P P and provides the computed polynomial coefficients P P to tessellation hardware circuitry . CPU may directly load the computed polynomial coefficients P P into tessellation hardware circuitry or program a pointer into tessellation hardware circuitry in which case tessellation hardware circuitry loads the polynomial coefficients P P. In either case the polynomial coefficients P P are dynamically loaded based on the type of curve that is being tessellated.

Moreover CPU provides tessellation hardware circuitry with an input I that corresponds with a location along the curve at which a vertex point is to be generated. In the case of an elliptical arc curve defined using OpenVG the input may be a particular value of . In the case of a Bezier curve defined using OpenVG the input may be a particular value of t. Tessellation hardware circuitry performs the various multiplication and accumulation operations on the input using the polynomial coefficients P P to compute an output O . The output represents a coordinate e.g. an x coordinate or y coordinate of a vertex point at the location along the curve identified by the input. Tessellation hardware circuitry outputs a sixth degree polynomial of the form 6543210. 15 

Tessellation hardware circuitry continues to receive input locations along the curve and polynomial coefficients until tessellation hardware circuitry computes vertex points of the desired number of line segments are generated. For a portion of an elliptical curve from 0 to 4 that is to be divided into four additional line segments for example CPU may provide tessellation hardware circuitry with inputs 16 8 3 16 to generate vertex points for equally dividing the portion of the curve from 0 to 4 into four additional line segments.

Tessellation hardware circuitry computes two coordinates using inputs Iand Iand polynomial coefficients P P P P P P P and P. In one instances tessellation hardware circuitry may compute two coordinates that define a vertex point at location I. In other words tessellation hardware circuitry may compute an x coordinate and a y coordinate i.e. x y that define the vertex point at location I. In this case inputs Iand Iare equal and polynomial coefficients P P P and P correspond with polynomial coefficients of a polynomial for computing the x coordinate and polynomial coefficients P P P and P correspond with polynomial coefficients of a polynomial for computing the y coordinate.

In other instances tessellation hardware circuitry may compute two coordinates corresponding with different vertex points. For example tessellation hardware circuitry may compute two x coordinates that represent the x coordinates of two vertex points at different locations Iand Ialong the curve. In this case Iand Iare not equal and polynomial coefficients P P P and P and polynomial coefficients P P P and P both correspond with polynomial coefficients of a polynomial for computing the x coordinate. After computing the x coordinates for the vertex points tessellation hardware inputs coefficients associated with the y coordinates of the vertex points and compute y coordinates for the vertex points of the various locations I along the curve. In either case tessellation hardware circuitry provides hardware acceleration during the tessellation process by outputting two coordinate values for the vertex points in a single pass.

Tessellation hardware circuitry computes three coordinates using inputs I Iand I and polynomial coefficients P P P P P P P P and P. As described above tessellation hardware circuitry may compute three coordinates corresponding with different vertex points. For example tessellation hardware circuitry may compute three x coordinates that represent the x coordinates of three vertex points at different locations I Iand Ialong the curve. In this case I Iand Iare not equal and polynomial coefficients P P P polynomial coefficients P P and P and polynomial coefficients P P and P each correspond with polynomial coefficients of a second degree polynomial for computing the x coordinate. After computing the x coordinates for the vertex points tessellation hardware inputs coefficients associated with the y coordinates of the vertex points and compute y coordinates for the vertex points at I Iand Ialong the curve.

Alternatively tessellation hardware circuitry may compute a combination of both x coordinates and y coordinates of vertex points along the curve. In other words tessellation hardware circuitry may compute two x coordinates and a y coordinate or two y coordinates and an x coordinate at various locations I along the curve. In this case inputs Iand Iare equal and polynomial coefficients P P and P correspond with polynomial coefficients of a polynomial for computing the x coordinate and polynomial coefficients P P and P correspond with polynomial coefficients of a polynomial for computing the y coordinate. Ion the other hand is different than Iand Iand the polynomial coefficients P P and P may be either polynomial coefficients for the x coordinate or the y coordinate. In either case tessellation hardware circuitry provides hardware acceleration during the tessellation process by outputting three coordinate values for the vertex points in a single pass.

CPU computes an expanded polynomial representation of the curve . CPU may for example compute an expanded polynomial representation of an elliptical arc curve defined in accordance with equations 1 and 2 by approximating sin with the polynomial S S Sand cos with the polynomial C C C. The expanded polynomial representations are provided below. 21 22 where P P P P P and Pare polynomial coefficients defined as P a C2 P a C1 P a C0 P b C2 P b C1 and P b C0.

In addition CPU may transform the curve from the object coordinate space to the device coordinate space . CPU may transform to the device coordinate space either prior to computing the polynomial representation of the curve or after computing the polynomial representation of the curve. As described above CPU may compute the transformation once per curve. In other words CPU may compute the transformation at each of the points used to define the curve instead of computing the transformation for every vertex point along the curve. In the case of a quadratic Bezier curve for example CPU may compute the transformation of the start point start point x y end point x y and control point x y instead of computing the transformation for each of the computed vertex points of the first set of line segments. In other instances tessellation hardware circuitry or some other component of computing device may perform the transformation.

During the transformation CPU may determine a scale factor that approximates the amount of scaling performed during the transformation . CPU determines the number of additional line segments for the second tessellation stage based on the scale factor . In particular CPU may determine that the second tessellation stage subdivides the portion of the curve represented by the line segments into more additional line segments as the scale factor increases. After CPU computes the number of additional line segments to tessellate each portion of the curve into CPU determines locations along the portion of the curve at which to generate a new vertex point . For a portion of an elliptical curve from 0 to 4 that is to be divided into four additional line segments for example CPU may determine that new vertices need to be computed at locations 16 8 3 16 to equally divide the portion of the curve from 0 to 4 into four additional line segments.

CPU configures tessellation hardware circuitry to tessellate the curve . CPU may for example provide tessellation hardware circuitry with the polynomial coefficients for the expanded polynomial representation of the curve. CPU may directly load the computed polynomial coefficients or program a pointer into tessellation hardware circuitry in which case tessellation hardware circuitry loads the polynomial coefficients and the locations. In either case the polynomial coefficients are dynamically loaded into tessellation hardware circuitry based on the type of curve that is being tessellated e.g. an elliptical arc curve a quadratic Bezier curve a cubic Bezier curve or the like.

CPU provides tessellation hardware circuitry with one or more inputs that identify locations along the curve at which to generate coordinates of one or more vertex points . As described above tessellation hardware circuitry may be configured to operate as two parallel three stage MAC arrays that each computes a coordinate of a vertex point or be configured to operate as three parallel two stage MAC arrays that each computes a coordinate of a vertex point. Tessellation hardware circuitry may be configured to compute x coordinates of more than one vertex point y coordinates of more than one vertex point an x coordinates and y coordinate of the same vertex point or a combination thereof.

CPU receives the one or more coordinates computed by tessellation hardware . CPU determines whether there are more coordinates to compute for the vertex points . When there are more coordinates to compute for the vertex points CPU continues to configure tessellation hardware circuitry and provide input for computing the additional coordinates. When there are no more coordinates to compute CPU renders the curve to the display using the tessellated line segments .

The techniques described herein may be implemented in hardware software firmware or any combination thereof. Any features described as modules or components may be implemented together in an integrated logic device or separately as discrete but interoperable logic devices. In some cases various features may be implemented as an integrated circuit device such as an integrated circuit chip or chipset. If implemented in software the techniques may be realized at least in part by a computer readable medium comprising instructions that when executed performs one or more of the methods described above. The computer readable medium may form part of a computer program product which may include packaging materials. The computer readable medium may comprise random access memory RAM such as synchronous dynamic random access memory SDRAM read only memory ROM non volatile random access memory NVRAM electrically erasable programmable read only memory EEPROM FLASH memory magnetic or optical data storage media and the like. The techniques additionally or alternatively may be realized at least in part by a computer readable communication medium that carries or communicates code in the form of instructions or data structures and that can be accessed read and or executed by a computer.

The code may be executed by one or more processors such as one or more DSPs general purpose microprocessors ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition in some aspects the functionality described herein may be provided within dedicated software applications or hardware modules configured for tessellating graphics images. Hence the disclosure also contemplates any of a variety of integrated circuit devices that include circuitry to implement one or more of the techniques described in this disclosure. Such circuitry may be provided in a single integrated circuit chip or in multiple interoperable integrated circuit chips.

Various aspects have been described. These and other aspects are within the scope of the following claims.

