---

title: Probabilistic mesh routing
abstract: Routing messages using unreliable routing data. A method includes receiving a message from a computer readable communication medium. Characteristic properties of the message are calculated so as to determine state requirements for a service instance at a service for processing of the message. An attempt is made to acquire an appropriate service instance that satisfies the state requirements for processing the message. A determination is made that attempting to acquire an appropriate service instance that satisfies the state requirements for processing the message is not successful at acquiring an appropriate service instance. As a result, the message is redirected using an unreliable local cache of routing information and without coordination between processing nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099498&OS=08099498&RS=08099498
owner: Microsoft Corporation
number: 08099498
owner_city: Redmond
owner_country: US
publication_date: 20080903
---
Computers and computing systems have affected nearly every aspect of modern living. Computers are generally involved in work recreation healthcare transportation entertainment household management etc.

Further computing system functionality can be enhanced by a computing systems ability to be interconnected to other computing systems via network connections. Network connections may include but are not limited to connections via wired or wireless Ethernet cellular connections or even computer to computer connections through serial parallel USB or other connections. The connections allow a computing system to access services at other computing systems and to quickly and efficiently receive application data from other computing system.

Messages can be routed between networked computers using a message processing system. A simple arrangement for a message processing system includes a service running on a single machine that directly receives messages from client machines. As the amount of resources required by the service grows either by increasing the number of messages or the average cost of processing a message it eventually may become impractically expensive to construct a single machine that can handle the processing load. One common practice is to execute multiple instances of a service across several machines so that the processing load is distributed among many cheaper machines. Distributing the processing load among many machines might also be used to eliminate critical points so as to improve overall system reliability.

The parallel efficiency of a system measures how effective it is to add more machines. When the parallel efficiency is 100 doubling the number of machines halves the processing load for each machine. The parallel efficiency may be a smaller percentage zero or even negative. A negative parallel efficiency means that the overhead of adding machines is larger than the gain in total processing power. Coordination between the processing machines is one of the common causes of poor parallel efficiency. For example before a message is routed to a service in a topology including a number of services it may be necessary to ensure that the service has the necessary state information to handle the message. Illustratively a state bag with state information for a particular e commerce shopping cart may be loaded at a particular service in a topology. A message updating the shopping cart such as adding new items removing items completing an order etc may be received at the topology. If multiple services in the topology can handle shopping cart functionality there may be a need at the topology to determine which of the services includes the state bag for the particular shopping cart in question.

There are many examples of services in which messages can be processed independently. Message independence allows a message to be sent to any available processing node. There are also examples of services that have an obvious association between messages and processing nodes. An obvious association permits routing an incoming message to the appropriate processing node with a low level of coordination. An example of an obvious association is for a network connection to exactly equal the boundary of a set of messages that must be processed together. However there are many examples where association overhead may be needed to coordinate messages and services.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.

One embodiment described herein is directed to a method of routing messages using unreliable routing data. The method may be practiced at a processing node in a computing environment. The method includes receiving a message from a computer readable communication medium. One or more characteristic properties of the message are calculated so as to determine state requirements for a service instance at a service for processing of the message. An attempt is made to acquire an appropriate service instance that satisfies the state requirements for processing the message. When attempting to acquire an appropriate service instance that satisfies the state requirements for processing the message is successful at acquiring an appropriate service instance the message is processed based on the state requirements. The method includes determining that attempting to acquire an appropriate service instance that satisfies the state requirements for processing the message is not successful at acquiring an appropriate service instance. As a result the message is redirected using an unreliable local cache of routing information and without coordination between processing nodes so as to attempt to cause the message to reach a server node that has an appropriate service instance or that can successfully acquire an appropriate service instance that satisfies the state requirements for processing of the message.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Additional features and advantages will be set forth in the description which follows and in part will be obvious from the description or may be learned by the practice of the teachings herein. Features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

Some embodiments are directed to services in which there is some non obvious association between messages and processing nodes. For example one example of a non obvious association is based on content in the message whose location and format depend on application defined protocols and or whose value reflects content seen in previous messages.

Some embodiments reduce the level of coordination for non obvious associations by making the processing nodes tolerant of routing errors and employing optimistic routing. An incorrect routing decision will be detected during later processing. In response to an incorrectly routed message partially completed work is discarded and the message is rerouted again in an optimistic fashion. Additionally information may be returned to a node that incorrectly routed a message such that future messages routed by that node will likely be routed correctly. Although some messages may require more work to process due to encountering routing errors the average cost of processing a message decreases because the optimistic routing can be made frequently correct and coordination between nodes can be reduced.

As noted some embodiments allow for routing a message based on a characteristic property of the message without coordination between processing nodes by using a best guess. This may be accomplished by maintaining an unreliable local cache of routing data. The unreliable local cache of routing data may include for example an association between message characteristics message metadata characteristics or other characteristics with service nodes. Further the routing data may include updates based on received redirect messages. For example nodes that incorrectly receive messages may be able to provide information identifying the correct node for the data. Embodiments may also include functionality for deciding how to handle the redirect message based on the original message delivery mechanism or characteristic. Further routing may include incorporating a load balancing mechanism as part of the definition for best guess routing.

Some embodiments may include an atomic create load primitive implemented by an instance coordinator based on a characteristic property of a message. For example additional associations may be supplied between characteristics and a service instance as part of the atomic create load operation Lookups performed to supply associations may be based on more than one characteristic. Further optimization of lookup may be accomplished by using a local catalog of service instances. More detailed descriptions of these embodiments will be included herein further below.

Embodiments may include functionality for generating a redirect message as an outcome of a failed create load operation. In some embodiments the redirect address may be resolved using a directory service or discovery protocol. Further routing data for other service instances may be included as part of the redirect message.

Referring now to a network of interconnected processing nodes is illustrated. The processing nodes may be implemented using computing hardware and software including appropriate processors memory devices computer storage computer executable instructions implemented on computer readable media as defined later herein etc. Some of the processing nodes are capable of executing instances of an application service. Some processing nodes are referred to herein as server nodes and are illustrated by the example server nodes and illustrated in . Some processing nodes are capable of routing messages among the processing nodes. These nodes are referred to herein as router nodes and are illustrated by the router node . Over time and without coordination there may be changes to the number of nodes the connections between nodes or the role of a node e.g. gaining or losing the router or server capabilities . Therefore any depiction of the network represents a snapshot of a particular moment in time. The processing nodes are not necessarily permanently partitioned into routers and servers. In particular a processing node may function as both illustrated by router server node which may be referred to herein as a router node or a server node or as neither.

An application including one or more service instances designated herein generally by and specifically by X where X is a variable for indicating a particular service instances executes on the network . The application may create and destroy service instances on an ongoing basis. Thus the current set of service instances may continuously change. A service instance processes messages and over time may accumulate instance state. In the present example a service instance exists at only one of the server nodes at a time. When a service instance is not located at any of the server nodes it is held by an instance coordinator that all of the server nodes can access. One typical implementation of an instance coordinator is a database that durably stores instance state for the service instances .

The application may continuously receive messages from external sources at various processing nodes. Processing a message may require the instance state of an existing service instance require the blank slate of a new service instance that has never processed a message before or have no instance state requirements. The processing requirements may be part of the definition of the application and thus may differ from application to application and may not be readily apparent from the message. One function of some embodiments is to direct a message to a server node that satisfies the processing requirements of the message without requiring excessive coordination between processing nodes. In some embodiments this may be accomplished by calculating a characteristic which can be used to determine the processing requirements of the message .

Characteristic calculation may be performed using for example techniques described in U.S. application Ser. No. 12 203 790 titled Query Oriented Message Characterization filed concurrently herewith and which is incorporated herein by reference in its entirety. illustrates how characteristic calculation may be performed for some embodiments. Referring now to an example is illustrated. illustrates a query engine . The query engine includes functionality for processing queries where the queries are queries against various sources of data such as messages which include message data or non message data obtainable from other sources. In particular some embodiments may be practiced such that a message characteristic may be specified using a query over message content metadata or other information. The query engine may include support for various languages . In one specific example a query may be formulated using XPath expressions as a query language.

Often query languages such as XPath have native functionality for accessing information in a limited variety of formats and from a limited variety of sources while not natively including functionality for access to other information. For example XPath includes native functionality for accessing information in an XML structured data structure such as a message formatted using XML but may not include functionality for determining other information from other services. Nonetheless the query language may be extended by including extensions to include functionality for accessing other services. In the XPath query language the extensions are referred to as selectors. Additionally some embodiments may include functionality for normalization of access to different storage locations using extensions to the query language. In some embodiments normalization of access to different storage locations may use a mutually agreed upon data structure. Optimization of computing multiple characteristics for the same message may be performed as will be described in more detail below by merging queries and executing them simultaneously or in parallel.

As illustrated in information sources may include a message which includes message data. The message may include information such as envelope data data in the message body data in the headers of the message etc. As noted above the query engine may include functionality for extracting the message data. For example in one embodiment the query engine may include functionality supporting the XPath query language for extracting data from XML formatted messages. Other query languages may also or alternatively be used. Notably the query engine may also include functionality for invoking various application programming interfaces APIs . APIs include programmed functionality for interacting with information sources to obtain data from the sources. Notably the languages may be considered in some respects to be APIs.

As noted previously illustrates that the query engine performs queries against the data sources. Based on the queries the query engine generates intermediate results which may be instance values of data. The intermediate results may include tables of data or other forms of data. For example the intermediate results may include information such as a specific time of day which may or may not be associated with the message a specific protocol used to transmit a message or other information. The intermediate results are typically not unit less results but rather represent some specific unit. For example the intermediate results may represent a time of day unit a protocol unit a transport unit or some other specific unit. Additionally the intermediate results may be of one or more different data types. For example the intermediate results may be integers floating points strings or other data types. Additionally a set of intermediate results may have a mix of different data types. For example a time may be expressed as one or more integers while a protocol may be expressed as one or more strings. Both the time integers and the protocol strings may be included in the same set of intermediate results .

The intermediate results can be used to create a characteristic by a characteristic computation module . The characteristic may be for example a number calculated using a hash algorithm or other numerical method to calculate a number based on the intermediate results . For example in one embodiment the characteristic may be a unit less 128 bit hash number that represents a globally unique identifier. The characteristic computation module may be embodied using computer hardware and software configured to calculate a hash or other representation such as for example a numerical representation.

As will be discussed in more detail below some embodiments may be practiced where coordination occurs between the computation of a message characteristic and the messaging infrastructure. In particular a messaging infrastructure may catalog the information that it can potentially supply for a query . For example the messaging infrastructure may be able to provide information regarding transports information regarding protocols etc. The messaging infrastructure can promise availability of information at a particular time. In some embodiments the promise is related to some functionality or performance of some action at the messaging infrastructure. Analysis of a query may be performed before characteristic computation at the characteristic computation module to determine what information will be needed. Optimizations of characteristic computation may be performed so as to perform calculations for a characteristic computation at more convenient times subject to constraints based on information availability.

As will be discussed in more detail below some embodiments may be practiced where transformation of information is performed before and or after a query.

With reference once again to a more detailed example with specifics is illustrated. Consider a message for which it is desirable to compute a characteristic. The existence of this message can be presupposed without regard to how the message is or was generated. Thus this could be a message that is being sent being received or possibly even created out of thin air without any connection to a messaging operation. The message may be represented in a variety of formats. As an example consider a message represented using the Simple Object Access Protocol SOAP 1.2 format. Such a message will have storage locations for a message envelope a message body and any number of message headers. The message may also have associated with it metadata that is not contained within the message envelope such as local message properties delivery properties or information in the ambient environment. This metadata may be represented by the non message data illustrated at . Thus sources of data may be referred to as either sources of information from within the message or sources of information from outside the message.

To compute a characteristic for the message all available sources of information can be drawn upon. The computation of the characteristic will frequently require only a subset of the available information. This subset is described by a query specification including one or more queries . Each query includes an identifier and a query procedure. The query procedure defines how a value is extracted from the available information.

As an example of a query specification in one embodiment a query procedure is specified using an XPath expression. For example the message may be a purchase order in the SOAP format a fragment of which is as follows 

The XPath expression s Envelope s Body po PurchaseOrder purchaseOrderNumber specifies a portion of the message. In the present example the XPath expression specifies the value of the attribute named purchaseOrderNumber on the element named PurchaseOrder inside the element named Body inside the element named Envelope. In the present example the XPath expression is named PONumber to create an association between the identifier PONumber and the fact resulting from evaluating the XPath expression i.e. the number which represents a purchase order unit .

Upon supplying the query engine with a query specification including queries and necessary information sources such as the message and or access to sources that generate the non message date the query engine computes a table of named query results illustrated in the intermediate results .

In the illustrated example the calculation of the characteristic is defined in terms of the named query results to abstract the calculation process from how information was accessed or organized. New information sources can be added to the system either by unifying them with existing information sources or by extending the query engine with a new access method. For example the standard XPath language only provides access to message data. The XPath language could be extended with a new function as illustrated by the extensions to access non message data.

In one embodiment the HTTP Referer header is not part of the message data but could be accessed in a similar fashion using the XPath expression z GetProtocolData Referer to specify a portion of the non message data . In this case the value of the Referer property in the protocol data is not contained within the message. Although the SMTP From header comes from a different information source it too could be accessed using the GetProtocolData function. Thus the grouping of information to the same or different access methods can be done at the convenience of the developer.

With reference now to additional details of the query engine will now be discussed and in particular with respect to optimizing query processing. If multiple queries are performed against the same sources of information such as the message data and non message data it is often possible to perform the collection of queries more efficiently when they are taken together rather than one at a time. To do this in one embodiment the query engine includes a query optimization module which first transforms the original query specification including into an optimized query specification before executing the optimized query specification using the language API s as illustrated in . The optimized query specification when processed produces the same table of query results .

In one embodiment the query optimizer of the query engine joins together queries that have common sub expressions so that a single common sub expression is only evaluated once. Thus the query engine operating on a query specification containing the two queries s Envelope s Body PurchaseOrder1 and s Envelope s Body PurchaseOrder2 may only have to scan through the Envelope and Body elements of the message once to satisfy both queries.

Referring now to additional features of the query engine with respect to transforming data prior to and post processing is illustrated. In the illustrated embodiment the query engine composes with other components and as part of a processing pipeline . These components and act on the inputs and outputs respectively to the engine. One or more transformations may be applied at component to the information sources before being read by the engine and one or more transformation may be applied at component to the query results before the characteristic see is calculated. Each fact in an information source and each named query result may have an individually crafted transformation applied to them or transformations may be applied to groups of facts or query results.

Applications often have a preferred time for computing a characteristic . It is typical for the application to want to compute the characteristic as late as possible or as early as possible depending on the type of decision being made. However an application may be unable to compute the characteristic until all of the necessary information is available. An example of this conflict occurs when sending a message. It may desirable to compute the characteristic as early as possible so that the characteristic is known before any responses to sending the message are observed. However the information necessary to compute the characteristic may not be available until the message is partially or fully sent. An example of information that is not available until very late is a message identifier that is assigned by the delivery system when the message is written onto the wire.

Referring now to an example of one embodiment that addresses these concerns is illustrated. To reason about a conflict what information will be used by the characteristic computation and when that information will be available should be known. Prior to the message being sent by an application a messaging infrastructure is introspected to identify the variety of information that this particular configuration will generate. The messaging infrastructure may also make one or more statements about when each fact will be available. Statements may be promises that the facts will be available at a particular time or stage of processing. Also prior to the message being sent the query specification see may be introspected to determine the variety of information that this particular query specification will request.

The timeline axis T includes a time Trepresenting the message being transmitted out of the messaging infrastructure such as by transmitting the message onto the communication wire. The communication wire may be any one of a different number of media including network cables or wireless transport media. The completion of the computation may take place earlier or later than the message being transmitted depending on the promises made by the components . In one embodiment the completion of the callback is used to solve races between sending and receiving messages. The application refrains from processing any received messages that might depend on the characteristic of a previously sent message until all of those characteristics have been computed.

The following discussion now refers to a number of methods and method acts that may be performed. It should be noted that although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order no particular ordering is necessarily required unless specifically stated or required because an act is dependent on another act being completed prior to the act being performed.

Referring now to operation of a server node such as nodes and in is illustrated. illustrates a method . The method includes an act of receiving a message act . The message e.g. message may be received from a computer readable communication medium such as a network medium computer bus or other communication medium.

The method further includes calculating characteristic properties of the message so as to determine state requirements for a service instance such as one of service instances at a service such as one of services or for processing of the message act . Calculating characteristic properties may be performed in some embodiments as illustrated above in above and the accompanying description.

The method further includes attempting to acquire an appropriate service instance e.g. a service instance that satisfies the state requirements for processing the message . At a decision block illustrates different acts that are performed depending on whether or not the attempt was successful. When attempting to acquire an appropriate service instance that satisfies the state requirements for processing the message is successful at acquiring an appropriate service instance the message is processed based on the state requirements act . Alternatively the method may include determining that attempting to acquire an appropriate service instance that satisfies the state requirements for processing the message is not successful at acquiring an appropriate service instance and as a result redirecting the message using an unreliable local cache of routing information and without coordination between processing nodes act so as to attempt to cause the message to reach a server node that has an appropriate service instance or that can successfully acquire an appropriate service instance that satisfies the state requirements for processing of the message.

Although not illustrated in the method may further include performing processing on the message that is independent of a service instance . An example of processing that is independent of a service instance is performing statically configured protocols and message transformations.

Illustrating now details of method in more detail when a message arrives at a server node such as node or an initial presumption can be made that the server node meets the processing requirements of the message . After some amount of processing is performed on the message the server node reaches a point at which further processing requires a service instance .

To identify the appropriate service instance the server node may calculate a characteristic property using the message and locally available state but without coordination between the processing nodes. For example if a message arrives at server node the server node may calculate a characteristic property using the message and locally available state but without coordination between the other processing nodes and . The characteristic computation is defined by the application. A characteristic might be information from the message delivery process a part of the message or even the whole message itself. As an example the server node may identify that the message is a purchase order request with a particular format identify that the purchase order format includes a purchase order identifier at a fixed location and extract the purchase order identifier to form the characteristic.

The server node then consults with the instance coordinator to obtain an appropriate service instance with appropriate state for the characteristic. This consultation may include several acts performed by the instance coordinator atomically 

In particular the consultation may include determining whether a service instance associated with this characteristic already exists. For example the instance coordinator may determine if an appropriate service instance exists at the instance coordinator or at any of the processing nodes in the network . If no service instance with the characteristic exists a new service instance is created and the service instance is associated with the characteristic. If a service instance with the characteristic exists the consultation may include determining where the service instance exists. The service instance may already exist at the requesting server node in the present example server node . If the service instance exists at the instance coordinator the service instance is transferred to the requesting server node . If the service instance exists at some other server node such as server nodes or the instance coordinator may reject the load request and transmit an error message to the server node . The error message includes an identifier for the server node e.g. or at which the service instance currently exists.

Embodiments may also be implemented in environments where locks can be placed on service instances . In some of these embodiments functionality may be included for providing a requesting processing node with information about a lock owner when the instance coordinator determines that the appropriate service instance is locked by one of the processing nodes in the network. In one embodiment the instance coordinator can provide information to requesting systems regarding locks on service instances .

As part of obtaining a service instance the server node may supply one or more additional characteristics that it wishes to have associated with the service instance . Although these additional characteristics are not used as part of the initial lookup after performing the associations a future lookup for one of the additional characteristics will match the service instance . If the server node includes additional characteristics these associations are performed as part of the atomic create or load process and in some embodiments only if the create or load process succeeds in obtaining a service instance . In particular attempting to acquire an appropriate service instance from an instance coordinator may include sending one or more additional characteristics. The additional characteristics are not considered for this attempt to acquire a service instance but if the processing node should be successful at this attempt to acquire an appropriate service instance the additional characteristics are added to the plurality of characteristics that describe the service instance . As an example the server node may look up a service instance using a characteristic derived from a purchase order identifier and supply an additional characteristic derived from a shipper tracking number. In the future the service instance could be found using the shipper tracking number even if the purchase order identifier was not known. Thus in some embodiments the instance coordinator associates a plurality of characteristics with service instances. Attempting to acquire an appropriate service instance from an instance coordinator may include sending any one or more of the characteristics to the instance coordinator without sending all of the characteristics associated with the service instance. In the example illustrated either one of the purchase order identifier or the shipper tracking number could be provided without need to provide the other identifier or number.

In some embodiments of the invention the instance coordinator accepts more than one characteristic for lookup and returns the service instance that matches any one of the characteristics. The outcome when the characteristics do not uniquely define a service instance may be to favor a particular service instance based on a property of the characteristic specification to favor a particular service instance based on a property of the service instances or to reject the lookup operation as being ambiguously specified.

In some embodiments the server node maintains a local catalog of service instances that it currently has. This local catalog allows the server node to refrain from consulting the instance coordinator when there are no additional associations to perform.

In some embodiments if the server node succeeds in obtaining a service instance it dispatches the received message to the remainder of the application. Otherwise the server node constructs a redirect message containing the address returned by the instance coordinator and instructs the sender of the message to retransmit the message to this new address. For example assume that the instance coordinator indicates that a particular service instance is located at the server node . The server node may construct a redirect message which is sent to the router node which sent the message to the server node indicating that the message should be retransmitted to service node .

In some embodiments the new address is not a physical machine address. For example it might be a logical address or service name that is to be looked up in a directory known to the sender of the message. As another example the new address might be resolved using a dynamic discovery protocol rather than a directory service.

In some embodiments the instance coordinator provides routing information for service instances other than what is strictly required to route the message to improve overall routing quality.

A redirect message from the server node or other router node may contain one or more additional associations between characteristic properties and processing nodes. The additional characteristic properties are not necessarily related to a message currently being processed. The unreliable local cache may be updated according to the one or more additional associations.

The following description includes further details about the functionality of the router nodes such as router nodes and in general. Additionally details may be included regarding processing the redirect message .

The method may be performed so as to perform processing that is independent of a service instance see . An example of processing that is independent of a service instance is performing statically configured protocols and message transformations.

In the case of a router server node such as node the server node might be the server component of the same processing node.

The operation of a router node in some respects is similar to that of a server node. However instead of consulting an authoritative source for the service instances such as the instance coordinator the router node such as router node consults potentially unreliable local routing data. For example the router node may include a routing table that includes potentially unreliable local routing data. The router node may from time to time suffer amnesia causing it to forget some or all of the routing data or false routing data may be incorporated due to incorrect guesses. There is no expectation that the router node will be informed in a timely fashion or indeed ever that processing nodes have been added to or removed from the network that processing nodes have changed their type or connectivity with other processing nodes or that a service instance has moved from one place to another. The router node makes a best guess determination of the correct route using the routing data in the routing table . The best guess may be based on among other things previously routed messages and routing data from the instance coordinator received previously in redirect messages .

In some embodiments the best guess incorporates a load balancing mechanism such as round robin load balancing or directs messages to processing nodes perceived as under utilized.

When the router node receives a redirect message for a message it previously routed the router node decides how to handle the routing failure. The router node may depending on the delivery mechanism characteristic and routing data retransmit the message itself. In other cases the router node may return the redirect message to the original sender. For example while not illustrated in an additional router node may have transmitted the message to router node . The router node may use the unreliable local routing data in the table to determine that the message should be sent to the router node . The router node may determine that the message was incorrectly sent to the router node . The router node in response to this determination sends the redirect message to the router node . In some embodiments the router node may also send information indicating what is believed to be the correct processing node for the message . This information indicating what is believed to be the correct processing node for the message may be derived from unreliable information in the local routing table or from reliable coordinated information from the instance coordinator . In response to the redirect message the router node may retransmit the message to the processing node indicated in the redirect message

In some embodiments the router node always returns a redirect message if possible. Messages received from a simplex message source are retransmitted while messages received from a duplex message source return a redirect message.

Embodiments of the present invention may comprise or utilize a special purpose or general purpose computer including computer hardware as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer readable media for carrying or storing computer executable instructions and or data structures. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer readable media that store computer executable instructions are physical storage media. Computer readable media that carry computer executable instructions are transmission media. Thus by way of example and not limitation embodiments of the invention can comprise at least two distinctly different kinds of computer readable media physical storage media and transmission media.

Physical storage media includes RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.

A network is defined as one or more data links that enable the transport of electronic data between computer systems and or modules and or other electronic devices. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a transmission medium. Transmissions media can include a network and or data links which can be used to carry or desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer readable media.

Further upon reaching various computer system components program code means in the form of computer executable instructions or data structures can be transferred automatically from transmission media to physical storage media or vice versa . For example computer executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module e.g. a NIC and then eventually transferred to computer system RAM and or to less volatile physical storage media at a computer system. Thus it should be understood that physical storage media can be included in computer system components that also or even primarily utilize transmission media.

Computer executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be for example binaries intermediate format instructions such as assembly language or even source code. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather the described features and acts are disclosed as example forms of implementing the claims.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers desktop computers laptop computers message processors hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers mobile telephones PDAs pagers routers switches and the like. The invention may also be practiced in distributed system environments where local and remote computer systems which are linked either by hardwired data links wireless data links or by a combination of hardwired and wireless data links through a network both perform tasks. In a distributed system environment program modules may be located in both local and remote memory storage devices.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

