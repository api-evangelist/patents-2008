---

title: Detecting policy violations in information content containing data in a character-based language
abstract: A method and apparatus for detecting policy violations in information content containing data in a character-based language is described. In one embodiment, the method includes identifying a policy for protecting source data having a tabular format. The source data contains one or more data fragments in the character-based language. The method further includes receiving information content having at least a portion in the character-based language, and determining whether any part of the information content, including the portion in the character-based language, violates the policy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08065739&OS=08065739&RS=08065739
owner: Symantec Corporation
number: 08065739
owner_city: Mountain View
owner_country: US
publication_date: 20080328
---
Embodiments of the invention relate to the field of processing data and more particularly to detecting policy violations in information content containing data in a character based language.

A modern organization typically maintains a data storage system to store and deliver records concerning various significant business aspects of the organization. Stored records may include data on customers or patients contracts deliveries supplies employees manufacturing or the like. A data storage system of an organization usually utilizes a tabular storage mechanism such as relational databases client server applications built on top of relational databases e.g. Siebel SAP or the like object oriented databases object relational databases document stores and file systems that store table formatted data e.g. CSV files or Excel spreadsheet files password systems single sign on systems or the like.

Tabular data stores are typically hosted by a computer connected to a local area network LAN . This computer is usually made accessible to the Internet via a firewall router or other packet switching devices. Although the accessibility of a tabular data store via the network provides for more efficient utilization of information maintained by the tabular data store it also poses security problems due to the highly sensitive nature of this information. In particular because access to the tabular data store is essential to the job function of many employees in the organization there are many possible points of potential theft or accidental distribution of this information. Theft of information represents a significant business risk both in terms of the value of the intellectual property as well as the legal liabilities related to regulatory compliance.

Existing security techniques typically monitor messages sent by employees of an organization to outside recipients to prevent loss of sensitive information. In particular existing security techniques usually separate a message into tokens and determine whether any subset of these tokens contains sensitive information. The tokenization process works well with word based natural languages that provide visible delimiters e.g. spaces and punctuation marks between words. Word based languages include languages utilizing the Roman alphabet e.g. English French etc. the Arabic alphabet e.g. Arabic Persian etc. the Cyrillic alphabet e.g. Russian Serbian Bulgarian etc. etc. Character based languages however do not provide visual delimiters between words. For example Chinese and Japanese do not visually separate words. Rather the reader is required to understand from the context where in a string of characters one word ends and the next word begins. In addition character based languages typically include thousands of characters and require support for multiple alphabets.

Current mechanisms for tokenizing content in character based languages usually rely on dictionaries containing lists of known words in specific character based languages. However this approach is ineffective with names because each name in a character based language such as Japanese or Chinese can be represented by any random combination of characters. Confidential information typically includes the name of an individual and his or her data identifier such as the social security number credit card number employee number etc. Hence there is a need for an efficient mechanism to protect confidential information that includes data in a character based language.

A method and apparatus for detecting policy violations in information content containing data in a character based language is described. In one embodiment the method includes identifying a policy for protecting source data having a tabular format. The source data contains one or more data fragments in the character based language. The method further includes receiving information content having at least a portion in the character based language and determining whether any part of the information content including the portion in the character based language violates the policy.

A system and method for detecting policy violations in information content containing data in a character based language is described. A policy specifies source data that should be protected from unauthorized use due to its sensitive or confidential nature. The source data may be stored in a tabular format or be convertible to a tabular format. In one embodiment the system for detecting policy violations includes a policy management component that defines a policy for protecting source data and a data monitoring component that monitors information content to detect policy violations. Information content may include transmitted messages e.g. email messages web mail messages etc. or data stored in databases caches etc. The system for detecting policy violations provides support for character based languages such as Japanese and Chinese. That is the policy management component may define a policy to protect source data that includes data fragments in a character based language and the data monitoring component may monitor information content that includes at least a portion in the character based language to determine whether the information content including the portion in the character based language violates the policy protecting the source data.

In the following description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed description that follows are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing computing calculating determining displaying or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The PMS is responsible for receiving parameters pertaining to policies such as pre configured template policies or customized policies and creating policies based on these parameters. In one embodiment the PMS receives the policy parameters via the policy definition graphical user interface GUI . In another embodiment the PMS receives the policy parameters from an Application Programming Interface API or via a configuration file formatted in text or a defined data format e.g. extensible markup language XML or binary format .

The PMS may create policies based on regulations concerning handling of sensitive information maintained by an organization or based on corporate data governance rules. The regulations may include for example the Health Insurance Portability and Accountability Act HIPAA ensuring the confidentiality of electronic protected health information California Senate Bill 1 SB1 or Senate Bill 1386 SB1386 controlling customer information leaving the company and affiliates the Gramm Leach Bliley Financial Services Modernization Act controlling customer information leaving a financial institution the Cardholder Information Security Program CISP controlling handling of customer credit card information maintained by an organization or the like. In one embodiment the PMS may use policy templates or customized policies pre configured based on input provided by individuals familiar with the relevant regulations or corporate data governance rules.

The policy may include a set of rules that specify which information should be present in a message to trigger a violation. The term message as used herein is referred to any content being scanned for policy violations. For example a message may represent a transmitted document e.g. an email message a web mail message etc. or data stored in databases caches etc. The set of rules may provide specific conditions for triggering a violation e.g. a sender or recipient of a message inclusion in a message of a keyword s or regular expression pattern etc. . The rules in the policy may be combined using logical connectives of first order logic e.g. AND OR NAND NOR NOT equivalent nonequivalent or the like .

The policy specifies source data that should be protected from unauthorized transmission access or any other use. The source data may be stored in a tabular format e.g. data in a relational database data maintained by client server applications built on top of relational databases data in document and file systems that store table formatted data e.g. CSV files or Excel spreadsheet files etc. or it may be stored in a non tabular format but convertible to a tabular format e.g. data stored as comma separated values in a flat file a password database or a single sign on system relational data in an object oriented database etc. . The policy may also specify which portions of the source data should be included in a message to trigger a policy violation.

In one embodiment the PMS extracts copies of the source data and derives from that data an abstract data structure as will be discussed in more detail. The abstract data structure may be created periodically and sent to the DMS along with the policy that is to be implemented.

The DMS is responsible for monitoring information content e.g. email messages and or other documents according to the configuration of the DMS based on the abstract data structure and policies to detect policy violation incidents. Once the DMS has detected a policy violation the DMS reports the policy violation to an appropriate entity e.g. a manager database administrator a reporting system etc. or performs some other action.

An exemplary operation of the PMS and the DMS will now be discussed in more detail with reference to . In particular shows a portion of source data including a set of columns and several rows. As shown the source data is indexed to derive an abstract data structure. A policy specifies that messages should be searched for data from the columns First Name Account Number and Balance in individual records from the source data in any order of appearance in the message. A message is searched for policy violations using the abstract data structure of the source data and the policy . As shown the message includes data from the last row of the source data . In particular the message includes data fragments and from restricted columns of the data source as specified in the policy . Accordingly the message violates the policy and needs to be reported to an appropriate entity.

Returning to the DMS detects policy violations in messages irrespective of the natural language of the source data and a message. For example the DMS can search messages for confidential information in any word based language e.g. English Hebrew Russian etc. or any character based language e.g. Chinese Japanese etc. . In one embodiment the DMS uses a search mechanism that first divides a message into tokens and then determines whether any subset of the tokens contains data fragments from the source data . For word based natural languages tokenization of a message is performed based on apparent delimiters between words such as spaces and punctuation marks. However character based languages do not provide any identifiable delimiters. In one embodiment the DMS solves this problem by utilizing token delimiter indicators contained in the abstract data structure which will now be discussed in more detail.

In one embodiment the PMS includes a Unicode converter and an abstract data structure creator . The Unicode converter is responsible for converting character encodings of the source data into Unicode. Unicode allows representing international characters using a single character set. By converting the character encodings into Unicode potential similarities between different language encodings are avoided maintaining the accuracy across international languages.

The abstract data structure creator is responsible for creating an index of the source data in the form of the abstract data structure as will be discussed in more detail below in conjunction with . In addition the abstract data structure creator adds to the abstract data structure a token delimiter indicator for each data fragment in a character based language. Because the source data has a tabular format the abstract data structure creator considers data from an individual cell in the source data as a token. In one embodiment the abstract data structure creator creates a token delimiter indicator for a token by combining a value of a first character of the token and the length of the token.

When the DMS determines that a message being examined includes at least a portion in a character based language the DMS uses the token delimiter indicators to guide the identification of potential tokens within the message. Exemplary embodiments of tokenizing content in a character based language in the context of source data protection will be discussed in more detail below.

The Unicode converter is responsible for receiving information content e.g. an email message and converting character encodings of the information content into Unicode to avoid potential similarities between different language encodings. The natural language identifier is responsible for analyzing the information content for languages and splitting the information content into single language sections.

The tokenizer is responsible for creating tokens from the information content. Sections of the information content in a word based language are tokenized based on apparent word boundaries e.g. spaces and punctuation marks . For a character based language the tokenizer invokes the character based language enhancer that creates tokens based on token delimiter indicators from the abstract data structure as will be discussed in more detail below in conjunction with A and B.

The search engine is responsible for searching the resulting tokens for data fragments from the source data based on the specific policy. Exemplary search techniques will be discussed in more detail below in conjunction with B and C. The violation reporter is responsible for notifying an appropriate entity of a detected violation e.g. via a user interface an email message etc. .

Referring to processing logic begins with determining whether the source data is stored in a standard tabular format block . If not processing logic converts the source data into a standard tabular format block . Each cell in the resulting table stores a fragment of the source data. This data fragment represents a token regardless of the natural language of the data fragment. A token may be a single word or a cluster of words e.g. words enclosed in quotation marks . For example while the word this may represent a token stored in a database cell the phrase this token may also represent a standalone token if it is stored as a single string in a database cell.

At block processing logic converts character encodings of data fragments to Unicode. In one embodiment processing logic first determines which language encoding scheme is used for a relevant data fragment. This determination can be made based on an encoding scheme indicator stored with the data fragment. If such an indicator is not present processing logic may use standard libraries e.g. International Components for Unicode ICU libraries to obtain a likely encoding scheme.

Next processing logic accesses the first data fragment from the source data and determines whether this data fragment is in a character based language block . If not processing logic proceeds to block . If so processing logic creates a token delimiter indicator for this data fragment block and then proceeds to block . In one embodiment the token delimiter indicator includes the value of a first character of the data fragment and the length of the data fragment. Such a token delimiter indicator includes generalized data that would not allow a malicious user to recover the content of the original data fragment.

At block processing logic creates a signature and placement information for the current data fragment. The signature may include an encrypted or hashed copy of the data fragment or some other representation of the data fragment that would not allow a malicious user to recover the actual content of the data fragment. The placement information may include the number of a row storing the data fragment in the source data and or the number of a column storing the data fragment in the source data. Optionally the placement information may also include the data type of the column.

In one embodiment the data created at blocks and may be stored in a tuple storage structure derived from the source data. A tuple storage structure provides a mechanism for storing multiple tuples associated with the fragments of the source data. Examples of tuple storage structures include a hash table a vector an array a tree or a list. Each type of the tuple storage structure is associated with a method for retrieving a set of tuples for any given content fragment the set of tuples may be empty if no match is found in the tuple storage structure . The data created at blocks and may be stored in a tuple corresponding to the data fragment being currently processed.

At block processing logic determines whether the source data includes more data fragments that have not yet been processed. If so processing logic switches to the next data fragment block and returns to block . If all data fragments have been processed processing logic creates an index from the resulting token delimiter indicators using the value of the first character as the key.

In one embodiment in which the abstract adapt structure is created as a tuple storage structure processing logic may sort the tuples in a predetermined order e.g. in the ascending lexicographic order . In one embodiment the contents of the abstract data structure are treated cryptographically e.g. with a hash function or using an encryption function with a cryptographic key to further secure the abstract data structure from theft.

Referring to processing logic begins with identifying a policy for protecting tabular source data having data fragments in a character based language block . The policy may specify the source data and include one or more rules e.g. rules concerning data loss prevention for triggering a violation.

At block processing logic receives information content that contains at least a portion in a character based language e.g. Japanese or Chinese . The information content may include free from text and may be a file e.g. an archived email message stored on a hard drive of a computer or a block of data transmitted over a network e.g. an email message transmitted over a network using any type of a network protocol .

At block processing logic determines whether the information content including the portion in the character based language violates the policy for protecting the source data. If a policy violation is detected processing logic notifies an appropriate entity of the detected policy violation block .

Accordingly method allows sensitive information to be protected from unauthorized use e.g. transmission access etc. irrespective of the natural language of the sensitive information as well as the natural language of the content being monitored for presence of sensitive information.

Referring to method begins with processing logic converting character encodings of information content to Unicode block . In one embodiment processing logic first determines which language encoding scheme is used for the information content. This determination can be made based on an encoding scheme indicator stored with the information content e.g. in the header of the email message . If such an indicator is not present processing logic may use standard libraries e.g. ICU libraries to obtain a likely encoding scheme.

At block processing logic determines whether the information content includes data in a character based language. If not processing logic tokenizes the information content using apparent delimiters block and proceeds to block . If so processing logic handles a portion s in the character based language differently from a portion s if any in a word based language. In particular for each portion in the character based language processing logic creates tokens using an abstract data structure derived from the source data block . In particular processing logic utilizes token delimiter indicators contained in the abstract data structure derived from the source data. One embodiment of a method for tokenizing portions in a character based language will be discussed in more detail below in conjunction with . For each portion in a word based language processing logic tokenizes the relevant portion based on visible delimiters block .

At block processing logic determines whether the resulting tokens irrespective of the natural language contain data fragments from the source data as required by an applicable policy to trigger a violation. This determination can be made using a variety of search techniques including search techniques discussed in more detail below in conjunction with .

Referring to method begins with processing logic identifying a first character in the character based language portion of the information content such as a message block . Next processing logic accesses an index of token delimiter indicators in the abstract data structure. As discussed above a token delimiter indicator includes a value of a first character of a corresponding data fragment in the character based language in the source data and the length of the corresponding data fragments. The resulting collection of token delimiter indicators is indexed using the value of a first character as the key. Hence each key may be associated with several data fragments depending on how many data fragments start with the same character.

At block processing logic determines whether the first character in the character based portion of the message matches any key in the token delimiter index. If not processing logic moves to the next character block and returns to block . If so processing logic creates a token candidate using the first length parameter associated with the matching key block and creates a signature of the token candidate using the same signature creation technique that was used for generating signatures for the abstract data structure block .

If the signature of the token candidate from the message matches a signature of a corresponding data fragment from the abstract data structure block processing logic adds this token candidates to a list of tokens created for the message block and proceeds to a character at the end of the current token block if there are any characters that have not been processed in the character based language portion of the message block .

If the signature of the token candidate from the message does not match a signature of a corresponding data fragment from the abstract data structure processing logic determines whether the current key corresponds to any other data fragments from the source data block . An additional data fragment that corresponds to the current key may have the same or different length parameter. If the length parameter is the same processing logic returns to block . If the length parameter is different processing logic moves to the next length parameter block and then returns to block .

Accordingly method tokenizes the character based language portion of the message by creating only those tokens that match data fragments from the source data i.e. the tokens that can possible violate the policy. By ignoring the rest of the character based language portion of the message the subsequent search of the message for presence of the source data is simplified.

Exemplary search techniques will now be described in more detail. are flow diagrams of various exemplary embodiments of a method to find in a subset of tokens a match satisfying policy parameters in an abstract data structure derived from source data. The method is performed by processing logic that may comprise hardware circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. In one embodiment the method is performed by a data monitoring component e.g. DMS of .

Referring to processing logic begins with searching for each token or content fragment the abstract data structure for a set of matching tuples block . For example a word Smith contained in the information content may have several occurrences in the source data that are reflected in the abstract data structure. Specifically each of these occurrences has a corresponding tuple in the abstract data structure. During the search processing logic retrieves a set of tuples corresponding to the occurrences of the word Smith in the source data. Each tuple stores information about the position of this data fragment within a database or a table storing the source data. In one embodiment the positional information includes the row number of a cell storing the data fragment. In another embodiment the positional information also includes a column number of this cell and optionally the data type of the column.

Next processing logic combines the matching tuple sets found for all the content fragments block and then groups the combined matching tuple sets by row numbers into groups L block . As a result each group L referred to herein as an accumulator contains matching tuple sets that all have the same column number i.e. the matching tuple sets in each group L correspond to fragments of the source data that all appear to be from the same row in the database.

Further processing logic sorts the groups L by the number of matching tuple sets contained in each group block and in one embodiment selects those groups that have tuple sets with distinct column numbers block . Afterwards processing logic determines whether any of the selected groups satisfy policy parameters block .

Referring to processing logic begins with determining whether the policy parameters specify inclusion columns block . If not processing logic proceeds to block . If so processing logic determines whether the policy parameters specify a minimum number M of inclusion columns block . If number M is specified processing logic searches for groups with tuples from at least M number of the inclusion columns block and determines whether any such groups are found i.e. the number of found groups is greater than 0 block . If the determination made at block is positive processing logic proceeds to block . If the determination made at block is negative processing logic decides that no violation has been detected block .

If number M is not specified block processing logic searches for groups with tuples from each specified inclusion column block and determines whether any such groups are found block . If the determination made at block is positive processing logic proceeds to block . If the determination made at block is negative processing logic decides that no violation has been detected block .

At block processing logic determines whether the policy parameters specify any key words or expressions. If not processing logic proceeds to block . If so processing logic searches for groups with tuples matching the specified keywords or expressions block and determines whether any such groups are found block . If the determination made at block is positive processing logic proceeds to block . If the determination made at block is negative processing logic decides that no violation has been detected block .

At block processing logic determines whether the policy parameters specify exclusion columns. If not processing logic proceeds to block . If so processing logic searches for groups with tuples that are not from all of the exclusion columns block and determines whether any such groups are found block . If the determination made at block is positive processing logic proceeds to block . If the determination made at block is negative processing logic decides that no violation has been detected block .

At block processing logic determines whether the policy parameters specify a minimum number L of rows. If not processing logic decides that a violation is detected block . If so processing logic determines whether the most recent number of found groups is not less than L block . If this determination is positive processing logic decides that a violation is detected block . If the determination made at block is negative processing logic decides that no violation has been detected block .

Referring to processing logic begins with receiving parameter m that identifies the minimum number of inclusion columns i.e. data source columns whose data needs to be included in the search result block .

Next processing logic receives parameter S specifying the set of inclusion columns and confirms that S is greater or equal to m block .

At block processing logic receives parameter r specifying the minimum number of rows. Parameter r requires that the search result contain data from at least r rows of the source data.

At block processing logic receives parameter E specifying a set of exclusion columns i.e. data source columns whose data has to be excluded from the search result and confirms that for each e member if E e is equal to m.

At block processing logic determines whether G is greater than r. If so processing logic decides that a match is detected block . If not processing logic decides that no match is detected block .

The exemplary computer system includes a processing device processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or a processor implementing other instruction sets or processors implementing a combination of instruction sets. The processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processor is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine accessible storage media. The software may further be transmitted or received over a network via the network interface device .

While the machine accessible storage medium is shown in an exemplary embodiment to be a single medium the term machine accessible storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine accessible storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine accessible storage medium shall accordingly be taken to include but not be limited to solid state memories optical media and magnetic media.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

