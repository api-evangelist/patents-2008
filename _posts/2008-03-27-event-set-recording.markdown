---

title: Event set recording
abstract: Recording of functional steps resulting from actions in an application is desirable for performing functional testing or user interface automation of an application. However, certain events that may result from actions occurring in an application are often difficult to record, which may lead to playback failure. Further, a user's intent when performing an action is difficult to determine. In order to obtain effective playback, a reliable and efficient recording of an application's functional steps needs to occur. Injecting wrapper functions into an application and monitoring an event generator's state before and after an action has occurred may yield more reliable and effective results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08196118&OS=08196118&RS=08196118
owner: Microsoft Corporation
number: 08196118
owner_city: Redmond
owner_country: US
publication_date: 20080327
---
In a computing environment one may wish to automate functional steps of an application for example for functional testing or user interaction automation in an application. As an example in a web based application one may wish to test results of changes to a web page by recreating typical user interactions on that page after the changes have been made. In this example it may be desirable to record events that resulting from actions upon the web page during the user interaction. Recording the events yields an ability to playback the user actions on a web page during a functional test for the web based application.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In computing environments functional testing and user interface UI application automation is a process by which functional steps of an application are recreated from previously performed user actions or actions imitated for functional testing or process automation. The purpose of recreating these steps is to recreate all performance of intended actions on a target application without user interaction. In order to accomplish this task the functional steps of an application need to be recorded along with all relevant events that may occur as a result of performing the steps in the application. Therefore to faithfully recreate original user intent when interacting with an application a recording of the user s action may be performed followed by performing those actions upon the application using a playback. However current techniques may not effectively record the user s intent are typically resource intensive and may not provide effective functionality.

As provided herein a technique and system for reliable and efficient recording of functional steps in an application allow for reliable and efficient playback of the functional steps. The technique and system use instruction e.g. JavaScript code injection to apply wrapper functions to event handlers and elements in an application as necessary to monitor a state of an event generator before and after actions have be called upon the event generator. In this way properties of the event generator may be recorded for use by a playback engine or the properties may be processed to determine a user s intent when performing an action upon the event generator.

For example if a user clicks on an item on a web page then intent of that click may not be able to be determined by current techniques. However the technique and system provided herein may be able to determine whether the user intended to select the item deselect the item or simply clicked the item for another intent e.g. to edit or copy the item . To facilitate at least some of the same when a page loads event handler monitoring wrappers are injected into the page and event handlers on the page are associated with the monitoring wrappers. When an event is called upon an element attached to the event handler the monitoring wrapper function is called to record a state of the element prior to an event handler function being called. Once the event handler function has been called the monitoring wrapper function is called again to record a state of the element. State sets of the element e.g. sets of element properties can be sent to a recording engine or the state sets can be processed e.g. compared to determine user intent.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Embodiments described herein relate to techniques for recording actions in application interfaces e.g. web based applications browser applications user interfaces by injecting wrapper functions into application instructions and monitoring a state of an application interface element before and after an event is called upon the element.

In computing environments to record actions in application interfaces based on external events for example the recorder should intercept the event and attempt to locate the element that is the target of the action. The process of looking for the element in this example involves inter process communication which can be quite lengthy. Further external observation of the event may not be useful for realizing intent of the action. As an example a click on a list item may have intent to select unselect or change item to an editable state. Capturing intent may be possible by using an external application programming interface API but this technique often has a significant impact on computing resources e.g. performance . For example in the Windows operating system OS there is a default time limit of 500 ms for how long an event can be held before it must be allowed to proceed. While this limit can be changed changing it may create undesired effects in the OS behavior. Further this default limit is often hit when attempting to record from an external API provided by a browser.

An alternate technique for recording events from application interfaces involves injecting instructions e.g. JavaScript code for event handler wrapper functions into the application interface. When called the wrapper function collects and processes a set of current state information e.g. relevant properties of an event generator e.g. an element receiving the event call. The wrapper function then calls an event handler function on the element then again collects and processes a set of current state information of the event generator. Both sets of information e.g. properties of the element before the event handler function and properties after can be sent to a recording engine or processed e.g. determining intent of an action by comparing the sets of element states . By employing wrappers around respective event handlers for an event generator e.g. an element one can examine information on the state of the event generator e.g. element properties before and after an action was taken upon the event generator e.g. clicking on an element . Further by using this technique more than one set of information may be recorded at one time for a given event generator. Therefore a playback engine may search a list of information sets e.g. property sets for the element in order to produce a more accurate playback experience.

One embodiment of the technique described above is illustrated by an exemplary method in . Exemplary method begins at and involves injecting instructions in an application interface for wrapper monitoring functions at one of which may be configured to record a first state of an event generator e.g. an element and one of which may be configured to record a second state of an event generator compare the first state to the second state and send event generator properties to a recording engine. At a first reference to a monitoring wrapper function is associated with an event handler. At a second reference to a monitoring wrapper function is associated with the event handler at a position in the event handler s instructions subsequent to the first reference with at least one set of instructions between the first reference and the second reference. Having associated the second reference the method ends at .

As an example of this embodiment one may record actions executed by a user on web page elements having dynamic properties. For example as a web page is loaded JavaScript code for one or more monitoring wrapper functions may be injected into the web page code. A first monitoring wrapper may be configured to record a set of properties of a state of an element prior to an event handler function being called upon the element. A second monitoring wrapper may be configured to record the set of properties of the state of the element after the event handler function is called upon the element and send both sets of properties of the element to a recording engine. Concurrently a JavaScript code event handler wrapper referencing the first and second monitoring wrapper functions may be inserted in the page code for all event handlers on the page. This event handler wrapper wraps the event handler and includes the event handler function call at a point after a call to the first monitoring wrapper function. For example the following html code line 

In one aspect there are applications that programmatically attached event handlers e.g. dynamic event handlers to elements in response to actions taken in the application a timer or other code execution that invokes attachment. Problems may arise when attempting to record actions involving programmatically attached event handlers such as an application e.g. a browser may not allow for a list of these event handlers to be received e.g. by a recording system and these event handlers may be added after a page has loaded or other code has been executed. Therefore attempting to wrap event handlers as described above may not account for programmatically attached event handlers. As such in order to overcome possible problems additional steps may be included in the technique.

An embodiment of a technique to overcome problems described above is illustrated in . In an exemplary method is devised to record events from applications interfaces by monitoring attachment of programmatically attached event handlers and creating wrappers for event handlers. The exemplary method begins at and involves replacing one or more references to event handler attaching and detaching function s found in respective elements e.g. event generator in an application interface page with one or more references to one or more wrapper attach and detach functions at . Instructions for the one or more wrapper functions for attaching and detaching event handlers are injected into page instructions at . At when an event is invoked on an element the wrapper attach function is called by the wrapper reference in the element. At the wrapper attach function uses an event handler wrapper generator to generate a monitoring wrapper function for an event handler. Once the one or more monitoring wrapper functions are generated event handler functions are associated with a first reference and second reference e.g. subsequent to the first to the monitoring wrapper function at . The event handler function reference and the monitoring wrapper function reference are stored at . When an event is invoked on the element the monitoring wrapper function records a first state of the element prior to the event handler function being called at . The event handler function is called at and second state of the element is recorded by the monitoring wrapper function at . The property sets of the first state and second state are passed to a recording engine at . Once the information is recorded the stored references are used to activate the event handler detach function for an element at where a wrapper detach function finds the stored event handler function reference. Detachment of the event handler occurs at . Having completed the event handler detachment the exemplary method ends at .

It is to be appreciated that there is not necessarily an attach detach handler per every event invocation. Rather event handlers are attached and detached as necessary generally at the beginning of page loading and or upon completion of certain conditions. To effectively detect such programmatically added handlers references to one or more wrapper attach and detach functions are substituted for references to event handler attaching and detaching function very early on. Should an event handler be attached arriving events can be readily diverted since the attach method itself is hijacked and so had a chance to make the aforementioned wrapper for handler substitution. Essentially attach and detach methods for respective elements are substituted or hijacked as early as possible an application decides whether to attach or detach event handlers e.g. whenever the application wants to monitor events where timing of such monitoring is generally unknown and events then arrive at the wrapper if an event handler was attached.

As an example one embodiment of the exemplary method in is illustrated in . In the method acts upon an exemplary web page as the page loads all its elements . When the web page finishes loading a wrapper attach function and a wrapper detach function have been injected into the web page code. Further references to the wrapper attach function and the wrapper detach function have been inserted in each of the elements on the loaded web page in place of references that pointed to the original registration and deregistration functions for each element .

In a user acts upon an element in a web page e.g. by clicking on the element which calls for dynamically attaching an event handler . A wrapper attach function reference in the element calls to a wrapper attach function in the web page s code which initiates a method . The method collects a set of properties of the element in the web page prior to the event handler acting upon the element . Further the method initiates the dynamically attached event handler that is called when the user clicked on the element in the web page . The event handler acts upon the web page as it would have without the method . When the event handler has completed its function on the web page the method again collects a set of properties of the element in the web page . The collected sets of properties of the element are sent to a recording engine . The method calls back to the wrapper detach function reference in the element which calls to the wrapper detach function in the web page . The wrapper detach function activates the event handler detach function dynamically detaching the event handler from the element .

In another aspect some elements in an application interface may be created dynamically for example by invoking document object model DOM methods to create and add elements to a browser page. In this example creation of an element is a DOM method whereas adding created elements is either a method of the page or a method of an element to which elements are added as children. Both the addition of an element as a method of a page and the addition of an element as a method of an element to which elements are added as children can be wrapped by having a wrapper function perform all actions performed on preexisting elements in an application interface. In this aspect instructions for wrappers are injected around event handlers that are placed as attributes on created elements. Further as described above event handler attach and detach wrapper functions are injected for respective newly created and or newly attached elements. Also attach element wrapper function instructions are injected around an attach element method of respective elements such that children added to the element may also be wrapped as described above.

Therefore as an example a user s action on a web browser page may call a DOM method createElement and add a newly created element to the web page. In this example as described in method above wrapper attach and detach event handler functions are injected into the page code for the newly created and added element and event handlers attached to the newly added element are wrapped with wrapper monitoring functions. Further an attach element function for the newly added element is wrapped with a wrapper function that creates wrappers for any newly added children of the element. As in method the newly added element from the user s action on the web page may be monitored during respective actions upon the element and its properties may be sent to a recording engine. In this example when a tester wishes to perform functional testing of the user s action upon the web page an automated playback of the user s actions will include creating and adding an element to the web page and any other actions that the user may have performed upon the newly added element.

In yet another aspect a mouse over is an action of passing a mouse cursor over an element. Some application interfaces e.g. dynamic web pages may use this action to activate additional functionality e.g. activating menus not previously visible when a mouse cursor passes over an element on a browser page . Because a mouse over is not visible as an event outside of the DOM a problem may arise when attempting to record a mouse hover. At levels outside of the DOM the only action indicating a mouse over is an act of moving a mouse. Currently there may be several solutions for recording a mouse over event. One solution may be to record all mouse movements however system performance is negatively affected and playback failure invariably occurs in some situations. Another solution may be to record all mouse moves in correlation with underlying elements however while failure during playback is less likely system resources are taxed even more than the previous solution. Yet another solution may be to perform a lookup of an element s bounding rectangle each time there is a given mouse position change and ignore further movements if they occur within the rectangle however while system performance is better than the previous solutions one must still record many mouse movements which is more likely to lead to playback failure and decreased system performance.

In this aspect an alternate technique for recording mouse over events in an application interface is to use the methods described herein for injecting wrapper functions wrapping event handlers and monitoring an element s properties. Further this method can account for elements that do not activate an event when a mouse over occurs by ignoring such actions. As an example during wrapping of registered event handlers if an element does not have an attached event handler for a mouse event this element can be ignored during recording. However if the element does have an attached event handler for mouse motion events the wrapping method described herein can monitor and record the event as a mouse over event on the element as described above. Further if the mouse over action results in a change to the element s layout its properties are recorded using the method herein. As an example when wrapping event handlers for mouse over events injected wrapper functions e.g. programming code instructions may be executed before an action is taken by an element for an event and after all actions are executed by the element. In this example a wrapper function e.g. a mouseenter wrapper is injected at the element level as an event is first detected at this level then injecting a wrapper function e.g. a mouseexit wrapper at the document level. In this example the mouse movements and actions that occur as a result of a mouse over can be recorded.

In yet another aspect element selection deselection may be an action for example upon an element in a list table or on an application page. A problem with state of the art solutions for recording such an event is that intent of a click upon an element cannot be determined. For example clicking on an element may be an action selecting the item deselecting the item or no action other than a click. Therefore proper functional playback of such a recorded event may be affected. However in this aspect one may use the method for injecting wrapper functions wrapping event handlers and monitoring an element s properties described herein to record element selection deselection events in an application interface.

In this aspect as an example by wrapping all event handlers by injecting instructions e.g. JavaScript code including selection handlers e.g. onchange event and mouse event handlers e.g. onclick event effective recording of element selection deselection events may occur. As a result a click on an element may be intercepted before propagating it to the element. Further the element s properties may be checked to determine whether it supports selection. After the click event proceeds properties of the element are again recorded capturing the intent of the click action. Once properties of the element prior to the click and after the click are captured the intent of the click can be determined and recorded.

A system may be configured to record events from web based applications or user interfaces by registering event handlers with references to wrappers and creating wrappers for event handlers such as illustrated by an exemplary system in . The exemplary system has an event handler registerer that injects an event handler wrapper function and replaces an event handler function reference in an event handler with a wrapper function reference . When an event is invoked upon an element the element calls to the registered event handler which calls to the wrapper function via the wrapper function reference now in place in the event handler . The wrapper function collects and sends information associated with the event to the recording engine . After the information is collected and sent the wrapper function calls to the original event handler function which performs its functions upon the element .

In when an event is invoked on an element the reference to the wrapper attach function calls to the wrapper attach function . An event handler monitoring wrapper function generator creates and injects an event handler monitoring wrapper function injects a reference to an event handler monitoring wrapper function in an event handler at a 1location and at a 2location and sends both the reference to an event handler monitoring wrapper function and the reference to the event handler function to a reference storer . The event handler monitoring wrapper function records a 1state of the element prior to an event handler function being called upon it. The event handler monitoring wrapper function calls to the event handler to invoke the event function upon the element . A 2monitoring wrapper function reference calls to the monitoring wrapper function which records a 2state of the element . The monitoring wrapper function sends a 1and 2state of the element as event information to a recording engine . The event handler function calls back to the element for deregistration of the event handler . The reference to a wrapper detach function calls to a wrapper detach function which calls to the reference storer to retrieve the reference to event handler function stored there. The wrapper detach function calls to the event handler to deregister from the element .

Another embodiment which may include one or more of the variations described above involves a computer readable medium comprising processor executable instructions configured to apply one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method for recording events from user interfaces by registering event handlers with references to wrappers and creating wrappers for event handlers such as the method of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 8394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

