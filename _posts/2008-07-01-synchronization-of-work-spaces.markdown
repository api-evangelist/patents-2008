---

title: Synchronization of work spaces
abstract: A method is provided for synchronization of a first workspace with a second workspace. Both workspaces are connected to a version control system. The method comprises for a first refactoring operation being performed on the first workspace, performing first refactoring step, resulting in a modification of an object, storing the modification in a change information for the object, storing in a change information recording step the change information, and storing in a descriptor recording step refactoring information comprising information enabling execution of a refactoring corresponding to the first refactoring step during an update operation. The method further comprises for a commit operation, delivering in a change information delivery step the change information to the version control system, and delivering in a descriptor commit step the refactoring information to the version control system. Then the method comprises for the update operation being performed on the second workspace, retrieving into the second workspace in a load step from the version control system the change information and the refactoring information, performing a second refactoring operation using the refactoring information, and performing in an execution step an update of the object in the second workspace using the change information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08418141&OS=08418141&RS=08418141
owner: International Business Machines Corporation
number: 08418141
owner_city: Armonk
owner_country: US
publication_date: 20080701
---
The present application claims the benefit under 35 U.S.C. 119 of Switzerland Application Serial Number 07112441.6 filed Jul. 13 2007 entitled SYCHRONIZATION OF WORK SPACES which is incorporated herein by reference.

The present disclosure generally relates to the field of refactoring aware synchronization of workspaces with VCS systems and more particularly to a method of automatically applying refactorings during update operations to maintain consistency of artifacts.

A refactoring is a process for improving the design of software by applying several behavior preserving transformations to a software system. M. Fowler K. Beck J. Brant W. Opdyke and D. Roberts Refactoring Improving the Design of Existing Code 1st edition Addison Wesley 1999 gives an introduction to the subject. A refactoring engine is a software development tool usually offered as a service by an integrated development environment IDE to provide automatic code transformations such as reference adjusting renaming of software elements or reorganizing hierarchies of software artifacts. Refactoring engines automate the refactoring process and help developers to safely change information. Current refactoring engines are designed to work on a local set of artifacts conventionally called a workspace. The scope of refactoring operations therefore is naturally bounded by such a workspace. Artifacts not present in the workspace at the time of initiating the refactoring cannot be considered and hence are not updated by the refactoring engine.

Most of the time software development is performed as a collaborative process. Therein software developers only work on a subset of an entire software project. Consequently such a developer typically has only a subset of all the artifacts of the entire project loaded in his workspace. The propagation of changes to a software artifact is then done by a Version Control System VCS which acts as a centralized repository that stores all artifacts belonging to a software project.

Current refactoring engines require that all artifacts to be refactored are present in the workspace from which the refactoring operation has been initiated. Other developers having artifacts with references to the refactored artifact in their workspace may have to perform manual adjustments when accepting incoming changes from the VCS system since their content has not been updated by the refactoring engine. Due to the definition of the scope of a refactoring operation the delivered change information does not comprise information on how to resolve conflicts in additional artifacts in workspaces other than the original workspace.

In T. Ekman and U. Asklund Refactoring aware versioning in Eclipse http www.lucas.lth.se cm cmeclipse.shtml describes previous work that has been done to enrich a VCS with refactoring information. However this information is only leveraged during merge and compare operations and not to solve the consistency problem caused by the definition of the scope of refactoring operations performed by refactoring engines during update operations.

In J. Henkel and A. Diwan CatchUp Capturing and Replaying refactorings to Support API Evolution. In ICSE St. Louis USA 2005 the authors are describing a refactoring engine that is able to capture refactorings performed on a workspace and then later replay the refactorings on a different workspace. This refactoring engine however is a standalone system which is not integrated in a VCS and does not support collaboration by software repositories.

Dig et al. present in D. Dig T. N. Nguyen and R. Johnson Refactoring aware Software Configuration Management Report No. UIUCDCS R 2006 2710 April 2006 a refactoring aware software configuration management system where change information is not stored as files but as logical operations on source code. In conjunction with a refactoring engine which has been extended to record refactorings this system stores refactorings as semantic operations in order to maintain a consistent history of a source code element. The semantic operations are then replayed on the workspace during update operations. This software configuration management system is a standalone solution which does not work with an existing resource based VCS.

The Borland JBuilder 2005 described in Borland JBuilder 2005 Whitepaper http www.borland.com resources en pdf white papers jb2 005 whats new.pdf has support to record and replay refactorings. Refactoring information can be associated with a project archive from a project which is dependent on the project which the refactoring has been initiated from. This feature is called distributed refactoring but does not leverage refactoring information during synchronization with a VCS.

In CatchUp Capturing and Replaying Refactorings to Support API Evolution by Johannes Henkel and Amer Diwan International Conference on Software Engineering Proceedings of the 27th international conference on Software engineering St. Louis Mo. USA SESSION Software evolution Pages 274 283 2005 the creation of a meta data file containing refactoring information is described. Library developers who have to evolve a library to accommodate changing requirements often face a dilemma Either they implement a clean efficient solution but risk breaking client code or they maintain compatibility with client code but pay with increased design complexity and thus higher maintenance costs over time. A lightweight approach is discussed for evolving application programming interfaces APIs which does not depend on version control or configuration management systems. Instead API refactoring actions are captured as a developer evolves an API. Users of the API can then replay the refactorings to bring their client software components up to date.

In the web article http www.eclipse.org articles article.php file Article Unleashing the Power of Refactoring index.html the author Tobias Widmer specifies how refactoring descriptors can be used to store refactorings for monitoring or later re execution.

The challenge is the ability to extend an existing version control system to allow refactoring during an update operation.

In accordance with the present invention there is now provided a method for refactoring aware synchronization with version control systems VCS capable of refactoring a second workspace controlled by a VCS system containing dependent artifacts originally not part of a first workspace where the refactoring causing an outgoing change information has been recorded the method comprising recording of refactorings performed on the first workspace storing refactoring information associated with the outgoing change information to be delivered to the VCS system and recognizing and replaying refactorings associated with incoming changes during an update operation at the second workspace.

According to a first aspect of the invention a method is provided for synchronization of a first workspace with a second workspace. Both workspaces are connected to a version control system. The method comprises for a first refactoring operation being performed on the first workspace performing first refactoring step resulting in a modification of an object storing the modification in a change information for the object storing in a change information recording step the change information and storing in a descriptor recording step refactoring information comprising information enabling execution of a refactoring corresponding to the first refactoring step during an update operation. The method further comprises for a commit operation delivering in a change information delivery step the change information to the version control system and delivering in a descriptor commit step the refactoring information to the version control system. Then the method comprises for the update operation being performed on the second workspace retrieving into the second workspace in a load step from the version control system the change information and the refactoring information performing a second refactoring operation using the refactoring information and performing in an execution step an update of the object in the second workspace using the change information.

Hence the invention provides a method for refactoring aware synchronization with a VCS system working in a development environment where several developers also referred to as users are collaborating and sharing artifacts via a VCS system. First a developer makes a change consisting of refactorings to a first workspace. Second the developer delivers the outgoing change information to the VCS system which also stores refactoring information in addition to the change information. Third another developer synchronizes a second workspace with the VCS system and receives the incoming change information. Fourth that other developer accepts the incoming change information. Finally the development environment uses the received refactoring information to replay the refactorings from the first workspace on the second workspace and also applies the incoming change information to that second workspace.

The refactoring information is a place to store refactorings as semantic operations and allows this refactoring information during an update operation to refactor artifacts which originally were not part of the first workspace where the refactoring has been recorded.

The method according to the present invention is particularly useful for large layered software systems which are developed by distributed teams. Refactorings performed on lower layers may cause changes which would normally break higher levels. Using the method according to the present invention allows such breaking changes to be adopted automatically by replaying refactorings associated with incoming changes. Regarding the integration into existing VCS systems which do not support meta data to be associated with changes the method according to the present invention proves to be particularly convenient since the method in question does not require any meta data storage facility but also performs on file based VCS systems without any meta data capabilities. Another advantage of the method comprised in the present invention is the ability to selectively apply pending refactorings to the second workspace. Artifacts in the second workspace to be updated can therefore be gradually migrated to the state in the repository since refactoring changes provide richer semantics and time information.

According to a second aspect of the invention a method is provided for synchronization of a first workspace with a second workspace the workspaces being connected to a version control system. The method comprises at the first workspace for a first refactoring operation being performed on the first workspace performing a first refactoring step that results in a modification of an object storing the modification in a change information for the object storing in a change information recording step the change information and storing in a descriptor recording step refactoring information comprising information enabling execution of a refactoring corresponding to the first refactoring step during an update operation. The method further comprises for a commit operation delivering in a change information delivery step the change information to the version control system for being retrievable into the second workspace to update the object therein and delivering in a descriptor commit step the refactoring information to the version control system for being retrievable into the second workspace and usable for a second refactoring operation. This method covers the part of the process that takes place at the first workspace.

According to a third aspect of the invention a method is provided for synchronization of a first workspace with a second workspace both workspaces being connected to a version control system. The method comprises for an update operation being performed on the second workspace retrieving into the second workspace in a load step from the version control system change information and refactoring information wherein the change information comprises a modification of an object that resulted from a first refactoring step that was performed on the first workspace and wherein the refactoring information comprises information enabling execution of a refactoring corresponding to the first refactoring step during the update operation. The method comprises also performing a second refactoring operation using the refactoring information and performing in an execution step an update of the object in the second workspace using the change information. This method covers the part of the process that takes place at the second workspace.

According to a fourth aspect of the invention a computer program element is provided comprising computer program code means which when loaded in a processor of a data processing system configures the processor to perform the above described method.

According to a fifth aspect of the invention a computer program product is provided comprising a computer readable medium embodying program instructions executable by a processor to perform the above described method.

The present invention also extends to a computer program element comprising computer program code means which when loaded in a processor of a data processing system configures the processor to perform a method for refactoring aware synchronization including refactoring of dependent artifacts not part of the workspace where the refactoring has been originally recorded during update operations.

According to a sixth aspect of the invention a first refactoring engine VCS extension is provided being a part of a first workspace adapted to deliver in a descriptor commit step refactoring information to a version control system for being retrievable into a second workspace and usable for a second refactoring operation wherein the refactoring information comprises information enabling execution of a refactoring corresponding to a first refactoring step during an update operation.

According to a seventh aspect of the invention a second refactoring engine VCS extension is provided being a part of a second workspace adapted to receive from a second VCS client refactoring information wherein the refactoring information comprises information enabling execution of a refactoring corresponding to a first refactoring step during an update operation and to determine under use of the refactoring information pending refactorings for the object in the second workspace associated with a change information wherein the change information comprises a modification of an object that resulted from a first refactoring step that was performed on a first workspace.

The recording of refactorings comprises the detection of refactorings performed on a first workspace the storage of refactoring information such as references to elements to be refactored or other user defined input in a first workspace and the ability to associate recorded refactorings with a module of a VCS system. The first workspace can be structured to encompass a user or program data section and a meta data area. The latter is a preferred place to store the refactoring information.

In a preferred embodiment of this invention refactorings are tracked by the first refactoring engine module itself which queries a particular refactoring operation for a refactoring descriptor describing its current state and stores this information in refactoring histories organized per project directory. A refactoring is associated with the project containing the element to be refactored.

During a commit operation of outgoing changes to a VCS repository an extension of the VCS system contributed by the refactoring engine and therefore referred to as first refactoring engine VCS extension queries for refactoring information of refactorings performed on artifacts which refactorings are part of the outgoing changes and stores this refactoring information along with the change information in the VCS repository. Since the artifacts in a workspace are usually organized hierarchically in project directories folders and files the refactoring engine advantageously associates refactoring information with the project directory corresponding to the VCS module shared in the repository.

In a preferred embodiment of this invention the refactoring engine maintains separate refactoring histories for each project directory corresponding to a VCS module. Upon commit operations the refactoring engine VCS extension computes the project directories affected by the outgoing changes queries the refactoring engine for the recorded refactoring information and stores this information in conjunction with the actual change information in the repository.

During an update operation which computes the difference between the history file at the local workspace and the VCS repository the refactoring engine VCS extension can present outgoing and incoming changes to the user for a possible selection or deselection of items within the change information. The changes can comprise both refactorings and traditional textual changes. The user can hence effectuate selective deliverance of outgoing changes or acceptance of incoming changes. This can be applied similarly for the commit operation.

During an update operation of incoming changes from a VCS repository the second refactoring engine VCS extension first determines whether any refactoring information is associated with the incoming changes. In case there is such information available the refactoring engine is asked to interpret this information re instantiate the original refactorings and perform the refactorings on the workspace. After the execution of the refactorings the incoming changes are merged with the workspace and the workspace is now synchronized with respect to the incoming refactorings and textual changes.

In a preferred embodiment of this invention this process of computing the differences of the workspace with the VCS system in terms of refactorings and textual changes storing refactoring information associated with change information during commit retrieving refactoring information and executing the associated refactorings before the update is implemented by a refactoring engine VCS extension using a synchronize hook a commit hook and a pre update hook offered by the underlying VCS system.

According to a second aspect of the invention a computer program product comprising a computer readable medium embodying program instructions executable by a processor to perform a method as described above is presented.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not necessarily restrictive of the present disclosure. The accompanying drawings which are incorporated in and constitute a part of the specification illustrate subject matter of the disclosure. Together the descriptions and the drawings serve to explain the principles of the disclosure.

Reference will now be made in detail to the subject matter disclosed which is illustrated in the accompanying drawings.

The first workspace W contains here the first project P with a first file F. The first file F declares a first programming language element E e.g. a function or a class or a STRUCT etc. The first project P is shared with the version control system V and without loss of generality assumed to be in synchronized state. The second workspace W also contains the first project P with the first file F shared with the version control system V and in synchronized state. The second workspace W additionally contains an unshared second project P with a second file G whose content references the first programming language element E declared in the first file F in the first project P. Hence in the second workspace W the second project P has a dependency D on the first project P. The first workspace W also comprises a first VCS client and a first refactoring engine module . The second workspace W also comprises a second VCS client .

A first refactoring operation ROP can be triggered by a first user U. As an example here the first programming language element E declared in the first file F in the first project P of the first workspace W is renamed to E during a first refactoring step executed by the first refactoring engine module that belongs to the first workspace W. The execution of the first refactoring step results in a textual modification of the first file F in the first project P of the first workspace W. This modification is stored in a change information C for the first file F wherein this modification expresses itself as a character string change. Exemplarily here also a purely textual change of the first file F is performed in that a comment is added thereto. Also this modification is stored in the same change information C.

In a commit operation COP that can be triggered by the first user U the first VCS client retrieves the change information C in a retrieval step from the first workspace memory and delivers the change information C in a delivery step via the version control system V to the repository . The change information C comprises essentially the information that a content change information has happened in the first file F and also comprises the new content of the first file F. The change information delivery step is performed by the first VCS client that is functional at the first workspace W.

In an update operation UOP that can be triggered by a second user U the change information C is loaded in a loading step into the second VCS client from the repository of the version control system V. The change information C is applied in an execution step by the second VCS client such that the content of the first file F in the second workspace W is updated with the new content of the first file F stored in the repository thereby reflecting the modifications contained in the change information C.

The first refactoring operation ROP has only produced the modifications in the change information C to update the content of the first file F to a new version in both workspaces W W. The second VCS client has no notion that one of the modifications in the change information C is stemming from a refactoring type operation namely here the renaming of the first programming language element E to E and hence has no means to make any corrections that are necessary from the first refactoring operation ROP. Hence after the update operation UOP in the second workspace W the first file F has a new content with the renamed first programming language element E but the reference from the second file G still points to the first programming language element E which however no longer exists. This outdated reference to the first programming language element E will later lead to errors if it is not somehow corrected beforehand.

The first workspace W contains here the first project P with a first file F containing a first programming language element E all being objects within the first workspace W. The first project P is shared with the version control system V and without loss of generality assumed to be in synchronized state. The second workspace W also contains as objects the first project P with the first file F containing the first programming language element E shared with the version control system V and in synchronized state. The second workspace W additionally contains a second project P which can be shared or unshared with a second file G whose content references the first programming language element E in the first file F in the first project P. Hence in the second workspace W the second project P has a dependency D on the first project P via the first programming language element E. The first workspace W also comprises a first VCS client a first refactoring engine VCS extension and a first refactoring engine module . The second workspace W also comprises a second VCS client a second refactoring engine VCS extension and a second refactoring engine module .

The first refactoring engine VCS extension is arranged with connections to both the first refactoring engine module and the first VCS client .

A first refactoring operation ROP can be triggered by a first user U. As an example the first programming language element E in the first file F in the first project P of the first workspace W is renamed to E during a first refactoring step executed by the first refactoring engine module that belongs to the first workspace W. The execution of the first refactoring step results in a textual modification of the first file F in the first project P of the first workspace W. This modification is stored in a change information C for the first file F.

Exemplarily here also a purely textual change of the first file F is performed in that a comment is added thereto. Also this modification is stored in the same change information C. That means other modifications of the object P F are also stored in the change information C. Hence the change information C tells that the first file F has been changed to become a modified first file F . This modification is not expressed in any semantic or logical way instead it tells the amendment in the character string from the first file F to the modified first file F . The change information C is stored in the first workspace memory in a change information recording step .

Also in a descriptor recording step a refactoring information hereinafter also referred to as refactoring descriptor is generated by the first refactoring engine module and stored in the first workspace memory . Hence the descriptor recording step is executed by a first refactoring engine module that is functional at the first workspace W. The refactoring descriptor comprises information about the first refactoring step . In this example the refactoring descriptor comprises information that the first programming language element E in the first file F has been renamed to E by means of a refactoring operation. Such refactoring descriptor contains the information that allows to reconstruct and execute the corresponding refactoring during an update operation. For instance such information includes the programming language element to be refactored the time of the refactoring execution an identifier of the refactoring type and the parameters specific to the refactoring type denoted by this identifier.

For the first refactoring operation ROP being performed on the first workspace W hence a first refactoring step is performed resulting in a modification of an object P F the modification is stored in a change information C for the object P F and in a change information recording step the change information C is stored and in a descriptor recording step the refactoring information comprising information enabling execution of a refactoring corresponding to the first refactoring step during an update operation UOP is stored

The format of the refactoring descriptor for the described embodiment here is for example specified by the XML markup language 

It hence contains the type of the refactoring operation rename and its parameters. In this embodiment this is a first parameter being the name of the object that is affected by this operation i.e. the object P F E that is renamed another parameter specifying the new name of the object El and the timestamp telling when the operation has been executed. As an optional addition here also a version number is given to accommodate for later updates in the descriptor syntax by identifying its version e.g. here 1.0. The refactoring descriptor hence contains the identifying parameters for the refactoring that is the root of the corresponding modification contained in the change information C. While the change information C for any of its modifications only comprises the string change information the refactoring descriptor contains the semantic identification of the refactoring operation. The refactoring descriptor is here written into a refactoring history file H that is associated with the first project P. The refactoring information is hence stored in a subfolder of a directory of the object P.

Next a commit operation COP is triggered by the first user U. Here this triggering action is in contrast to the embodiment depicted in routed to the first refactoring engine VCS extension . The first refactoring engine VCS extension causes two further steps In a change information retrieval command step the first VCS client is triggered to perform a change information retrieval step . In a refactoring descriptor retrieval command step the first refactoring engine module is triggered to perform a descriptor retrieval step .

The first VCS client retrieves the change information C in the change information retrieval step from the first workspace memory and delivers the change information C in a change information delivery step via the version control system V to the repository . The change information C comprises essentially the information that the content of the first file F has changed to the modified first file F and also comprises the new content of the modified first file F .

In the refactoring descriptor retrieval command step the first refactoring engine module is queried for the refactoring information belonging to the outgoing change information C. In the descriptor retrieval step the first refactoring engine module retrieves the refactoring descriptor from the first workspace memory see dashed line in and delivers it to the first refactoring engine VCS extension which in a descriptor commit step delivers that refactoring descriptor via the version control system V to the repository see dashed line in . The descriptor commit step is performed by the first refactoring engine VCS extension that is functional at the first workspace W and that is connected to the first VCS client and the first refactoring engine module . The first refactoring engine VCS extension makes here use of the standard functionality of the first refactoring engine module to be able to retrieve the refactoring descriptor belonging to a specific change information C for the first refactoring engine VCS extension . This allows to plug a first refactoring engine VCS extension right into an existing system that comprises already a first VCS client and a first refactoring engine module while also modifying the existing first refactoring engine module to offer the functionality to record and store the refactoring descriptor or alternatively by replacing the existing first refactoring engine module with another first refactoring engine module that offers the functionality to record and store the refactoring descriptor . Alternatively the first refactoring engine VCS extension can retrieve the refactoring descriptor directly from the first workspace memory if the first refactoring engine VCS extension is equipped with that functionality.

The refactoring descriptor is here serialized into the refactoring history file H located in the folder hierarchy of the project directory of the first project P in the repository . The refactoring history file H which preferably is a hidden file lists the refactorings executed on the first project P in chronological order using e.g. an XML markup similar to the example above depicting the XML markup of the refactoring descriptor . The advantage of this solution is the participation of the refactoring history file H in the update operation UOP since the refactoring history file H can be processed by the update operation UOP of the version control system V in the same manner during merging of project directories folders and files as any file with textual content. This allows the described method and the first refactoring engine VCS extension to be connected with any existing type of first VCS client . A disadvantage would be that the change information C and the refactoring descriptor are not stored as a logical unit and hence the first refactoring engine VCS extension has the extra task to make sure that the corresponding pair of change information C and refactoring descriptor are associated with each other.

Between the descriptor retrieval step and the descriptor commit step respectively between the change information retrieval step and the change information delivery step there is an optional step of allowing the first user U to intervene with the process. Therein the change information C can be presented to the first user U for deselection of items contained therein from being delivered in the change information delivery step . Also therein the refactoring information is presented to the first user U for deselection of items contained therein from being delivered in the descriptor commit step .

Any of the first VCS client the first refactoring engine VCS extension and the first refactoring engine module can display as items to the first user U the modifications contained in the change information C and or the refactoring descriptor . The first user U is then enabled to choose one of more of the displayed items to be deselected from the list of items before they are committed. Only the remaining selected items of the change information C and of the refactoring descriptor will be further processed as outgoing changes to the repository . This way the first user U has a possibility to prevent modifications to be committed that the first user U does not desire. The refactoring descriptor provides here the advantage that the first user U gets semantic information that describes what kind of operation will be executed whereas the change information C will only disclose which file is subjected to a modification. It becomes clear that the information change the first file F to become the modified first file F as reflected in the change information C is not as helpful to the first user U as the information rename in the first file F the first programming language element E to E1 as reflected in the refactoring descriptor .

The intervention possibility can in a preferred embodiment also be implemented in a way that the first user U is presented with the change information C and the refactoring descriptor at the same time such that the first user U can perform the deselection selection in a single step whereupon the change delivery step and the descriptor commit step are continued.

In summary for the commit operation COP in the change information delivery step the change information C is delivered to the version control system V for being retrievable into the second workspace W to update the object P F therein and in a descriptor commit step the refactoring information is delivered to the version control system V for being retrievable into the second workspace W and usable for a second refactoring operation ROP.

Update Operation The second refactoring engine VCS extension is arranged with connections to both the second refactoring engine module and the second VCS client .

An update operation UOP can be triggered by a second user U. Here this triggering action is in contrast to the embodiment depicted in routed to the second refactoring engine VCS extension . The second refactoring engine VCS extension causes two further steps In an update load command step the second VCS client is triggered to perform a load step . The load step is performed by the second VCS client that is functional at the second workspace W. In a refactoring command step the second refactoring engine module is triggered to perform a second refactoring operation ROP comprising a second refactoring step .

In the load step the change information C and the refactoring descriptor are loaded into the second VCS client from the repository of the version control system V. The refactoring descriptor is routed via the second refactoring engine VCS extension to the second refactoring engine module see dashed line in .

At this point there is another optional step of allowing the second user U to intervene with the process. Therein the change information C can be presented to the second user U for deselection of items contained therein from being applied in the execution step . Also the refactoring information can be presented to the second user U for deselection of items contained therein from being used in the second refactoring operation ROP.

Any of the second VCS client the second refactoring engine VCS extension and the second refactoring engine module can display as items to the second user U the modifications contained in the change information C and or the refactoring descriptor . The second user U is then enabled to choose one of more of the displayed items to be deselected from the list of items. Only the remaining selected items of the change information C and of the refactoring descriptor will be further processed as incoming changes to the second workspace W. This way the second user U has a possibility to prevent modifications that the second user U does not desire. The refactoring descriptor provides also here the advantage that the second user U gets semantic information that describes what kind of operation will be executed whereas the change information C will only disclose which file is subjected to a change information.

In the second refactoring step the refactoring descriptor is used to instantiate and execute a refactoring operation on the folders and files in the second workspace memory . Since in the refactoring descriptor the renaming of the first programming language element E to E in the first file F is designated as part of a refactoring operation the second refactoring step produces a renaming not only of the first programming language element E but also of the reference of the second file G towards that first programming language element E. Hereby the dependency D is updated.

At this point there is another optional step of allowing the second user U to intervene with the process. Any of the second VCS client the second refactoring engine VCS extension and the second refactoring engine module can display as items to the second user U the modifications contained in the change information C. The second user U is then enabled to choose one of more of the displayed items to be deselected from the list of items. Only the remaining selected items of the change information C will be further processed as incoming changes to the second workspace W. This way the second user U has a possibility to prevent modifications that the second user U does not desire. If this step is offered the previous intervention possibility can be limited to the refactoring descriptor .

Then the change information C is merged into the execution step by the second refactoring engine VCS extension using basic commands from the second VCS client such that the first file F in the second workspace W is updated with a new content thereby reflecting the modifications contained in the change information C depending on the relation between the change information C and the refactoring descriptor . The merge process is described further below in more detail.

The refactoring descriptor is here obtained from a hidden refactoring history file H located in the folder hierarchy of the project directory of the corresponding project.

Next the process at the second refactoring engine is described in more detail. Without loss of generality it is now assumed that there are several refactoring descriptors to be synchronized from the repository . Also it is assumed that the system described here has a history i.e. there have been refactoring commit and update operations before and hence there is a refactoring history. This refactoring history leaves its traces in the system namely in that the refactoring operations have produced refactoring descriptors that are maintained in a refactoring history file at the respective entity. Hence for each project subjected to refactoring there is a refactoring history file at the repository hereinafter referred to as repository history file RH and also a refactoring history file at the second workspace W hereinafter referred to as workspace history file WH. In the current embodiment the repository history file RH comprises the refactoring history file H.

The repository history file RH is delivered together with the change information C to the second VCS client .

After the load step the second refactoring engine VCS extension first determines whether there are pending refactorings associated with the incoming change information C. The set of pending refactorings is computed by determining the difference between the received repository history file RH and the present workspace history file WH. In the example described above the difference of the refactoring history of the first project P contains one incoming refactoring descriptor for the performed first refactoring operation ROP which renamed the first programming language element E in the first file F to E. Hence the first refactoring operation ROP is identified as a pending refactoring.

In this embodiment the second refactoring operation ROP is performed before the execution step . The second refactoring engine VCS extension is arranged at the second workspace W to determine under use of the refactoring information the pending refactorings for the object P F in the second workspace W associated with the change information C.

Then the second refactoring engine module processes for the pending refactorings the refactoring descriptors associated with the incoming change information C. The second refactoring engine module processes the incoming refactoring descriptors by examining the hidden refactoring history file H. The refactoring descriptors for the pending refactorings are hereinafter referred to as pending refactoring descriptors .

Then the second refactoring engine module examines the pending refactoring descriptors checks whether a refactoring implementation to execute the pending refactoring described in the respective pending refactoring descriptor is available. A refactoring implementation is here executable code such as a component of a development environment IDE . Such code is able to execute the transformation of the specified refactoring. If no refactoring implementation is found the refactoring descriptor is ignored and not selected for execution. The second user U can be informed of this situation.

Next if more than one pending refactoring descriptor exists it sorts the pending refactoring descriptors in ascending order of their time stamps meaning that refactorings executed in the first refactoring operation ROP by the first refactoring engine module are executed in the same order during the update operation UOP respectively the second refactoring operation ROP.

Third the second refactoring engine module sequentially executes the pending refactorings. This process must not necessarily be implemented as a transaction but the method described here also supports the incremental execution of pending refactorings during the update operation UOP i.e. allowing the second user U to deselect any of the presented refactorings. In a preferred embodiment the pending refactorings are handled similarly as the incoming change information C i.e. pending refactorings and incoming change information C are treated uniformly during the update operation UOP. The update operation UOP comprises a number of independent executions of pending refactorings terminated by the updating of the second workspace W with the incoming change information C. In the case above the second refactoring engine module executes the second refactoring step which renames the local version in the second workspace W of the first programming language element E in the first file F of the first project P to E. The second refactoring step not only produces a change to rename the first programming language element E to E but also a change to adapt the reference to the first programming language element E in the second file G of the second project P of the second workspace W to E. This results in all references to the first programming language element E in the second workspace W being refactored to E as well thereby avoiding errors or inconsistencies.

Fourth the incoming change information C is merged with the second workspace W i.e. it is executed by means of the second refactoring engine VCS extension using the basic update overwrite and merge commands from the second VCS client . The content change of the first file F in the first project P cannot be simply applied to the second workspace W using the second VCS client since the second refactoring step already caused a content change to the first file F in the first project P in the second workspace W. Hence to perform this change here would result in a merge conflict in the VCS client . The merge process to remedy this situation works as follows 

Therefore an intersection set S is defined as the intersection of the files and folders modified by the change information C and also by the refactoring execution step . The intersection set S in the second workspace W contains here the first file F of the first project P. For the merge process the following cases exist 

The intersection set S is empty. The refactoring engine VCS extension can delegate the change execution to the second VCS client . The processing of the change information C is done within the execution step .

The intersection set S is not empty. It can be divided into two intersection subsets a first intersection subset SN and a second intersection subset SO such that the following holds The first intersection subset SN contains all artifacts A from the intersection set S which did not have an outgoing change before the refactoring execution step . The second intersection subset SO contains all artifacts A from the intersection set S which had an outgoing change before the refactoring execution step . Outgoing changes are those changes that are pending for any object in the second workspace W which changes result from any kind of modification executed on that object before the second user U has triggered the update operation. Hence SO S SN. The artifacts A from the intersection subsets SN and SO are processed as follows 

For the artifacts A contained in the first intersection subset SN a pseudo merge conflict arises. Since the same refactorings have been applied to both the first workspace W and the second workspace W the modifications comprised by the change information C are a superset of the modifications comprised by the second refactoring execution step . The second refactoring engine VCS extension can apply the part of the change information C associated with the artifacts A in the first intersection subset SN to the second workspace W. For the artifacts A in the first intersection subset SN the second refactoring engine VCS extension triggers an overwrite operation via the second VCS client within the execution step . In other words for the concrete embodiment of the renaming of the first programming language element E the refactoring operation described by the refactoring descriptor has been executed in the refactoring execution step thereby renaming the first programming language element E to El and inherently modifying the first file F to the content of the modified first file F . Thereafter in the execution step the change information C will replace the first file F with the modified first file F factually changing nothing since the content of the first file F was already that of the modified first file F . Other changes that are not associated with refactoring operations e.g. the insertion of the textual comment into the first file F are applied by the second VCS client without activity of the second refactoring engine VCS extension therefore. Hence the pseudo merge conflict is resolved automatically. The modifications created to the object P F by the second refactoring operation ROP are overwritten by modifications to the object P F created by the execution step .

For the artifacts A contained in the second intersection subset SO a real merge conflict arises since they have one or more outgoing changes conflicting with one or more incoming changes. The second refactoring engine VCS extension triggers a merge operation for all artifacts A in the second intersection subset SO via the second VCS client possibly requiring user intervention as is standard in existing VCS systems. One simple way to automate conflict resolution can be to alert the corresponding second user U of the conflict and to either automatically delete the conflicting changes or to allow the second user U to select which of the changes shall be applied in which order.

Another possibility is to first conduct the execution step and thereafter to execute the second refactoring step . In that scenario the change information C would be completely applied by the second VCS client within the execution step and thereafter the second refactoring engine VCS extension would execute all pending refactorings by using the pending refactoring descriptors . The refactoring operation would not find the previous files and folders that have been changed in the execution step such that those files and folders will be simply left alone by the second refactoring engine module . This method is still less preferred than the opposite order of steps since at the example of the herein described embodiment finding any additional references to the first programming language element P F E can not be conducted with a normal compiler based search mechanism because the original first programming language element P F E does no longer exist in the second workspace W.

The first and second VCS extension hence are additional modules that enable the refactoring aware synchronization in that they handle the communication of the refactoring descriptor between the workspaces W W and the version control system V. The first refactoring engine VCS extension is a part of a first workspace W adapted to deliver in the descriptor commit step the refactoring information to the version control system V for being retrievable into the second workspace W and usable for the second refactoring operation ROP the refactoring information comprises information enabling execution of a refactoring corresponding to the first refactoring step during the update operation UOP.

The second refactoring engine VCS extension is in particular arranged for controlling the performance of the second refactoring operation ROP and the execution step relative to each other. Such control can comprises selecting the order of the steps to be performed and controlling their parameters. Here the second refactoring engine VCS extension controls the retrieval of the refactoring descriptor the decision which refactorings will be executed in the second refactoring operation ROP and which changes will be applied in the execution step . The second refactoring engine VCS extension is arranged at the second workspace W to determine under use of the refactoring information pending refactorings for the object P F in the second workspace W associated with the change information C. In particular the second refactoring engine VCS extension is adapted to receive via the second VCS client the refactoring information wherein the refactoring information comprises information enabling execution of a refactoring corresponding to the first refactoring step during the update operation UOP and to determine under use of the refactoring information pending refactorings for the object P F in the second workspace W associated with the change information C wherein the change information C comprises a modification of an object P F that resulted from the first refactoring step that was performed on the first workspace W.

The system has been described for a refactoring that is first executed in the first workspace W whose result is then transported onto the second workspace W. However the system can also be extended to enable this process to run in the opposite direction to allow bidirectional refactoring aware synchronization. Therefor the respective components of the first workspace W and of the second workspace W are added in a mirrored fashion i.e. to the first refactoring engine module is added the functionality of the second refactoring engine module and to the second refactoring engine module is added the functionality of the first refactoring engine module . Similarly this is done for the first and second refactoring engine VCS extensions so they can both perform the commit operation COP and the update operation UOP. Then the first refactoring engine VCS extension is arranged to also perform the functionality of the second refactoring engine VCS extension and vice versa. Also the first and second VCS client are amended in a corresponding manner.

The refactoring descriptor may alternatively associated with the change information C using the following approach The refactoring descriptor may be stored in the repository as a meta data extension to the change information C i.e. refactoring information is stored as meta data associated with the change information C. The version control system V may therefore provide an explicit feature to attach additional information to a change information C that is delivered to the repository . This way the refactoring descriptor and the change information C are automatically kept together which facilitates handling and reduces the amount of logic. The second refactoring engine module interprets the incoming refactoring descriptors by examining the meta data extension to the change information C. As this is possible for the commit operation COP it is also possible in the update operation UOP If the version control system V supports a meta data extension mechanism for changes the refactoring descriptor may be obtained from the change information C itself.

The system described works for any type and combination of refactoring operations. Also it can be extended to work between an arbitrary numbers of workspaces that share the same VCS. More particularly although the embodiment has been described for one refactoring operation it can be extended within the scope of the invention also to work with the following modifications The change information C can also comprise the modifications to multiple files such as several non refactoring type modifications and or refactoring type modifications to one or more files. This can in an advantageous manner also comprise refactoring operations that effectuate modifications to several files. A typical scenario could be to group the refactoring descriptors of several refactorings executed in a row e.g. during a refactoring session into a single change information C. Another generalization applies to the commit operation. It is also possible to perform several commit operations on the first workspace W and only thereafter to execute one update operation on the second workspace W. The update operation in the load step load all incidents of the change information C into the second workspace W for the update. So the load step can load several pieces of change information C and several refactoring descriptors into the second workspace W from the repository .

The method for synchronization of several workspaces may be implemented in part or as a whole in software or hardware or a combination thereof. The method may implemented in hardware be performed by a device for determining a malicious workload pattern. The method may implemented in software be performed by a computer program product. The computer program product may be provided on a computer readable medium embodying software instructions executable by a computer to perform the steps of the method. The computer readable medium may for example be a CD ROM a DVD a flash memory card a hard disk or any other suitable computer readable medium e.g. a storage medium within a network.

In the present disclosure the methods disclosed may be implemented as sets of instructions or software readable by a device. Further it is understood that the specific order or hierarchy of steps in the methods disclosed are examples of exemplary approaches. Based upon design preferences it is understood that the specific order or hierarchy of steps in the method can be rearranged while remaining within the disclosed subject matter. The accompanying method claims present elements of the various steps in a sample order and are not necessarily meant to be limited to the specific order or hierarchy presented.

It is believed that the present disclosure and many of its attendant advantages will be understood by the foregoing description and it will be apparent that various changes may be made in the form construction and arrangement of the components without departing from the disclosed subject matter or without sacrificing all of its material advantages. The form described is merely explanatory and it is the intention of the following claims to encompass and include such changes.

