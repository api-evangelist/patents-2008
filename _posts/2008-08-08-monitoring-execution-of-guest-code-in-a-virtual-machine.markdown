---

title: Monitoring execution of guest code in a virtual machine
abstract: A method is provided for monitoring registered code in a virtual machine of a virtualization system. The method includes instantiating a guest in the virtual machine of the virtualization system and monitoring execution of code registered for monitored execution in an execution context of the guest. The monitoring is performed by the virtualization system and is hidden from computations of the guest.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08402441&OS=08402441&RS=08402441
owner: VMware, Inc.
number: 08402441
owner_city: Palo Alto
owner_country: US
publication_date: 20080808
---
This application claims benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 60 954 733 filed Aug. 8 2007.

In addition this application is related to the following commonly owned co pending US Patent Applications 1 12 051 516 filed Mar. 19 2008 entitled IMPEDING PROGRESS OF MALICIOUS GUEST SOFTWARE and naming as inventors Budko Chen Horovitz and Waldspurger 2 12 188 973 filed Aug. 8 2008 entitled FORCING REGISTERED CODE INTO AN EXECUTION CONTEXT OF GUEST SOFTWARE and naming as inventors Budko Chen Horovitz Subrahmanyam and Waldspurger 3 10 791 602 filed Mar. 2 2004 entitled DYNAMIC VERIFICATION OF VALIDITY OF EXECUTABLE CODE and naming as inventors Waldspurger Agesen Chen Zedlewski and Garfinkel and 4 11 584 178 filed Oct. 20 2006 entitled ISOLATING DATA WITHIN A COMPUTER SYSTEM USING PRIVATE SHADOW MAPPINGS and naming as inventors Chen Waldspurger and Subrahmanyam.

The vulnerability of computer systems configurations software information codings and protocols to unauthorized access or use is problematic. In general these vulnerabilities can range from minor annoyances to national security risks. Automated tools facilitate probing of systems and discovering vulnerable systems and configurations. Once vulnerabilities are identified exploits often embodied as computer viruses worms trojans spyware rootkits and or other malicious forms of code can be globally disseminated and rapidly employed.

In recognition of threats posed by such vulnerabilities methods have been developed to identify malicious software in use in media or in transit. Indeed persons of skill in the art will appreciate a broad range of existing methods including signature and or behavior based detection methods employed in commercially available anti virus and or intrusion detection prevention systems.

Unfortunately once running malicious software may attempt to hide itself disable existing security checks or otherwise evade detection. In some cases the very tools and facilities that might be relied upon to detect isolate terminate or mitigate malicious code are themselves subject to compromise. For example if an operating system or an antivirus intrusion detection facility is itself compromised it may be unrealistic to expect the compromised system facility to reliably interdict malicious code even if an exploit is successfully identified. Indeed a common strategy of many exploits after gaining privileged access is to disable interfere with or otherwise subvert the very systems that are designed to protect against them.

Embodiments of the present invention include methods systems apparati computer program products and other tangible realizations of techniques for monitoring execution of registered code within a virtual machine wherein the monitoring is performed from behind a virtualization barrier without reliance on functionality of a guest operating system executing within the virtual machine. In particular one embodiment of the present invention is a method comprising a instantiating a guest in a virtual machine of a virtualization system and b monitoring execution of code registered for monitored execution in an execution context of the guest wherein the monitoring is performed by the virtualization system and is hidden from computations of the guest.

Various programs and protective constructs such as anti virus scanners host firewalls intrusion detection software registry monitors etc. can benefit from system level support for assuring that certain specified operations are executed as intended. When the possibility exists that malicious software operates or could operate within a virtual machine it can be desirable to verify or guarantee such execution without relying on cooperation or support from the guest operating system or other software running within the virtual machine since the guest software may have already been compromised.

Accordingly in one or more embodiments in accordance with the present invention methods systems apparati computer program products and or other tangible realizations of techniques are employed to monitor code registered for execution within a virtual machine. Monitoring is performed from behind a virtualization barrier without reliance on functionality of a guest operating system executing within the virtual machine. For example in some embodiments the virtualization layer itself monitors whether or not registered guest code is actually executed as expected. If it detects that the registered code has not been executed as expected it can respond appropriately based on a specified security policy. Depending on the particular security policy implemented appropriate responses can include generation of notifications or alerts escalation of a security posture and or actions designed to forcibly execute the registered code.

For the most part embodiments of the present invention operate at or from a virtualization layer e.g. within a virtual machine monitor or hypervisor and do not require cooperation or support from a guest operating system running within a virtual machine. This independence can be useful when as is often the case an operating system is or may be compromised by the malicious software itself or via a complementary attack vector. That said persons of ordinary skill in the art will recognize that modern operating system vendors face increasing pressure to include virtualization features or capabilities in their product offerings and as a result product offerings styled as operating systems may increasingly incorporate virtualization system concepts. Accordingly it is important to recognize that a virtualization barrier or boundary i.e. a barrier or boundary between i software that manages exposes and or aggregates underlying hardware resources for presentation as a virtual machine and ii software that operates within such a virtual machine can exist at the interface between separately supplied software components or within software marketed aggregated and or supplied as a single product. Indeed embodiments that provide virtualization support in a software product marketed aggregated and or supplied as an operating system are envisioned and may fall within the scope of certain of the appended claims.

Some embodiments of the present invention allow registration of guest code that is intended to execute in response to certain trigger events. One simple example of an execution trigger is an amount of elapsed time specified in units such as milliseconds processor cycles or timer ticks. However triggers may also be specified in units of some other event such as a count of received network packets or a count of cache misses. Other types of triggers include attempts to execute some particular guest code address particular guest instruction type such as a syscall or memory management operations or even attempted accesses to particular guest memory addresses.

Although some embodiments of the present invention are described in an overall context that includes anti virus anti spyware intrusion detection protection or other anti malware systems or techniques it is important to recognize that embodiments of the present invention do not require anti malware systems or techniques. Indeed anti malware systems are but one example of code that may be monitored to assure execution within a virtual machine. Based on the description herein persons of ordinary skill in the art will appreciate applications to other types of monitored code in addition to anti malware systems. Furthermore some embodiments of the present invention are implemented in software systems or computer program products that do not themselves provide malware detection or protection but in which cooperative systems or products are used. Accordingly in some embodiments a generalized facility for registration of code to be monitored can be provided e.g. via an application programming interface API . Finally even in those embodiments in which anti malware systems or techniques may be implemented we do not presuppose any particular anti malware system or technique.

Several illustrative embodiments of the present invention are described herein. In general the described embodiments may be employed individually or in combination in a given implementation. The embodiments will be understood both in terms of general strategies such as selective alteration of virtual machine operation and or modifications to code and or control flows to transparently interpose on the execution of particular code memory accesses and or I O operations and based on specific implementations.

For example in some embodiments virtual machine operations executed by monitored code may be selectively altered to supply a hidden fault trap or interrupt under circumstances in which faithful emulation of a particular physical machine would not otherwise dictate. Such a hidden fault trap or interrupt can then be intercepted by the virtualization layer to record that corresponding code was actually executed. In some embodiments page table entries are selectively modified to generate such faults upon execution of code that appears within a monitored memory page. In some embodiments the instruction sequences actually executed for a particular execution context are altered. Typically such alterations can be made in the virtualization system e.g. using a binary translation facility to effect the desired changes to code semantics or control flows.

For concreteness embodiments based on facilities terminology and exploits typical of certain processor architectures operating systems virtualization systems and network protocols and or services are described. For example conventional processor and operating system features mechanisms and constructs typical of microprocessors and software available from Intel Corporation and Microsoft Corporation provide a useful descriptive context for our techniques. That said embodiments of the present invention are general to a wide variety of processor and system architectures including both single and multi processor architectures based on any of a variety of instruction set architectures to numerous operating system implementations as well as to computations that need not include or be coordinated by a conventional operating system.

Accordingly in view of the foregoing and without limitation on the range of underlying processor hardware or system architectures operating systems or virtualization techniques that may be employed in embodiments of the present invention based on these embodiments and on the claims that follow persons of ordinary skill in the art will appreciate a broad range of suitable implementations and embodiments.

As on a conventional hardware computer platform guest operating system coordinates execution sequences of instructions on one or more processors or CPUs helps to maintain memory management and or mapping information e.g. virtual to physical page mappings and manages devices of an underlying computational machine. Together the operating system and underlying computational machine e.g. guest operating system and VM of virtual computer in the illustrated configuration manage context switches amongst various execution contexts based on priority data or instruction memory access stalls input output events explicit code directives etc. Numerous techniques and designs both hardware and software for scheduling and performing context switches in multitasking multithreaded systems are known and will be understood by persons of ordinary skill in the art. However in each case the identity of at least a current execution context is part of the observable state of the computational machine or in the illustration of of VM .

From the perspective of operating system and the individual execution contexts thereof exposed VM appears to be and indeed behaves like a conventional hardware computer platform executing instruction sequences and presenting an apparent processor and memory state. Indeed in some embodiments of virtualization system the interface presented by VM may be nearly indistinguishable from a conventional hardware computer platform. However unlike a conventional hardware computer platform virtualization system itself manages underlying hardware resources e.g. without limitation CPUs memory devices and storage and generally exposes virtual resources e.g. virtual processor s vMEM virtual devices and virtual storage rather than the underlying resources themselves to guest computations such as guest operating system and any applications services executing therewith. In general the characteristics and configurations of an exposed virtual machine need not match those of underlying hardware resources although in many implementations a correspondence between instruction set architectures of exposed virtual processors and underlying hardware CPUs may be desirable.

Although particular virtualization strategies designs are described herein virtualization system is representative of a wide variety of designs and implementations in which underlying hardware resources are presented to software typically to operating system software and or applications as virtualized instances of computational systems that may or may not precisely correspond to the underlying physical hardware.

Virtualization systems are well known in the art and include commercial implementations such as VMware ESX VMware Server and VMware Workstation available from VMware Inc. Palo Alto Calif. Microsoft Virtual Server 2005 operating systems with virtualization support such as Linux KVM or user mode Linux UML and open source implementations such as those available from XenSource Inc. Accordingly persons of ordinary skill in the art will appreciate the described embodiments for selectively impeding progress of a targeted computation in the context of a substantial existing body of virtual machine technology.

Typically virtual resources of an exposed virtual machine are presented to a guest computation using mapping and or emulation techniques. In general some interface is provided between the guest software and the various hardware components and devices in the underlying hardware platform. This interface may include one or more software components and or layers possibly including one or more software components known in the field of virtual machine technology as virtual machine monitors VMMs hypervisors or virtualization kernels. For purposes of illustration only and without limitation VMM layer is illustrated in which the operative mappings and or emulations will typically be performed. In the description that follows certain enhancements or alterations are described that may be made to VMM and or VM operation to monitor execution of code in an execution context of guest operating system . These and other embodiments will be understood with reference to the description that follows.

Each virtual CPU vCPU typically has its own active context and at any given time an execution context e.g. current context will be current and state of at least one vCPU corresponds thereto. In particular register states instruction pointer state memory address translation data structures etc. presented by VM are those appropriate to the current state of current context . Therefore instruction sequences including sequences of user code and system calls appropriate to current context are executed on VM and ordinarily result in progress of a computation associated with current context . In particular individual instructions of instruction sequence are ordinarily executed and result in updates to register state of exposed vCPU . Control flow instructions affect call return stacks and load store instructions affect buffer and vMEM states as well as memory address translation data structures including page table states translation lookaside buffer TLB states etc that reside in memory exposed as vMEM . Input output operations affect the state of exposed vDEVs and typically transfer data through buffers in memory exposed as vMEM .

As is typical in the art switches between execution contexts are managed or initiated by operating system based on desired multitasking and scheduling behavior and based on events such as execution and or memory access stalls and interrupts or faults supplied by VM . Context switch handling is well understood in the art but typically includes writing back some state corresponding to a switched out context e.g. register state of a processor current instruction pointer stack pointer etc. to a backing store and loading from such a backing store e.g. memory at least some state corresponding to a switched in context. Of course in some processor implementations architectural techniques including e.g. large onboard register sets with context selectable subsets and simultaneous multithreading techniques may facilitate lightweight context switches in which overheads associated with transfers to and from a backing store can be minimized. Depending on the implementation VM particularly exposed vCPU may leverage similar facilities including those supported by underlying hardware.

In any case a switch between execution contexts typically results in some observable change in architectural state of the processor whether implemented as a hardware processor or as in as vCPU . For example in a processor conforming to the Intel IA 32 microprocessor architecture states of certain registers e.g. Control Register 3 CR3 also known as the Page Directory Base Register PDBR and the Local Descriptor Table Register LDTR which contains the address in memory of the Local Descriptor Table LDT can be expected to change in correspondence with a context switch. As a result contents of the CR3 register are often used in IA 32 architectures as a process id tracking mechanism. Of course other instruction set architectures and implementations may provide other facilities for tracking context switches and based on the description herein persons of ordinary skill in the art will appreciate suitable adaptations. For example some architectures expose an explicit address space identifier sometimes called an ASID which may be employed in a manner similar to that described above with respect to the CR3 register of IA 32 architectures. Similarly a guest operating system may use its own identifier for a context e.g. a process identifier PID . Accordingly in some embodiments in accordance with the present invention a virtualization system may read such an identifier directly from guest kernel memory. A memory trace may be used to detect when the guest operating system modifies the identifier as such a change may be made without modifying the architectural state of the processor.

Recognizing the variety of alternative mechanisms by which a processor and or operating system may maintain context identifiers embodiments of the present invention are described with generality. Accordingly in the illustration of VM exposes register s in or via which a context or process ID PID is encoded or may be referenced e.g. using CR3 LDTR ASID or PID states etc. for corresponding vCPUs. Note that despite the use here and elsewhere of the shorthand PID nothing herein shall be construed as limiting embodiments to mechanisms for context identification that rely on guest operating system support.

In illustrated virtualization system VMM exposes resources of hardware machine as virtual machine VM . For simplicity of illustration only a single virtual machine is illustrated. In general VMM manages utilization of underlying hardware structures and states typically through a combination of direct execution selective binary translation mapping and or emulation techniques. When possible it can be desirable to directly execute code that is scheduled for execution on a virtual machine e.g. vCPU on an underlying hardware processor e.g. CPUs . However for at least some instruction set architectures binary translation or emulation of at least certain code and or instructions may be necessary. Similarly it can be desirable for memory accesses performed by code executing on the virtual machine to efficiently map to locations in underlying hardware memory e.g. MEM using memory management constructs such as page tables and translation lookaside buffers TLBs exposed to guest software as part of a virtual machine but maintained coherently with memory management facilities of underlying hardware.

Typically both the internals of any direct execution and or binary translation mechanism and the internals of any segmentation memory management virtualization mechanisms will be hidden from guest computations. Accordingly a virtualization barrier is illustrated in to mark a somewhat arbitrary boundary between exposed and therefore visible states functionality and constructs of VM and those states functionality and constructs of VMM and underlying hardware that are hidden from guest computations.

Of course a number of significant practical challenges exist for virtualization system implementations that seek to directly execute code and coherently map underlying physical memory particularly for virtualization of processors that implement the ubiquitous x86 or IA 32 instruction set architecture. In particular practical implementations must typically deal with instruction sets that include instructions sometimes called non virtualizable instructions that behave differently depending on an execution mode. Classic examples include instructions such as the IRET and PUSHF instructions implemented in x86 processors which behave differently based on a privilege level. Another set of practical challenges involves implementations of segmented architectures that include segment registers which are used to help manage and provide protection for a memory address space. In particular semantics of certain IA 32 specific segment operations lead to reversibility challenges that are described and addressed in the art. While elegant solutions to these problems can be non trivial and virtualization system embodiments in accordance with the present invention may build upon such solutions embodiments of the present invention relate more directly to selective alteration of virtual machine behavior for targeted execution contexts.

Therefore certain aspects of virtualization system implementations are summarized and certain more detailed descriptions of specific implementations are incorporated herein by reference from a U.S. Pat. No. 6 397 242 to Devine Bugnion and Rosenblum describes methods for managing a mix of directly executable code and code for which binary translation may be performed b U.S. Pat. No. 6 704 925 to Bugnion which among other things describes implementation of a dynamic binary translator mechanism and methods for maintaining coherence of a translation cache c U.S. Pat. No. 6 785 886 to Lim Le and Bugnion which among other things describes methods for shadowing segment descriptors in a VMM implementation and maintaining backmaps to address segment reversibility challenges and d U.S. Pat. No. 7 222 221 to Agesen Subrahmanyam and Adams which among other things describes methods for maintaining shadow page tables in a virtualization system and for maintaining coherence between related memory management data structures in a VM a VMM and underlying hardware. U.S. Pat. Nos. 6 397 242 6 704 925 6 785 886 and 7 222 221 are therefore each incorporated herein by reference and persons of ordinary skill in the art will appreciate based on the description herein virtualization system implementations that build upon code execution translation methods and or segment memory management virtualization methods described in detail in any of the incorporated patents.

Notwithstanding the foregoing persons of ordinary skill in the art will readily understand embodiments of the present invention with reference to a more simplified view of VMM operations presented in . For example in the illustration of VMM provides selective code execution facilities using any suitable mechanism including but not limited to those described in the above incorporated patents . In general selective code execution facilities allow certain code to execute directly on underlying hardware in furtherance of the computation executing on exposed vCPU while supporting at least some method e.g. a binary translation method hardware assisted virtualization or other trap and emulate methods etc. for executing alternative or modified instruction sequences when needed or when desirable. In general hardware assisted virtualization methods include those extensions to 32 bit and 64 bit x86 architecture commonly known as Intel VT Intel Virtualization Technology and AMD V AMD Virtualization which provide hardware support for trap and emulate methods whereby a VMM may specify those events that will cause the hardware to exit guest execution and trap into the VMM.

Apart from embodiments of the present invention the availability of a binary translation for certain instructions or code blocks facilitates use of an efficient direct execution path for most code while ensuring that non virtualizable instructions or code blocks can be handled in a way that is faithful to the function semantics of the original code. However relative to embodiments of the present invention selective code execution facilities whether supported using binary translation hardware assisted trap and emulate methods or otherwise can be adapted to provide a method for selectively altering the behavior of VM for a targeted execution context. In particular some embodiments employ facilities of a binary translation emulation or other facility to replace original code sequences or individual instructions that would ordinarily be executed in connection with current context with code that is augmented to generate at least some side effect discernable by monitoring code while still faithfully replicating the function semantics of the original code.

Augmentation may simply introduce e.g. responsive see to a registration see one or more extra instructions into a program sequence of code executed on behalf of context . For example the introduced instruction s may increment a counter set a flag in memory or in a register exposed by VM execute a system call etc. Alternatively the introduced instruction s may be selected to trigger an exception or fault that may then be intercepted by the virtualization layer monitoring code of VMM to increment a counter set a flag or otherwise record transit of the current context execution flow through registered code.

In a similar way mapping shadowing and tracing mechanisms employed by VMM to efficiently handle segmentation and memory management expose a VM specific set of segment register states TLB states and page table hierarchies while mapping memory accesses and paging operations to underlying states and locations in memory . As with the selective code execution facilities described above mapping shadowing and tracing mechanisms are typically used to faithfully present virtual and physical address spaces consistent with the machine virtualized. However in accordance with one or more embodiments of the present invention such facilities can be employed to generate at least some side effect discernable by monitoring code while still faithfully replicating the memory model of the exposed virtual machine.

For example responsive see to a registration see page attributes or mapping information corresponding to registered code may be updated so that upon an attempt to execute code on the corresponding page an exception or fault is triggered. That exception or fault may then be intercepted by the virtualization layer e.g. monitoring code of VMM to discern whether the faulting access indicates execution of the registered code and if so increment a counter set a flag or otherwise record transit of the current context execution flow through registered code. Similar techniques may be used in hardware assisted virtualization systems to detect and respond to an execution of registered code.

In each case monitoring and selective alteration of VM behavior are performed from behind virtualization barrier and may be hidden from both guest operating system and the affected execution context e.g. current context . Building on the foregoing illustration of a suitable virtualization system infrastructure a few strategies for registering and monitoring code are described.

As described herein a variety of programs or functions that may be executed within a guest context such as anti virus scanning intrusion detection firewall status operating system integrity checks etc. can benefit from virtualization system level support for ensuring that specified operations thereof are actually being executed as intended. To identify the operations of interest a registration facility can be provided as illustrated in . In general some sort of identifying information or identifier is supplied to or loaded by a code registration interface where the identifying information or identifier can be used to identify registered code. Often the identifier will be associated with a trigger indication that may further specify the type manner timing number of occurrences and or frequency for events that are to be considered significant relative to the registered code.

Although registrations are maintained and acted upon by the virtualization system e.g. in the VMM implementation in some embodiments registration may be initiated from outside virtualization barrier . For example in some embodiments it may be desirable to allow a guest context to register itself for monitoring and or execution assurance. In some embodiments registrations may be provided through facilities of the virtualization system itself. Indeed in some embodiments registration via administrative facilities of the VMM implementation may constitute the exclusive registration mechanism. In some embodiments VMM may load registrations from virtual machine configuration information.

In general any of a variety of methods may be used to identify or specify the extent of registered code. For example a code region can be specified by address by content or by both address and content. For a user mode guest program a code region can be identified by a range of guest virtual addresses that contain the code region or by one or more guest virtual addresses within that range. For a kernel mode guest program such as a driver a code region could also be identified by a range of guest physical addresses that contain the code region. Alternatively a code region could be identified by its contents such as based on an actual sequence of bytes containing executable instructions. Similarly content based identification could be performed by specifying a more compact hash checksum or signature of the actual contents e.g. a secure MD5 hash . For example one content based code identification technique that could be employed for content based registration is described in greater detail in commonly owned co pending application Ser. No. 10 791 602 filed Mar. 2 2004 entitled DYNAMIC VERIFICATION OF VALIDITY OF EXECUTABLE CODE and naming as inventors Waldspurger Agesen Chen Zedlewski and Garfinkel which is incorporated herein by reference.

Registrations may specify triggers for use by the monitoring system and or in some embodiments for enforced execution. For example in some embodiments an execution trigger can be specified as an event type and an associated count. In this way monitoring system may determine whether the registered code has been executed at least after the specified number of matching events. Similarly in an enforced execution system such as described later herein monitoring system may determine the specified number of matching events have been observed and it is time to force execution of registered code into execution context . Note that a count may be one so that the trigger fires on every matching event. In addition in some embodiments and or for some types of events a count may be omitted or implied. In some embodiments it may be desirable to specify compound execution triggers that are composed of several individual triggers e.g. as Boolean expressions involving predicates over multiple events.

Building the registration framework described above a simple time based trigger may be specified using the same type of parameters that are commonly used to specify periodic callbacks in computer systems such as a period expressed in units of milliseconds or timer ticks. For example a registration may specify that monitoring system checks to ensure that program code implementing a system integrity scan is executed at least once in any 5 second interval. Another registration may identify real time virus scanning code that is to be executed within a short but specified period of time after reading a file or stream. As yet another example a registration may specify that code which scans for suspicious branch targets should be executed at least once for every N write accesses to a range of memory addresses that includes a return address stack.

A registration that identifies a code region e.g. by virtual physical address range or content and its expected execution trigger e.g. a period in units of time or other events is communicated to the virtualization layer. In some embodiments an executing guest program may itself communicate with the registration facilities of VMM using a predefined hypercall interface as in para virtualized systems such as VMI or similarly using some predefined communication channel such as a special I O port provided in virtualization systems available from VMware Inc. In some embodiments one or more registrations may be specified without involvement of the guest computation e.g. without involvement of guest OS or any execution context thereof from outside of the virtual machine. For example registrations may be specified as static or dynamic configuration information maintained by the virtualization system for VM .

In some cases an administrator may specify that code with a particular content hash should be executed with a specified periodicity. As before such a registration may be used to support monitoring of guest contexts for execution of specified code in accord with the registration and or in some embodiments as a directive for forced execution of registered code irrespective of guest context execution. Supporting and or performing the registration outside of the VM is typically more secure since registration facilities or flows that are not exposed outside virtualization barrier should not typically be vulnerable to interdiction by software running within the guest OS which might have been compromised.

Relative to the monitoring of guest contexts for execution of registered code illustrates an example scenario in which a guest computation e.g. guest operating system and various contexts thereof execute on VM . VM includes resources exposed from underlying hardware resources by VMM . For example guest operating system maintains in exposed memory vMEM address translations that map virtual memory pages e.g. guest virtual pages GVPN . . . GVPNx to what it perceives to be physical pages e.g. guest physical pages GPPN . . . GPPNx . In general virtual to physical mappings are conventional except that as described below additional mappings maintained by the virtualization system are used to resolve addresses to actual physical pages.

Based on a context switch which may be triggered in any of the usual ways e.g. based on operating system scheduling control flow in the current context a page fault interrupt etc. relevant states of a current context e.g. registers call stack etc. are saved and those of another context are restored. In the course of the context switch address translations and contents of control registers exposed to VM are updated in accord with operative conventions of guest operating system and of the particular processor architecture virtualized by exposed processor s vCPUs.

For example in some virtualizations of an IA 32 type processor architecture an architecturally defined control register such as the CR0 register will contain a task switch flag and a CR3 register will identify the location of a page directory that is associated with the new context. Therefore by monitoring the state of these exposed architecturally defined features VMM may observe a context switch and make any appropriate changes to its state and its presentation of virtualized resources e.g. memory vMEM and processor s vCPUs from underlying hardware resources e.g. physical memory MEM and hardware processor s CPUs .

In general to expose memory vMEM to guest operating system which generally knows nothing of physical memory underlying the virtualization its mappings or paging state virtualization system VMM maintains a further set of mappings from guest address space to pages in physical memory managed by the virtualization system. In some cases these mappings provide the information that allows VMM to map from a guest physical page to a physical page represented in memory of the underlying hardware. In hardware assisted virtualization systems such mappings from a guest address space to pages in physical memory may be specified by virtualization software but may be used by the underlying processor s such as in the case of the Extended Page Tables EPT of the Intel VT technology. In some cases VMM employs isolation techniques including shadow page tables such as described in greater detail in commonly owned co pending application Ser. No. 11 584 178 filed Oct. 20 2006 entitled ISOLATING DATA WITHIN A COMPUTER SYSTEM USING PRIVATE SHADOW MAPPINGS and naming as inventors Chen Waldspurger and Subrahmanyam which is incorporated herein by reference. In any case an operative set or subset of mappings is selected by VMM based on a then current execution context.

Based on the preceding description it will be understood that in some embodiments registered code may be specified or identified by one or more memory addresses. For example a code region of a user mode guest program can be identified by a range of guest virtual addresses. Similarly a code region of a kernel mode guest program such as a driver can be identified by a range of guest physical addresses. Data structures characteristically accessed by registered code may be similarly identified by a memory address. Accordingly registrations e.g. those appearing in registration store allow VMM to identify corresponding entries in page tables translation lookaside buffers etc. shown collectively as a current operative set of mappings for which memory management attributes may be manipulated to facilitate monitoring of events related to execution of registered code access to sensitive data structures etc.

In one embodiment page table entries e.g. the current operative set of mappings maintained by VMM that map guest virtual pages to actual physical pages i.e. GVPN PPN mappings are updated based on registrations appearing in registration store to mark entries that correspond to registered code with page attributes that facilitate monitoring. For example by marking such pages as not executable or not present VMM leverages memory management facilities that exist behind virtualization barrier to provide an efficient monitoring mechanism that may be entirely invisible to code running within guest operating system . For registered code that runs in user mode the system flag may be used for monitoring execution. More particularly when VMM executes registered code on behalf of a guest execution context memory mappings using the corresponding entry e.g. page table entry . of current operative set generate a hidden fault that is intercepted within VMM and is not visible to guest execution contexts. Based on the hidden fault VMM can record when the registered code is actually executed and evaluate as against the registered trigger. As indicated above such faults can in general be supplied based on attempts to execute code on a marked page or based on attempts to access data on a marked page. Both mechanisms may be employed in some embodiments. Again similar techniques may be used in hardware assisted virtualization systems such as by using bits in extended or nested page tables to indicate that an address is not executable or not present. 

For example consider a registration of system integrity scan code that specifies execution at least once in any 5 second interval. If VMM handles before expiry of an appropriate timer a fault generated by an attempt to execute code at the address registered for the integrity scan code then the desired execution is confirmed and the timer is reset. Otherwise on expiry an appropriate response may be triggered. In general appropriate responses may include generating a notification or alert informing a software module user or administrator that registered code has not been executed as desired and or in some embodiments forcing execution of the registered code into a guest execution context.

Similarly in the case of a registration that specifies certain virus scanning code that is to be executed within a short but specified period of time after reading a file or stream a related strategy may be employed. For example upon a system call that can be associated with reading the file or stream of interest a timer may be initialized and if prior to expiry of the timer VMM handles a fault generated by an attempt to execute code at the address registered for the virus scanning code then the desired execution is confirmed. Otherwise on expiry an appropriate response may be triggered. Note that timer initialization may itself be triggered by a similar mechanism tied to execution of a system call at a known address. Alternatively binary translation BT techniques such as described elsewhere herein may be employed to augment code actually executed by VMM in furtherance of the system call so as to initialize the timer.

Likewise a registration that specifies that certain code which scans for suspicious branch targets should be executed at least once for every N write accesses to a return address stack may be handled using similar techniques. For example by marking as read only a mapping e.g. page table entry . which corresponds to the in memory extent of the return address stack VMM may intercept faults corresponding to attempted write accesses increment a corresponding counter and thereafter allow the write access to proceed. Upon an Nth interception of the fault VMM may check whether the appropriate scan has been performed again using a memory management mediated monitoring mechanism or may optionally force execution of the scan for suspicious branch targets into the current context as described elsewhere herein.

In some virtualization system implementations and or for some code registrations or trigger events it may be desirable to employ techniques such as binary translation or emulation that allow code executed on behalf of a guest computation to be augmented when instruction sequences are actually executed on underlying hardware. For many of the code registrations or trigger events described herein in the context of monitored code examples either or both of memory mapping techniques and code modification techniques may be employed. In some cases memory mapping may provide a low overhead mechanism with great specificity of detection. In some cases runtime augmentation of specific code may provide an attractive mechanism for monitoring specific code or for sampling a relevant event. In any case selection of an appropriate mechanism to support any given monitoring goal is typically a matter of design choice. One monitoring mechanism may be selected over another mechanism for sole use in a virtualization system implementation based on general monitoring goals or multiple monitoring mechanisms may be used within a single implementation in an attempt to improve efficiency effectiveness or based on other criteria. Different mechanisms may be used for different code registrations and or different mechanisms may be used for a single code registration at different times based on any one or more of various operational parameters or conditions.

Accordingly illustrates exemplary scenarios in which selective alterations to the execution characteristics of a virtualization system are employed to facilitate monitoring of registered code. The illustrations of runtime augmentation to guest code are in many ways analogous to situations described with reference to and will be understood with reference to the description of . In addition in view of the prior description aspects of memory mapping are de emphasized for clarity in . Nonetheless based on the description herein persons of ordinary skill in the art will appreciate that at least in some embodiments virtualization system implementations may employ both sets of techniques.

Referring now to VMM modifies code or control flows of an execution context which based on a registration appearing in registration store corresponds to registered code or to an event to be monitored with reference to registered code. In general VMM may overwrite patch or otherwise modify binary code that would normally be executed for the current context. For example existing instruction sequences can be augmented or altered to generate a side effect that is observable. One example of such an augmentation or alteration is substitution of a particular presumably valid instruction of registered code with a coding that corresponds to an illegal instruction and thus triggers a hidden fault that is intercepted within VMM and is not visible to guest execution contexts. Alternatively a memory access instruction can be purposefully altered to target a memory address that will trigger a paging or memory management or protection fault again hidden from guest execution contexts that may be intercepted and serviced by VMM .

If the substituted instruction corresponds to registered code VMM can record when the registered code based on the intercepted fault is actually executed and evaluate against a corresponding trigger. Alternatively if the substituted instruction corresponds to an event trigger VMM can log the event initiate an appropriate timer etc. In either case after servicing the fault VMM may restore original execution semantics and continue executing instructions on behalf of the current guest execution context.

In general any augmentation or alteration that provides VMM with a discernible side effect may be employed. For example although fault based techniques have been emphasized above other more direct transfers of control may be exploited. In some implementations VMM may dynamically alter a branch target for target code based on a registration appearing in registration store so as to interpose the desired monitoring or event detection sequence. In some cases VMM may even directly warp the program counter associated with a guest context causing a transfer of control to code that provides the discernible side effect.

Based on the foregoing persons of ordinary skill in the art will appreciate a variety of strategies by which a virtualization system can monitor and selectively alter virtual machine behavior for registered code. Typically the selective alterations are performed from behind a virtualization barrier and may be hidden from both the guest operating system and the affected execution context. In general the described embodiments may be exploited in a variety of virtualization system designs including those now reviewed.

As is well known in the art a virtual machine VM is a software abstraction a virtualization of an actual physical computer system. illustrate aspects of embodiments of the present invention for monitoring registered code. In describing embodiments of the present invention certain aspects of more complete virtualization system implementations have been abstracted. To facilitate an understanding of the broad applicability of embodiments of the present invention a few examples of specific virtualization system designs and variations thereon are described.

In general in most virtualization system designs some interface is provided between guest software within a VM and the various hardware components and devices in the underlying hardware platform. This interface which can generally be termed virtualization software may include one or more software components and or layers possibly including one or more of the software components known in the field of virtual machine technology as virtual machine monitors VMMs hypervisors or virtualization kernels. Because virtualization terminology has evolved over time and has not yet become fully standardized these terms when used in the art do not always provide clear distinctions between the software layers and components to which they refer. For example the term hypervisor is often used to describe both a VMM and a kernel together either as separate but cooperating components or with one or more VMMs incorporated wholly or partially into the kernel itself however the term hypervisor is sometimes used instead to mean some variant of a VMM alone which interfaces with some other software layer s or component s to support the virtualization. Moreover in some systems some virtualization code is included in at least one superior VM to facilitate the operations of other VMs. Furthermore specific software support for VMs is sometimes included in the host OS itself. Unless otherwise indicated embodiments of the present invention may be used and or implemented in or in conjunction with virtualized computer systems having any type or configuration of virtualization software.

In view of the above and without limitation an interface usually exists between a VM and the underlying platform which is responsible for actually executing VM issued instructions and transferring data to and from the memory and storage devices or underlying hardware. Subject to the foregoing certain commercially available virtualization systems employ a virtual machine monitor VMM in this role. A VMM is usually implemented as a thin piece of software that runs directly on top of a host or directly on the hardware and virtualizes at least some of the resources of the physical host machine. The interface exported to the VM is then the same as the hardware interface of a physical machine. In some cases the interface largely corresponds to the architecture resources and device complements of the underlying physical hardware however in other cases it need not.

Although the VM and thus applications executing in the VM and their users cannot usually detect the presence of the VMM the VMM and the VM may be viewed as together forming a single virtual computer. They are shown and described herein as separate components for the sake of clarity and to emphasize the virtual machine abstraction achieved. However the boundary between VM and VMM is somewhat arbitrary. For example while various virtualized hardware components such as virtual CPU s virtual memory virtual disks and virtual device s including virtual I O devices can be presented as part of previously described VMs see in some virtualization system implementations these components are at least partially implemented as constructs or emulations exposed to a VM by the VMM. One advantage of such an arrangement is that the VMM may be set up to expose generic devices which facilitate VM migration and hardware platform independence. In general such functionality may be said to exist in the VM or the VMM.

It should be noted that while VMMs can be viewed as executing on underlying system hardware many implementations based on the basic abstraction may be implemented. In particular some implementations of VMMs and associated virtual machines execute in coordination with a kernel that itself executes on underlying system hardware while other implementations are hosted by an operating system executing on the underlying system hardware and VMMs and associated virtual machines execute in coordination with the host operating system. Such configurations sometimes described as hosted and non hosted configurations are illustrated in . In the hosted configuration an existing general purpose operating system OS acts as a host operating system that is used to perform certain I O operations. In the non hosted configuration a kernel customized to support virtual computers takes the place of the conventional operating system.

Embodiments of the present invention for monitoring registered code may build on systems of either configuration. Accordingly in view of the variations two exemplary virtualization system configurations are summarized and based on the preceding description persons of ordinary skill in the art will appreciate suitable hosted and non hosted embodiments of the present invention.

Different systems may implement virtualization to different degrees virtualization generally relates to a spectrum of definitions rather than to a bright line and often reflects a design choice in respect to a trade off between speed and efficiency on the one hand and isolation and universality on the other hand. For example full virtualization is sometimes used to denote a system in which no software components of any form are included in the guest other than those that would be found in a non virtualized computer thus the guest OS could be an off the shelf commercially available OS with no components included specifically to support use in a virtualized environment.

In contrast another term which has yet to achieve a universally accepted definition is that of para virtualization. As the name implies a para virtualized system is not fully virtualized but rather the guest is configured in some way to provide certain features that facilitate virtualization. For example the guest in some para virtualized systems is designed to avoid hard to virtualize operations and configurations such as by avoiding certain privileged instructions certain memory address ranges etc. As another example many para virtualized systems include an interface within the guest that enables explicit calls to other components of the virtualization software. For some the term para virtualization implies that the guest OS in particular its kernel is specifically designed to support such an interface. According to this view having for example an off the shelf version of Microsoft Windows XP as the guest OS would not be consistent with the notion of para virtualization. Others define the term para virtualization more broadly to include any guest OS with any code that is specifically intended to provide information directly to the other virtualization software. According to this view loading a module such as a driver designed to communicate with other virtualization components renders the system para virtualized even if the guest OS as such is an off the shelf commercially available OS not specifically designed to support a virtualized computer system.

Unless otherwise indicated or apparent virtualized computer system based realizations of the present invention are not restricted to use in systems with any particular degree of virtualization and is not to be limited to any particular notion of full or partial para virtualization. Furthermore embodiments of techniques described herein for impeding or interdicting system calls can also be applied to hypercalls between a guest and a VMM or hypervisor. In general hypercall mechanisms are part of a well defined interface for transitioning between the guest and the VMM hypervisor while system call mechanisms are part of a well defined interface for transitioning between user mode and kernel mode. Accordingly based on the description herein persons of ordinary skill in the art will appreciate analogous hypercall targeted adaptations of the aforementioned techniques for impeding or interdicting system calls.

While the invention s is are described with reference to various implementations and embodiments it will be understood that these embodiments are illustrative and that the scope of the invention s is not limited to them. In general virtual machines may be implemented consistent with hardware systems now existing or hereafter defined. In addition while our description of virtualization techniques has generally assumed that the virtual machines present interfaces consistent with a hardware system persons of ordinary skill in the art will recognize that the techniques described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the present invention implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned.

Although achieving a goal of VMM transparency may be facilitated using techniques of the present invention VMM transparency is not required. Rather the virtualization system techniques for monitoring registered code may be incorporated in so called para virtualization systems in which a guest operating system is aware that it is being virtualized and has an explicit interface to the VMM. In such systems functionality analogous to that described herein as a VMM is sometimes referred to as a hypervisor. 

Many variations modifications additions and improvements are possible. For example while strategies for monitoring registered code have been described in detail herein other techniques and strategies will also be appreciated by persons of ordinary skill in the art based on the description herein. Furthermore while techniques and mechanisms have been described using particular network configurations hardware architectures memory organizations and particular operating system constructs typically IA 32 based architectures systems and Windows or Linux based operating systems as a descriptive framework persons of ordinary skill in the art will recognize that it is straightforward to modify such implementations for use in systems that support other processor instruction set architectures other network or memory configurations and or other operating system constructs. Furthermore although certain embodiments of the present invention are illustrated herein in a descriptive context that includes software distributed conventionally and often in multiple separately packaged components as operating system and or application software that are together executable as a guest computation other guest software models are also possible. For example guest software instances may be implemented as so called virtual appliances in the form of pre built pre configured ready to run applications typically packaged with an operating system inside a virtual machine as a self contained self consistent software solution.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the invention s .

