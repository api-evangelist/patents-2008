---

title: Graphical user interface application comparator
abstract: A graphical user interface (GUI) application comparator helps application designers create error free graphical user interface applications (GAPs). The comparator finds differences in the GUI elements used to compose an interface between a current GAP version and a subsequent GAP version. One benefit is that a test script writer may better understand how the GAP has evolved in order to write a better test script. Another benefit is that the comparator output may be analyzed by subsequent processing systems for automated analysis of test scripts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08185917&OS=08185917&RS=08185917
owner: Accenture Global Services Limited
number: 08185917
owner_city: Dublin
owner_country: IE
publication_date: 20080227
---
This application is related to following applications all filed on the same day U.S. patent application Ser. No. 12 038 665 filed Feb. 27 2008 U.S. patent application Ser. No. 12 038 672 filed Feb. 27 2008 U.S. patent application Ser. No. 12 038 676 filed Feb. 27 2008 U.S. patent application Ser. No. 12 038 658 filed Feb. 27 2008 and U.S. patent application Ser. No. 12 038 675 filed Feb. 27 2008.

This application relates to graphical user interfaces. In particular this application relates to determining differences between graphical user interfaces.

The relentless pace of advancing technology has given rise to complex computer software applications that assist with almost every aspect of day to day life. These applications exist in virtually every field such as analyzing radio telescope signals for signs of intelligent life among the stars finding new oil deposits under the earth and designing new automobiles. One nearly ubiquitous feature of these applications is that they employ graphical user interfaces GUIs . Another nearly ubiquitous aspect of GUI applications GAPs is that they are complex difficult to design and difficult to debug.

In the past it has generally been easier to implement the GUI to the application than to thoroughly test the GAP logic. For GAPs of any significant complexity the permutations and combinations of GUI elements give rise to an enormous field of potential interactions with GUI elements other GAPs and logic execution that could have bugs of any severity from insignificant to critical failure. Exacerbating the problem is that application developers are under pressure to continually add new features update the GUI and release new versions of applications.

Manually testing large scale enterprise GAPs is tedious error prone and laborious. Nontrivial GAPs contain hundreds of GUI screens that in turn contain thousands of GUI objects. In order to automate testing of GAPs test engineers write programs using scripting languages e.g. JavaScript and VBScript and these testing scripts drive GAPs through different states by mimicking users who interact with the GAP by performing actions on the GAP GUI objects. These testing procedures operate on the GAP after it has been designed built and is in executable form. During the design of the GAP however little guidance was available to the designer for how to build and debug the GAP itself.

A graphical user interface application comparator helps application designers create error free graphical user interface applications GAPs . The comparator finds differences in the GUI elements used to compose an interface between a current GAP version and a subsequent GAP version. One benefit is that a test script writer may better understand how the GAP has evolved in order to write a better test script for the subsequent version. Another benefit is that the comparator output may be analyzed by subsequent processing systems for automated analysis of test scripts.

Other systems methods features and advantages will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. All such additional systems methods features and advantages are included within this description are within the scope of the invention and are protected by the following claims.

The memory may include GUI model builder logic . The GUI model builder logic may communicate with a proxy . The proxy may be stored in the memory and access a GAP table . The proxy may communicate with GAPs such as a current GAP version and a subsequent GAP version . The current GAP version and subsequent GAP version may already reside in the memory . Alternatively or additionally the system may request and receive the current GAP version and the subsequent GAP version through the communication logic whereupon the current GAP version and the subsequent GAP version may be stored in the memory .

The proxy may include logic that inserts the hooks and into a process space of the GAPs and . The proxy may communicate with the hooks and . In particular the proxy may exchange messages with the hooks and to obtain the state of any or all of the GUI elements in the GAPs and . The hooks and may be programs that respond to messages from the proxy and may interact through an accessibility layer of an operating system to discover and report information about the GUI elements in the GAPs and to the proxy. The accessibility layer may expose an accessibility interface through which the proxy and hooks and may invoke methods and set and retrieve GUI element values and characteristics and thereby select highlight control modify assign identifiers for or otherwise interact with the GUI elements in the GAPs.

The Microsoft Active Accessibility MSAA layer is one example of a suitable accessibility layer. In this regard the GAPs and expose the accessibility interfaces that export methods for accessing and manipulating the properties and behavior of GUI elements. For example the GAPs and may employ the IAccessible interface to allow access and control over the GUI element using MSAA application programming interface API calls. The IAccessible interface further facilitates applications to expose a tree of data nodes that make up each window in the user interface currently being interacted with. The GUI model builder logic and proxy may then include program statements to access and control the GUI element as if the GUI element was a conventional programming object. Accessibility API calls may include perform actions on objects get values from objects set values on objects navigate to objects and set properties on objects and other calls.

The proxy may be a daemon program and may start prior to the GUI model builder logic . The proxy may be aware of one or more GAPs. When the proxy starts it may load the GAP table which may include a predefined set of GAP entries for which the proxy is aware. A GAP entry may take the form 

where Alias may be a unique pre defined name for the GAP e.g. a name generic to both the current GAP version and the subsequent GAP version File0 may be the name of the executable program for the current GAP version Path0 may be the absolute path to File0 Dir0 may be the absolute path to the directory from which File0 should execute and CommandLine0 may specify command line arguments for File0. File1 Path1 Dir1 and CommandLine1 provide similar parameters for the subsequent GAP version .

When the GUI model builder logic starts it may connect to the proxy . Once connected the GUI model builder logic may request the GAP table by sending a GAP table request message to the proxy . The proxy may respond by sending a GAP table response message including the GAP table to the GUI model builder logic . An example message exchange is shown in Table 1 

The GUI model builder logic may then provide a list of GAPs from which an operator may choose. The operator may access the system either locally through the display or remotely e.g. through the terminal . The GUI model builder logic may then create a GAP load message e.g. and send the GAP load message to the proxy to start any selected GAP which may then display its user interface . One GAP load message may cause the proxy to start multiple versions of a GAP identified together in the GAP table in the section.

After starting the GAPs the proxy may inject hooks into the GAPs process space. The hook may connect to the proxy and send a confirmation message e.g. . The proxy may send a success message e.g. to the GUI model builder logic thereby acknowledging that the GAPs are started successfully.

The GUI model builder logic may request the current state of each started GAP. In that regard the GUI model builder logic may send a state request message e.g. to the proxy . In turn the proxy may locate the connection to the corresponding hooks of the GAPs and send a state request message e.g. to the hooks. The hooks may create a GAP state including unique identifiers for GUI elements such as a state tree encode it e.g. in XML format and send it to the proxy . The proxy may forward the GAP state to the GUI model builder logic . An example GAP state message sent by the proxy is shown in Table 2.

The GAP state contains information about the GUI elements composing a given screen as well as the values of these elements and their assigned identifiers. The GAP state specifies the GAP GUI elements and the values of the GUI elements. In one implementation the GAP state is reflected in an extensible Markup Language XML structure where the element State has one or more children elements GAP whose children elements are in turn GUIElement s. For example GUI elements may be either containers or basic. Container GUI elements contain other elements while basic elements do not contain other elements. The XML structure reflects the containment hierarchy by allowing GUIElements to contain other GUIElements.

In the XML structure the attribute SeqNumber may designate a unique sequence number of the state within the GAP. Since states are mapped to GUI screens each state may be given a name which is specified by the optional attribute Name . The attributes Alias and ProcessID may denote the alias of the GAP and its instance process identifier respectively. The instance process identifier may differentiate between the current GAP version and the subsequent GAP version.

The GUI model builder logic may construct GAP GUI models based on the GAP state messages received from the proxy . For example the GUI model builder logic may construct a GAP Vn GUI model from GAP state messages regarding the current GAP version . Similarly the GUI model builder logic may construct a GAP Vn 1 GUI model from GAP state messages regarding the subsequent GAP version .

The processor may invoke GAP comparison logic stored in the memory . The GAP comparison logic may compare two GAP GUI models such as GAP GUI models and and produce a GUI difference model . The GAP comparison logic may include mapping retrieval logic representation traversal logic weighted analysis logic and match building logic .

The mapping retrieval logic may request particular GAP GUI element mappings from the GAP GUI element mappings in a GUI element data repository and store the particular GAP GUI element mappings in the memory as GUI element version mappings .

The representation traversal logic may traverse a GAP GUI model such as GAP Vn GUI model . For example the representation traversal logic may determine the next node to visit in either of the GAP GUI models and . Alternatively or additionally the representation traversal logic may traverse all or parts of a GUI difference model such as GUI difference model . The next node to visit may be determined as examples in depth first or breadth first fashion.

The weighted analysis logic may use GUI characteristic weights obtained from a weight table to determine a similarity value between a GUI element within a first GAP GUI model such as the GAP Vn GUI model and each GUI element within a second GAP GUI model such as the GAP Vn 1 GUI model . Different GUI characteristic weights may be assigned to the similarities or differences between different GUI element characteristics or properties that may be present or absent between the GUI elements in the two GAP GUI models. The GUI element characteristics may include GUI element characteristics such as size XY position color window position font type font size border style background color foreground color Read only Read Write or any other GUI element characteristic. Alternatively or additionally the GUI element characteristics may include an accessibility layer Role Class Style Extended Style number of Children Level within a tree or hierarchy Name of the GUI element or other accessibility layer assigned properties. The weight table may also include notes associated with the weights assigned to the GUI characteristics that may explain the rationale behind each weight value.

The weighted analysis logic may store a score in a score table based on each similarity value generated by the weighted analysis logic . Each score in the score table may correspond with a source identifier and a destination identifier . The source identifier and destination identifier may be a unique value or combination of values e.g. including GAP aliases identifying the GAPs and GUI elements that the weighted analysis logic compared to calculate each score .

The match building logic may compare the similarity values generated by the weighted analysis logic and or the scores stored in the score table against a similarity threshold . This comparison may determine whether two GUI elements are sufficiently similar to be considered a match from the current GAP version to the subsequent GAP version. The match building logic may create a link between matching GUI elements in the GUI difference model . The link may be stored in the GUI element representation within the GUI difference model as a GUI element link with an optional corresponding matching score . The GUI element link may comprise an identifier of a second GUI element . The identifier may be the source identifier the destination identifier or both.

In operation the GAP comparison logic may obtain the GAP GUI models and by retrieving them from the memory by calling the GUI model builder logic or in another manner. The GAP comparison logic may create a base GUI difference model as a root node from which the GAP GUI models and descend in different branches from the root. The GAP comparison logic may then determine the next node to visit in each of the GAP GUI models using the representation traversal logic .

The GAP comparison logic may initiate execution of the mapping retrieval logic to obtain GUI element version mappings available from external sources such as the metadata repository . The GAP comparison logic may request all available GUI element version mappings or may specifically request GUI element version mappings for the next node in the current GAP GUI model. If a GUI element version mapping is available for the next node in the current GAP GUI model the GAP comparison logic may forgo execution of the weighted analysis logic . Instead the GAP comparison logic may employ the match building logic to write a GUI element link into the base GUI difference model. As another alternative when a GUI element version mapping is available the GAP comparison logic may create a corresponding entry in the score table based on the information available in the GUI element version mapping.

However the GUI comparison logic need not forgo the weighted analysis when a GUI element version mapping exists. Instead the GAP comparison logic may decide whether to proceed with the weighted mapping based on the confidence level provided in the GUI element version mapping. For example when the confidence level exceeds a confidence threshold the GAP comparison logic may forgo execution of the weighted analysis. As another example when the confidence level specifies manual mapping the GAP comparison logic may forgo execution of the weighted analysis.

The GAP comparison logic uses the weighed analysis logic to determine similarity values between each GUI element in the current GAP GUI model and each element in the subsequent GAP GUI model . The weighted analysis logic is described in more detail below. The weighted analysis logic records the similarity values in the weight table as scores. The scores may be the similarity values normalized similarity values or based in some other way on the similarity values.

Having determined the similarity values the GAP comparison logic may use the match building logic to determine whether GUI elements match between GAP versions. To that end the match building logic may compare the scores in the score table against the similarity threshold . GUI elements with scores that exceed the similarity threshold may be considered matches under the assumption that the higher the similarity score the more likely they refer to corresponding GUI elements. The match building logic may create GUI element links in the base GUI difference model when matches are determined.

The GUI element with identifier is a modified version of the GUI element with identifier . In other words when the programmer designed the subsequent GAP version the programmer modified the GUI element with identifier to obtain the GUI element with identifier . In particular show that the following changes have been made the style changed from 0x560100c1 to 0x560100242 and the extended style changed from 0xc0000a00 to 0xc0000800 . These differences in GUI element characteristics are not readily discernible to test script writers. However other changes may be discernable to a programmer such as the class change from WindowsForms10.LISTBOX.app4 to WindowsForms10.COMBOBOX.app.0.378734a .

The GUI difference model may be in a flat configuration where the GUI difference model includes a single section and a single corresponding section . Alternatively or additionally the GUI difference model may be in a tree hierarchical or nested configuration where the GUI difference model includes multiple sections and multiple corresponding sections . In the tree hierarchical or nested configuration similar GUI elements may be represented by a single node. Alternatively or additionally similar GUI elements may be represented in separate nodes. The GUI difference model may include all of the GUI elements of both of the GAP GUI models. Alternatively the GUI difference model may include only the elements of the second GAP GUI model and the corresponding portions of the first GAP GUI model. The GUI difference model may be formed based on a bi simulation algorithm as described in more detail below.

The GAP comparison logic may create the difference portion in the format presented in when it combines the source GAP GUI model with the destination GAP GUI model under a root node. Alternatively or additionally the GAP comparison logic may create the difference portion after the mapping retrieval logic obtains a relevant mapping between the GUI element represented in the current version section and the subsequent version section . Alternatively or additionally the GAP comparison logic may create the difference portion after the match building logic creates a link between the current version section and subsequent version section .

An optional extension to the GUI element version mapping is the confidence level field . The confidence level field may specify a degree of reliability for the GUI element version mapping. When the version mapping arises from the efforts of a human operator for example the confidence level field may be relatively high e.g. 90 100 . When the version mapping arises from an automated analysis the confidence level field may be set at a specified level e.g. a predefined level for automated matching or may be set at a threshold that depends on the strength of the automated analysis.

For example the automated analysis described above may determine a normalized score representing a GUI element similarity value for any given attempt to match one GUI element to another GUI element. The confidence level field may then specify the normalized score. The confidence level field may further specify why the confidence level is set to any particular value. Furthermore an explanation field e.g. a character such as M or A may be included in the confidence level field to denote that the confidence level arises from Manual or Automated analysis.

The source GAP alias specifies an identifier for a GAP or GAP version the source GAP that includes a first selected GUI element while the destination GAP alias specifies an identifier for a GAP or GAP version the destination GAP that includes a second selected GUI element that should be linked to the first selected GUI element. The GAP aliases and may be unique identifiers that distinguish between GAPs or GAP versions such as identifiers that differentiate the current GAP version and the subsequent GAP version. The source GUI element identifier provides a unique identifier for the selected GUI element in the source GAP while the destination GUI element identifier provides a unique identifier for the selected GUI element in the destination GAP.

The GUI model builder logic may then create a GAP load message e.g. and send the GAP load message to the proxy to start the selected GAP version which may then display its GUI . After starting the GAP the proxy may inject a hook into the GAP s process space . The hook may connect to the proxy and send a confirmation message e.g. . The proxy may send a success message e.g. to the GUI model builder logic thereby acknowledging that the GAP is started successfully.

The accessibility layer proxy hook and GUI model builder logic monitor operator interaction with GUI elements in the selected GAP version . The GUI model builder logic may send a state request message e.g. to the proxy to obtain GUI element information from the hook . In turn the proxy may locate the connection to the corresponding hook in the selected GAP version and send a state request message e.g. to the hook. The hook may create a GAP state including unique identifiers for GUI elements such as a state tree encode it e.g. in XML format and send it to the proxy . The proxy may forward the GAP state to the GUI model builder logic . The GUI element information may be returned to the GUI model builder logic one screen at a time one GUI element at a time an entire application at a time or at some other discrete segmentation of the GAP.

The purpose of monitoring operating interaction with the GAP is to allow the GUI model builder logic to record the structures of the screens and operator actions on the GAPs. The GUI model builder logic intercepts operator events using the accessibility layer. Through these events the GUI model builder logic records the sequence of screens that the operator navigates through as well as the actions that the operator performs on GUI elements. When recording the sequence of screens the GUI model builder logic obtains information about the structure of the GAP and the properties of the individual GUI elements using the accessibility enabled interfaces. Accordingly the GUI model builder logic extracts GUI element structural data and GUI element characteristics from the information returned by the accessibility layer. The GUI model builder logic uses the GUI element structural data and GUI element characteristics to add GUI element information into a GAP GUI model e.g. on an element by element screen by screen or other incremental basis. The GUI model builder logic may continue to build the GAP GUI model until the operator stops interacting with the selected GAP .

The GAP GUI model that results may be a full or partial capture of the entire GAP GUI structure. Thus when the operator is interested in comparing specific pieces of a GUI between two GAPs the operator may exercise only those pieces of interest. The GUI model builder logic captures the specific pieces in a GAP GUI model specific to the pieces that the operator exercised rather than every aspect of every GUI element in the entire selected GAP. The operator may run both the current GAP version and subsequent GAP version with the GUI model builder logic to create the GAP Vn GUI model and the GAP Vn 1 GUI model respectively.

The GAP comparison logic may then combine the first GAP GUI model and the second GAP GUI model to create a base GUI difference model . The first and second GAP GUI models may be combined in a flat configuration. Alternatively or additionally the first and second GAP GUI models may be combined in a tree hierarchical or nested configuration.

The GAP comparison logic may then invoke the mapping retrieval logic . The mapping retrieval logic may determine whether GUI element version mappings are available for the first GAP GUI model and the second GAP GUI model . This determination may be performed by querying a local source such as the memory for the GUI element version mappings. Alternatively or additionally the mapping retrieval logic may query a GUI element data repository via the communication logic .

If the mapping retrieval logic determines that GUI element version mappings are available then the mapping retrieval logic may request those GUI element version mappings . The request may be made to a local source such as the memory . Alternatively or additionally the request may be made to a GUI element data repository via the communication logic . The request may be for specific mappings such as for GUI element version mappings relevant for the next node. Alternatively the request may be for all available GUI element version mappings. The mapping retrieval logic may receive the GUI element version mappings in response to the request .

Alternatively or additionally the determination of whether GUI element version mappings are available the request and the response may be combined into fewer actions. For example the mapping retrieval logic may just request the mappings. A response of GUI element version mappings may confirm that the mappings are available while a negative or null response may confirm that the mappings are not available.

The mapping retrieval logic may then return and the GAP comparison logic may then invoke the representation traversal logic . The representation traversal logic may traverse to the next GUI element i.e. a source GUI element from the first GAP GUI model . In the case where the base GUI difference model is newly created the traversal may be to the first GUI element. The traversal may be performed based on the first GAP GUI model. Alternatively or additionally the traversal may be performed based on the representation of the first GAP GUI model within the base GUI difference model. The next node to visit may be determined as examples in depth first or breadth first fashion.

The GAP comparison logic may then determine whether a GUI version mapping exists for the GUI element . The GAP comparison logic may search within the retrieved GUI element version mappings to determine whether the mapping exists. If a mapping exists then the GAP comparison logic may create a link field in the base GUI difference model . The link field may include a GUI element identifier such as a source GUI element identifier or a destination GUI element identifier. The link field may also include a GAP alias. The GAP comparison logic may create a link field for just the source GUI element. Alternatively or additionally the GAP comparison logic may create a link field for the destination GUI element.

The representation traversal logic may then determine whether more source GUI elements are available . If more source GUI elements have not yet been traversed then the representation traversal logic cycles back and traverses to the next available source GUI element . If no source GUI elements are available the GAP comparison logic may terminate.

If either no GUI element version mappings exist or the mappings exist but no mappings exist for the source GUI element then the GAP comparison logic may invoke the weighted analysis logic . The weighted analysis logic may retrieve weights from a weight table . For example the weighted analysis logic may retrieve the weights from a weight table in the memory . Alternatively or additionally the weighted analysis logic may request and receive a weight table from the communication logic .

The representation traversal logic may then traverse to the next GUI element i.e. a destination GUI element in the second GAP GUI model . In the case where no previous traversals in the second GAP GUI model have been made for a given source GUI element then the representation traversal logic may traverse to the first GUI element in the second GAP GUI model. The traversal may be performed based on the second GAP GUI model. Alternatively or additionally the traversal may be performed based on the representation of the second GAP GUI model within the base GUI difference model. The traversal may be performed using a depth first breadth first or other traversal technique.

The weighted analysis logic may then obtain GUI element characteristics for the source GUI element and the destination GUI element . The GUI element characteristics may include GUI element characteristics such as size XY position color window position font type font size border style background color foreground color Read only Read Write or any other GUI element characteristic. Alternatively or additionally the GUI element characteristics may include an accessibility layer Role HWND Class Style Extended Style number of Children Level within a tree or hierarchy Name of the GUI element or other accessibility layer assigned properties. These GUI element characteristics may be obtained from the first and second GAP GUI model. Alternatively or additionally the GUI element characteristics may be obtained from the base GUI difference model.

The weighed analysis logic may then determine a GUI element similarity value for the source GUI element and the destination GUI element . The similarity value may be determined according to the following formula 

where Vis the similarity value N is the number of characteristics or properties against which the similarity is being measured Pis a value assigned to the differences between each property or characteristic and Wis the corresponding weight for each property P. As one example Role

where Role may be either 0 or 1 depending on whether the Role characteristics between the two GUI elements are different or the same respectively and Wmay be the corresponding weight for the Role. The weight for the Role may be assigned a value indicative of the importance of the Role matching between GUI elements. For example the weight of the Role may be very large in relation to the weight for other characteristics.

where Class may be a count of how many terms in the Class property match divided by the total number of terms in the Class property and Wmay be the corresponding weight for the Class. For example a Class characteristic for a GUI element may be WindowsForms10.LISTBOX.app4 . If the Class characteristic for a corresponding GUI element is WindowsForms10.COMBOBOX.app.0.378734a then because the characteristics only match to a single place out of three or five places the Class value may be either or .

The GAP comparison logic may then store in a score table a score based on the similarity value . Alternatively or additionally the GAP comparison logic may store the GUI element identifiers for the source GUI element and the destination GUI element along with the score in the score table. The score table may reside in the memory .

The GAP comparison logic may then determine whether the representation traversal logic has completed traversing the second GAP GUI model . If the representation traversal logic still has more destination GUI elements to traverse then the representation traversal logic cycles back to traversing to the next destination element . If the representation traversal logic has completed traversing the destination GUI elements the GAP comparison logic may invoke the match building logic .

The match building logic may analyze either the similarity values determined by the weighted analysis logic or the scores stored in the score table . The match building logic may compare the values or scores against a similarity threshold to determine whether values or scores meet and or exceed the similarity threshold. Alternatively or additionally the values or scores may be compared against a difference threshold to determine whether the values or scores are at and or below a difference threshold.

The match building logic may determine whether the GUI elements match . This determination may occur when the values or scores exceed the similarity threshold. Alternatively or additionally this determination may occur when the values or scores are not below a difference threshold.

If a match exists then the GAP comparison logic may create a link field in the base GUI difference model . The link field may include a GUI element identifier such as a source GUI element identifier or a destination GUI element identifier. The link field may also include a GAP alias. The GAP comparison logic may create a link field for just the source GUI element. Alternatively or additionally the GAP comparison logic may create a link field for the destination GUI element.

After the GAP comparison logic creates a link field or if no match exists then the match building logic may determine whether more scores or similarity values need to be analyzed . This determination may depend on whether the score table still includes scores that have not been analyzed. If the GAP comparison logic determines that more scores need to be analyzed the match building logic cycles back to analyzing the next score in the score table . If no unanalyzed scores exist in the score table the match building logic may return and the GAP comparison logic may cycle back to determining whether any more source GUI elements remain . Alternatively or additionally the GAP comparison logic may communicate any link fields created by the match building logic to the GUI element data repository for storage as a GAP GUI element version mapping. The communication may use a GUI element version mapping message format as described in .

In another implementation the GAP comparison logic may execute a schema comparison to determine differences between the current GAP GUI and the subsequent GAP GUI. Given a schema representation e.g. an XML schema representation of the current GAP GUI and the subsequent GAP GUI the GAP comparison logic may compare the respective schemas. If these schemas are equal then the current GAP version and subsequent GAP version are the same. Otherwise the current GAP version and the subsequent GAP version are different and the GAP comparison logic finds the differences.

For example the XML schemas may be recorded in the XML format and each schema may have the root specified with the element. Data elements may be specified with the and with the tags. Each data element may be defined by its name and its type. Elements may be either of simple or complex types. Complex element types support nested elements while simple types are attributes and elements of basic types.

Extending the example elements may have two kinds of constraints. First values of elements may be constrained. The second kind of constraints specifies bounds on the number of times that a specific element may occur as a child of an element. These bounds are specified with the minOccurs and maxOccurs attributes of the tag to represent the minimum and maximum number of occurrences. Elements may be grouped in a sequence if they are children of the same parent element. Attributes of the same element may also be grouped in a sequence. Each element or attribute in a sequence may be assigned a unique positive integer sequence number. This number may be used to access elements or attributes instead of using their names.

Schemas may be represented using graphs. Let T be finite sets of type names and F of element and attribute names labels and distinct symbols F and T. Schemas graphs are directed graphs G V E L such that 

3 E L V V edges are cross products of labels and nodes. If E then vk l vm. Nodes vm are called children of the node vk. If an element has no children then its corresponding node in a schema graph has an empty collection of children nodes 

4 Bounds for elements are specified with subscripts and superscripts to labels designating these elements. Subscripts are used to specify bounds defined by the minOccurs attribute and superscripts designate the bounds specified by the maxOccurs attribute 

5 Each graph has the special node labeled root V where root represents a collection of the root elements. An empty schema has a single root node and no edges 

Once GAPs are modeled using XML schemas these schemas can be compared using simulation to compute changes between the corresponding GAPs. That is if the schema of the new GAP is the same as the schema of the previous release of the GAP or the types of its GUI objects are subsumed by the types of the corresponding GUI object of the previous GAP then these schemas may be considered identical. Otherwise the GAP comparison logic may issue a warning and GUI objects with the associated modification types are reported.

To that end the GAP comparison logic may implement a bi simulation technique to compare schemas. shows an example of the bi simulation properties that the GAP comparison logic may employ including a first bi simulation property a second bi simulation property a third bi simulation property and a fourth bi simulation property .

The bi simulation may be a binary relation between the nodes of two graphs g g G written as x y x y V satisfying the bi simulation properties .

The GAP comparison logic may consider two finite graphs g g G equal if there exists a bi simulation from g to g. A graph is bi similar to its infinite unfolding. The GAP comparison logic may compute the bi simulation of two graphs starts with selecting the root nodes and applying the bi simulation properties . The GAP comparison logic search for a relation x y between nodes x and y in a graph that fails to satisfy the bi simulation properties . When such a relation x y is found then the GAP comparison logic determines that the graphs are not equal and the bi simulation may stop.

For example consider the current schema and the subsequent schema in . The GAP comparison logic applies bi simulation to determine whether two schemas and are equivalent. The schema describes XML data that models a current GUI screen and the schema models a modified version of the current GUI screen. The comparator logic may determine that If the schema is equivalent to the schema then the GUI screens are the same.

The GUI comparison logic selects the root nodes and in both schemas and that satisfy the first bi simulation property and the second bi simulation property . The GAP comparison logic may then select the relation root book from the schema and check to see that the third bi simulation property holds for the relation root root in the schema .

Since it does the GAP comparison logic determines whether the fourth bi simulation property holds for both relations. Since it does the GAP comparison logic proceeds to the relation author1 for the schema and the relation author1 for the schema . The GAP comparison logic determines that the third bi simulation property and the fourth bi simulation property are violated. In particular the GAP comparison logic determines that the offending relation author is tagged as potentially deleted in the schema a difference from the schema . Thus the schemas and are not equal.

In the example shown in the interface includes a slider that selects a value between 0 and 1. Any other interface or value range may be provided to the operator. The GUI difference model logic may set the difference threshold based on the value of the slider . The value 0 represents that essentially no or limited similarity is needed to find a match between GUI elements. The value 1 represents that very close or exact similarity is needed to find a match between GUI elements. Such similarity may be found in manual mappings for example as specified in a high confidence level field e.g. 100M as received from the metadata repository. However a very high level of confidence may also be obtained through the automated weighting analysis described above and the GUI difference model logic may in some implementations accept a manual version mapping as correct regardless of the associated confidence level.

In the visualization logic highlights matching GUI elements based on the similarity threshold set through the interface . The similarity threshold is relatively high. In the example shown in the visualization logic highlights the textbox elements and in the portion of the current GAP version that match respectively to the textbox elements and in the portion of the subsequent GAP version . The textbox elements have little or no changes in their characteristics between the subsequent GAP versions. The textbox element and the combo box element remain un highlighted however because their characteristics differ to a greater extent and the weighted comparison analysis does not determine a GUI element similarity value that exceeds the similarity threshold.

In the display shows that the slider has been adjusted to a lower similarity threshold. The visualization logic highlights the matching GUI elements based on the lower similarity threshold set through the interface . In the example shown in the visualization logic highlights as before the textbox elements and in the portion of the current GAP version that match respectively to the textbox elements and in the portion of the subsequent GAP version .

However the visualization logic also highlights the textbox element and the combo box element . Although the characteristics of the textbox element and the combo box element differ to a certain extent the weighted comparison analysis does obtain a GUI element similarity value that exceeds the similarity threshold. Accordingly the visualization logic highlights the elements and .

The visualization logic also may display a GUI comparator threshold interface . The visualization logic may set the similarity threshold based on the value chosen through the GUI comparator threshold interface . Given the similarity threshold the visualization logic may call the GUI difference model logic to determine a matching GUI element between the current GAP version and the subsequent GAP version . Alternatively the visualization logic may execute a comparison analysis e.g. the weighted comparison analysis described above to determine one or more GUI elements in the subsequent GAP version that match any particular element in the current GAP version. The visualization logic may accept an element selection from the operator that specifies one or more particular GUI elements of interest in either GAP version and find the matching GUI elements in the other GAP version. Alternatively the visualization logic may consider each GUI element in the current GAP version and find the matching GUI elements in the subsequent GAP version .

The visualization logic highlights matching GUI elements in the current GAP version and in the subsequent GAP version . To that end the visualization logic may issue commands to the proxy to highlight any particular GUI elements. If there are more GUI elements to consider the visualization logic attempts to find additional matches.

At any time the visualization logic may check to determine whether the GUI comparator threshold interface has changed e.g. the operator changed the slider position to select a new threshold value . The visualization logic may also check at any time whether the operator desired to review different GAPs. If so the visualization logic obtains new GAP selections . The visualization logic then displays the GAPs and the GUI comparator threshold interface and proceeds as noted above.

Exemplary aspects features and components of the system are described above. However the system may be implemented in many different ways. For example although some features are shown stored in computer readable memories e.g. as logic implemented as computer executable instructions or as data structures in memory all or part of the system and its logic and data structures may be stored on distributed across or read from other machine readable media. The media may include hard disks floppy disks CD ROMs a signal such as a signal received from a network or received over multiple packets communicated across the network.

The system may be implemented with additional different or fewer components. As one example a processor may be implemented as a microprocessor a microcontroller a DSP an application specific integrated circuit ASIC discrete logic or a combination of other types of circuits or logic. As another example memories may be DRAM SRAM Flash or any other type of memory. The processing capability of the system may be distributed among multiple components such as among multiple processors and memories optionally including multiple distributed processing systems. Parameters databases and other data structures may be separately stored and managed may be incorporated into a single memory or database may be logically and physically organized in many different ways and may implemented with different types of data structures such as linked lists hash tables or implicit storage mechanisms. Logic such as programs or circuitry may be combined or split among multiple programs distributed across several memories and processors and may be implemented in a library such as a shared library e.g. a dynamic link library DLL . The DLL for example may store code that prepares intermediate mappings or implements a search on the mappings. As another example the DLL may itself provide all or some of the functionality of the system tool or both.

While various embodiments of the invention have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly the invention is not to be restricted except in light of the attached claims and their equivalents.

