---

title: Methods and systems for filtering encrypted traffic
abstract: Application programming interface (API) hooks are injected into an application program executing at a client during run-time. Responsive to these hooks, data intended for encryption prior to transmission from the client is diverted, for example for content filtering, compression, etc., prior to being encrypted. In the case of encrypted data received at the client, the data is decrypted but before being passed to the application it is diverted, under control of the API hooks, for content filtering, decompression, etc.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09304832&OS=09304832&RS=09304832
owner: Blue Coat Systems, Inc.
number: 09304832
owner_city: Sunnyvale
owner_country: US
publication_date: 20080109
---
The present invention relates to methods and systems for filtering encrypted communication traffic for example HTTPS traffic without cracking the encryption and exposing the underlying plain text.

The Internet and its graphical user interface the World Wide Web are indispensable tools for all manner of communications and commerce. However not all types of communications are appropriate for viewing by all people. Further when transacting commerce via the Internet individuals generally insist upon some security measures to protect their sensitive information against compromise.

To address concerns regarding accessing of potentially inappropriate communications and here Web sites and the like are considered to be a form of such communications filtering technologies have been developed. These filters are software tools that can block access to specific Web sites and Internet services. Hence the filters allow administrators or parents to selectively control what sort of communications can be accessed when employees or minors are surfing the Web using a personal computer and a Web browser. In some cases the filters are applied at the local computer level while in other cases the filters are employed at computer systems e.g. proxies that act as gatekeepers between a personal computer or workstation and the Internet.

Security concerns on the other hand have been addressed through the use of encrypted communications between users local computer systems and remote computer systems called servers . Through an exchange of credentials that allow the local computer to verify the identity of the server and in some cases vice versa the two computer systems establish an encrypted communication session with one another. Data such as credit card numbers and the like exchanged between the computer systems during this session is not visible to other computer systems such as proxies that may reside in the communication path between the user s local computer and the server. This affords the user some degree of privacy and security when conducting commerce or other private transactions over the Internet.

While the use of encrypted communications is of great benefit in helping to facilitate commerce over the Internet it does pose a problem for the filters discussed above. Because the data called the plain text is encrypted by the time it reaches the filters whether the filters are deployed at the user s local computer or a proxy the filters cannot determine whether or not the content represented by that data is subject to filtering under the rules prescribed by the filter administrator. Hence the filter is rendered ineffective.

Recognizing this problem proxy vendors have developed solutions that allow the encrypted communications to be cracked so that for example the underlying plain text from a server can be examined against the prescribed filing rules. If the content represented by this data is found to be inappropriate under the filtering rules it is blocked. Otherwise the data is re encrypted and delivered to the user s local computer.

While this scheme allows content filters to operate on encrypted traffic exchanged between user s local computers and servers it does compromise the very security which the encrypted communication scheme sought to establish in the first place. For example if one considers an on line banking transaction which ordinarily would employ encrypted communications between the user s computer and the bank s server by cracking the encrypted communications at a proxy disposed between these two systems the user s personal financial information and perhaps his her log in credentials for the bank s Web site become exposed and may be subject to compromise.

Perhaps an even more important limitation of this proxy in the middle method is that it requires the client to trust everything that the proxy trusts. All secure communications are intercepted and the proxy acts as a man in the middle replacing the server s certificate with its own knowing the client will always trust the proxy even though the client may not always trust the endpoint to which the proxy is connected. That is the endpoint s e.g. an origin server s certificate is never examined by the end user as it otherwise would be when a direct connection is made to the endpoint. Thus this form of filtering for what are supposed to be secure communications is simply not acceptable to many individuals or institutions.

Nevertheless simply because communications are encrypted is not a sufficient reason to allow the data associated with such communications to pass unfiltered. Malicious programs such as worms and viruses could be disguised in such communications and if not subject to filtering would be allowed to pass unwittingly to a user s computer system or a server. Likewise content deemed inappropriate by a network administrator or a parent could bypass filtering by being shrouded in an envelope of encryption. Hence a methodology for filtering secure communications which nevertheless preserves the privacy of the information being exchanged and which ensures the user receives the original endpoint certificate is needed.

In various embodiments of the invention application programming interface API hooks are injected into an application program executing at a client during run time. Responsive to these hooks data intended for encryption prior to transmission from the client is diverted for example for content filtering compression etc. prior to being encrypted. In some cases the API hooks may be included in computer readable instructions that are injected into a currently running or starting process. These instructions contain the API hooks through which data flows for transmission just prior to encryption. This manipulation may or may not occur at the client and following the manipulations the data may be passed for encryption by an encryption engine at the client or remote from the client on which the application is executing e.g. via a secure tunnel .

In the case of encrypted data received at the client the data is decrypted but before being passed to the application it is diverted under control of the API hooks for content filtering decompression etc. Thereafter assuming the data is not otherwise blocked it is passed to the application.

Described herein are methods and systems for filtering encrypted communication traffic for example HTTPS traffic without cracking the encryption and exposing the underlying plain text.

Readers should recognize that various embodiments of the present invention may be implemented with the aid of computer implemented processes or methods a.k.a. software programs or routines that may be rendered in any computer language including without limitation C C C Fortran COBOL PASCAL assembly language markup languages e.g. HTML SGML XML VoXML and the like as well as object oriented environments such as the Common Object Request Broker Architecture CORBA Java and the like. In general terms such as software programs routines scripts and the like as used herein are meant to encompass any series of logical steps performed in a sequence to accomplish a given purpose.

In view of the above it should be appreciated that some portions of the detailed description that follows are presented in terms of algorithms and symbolic representations of operations on data within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the computer science arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise it will be appreciated that throughout the description of the present invention use of terms such as processing computing calculating determining displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention can be implemented with an apparatus to perform the operations described herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and processes presented herein are not inherently related to any particular computer or other apparatus. However some embodiments of the invention are intended for network systems where encryption decryption points can be identified and hooked. Further although specific examples of hook points for SSL communications are discussed below the techniques described herein are not necessarily limited to SSL and the same methods may find application anywhere that hooks may be set prior to encryption and after decryption of the data i.e. prior to transmission or after receipt of such data respectively .

Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method. For example any of the methods according to the present invention can be implemented in hard wired circuitry by programming a general purpose processor or by any combination of hardware and software. One of ordinary skill in the art will immediately appreciate that the invention can be practiced with any computer system configuration including personal computers workstations hand held devices multiprocessor systems microprocessor based digital signal processor based or other programmable consumer electronics network computers that employ thin client architectures minicomputers mainframe computers and the like. The invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.

Referring now to the illustration shows a computer system called a client communicatively coupled to a server via a computer network or network of networks such as the Internet . Communications between the client and the network take place over communication link while communications between server and network take place over communications link . Communications links and may be any form of communications links and the precise nature of these links is not critical to the present invention. Likewise client may be any of the above described forms of computer systems. Often client will be a personal computer or a mobile device such as a mobile phone having one or more applications capable of communicating over the Internet installed thereon. Such applications include but are not limited to Web browsers.

In order to provide secure communications of the type described above client also has installed thereon computer readable instructions that provide an encryption layer . For secure communications between client and server plain text is passed from application to encryption decryption layer where it is encrypted according to whichever secure communication scheme the client and the server have agreed upon. Often especially for communications over the Internet this secure communication scheme will be a form of secure socket layer SSL encryption such as HTTPS HTTP over SSL .

HTTP is the HyperText Transport Protocol and is one of the most often used communication protocols for passing data between computer systems via the Internet. HTTP is commonly used by Web browsers running on client computers to allow for the quick viewing of many filetypes and for ease of navigation among them. HTTPS operates virtually identically to HTTP except that data transported over HTTPS is encrypted prior to transmission. The encryption is performed using cryptographic keys exchanged between the client and the server at the outset of a communications session. Because the keys are unique to each computer system only the client and the server engaged in the communication session can decrypt one another s transmissions to recover the plain text.

As indicated then plain text is passed from application program at client to encryption decryption layer where it is encrypted prior to transmission. Note in some cases the encryption may occur remote from the client for example where the data is passed over a secure tunnel to be encrypted. In such instances the encrypted data would be subsequently transferred to the receiver from the platform at which it was encrypted or perhaps transferred back to the client for further processing and or transmission to the receiver.

Assuming the encryption occurs at the client the encrypted data is then passed to a network communications layer which handles the actual transmission of this information over communication link network and communication link to the server . In the case of communications over the Internet network communications layer and a corresponding network communications layer at server communicate using the Transmission Control Protocol Internet Protocol TCP IP communication suite. The details of this communication protocol are not critical to the present invention and other forms of network layer communications and communications protocols may be used.

When the traffic is received at server network communication layer passes the encrypted data to encryption decryption layer where the original plain text is recovered. That is using the cryptographic keys received from the client encryption decryption layer decrypts the received data to recover the original plain text that was transmitted from application . This plain text is then passed to application where it is processed according to the nature of the application.

Communications from server to client happen in the reverse sequence with encryption decryption layer encrypting plain text received from application and passing the encrypted data to network communication layer which transmits the encrypted information over network to network communications layer at client . The encrypted information is then passed to encryption decryption layer where it is decrypted using the keys provided by server . The resulting plain text is then passed to application . In the case where application is a Web browser this plain text may be a Web page or other information that is then presented to the user.

In accordance with the present invention rather than employing a proxy or other computer system between client and server where the encrypted traffic passed between them is cracked examined for compliance with filtering rules and then either blocked or re encrypted and passed on computer software installed on client is used to inject hooks into application to allow for diversion of the plain text to instruction layer for filtering and or modification of the traffic prior to encryption. These hooks may be injected at any point during run time including but not limited to times when application is initially launched at client .

In one embodiment of the present invention where application is a browser application the hooks are placed in application programming interface API calls in the browser at the point where plain text is to be passed to encryption layer . Note in many instances application layer will actually be a component of application but it is shown separately in the illustration for sake of clarity. By providing the hooks at this juncture the plain text can be diverted to instruction layer prior to encryption. This allows the plain text to be examined against filtering rules compressed and or otherwise modified prior to being encrypted. For example in some cases it may be desirable to employ dictionary compression of the plain text prior to encryption. The present invention facilitates such operations by diverting the plain text allowing the dictionary compression to be performed and then passing the compressed version of the plain text to the encryption decryption layer . From that point the compressed data may be encrypted and passed to the server as described above. Of course a decompression process would need to be employed at the server once the encrypted traffic had been decrypted by encryption decryption layer before the decrypted decompressed plain text could be passed to application .

Of course in many instances instruction layer will include a content filtering application or will permit the plain text to be diverted to such a content filtering application prior to encryption. This has the advantage of allowing the filtering desired by the administrator of the client e.g. a parent or the network in which the client is used to be performed before the data ever leaves the client . In particular the diversion may occur inside of application . The plain text thus remains within its place of origin and as long as the instruction layer is trusted there will be no compromise of the data. Note that if the data left application or client for processing in plain text it would be subject to ever increasing risks of compromise.

Notwithstanding the increased risk of compromise in some cases the plain text may be diverted to a remote trusted computer system across a trusted communication link for the filtering to be performed. This would in some instances require the use of security systems at each end of the communication link with the remote system in order to be certain that the plain text had not been compromised.

In the reverse data path for encrypted traffic received from server that traffic is decrypted at encryption decryption layer as discussed above but before being passed to the application it is diverted by instruction layer for filtering or other operations. In the case of filtering the filter rules may be run against the now decrypted plain text to ensure compliance with the administrator s policies but because the plain text is now resident at client it is not subject to compromise at some intermediary proxy. Again the decrypted plain text could be transferred from client to a remote trusted computer system across a trusted communication link for filtering. If the plain text passes the filtering operation it is provided to application otherwise it is blocked. As indicated above remote trusted systems and or trusted external processes on the client system could be used in both pre encrypt and post decrypt situations.

In addition to or in place of the filtering other operations may be employed on the decrypted plain text. For example in the case of an acceleration application the decrypted data may be decompressed before being provided to application . Many other operations on or modifications to the data could be made in this fashion.

Thus by employing instruction layer at client the present invention is able to facilitate filtering of or other operation on encrypted traffic without actually having to crack the encryption. In essence the data is acted upon either prior to the encryption or subsequent to the decryption but always within a trusted environment so that it is not subject to compromise. This permits HTTPS filtering and or HTTPS acceleration etc. without the necessity of cracking open SSL connections and without port specification. Although not discussed in detail above SSL cracking is extremely difficult without targeting a specific port since the SSL protocol does not use any type of plain text eye catcher etc. and multiple sends and receives are needed to detect the protocol. Moreover without the need for an intervening proxy certificate changes are not required and a client system can validate the original server certificates. This approach also minimizes the number of times data is encrypted and decrypted and provides opportunities to filter returned HTTPS content e.g. keywords could be detected and used in page ranking etc. .

Various embodiments of the present invention may employ the hook points identified in. Table 1 for commonly used browser applications such as Microsoft s Internet Explorer Mozilla s Firefox AOL s Netscape Navigator and Apple s Safari . The hook points are listed as ModuleName FunctionName. For example wininet InternetOpen is a hook on the function API InternetOpen in the wininet.dll operating system component. Likewise nspr4 PR Connect is a hook on the PR Connect function in the nspr4.dll or nspr4.so etc. platform specific application module.

Depending on the application hook points in addition to or other than those listed above may be desirable. For example for basic filtering applications and for Internet Explorer running on Windows one may use hook points at 

For acceleration or more advanced filtering applications hook points at the following may also be required 

Likewise for basic filtering applications and for Netscape Firefox Mozilla running on Windows one may use hook points at 

In the above lists the PR Close and InternetCloseHandle calls are hooked so that the end of a connection can be observed. The same is true with PR Shutdown. The PR GetHostByName is used to obtain the name instead of the IP address of the destination server. ssl3 SSL ImportFD is used to replace a normal connection handle with an SSL connection handle. The hooks on the PR Read PR Write InternetReadFile and InternetWriteFile calls are used to observe the data prior to encryption and after decryption. This way data enters a write call in plain text and leaves encrypted. Likewise decrypted data is returned to an application when a read call returns. In the latter case the original read function is first called and the data then examined and or modified before being passed to the application.

The above described hooks may be implemented using any of a variety of techniques. For example one can inject a new dynamic library into a process using techniques similar to the injector described in U.S. patent application Ser. No. 10 829 499 filed 22 Apr. 2004 assigned to the assignee of the present invention and incorporated herein by reference. Upon initialization the injected code installs hooks for the API call.

In addition API calls can be hooked by overwriting portions of the original computer readable instructions that make up the application to point to a trampoline to the newly injected code and another trampoline may be created to allow the replacement API contained in the newly injected code to call the original code. The new API is responsible for returning control to the caller. In some instances the API hooks may operate such that the original routine is called first and subsequent processing occurs before the code returns to the caller of the API. That processing can include changing the data originally passed to the API. The trampoline code for calling the original API must relocate the original now overwritten instructions and safely branch back to the unaltered portion of the original code. Of course other techniques for hooking calls exist for example techniques described in the above cited U.S. patent application Ser. No. 10 829 499 and the precise means by which the call is hooked is not critical to the present invention and any desirable means of doing so may be used.

The present invention also facilitates the use of an intervening proxy for performing HTTPS acceleration without acting as a man in the middle during certificate exchanges between the client and the server. As shown in following a complete certificate exchange between a server and a client a first connection Connection A is established between the client and the server. Thereafter the client opens a new connection to a proxy which then establishes its own connection to the server . The client s connection to the proxy is returned to the application running on the client and is utilized in reads and writes while the original connection between client and server remains available for calls such as getpeername . Client side writes may be utilized in an acceleration engine as needed and client side reads may be expanded into buffers provided by the application. When the session is closed the injected hooks close both the proxy connection and the original server connection .

While the number of connections and SSL exchanges on the server is doubled over that which it would normally be when the above described connection plan is used it does permit genuine server verification for the client and the proxy and client are able to manage byte caching and other data manipulations without cracking open the SSL exchange and decrypting and re encrypting traffic. Further optimizations to allow the original server connection to close immediately after the SSL handshake completes could be implemented in some instances. In such cases the client would need to forward requests such as getpeername to the proxy which could then make the call using its own connection to the server.

There may be instances where the above described scheme will not be appropriate for example for servers that require client certificates for authenticating the client. If such servers also support so called proxy certificates as described in IETF RFC 3820 a variation of the above scheme is possible. Proxy certificates are certificates that a middle man such as a proxy presents to one application end point typically a server on behalf of another application end point e.g. a client . The proxy certificate is signed by the entity on whose behalf the proxy is acting. The two connection scheme can make use of such proxy certificates in cases where client certificate authentication is deployed at the server.

In such scenarios the client can issue a proxy certificate to the intervening proxy using its private key. The certificate request from proxy to the client and the return of the signed proxy certificate from the client to the proxy can happen on connection between client and proxy . The client can also chain along its own certificate along with the signed proxy certificate. The proxy can then present the new certificate as it s proxy certificate along with the client s original certificate in a certificate chain to the server on connection . This should permit the server to verify the certificate chain comprising of proxy certificate followed by the client s certificate and complete an SSL handshake with the proxy and facilitate the above described transactions. Note the that presence of the original client certificate in this certificate chain enables the server to identify the client end point and the intervening proxy.

Thus methods and systems for filtering encrypted communication traffic for example HTTPS traffic without cracking the encryption and exposing the underlying plain text have been described. Although discussed above with reference to certain illustrated embodiments the present invention should not be limited thereby. Instead the invention should only be measured in terms of the claims which follow.

