---

title: System and method for improving run-time performance of applications with multithreaded and single threaded routines
abstract: A system and method for improving run-time performance of applications with multithreaded and single threaded routines that are linked with libpthreads library is disclosed. In one embodiment, a method for running a mixed ST/MT application program linked with libpthreads library including creating an interceptor library containing pthread application programming interface (pthread_API) call interceptors and loading the interceptor library into the mixed ST/MT application program, and running the mixed ST/MT application program by using light weight (LW) and heavy weight (HW) synchronization routines based on determining switchovers between ST and MT program modes, respectively, during run-time using the interceptor library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495662&OS=08495662&RS=08495662
owner: Hewlett-Packard Development Company, L.P.
number: 08495662
owner_city: Houston
owner_country: US
publication_date: 20080923
---
Benefit is claimed under 35 U.S.C. 119 a d to Foreign application Ser No. 1930 CHE 2008 entitled SYSTEM AND METHOD FOR IMPROVING RUN TIME PERFORMANCE OF APPLICATIONS WITH MULTITHREADED AND SINGLE THREADED ROUTINES by Hewlett Packard Development Company L.P. filed on 11 Aug. 2008 which is herein incorporated in its entirety by reference for all purposes.

Generally multithreaded MT programs based on pthreads have considerably more overhead than single threaded ST programs due to synchronization requirements in standard threaded library routines during run time. This overhead can significantly affect the performance of MT programs when they are used in an ST program mode.

One current technique addresses this problem by including an MT option that does not create multiple threads in the MT programs that uses pthread library calls and only operates in the ST program mode during run time. Another current technique solves the MT overhead problem for the ST programs that has been optimized by compilers to run like the MT programs by marking MT regions through pthread autoparallelizations. Generally such converted MT programs have well defined MT regions since compiler decides when the ST program can begin and end to run as an MT program. This is generally accomplished by exporting interfaces from libpthreads for communicating the beginning and end of ST program mode to the libpthreads. Generally the libpthreads use this information to decide whether to use a heavy weight HW synchronization or a light weight LW synchronization to improve performance.

However the above techniques do not address the general problem of significant overhead created in the MT programs that alternate between the MT and ST program modes. Further the current techniques cannot address the overhead problem in the MT programs when the existing legacy auto parallelized open market partition MP applications are created using older compilers which do not have the ability to mark when an MT program can begin and end to run as an ST program. The above techniques address only one way first time switchover from the ST to MT program mode or vice versa and for subsequent threads they continue to pay the excessive synchronization overhead.

There are many MT programs that run in the ST program mode most of the time and run on the MT program mode briefly only to handle some service requests or perform certain compute intensive tasks. In such scenarios these programs suffer from significant performance overhead due to the HW synchronization requirements in the standard threaded library routines. Typical example of such programs in producer consumer type of applications includes Web applications which are usually written as threaded applications. In these applications a main thread server waits for requests from a client and when one such request arrives the main thread spawns a new thread there can be many such requests . Upon completing the request the threads generally terminate and the main thread then waits again for another request from the clients. These MT programs are generally characterized by running most of the time in the ST program mode and only running in short periods in the MT program mode. However such programs pay the penalty of performance overhead while using MT safe standard library routines for the entire time they are running. It can be seen that such programs suffer from excessive MT overhead due to high synchronization requirements that requires the pthread library calls to mutex lock and mutex unlock which use waiters list. The excessive MT overhead can be of the order of 2 3 times that of running an ST program without the MT overhead and this can significantly slowdown an application during run time.

Other features of the present embodiments will be apparent from the accompanying drawings and from the detailed description that follows.

A system and method for improving run time performance of applications with multithreaded and single threaded routines is disclosed. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the various embodiments. It will be evident however to one skilled in the art that the various embodiments may be practiced without these specific details.

The terms pthread refers to a set of C programming language types and procedure calls. For example pthreads can include library of threads that use substantially same time shared resources such as using same memory during run time which requires mutex lock and mutex unlock. The term mixed ST MT application program refers to an MT program that runs on an ST program mode most of the time and runs on an MT program mode briefly only to handle some service requests or to perform certain compute intensive tasks. The terms switch and switchover is used interchangeably throughout the document.

In step a thread counter is initialized by a predetermined value. In step the thread counter is incremented or decremented by the predetermined value upon each pthread create call or pthread exit call respectively during run time. In one example embodiment the mixed ST MT application program may be run in an ST program mode by informing a pthreads library to call light weight LW synchronization routines or in an MT program mode by informing the pthreads library to call heavy weight HW synchronization routines based on a value in the thread counter.

In step a resulting overhead due to switchovers between the ST and MT program modes is estimated using statistical analysis or profile data including pthread API calls based on previous mixed ST MT application program that runs upon incrementing the thread counter by the predetermined value. In some embodiments the statistical analysis or profile data e.g. includes the pthread API calls is based on determining duration of time during which the mixed ST MT application program stays in the ST program mode during run time and the estimated resulting overhead. In one example embodiment the resulting overhead and expected percent of improvement are computed using the following equations Resulting overhead number of locks to be converted estimated overhead helper thread overhead pthread call overhead. Expected percent of improvement number of locks found during the period of time the mixed ST MT application program runs in the ST program mode estimated overhead for HW per lock.

In step the mixed ST MT application program may be run in the ST program mode by informing the pthreads library to call the LW synchronization routines or in the MT program mode by informing the pthreads library to call the HW synchronization routines based on the estimated resulting overhead. In one example embodiment the mixed ST MT application program may be run by using the LW and HW synchronization routines based on determining the switchovers between the ST and MT program modes respectively during run time using the interceptor library.

In accordance with the above mentioned embodiments the interceptor library e.g. including the pthread API call interceptors is created for libpthread library. Further the interceptor library is loaded into the mixed ST MT application program. In one example embodiment a LD PRELOAD environment variable is used to instruct a dynamic loader to load the interceptor library first before any other libraries when it searches for shared libraries for example on an HPUX Hewlett Packard Unix operating system. Any pthread API call made by the mixed ST MT application program is first resolved using the interceptor library. The interceptor library executes certain amount of book keeping and makes the actual pthread API call. In one example embodiment the interceptor library is loaded into already existing binaries e.g. the mixed ST MT application program without the need to recompile the interceptor library.

Further the interceptor library intercepts the pthread create and pthread exit calls. The interceptor library further keeps the thread counter to maintain a number of threads at any point of time. In one embodiment the thread counter increments or decrements by the predetermined value upon each pthread create call or pthread exit call respectively during run time. For example the thread counter is initialized to 1 indicating execution of the main thread. Consider the mixed ST MT application program is in ST program mode. From the ST program mode when a call to pthread create is made the thread counter increments by the predetermined value and indicates that the mixed ST MT application program is switched to the MT program mode. Similarly a call to pthread exit is made the thread counter decrements by the predetermined value and indicates that the mixed ST MT application program is switched to the ST program mode.

In operation when the mixed application program switches from the MT program mode to the ST program mode the dynamic optimizer determines whether it is profitable to inform pthreads library to call the LW synchronization routines. In one example embodiment the dynamic optimizer e.g. may be an Itanium compiler runtime roadmap is enhanced to monitor the ST MT application program. Further book keeping is required when the ST MT application program switches from using the LW synchronization routines to the HW synchronization routines. Hence it may not be profitable to make the HW synchronization routine switchover to the LW synchronization routine unless the ST program mode is sufficiently long enough to recover the overhead during the switch. Further if it is decided that it is profitable to switch the mixed ST MT application program switches from the MT program mode to the ST program mode and informs the pthreads library accordingly. The LW synchronization routines are used during the ST program mode.

Further when the application is about to re enter the MT program mode the dynamic optimizer checks which of the outstanding locks are held by the existing ST program mode makes the mixed ST MT application program to execute the HW synchronization routines for these locks and then informs the pthreads library accordingly. This triggers the libpthread library to start using the HW synchronization routines when the mixed ST MT application program shifts to the MT program mode. During switchover if there are locks held by the ST program mode that are acquired while in the MT program mode certain book keeping and clean up operation needs to be carried out to destroy the waiters s list etc. Due to which the LW synchronization routines operate correctly on those locks. In another embodiment the above described mechanism is also implemented within the libpthread library itself as illustrated in .

In step a thread counter is initialized by a predetermined value. In step the thread counter is incremented or decremented by the predetermined value upon each pthread create call or pthread exit call respectively during run time. In one example embodiment the mixed ST MT application program may be run in an ST program mode by informing pthreads library to call the LW synchronization routines or in an MT program mode by informing the pthreads library to call the HW synchronization routines based on a value in the thread counter.

In step a helper thread is triggered upon decrementing the thread counter by the predetermined value. In one example embodiment the helper thread is triggered to compute an estimated resulting overhead by determining duration of time the mixed ST MT application program runs in the ST program mode by examining sliced versions of the mixed ST MT application program. In step the mixed ST MT application program may be run in the ST program mode by informing the pthreads library to call the LW synchronization routines or in the MT program mode by informing the pthreads library to call the HW synchronization routines based on the determined duration of time and the estimated resulting overhead. In one example embodiment the mixed ST MT application program may be run by using the LW and HW synchronization routines based on determining switchovers between the ST and MT program modes respectively during run time using the interceptor library.

At the mixed ST MT application program switches to the MT program mode. In these embodiments a check is made to determine whether the locks which have to be converted to HW locks are available. The dynamic optimizer checks which are the outstanding locks held by the existing ST program mode makes the thread to execute the HW synchronization routines for these locks and then informs the pthreads library accordingly. At the mixed ST MT application program runs in the MT program mode. In one example embodiment in the MT program mode the pthreads library calls the HW synchronization routines. As a consequence the libpthread library is triggered to start using the HW synchronization routines. At a check is made to determine whether the mixed ST MT application program is to be switched to the ST program mode or not. At if the helper thread estimates that the overhead is high the mixed ST MT application program runs in the MT program mode only though the mixed ST MT application program is in the ST program mode.

For example when there is a switchover from the MT program mode to the ST program mode a dynamic optimizer e.g. Itanium compiler runtime roadmap determines whether it i.e. switchover from the MT program mode to the ST program mode is profitable to inform the pthreads library to call the LW synchronization routines. In these embodiments the dynamic optimizer may be enhanced to monitor the ST MT application program mode. In one example embodiment it is not profitable to make the synchronization routine to switchover from the MT program mode to the ST program mode unless the ST program mode is sufficiently long enough to recover the overhead in making the switch.

At the mixed ST MT application program continues to run in the MT program mode since the helper thread estimates overhead is high at . At the mixed ST MT application program runs in the MT program mode. In one embodiment if the dynamic optimizer determines that it is profitable to switchover from the MT program mode to ST program mode the dynamic optimizer informs the pthreads library that the mixed ST MT application program to switch to the ST program mode. At the mixed ST MT application program switchovers to the ST program mode during which the LW synchronization routines are used during the ST program mode. At the ST MT application program runs in the ST program mode and the ST MT application program uses LW locks thus avoiding the overhead when the ST MT application program runs in the ST program mode. As illustrated in the performance of the MT program is improved during the time period when the mixed ST MT application program runs in the ST program mode.

The diagrammatic system view may indicate a personal computer and or a data processing system in which one or more operations disclosed herein are performed. The processor may be a microprocessor a state machine an application specific integrated circuit a field programmable gate array etc. The main memory may be a dynamic random access memory and or a primary memory of a computer system. The static memory may be a hard drive a flash drive and or other memory information associated with the data processing system.

The bus may be an interconnection between various circuits and or structures of the data processing system. The video display may provide graphical representation of information on the data processing system. The alpha numeric input device may be a keypad keyboard and or any other input device of text e.g. a special device to aid the physically handicapped . The cursor control device may be a pointing device such as a mouse. The drive unit may be a hard drive a storage system and or other longer term storage subsystem.

The signal generation device may be a BIOS and or a functional operating system of the data processing system. The network interface device may perform interface functions e.g. code conversion protocol conversion and or buffering required for communications to and from the network between a number of independent devices e.g. of varying protocols . The machine readable medium may provide instructions on which any of the methods disclosed herein may be performed. The instructions may provide source code and or data code to the processor to enable any one or more operations disclosed herein.

For example a storage medium having instructions that when executed by a computing platform result in execution of the method of running the mixed ST MT program linked with libpthreads library including creating the interceptor library containing the pthread application programming interface pthread API call interceptors and loading the interceptor library into the mixed ST MT application program and running the mixed ST MT application program by using the LW and HW synchronization routines based on determining the switchovers between the ST and the MT program modes respectively during run time using the interceptor library.

The storage medium may also have instructions to dynamically load the interceptor library before loading other shared libraries from the mixed ST MT application program to initialize the thread counter by the predetermined value to increment or decrement the thread counter by the predetermined value upon each pthread create call or pthread exit call respectively during run time and to run the mixed ST MT application program in the ST program mode by informing pthreads library to call the LW synchronization routines or in the MT program mode by informing the pthreads library to call the HW synchronization routines based on the value in the thread counter.

Also the storage medium may have instructions to estimate a resulting overhead due to the switchovers between the ST and MT program modes using statistical analysis or profile data including pthread API calls based on previous mixed ST MT application program runs upon incrementing the thread counter by the predetermined value and to run the mixed ST MT application program in the ST program mode by informing the pthreads library to call the LW synchronization routines or in the MT program mode by informing the pthreads library to call the HW synchronization routines based on the estimated resulting overhead.

Furthermore a computer system includes a processor a memory coupled to the processor the memory having stored therein code which when decoded by the processor the code causes the processor to perform the method of running the mixed ST MT program linked with the libpthreads library including creating the interceptor library containing the pthread application programming interface pthread API call interceptors and loading the interceptor library into the mixed ST MT application program and running the mixed ST MT application program by using the LW and HW synchronization routines based on determining the switchovers between the ST and MT program modes respectively during run time using the interceptor library.

The above described technique improves performance of arbitrarily mixed ST MT application programs which are linked with the libpthread library but remains in the ST program mode most of the time by reducing the requirement of excessive synchronization overhead even when running on the ST program mode. Further the above technique improves performance of applications created using existing legacy auto parallel open market partition MP applications created with older compilers which do not have the ability to mark beginning and ending ST regions by reducing the need to pay for excessive synchronization overhead even when they are running in the ST program mode most of the time.

The above technique efficiently determines the transition from the MT program mode to the ST program mode and vice versa during runtime and communicates this transition information to the libpthreads to switchover the synchronization from the HW to LW synchronization routines. Further the above technique ensures that the application semantics are not violated due to the switchover from the HW synchronization routines to LW synchronization routines. For example if an applications thread has executed an acquire lock in the ST program mode which would have been through the LW synchronization routines and if the lock has not been released at the point of switching from the ST program mode to the MT program mode and hence from the LW to HW synchronization routines there is a need to ensure that subsequent unlock lock operations for this lock using the HW synchronization routines perform as desired. In addition the above technique determines the profitability of applying the switchover from the HW to LW synchronization routines selectively at MT ST program mode transitions.

Also the method may be in a form of a machine readable medium embodying a set of instructions that when executed by a machine cause the machine to perform any method disclosed herein. It will be appreciated that the various embodiments discussed herein may not be the same embodiment and may be grouped into various other embodiments not explicitly disclosed herein.

In addition it will be appreciated that the various operations processes and methods disclosed herein may be embodied in a machine readable medium and or a machine accessible medium compatible with a data processing system e.g. a computer system and may be performed in any order e.g. including using means for achieving the various operations . Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

