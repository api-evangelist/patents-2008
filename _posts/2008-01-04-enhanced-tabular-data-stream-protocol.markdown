---

title: Enhanced tabular data stream protocol
abstract: Systems and methodologies are provided as part of a computing environment that implements an enhanced tabular data stream (TDS) protocol. Such enhanced TDS protocol can mitigate synchronization inconsistencies between client and servers, improve robustness of the data transfer, facilitate password specification as part of login procedures, and reduce administration overhead. Various headers are provided as part of the data stream protocol, and a versioning scheme is established that facilitates proper communication between servers and clients having different release dates and versions of the TDS protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370511&OS=08370511&RS=08370511
owner: Microsoft Corporation
number: 08370511
owner_city: Redmond
owner_country: US
publication_date: 20080104
---
This application is a continuation of copending U.S. application Ser. No. 10 773 724 filed Feb. 6 2004 entitled ENHANCED TABULAR DATA STREAM PROTOCOL the entirety of both are hereby incorporated by reference as if fully set forth herein.

The present invention relates generally to features of a Tabular Data Stream TDS protocol and more particularly to systems and methods for improving security compatibility and synchronization between servers and client drivers that employ the TDS protocol.

Advances in computer technology e.g. microprocessor speed memory capacity data transfer bandwidth software functionality . . . have generally contributed to increased computer application in various industries such that organization of computer systems has changed dramatically. The concept of a large computer center with a single large computer to which all users bring their work is obsolete. Similarly Data Base Management Systems DBMS systems have long since moved from a centralized mainframe environment to a de centralized or distributed environment. One or more PC client systems for instance can be connected via a network to one or more server based database systems SQL database server . Known examples of computer networks include local area networks LANs where the computers are geographically close together e.g. in the same building and wide area networks WANs where the computers are farther apart and are connected by telephone lines or radio waves.

Often networks are configured as client server networks such that each computer on the network is either a client or a server. Servers are powerful computers or processes dedicated to managing shared resources such as storage e.g. disk drives printers modems or the like. Servers are often dedicated meaning that they perform no other tasks besides their server tasks. For instance a database server is a computer system that manages database information including processing database queries from various clients. The client part of this client server architecture typically comprises PCs or workstations which rely on server s to perform operations. Typically a client runs a client application that relies on a server to perform some operations such as returning particular database information. Over such networks various protocols that

transport information according to specifications while at the same time accompany other request response protocols have emerged.

One such protocol is the TDS protocol which is a message oriented application level protocol employed for transfer of requests and responses between client and server systems and can include native support for traditional Structured Query Language SQL data types such as character char variable length character vchar binary blob date time time stamp together with some support for vendor specific data types. In systems employing TDS it is typical for a client such as a user or application program to establish a long lived connection with a server such as a database system. Upon a successful hand shake and establishment of the connection via any suitable supported transport session level protocol a complete message is sent from client to server after which a complete response is sent from server to client.

Generally some prior versions of the TDS protocol were not adapted to designate whether down level clients and new clients can communicate with down level servers or new servers. In addition various requirements of the protocol could typically create potential inefficiencies in utilizing a system s resources. For example to send large values in the form of followed by can require computation and allocation of a CPU memory which could have other wise been employed for completion of higher priority tasks. As another example during a re set operation the client driver typically does not know if the re set operation had succeeded or not until the submitted request has been completed. As such long running requests could imply long wait times to determine whether a re set operation had succeeded or not and while the driver was pending confirmation of success of a reset operation other requests on the same connection were blocked as it was uncertain whether the connection was usable or not.

At the same time in some cases it can be desirable for a client driver to cancel a command executing in the server without rolling back the current transaction. Likewise it can be desirable to reduce administration over head when employing a TDS protocol in a network environment. For example having administrators assigned to resetting user expired passwords can increase costs and reduce productivity.

The following presents a simplified summary of the invention in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention. It is intended to neither identify key or critical elements of the invention nor to delineate the scope of the present invention. Rather the sole purpose of this summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented hereinafter.

The present invention provides for an enhancement of a Tabular Data Stream TDS protocol that can be employed for client server communication networks. As part of such enhanced protocol various systems and methods are provided for versioning and supporting a Multiple Active Result Sets MARS feature which can include a data field header for example. Such a data field can identify to servers a number of pending requests known by clients and facilitate query synchronization regardless of buffer sizes employed in the client server communications network. Other aspects of the enhanced TDS protocol according to the present invention can facilitate query execution and administration aspects e.g. password regulation for such networks.

A versioning scheme of the present invention accounts for chronological versioning of TDS components e.g. release dates as well as software versioning e.g. protocol version and negotiates down to a common version between the client and the server side. Such scheme can facilitate instant determination of a protocol version that is common between the client and the server so that both down level clients and new clients can communicate with both down level servers and new servers for example. Accordingly background compatibility between the server and client can be improved when changes occur to implemented versions of the TDS protocol.

Another aspect of TDS protocol of the present invention improves consistency of behavior on server side e.g. when server commits transactions. Initially and as part of a header field client can send to server number of pending requests known to client driver. In case server already has completed processing of previous requests such number reported by client helps synchronize and coordinate a view of the number of requests currently pending therebetween. Such can typically mitigate inconsistent server behavior related to instances wherein buffer zones are waiting to be read by the client. For example a typical inconsistent behavior can arise when the client executes a query the server performs and the results remain in a network buffer waiting to be read by the client.

In a related aspect according to the present invention query notification headers are provided as part of the enhanced TDS protocol. At the time of establishing the query the server is asked to provide the client with future update results related to the query. As such a requirement for periodically re asking the server of any changes to the initial query can be mitigated. Accordingly the manner of sending such notifications e.g. channels for sending the notification as well as the set up for notification is established at the time of the query and does not require changes to be made on the client side. Moreover such feature allows creation of middle tier type caches which can be transparent to the client.

To the accomplishment of the foregoing and related ends the invention then comprises the features hereinafter fully described. The following description and the annexed drawings set forth in detail certain illustrative aspects of the invention. However these aspects are indicative of but a few of the various ways in which the principles of the invention may be employed. Other aspects advantages and novel features of the invention will become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The present invention is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the present invention.

As used in this application the term computer component is intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a computer component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a computer component. One or more computer components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The present invention provides for an enhanced Tabular Data Stream Protocol with a versioning scheme annotation of requests and Multiple Active Results Sets MARS headers. Typically in systems employing TDS a client such as a user or application program initiates a handshake with the server and sends a complete message thereto after which a complete response is sent from server to client. For example below is a high level description of the messages exchanged between the client and the server to execute a simple SQL statement e.g. select name from sysobjects where id

The server executes the statement and then sends back the results to the client. The data columns being returned are first described by the server and then the rows follow. A completion message is sent after the row data has been transferred.

Referring now to various other feature enhancements for a TDS protocol is illustrated in accordance with an aspect of the present invention. For example chunk format component can employ a Partially Length Prefixed PLP format to transmit large volumes of data as described in detail infra. Briefly the chunk format component provides for a special length designator which can be sent to a data stream receiver e.g. a client indicating that length of total value is not known and that such value can be streamed in several chunks. For example each chunk can contain a designator followed by with a specific value reserved for as designation to the receiver . Thus data stream packets can have individual data items that are themselves streams of indeterminate length and transmittal of large data values is thus facilitated. Moreover the chunk format component of the TDS protocol provides the receiver with option of additional optimization that can exist as part of the receiver . Likewise a re order component provides for a re order of large output parameters in the data stream e.g. small values can be sent first with the large values to follow. Such feature can enable efficient parameter retrieval from the API model as described in detail infra. Similarly a conversion component of the TDS protocol is a new transaction manager request of TM PROMOTE as described in detail infra which can convert a local transaction into a Distributed Transaction Coordinator DTC transaction. Such improvement can facilitate application performance for example in COM programming model s System Enterprise Services System Transactions wherein transaction services can be provided at component boundaries with several disjoint components co operating under a same transaction and employing a single SQL Server Resource Manager. In addition a server side attention component is provided that enables graceful failure of a server side without dropping an established connection. Briefly a bit is reserved in the TDS header such that a packet as part of data stream sent from the server to the client can set such bit indicating to a server side cancellation of a currently executing request. Thus if such bit is set client drivers can become prepared to abort current requests. As such internal state of client drivers can generally be reset and any subsequent protocol packets can be treated as new server side responses with state recreated thereafter. A server side attention component provides robustness to the TDS protocol so that occurrence of exceptions and errors on the server side do not fatally affect entire connection or other requests running there under. Similarly a low severity attention component provides for an interrupt signal without affecting transaction semantics and is described in detail with respect to infra.

A password change component of the TDS protocol specifies a new password as part of a login procedure when the old password is presented. If a previous password matches systems employing the TDS protocol can change the password for login. Subsequently such systems can proceed with logon process and session establishment. Similar to resetting the connection the password change request component can be achieved by being aligned with and performed as a function of another request which is sent out of band from an initial query of the protocol . Accordingly problems associated with locked out administrators as well as administrators resetting users expired passwords can be mitigated.

On the client side the data can be a login record or a Structured Query Language SQL command being in a language that the server side can accept a SQL command followed by its associated binary data e.g. the data for a bulk copy command or an attention signal. When a connection is desired the client can send a login data stream to the server. Even though the client can have more than one connection to the server each connection path can be established separately and in the same manner. An exemplary TDS protocol and detailed syntax employed for marking the data is provided at the end section of this specification.

Once the server has received the login record from the client it will notify the client that it has either accepted or rejected the connection request. Like wise to send SQL command or batch of SQL commands then the SQL command e.g. represented by a Unicode format can be copied into the data section of a buffer and then sent to the SQL Server side . A SQL batch may span more than one buffer. In addition various Open Data Base Connectivity ODBC routines can cause SQL command to be placed into a client message buffer or can cause the message buffer to be sent to the server. Such buffer header arrangement according to one aspect of the present invention will be described in detail infra.

In addition for an SQL command with binary data the insert bulk operation can represent a case of a SQL command e.g. in a Unicode format followed by binary data. Initially an insert bulk command can be sent to the server in the normal way and once an acknowledgment is received from the server the client can then send formatted binary data to the server . Such functionality can be provided by routines included in the ODBC in accordance with one exemplary aspect of the present invention. Moreover the client can initially send an insert bulk SQL statement followed by a COLMETADATA token which describes the raw data followed by Multiple rows of binary data to the server . The data is not formatted in storage engine row format but rather the format described by the COLMETADATA token. The stream is the same as if the data was being selected from the server rather than being sent to the server . One particular TDS protocol and detailed syntax employed for marking the data is provided toward the end section of this specification.

In one aspect of the present invention when there is desire to execute a remote procedure call on the server the client can send a Remote Procedure Call RPC data stream to the server. Such is a binary stream that contains the RPC name options and parameters. Typically RPCs can be in a separate message and not intermixed with SQL commands. Additionally there can be several RPCs in one message.

If an interrupt is desired the client can cancel a current command by sending an attention signal also known as out of band data . Once the client sends an attention signal described in further detail infra the client continues reading until it gets an attention acknowledgment. During the time between sending the attention and receiving the acknowledgment the client can discard any buffers it receives. An attention request of the present invention can roll back any transactions active in the request s stack. In a related aspect the client can request that the connection enlist in a Distributed Transaction Coordinator DTC transaction. Furthermore the client can interrupt and cancel a current command without affecting transaction semantics by sending a non severe attention NSA signal. Once the client sends an NSA the client reads until it gets an attention acknowledgment. An NSA cancels a specific request though it does not affect the state of the current transaction. It is noted that an NSA can be sent to the server during the execution of the following stored procedures when invoked via IPC interprocess communications that are numbered on the RPC requests of Sp cursor Sp cursorfetchnext and Sp cursoroption. If NSA is sent during execution of any other command or to abort non ipc invocation it can be considered a client error and an error flag can be raised. Typically in other respects the NSA behaves as a regular attention.

Referring now to the server side the data can comprise a login response row data return status of an RPC return parameters of an RPC request completion information error and information or an attention signal as described in detail infra. The login response can be a token stream consisting of information about server characteristics optional information and error messages followed by a completion message. Here a LOGINACK data stream can include information about the SQL interface and the server s product code and name. If there are any messages in the login response an ERROR or INFO data stream is returned from server to the client .

There can also be a ENVCHANGE data stream if the login changed the environment and the associated notification flag has been set. Moreover if the database specified for connection in the login packet is participating in real time log shipping then the corresponding ENVCHANGE can be included as part of the response. A done packet is always present as the final part of the login response. Thus a DONE data stream is the last thing sent in response to a client login request. Moreover if the client request results in data being returned the data can precede any other data streams returned from the server e.g. Row data is preceded by a description of the column names and data types. When an RPC is executed by the server the server typically returns a status value. Such can be a 4 byte integer that can be sent via the RETURNSTATUS token. As for the return parameters the response format for execution of a stored procedure can be identical regardless of whether the request was sent in SQL or RPC format. For example such can be a table response to command type message.

If the procedure explicitly sends data then the message can start with one token stream of rows informational messages and error messages. Such data can be sent in the usual way. Also when the RPC is invoked some or all of its parameters can be designated as output parameters. Such features allow RPC parameters to act like variables that are passed by reference. Typically output parameters can have values returned from the server . For each output parameter there can be a corresponding return value sent via the RETURNVALUE token. The RETURNVALUE stream can also be employed for sending back the value returned by a User Defined Function UDF when it is called as an RPC.

Although the end of message can be determined by the length field in the buffer header the client can read results in logical units and can also determine when all results have been received by examining the DONE data stream. Accordingly when executing a batch of SQL commands there can be a DONE data stream for each set of results. All but the last DONE can have the DONE MORE bit set in the Status field of the DONE data stream. Therefore the client can typically tell after reading a DONE whether or not there are more results. Likewise for stored procedures and for each statement completion of statements in the stored procedure can be indicated by a DONEINPROC data stream and a DONEPROC data stream for each completed stored procedure. For example if a stored procedure executes two other stored procedures a DONEPROC data stream can signal the completion of each stored procedure. Additionally besides returning description of row data and data itself an enhanced TDS protocol according to the present invention can provide a data stream type for the server to send error or informational messages to the client. Such can be the INFO data stream and the ERROR data stream. At the same time once the client has sent an interrupt signal to the server the client typically can read returning data until the interrupt has been acknowledged. As such attentions are acknowledged in the DONE data stream or the DONEPROC data stream. An exemplary TDS protocol and detailed syntax employed for marking data is provided toward an end section of this specification.

Referring now to an exemplary buffer header arrangement in accordance with an aspect of the present invention is illustrated. Typically a buffer is the unit written or read at one time and can be modeled as a packet . A message can consist of one or more buffers. A buffer can include a buffer header and is usually followed by buffer data that contains the message. Moreover each new message can start in a new buffer.

Typically both the Client and Server will try to read a buffer full of data. They can pick out the header to see how much more or less data there is in the communication. When the underlying network interface insists on blocking until all bytes specified in the read have been read the client can read the header and then determine how much more to read. In one aspect of the present invention and at login time client can specify a requested packet size. Such can identify a size employed to break large messages into smaller packets . Furthermore server acknowledgement of changes in the negotiated packet size can be transmitted back to the client via ENVCHANGE streams. Also for requests sent to the server larger than the current negotiated packet size client typically can send all but the last chunk with a total number of bytes equal to the negotiated size. As such only the last packet in the request can have an actual number of bytes smaller than the negotiated packet size. If any of the intermediate chunks is not sent at its maximum capacity the server disconnects the client when the next chunk arrives.

In a related aspect of the present invention to implement messages on top of existing and arbitrary transport layers a buffer header is included as part of the buffer. As illustrated in a particular example of a buffer header which precedes all data within the buffer can be 8 bytes in length. Such buffer header can further include items such as Type Status Length SPID Packet and window as described in detail below.

For example the following illustrates a description of a particular message exchange between the client and the server 

Status is a bit field used to indicate the message state. Status is a 1 byte unsigned char. Exemplary status include 

Length is the size of the buffer including the eight bytes in the buffer header. It is the number of bytes from the start of this header to the start of the next buffer header. Length can be a 2 byte unsigned short int.

Spid is the process id on the server corresponding to the current connection. Such can be useful for identifying which thread on the server sent the TDS packet and is provided for debugging purposes.

Packet is used for numbering message buffers that contain data in addition to the buffer header. Packet is a 1 byte unsigned char. Each time a data buffer is sent the value of tds packet is incremented. Exemplary Data buffers can be of following types 

In a related aspect of the present invention messages that pass between client and the server can typically be one of two types either a token stream or a tokenless stream . A token stream consists of one or more tokens each followed by some token specific data. A token is a single byte identifier used to describe data that follows it e.g. contains token data type token data length and the like. Tokenless streams are typically used for simple messages while messages that can require a more detailed description of the data within it are sent as a token stream. The table below provides an example which messages use token streams and which do not.

As explained earlier some messages do not use tokens to describe the data portion of the data stream. In such cases all the information required to describe the buffer data is contained in the buffer header. This is referred to as a tokenless stream and is essentially just a collection of buffers and data. illustrates a tokenless stream in accordance with an aspect of the present invention that spans two buffers A and B.

More complex messages e.g. Row Data can be constructed using tokens. illustrates a token stream according to one aspect of the enhanced TDS protocol of the present invention that spans two buffers and consists of a single byte identifier followed by token specific data.

Typically there exist four classes of token a zero length token a fixed length token a variable length token and a variable count token. Such are listed below including the bit pattern of the token various extensions to this bit pattern for a given token class and a description of their function s according to one aspect of the present invention.

This token is not followed by a length. There is no data associated with the token. A zero length token always has its third bit off and the fourth bit on.

This token can be followed by 1 2 4 or 8 bytes of data. No length follows this token since the length of its associated data is encoded in the token itself. Bits and are always on. Bits and indicate the length of the fixed length data as shown below.

In one exemplary aspect of the present invention fixed length tokens can be employed by the following data types bigint int smallint tinyint float real money smallmoney datetime smalldatetime and bit.

This token is followed by a length. The length in bytes of this length is included in the token itself as a Length value see the Length rule of the COLINFO token stream as described toward an end section of this specification. Bit is always on and bit is always off.

There can be two data types that can be of a variable length. Such are real variable length data types like char and binary and nullable data types that are either their normal fixed length or a special length if null. Char and binary data types have values which are either null or 0 to 65534 bytes in length. Null is represented by a length of 65535. A char or binary which cannot be null can still have a length of zero e.g. an empty value . A program which must pad a value to a fixed length can typically add blanks to the end of a char and binary zeros to the end of a binary. Text and image data types have values which are either null or 0 to 2 gb bytes in length. Null is represented by a length of 1. Other nullable data types have a length of 0 if they are null.

This token is followed by a count of the number of following fields. Each field length is dependent on the token type. The total length of the token can be determined by walking the fields. A variable count token always has its third and fourth bits off.

The server generates a DONE token for every TRANSACT SQL statement. In the implementation of ODBC all DONES can be passed back to the user when executing ad hoc SQL statements. When handling results from stored procedures ODBC can pass back to the user DONES which are part of SQL select statements. Such can be primarily due to triggers but also can be due to the way stored procedures are used. It is very common for an application user to submit a simple update to the server and cause more than one SQL statement to be executed due to trigger on the target table. If all the DONES were passed back to the user such user would have to be aware of any trigger and or stored procedure that might get executed including all the statements contained in the triggers and stored procedures

The following two examples highlight token stream communication in accordance with an aspect of the present invention.

In this example a SQL statement is sent to the server and the results are sent to the client. The SQL statement is 

In this example a SQL command is sent to the server yet before all the data has been returned an interrupt or Attention Signal is sent to the server. The client reads and discards any data received between the time the interrupt was sent and the interrupt acknowledgment was received. The interrupt acknowledgment from the server is a bit set in the status field of the DONE token.

According to another aspect of the present invention a versioning scheme is provided that enables a handshake between client e.g. in and server e.g. in such that both down level as well as newer clients can communicate with down level and newer servers. Such a scheme accounts for chronological versioning of components e.g. release dates as well as software versioning e.g. protocol version and negotiates down to the common version between the client and the server side for an instant determination of the version of the TDS protocol. To initiate communication the client driver sends a login record to the server which can for example contain a 4 byte TDS version indicative of the most recent protocol that the client understands. Based in part on this login record the server makes an inference of the versions that the client understands and which at the same time is also understandable by the server. For example the 4 byte TDS version can be split into three distinct parts form hi byte to lo byte with each distinct part indicative of a defined structure for the syntax and semantics of the TDS protocol. In this example the first part is a major number or major version such as in the form 0xNN N being an integer e.g. 0x70 0x71 0x72 indicative of a particular version of the SQL. The second part can be an increment number indicative of the TDS change such as in the form of 0xNN N being an integer and the third part can be a minor number or minor version such as 0xNNNN N being an integer which can indicate a number associated with the Response Time Monitor RTM server. Accordingly a server that employs the version 0x72020002 has a major number of 0x72 an increment number of 0x02 and a minor number of 0x0002.

Typically by looking at the client s major number a server can infer that if the server s major number is less than or equal that of the client s major number a successful hand shake can be instigated. For example a client having a major version 0x71 and a minor version of 0x0004 attempts to initiate handshake with a server having a major version 0x71 and a minor version of 0x0002. Such server can find its largest major number that is less than or equal the major number sent by the client for which there is also a minor below or equal the minor received. In this example both the client and the server understand a TDS protocol having a major 0x71 and a minor version 0x0002.

For all products and for any given major and minor combination one recognized increment number can be assigned. Such increment number can be a number from 0x00 to 0xFF wherein F represent a 4 bit hexadecimal value with no relation to the increment of another major minor combination. During development the increment can be employed in order to stagger out TDS changes. The server typically recognizes more than one increment for the major minor combinations in development and is thus free to make the next round of TDS changes. Such changes however can be enabled under the next increment as the client will not face these changes until it has bumped up its increment.

Thus a joint check in is typically not required and connectivity breakage can be avoided. Once the client also bumps its increment and checks in the server can wait for a period and thereafter assumes that all users have obtained an updated version and then drop support for the old increment. Such process can for example support 255 rounds of TDS changes during any release. It is noted that the dropping of support is merely for the old increment and thus support for old shipped versions are not dropped. For example support can be dropped for old increments of a particular TDS SQL server while it is in development. As such a client never needs to support multiple increments as server changes can occur in advance of any client change. Thus back ground compatibility between the server and client can be improved when changes occur to versions of the TDS protocol being implemented in client and servers.

In another aspect of the enhanced TDS protocol of the present invention various new headers are provided including a new header as part of batch of SQL commands Transaction Manager Request and Remote Procedure Calls. Such new headers can be typically required for all incoming client requests and specifies two pieces of information namely a Transaction Descriptor and an outstanding request count.

As part of the Unified Transaction Framework infrastructure SQL Server according to the present invention can be enhanced to support more than one active transaction under a single session. Accordingly client drivers can create more than one transaction and freely associate requests sent to the server to any of the active transactions. Transactions can be described by transaction descriptors . Such descriptor is the one sent on this part of the protocol header to indicate which transaction a given request should run under.

One aspect of the enhanced TDS protocol of the present invention can improve consistency of behavior on the server side e.g. when the server commits transactions. Initially and as part of a header field the client sends the number of pending requests known to the client driver. In case the server already is done with processing of previous requests such number reported by the client helps synchronize and coordinate view of number of pending requests between the client and the server. Such can typically mitigate inconsistent server behavior such as from instances wherein buffer zones are waiting to be read by the client. For example a typical inconsistent behavior can arise when the client executes a query the server performs and the results sit in a network buffer waiting to be read by the client. If the results are such that they can fit entirely within the network buffers the server is considered finished and ready to accept new requests from the client. Nonetheless if the results do not entirely fit within the network buffers the server can still be considered tied up with previous transaction and not able to accept new requests. Thus depending upon a size of the buffer zone requests can fail or succeed leading to an unpredictable server behavior. The Multiple Active Result Sets MARS header of the enhanced protocol improves an ability to keep semantics constant regardless to the size of the results produced by a query.

In a related aspect according to the present invention query notification header is provided as part of the enhanced TDS protocol. At the time of establishing the query the server is asked to provide that the client with future updates related to the query. As such the requirement for periodically re asking the server of any changes to the initial query is mitigated. Accordingly the manner of sending such notifications e.g. channels for sending the notification as well as the set up for notification is established at the time of the query and does not require changes to be made on the client side. Moreover such feature allows creation of middle tier type caches that are transparent to the client.

The following illustrates an exemplary description of various data streams as well as exemplary headers employed in conjunction with a message exchange between client and server according to one particular aspect of the present invention 

Unknown length streams are used by some token less data streams. It is a stream of bytes. The number of bytes within the data stream is defined in the buffer header.

Variable length data streams consist of a stream of characters or a stream of bytes. Streams of bytes are defined as one of two possible types Generic Bytes and Complex Bytes . The two types are similar in that they both have a length rule and a data rule yet in the complex byte variable length data stream definition the length can be broken out into a separate rule at the message specific rule level for extra flexibility.

Variable length streams of characters can be defined by a length field followed by data itself. There are three types of variable length character streams each dependent on the size of the length field e.g. a BYTE USHORT or LONG . If the value of the length field is zero then no data follows the length field 

Similar to the variable length character stream variable length byte streams are defined by a length field followed by the data itself 

Messages that use variable length byte streams can use a well known format of the variable length byte stream itself e.g. BulkLoadData . In such cases variable length byte streams can be explicitly defined in a similar format to that shown above rather than use the generic B VARBYTE US VARBYTE or L VARBYTE format 

Some messages contain variable data types. The actual type of a given variable datatype can depend on type of data being sent within the message. For example the RPCRequest message contains the TYPE INFO and TYPE VARBYTE rules.

These two rules contain data of a type that can depend on actual type employed in value of the FIXEDLENTYPE or VARLENTYPE rules of the TYPE INFO rule.

Datatype dependant integers can be either a BYTELEN USHORTCHARBINLEN or LONGLEN in length. This length can depend on the TYPE INFO associated with the message. If the datatype i.e. FIXEDLENTYPE or VARLENTYPE rule of the TYPE INFO rule is of type TEXTTYPE NTEXTTYPE IMAGETYPE or SSVARIANTTYPE the integer length is LONGLEN. If the datatype is BIGCHARTYPE BIGVARCHARTYPE NCHARTYPE NVARCHARTYPE BIGBINARYTYPE or BIGVARBINARYTYPE the integer length is USHORTLEN. For all other datatypes the integer length is BYTELEN.

The datatype to be used in a datatype dependant byte streams is defined by the TYPE INFO rule associated with the message.

For variable length types the TYPE VARLEN value defines the length of the data that follows. As described above the TYPE INFO rule defines the type of TYPE VARINT i.e. BYTELEN USHORTLEN or LONGLEN .

For fixed length types the TYPE VARINT rule is not present. In these cases the number of bytes to be read can be determined by the TYPE INFO rule e.g. if INT2TYPE can be specified as the value for the FIXEDLENTYPE rule of the TYPE INFO rule 2 bytes should be read as INT2TYPE is always 2 bytes in length.

The data following this can be a stream of bytes or a NULL value. The CHARBIN NULL rule is used for BIGCHARTYPE BIGVARCHARTYPE NCHARTYPE NVARCHARTYPE BIGBINARYTYPE and BIGVARBINARYTYPE types and the GEN NULL rule for all other types 

Unlike fixed or variable byte stream formats Partially length prefixed bytes does not require the full data length to be specified before the actual data is streamed out. Thus it is ideal for those applications where the data length may not be known upfront e.g. xml serialization . The rule below describes such stream format 

Some message streams can be preceded by a variable number of headers as specified by the ALL HEADERS rule. List of headers that are applicable to the different types of messages are described in the following table.

It is noted that stream headers can be present in first packet in requests that spans more than one packet.

Contains information specifying that a notification is desired on the request and information for delivery of the notification.

As explained earlier such aspect of TDS protocol of the present invention contains information regarding transaction descriptor and number of outstanding requests in support of MARS.

As described above a query notification header is also provided as part of the enhanced TDS protocol. At the time of establishing the query the server is asked to provide that the client with future updates related to the query. As such the requirement for periodically re asking the server of any changes to the initial query is mitigated. Accordingly the manner of sending such notifications e.g. channels for sending the notification as well as set up for notification can be established at time of the query and does not require changes to be made on the client side. Moreover such feature allows creation of middle tier type caches that are transparent to the client. At the same time developers building the caching layers need not be the same as the developers who create the Structured Query Language SQL application. Thus the query notification feature can enable an infrastructure component that can provide for development of caching layers on top of SQL server applications. Any request sent to the server can be pre pended by a QN header indicating that subscriptions should be established for each statement executed. The payload of the header can contain 

In a related aspect of the present invention a TDS protocol is enhanced to include the notion of resetting a connection which cleans up server side state of the connection and allows client drivers to cache and reuse the connection. Accordingly such request to rest connection can be performed as part of the function for the next request that is sent under a connection.

As such and in conjunction with MARS feature a request can itself send a request that includes re set connection to the server and shortly thereafter send another request under the same connection. Such aspect of the present invention can also include the environment change notification ENVCHAGE which can be sent back to the client driver as soon as the reset operation completes without the need to wait for the request to execute. Such can reduce latency in the driver to determine success of a reset operation and enables other MARS requests to be submitted as soon as confirmation of reset success has been received. Moreover such feature enables by passing the client and perform particular activities and then notify the client as opposed to initially waiting for the client driver to provide instructions.

Referring now to another aspect of the present invention is illustrated as method wherein client can interrupt and cancel a current command without affecting transaction semantics. Such is performed by the client sending a non severe attention NSA signal at . Once the client sends an NSA the client continues to read at until it gets an attention acknowledgment sent by the server at . As such an NSA can cancel a specific request though it does not affect the state of the current transaction at . It is noted that an NSA can typically be sent to the server during the execution of the stored procedures for Sp cursor Sp cursorfetchnext Sp cursoroption and if invoked via IPC numbered on RPC requests. 

The following illustrates an exemplary description of the various data streams as well as and above identified headers in conjunction with a particular message exchange between the client and the server. It is noted that references to the terms Shiloh Yukon Sphinx MSSQL are exemplary SQL servers with TDS protocol.

Nullable values are returned using the INTNTYPE BITNTYPE FLTNTYPE MONEYNTYPE DATETIMNTYPE tokens which will use the length byte to specify the length of the value or GEN NULL as appropriate.

BIGVARCHRTYPE BIGVARBINTYPE and NVARCHARTYPE can represent two types each one is the regular type with a known maximum size range from 0 to 8000 and the other has unlimited max size known as varchar max varbinary max and nvarchar max which has a max size of 0xffff

UDT METADATA byte specifies type of metadata to be used defined by UDT implementation and defines semantics of byte stream that follows.

Note that the length for the parameters of type UDT BLOB or XML is specified as a ULONGLONG as with PLP values.

System defined UDTs are system types implemented using the CLR UDT infrastructure. In general they are sent on TDS as user CLR UDTs would be with the following exceptions 

User Type rule in the TYPE INFO rule sent as part of the COLMETADATA stream specifies the ID of the type. System UDTs have IDs between 128 and 255. In particular 

SCHEMA PRESENT specifies 0x01 if the type has an associated schema collection and DBNAME OWNING SCHEMA and XML SCHEMA COLLECTION are included in the stream or 0x00 otherwise.

DBNAME specifies the name of the database where the schema collection is defined. OWNING SCHEMA specifies the name of the relational schema containing the schema collection.

The TYPE INFO rule applies to several messages used to describe column information. For columns of fixed data length the type is all that is required to determine the data length. For columns of a variable length type TYPE VARLEN defines the length of the data contained within the column.

Describes the format of bulk loaded data with BULK INSERT. The format is a COLMETADATA token describing the data being sent followed by multiple ROW tokens ending with a DONE token. The stream is equivalent to that produced by the server if it were sending the same row set on output.

The Unicode stream contains the TSQL text within the batch. An example stream would be Select author id from Authors 

Request to perform transaction coordination through a Distributed Transaction Coordinator DTC implemented to the Microsoft DTC Interface Specification.

Used to send a complete row of computed data where the data format is provided by the ALTMETADATA token.

For Types 8 9 10 11 12 the ENVCHANGE event is returned only if the transaction lifetime is controlled by the user i.e. explicit transaction commands including transactions started by SET IMPLICIT XACT ON.

ENVCHANGE TYPE always produces empty 0x00 old and new values. It simply acknowledges completion of execution of a reset connection request.

Note LENGTH for ENVCHANGE type 15 is sent as 0x01 indicating only the length of the type token. Client drivers are responsible for reading the additional payload if type is 15.

If an error is produced within a result set the ERROR token is sent before the DONE token for the statement and such DONE token is sent with the error bit set.

Used to send the return value of a RPC to the client. When an RPC is executed the associated parameters may be defined as input or output or return parameters. This token is used to send a description of the return parameter to the client. This token is also used to describe the value returned by a User Defined Function UDF when executed as an RPC. This token is also sent back for EXEC statements within a batch for TDS 4.2. drivers.

The Tabular Data Stream consists of a variety of messages. Each message further consists of a set of bytes transmitted in a predefined order. This predefined order or grammar can be specified using Extended Backus Naur Form.

The collation rule is used to specify collation information for character data or metadata describing character data.

A SQL Server collation is one of a predefined set of sort orders. It is identified by having SortId being non zero. If this is the case the following table defines each SortId including character code page and comparison semantics 

For a windows collation SortId 0 the LCID bits correspond to a LocaleId as defined by the National Language Support NLS functions in Windows.

The GetLocaleInfo windows api can be used to retrieve information about the locale. In particular querying for the LOCALE IDEFAULTANSICODEPAGE retrieves the code page information for the given locale.

For either collation type the different comparison flags map to those defined as valid comparison flags for the CompareString windows api.

However for SQL collations with non unicode data the sort order id should be used to derive comparison information flags.

Referring now to a brief general description of a suitable computing environment on the client as well as the server side is illustrated wherein the various aspects of the present invention can be implemented. While the invention has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the invention can also be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like. As explained earlier the illustrated aspects of the invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules can be located in both local and remote memory storage devices. The exemplary includes a computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors. Dual microprocessors and other multi processor architectures also can be used as the processing unit .

The system bus may be any of several types of bus structure including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory may include read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM .

The computer further includes a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading from or writing to a CD ROM disk or to read from or write to other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of data data structures computer executable instructions etc. for the computer . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges and the like may also be used in the exemplary operating environment and further that any such media may contain computer executable instructions for performing the methods of the present invention.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . The operating system in the illustrated computer can be substantially any commercially available operating system.

A user can enter commands and information into the computer through a keyboard and a pointing device such as a mouse . Other input devices not shown can include a microphone a joystick a game pad a satellite dish a scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port a game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a workstation a server computer a router a peer device or other common network node and typically includes many or all of the elements described relative to the computer although only a memory storage device is illustrated in . The logical connections depicted in may include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks Intranets and the Internet.

When employed in a LAN networking environment the computer can be connected to the local network through a network interface or adapter . When utilized in a WAN networking environment the computer generally can include a modem and or is connected to a communications server on the LAN and or has other means for establishing communications over the wide area network such as the Internet. The modem which can be internal or external may be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be employed.

In accordance with the practices of persons skilled in the art of computer programming the present invention has been described with reference to acts and symbolic representations of operations that are performed by a computer such as the computer unless otherwise indicated. Such acts and operations are sometimes referred to as being computer executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processing unit of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation and the maintenance of data bits at memory locations in the memory system including the system memory hard drive floppy disks and CD ROM to thereby reconfigure or otherwise alter the computer system s operation as well as other processing of signals. The memory locations wherein such data bits are maintained are physical locations that have particular electrical magnetic or optical properties corresponding to the data bits.

Referring now to a client server system that employs a TDS protocol according to one aspect of the present invention is illustrated. The client s can be hardware and or software e.g. threads processes computing devices . The system also includes one or more server s . The server s can also be hardware and or software e.g. threads processes computing devices . For example such servers can house threads to perform transformations by employing the present invention. The client and the server can communicate in the form of data packets transmitted according to the present invention between two or more computer processes. As illustrated the system includes a communication framework that can facilitate communications between the client s and the server s . The client s is operationally connected to one or more client data store s that can store information local to the client s . Moreover client can access and update databases located on a server computer running a server process. In one aspect of the present invention the communication frame work can be the internet with the client process being a Web browser and the server process being a Web server. As such a typical client can be a general purpose computer such as a conventional personal computer having a central processing unit CPU system memory a modem or network card for connecting the personal computer to the Internet and a display as well as other components such as a keyboard mouse and the like. Likewise a typical server can be university or corporate mainframe computers or dedicated workstations and the like.

Although the invention has been shown and described with respect to certain illustrated aspects it will be appreciated that equivalent alterations and modifications will occur to others skilled in the art upon the reading and understanding of this specification and the annexed drawings. In particular regard to the various functions performed by the above described components assemblies devices circuits systems etc. the terms including a reference to a means used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary aspects of the invention. In this regard it will also be recognized that the invention includes a system as well as a computer readable medium having computer executable instructions for performing the acts and or events of the various methods of the invention. Furthermore to the extent that the terms includes including has having and variants thereof are used in either the detailed description or the claims these terms are intended to be inclusive in a manner similar to the term comprising. 

