---

title: Triggering job execution in application servers based on asynchronous messages sent by scheduling tasks
abstract: A method and a system for job scheduling in application servers. A common metadata of a job is deployed, the job being a deployable software component. An additional metadata of the job is further deployed. A scheduler task based on the additional metadata of the job is created, wherein the task is associated with a starting condition. The scheduler task is started at an occurrence of the starting condition, and, responsive to this an execution of an instance of the job is invoked asynchronously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09645845&OS=09645845&RS=09645845
owner: SAP SE
number: 09645845
owner_city: Walldorf
owner_country: DE
publication_date: 20080926
---
This application claims priority to U.S. Provisional Patent Application Ser. No. 60 975 562 titled Job scheduling for java application servers filed Sep. 27 2007 which is hereby incorporated by reference.

The field of invention relates generally to electronic data processing in multi tier computer systems and more particularly to scheduling job execution in application servers.

IT landscapes and business processes are becoming more complex on a daily basis. Automating these processes could simplify the IT architecture and reduce some of the errors and issues caused through human error. In addition asynchronous execution of background processes in computer systems has become increasingly important for many business applications. The execution of business processes may take hours or days for example assessing the risk of a complex financial portfolio performing billing and dunning operations for millions accounts etc. As state of the art computer systems and more specifically the application servers provided by various vendors are transaction oriented it becomes more difficult if not impossible to submit requests for execution of background processes or jobs and to monitor the progress of the execution.

Currently there is no universally agreed standard for asynchronous processing of jobs in Java Application Server Java AS . Java AS basic features are standardized in Java Enterprise Edition Java EE specification. The standard defines a very low level of abstraction for asynchronous processing on the application programming interface API level that is not sufficient for a complex business application in most cases. The current Java EE platform includes java.util.Timer and the Enterprise JavaBean EJB Timer Service. These solutions are not flexible enough to support the typically required range of scheduling jobs. Scheduling jobs scenarios that currently present a challenge include 

Some vendors Oracle Corp IBM Corp OpenSymphony Quartz open source have developed their own proprietary scheduling solutions. Some third party vendors Redwood Software have included Java EE in the set of their supported platforms. Despite this there is a growing need for an integrated solution that provides services to internal and external users for asynchronous execution of business processes. Further proprietary solutions do not consistently address important issues such as 

A method and a system for job scheduling in application servers are described. A common metadata of a job is deployed the job being a deployable software component. An additional metadata of the job is further deployed. A scheduler task based on the additional metadata of the job is created wherein the task is associated with a starting condition. The scheduler task is started at an occurrence of the starting condition and responsive to this an execution of an instance of the job is invoked asynchronously.

Embodiments of a method and a system for providing job scheduling in application servers are described.

This specification presents a solution that addresses not only the limitations of current programming models but also provides a solution for common operational issues. Embodiments consistent with the present teachings of the invention are built using standard Java EE technology. However it will be obvious for one skilled in the art that other technologies could be used for building alternative embodiments of the invention for example the Microsoft .Net application platform.

The present invention allows application developers to concentrate on developing business logic for their background processes by providing standardized support for background processing. Moreover this solution provides interoperability by using an open interface. Thus integration with an external scheduler allows co operative management of jobs in Java and non Java applications.

As used herein the term job means a process that includes system or business functionality and that is executed within a computer system. Jobs that provide functionality of business systems are executed by application servers. Application servers are provided by various vendors and their basic specifications correspond to established standards. For example SAP AG NetWeaver Java application server Java AS and IBM Corp WebSphere Java AS both corresponding to Java EE specification. The jobs are installed or deployed in the application servers as program components or beans e.g. Message Driven Beans MDB object according to one embodiment of the invention. Java application servers execute one or more instances of the deployed jobs.

The described embodiments of the invention provide implementation of a scheduler that can be used to schedule applications or jobs. The implementation is aligned with the standard Java AS installation. With this new capability customers and partners are able to develop applications to automate the business processes running on a Java AS. The jobs are implemented on the basis of message driven beans. The execution of jobs is handled by a container in the Java AS. An instance of a job is executed when it receives a Java Messaging Service JMS message sent by the scheduler. In a cluster environment the JMS also is responsible for load balancing it decides which job instance on which node gets the request to run. From a purely scheduling perspective a job is executed when a certain start condition such as a particular time of the day is fulfilled.

As used herein the term job definition means the blueprint representation of a job also called job metadata which is deployed on the application server in a scheduler. The job metadata includes a name for the job definition a description and a list or parameters which need to be specified when triggering the job. A job definition is not bound to any start conditions and thus is not a job that is scheduled and ready to run.

As used herein the term scheduler job means an instance of a deployed job definition corresponding to an instance of a deployed job that runs or has performed a certain amount of work at a particular point in time. It contains all the state information from the job such as the start time end time provided parameters return code and the job log. One job runs in one thread.

As used herein the term scheduler task or simply task means an item that contains the start conditions and parameter values for a job definition. A scheduler task instructs the scheduler which job to instantiate and run when to run the job and with which parameters. A scheduler task can trigger a single or multiple instances of a job. As an example consider a job definition for a payroll job which calculates the salary of all employees. An instance of the corresponding job is usually run once a month. The scheduler task instructs the scheduler to invoke an execution of an instance of the payroll job at the 20th of every month.

Application server accesses and persists relevant data on storage . In an alternative embodiment storage may not be a separate unit of system and the provided functionality could be part of application server . Archives deliver installable program components to application server . The installable program components including a number of deployment descriptors DDs and classes are packed in archives e.g. enterprise application archive EAR files.

Classes contain the program code defining the business functionality of the installable program component. Classes are developed as message driven bean MDB classes. MDBs are program components deployable in Entity JavaBean EJB container of Java AS according to Java Enterprise Edition Java EE standard. When deployed MDBs are started in response of receiving an addressed JMS message at the EJB container.

Deployment descriptors contain descriptive information of the deployable program components. In this document this representation is also referred to as metadata. EJB DD and application DD provide environment metadata that is required for deployment of MDBs in EJB container of Java AS . Job DD provides additional metadata required for scheduling the execution of the deployed MDBs. Alternatively instead of using deployment descriptors metadata could be provided with annotations included directly in classes according to Java EE specification.

The installation of applications on application server is performed by deployer module. Deployer reads archives and installs MDBs in EJB container . The installed MDBs could be one or more than one and are illustrated in as job A job B and job N . EJB container is a standard infrastructure module of Java AS according to Java EE standard specification. EJB container provides execution environment to the installed components and integration with other Java AS components through interfaces such as 

Deployer transfers the additional metadata contained in job DD in scheduler where it is deployed as job definitions for the MDBs. Scheduler is a Java AS infrastructure module to provide services for asynchronous scheduling the executions of the deployed MDBs. Scheduler is developed in accordance with Java EE specification and provides execution environment and container infrastructure similar to EJB container including JDBC JNDI JMS etc.

Besides the standard container infrastructure Scheduler includes scheduler runtime module in which the additional metadata for the deployed program components is received. The additional metadata of the MDBs is illustrated in as job A job B and job N representing job definitions for job A job B and job N respectively. Scheduler uses job A job B etc. to asynchronously invoke an execution of an instance of the corresponding MDBs deployed in EJB container . The execution is invoked with the help of JMS messages that are sent from scheduler runtime module to EJB container through JMS queue . JMS queue stores messages and asynchronously delivers them to EJB container where an execution of an instance of a corresponding MDB is triggered.

Scheduler runtime module sends messages to EJB container through JMS queue in accordance with a scheduled task list . For each deployed job definition in scheduler an arbitrary number of corresponding tasks in tasklist could be created. Tasks are associated to job definitions and for each task an execution schedule or start up events is specified. The execution schedule could be for example fixed start date and time or recurrent time event. Start up event could be any type of system event that could be used to trigger an execution of a program module recognized by a person skilled in the art. Scheduled tasks also provide input data required in execution of the instances of the corresponding jobs.

Scheduler further includes processor to execute logic for creating scheduling and triggering tasks in task list . Tasks may be created manually through graphical user interface GUI . GUI visualizes information and includes controls to create tasks associate tasks to job definitions define execution schedule for tasks specify input parameters for execution of instances of the corresponding jobs monitor execution of tasks respectively of jobs and access execution log files.

GUI further displays information and includes controls to create execution schedule for the deployed job definitions and for administrating the overall job execution process. illustrates an embodiment of a GUI of scheduler . The screen of the GUI is separated in three areas to provide nested scheduling information. Area is a menu to open particular information in the second area . Specifically for the first area is chosen Jobs menu item and the second area lists instances of jobs. This area provides basic information comprising job name status of the job instance return code instance start time and end time user who scheduled the job etc. The list could be refreshed filtered deleted scrolled etc. When a user chooses a job instance item from the list the third area displays detailed information for the corresponding job as illustrated in the figure including the job definition metadata parameters and all logged execution details.

Referring again to scheduler runtime module includes scheduler APIs to provide a plurality of runtime services to jobs during execution of their instances. Scheduler APIs contain job context module and intercept module . Job context module in communication with intercept module provides the running instances of jobs with access to functions . Intercept module instantiates execution context for a job in response to the invoking message sent from scheduler runtime module to the job.

As a runtime object an instance of a job accesses the scheduler runtime module through scheduler APIs . The scheduler APIs are accessible by the running instances of the deployed MDBs. For example an instance of the job could delete obsolete schedule data. Subsequently the job instance is authorized to call methods or functions from the job context module . Every running job instance has an execution job context instance provided by job context module . During runtime the job instance obtains a reference to its execution job context. Through the job context module an instance of a job could 

The job return code is an integer value output by the job and stored in the storage . The return code is used by the job to communicate information. In one embodiment the default value of the return code may be 0 to indicate that the job completed successfully. Further the job context module is security aware.

Intercept module further establish security context to allow execution if certain user privileges requirements are met and instantiate logging to write logs of job s execution to storage . The instances of jobs are executed assuming the privileges of a user that scheduled the corresponding tasks. This is independent of a currently logged on user or users. Child jobs inherit the privileges of their parent jobs. Particular system functionalities that require higher privileges could be inaccessible for the executed job instances.

Referring again to implemented jobs are invoked when a message is sent to them by scheduler runtime module . According to Java EE specification onMessage method is the standard business method of message driven beans. However in the presented embodiment of the invention jobs cannot implement the onMessage method because it is implemented by intercept module in order to establish execution context in job context . Therefore each job implements a single business onJob method. This implementation is illustrated with OnJob module within job A . The unit of work performed by the instances of the job is programmed within the onJob method.

At section a value of the message selector is specified. By using the ActivationConfig element of the MessageDriven annotation the job MDB class specifies the value of the message selector. In one embodiment the message is in the following format JobDefinition . may contain any valid message selector string literal composed of letters digits hyphens and underscores. has to be specified in the additional job definition deployment descriptor that is deployed in the scheduler. The value in the MDB class has to be identical to the one in the job definition deployment descriptor.

Deployed MDB objects are associated with a JMS queue. Instances of the jobs that are deployed as MDB objects could be invoked asynchronously by sending messages via the JMS queue. The job MDB class specifies javaxjms.Queue as the destination type at section by using ActivationConfig element of the MessageDriven annotation.

At section the single business method onJob of the MDB class is implemented. The job MDB inherits from an MDBJobImplementation base class that itself provides an implementation of the onMessage method. MDBJobImplementation base class is implemented in the scheduler and more specifically in intercept module as described above in reference to . In the implementation of the onJob method the unit of work that an instance of the job should perform is executed when the method receives a JMS message.

Referring again to at block deployment descriptor DD files of the job MDB are specified. In one embodiment DDs files are in extensible markup language XML format that provide metadata for the jobs. In alternative embodiment of the invention the metadata for the job may be provided with other means such as annotations or vendor specific deployment tools. There are different kinds of metadata depending on their purpose. As described here metadata is used for setting up the system and execution environment of the deployed message driven bean MDB . Metadata is also used for scheduling executions of instances of the deployed job MDBs.

In one embodiment the metadata for each job MDB is split in three DD files that are deployed on the application server. Two of the three DD files provide metadata to the EJB container. These two DD files may be named ejb j2ee engine.xml and application j2ee engine.xml and in this document are referenced as common deployment descriptors for message driven beans. The third file is a specific or additional DD file that provides metadata to the scheduler. This DD file may be named job definition.xml . The metadata of job definition.xml contain job definitions necessary for scheduling execution of instances of the deployed job MDBs. The three files are vendor specific and are not part of Java EE specification.

The deployment descriptor ejb j2ee engine.xml provides job MDB metadata to the EJB container that is used to setup general parameters of Java EE engine for the respective job MDB. is an example ejb j2ee engine.xml DD file according to an embodiment of the invention. The illustrated DD file specifies the destination name and connection factory name which the job MDB uses. The destination name is JobQueue and the connection factory name is JobQueueFactory . The example shows the ejb j2ee engine.xml deployment descriptor for the HelloWorld job whose MDB class is named HelloWorldBean . In an alternative embodiment of the invention rather than using this DD file an arbitrary JMS queue could be defined with annotations in the MDB class.

The deployment descriptor application j2ee engine.xml provides job MDB metadata to the EJB container that is used to setup the execution environment. It incorporates a reference to the scheduler APIs containing job context and MDBJobImplementation classes. shows an example of the application j2ee engine.xml DD file for the HelloWorld job created in an EJB project named HelloWorldProject .

The additional deployment descriptor job definition.xml provides additional metadata to the scheduler. The additional metadata contains job definitions of the deployed job MDBs. In the scheduler this metadata is used to schedule the execution of the instances of the jobs. The additional DD file specifies the name and description of a job and names and properties of the job parameters when the job requires input or output parameters. The additional DD file also specifies a retention period for the persisted job related data e.g. for the execution logs of the job instances. shows an example job definition.xml deployment descriptor file for the job HelloWorld that only logs a Hello World message and has no job parameters. The job definition name has to be identical with the value of the message selector specified in the job MDB class.

Referring again to the process continues with packaging a compiled version of the job MDB class together with all DD files in an Enterprise Application Archive EAR at block . Such an EAR is ready to be deployed on an application server by a deployer. The deployer is a special infrastructure or a module in the applications server. At block the class and the first two common DDs are deployed in EJB container of the Java AS. The additional job definition.xml DD is deployed in scheduler at block . Deploying the metadata means reading it by EJB container and by scheduler respectively. The deployment is usually executed as a single operation where EJB container and scheduler receive the pertinent data.

At block a scheduler task is created in the scheduler. The task is associated with a deployed job definition additional metadata for a job MDB . The task may be created manually by a program or from a predefined template. The scheduler task is used to invoke execution of one or more instances of the corresponding job. At block input parameters for the corresponding job are specified in the scheduler task. These parameters are required during the execution of the instances of the corresponding job.

The number and the type of the parameters are predefined by the job definition as described earlier. Whether parameters will be required depend on the business logic of the job. For example instead of coding the message Hello World in the job MDB class as shown in a parameter of type string could be defined in job definition DD. Thus the message that is logged will be specified when a scheduler task is created for that job.

At block a start condition for the created scheduler task is defined. The scheduler task starts every time the specified start condition is fulfilled. The task triggers or invokes an execution of an instance of the corresponding job and provides the input parameters.

In the scheduler a task could be scheduled to start when a particular time comes according to an embodiment of the invention. There are several possible types of time based start conditions that could be specified. One possibility is to start the task once or periodically at a particular time. This type of time based start conditions is called recurrent execution where the task is started once at a particular date and time and then starts recurrently at specified regular intervals for predefined period or number of times. To start the task only once is a special case where the task has a single iteration.

Another possible type of time based start condition is known as a cron execution. In this case the task starts once or periodically on a day that is relative to the start or end of month or week. The cron start condition defines the minute the hour the day of week and or month and the year when the task starts. The task starts once at the specified time. Further the task starts at the specified intervals. The task can be set to start one or more times within a predefined period at regular intervals. The table below provides examples of the various time based start conditions could be used to schedule tasks 

At block the process of continues in . is a flowchart of a second part of a process to schedule invoke asynchronously and monitor an execution of an instance of a job according to an embodiment of the invention. The second part of the process starts at block and at block scheduler checks whether the starting condition has occurred.

At block scheduler sends a JMS message to EJB container to invoke an execution of an instance of the job. More specifically the message is sent by scheduler runtime service as described above in reference to . At block the scheduler intercepts the issued message. In Java EE specification EJB container provides OnMessage method to the MDB. MDBs implement onMessage method in order to execute the intended business functionality. In one embodiment onMessage method is implemented in the scheduler. An EJB listener registers the message and onMessage method is triggered in the scheduler. In this way the scheduler intercepts the message that is routed to the job MDB through the JMS queue. The job MDB implements an additional method onJob in order to execute the intended business logic in response to the message.

One of the functions of onMessage method is to instantiate an execution context at block in the scheduler. The instantiated execution context provides a number of runtime services or functions to the instance of the job that is invoked for execution based on the message at . At block the instance of the job running in the EJB container executes one or more of the functions provided by the execution context instance on scheduler. The status of the execution is monitored at block . The process illustrated with flowchart ends at block . In case of periodic job execution blocks through repeat until the corresponding scheduler task expires or is suspended.

At block the execution of context functions refers to that is a flowchart of a process to execute a number of functions provided by the job context. The process of flowchart starts at block and ends at block . This process is executed by the running instance of the job as many times as required. The different functions that are provided by the execution context at the scheduler are denoted with blocks and .

A function available to the running instance of the job through the execution context allows reading data from the scheduler. This function is illustrated at block . This function or service allows reading of input parameters for the execution of the instance of the job. The parameters are specified in the scheduler during job execution scheduling. Other kinds of information from the scheduler could also be read. For example an instruction for the job execution could be entered in the scheduler and referred by the business logic of the running instance of the job e.g. stop execution . In addition this function may be applied for prompting a user input.

At block the running instance of the job provides or sends data to the scheduler. For example this information could be an output parameter of the job specified in the job definition DD. Similar to this function are the functions illustrated at blocks and .

At block running instance of the job reports its status e.g. whether its unit of work is completed. Scheduler uses this information to report status of the scheduled job. The status of a scheduler job signifies the job condition at a certain point in the job s life cycle. A job can be only in one status at a time. According to the presented embodiment of the invention a job can be in any of the six job statuses outlined in the table below 

At block running instance of the job instantiate a logging context and stores all relevant execution information in a database or storage. The scheduler could use a standard logging framework to log messages on job level and on scheduler level. Logs at job level or job logs are logged in the database by every running instance of a job. The following rules apply for job logs 

Blocks and represent two functions oriented for managing child job executions. At block an instance of a child object is retrieved. This function is applied when a deployed job of a child job is instantiated by the running instance of the parent job. At block the execution of the running instance is paused until the execution of an instantiated child job is completed.

The execution context provides interaction between the running instances of the scheduling jobs and the scheduler. However in alternate embodiments the execution context may not be required. In such embodiments the jobs are scheduled and instantiated with JMS messages or other kinds of asynchronous triggering. Alternative status reporting and logging of the job execution to the scheduler could be used e.g. using vendor specific logging frameworks or APIs.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least embodiment of the invention. Thus the appearance of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

