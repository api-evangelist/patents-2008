---

title: Program product providing a configuration specification language having clone latch support
abstract: Methods, data processing systems, and program products supporting the insertion of clone latches within a digital design are disclosed. According to one method, a parent latch within the digital design is specified in an HDL statement in one of the HDL files representing a digital design. In addition, a clone latch is specified within the digital design utilizing an HDL clone latch declaration. An HDL attribute-value pair is associated with the HDL clone latch declaration to indicate a relationship between the clone latch and the parent latch according to which the clone latch is automatically set to a same value as the parent latch when the parent latch is set. Thereafter, when a configuration compiler receives one or more design intermediate files containing the clone latch declaration, the configuration compiler creates at least one data structure in a configuration database representing the clone latch and the relationship between the clone latch and the parent latch.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08028273&OS=08028273&RS=08028273
owner: International Business Machines Corporation
number: 08028273
owner_city: Armonk
owner_country: US
publication_date: 20080418
---
The present application is a continuation of U.S. patent application Ser. No. 10 651 186 filed on Aug. 28 2003 now U.S. Pat. No. 7 395 524 entitled Method System and Program Product Providing a Configuration Specification Language Having Clone Latch Support which is also related to co pending U.S. patent application Ser. No. 10 425 096 which is assigned to the assignee of the present application and incorporated herein by reference in its entirety.

The present invention relates in general to designing simulating and configuring digital devices modules and systems and in particular to methods and systems for computer aided design simulation and configuration of digital devices modules and systems described by a hardware description language HDL model.

In a typical digital design process verifying the logical correctness of a digital design and debugging the design if necessary are important steps of the design process performed prior to developing a circuit layout. Although it is certainly possible to test a digital design by actually building the digital design digital designs particularly those implemented by integrated circuitry are typically verified and debugged by simulating the digital design on a computer due in part to the time and expense required for integrated circuit fabrication.

In a typical automated design process a circuit designer enters into an electronic computer aided design ECAD system a high level description of the digital design to be simulated utilizing a hardware description language HDL such as VHDL thus producing a digital representation of the various circuit blocks and their interconnections. In the digital representation the overall circuit design is frequently divided into smaller parts hereinafter referred to as design entities which are individually designed often by different designers and then combined in a hierarchical manner to create an overall model. This hierarchical design technique is very useful in managing the enormous complexity of the overall design and facilitates error detection during simulation.

The ECAD system compiles the digital representation of the design into a simulation model having a format best suited for simulation. A simulator then exercises the simulation model to detect logical errors in the digital design.

A simulator is typically a software tool that operates on the simulation model by applying a list of input stimuli representing inputs of the digital system. The simulator generates a numerical representation of the response of the circuit to the input stimuli which response may then either be viewed on the display screen as a list of values or further interpreted often by a separate software program and presented on the display screen in graphical form. The simulator may be run either on a general purpose computer or on another piece of electronic apparatus specially designed for simulation. Simulators that run entirely in software on a general purpose computer are referred to as software simulators and simulators that run with the assistance of specially designed electronic apparatus are referred to as hardware simulators. 

As digital designs have become increasingly complex digital designs are commonly simulated at several levels of abstraction for example at functional logical and circuit levels. At the functional level system operation is described in terms of a sequence of transactions between registers adders memories and other functional units. Simulation at the functional level is utilized to verify the high level design of digital systems. At the logical level a digital system is described in terms of logic elements such as logic gates and flip flops. Simulation at the logical level is utilized to verify the correctness of the logic design. At the circuit level each logic gate is described in terms of its circuit components such as transistors impedances capacitances and other such devices. Simulation at the circuit level provides detailed information about voltage levels and switching speeds.

In order to verify the results of any given simulation run custom developed programs written in high level languages such as C or C referred to as a reference model are written to process input stimuli also referred to as test vectors to produce expected results of the simulation run. The test vector is then run against the simulation execution model by the simulator. The results of the simulation run are then compared to the results predicted by the reference model to detect discrepancies which are flagged as errors. Such a simulation check is known in the verification art as an end to end check.

In modern data processing systems especially large server class computer systems the number of latches that must be loaded to configure the system for operation or simulation is increasing dramatically. One reason for the increase in configuration latches is that many chips are being designed to support multiple different configurations and operating modes in order to improve manufacturer profit margins and simplify system design. For example memory controllers commonly require substantial configuration information to properly interface memory cards of different types sizes and operating frequencies.

A second reason for the increase in configuration latches is the ever increasing transistor budget within processors and other integrated circuit chips. Often the additional transistors available within the next generation of chips are devoted to replicated copies of existing functional units in order to improve fault tolerance and parallelism. However because transmission latency via intra chip wiring is not decreasing proportionally to the increase in the operating frequency of functional logic it is generally viewed as undesirable to centralize configuration latches for all similar functional units. Consequently even though all instances of a replicated functional unit are frequently identically configured each instance tends to be designed with its own copy of the configuration latches. Thus configuring an operating parameter having only a few valid values e.g. the ratio between the bus clock frequency and processor clock frequency may involve setting hundreds of configuration latches in a processor chip.

Conventionally configuration latches and their permitted range of values have been specified by error prone paper documentation that is tedious to create and maintain. Compounding the difficulty in maintaining accurate configuration documentation and the effort required to set configuration latches is the fact that different constituencies within a single company e.g. a functional simulation team a laboratory debug team and one or more customer firmware teams often separately develop configuration software from the configuration documentation. As the configuration software is separately developed by each constituency each team may introduce its own errors and employ its own terminology and naming conventions. Consequently the configuration software developed by the different teams is not compatible and cannot easily be shared between the different teams.

In addition to the foregoing shortcomings in the process of developing configuration code conventional configuration software is extremely tedious to code. In particular the vocabulary used to document the various configuration bits is often quite cumbersome. For example in at least some implementations configuration code must specify for each configuration latch bit a full latch name which may include fifty or more ASCII characters. In addition valid binary bit patterns for each group of configuration latches must be individually specified.

In view of the foregoing the present invention appreciates that it would be useful and desirable to provide an improved method of configuring a digital system described by an HDL model particularly one that permits configuration information to be specified in a logical manner with a reasonable amount of input and then shared among the various organizational constituencies involved in the design simulation and commercial implementation of the digital system.

In addition the present invention appreciates that it would be desirable to provide an improved method and system of configuring a digital system that permit modification to an existing digital design for example through the insertion of additional configuration latches without significant modification or addition to the existing configuration information.

Methods data processing systems and program products supporting the insertion of clone latches within a digital design are disclosed. According to one method a parent latch within the digital design is specified in an HDL statement in one of the HDL files representing a digital design. In addition a clone latch is specified within the digital design utilizing an HDL clone latch declaration. An HDL attribute value pair is associated with the HDL clone latch declaration to indicate a relationship between the clone latch and the parent latch according to which the clone latch is automatically set to a same value as the parent latch when the parent latch is set. Thereafter when a configuration compiler receives one or more design intermediate files containing the clone latch declaration the configuration compiler creates at least one data structure in a configuration database representing the clone latch and the relationship between the clone latch and the parent latch.

All objects features and advantages of the present invention will become apparent in the following detailed written description.

The present invention discloses a configuration specification language and associated methods systems and program products for configuring and controlling the setup of a digital system e.g. one or more integrated circuits or a simulation model thereof . In at least one embodiment configuration specifications for signals in the digital system are created in HDL code by the designer responsible for an associated design entity. Thus designers at the front end of the design process who are best able to specify the signal names and associated legal values are responsible for creating the configuration specification. The configuration specification is compiled at model build time together with the HDL describing the digital system to obtain a configuration database that can then be utilized by downstream organizational groups involved in the design simulation and hardware implementation processes.

With reference now to the figures and in particular with reference to there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized for example as a workstation server or mainframe computer.

As illustrated data processing system includes one or more processing nodes which if more than one processing node is implemented are interconnected by node interconnect . Processing nodes may each include one or more processors a local interconnect and a system memory that is accessed via a memory controller . Processors are preferably but not necessarily identical and may comprise a processor within the PowerPC line of processors available from International Business Machines IBM Corporation of Armonk N.Y. In addition to the registers instruction flow logic and execution units utilized to execute program instructions which are generally designated as processor core each of processors also includes an on chip cache hierarchy that is utilized to stage data to the associated processor core from system memories .

Each of processing nodes further includes a respective node controller coupled between local interconnect and node interconnect . Each node controller serves as a local agent for remote processing nodes by performing at least two functions. First each node controller snoops the associated local interconnect and facilitates the transmission of local communication transactions to remote processing nodes . Second each node controller snoops communication transactions on node interconnect and masters relevant communication transactions on the associated local interconnect . Communication on each local interconnect is controlled by an arbiter . Arbiters regulate access to local interconnects based on bus request signals generated by processors and compile coherency responses for snooped communication transactions on local interconnects .

Local interconnect is coupled via mezzanine bus bridge to a mezzanine bus . Mezzanine bus bridge provides both a low latency path through which processors may directly access devices among I O devices and storage devices that are mapped to bus memory and or I O address spaces and a high bandwidth path through which I O devices and storage devices may access system memory . I O devices may include for example a display device a keyboard a graphical pointer and serial and parallel ports for connection to external networks or attached devices. Storage devices may include for example optical or magnetic disks that provide non volatile storage for operating system middleware and application software. In the present embodiment such application software includes an ECAD system which can be utilized to develop verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.

Simulated digital circuit design models created utilizing ECAD system are comprised of at least one and usually many sub units referred to hereinafter as design entities. Referring now to there is illustrated a block diagram representation of an exemplary design entity which may be created utilizing ECAD system . Design entity is defined by a number of components an entity name entity ports and a representation of the function performed by design entity . Each design entity within a given model has a unique entity name not explicitly shown in that is declared in the HDL description of the design entity. Furthermore each design entity typically contains a number of signal interconnections known as ports to signals outside the design entity. These outside signals may be primary input outputs I Os of an overall design or signals connected to other design entities within an overall design.

Typically ports are categorized as belonging to one of three distinct types input ports output ports and bi directional ports. Design entity is depicted as having a number of input ports that convey signals into design entity . Input ports are connected to input signals . In addition design entity includes a number of output ports that convey signals out of design entity . Output ports are connected to a set of output signals . Bi directional ports are utilized to convey signals into and out of design entity . Bi directional ports are in turn connected to a set of bi directional signals . A design entity such as design entity need not contain ports of all three types and in the degenerate case contains no ports at all. To accomplish the connection of entity ports to external signals a mapping technique known as a port map is utilized. A port map not explicitly depicted in consists of a specified correspondence between entity port names and external signals to which the entity is connected. When building a simulation model ECAD software is utilized to connect external signals to appropriate ports of the entity according to a port map specification.

As further illustrated in design entity contains a body section that describes one or more functions performed by design entity . In the case of a digital design body section contains an interconnection of logic gates storage elements etc. in addition to instantiations of other entities. By instantiating an entity within another entity a hierarchical description of an overall design is achieved. For example a microprocessor may contain multiple instances of an identical functional unit. As such the microprocessor itself will often be modeled as a single entity. Within the microprocessor entity multiple instantiations of any duplicated functional entities will be present.

Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.

With reference now to there is illustrated a diagrammatic representation of an exemplary simulation model that may be employed by ECAD system to represent a digital design e.g. an integrated circuit chip or a computer system in a preferred embodiment of the present invention. For visual simplicity and clarity the ports and signals interconnecting the design entities within simulation model have not been explicitly shown.

Simulation model includes a number of hierarchically arranged design entities. As within any simulation model simulation model includes one and only one top level entity encompassing all other entities within simulation model . That is to say top level entity instantiates either directly or indirectly all descendant entities within the digital design. Specifically top level entity directly instantiates i.e. is the direct ancestor of two instances and of the same FiXed point execution Unit FXU entity and a single instance of a Floating Point Unit FPU entity . FXU entity instances having instantiation names FXU and FXU respectively in turn instantiate additional design entities including multiple instantiations of entity A having instantiation names A and A respectively.

Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name which must be unique among all descendants of the direct ancestor entity if any. For example top level entity has a description including an entity name i.e. the TOP preceding the colon and also includes an instantiation name i.e. the TOP following the colon . Within an entity description it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example single instances of entity B and entity C instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However this naming convention is not required by the present invention as shown by FPU entity i.e. the instantiation name is FPU while the entity name is FPU .

The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity provided that all entities instantiated whether singly or multiply have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.

Associated with each design entity instantiation is a so called instantiation identifier . The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top level entity instantiation name. For example the design instantiation identifier of instantiation of entity C within instantiation of FXU entity is TOP.FXU0.B.C . This instantiation identifier serves to uniquely identify each instantiation within a simulation model.

As discussed above a digital design whether realized utilizing physical integrated circuitry or as a software model such as simulation model typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies which employ stand alone configuration software created after a design is realized to load values into the configuration latches the present invention introduces a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design as illustrated in or in one or more external configuration files referenced by the one or more HDL files specifying the digital design as depicted in .

Referring now to there is depicted an exemplary HDL file in this case a VHDL file including embedded configuration statements in accordance with the present invention. In this example HDL file specifies entity A of simulation model and includes three sections of VHDL code namely a port list that specifies ports and signal declarations that specify the signals within body section and a design specification that specifies the logic and functionality of body section . Interspersed within these sections are conventional VHDL comments denoted by an initial double dash . In addition embedded within design specification are one or more configuration specification statements in accordance with the present invention which are collectively denoted by reference numerals and . As shown these configuration specification statements are written in a special comment form beginning with in order to permit a compiler to easily distinguish the configuration specification statements from the conventional HDL code and HDL comments. Configuration specification statements preferably employ a syntax that is insensitive to case and white space.

With reference now to there is illustrated an exemplary HDL file that includes a reference to an external configuration file containing one or more configuration specification statements in accordance with the present invention. As indicated by prime notation HDL file is identical to HDL file in all respects except that configuration specification statements are replaced with one or more and in this case only one configuration file reference statement referencing a separate configuration file containing configuration specification statements .

Configuration file reference statement like the embedded configuration specification statements illustrated in is identified as a configuration statement by the identifier . Configuration file reference statement includes the directive cfg file which instructs the compiler to locate a separate configuration file and the filename of the configuration file i.e. file00 . Configuration files such as configuration file preferably all employ a selected filename extension e.g. .cfg so that they can be easily located organized and managed within the file system employed by data processing system .

As discussed further below with reference to configuration specification statements whether embedded within an HDL file or collected in one or more configuration files are processed by a compiler together with the associated HDL files.

In accordance with a preferred embodiment of the present invention configuration specification statements such as configuration specification statements facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a Dial. A Dial s function is to map between an input value and one or more output values. In general such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently by virtue of their association with particular design entities which all have unique instantiation identifiers Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent many different types of Dials can be defined beginning with a Latch Dial or LDial .

Referring now to there is depicted a representation of an exemplary LDial . In this particular example LDial which has the name bus ratio is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.

As illustrated LDial like all Dials logically has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . That is mapping table specifies a one to one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches each output of LDial logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations each configuration latch is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .

At input LDial receives an enumerated input value i.e. a string among a set of legal values including 2 1 3 1 and 4 1 . The enumerated input value can be provided directly by software e.g. by a software simulator or service processor firmware or can be provided by the output of another Dial as discussed further below with respect to . For each enumerated input value the mapping table of LDial indicates a selected binary value i.e. 0 or 1 for each configuration latch .

With reference now to there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model of which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model of illustrates two properties of Dials namely replication and scope.

Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example in order to instantiate the six instances of LDials illustrated in the designer need only code two LDial configuration specification statements utilizing either of the two techniques illustrated in . That is the designer codes a first LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity A in order to automatically instantiate LDials and within entity A instantiations and respectively. The designer codes a second LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity FXU in order to automatically instantiate LDials and within FXU entity instantiations and respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values different instances of the same Dial can be set to generate different outputs by providing them different inputs.

The scope of a Dial is defined herein as the set of entities to which the Dial can refer in its specification. By convention the scope of a Dial comprises the design entity with which the Dial is associated i.e. the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated and any design entity contained within the associated design entity i.e. the associated design entity and its descendents . Thus a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated but can also specify configuration latches at any lower level of the design hierarchy within its scope. For example LDials and even though associated with FXU entity instantiations and respectively can specify configuration latches within entity C instantiations and respectively.

Referring now to there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of .

As shown simulation model of includes an LDial associated with top level design entity . LDial specifies the signal states of each signal sig which is determined by a respective configuration latch the signal states of each signal sig which is determined by a respective configuration latch the signal state of signal sig which is determined by configuration latch and the signal state of signal sig which is determined by configuration latch . Thus LDial configures the signal states of numerous different signals which are all instantiated at or below the hierarchy level of LDial which is the top level .

As discussed above with respect to LDial is instantiated within top level entity of simulation model by embedding within the HDL file of top level entity a configuration specification statement specifying LDial or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case an exemplary configuration specification statement for LDial is as follows 

The exemplary configuration specification statement given above begins with the keyword LDial which specifies that the type of Dial being declared is an LDial and the Dial name which in this case is bus ratio. Next the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above the signal identifier for each signal is specified hierarchically e.g. FXU.A.SIG for signal relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Several different syntaxes can be employed to specify the signal states. In the example given above signal states are specified in either binary format which specifies a binary constant preceded by the prefix 0b or in hexadecimal format which specifies a hexadecimal constant preceded by the prefix 0x . Although not shown signal states can also be specified in integer format in which case no prefix is employed. For ease of data entry the configuration specification language of ECAD system also preferably supports a concatenated syntax in which one constant value which is automatically extended with leading zeros is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax the mapping table of the configuration specification statement given above can be rewritten as 

With reference now to there is illustrated a diagrammatic representation of a special case of an LDial having a one bit output which is defined herein as a Switch. As shown a Switch has a single input a single 1 bit output that controls the setting of a configuration latch and a mapping table that maps each enumerated input value that may be received at input to a 1 bit output value driven on output .

Because Switches frequently comprise a significant majority of the Dials employed in a digital design it is preferable if the enumerated value sets for all Switches in a simulation model of a digital design are the same e.g. ON OFF . In a typical embodiment of a Switch the positive enumerated input value e.g. ON is mapped by mapping table to an output value of 0b1 and the negative enumerated input value e.g. OFF is mapped to an output value of 0b0. In order to facilitate use of logic of the opposite polarity a Negative Switch or NSwitch declaration is also preferably supported that reverses this default correspondence between input values and output values in mapping table .

The central advantage to defining a Switch primitive is a reduction in the amount of input that designers are required to enter. In particular to specify a comparable 1 bit LDial a designer would be required to enter a configuration specification statement of the form 

Referring now to there is depicted a diagrammatic representation of an Integer Dial IDial in accordance with a preferred embodiment of the present invention. Like an LDial an IDial directly specifies the value loaded into each of one or more configuration latches by indicating within mapping table a correspondence between each input value received at an input and an output value for each output . However unlike LDials which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables the legal input value set of an IDial includes all possible integer values within the bit size of output . Input integer values containing fewer bits than the bit size of output s are right justified and extended with zeros to fill all available bits. Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table mapping table simply indicates the manner in which the integer input value received at input is applied to the one or more outputs .

IDials are ideally suited for applications in which one or more multi bit registers must be initialized and the number of legal values includes most values of the register s . For example if a 4 bit configuration register comprising 4 configuration latches and an 11 bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial the designer would have to explicitly enumerate up to 2input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement 

IDials may also be utilized to specify the same value for multiple replicated configuration registers as depicted in . In the illustrated embodiment an IDial which can be described as an IDial splitter specifies the configuration of three sets of replicated configuration registers each comprising 15 configuration latches based upon a single 15 bit integer input value. An exemplary configuration specification statement for instantiating IDial may be given as follows 

Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials in many cases it would be inefficient and inconvenient to do so. In particular for hierarchical digital designs such as that illustrated in the use of LDials and or IDials alone would force many Dials to higher levels of the design hierarchy which from an organizational standpoint may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result proper configuration of the configuration latches would require not only significant organizational coordination between design groups but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.

In view of the foregoing the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower level Dials and control of the lower level Dials by one or more higher level Dials. The configuration specification language of the present invention terms a higher level Dial that controls one or more lower level Dials as a Control Dial CDial .

Referring now to there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial like all Dials preferably has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . Unlike LDials and IDials which directly specify configuration latches a CDial does not directly specify configuration latches. Instead a CDial controls one or more other Dials i.e. CDials and or LDials and or IDials logically coupled to CDial in an n way Dial tree in which each lower level Dial forms at least a portion of a branch that ultimately terminates in leaves of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.

In the exemplary embodiment given in CDial receives at input an enumerated input value i.e. a string among a set of legal values including A . . . N . If CDial or an LDial or IDial is a top level Dial i.e. there are no Dials above it in a Dial tree CDial receives the enumerated input value directly from software e.g. simulation software or firmware . Alternatively if CDial forms part of a branch of a dial tree then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input CDial specifies a selected enumerated value or bit value for each connected Dial e.g. Dials and in mapping table . The values in mapping table associated with each output are interpreted by ECAD system in accordance with the type of lower level Dial coupled to the output . That is values specified for LDials and CDials are interpreted as enumerated values while values specified for IDials are interpreted as integer values. With these values each of Dials and ultimately specifies either directly or indirectly the values for one or more configuration latches .

With reference now to there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top level CDial that controls multiple lower level LDials. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of and contains the same configuration latches and associated signals as simulation model of .

As shown simulation model of includes a top level CDial associated with top level design entity . Simulation model further includes four LDials and . LDial which is associated with entity instantiation A controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is a replication of LDial associated with entity instantiation A similarly controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is associated with top level entity controls the signal state of signal sig which is determined by configuration latch . Finally LDial which is associated with entity instantiation FPU controls the signal state of signal sig which is determined by configuration latch . Each of these four LDials is controlled by CDial associated with top level entity .

As discussed above with respect to CDial and each of the four LDials depicted in is instantiated within the associated design entity by embedding a configuration specification statement or a configuration file reference statement pointing to a configuration file containing a configuration specification statement within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in is given below 

By implementing a hierarchical Dial tree in this manner several advantages are realized. First the amount of software code that must be entered is reduced since the automatic replication of LDials within FXU entity instantiations and allows the code specifying LDials to be entered only once. Second the organizational boundaries of the design process are respected by allowing each designer or design team to specify the configuration of signals within the design entity for which he is responsible. Third coding of upper level Dials i.e. CDial is greatly simplified reducing the likelihood of errors. Thus for example the CDial and LDial collection specified immediately above performs the same function as the large LDial specified above with reference to but with much less complexity in any one Dial.

Many Dials for example Switches utilized to disable a particular design entity in the event an uncorrectable error is detected have a particular input value that the Dial should have in nearly all circumstances. For such Dials the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment a Default value is specified by including default value following the specification of a Dial and prior to the concluding semicolon. For example a default value for a CDial can be given as follows 

The use of default values for Dials is subject to a number of rules. First a default value may be specified for any type of Dial including LDials IDials including those with split outputs and CDials. Second if default values are specified for multiple Dials in a multiple level Dial tree only the highest level default value affecting each branch of the Dial tree is applied including that specified for the top level Dial and the remaining default values if any are ignored. Despite this rule it is nevertheless beneficial to specify default values for lower level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated as discussed above. In the event that the combination of default values specified for lower level Dials forming the branches of a Dial tree do not correspond to a legal output value set for a higher level Dial the compiler will flag an error. Third a default value is overridden when a Dial receives an input to actively set the Dial.

By specifying default values for Dials a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition as discussed further below use of default values assists in auditing which Dials have been actively set.

In addition to defining syntax for configuration specification statements specifying Dials the configuration specification language of the present invention supports at least two additional HDL semantic constructs comments and attribute specification statements. A comment which may have the form 

Attribute specification statements are statements that declare an attribute name and attribute value and associate the attribute name with a particular Dial name. For example an attribute specification statement may have the form 

In this example BusRatio.attribute declares that this statement is an attribute specification statement associating an attribute with a Dial having BusRatio as its Dial name myattribute is the name of the attribute and scom57 0 9 is a string that specifies the attribute value. Attributes support custom features and language extensions to the base configuration specification language.

Referring now to there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files which include configuration specification statements and or configuration file reference statements and optionally one or more configuration specification reference files . HDL compiler processes HDL file s and configuration specification file s if any beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file s describing a complete simulation model. As HDL compiler processes each HDL file HDL compiler creates markers in the design intermediate files produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.

Thereafter the design intermediate files in memory are processed by a configuration compiler and model build tool to complete the model build process. Model build tool processes design intermediate files into a simulation executable model that when executed models the logical functions of the digital design which may represent for example a portion of an integrated circuit an entire integrated circuit or module or a digital system including multiple integrated circuits or modules. Configuration compiler processes the configuration specification statements marked in design intermediate files and creates from those statements a configuration documentation file and a configuration database .

Configuration documentation file lists in human readable format information describing the Dials associated with the simulation model. The information includes the Dials names their mapping tables the structure of Dial trees if any instance information etc. In addition as noted above configuration documentation file includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a bottom up fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design simulation laboratory hardware evaluation and commercial hardware implementation of the digital design.

Configuration database contains a number of data structures pertaining to Dials. As described in detail below these data structures include Dial data structures describing Dial entities latch data structures and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design i.e. simulation executable model . In a preferred embodiment the configuration values can be specified in terms of either signal states or configuration latch values and the selection of which values are used is user selectable. Configuration database is accessed via Application Programming Interface API routines during simulation of the digital design utilizing simulation executable model and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment the APIs are designed so that only top level Dials i.e. LDials IDials or CDials without a CDial logically above them can be set and all Dial values can be read.

As described above the configuration specification language of the present invention advantageously permits the specification of the output values of LDials and IDials by reference to signal names e.g. sig . As noted above a key motivation for this feature is that designers tend to think in terms of configuring operative signals to particular signal states rather than configuring the associated configuration latches. In practice however a signal that a designer desires to configure to a particular state may not be directly connected to the output of an associated configuration latch. Instead a signal to be configured may be coupled to an associated configuration latch through one or more intermediate circuit elements such as buffers and inverters. Rather than burdening the designer with manually tracing back each configurable signal to an associated configuration latch and then determining an appropriate value for the configuration latch configuration compiler automatically traces back a specified signal to the first storage element i.e. configuration latch coupled to the signal and performs any necessary inversions of the designer specified signal state value to obtain the proper value to load into the configuration latch.

With reference now to there is illustrated a portion of a digital design including an LDial that controls the states of a plurality of signals within the digital design. When configuration compiler performs a traceback of signal no inversion of the designer specified signal states is required because signal is directly connected to configuration latch . Accordingly configuration compiler stores into configuration database the designer specified values from the configuration specification statement of LDial as the values to be loaded into configuration latch . Traceback of signal to configuration latch similarly does not result in the inversion of any designer specified values from the configuration specification statement of LDial because the only intervening element between signal and configuration register is a non inverting buffer .

Configuration latches such as configuration latches and are frequently instantiated by designers through inclusion in an HDL file of an HDL statement referencing a latch primitive in an HDL design library. The latch entity inserted into the simulation executable model in response to such HDL library references may include inverters such as inverters which are not explicitly visible to the designer in the HDL code. The automatic traceback performed by configuration compiler nevertheless detects these inverters thus preventing possible configuration errors.

Accordingly when performing a traceback of signal configuration compiler automatically inverts the designer specified configuration value specified for signal before storing the configuration value for configuration latch in configuration database because of the presence of an inverter between signal and configuration latch . When configuration compiler performs traceback of signal however configuration compiler does not invert the designer specified signal state values despite the presence of inverters and buffer in the signal path because the logic is collectively non inverting. It should be noted that configuration compiler can accurately process both hidden inverters like inverter and explicitly declared inverters like inverter .

Referring now to there is depicted a high level logical flowchart of the traceback process implemented by configuration compiler for each signal name specified in a configuration specification statement. As shown the process begins at block and then proceeds to block which illustrate configuration compiler initializing an inversion count to zero and then locating the signal identified by the signal name specified in a configuration specification statement.

The process then enters a loop comprising blocks which collectively represent configuration compiler tracing back the specified signal to the first latch element in the signal path. Specifically as illustrated at blocks configuration compiler determines whether the next upstream circuit element in the signal path is a latch buffer or inverter . If the circuit element is a latch the process exits the loop and passes to block which is described below. If however the circuit element is a buffer the process passes to block which illustrates configuration compiler moving to the next upstream circuit element to be processed without incrementing the inversion count. If the circuit element is an inverter the process passes to blocks and which depicts incrementing the inversion count and then moving to the next upstream circuit element to be processed. In this manner configuration compiler traces back a specified signal to a configuration latch while determining a number of inversions of signal state implemented by the circuit elements in the path. As noted above if configuration compiler detects a circuit element other than a buffer or inverter in the signal path configuration compiler preferably flags an error as shown at block . The process thereafter terminates at block .

Following detection of a configuration latch at block configuration compiler determines whether the inversion count is odd or even. As shown at blocks if the inversion count is odd configuration compiler inverts the designer specified configuration values for the signal at block prior to inserting the values into configuration database . No inversion is performed prior to inserting the configuration values into configuration database if the inversion count is even. The process thereafter terminates at block .

As has been described the present invention provides a configuration specification language that permits a designer of a digital system to specify a configuration for the digital system utilizing configuration statements embedded in the HDL design files describing the digital system. The configuration statements logically instantiate within the digital design one or more Dials which provide configuration values for the digital design in response to particular inputs. The Dials like the design entities comprising the digital design may be hierarchically arranged. The configuration specification statements are compiled together with the HDL files describing the digital design to produce a configuration database that may be accessed to configure a simulation executable model or after appropriate transformations a physical realization of the digital design. The compilation of the configuration specification statements preferably supports a traceback process in which designer specified configuration values for a signal are inverted in response to detection of an odd number of inverters coupled between the signal and an associated configuration latch.

With reference again to recall that an exemplary configuration specification statement for LDial includes a parenthetical signal enumeration of the form 

In order to reduce the amount of input required to input the signal or Dial enumeration sections of configuration specification statements and to reduce the burden of code maintenance as new signal and Dial instances are added to the digital design an ECAD system in accordance with the present invention also supports a compact expression syntax for the signal or Dial enumeration sections of configuration specification statements. This syntax is referred to herein more specifically as compact signal expression when applied to the configuration specification statements of LDials and IDials and is referred to as compact Dial expression when referring to the configuration specification statements of CDials.

In a compact expression of a signal or Dial enumeration all instances of an entity within a selected scope for which a common configuration is desired can be enumerated with a single identifier. For example in if the designer wants a common configuration for all four instantiations of signal sig the designer could enumerate all four instantiations in the configuration specification statement of LDial with the single compact signal expression A .sig where the bracketed term is the name of the entity in which the signal of interest occurs. In compact expressions the default scope of the expression is implied as the scope of the design entity in this case top level entity with which the Dial is associated. The identifier A .sig thus specifies all four instantiations of signal sig within A entity instantiations within the default scope of top level entity .

The scope of the identifier in a compact expression can further be narrowed by explicitly enumerating selected levels of the design hierarchy. For example the compact expression FXU. A .sig refers only to signal sig instantiations and within FXU entity instantiation but does not encompass signal sig instantiations and within FXU entity instantiation

Of course when only a single instance of a signal or Dial is instantiated at higher levels of the design hierarchy the compact expression and the full expression will require approximately the same amount of input e.g. FPU.sig versus FPU .sig to identify signal sig . However it should be noted that if another FPU entity were later added to simulation model the compact expression of the identification would advantageously apply to any later added FPU entities within the scope of top level entity .

Utilizing compact expression the configuration specification statement for LDial can now be rewritten more compactly as follows 

Compact Dial expressions are constructed and parsed by the compiler in the same manner as compact signal expressions. For example the configuration specification statement for CDial of can be rewritten utilizing compact Dial expression as follows 

Referring now to there is depicted a high level logical flowchart of an exemplary method by which configuration compiler parses each signal or Dial identification within a configuration specification statement in accordance with the present invention. As described above each signal or Dial identification is constructed hierarchically from one or more fields separated by periods . . The last field specifies an instance name of a signal e.g. sig or Dial e.g. Bus Ratio and the preceding fields narrow the scope from the default scope which by convention is the scope of the design entity with which the Dial is associated.

As shown the process begins at block and then proceeds to block which illustrates configuration compiler determining whether the first or current field of the signal or Dial identification contains an entity identifier enclosed in brackets e.g. A that is whether the identification is a compact expression. If so the process passes to block which is described below. If not configuration compiler determines at block whether the identification is a full expression by determining whether the first or current field of the identification is the last field of the identification. If so the signal or Dial identification is a full expression and the process passes to block . If on the other hand the current field of the identification is not the last field configuration compiler narrows a current scope to the design entity instantiation identified in the current field of the identification as depicted at block . For example if configuration compiler were processing the identification FPU.SIG within the configuration specification statement of CDial of configuration compiler would narrow the scope from the default scope of top entity to FPU entity instantiation . If the entity instantiation indicated by the current field of the identification exists as shown at block the process returns to block after updating the current field to be the next field as shown at block . If however the entity instantiation specified by the current field does not exist within the current scope configuration compiler flags an error at block and terminates processing of the signal or Dial identification.

Referring again to block when configuration compiler detects that it has reached the last field of a full expression the process shown in passes from block to block . Block illustrates configuration compiler attempting to locate within the current scope the single signal or Dial instance having a name matching that specified in the last field of the signal or Dial identification. If configuration compiler determines at block that no matching instance is found within the current scope the process passes to block and configuration compiler flags an error. However if configuration compiler locates the matching signal or Dial instance then configuration compiler makes an entry in configuration database binding the signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed as shown at block . Thereafter processing of the signal or Dial identification terminates at block .

With reference now to block and following blocks the processing of a signal or Dial identification employing compact expression will now be described. Block depicts configuration compiler attempting to locate within each of one or more instances in the current scope of the entity indicated by the bracketed field each Dial or signal instance matching that specified in the signal or Dial identification. For example when processing the compact expression FXU. A .sig for simulation model of configuration compiler upon reaching the field A searches FXU for instantiations of entity A and upon finding entity instantiations and searches within each of these two entity instantiations to locate signals instantiations sig and . If configuration compiler determines at block that no matching signal or Dial instance is found within the current scope the process passes to block which depicts configuration compiler terminating processing of the signal or Dial identification after flagging an error. However if configuration compiler locates one or more matching signal or Dial instances then the process passes from block to block . Block illustrates configuration compiler making one or more entries in configuration database binding each matching signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed. Thereafter processing of the signal or Dial identification terminates at block .

Utilizing the compact expressions supported by the present invention the amount of code a designer must enter in a configuration specification statement can be advantageously reduced. The use of compact expressions not only reduces input requirements and the likelihood of input errors but also simplifies code maintenance through the automatic application of specified configuration parameters to later entered instances of signals and Dials falling within a selected scope.

As described above every Dial has a one to one mapping between each of its input values and a unique output value of the Dial. In other words each input value has a unique output value different than the output value for any other input value. For CDials and LDials the mapping table must explicitly enumerate each legal input value and its associated mapping.

The requirement that the input values must be explicitly enumerated in the mapping table limits the overall complexity of any given LDial or CDial. For example consider the case of an integrated circuit e.g. a memory controller containing 10 to 20 configuration registers each having between 5 and 20 legal values. In many cases these registers have mutual dependencies the value loaded in one register can affect the legal possibilities of one or more of the other registers. Ideally it would be convenient to specify values for all of the registers utilizing a Dial tree controlled by a single CDial. In this manner the configuration of all of the 10 to 20 registers could be controlled as a group.

Unfortunately given the assumptions set forth above the 10 to 20 registers collectively may have over 300 000 legal combinations of values. The specification of a CDial in such a case although theoretically possible is undesirable and practically infeasible. Moreover even if a looping construct could be employed to automate construction of the configuration specification statement of the CDial the configuration specification statement although informing simulation software which input values are legal would not inform users how to set a CDial of this size.

In recognition of the foregoing the configuration specification language of the present invention provides a Dial group construct. A Dial group is a collection of Dials among which the designer desires to create an association. The runtime APIs utilized to provide Dial input values observe this association by preventing the individual Dials within a Dial group from being set individually. In other words all Dials in a Dial group must be set at the same time so that individual Dials are not set independently without concern for the interactions between Dials. Because software enforces an observance of the grouping of the Dials forming a Dial group use of Dial groups also provides a mechanism by which a designer can warn the downstream user community that an unstated set of interdependencies exists between the Dials comprising the Dial group.

With reference now to there is illustrated a diagrammatic representation of a Dial group . A Dial group is defined by a group name e.g. GroupG and a Dial list listing one or more Dials or other Dial groups. Dial groups do not have any inputs outputs. The Dials listed within Dial list which are all top level Dials may be LDials CDials and or IDials.

One motivation for implementing Dial groups hierarchically is to coordinate configuration of groups of Dials spanning organizational boundaries. For example consider a digital system in which 30 Dials logically belong in a Dial group and 10 of the Dials are contained within a first design entity that is the responsibility of a first designer and 20 of the Dials are contained within a second design entity that is the responsibility of a second designer. Without a hierarchical Dial group a single Dial group explicitly listing all 30 Dials in its Dial list would have to be specified at a higher level of the design hierarchy encompassing both of the first and second design entities. This implementation would be inconvenient in that the designer or design team responsible for the higher level design entity would have to know all of the related Dials in the lower level design entities and specifically identify each of the 30 Dials in the Dial list of the Dial group.

An alternative hierarchical approach would entail creating a first Dial group containing the 10 Dials within the first design entity a second Dial group containing the 20 Dials within the second design entity and a third higher level Dial group that refers to the first and second Dial groups. Importantly the Dial list of the higher level Dial group must only refer to the two lower level Dial groups thus shielding designers responsible for higher levels of the design hierarchy from low level details. In addition code maintenance is reduced since changing which Dials belong to the two lower level Dial groups would not affect the Dial list of the upper level Dial group.

Dial groups are subject to a number of rules. First no Dial or Dial group may be listed in the Dial list of more than one Dial group. Second a Dial group must refer to at least one Dial or other Dial group in its Dial list . Third in its Dial list a Dial group can only refer to Dials or Dial groups within its scope which by convention and like the concept of scope as applied to Dials is that of its associated design entity i.e. the design entity itself and any lower level design entity within the design entity . Fourth each Dial referred to in a Dial list of a Dial group must be a top level Dial.

Referring now to there is depicted an exemplary simulation model illustrating the use of Dial groups. Exemplary simulation model includes a top level design entity having instantiation identifier TOP TOP . Within top level design entity two design entities and are instantiated which have entity names FBC and L respectively. FBC entity instantiation in turn instantiates a Dial instance having Dial name C a Z entity instantiation containing a Dial instance having Dial name B and two instantiations of entity X which are respectively named X0 and X1 . Each entity X instantiation contains two entity Y instantiations each further instantiating a Dial instance having Dial name A . L entity instantiation contains a Dial instance having Dial name D and two entity L instantiations each containing a Dial instance having Dial name E .

As shown FBC entity instantiation has an associated Dial group instance having a group name F . As indicated by arrows Dial group instance includes each of Dials instances and within FBC entity instantiation . L entity instantiation similarly has an associated Dial group instance that includes each of Dial instances and within L entity instantiation . Both of these Dial group instances in turn belong to a higher level Dial group instance having group name H which is associated with top level design entity .

Each Dial group instance is created by including within the HDL file of the associated design entity an appropriate configuration statement. For example exemplary syntax for configuration statements creating Dial groups F G and H are respectively given as follows 

In each configuration statement a Dial group is declared by the keyword GDial which is followed by string e.g. F representing the group name. Within the parenthesis following the group name the Dial list for the Dial group is specified. As indicated in the configuration statement for Dial group H the Dial list for a hierarchical Dial group specifies other Dial groups in the same manner as Dials. It should also be noted that the compact dial expression syntax discussed above can be employed in specifying Dials or Dial groups in the Dial list as indicated in the configuration statements for Dial groups F and G . In addition default values may be applied to a Dial group by specifying a default value for each top level Dial included in the Dial group.

Now that basic types of Dials syntax for their specification and the application and Dial groups have been described a description of an exemplary implementation of configuration database and its use will be provided. To promote understanding of the manner in which particular Dial instantiations or multiple instantiations of a Dial can be accessed in configuration database a nomenclature for Dials within configuration database will be described.

The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity i.e. the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.

Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model e.g. due to replication use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly in a preferred embodiment the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an extended Dial identifier for each Dial within the simulation model.

As an aside it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example conventional VHDL entity naming constructs permit two design entities to share the same entity name entity name. However VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance the entity name is equivalent to the VHDL library name concatenated by a period . to the entity name as declared in the entity declaration. Thus pre pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.

In a preferred embodiment an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields an instantiation identifier field a design entity name and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period . as follows 

In the extended Dial identifier the design entity field contains the entity name of the design entity in which the Dial is instantiated and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers proceeding from the top level entity of the simulation model to the direct ancestor design entity of the given Dial instance with adjacent instance identifiers separated by periods . . Because no design entity can include two Dials of the same name the instantiation identifier is unique for each and every instance of a Dial within the model.

The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier each design entity is in effect given a unique namespace for the Dials associated with that design entity i.e. Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is due to the uniqueness of instantiation identifiers Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However such a naming scheme does not associate Dials with a given design entity. In practice it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.

As noted above use of extended Dial identifiers permits the unique identification of a particular instantiation of a Dial and permits the re use of design entities within any arbitrary model without risk of Dial name collisions. For example referring again to Dial A entity instantiations and can be respectively uniquely identified by the following extended Dial identifiers 

With an understanding of a preferred nomenclature of Dials reference is now made to which is a diagrammatic representation of an exemplary format for a configuration database created by configuration compiler . In this exemplary embodiment configuration database includes at least four different types of data structures Dial definition data structures DDDS Dial instance data structures DIDS latch data structures and top level pointer array . Configuration database may optionally include additional data structures such as Dial pointer array latch pointer array instance pointer array and other data structures depicted in dashed line illustration which may alternatively be constructed in volatile memory when configuration database is loaded as described in the above referenced application. Generating these additional data structures only after configuration database is loaded into volatile memory advantageously promotes amore compact configuration database .

A respective Dial definition data structure DDDS is created within configuration database for each Dial or Dial group in the digital system. Preferably only one DDDS is created in configuration database regardless of the number of instantiations of the Dial or Dial group in the digital system. As discussed below information regarding particular instantiations of a Dial described in a DDDS is specified in separate DIDSs .

As shown each DDDS includes a type field denoting whether DDDS describes a Dial or Dial group and if a Dial the type of Dial. In one embodiment the value set for type field includes G for Dial group I for integer Dial IDial L for latch Dial LDial and C for control Dial CDial . DDDS further includes a name field which specifies the name of the Dial or Dial group described by DDDS . This field preferably contains the design entity name of the Dial or Dial group followed by a period . followed by the name of Dial or Dial group given in the configuration specification statement of the Dial or Dial group . The contents of name field correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.

DDDS also includes a mapping table that contains the mapping from the input of the given Dial to its output s if required. For LDials and CDials mapping table specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output mapping table is an empty data structure and is not used. In the case of an IDial with a split output mapping table specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields. If the configuration specification statement for the Dial has a default specified DDDS indicates the default value in default field if no default is specified default field is NULL or is omitted.

Finally DDDS may include an instance pointer array containing one or more instance pointers pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array facilitates access to multiple instances of a particular Dial or Dial group.

As further illustrated in configuration database contains a DIDS corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS contains a definition field containing a definition pointer pointing to the DDDS of the Dial for which the DIDS describes a particular instance. Definition pointer permits the Dial name Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.

DIDS further includes a parent field that in the case of an IDial CDial or LDial contains a parent pointer pointing to the DIDS of the higher level Dial instance if any having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group parent pointer points to the DIDS of the higher level Dial group if any that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS is a top level Dial and does not belong to any Dial group parent pointer in parent field is a NULL pointer. It should be noted that a Dial can be a top level Dial but still belong to a Dial group. In that case parent pointer is not NULL but rather points to the DIDS of the Dial group containing the top level Dial.

Thus parent fields of the DIDSs in configuration database collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described below the hierarchical information provided by parent fields advantageously enables a determination of the input value of any top level Dial given the configuration values of the configuration latches ultimately controlled by that top level Dial.

Instance name field of DIDS gives the fully qualified instance name of the Dial instance described by DIDS from the top level design entity of the digital design. For Dial instances associated with the top level entity instance name field preferably contains a NULL string.

Finally DIDS includes an output pointer array containing pointers pointing to data structures describing the lower level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically in the case of IDials and LDials output pointers refer to latch data structures corresponding to the configuration latches coupled to the Dial instance. For non split IDials the configuration latch entity referred to by output pointer receives the high order bit of the integer input value and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial output pointers refer to other DIDSs corresponding to the Dial instances controlled by the CDial. For Dial groups output pointers refer to the top level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS .

Configuration database further includes a respective latch data structure for each configuration latch in simulation executable model to which an output of an LDial or IDial is logically coupled. Each latch data structure includes a parent field containing a parent pointer to the DIDS of the LDial or IDial directly controlling the corresponding configuration latch. In addition latch data structure includes a latch name field specifying the hierarchical latch name relative to the entity containing the Dial instantiation identified by parent pointer . For example if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name a.b.c.d.latch1 latch name field will contain the string d.latch1 . Prepending contents of an instance name field of the DIDS identified by parent pointer to the contents of a latch name field thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .

Still referring to as noted above configuration database includes top level pointer array and optionally Dial pointer array and latch pointer array . Top level pointer array contains top level pointers that for each top level Dial and each top level Dial group points to an associated DIDS for the top level entity instance. Dial pointer array includes Dial pointers pointing to each DDDS in configuration database to permit indirect access to particular Dial instances through Dial and or entity names. Finally latch pointer array includes latch pointers pointing to each latch data structure within configuration database to permit easy access to all configuration latches.

Once a configuration database is constructed the contents of configuration database can be loaded into volatile memory such as system memory of data processing system of in order to appropriately configure a simulation model for simulation. In general data structures and can be loaded directly into system memory and may optionally be augmented with additional fields as described in the above referenced application. However as noted above if it is desirable for the non volatile image of configuration database to be compact it is helpful to generate additional data structures such as Dial pointer array latch pointer array and instance pointer arrays in the volatile configuration database image in system memory .

After an integrated circuit design has been simulated to detect and correct logical errors synthesis and timing are typically performed. During synthesis and timing integrated circuit blocks implementing the logical functions represented by design entities in the simulation model are developed and placed within the floor plan of the integrated circuit. Circuit timing is then measured to ensure that the timing constraints of the integrated circuit are satisfied. If a signal does not meet the desired timing constraints various techniques may be employed to improve signal timing. For example the signal may be rerouted the placement of circuit blocks coupled to the signal may be modified or if the signal is too heavily loaded additional copies of the latch driving the signal may be inserted in the integrated circuit to drive multiple instances of the signal. These additional latches are referred to herein as clone latches. The latch of which the clone latches are copies is referred to herein as the parent latch.

Referring now to there is illustrated an exemplary embodiment of an integrated circuit design in which clone latches are inserted in order to improve signal timing. As shown in in the exemplary integrated circuit design a latch drives a signal on signal lines to an integrated circuit block . The load created by fanout of signal lines from latch causes the signal to fail the timing constraints of integrated circuit block .

As shown in if sufficient timing slack exists on the input side of latch clone latches can be inserted into the integrated circuit design preferably physically close to parent latch in order to improve signal timing. That is rather than having latch the parent latch drive all of signal lines clone latches are inserted to drive signal lines . In this manner signal timing of all of signal lines is improved by reducing loading and the timing constraints of integrated circuit block can be satisfied.

Because clone latches such as those illustrated in are typically inserted late in the design process it is desirable for a designer to be able to define Dials and parent latches early in the design process without reference to clone latches and then to insert clone latches as needed later in the design process without having to alter existing Dial definitions. In order to accomplish this the designer initially creates the digital design including configuration latches without clone latches and creates a set of Dials that refer to only the non clone latches utilizing the methodology discussed above. Thereafter when the designer desires to insert a clone latch of a parent latch referenced by a Dial the designer employs a predefined HDL syntax in a HDL design file to specify a new latch as a clone latch of the parent latch.

In a preferred embodiment this predefined syntax comprises a HDL declaration of the clone latch e.g. clone latch and its clone latch output signal e.g. signal and an HDL attribute declaration. The HDL attribute declaration which takes the general form of an attribute name and value string pair associated with either the clone latch or clone latch output signal identifies the clone latch or clone latch output signal as a clone of the parent latch or parent latch output signal identified by the value string. In the declaration of the clone latch output signal the designer need not explicitly specify a connection for the clone latch output signal because a subsequent synthesis tool such as model build tool will automatically make connections for the clone latch output signal that optimize signal loading.

In order to permit the control and monitoring of the clone latches thus inserted utilizing previously created Dials configuration compiler also updates configuration database to reflect the existence of the clone latches and their relationship to the respective parent latches. In accordance with the present invention configuration compiler can be implemented to perform the update to configuration database either with or without additional designer input.

In implementations in which additional designer input is utilized by configuration compiler to update configuration database the designer in addition to the entry of the HDL declarations of the clone latch and clone latch output signals discussed above enters an explicit configuration specification language statement declaring the clone latch. An exemplary configuration specification language syntax for declaring one or more clone latches within an HDL file of a design entity including the clone latch es is as follows 

As an example assume that a parent latch X has an output signal X SIGNAL. Further assume latch parent latch X is controlled along with another latch driving signal Y SIGNAL by an LDial having the following definition 

With reference now to there is depicted a exemplary embodiment of a latch data structure within configuration database that is enhanced in accordance with one embodiment of the present invention to support clone latches. As described above with reference to latch data structure includes parent field latch name field latch value field and latch set field . To support clone latches each latch data structure is augmented to include a clone field containing a clone pointer . If configuration compiler does not detect any clone latches of the latch corresponding to latch data structure then clone pointer is set to NULL. However if configuration compiler detects a configuration specification language declaration of one or more clone latches corresponding to a particular latch data structure then configuration compiler creates a singly linked list of clone latch data structures each corresponding to a respective one of the clone latches. In addition configuration compiler points the clone pointer of the latch data structure of the parent latch to the clone latch data structure heading the singly linked list.

As shown each clone latch data structure contains a latch name field latch value field and latch set field serving the same functions as the corresponding fields within latch data structure . Each clone latch data structure further includes a next clone field containing a next clone pointer identifying the next clone latch data structure if any in the singly linked list. Clone pointer and next clone pointers thus permit all clone latches of the parent latch corresponding to latch data structure to be easily set and read simply by traversing the singly linked list of clone latch data structures .

As modified to include enhanced latch data structures configuration database functions in the same manner as described in above referenced U.S. patent application Ser. No. 10 425 096 with some small additions to the processes for setting and reading Dials described with reference to A B and . In particular each time a Dial and each of its underlying configuration latches is set via an API call all of the clone latches of each affected parent latch are also set to the same value as the parent latch. That is when a latch data structure having a non NULL clone pointer is accessed to update latch value field and latch set field the singly linked list of clone latch data structures identified by clone pointer is traversed to set the latch value field and latch set field in each clone latch data structure to the same values as the corresponding fields in latch data structure . In this manner the digital design is ensured to have the same logical behavior whether or not clone latches are inserted.

In addition each time a Dial is read via an API call as described in the above referenced application for example with reference to the latch value fields of each of clone latch data structures are checked to verify that their value s match the value contained in latch value field of the latch data structure of the parent latch. If any of the values within the latch value field s of clone latch data structure s does not match the value within latch value filed of latch data structure an error is recorded in the result data structure as shown at block of and block of of the above referenced application.

As noted above configuration compiler can alternatively be designed to record clone latches within configuration database without requiring designer entry of any additional configuration specification language declarations. A high level logical flowchart of an exemplary process by which configuration compiler automatically creates clone latch data structures within configuration database is given in .

Referring now to the process begins at block following the creation of configuration database in accordance with the process described above with respect to . As described above each latch data structure within configuration database is augmented with a clone field .

The process then proceeds from block to block which illustrates configuration compiler scanning design intermediate files to detect another HDL clone latch declaration if any. As noted above an HDL clone latch declaration preferably takes the form of an HDL latch or signal declaration having an associated HDL attribute and value string pair identifying the declaration as a clone latch declaration. If configuration compiler does not locate another HDL clone latch declaration within design intermediate files then the process terminates at block .

If on the other hand configuration compiler locates another HDL clone latch declaration within design intermediate files configuration compiler determines by reference to configuration database whether or not the parent latch identified in the attribute s value string is referenced by a Dial. Configuration compiler can make this determination for example by examining the latch name field of each latch data structure referenced by latch pointer array . If the parent latch is not referenced by a Dial then configuration compiler continues scanning design intermediate files for a next HDL clone latch declaration as represented by the process returning to block . However if the parent latch identified in the HDL clone latch declaration is referenced by a Dial configuration compiler creates a clone latch data structure for the clone latch and updates clone field and next clone field as needed to create the singly linked list structure depicted in . Thereafter the process returns to block which has been described.

It should again be noted that that clone latch data structures created by configuration compiler within configuration database will also be present within any hardware configuration database created from configuration database for example utilizing the database transformation process illustrated in of the above referenced application. The hardware configuration database may then be utilized to read and set latches including clone latches within a hardware realization of a digital design according to the process hereinbefore described.

As described above the present invention provides an improved method system and program product supporting the insertion of clone latches in a digital design. In accordance with the present invention a designer inserts a clone latch within a digital design through the inclusion of a clone latch declaration within an HDL file. The clone latch declaration preferably includes an attribute and value string pair identifying a parent latch of the clone latch. A configuration compiler then adds a data structure representing the clone latch to a configuration database in response to either the HDL clone latch declaration or an additional configuration specification language clone latch declaration. The clone latch is thereafter set or read when a Dial referencing the parent latch is set or read by reference to the configuration database.

While the invention has been particularly shown as described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration constructs having different rules than the particular exemplary embodiments disclosed herein. In addition although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal bearing media which include without limitation non rewritable storage media e.g. CD ROM rewritable storage media e.g. a floppy diskette or hard disk drive and communication media such as digital and analog networks. It should be understood therefore that such signal bearing media when carrying or encoding computer readable instructions that direct the functions of the present invention represent alternative embodiments of the present invention.

