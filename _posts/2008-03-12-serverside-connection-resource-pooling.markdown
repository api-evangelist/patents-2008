---

title: Server-side connection resource pooling
abstract: A server side connection pool provides pooling of server connections. Thus, client side processes do not create groups of dedicated resources. Clients are provided the capability to communicate to a server side connection broker process to GET a pooled server connection comprising connection state plus a thread of execution for doing some work, whereby requesting the work can bypass the connection broker process and go directly to the assigned pooled connection. Once the client issues a RELEASE to release the pooled connection back to the pool, a completely different client process on potentially a different client middle tier machine can reuse the same pooled connection. The server-side connection pool can be logically partitioned into sub-pools that correspond to connection classes that typically correspond to respective applications. A client process can request a pooled connection having a particular state, where a stored procedure can be executed to generate such state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713186&OS=08713186&RS=08713186
owner: Oracle International Corporation
number: 08713186
owner_city: Redwood Shores
owner_country: US
publication_date: 20080312
---
This application claims benefit of priority to U.S. Provisional Patent Application No. 60 906 941 entitled Server Side Resource Pooling filed Mar. 13 2007 by Lakshminarayanan Chidambaran et al. the entire contents of each of which are hereby incorporated by reference as if fully set forth herein.

The present invention relates generally to data management and more specifically to techniques for server side connection resource pooling.

A multi tier system typically comprises one or more clients that are communicatively coupled to a server. Generally a server is a combination of integrated software components and an allocation of computational resources such as memory and processes for executing the integrated software components on a processor where the combination of the software and computational resources are dedicated to providing a particular type of function on behalf of clients of the server. An example of server is a database server which among other functions manages and governs access to a database.

In order for a client to interact with a server a server connection is established for the client. Through a server connection the client can issue a series of requests to the server e.g. requests for data such as queries.

For certain kinds of servers server connections can be expensive to create and tear down. To take an example a database server connection is a heavyweight resource that often is associated with a corresponding state e.g. for authentication SQL statements etc. on the database and often comprises a dedicated process thread of execution on the server side. Creating such a database server connection involves establishing a network transport connection from the client to the server machine often spawning an operating system process thread of execution doing multiple roundtrips for authentication and allocating some state associated with the connection. Tearing down such a connection involves disposing of the network transport connection and the associated state and the process thread of execution. Thus a server connection can be expensive to create and tear down. With a dedicated server model a thread of execution and server connection state resources are dedicated to each server connection and thus there is no sharing or persistence and the thread of execution and the server connection state are recreated from scratch for each connection.

A middle tier generally refers to the processing that takes place in an application server that sits between the user s machine and a server such as a database server. The middle tier server performs the business logic. Some middle tiers implement server connection pooling so that multiple middle tier threads can share already opened connections and serially reuse them without having to create and tear down one for each web request for example.

The foregoing scheme works when middle tiers are multi threaded. However there are common scenarios in which middle tiers use single threaded processes. For example PHP Hypertext Preprocessor is a very popular scripting language that is used in almost a third of the web domains and PHP applications typically run in single threaded web server environments and often must access database servers to read and store data. There are also common scenarios in which a very large number of middle tier systems are implemented with each middle tier system having small pools to the database. However there is no way to share server connections across the pools i.e. across the middle tier systems. In both of these scenarios each process holds private resources associated with the database server that are not serially reusable by other processes and therefore are often idle. Hence pooling from the middle tier does not work at all or does not work effectively enough.

Also note that the same scenario with reference to single threaded mid tier systems is also possible in traditional client server systems where a large number of separate client processes hold onto server connections but need to use them relatively infrequently. In such cases also pooling of such connections is desired but not possible without additional support. The present detailed description may refer to a mid tier process operating on a server connection but it should be understood as not being limited to processes belonging to middle tier application servers but also subsuming client server systems as well.

One workaround may involve tearing down and recreating server connections which is not a very viable alternative due to the significant overhead and resource usage involved for example in spawning a new thread of execution and recreating server connection state.

Another workaround could involve using a connection proxy to pool server connections among middle tier machines through which all client processes interact with the back end server for both requesting server connections as well as requesting server operations. Not only does such a middle tier architecture force an extra hop in all communications between the clients and the servers i.e. through the proxy but also often requires applications to be recoded to use the connection proxy s API Application Programming Interface rather than some standard API. Examples of such connection proxies include products such as SQL Relay that are used in PHP environments to alleviate some of the lack of server connection pooling.

Another workaround may involve the use of shared threads processes on the server where the threads of execution can be shared amongst different server connections but each server connection still has its distinct state in some shared memory accessible by all the threads. Moreover in such a model the dispatching process is always involved in the communications. Examples of such technologies include the Oracle Shared Server Database configuration with Oracle 11g.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

A server side connection pool is described where server connections and resources thereof are pooled and managed by a connection broker. Thus client side processes do not create islands of dedicated server connections. Rather clients simply connect to a connection broker and do not hold on to server connections when idle. When the clients need to do operations on the server they have the ability to communicate to the server side connection broker process to GET a server connection e.g. server connection state plus a thread of execution on demand for doing some work following which the work requests can bypass the connection broker process. When a client side process needs a server connection the client process issues a GET request to the server which assigns a temporarily dedicated server connection from the pool to the client. The client then requests performance of the required work on the temporarily dedicated server connection directly and then issues a RELEASE to release the server connection back to the pool. At this point a completely different client process on potentially a different client middle tier machine can reuse the same pooled server connection.

The connection broker may run on the same machine as the server. It may also run on a different machine which may or may not be the same machine as the middle tier. In either case the client application need not be aware of where the connection broker runs and interacts with the connection broker with the same set of APIs to GET and RELEASE connections. In one embodiment the client side APIs to access the server are transparently modified to interact with the connection broker and hence no changes are required to application code on the client to run against a system where the connection broker manages a pool of server connections.

The server side connection pool can be logically partitioned into sub pools that correspond to connection classes that typically correspond to respective applications. This ensures that clients belonging to different applications do not inadvertently share pooled server connections which might be associated with application specific connection state. This however allows for multiple client processes associated with a particular application even across machines running one or more instances of the application to specify their corresponding connection class in server connection GET requests in order to obtain a server connection with a desired state. Furthermore a client process can request a server connection having a particular state where a stored procedure can be executed to generate such state.

Optimizations include preserving the network transport connection from the client to the connection broker even after a RELEASE has been issued by the client. Creating the network transport connection from scratch and re authenticating the client is an expensive operation. By preserving the network transport connection and by maintaining state on the broker associated with the network transport connection known as the network connection state the broker can remember the fact that a client has been authenticated once. Thus subsequent GET requests from the client need not present the credentials required for authenticating the client all over again. Also the process of authentication need not be carried out again because the client s credentials would have been verified the very first time a GET was issued by such a client. This enables clients that need to issue frequent work requests to the server to stay connected to the connection broker for an extended period of time and allows them to get a pooled server connection on demand without incurring the additional overheads described previously on every occasion. The resources associated with the network connection state typically a small amount of memory for example are quite minimal and can be easily assigned to each incoming network transport connection.

An optimization includes piggybacking the GET request on the real work request from the client. In this manner the client need not perform an explicit round trip just to issue a GET message to the broker.

A further optimization can leverage a certain common mode of operation in which a client issues multiple GET requests. GET requests originating from a certain network transport connection from a certain client are associated by the network connection state with a fixed connection class provided during the first GET request on that transport connection. The connection class usually corresponds to a certain application and clients repeatedly process requests for that fixed application for their lifetime. Hence all network transport connections opened to the broker from such clients carry GET requests for the same connection class. Moreover even if the client indeed does have a need to deal with multiple connection classes it can always be required to open a new transport connection to the broker for each new connection class thereby still maintaining the one to one mapping from a given transport network connection to connection class. In such an environment after the first GET request the broker can cache the supplied connection class in the network connection state associated with the network transport connection to the broker. Thereafter following a RELEASE the next call doing real work is assumed to imply a GET request so that the extra roundtrip or even an extra explicit message for the GET is avoided altogether and the client is assigned a pooled server connection based on the cached connection class in the network connection state associated with the network transport connection to the broker. In another embodiment a RELEASE can be piggybacked on the last call from the client. In yet another embodiment a RELEASE can be converted into a one way RPC so that the client side does not have to wait for the RELEASE action to be completed on the server and acknowledged before the client moves ahead.

In order to achieve the client s direct conversation with the pooled server connection thread for doing actual server operations in one embodiment the network transport connection associated at the connection broker is handed off to the pooled server connection s thread of execution. Such a hand off may require operating system support if the connection broker and the server connection thread reside in separate processes involving a separation of address spaces. On the other hand if they reside in the same address space the handoff of the network descriptor may require no special operating system support. In this manner the connection broker is not involved in subsequent conversations between the client and the pooled server connection thread. At this point the network transport connection descriptor is owned by the pooled server connection thread but may also exist at both the connection broker. However as long as the network transport connection is given to the pooled server connection the connection broker removes the corresponding descriptor from the list of network transport connection descriptors that it listens to for GET requests. Thus all subsequent requests are only handled by the pooled server connection s thread of execution.

In another embodiment when the pooled server connection thread receives a RELEASE message from the client it hands back the network transport descriptor to the connection broker at which point the connection broker adds the descriptor back to the list of descriptors that it listens on for GET requests. If the connection broker and the pooled server connection thread reside in separate processes with a separation of address spaces such a hand back can be physically carried out using operating system support. In such a case in one embodiment where the broker continues to retain the network transport descriptor after handoff this hand back can be optimized such that the hand back can be made virtual wherein the pooled server thread of execution supplies the connection broker with some identifier this identifier uniquely determining the network transport connection descriptor which then can be simply added by the broker to the list of descriptors to which it listens for GET requests.

Even though in the illustration above the handing off and handing back of the network descriptor was described in the context of the connection broker and server connection pool being co located on the same server machine it is worthwhile noting that it is possible to achieve the direct conversation between the client process and the server connection thread even otherwise. In another embodiment when the connection broker runs on the same machine as the mid tier there could be a handoff from the connection broker to the client process directly. And when the client process does a RELEASE it could perform a handback to the connection broker. In yet another embodiment when the connection broker runs on a separate machine altogether the client connection GET request can involve a network level redirect to an appropriate pooled server connection thread. Similarly a RELEASE would involve a redirect back from the pooled server connection back to the connection broker. This may involve extra communications. Thus it is important to note that the direct conversation between the client process and the pooled server connection can be instrumented by the broker regardless of where it runs.

Other embodiments include performing a lazy RELEASE in environments wherein the number of pooled server connections is higher than the number of client connections or where the contention for pooled server connections is low. In such cases the connection broker can defer the actual RELEASE and keep the client bound to a certain pooled server connection in the expectation that the same client will request a similar pooled server connection again. In such cases the client experiences a superior level of performance because it eliminates the GET RELEASE handshake altogether. In the eventuality that the pooled server connection bound to a client gets reassigned the client is notified of the change as a response on the first implicit or explicit GET request. This special response can then be used by the client to destroy certain cached state that may have had some tight coupling with the earlier pooled server that it was bound to. However if such a reassignment does not occur especially when there is low contention the client can enjoy the benefits of the cached state across multiple explicit implicit GET requests as if it had its own dedicated server connection. This requires that the very first request which serves as an implicit GET request from the client not have any dependence on the cached state whose validity is questionable at that point. Following the first request if the client does not receive a reassignment notification the cached state is assumed to be valid and the client and server can reuse such cached state for all subsequent requests.

Applications represent any computer software application or module that operates in conjunction with server . For non limiting examples applications may be online commerce applications running on an application server on multiple mid tier machines and or web servers running on multiple mid tier machines providing services to clients . Applications at times need access to a server such as a database server in order to serve the requests of one or more clients . Applications typically execute on at least one of the mid tier machines and multiple instances of a given application may execute on multiple mid tier machines . In this example operating environment applications utilize mid tier resources such as use of processes and or threads of execution provided by one or more mid tier machines . When applications need access to the functionality of server the applications need a connection to server to enable a server connection with server . Hence applications are capable of submitting one or more requests for a connection to server via a process running on a mid tier machine where in response to a connection request process communicates with connection broker . The number of applications running on mid tier machines and communicatively coupled to server may vary from implementation to implementation.

Multiple mid tier machines or middle tier machines are depicted in however the number of mid tier machines may vary from implementation to implementation. Thus some embodiments described herein may be applicable to configurations having a single mid tier machine some embodiments may be applicable to configurations having multiple mid tier machines and some embodiments may be applicable to either configurations having a single mid tier machine or multiple mid tier machines where the context in which each embodiment is described provides an indication of which types of configurations may apply. Each mid tier machine hosts one or more computer program applications and or servers generally applications for servicing client requests.

Each mid tier machine typically operates by running multiple concurrent processes to perform work for or associated with applications . The number of processes running on mid tier machines and the number of threads of execution associated with each process may vary from implementation to implementation. For example the mid tier machines may run applications using single threaded processes or may run applications using multi threaded processes . Recall that a challenge is associated with scenarios in which mid tier machines use single threaded processes or in embodiments where in spite of middle tier processes being multi threaded the number of middle tier systems is very large and therefore certain embodiments are especially beneficial to such a mid tier configuration.

Generally in response to a connection request from an application e.g. via a mid tier API a process running on a mid tier machine passes the connection request or reconstructs the connection request for transmission to the connection broker of server . Similarly with multi threaded mid tier processes in response to a connection request from an application a thread of execution associated with a process passes the connection request or reconstructs the connection request for transmission to the connection broker . Connections from processes and or threads generally processes running on mid tier machine to connection broker are generally depicted in as the solid lines connecting the processes to the connection broker .

Once the connection broker assigns a pooled server connection to a process further interactions between the process and the pooled server connection are direct in that these interactions are not via the connection broker . Hence there is no extra hop in communicating with the pooled server connection when in a steady state e.g. after a pooled server connection is assigned and the process is requesting server operations. Requests and other communications other than connection requests from processes running on mid tier machine to the pooled server connection are generally depicted in as the dashed lines connecting the processes to a respective pooled server connection .

As already mentioned a server is generally a combination of integrated software components and an allocation of computational resources such as memory and processes for executing the integrated software components on a processor where the combination of the software and computational resources are dedicated to providing a particular type of function on behalf of clients of the server. For example server performs work on behalf of applications generally for clients . Thus server may be any server based software that performs any type of work on behalf of clients in conjunction with some computational resources.

According to an embodiment the server of operating environment is a database server. However certain embodiments of the invention are not limited to use with a database server. As mentioned a database system typically comprises one or more clients that are communicatively coupled to a database server that is connected to a database where the clients of the database server may be applications as well as client end users. A database server is a combination of integrated software components and an allocation of computational resources such as memory and processes for executing the integrated software components on a processor for providing a particular type of function on behalf of clients of the database server. A database server governs and facilitates access to a database processing requests by applications to access the database through respective database server connections. Through database server connections the applications can issue a series of requests e.g. requests for operations on data and or metadata to the database server. For example clients of a database server interact with a database server by submitting commands that cause the database server to perform operations on data stored in a database. A database command that is sent from a database client to a database server contains an original statement of the database command where such statements and commands are also referred to generally herein as requests . For the database server to process the commands the commands must conform to a database language supported by the database server such as the Structured Query Language SQL .

Connection broker receives connection requests from a process of a mid tier machine . Connection broker processes connection requests and manages a pool of server connections referred to herein as pooled server connections . The manner in which connection broker processes server connection requests and manages pooled server connections is described in greater detail herein. In response to this request a network transport connection is established between the connection broker and the client process . As described herein the network transport connection may be handed off from the connection broker to the pooled server connection and vice versa. Thus the endpoint of network transport connection may switch between connection broker and server connection . Connection broker maintains information about the network transport connection within network connection state . This network connection state includes information such as the connection class and also whether client process has already been authenticated.

Referring to pooled server connections represent a unit of resource assigned to active mid tier processes on demand that are clients to server . Each pooled server connection comprises a a server connection state data structure with which server connection state is maintained at the server referred to herein as a server connection state see and b a thread of execution referred to herein as a thread . In response to a server connection request from a mid tier process connection broker assigns to the requesting process a pooled server connection . Because the pooled server connections are managed at server server connection pooling is achieved among multiple mid tier machines and also with single threaded processes . Furthermore applications communicate via the same client mid tier APIs that these applications would otherwise use with the API driver layer being changed to interact with the connection broker rather than with a mid tier connection pool manager as with some other approaches.

In the context of a database server an unpooled server connection generally comprises a a network transport connection to the database server machine e.g. a TCP IP operating system connection b server connection state in dedicated or shared memory e.g. SQL cache Java object cache buffer cache etc. c a database security context associated with the corresponding server connection e.g. under which database user the connection resource will function d if a dedicated server configuration then a dedicated thread of execution for the server connection. The server connection state is bound to the corresponding server connection and may comprise for example authentication context SQL statements environmental variables e.g. what language is the client using global variables references to a procedural package e.g. a PL SQL package and the like.

In the absence of a server connection pool when a server connection resource is closed the corresponding server connection state is deleted any dedicated thread of execution is terminated and the network transport connection from the client is closed. On the other hand when a pooled server connection is released by a process not only is the actual authenticated network transport connection to the connection broker maintained if not otherwise instructed the server connection state is often maintained if not otherwise instructed and the pooled server connection along with the retained server connection state is returned to the server connection pool. For example when a pooled server connection is released by a process the corresponding thread places itself back into the connection pool and requests the connection broker to continue listening for more requests on the corresponding authenticated network transport connection.

The pool of server connections is able to be administered on the server side for example by a system administrator setting the minimum size the maximum size and the server connection timeout values for the pool and any sub pools. The timeout setting itself can be an inactivity timeout for which if a pooled server connection stays inactive and unassigned the pooled server connection is destroyed. There can be an additional timeout setting called as the maximum think time which is the maximum time for which a process can hold onto a pooled server connection after an implicit explicit GET without doing any useful work on it. If the think time expires the pooled server connection is reclaimed and may or may not be returned to the pool. The middle tier process will receive an error on subsequent use in the eventuality that the max think time expired. This allows the administrator of the server connection pool which is a shared resource to guard the pool from runaway processes that may hang or become unresponsive after obtaining a server connection from the server connection pool. Thus the pool size may start at the minimum size and as the load increases automatically increase in size up to the maximum size. Once the maximum size is reached and all pooled server connections are assigned then further connection requests would have to wait for a pooled server connection to be released and therefore become available for use by another process . Also in periods of inactivity if pooled server connections are left unused their inactivity time expires and they get reclaimed and the server connection pool shrinks in size until it hits the minimum number of connections beyond which point it does not shrink anymore. In this manner in a limited resource system the server connections are effectively throttled within the parameters set by the administrator.

According to an embodiment the connection broker manages a single pool of server connections . Alternatively according to an embodiment the capability is provided for an administrator to name pools of server connections for example to dedicate a pool to a high priority application. A pool of server connections may serve multiple applications .

According to an embodiment the pool of server connection is logically partitioned e.g. per application into sub pools of server connections . Each sub pool of server connections could be administered and tuned similarly to the pool of server connections e.g. by a system administrator setting the minimum size the maximum size and the server connection timeout values for the each sub pool. Each sub pool could be used to serve only a corresponding application rather than multiple applications. Therefore according to one embodiment connection classes are used to identify a certain class of pooled server connections. According to an embodiment a connection class is associated with the network transport connection e.g. a TCP operating system connection in a data structure maintained by the connection broker known as the network connection state for as long as the authenticated network transport connection is maintained between a mid tier machine and the server for the connection class.

When a connection class is specified in a server connection request the connection class implicitly identifies a corresponding sub pool of server connections from which server connections associated with that connection class are assigned. For example a certain connection class may correspond to a sub pool of server connections for a certain application from applications and all instances of the application running on any number of mid tier machines . It is noteworthy that sharing of server connections associated with a given connection class could include sharing of server connections across mid tier machines .

Client processes working on behalf of stateless applications i.e. applications that do not depend on server connection state belonging to a particular server connection as long as they have been operated on only by that application itself can share a connection class sub pool of server connections . Furthermore server connections from a sub pool could be aged out e.g. using an LRU least recently used process so that some server connections from that sub pool could be used by another sub pool and therefore by another connection class.

According to an embodiment if a server connection request indicates that a new i.e. a connection without any pre existing server connection state connection is requested and there are no new server connections available in the pool of server connections then the connection broker can destroy the server connection state associated with a particular server connection and recreate a new initialization server connection state as such state is maintained within the corresponding server connection state data structure of the particular pooled server connection . In such a scenario even though the server connection state of the particular pooled server connection is destroyed and recreated the particular pooled server connection could still comprise the same thread from the particular pooled server connection s previous manifestation. This new server connection is assigned to the requesting process as if the server connection is entirely created from scratch even though the server connection is pooled and has been used previously.

An application may provide application code e.g. a PL SQL stored procedure for resetting a server connection state to a particular state including an initialization state. For example a developer of an application may have a better understanding of how its use of server connections affects the server connection state and therefore the application is in a better position to reset the server connection state from its dirtied state to a desired state in a computationally efficient manner. In such a scenario in which server connection state reset code is provided by a source external to the server the pooled server connection thread of server could execute the stored procedure on behalf of the application such as in response to a server connection request that identifies explicitly or implicitly the procedure and or a particular desired server connection state.

An application may tag a server connection state prior to a process placing the corresponding server connection back into the pool of server connections where the tag association indicates the type of state embodied in server connection state . For example if an application has been servicing client requests in the German language via a particular server connection the application associates with the server connection state of the particular server connection an indication that the environmental context of that particular server connection includes the German language context. A subsequent GET request can ask for a pooled server connection with a particular tag . The tag could also be tracked in the network connection state maintained at the connection broker .

The mid tier process typically needs to issue multiple units of GET do server work and RELEASE requests. Re establishing and tearing down the network connection for each GET RELEASE request can be very expensive. In one embodiment the network transport connection from the mid tier process to the connection broker is kept open even after a RELEASE has been issued by the process . Creating the network transport connection from scratch and re authenticating the mid tier process is an expensive operation for the connection broker to perform. By keeping the network transport connection cached and by associating state on the connection broker associated with the network transport connection known as the network connection state the connection broker can remember the fact that a mid tier process has been authenticated once. Thus subsequent GET requests from the mid tier process need not present the credentials required for authenticating the mid tier process all over again. Also the process of authentication need not be carried out again because the credentials presented by the mid tier process would have been verified the very first time a GET was issued by such a mid tier process . This enables the mid tier processes that need to issue frequent work requests to the server to stay connected to the connection broker for an extended period of time and allows them to get a pooled server connection on demand. The resources associated with the network connection state are quite minimal and can be easily assigned to each incoming network transport connection at the connection broker .

With a connection broker controlling and managing the server connections i.e. the pooled server connection an extra round trip communication between each application mid tier machine and the server may result e.g. embodied generally by the server connection request to the server . This extra round trip could affect system performance. This extra roundtrip can be eliminated by two techniques known as piggybacked GET and implicit GET .

According to the piggybacked GET technique the GET message is piggybacked with the message for the first work request to the server from the client. In this manner a separate round trip for the GET is avoided.

According to another embodiment an implicit GET technique is utilized in some scenarios in order to minimize the round trip communications between the mid tier and server and to minimize processing at server .

According to the piggybacked GET technique when a message to perform work on the server from a process associated with a particular application is sent to the server a server connection GET command is appended and the connection broker responds accordingly by assigning a pooled server connection to the process . Thus the process does not need to send a first message to request a server connection and a second message to request a service. Rather a single message serves both purposes explicitly requesting a server connection in the same message that is requesting the service.

Furthermore according to the implicit GET technique after a process associated with a particular application releases a pooled server connection back to the pool the first time that any process associated with the particular application communicates with the server on the same network transport connection e.g. a TCP connection is still maintained for a corresponding connection class while not dedicating a pooled server connection to the network transport connection a server connection GET command is implied. Again the connection broker responds accordingly by assigning a pooled server connection to the process and a single message serves both the purpose of implicitly requesting a server connection and the purpose of requesting a service rather than using two round trip communications with the server . In order to achieve this the connection broker associates a fixed connection class with the network connection state associated with the network transport connection to the broker from the process . This fixed connection class for the network transport connection is assigned when the process submits the first GET request on that network transport connection . All subsequent requests that the broker gets on that network transport connection are assumed to belong to the fixed connection class. At this point the connection broker can simply interpret the presence of a message on the network transport connection to mean that the process needs to be assigned a pooled server connection corresponding to the cached connection class in the associated network connection state . It can do this without having to peek into the incoming message and without having to parse an explicit GET request which saves processing cycles in the connection broker when compared to either a separate explicit GET request or even a piggybacked GET request.

In order to achieve the direct conversation from client with the pooled server connection thread for doing actual server operations in one embodiment the network transport connection associated at the connection broker is handed off to the pooled server connection thread . Such a hand off can be carried out using operating system support. In this manner the connection broker is not really involved in subsequent conversations between the client and the pooled server connection thread . At this point in some embodiments the network transport connection descriptor exists at both the connection broker as well as with the pooled server connection thread . In such cases as long as the network transport connection is given to the pooled server connection thread the connection broker removes the corresponding descriptor from the list of network transport connection descriptors that it listens to for GET requests. Thus all subsequent requests from client are only handled by the pooled server connection s thread .

When the pooled server connection thread receives a RELEASE message from the client it hands back the network transport descriptor to the connection broker at which point the connection broker adds the descriptor back to the list of descriptors that it listens on for GET requests. Such a hand back can be physically carried out using operating system support. However in another embodiment this act of handing back the network transport descriptor can also be optimized such that the hand back can be made virtual wherein the pooled server thread of execution supplies the connection broker with some identifier this identifier uniquely determines the network transport connection descriptor which was previously removed by the connection broker from the list of descriptors that it listens to for GET requests but for which the connection broker retained a copy. At this point that network transport connection descriptor can be simply added by the connection broker to the list of descriptors to which it listens for GET requests.

Similarly to a piggybacked GET a RELEASE can be piggybacked on the last call from the client. This can be accomplished by exposing a special parameter in the client side APIs that can specify whether a certain call to the server is the last call and will be immediately followed by a release operation. Finally a RELEASE can also be converted into a one way remote procedure call RPC where appropriate so that the client process does not have to wait for the RELEASE to be acknowledged before it can proceed.

Additionally the server side server connection pool can bind process to a particular pooled server connection even after a RELEASE has been issued by process so that the cost of repeatedly binding the process to the same pooled server connection on the server can be avoided when there is little to no contention for the pooled server connection.

As an example in the event that the number of pooled server connections are more than the number of mid tier processes requesting pooled server connections then following a RELEASE a pooled server connection is kept bound to a mid tier process . Thus the RELEASE is implemented lazily and is truly released only if there is any contention for pooled server connections .

A pooled server connection may maintain state of frequently used operations in a cache that resides in the pooled server connection state and shared across all client processes using the same connection class that the pooled server connection may bind to over its lifetime. Similarly a client process can maintain state of frequently used operations in a cache on the client process for the lifetime of the client process and shared across all pooled server connections that the client process may bind to over its lifetime. This measure allows for repeatedly issued operations to be executed faster both on the server and the client. All client processes working on behalf of a certain application typically tend to issue similar operations repeatedly. Such state can survive both in the pooled server and the client process across GET RELEASE operations.

However there is additional cached state that the client and pooled server connection could maintain that can survive as a long as a particular client process is bound to a particular pooled server connection . Such state is often maintained by dedicated server connections for the lifetime of the server connection. In the context of pooled server connections such state is destroyed on a RELEASE and reconstructed from scratch starting with a GET as requests are issued because it is unsafe to let such state persist across RELEASE operations. However the Lazy Release optimization also enables caching of such state both in the mid tier process and in the server connection state even after a RELEASE has been issued. E.g. in the context of databases database clients often tend to keep cursor state for database cursors that they operate on. Such state becomes invalid after a RELEASE because the client may not get the same pooled server connection. To guard against such a scenario cached state tightly bound to a particular pooled server connection needs to be cleaned up on a RELEASE.

When the RELEASE is lazy the APIs that issue server work could keep such additional state locally in process and in pooled server connection that have some tight coupling between the client and the currently assigned pooled server connection . Only when the special response indicating that the pooled server connection is reassigned is received by the process does such state need to be cleaned up by the client process . Hence in such a mode of operation where RELEASE is indeed lazy and more often than not when the pooled server connection does not get reassigned the cached state mentioned above in process could help improve performance and providing a view of a nearly dedicated server connection. Any such additional state cached in pooled server connection is reclaimed lazily when the association between the pooled server connection and client process is actually severed.

When applied to database servers in the scenario in which a database client is kept bound to a pooled server connection even after a RELEASE in low contention environments an additional optimization is to keep cursors open even after the RELEASE for it is likely that the process will remain bound to the same pooled server connection . The cursors are destroyed only when the process loses its binding to the pooled server connection if the process had RELEASED the pooled server connection and in the meantime some other process was assigned the same pooled server connection before the first process issues the next GET operation. Such a reassignment is indicated by a special response sent back on an explicit or an implicit GET request.

At block a first request for a server connection to a server is received at the server from a first client process associated with a first machine. For example connection broker of server receives a server connection request from a process of a first mid tier machine . The server connection request may identify a particular server connection class with which the request is associated which implicitly identifies a corresponding sub pool of a pool of pooled server connections. For example identifying a connection class in the server connection request identifies that the request came from a corresponding application and a corresponding sub pool of the pool of pooled server connections from which a server connection should be assigned to the process in response to the request. The server connection request may be an implicit GET whereby the server connection broker infers a server connection request from the first call from a process which identifies a connection class and which is stored away by the connection broker in a network connection state data structure associated with the network connection .

At block in response to the first request the connection broker selects a server connection from a pool of server connections wherein the server connection comprises a thread of execution and associated server connection state as described earlier. For example connection broker selects a pooled server connection from a pool or sub pool. In the scenario in which a connection class is identified in the server connection request the server identifies a sub pool of the pool of server connections that corresponds to the connection class from which a server connection is assigned to the process in response to the server connection request. For example the connection broker of server identifies a sub pool of the pool of pooled server connections that corresponds to the connection class and its associated application from which a pooled server connection is assigned to the process in response to the server connection request. The connection broker may identify a particular used pooled server connection that was previously released back into the pool and that has an appropriate associated server connection state that is requested by the requesting process on behalf of the application which may indicate a server connection with clean or initialized state. Alternatively the connection broker may identify an unused pooled server connection or a pooled server connection that was previously released back into the pool and the pooled server connection thread could modify the associated pooled server connection state to a state that is requested by the requesting process on behalf of the application where modifying the state could entail executing one or more stored procedures.

At block the selected server connection is associated with the first client process. For example connection broker of server assigns the selected pooled server connection to the requesting process and maintains a data structure in which assignments of pooled server connection to processes are tracked to reflect assignment of the particular pooled server connection to the particular requesting process . According to an embodiment connection broker maintains a data structure to track the connection state associated with each pooled server connection that the connection broker is managing. For example the connection broker uses this data structure to track whether or not the server connection state of respective pooled server connections are dirty i.e. in a state other than a clean or initialized state.

At block after the first client process releases the pooled server connection back to the pool a second server connection request for a connection to the server is received at the server from a second client process associated with a second machine wherein the second machine is a different machine than the first machine from which the first server connection request was received at block . For example connection broker of server receives a server connection request from a process of a second mid tier machine . As with the server connection request at block this second server connection request may identify a particular connection class with which the request is associated and or the server connection request may be an implicit GET.

At block in response to the second request the pooled server connection is associated with the second client process i.e. the same pooled server connection as selected at block is associated with the second client process. For example connection broker of server assigns the selected pooled server connection to the second requesting process and maintains the data structure in which assignments of pooled server connections are tracked to reflect assignment of the particular pooled server connection to the particular second requesting process .

Once the pooled server connection is assigned to and associated with the requesting second client process at block a request for one or more operations may be received at the server from the second client process via the network transport connection originally established to the connection broker . For example the pooled server connection that was associated with the second client process at block directly receives the operation request bypassing the connection broker of server . Further in response to the request for one or more operations the server thread corresponding to the pooled server connection that was assigned to the second client process performs the requested one or more operations and returns a result to the requesting second client process via the network transport connection to the server e.g. a TCP connection between a mid tier machine and the server . To achieve this bypass for the request response the network transport connection from the mid tier process to the connection broker is handed off to the pooled server connection for as long as the mid tier process is associated with the particular pooled server connection .

Also when the pooled server connection is RELEASED back to the server connection pool at that point the network transport connection needs to be handed back to the connection broker . This handback can be physical or can be virtual . In a physical handoff the network transport connection descriptor is handed back from the pooled server connection to the broker . In a virtual handback the underlying network transport connection descriptor is not handed back again but a brief handshake from the pooled connection to the broker tells the broker that the pooled connection is no longer associated with the network transport connection and that the broker should again listen to implicit explicit GET requests on that network transport connection .

Based on the method depicted in pooling of server connections across mid tier machines is achieved. Some mid tier machines may be more active than others and therefore in such situations clients that are not as active do not hold any server connections when idle. Furthermore which mid tier machines are most active may change dynamically over time. By pooling resources at the server across mid tiers pooled server connections are assigned across the mid tier machines dynamically.

At block a first request for a server connection to a server is received at the server connection broker from a client process. For example connection broker of server receives a server connection request from a process of a mid tier machine on behalf of an application . The server connection request may identify a particular connection class with which the request is associated which implicitly identifies a corresponding sub pool of a pool of pooled server connections . For example identifying a connection class in the request identifies that the request came from a corresponding application and a corresponding sub pool of the pool of pooled server connections from which a server connection should be assigned to the process in response to the request by the connection broker . The server connection request may be an implicit GET whereby the connection broker infers a server connection request from the first call from a process which identifies a connection class.

At block in response to the server connection request the connection broker selects a server connection from a pool of server connections wherein the server connection comprises a thread of execution and associated server connection state. For example connection broker selects a pooled server connection from a pool or sub pool. In the scenario in which a connection class is identified in the server connection request the connection broker identifies a sub pool of the pool of server connections that corresponds to the connection class from which a server connection is assigned to the process in response to the server connection request. For example the connection broker of server identifies a sub pool of the pool of pooled server connections that corresponds to the connection class and its associated application from which a pooled server connection is assigned to the process by the connection broker in response to the server connection request. The connection broker may identify a particular used pooled server connection that was previously released back into the pool and that has an appropriate associated server connection state that is requested by the requesting process on behalf of the application which may be a clean or initialized state. Alternatively the connection broker may identify an unused pooled server connection or a pooled server connection that was previously released back into the pool and the pooled server connection thread could modify the associated server connection state to a state that is requested by the requesting process on behalf of the application where modifying the state could entail executing one or more stored procedures.

At block the selected server connection is associated with the requesting client process. For example connection broker of server assigns the selected pooled server connection to the requesting process and maintains a data structure in which assignments of pooled server connections to processes are tracked to reflect assignment of the particular pooled server connection to the particular requesting process . According to an embodiment connection broker maintains a data structure to track the server connection state associated with each pooled server connection that the connection broker is managing. For example the connection broker uses this data structure to track whether or not the connection state of respective pooled server connections are dirty i.e. in a state other than a clean or initialized state.

At block a request for one or more server operations is received at the server from the client process via the network transport connection to the server wherein the request for one or more server operations does not pass through the connection broker. For example the pooled server connection that was associated with the client process at block directly receives a server operation request bypassing the connection broker of server .

At block in response to the request for one or more server operations the server thread corresponding to the pooled server connection that was assigned to the client process performs the requested one or more server operations and returns a result directly to the requesting client process via the network transport connection to the server e.g. a TCP connection between a mid tier machine and the server. As with the request for one or more server operations the result returned to the requesting client process bypasses the connection broker thereby minimizing the number of hops between the client mid tier and the back end server tier. This bypass for the request response the network transport connection from the mid tier process to the connection broker is handed off to the pooled server connection for as long as the mid tier process is associated with the particular pooled server connection . Any such hops means extra processing e.g. additional inter process communication calls and extra latencies in communication both of which are performance issues.

Based on the method depicted in pooling of resources across client processes is achieved. For a non limiting example PHP is a very popular scripting language that is used in almost a third of the web domains. However PHP applications typically run in single threaded process oriented web server environments. Thus the former lack of connection pooling in PHP based systems is a major concern with PHP users. However this concern is overcome using embodiments of the invention thereby enabling more scalable PHP systems. Furthermore no proxy server process is involved when in a steady state. Stated otherwise once the server connection has been assigned to the requesting process all communications between a connection GET and a connection RELEASE and possibly even after a RELEASE unless there is contention happen directly with the thread of execution associated with the server connection. In this manner an extra hop for the data transfers is avoided.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing data that causes a machine to operation in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

