---

title: Method for managing network filter based policies
abstract: A method and system are provided for adding, removing, and managing a plurality of network policy filters in a network device. Filters are installed in a framework and designated as active or disabled. Each filter has a priority. When a new filter is to be installed into the framework, it is compared to installed filters to determine if a conflict exists. If no conflict exists, the new filter is added as an active filter. If a conflict exists, a higher priority conflicting filter is added as active and a lower priority filter is added as inactive.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08689315&OS=08689315&RS=08689315
owner: Microsoft Corporation
number: 08689315
owner_city: Redmond
owner_country: US
publication_date: 20080731
---
This application is a division of U.S. application Ser. No. 10 456 433 filed Jun. 6 2003 entitled Method for Managing Network Filter Based Policies which application is incorporated herein by reference in its entirety.

The present application also contains subject matter related to that of U.S. Pat. No. 7 260 840 Multi Layer Based Method for Implementing Network Firewalls U.S. Ser. No. 10 456 766 Multi Layered Firewall Architecture Implemented in a Network Device and U.S. Pat. No. 7 308 711 A Method and Framework for Integrating a Plurality of Network Policies all filed on Jun. 6 2003 the disclosures of which are hereby expressly incorporated by reference.

This invention generally relates to computer systems and to computer networks. More particularly this invention relates to managing network filter based policies.

Computers implement various network policies to control network traffic and to protect a computer or other network device from malicious attacks perpetrated by other network devices such as theft of data denial of service DOS attacks and the like.

One type of policy used to protect network devices is implemented through a tool known as a firewall. The firewall protects individual users network devices and networks in general from malicious attacks while also adding the ability to control the exchange of data. The firewall implements the policy by examining network packets and determining based on the examination whether the packets should be permitted or conversely blocked from further traversing the network. Firewalls perform other functions such as logging information pertaining to packets for future inspection.

The firewall uses filters to implement the policy. Each filter includes filter parameters and an action. The filter parameters identify network packets that are subject to the policy and include information such as hardware addresses e.g. Media Access Control MAC addresses network addresses e.g. Internet Protocol IP addresses protocol type e.g. Transport Control Protocol TCP port numbers and the like. The action defines how packets with parameters that match the filter parameters should be treated. As a specific example the filter includes as its parameters a Uniform Resource Locator URL address e.g. http www.foo.com. The filter further associates the action of block i.e. drop the packet with that URL address. Whenever the firewall examines a packet and through that examination identifies the URL address http www.foo.com as embedded in the packet the firewall drops the packet thereby preventing it from traversing the network.

The firewall includes multiple filters to implement the policy and two or more filters may conflict. Two or more filters conflict when they apply to a common subset of network packets and designate different actions. For example one filter designates that a network packet should be permitted to traverse the network while a different filter designates that the same network packet should be blocked from network traversal. Where conflicting filters exist within a network device it becomes unpredictable how the overall system will respond to network traffic.

The invention is directed towards a method and system for adding a new filter defining a portion of a network policy into a set of installed filters in a framework. The framework includes an active filters and disabled filters. The active filters identify filters in the set of installed filters used to implement current network policy. The disabled filters identify filters in the set of installed filters that are not used to implement current network policy.

The new filter and the set of installed filters each include a set of filter conditions and a priority class. The filter conditions identify network packets that are subject to the policy defined in the filter. The priority class identifies priority of the filter according to the user or process responsible for the policy defined in the filter.

A firewall engine determines whether the new filter and at least one of the filters in the set of installed filters conflict. If the new filter conflicts with one of the installed filters the firewall engine determines whether the priority class of the new filter is lower than the priority class of the at least one installed filter. The firewall engine then installs the new filter into the set of installed filters.

In an embodiment of the invention the firewall engine uses the priority class of the new filter and the at least one of the installed filters to determine whether the new filter is added as a disabled filter or as an active filter. If the priority class of the new filter is lower than the priority class of the at least one installed filter the new filter is added as disabled. If the priority class of the new filter is higher than the priority class of the at least one of the installed filters the new filter is added asactive provided that other higher priority class conflicting filters do not exist and the at least one of the installed filters is added as disabled.

In another embodiment of the invention each filter includes a weight value that further identifies priority of the filter and that is used to identify filter conflicts in conjunction with the priority class. The weight value is automatically calculated from the set of the filter conditions. Each of the filter conditions is scaled to fit in a bit allocation within the weight value. Alternatively the weight value is an assigned value.

The invention is also directed to a method of removing filters from the set of the installed filters. After the filter is removed the firewall engine determines whether the removed filter was an active filter. If the removed filter was identified as active the firewall engine identifies overridden disabled filters that were disabled as conflicting with the removed filter. The overridden filters are then added as active which may in turn cause other filters to be disabled.

Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments which proceeds with reference to the accompanying figures.

A method of maintaining and resolving conflicts among network filter based policies is disclosed. The method is capable of identifying and resolving filter conflicts when new filters are installed in a network device.

The network filter based policies are defined by filters installed in a firewall framework. Although the framework is designed to implement firewall policy the framework is equally suitable for facilitating other filter based policies such as Internet Protocol Security IPSec Quality of Service QOS and the like.

The framework includes a kernel mode process comprising one or more kernel layers forming a protocol stack a kernel firewall engine and one or more callouts. The protocol stack includes an application layer a transport layer a network layer and link layer. The kernel firewall engine includes a layer Application Programming Interface API a set of installed filters and a callout API.

The user mode process includes a user firewall engine policy providers and one or more user layers. The user firewall engine also includes an instance of the kernel firewall engine referred to as a filter module that replicates the services of the kernel firewall engine in user mode and that also includes a set of installed filters.

The user and kernel layers each form a requesting layer capable of sending a classification request to the kernel or user firewall engine. The classification request includes a packet received by the requesting layer a packet context and a set of layer parameters associated with the requesting layer. The kernel or user firewall engine processes the request and returns firewall or other network policy defined by the set of installed filters.

Each of the set of installed filters includes a set of filter conditions an action a set of filter properties and possibly other data defining network policies. The filter conditions identify packets or other data subject to the network policy defined in the filter. The action is used to define the policy in the filter and usually identifies whether packets matching the filter should be permitted to traverse a network or conversely should be blocked. The filter properties are used to identify the relative priority of the filter with respect to other filters and to identify actions that may taken by lower priority conflicting filters.

The kernel firewall engine processes the classification request sent from the requesting layer by identifying one or more matching filters. The matching filters have filter conditions that match the layer parameters and packet context. Once the matching filters are identified they are applied in order of filter priority. Actions to be taken on the packets are returned to the requesting layer.

The policy providers obtain policy from any suitable source such as volatile or non volatile memory. The policy is a source of information for rendering a new filter including the set of filter conditions associated actions and filter properties. The user firewall engine adds the new filter to the set of installed filters in the kernel firewall engine via a management API.

The user firewall engine adds new filters into the installed filters removes filters from the installed filters and identifies and resolves filter conflicts. Filter conflicts are resolved by placing one filter of two conflicting filters in an active state and the other filter of two conflicting filters in a disabled state.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a personal computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media. As used herein the terms computer storage medium and computer storage media refer to media that are configured to store information and thus do not include communication media and transitory signals.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers hereto illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

In the description that follows the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computer unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.

The firewall architecture includes a user mode process and a kernel mode process . The user mode process and kernel mode process execute as part of an operating system in a network device. Those skilled in the art will appreciate that the user mode process and the kernel mode process of the operating system include additional components that for simplicity are not shown. Alternatively the firewall architecture is executed in whole or in part within a single operating system process or outside of the operating system as one or more program modules or application programs.

The kernel mode process includes kernel layers forming a network stack a kernel firewall engine and optional callouts . The network stack comprises a plurality of layers including a data stream layer a transport layer a network layer and a link layer . The layers in the network stack process inbound and outbound network packets. Outbound network packets are packets being transmitted from the network device implementing the firewall architecture onto a network. Inbound packets are packets received at the network device implementing the firewall architecture. As indicated by the respective arrows shown in inbound packets traverse the network stack from bottom to top and outbound packets traverse the network stack from top to bottom.

Network packets traverse and are processed by the network layers sequentially. In accordance with known techniques each layer in the network stack is capable of receiving packets from a previous layer or module processing the packet according to a specification or protocol and sending the processed packet to a next layer or module. The framework implemented according to the present invention further enables each layer in the network stack to maintain packet context pass the packet context to the next layer issue a classification request to the kernel firewall engine and take action on the packet according to firewall or other network policy.

The packet context is a data structure that follows the packet from layer to layer. Each layer maintains the context by adding into the context data structure a set of parameters that the layer is designed to process e.g. the information that the layer is designed to parse from inbound packets add to outbound packets or otherwise derive from an inbound or outbound packet. An exemplary data structure used for the packet context is described with reference to .

One of the operations carried out by the layers of the network stack is to invoke the kernel firewall engine by issuing the classification request. The classification request is a call by a layer in the network stack requesting that any filters that match the packet be identified and any associated action e.g. permit or block be returned to the layer. The layer issuing the classification request is referred to herein as a requesting layer. Each layer also takes the action on the packet that is returned by the kernel firewall engine .

The kernel firewall engine includes a layer API a set of installed filters and a callout API . The kernel firewall engine performs various functions including 1 storing the set of installed filters 2 receiving classification requests from the layers in the network stack 3 identifying one or more matching filters from the set of installed filters based on the classification request and 4 instructing the requesting layer of any action to take on the packet based on the matching filters.

Each filter of the set of installed filters includes a set of filter conditions an action filter properties and a filter Id. The filter conditions identify the network packets that are subject to the action and possibly other network policy identified in the filter. The action identifies applicable network policy such as permit or block. The filter properties include a priority class an override allowance and a weight. The filter properties are used to determine whether a filter is an active filter or a disabled filter an order that active filters are applied to matching packets and whether an active filter is applied to a matching packet. An exemplary form of the filters is described with reference to .

Associated with the set of installed filters is a disabled filter list and an active filter list . The active filter list identifies filters that are in an active status and that are used to implement network policy. The disabled filter list identifies filters that are in an inactive or disabled status and that are not presently being used to implement network policy but that may be later placed in an active status. Alternatively the invention does not maintain the active filter list and the disabled filter list and tracks the status of each filter using a different method for example within a field maintained within each filter or other equivalent method.

In an embodiment of the invention filters are assigned to a specific user layer or kernel mode layer . Each layer includes a separate set of installed filters a separate disabled filter list and a separate active filter list . Alternatively only a single set of installed filter and active and disabled filter lists are maintained.

The layer API provides an interface between the layers in the network stack and the kernel firewall engine . Through the layer API the requesting layer issues the classification request to the kernel firewall engine . The classification request includes the packet as received by requesting layer the packet context as received by the requesting layer and layer parameters. The layer parameters are packet parameters processed by e.g. added parsed or otherwise derived from the packet by the requesting layer. As a specific example source and destination Internet Protocol IP addresses are layer parameters sent by the network layer when implementing the IP protocol. Layer parameters may also include information beyond the packet parameters that are added to or parsed from the packet. As a specific example the layer parameters include a local address type. The local address type is determined by the IP layer and sent as part of the classification request. Local address types include unicast broadcast multicast anycast and the like. A specific implementation of the layer API is described with reference to .

Optionally the callouts are used to implement added functionality beyond the permit and block filter actions. A callout is executed when the kernel firewall engine identifies a matching filter for the packet that includes as the associated action a callout to one of the callout modules. The kernel firewall engine sends the classification request as issued by the requesting layer i.e. full packet layer parameters and packet context to the callout module along with an identification of the matching filter via the callout API . In an embodiment of the invention the firewall architecture includes a base set of callouts . Additional callouts like layers are added as needed thereby providing an extensible framework. A specific implementation of the callout API is described with reference to .

The user mode process includes the user firewall engine and one or more policy providers identified as PP PP and PP. The policy providers are processes that add network policy i.e. installed filters into the framework described herein. Any process is used to accomplish this task. The user firewall engine converts the policy into a new filter i.e. defines the policy in terms of the filter conditions the action the filter properties and adds the new filter to the set of installed filters and adds the filter to the active filter list or the disabled filter list.

The user firewall engine also performs filter arbitration and conflict resolution functions. When the policy provider provides new policy to the user mode firewall engine the user firewall engine determines whether the new filter resulting from the new policy conflicts with any of the installed filters . A conflict occurs when two or more filters 1 specify different actions 2 overlap 3 have different priority classes 4 the filter with the lower priority class has a higher weight value and 5 the action specified in the filter with the lower priority class is not specified as an override allowance in the higher priority filter. Filters overlap if they include a common set of filter conditions i.e. filter conditions within an equal value or ranges of values that intersect. The override allowance defines actions in lower priority filters that may override the filter. If a conflict exists the user firewall engine resolves the conflict.

The filter engine API forms an interface between the user mode firewall engine and the kernel firewall engine . The filter engine API provides a mechanism for the user firewall engine to add new filters into the set of installed filters remove filters from the set of installed filters and to examine installed filters so that filter conflicts can be detected and resolved.

A keying module API provides an interface between the user policy engine and keying module . The keying module API is used to signal the keying module of the need to establish an SA.

The user firewall engine also includes a filter module . The filter module is an instance of the kernel firewall engine in the user mode . The instance of the filter module in the user firewall engine permits the user firewall engine to replicate the services of the kernel firewall engine for one or more user layers . The user mode layers are added in the same way that kernel mode layers are created. Because the filter module is the user mode instance of the kernel firewall engine it will be understood that any functionality described herein for the kernel mode firewall engine also applies to the filter module . For example additional user mode layers are added or deleted from the system architecture and callouts may be created thereby providing added functionality to the user mode layers. Filters may be added or removed from the filter module . The user firewall engine also resolves filter conflicts for filters in the filter module .

Referring to the set of installed filters will now be described. Each filter has a plurality of fields including the filter Id the filter properties the action and the set of filter conditions . The filter Id provides a unique identification to the filter. The filter Id is used for example as a means for the kernel firewall engine to return matching filter information to the user firewall engine and the callouts . The filter Id is used by the kernel firewall engine to track which filter is assigned to which layer. The filter Id is also used as part of the disabled filter list and the active filter list to identify which filters are inactive and active respectively.

The filter properties include a priority class an override allowance and a weight . The priority class is a value that specifies the class of the user that added the filter via one of the policy providers . Examples of priority classes include user administrator firewall client and guest. The higher the priority class the higher the priority of the filter.

The override allowance identifies the actions specified in lower priority filters that are permitted to override the filter . Examples of override allowances include allow block log callout all actions or none. The default override allowance is none.

The weight is any unsigned value. The default size of the weight is 64 bits. The weight value in conjunction with the priority class determines the overall filter priority. The higher the value in the weight field the higher the filter priority. The weight is automatically calculated by the user firewall engine based on specificity of the filter conditions and possibly other criteria. Alternatively the weight is a user entered value. A user may also modify the weight field if it is automatically calculated by the user firewall engine .

The set of filter conditions determine whether a packet matches the filter . Each filter condition includes a type data and a layer Id field Id .

The type defines the length and number of variables included in the corresponding data field . The framework provides for predefined known variable types such as Byte Short Long 8 Bytes String Internet Protocol version 4 IPv4 Address Internet Protocol version 6 IPv6 Address IPv4 Address plus Mask IPv6 Address plus Mask and Address Range.

The data field includes data matching the type . For example if the type is IPv4 Address an acceptable value for the data field is a 32 bit number in range of 00.00.00.00 to 255.255.255.255 as expressed in dotted decimal notation. In some instances the type provides for multiple values in the data field . The Address Range IPv4 Address plus Mask and IPv6 Address plus mask types allow two IP address values defining a beginning and ending range of IP addresses. For maximum flexibility the architecture also permits user defined types. Alternatively additional types are manually added to the framework.

The layer Id field Id field is used to identify an originating layer and a parameter from the originating layer respectively. The originating layer and the parameter from the originating layer define packet parameters i.e. layer parameters and packet context that the data is compared against when identifying matching filters. The originating layer identifies a kernel or user layer. The parameter identifies a specific originating layer parameter. A specific example is illustrated by filter condition . The type is IPv4 thereby indicating the data is a 32 bit IP address. The layer Id is IP representing that the 32 bit number is a network layer parameter. The field Id is Src IP Addr which identifies the IP layer parameter as a source IP address. The IP address provided in the data filed is 123.4.0.1 which identifies the specific IP source address. Packets with the source IP address of 123.4.0.1 match the filter conditions described in the example.

The filter can include multiple filter conditions in which case a packet matches the filer when all filter conditions are satisfied.

The action designated in the filter identifies how to treat packets that match the filter conditions . Examples of actions include permit and block. Permit and block identify firewall policy that indicates that matching packets should be permitted to further traverse the network or conversely should be blocked. Other actions may be included such as callout to execute optional callouts for added functionally or to execute policy such as IPSec. Other network policies may also be executed by defining the other network policies in a data structure referred to as a policy context data structure described below.

The policy context is used to store policy other than firewall policy such as security policy or QOS policy. The policy context is any suitable data structure. For example the policy context is a 64 bit number that is interpreted by a process that added the policy context. The policy context and or action may be a null value.

In an embodiment of the invention actions are designated terminating or non terminating. If the action is terminating once that action is identified for a packet the action is returned to the requesting layer and no additional filters are applied to the packet. If the action is non terminating additional filter lookups continue until a terminating action for the packet is identified. As a default permit and block are designated terminating actions.

The layer Id field Id has the same meaning as the layer Id field Id provided as part of the filter conditions in the filters . Namely the layer Id field Id identifies the originating layer and the layer parameter from the originating layer for the data in the value field . The value field includes a specific layer parameter.

As a specific example entry includes the layer Id field Id NDIS Src. MAC Addr. NDIS represents a NDIS implementation of the link layer . Src MAC addr. represents a source MAC address. Thus the layer field Id indicates that the data in the value field is a source MAC address that was processed and added by the NDIS Link layer. The value field includes the actual source MAC address which in the example is 00.08.74.4F.22.E5 as expressed in hexadecimal notation.

As a second example entry has a layer Id field Id of NDIS IF No. This again identifies the layer as NDIS but in this case identifies the parameter as IF No representing an interface number as the specific NDIS parameter. The value field includes the actual interface number which in this case is 2.

As a third example entry has a layer Id field Id of IP Dst IP Addr. The IP represents the network layer using the IP protocol and the Dst IP Addr represents a destination IP address as the IP layer parameter. The value field includes the actual destination IP address of 123.3.2.1. 

Having described the underlying firewall architecture of the present invention attention is drawn to the functional interfaces of the system and exemplary methods that are performed using the underlying framework described herein. The functional interfaces are implemented as a plurality of application programming interfaces APIs . The APIs include the layer API the callout API the firewall engine API and the keying module API as shown in and .

The layer API facilitates data exchange between each of the layers in the network stack and the kernel firewall engine . As shown the layer API includes a Classify method an Add Layer method and a Delete Layer method .

The Classify method is used by the requesting layer to send layer parameters the packet as received by the requesting layer and the packet context to the kernel firewall engine . The kernel firewall engine compares the 1 layer parameters from the requesting layer and 2 packet context entries to the filter conditions in each filter assigned to the requesting layer to identify matching filters. The following is an exemplary implementation of the Classify method. It will be understood that the following methods are described as receiving or returning data values. According to known programming techniques the methods may use pointers to data values instead of actual data values.

LayerId identifies the network layer issuing the classification request i.e. the requesting layer. Referring to the layer Id identifies the layer as the data stream layer the transport layer the network layer the link layer or a user mode layer . Other layers are valid if added to the system.

pInFixedValues includes a subset of the layer parameters processed by the requesting layer. The pInFixedValues along with the packet context entries are compared to the filter conditions to determine if the packet matches the filter. Exemplary layer parameters included in the pInFixedValues for each layer are identified in Table A below. It will be understood that these parameters are merely by way of example and not limitation.

pInContext includes the context data structure as received by the requesting layer. The packet context is used by the kernel firewall engine in conjunction with the layer parameters to identify matching packets.

pPacket includes the entire packet as received by the requesting layer. The pPacket is not used by the kernel firewall engine to identify matching filters. As previously described the kernel firewall engine uses the pinFixedValues and pInContext to identify matching filters. The pPacket is included in the Classify method so that the kernel firewall engine can send it to one or more callout modules identified as the action in matching filters.

pActionType includes the action that is returned to the requesting layer. The action returned is permit or block as identified in the matching filter or callout modules executed by the matching filter. If no matching filter exists a default action of permit is returned.

pOutContext is a data structure that in addition to the action is designed to include data further defining network policies such as QOS IPSec and the like. The pOutContext is any suitable data structure for example is a 64 bit entry that includes a stream of data to be interpreted by a layer or process adding the pOutContext.

The Add Layer and Delete Layer methods are used to add and remove a layer from the firewall architecture respectively. The following is an exemplary form of the Add Layer method.

pLayerId is a unique layer identification value returned to the layer being added i.e. the layer executing the Add Layer method.

The callout API facilitates data exchange between the kernel firewall engine and the callouts . The callout API includes a Classify method a Register Callout method and a Deregister Callout method .

The Classify method of the callout API is similar to the Classify method of the layer API except that it also includes matching filter data. The following is an exemplary form of the Classify method used to execute a callout.

fixedValues includes the layer parameters sent from the requesting layer. The fixedValues is the same data provided by the requesting layer in pinFixedValues data sent as part of the Classify method in the layer API .

wfpContext includes the context data structure . This data is the same as sent by the requesting layer in the pInContext sent as part of the Classify method in the layer API .

Packet includes the entire packet as received by the requesting layer. This data is the same as sent by the requesting layer in the pPacket sent as part of the Classify method in the layer API .

matchedFilter identifies the filter requesting the callout. Typically the matching filter is identified by the filter Id of the matching filter initiating the Classify method of the callout API .

pActionType includes the action that is returned to the kernel firewall engine from the callout . If the pActionType is permit or block it is returned to the requesting layer as the pActionType returned by the layer API . The callout can also return a continue action that instructs the kernel firewall engine to continue applying matching filters to the packet.

pOutContext is a data structure that in addition to the action is designed to include data further defining network policies such as QOS IPSec and the like. The pOutContext is any suitable data structure for example is a bit entry that includes a stream of data to be interpreted by a layer or process adding the pOutContext.

The Notify method is used to notify a callout when a filter is added to the set of installed filters that identifies as one of its actions the callout module . The notify provides the callout with an opportunity to take any required action such as allocating or de allocating buffers that will be used by the callout when it is executed by the kernel firewall engine . The following is an exemplary form of the Notify method .

notify includes a numerical value that indicates whether the filter is being added or deleted. For example a value of 1 indicates the filter is being added and a value of 2 indicates that the filter is being deleted.

filter identifies the filter being added or deleted by unique value. This may be accomplished by providing the filter Id included as part of the filter .

The Registration method and the Deregistration method are used to add and remove callout modules respectively. An exemplary form the Registration method is as follows 

callout provides any callout specific information such as a driver service name device name and pointers to the callout classify and notify functions.

sd provides a security descriptor for the callout. The security descriptor identifies which processes can read and delete the callout.

The filter API facilitates data exchange between the user firewall engine and the kernel firewall engine. As shown the filter engine API includes an Add Filter method a Delete Filter method and an Enum Layer method . . . . The methods of the filter engine API are also provided as part of the management API .

The Add Filter method and Delete Filter method are used to add a new filter to the set of installed filters and to delete an existing filter from the set of installed filters respectively. The following is an exemplary form of the Add Filter method .

The Enum Layer method provides a mechanism for the user firewall engine to identify all filters matching a set of criteria. This allows the filter engine API to identify conflicting filters for filter arbitration and conflict resolution. The following is an exemplary form of the Enum Layer method .

pEnumTemplate includes a data structure defining the filters that should be returned. Fore example it include parameters that the filter conditions must match for the filter to be returned.

The keying module API provides an interface between user layers and the keying module . The keying module API includes an IPSec SA Acquire method an Expire Notify method and an IPSec SA Acquire Complete method a Keying Module Register method a Keying Module Deregister method an IPSec Inbound Get SPI method an Add Inbound SA method an Add Outbound SA method an Inbound SA Expire method and a Keying Module Initiate method . The keying module API may also include the methods previously described for the layer API such as a Classify method an Add Layer method and a Delete Layer method .

The keying module API is used to facilitate use of known security protocols such as defined by IPSec used by an initiating computer and a responding computer. IPSec includes protocols such as AH or ESP. The ESP protocol is an authenticating and encrypting protocol that uses cryptographic mechanisms to provide integrity source authentication and confidentiality of data. The AH protocol is an authentication protocol that uses a hash signature in the packet header to validate the integrity of the packet data and authenticity of the sender.

The IKE protocol provides a method for an initiating computer and a responding computer to negotiate security settings used with the AH and ESP protocols. The negotiated security settings form a data structure called a security association SA . The SA defines parameters such as an authentication algorithm encryption algorithm keys and the lifetime of keys used by ESP or AH to protect the contents of an IP packet. Because ESP and AH require an established SA an IKE negotiation is executed before the ESP or AH protocols are used by the initiating and responding computer. A given SA is identified by a value known as a Security Parameter Index SPI .

Each of the initiating and responding computers include an IPSec driver that determines based on an IPSec policy whether data sent between the initiating and responding computers requires encryption or authentication. The IPSec policy is a set of filters that defines how the network device uses IPSec and includes filter lists authentication methods and other information. In an embodiment of the invention the IPSec policy is defined by filters included in the set of installed filters in the kernel policy engine or the filter module . The policy that applies to a packet is identified by invoking the keying module layer which uses the Classify method to identify matching filters.

The IPSec SA Acquire method is called by the user policy engine via a client proxy to pass a driver acquire or an external initiate request to the keying module layer. The keying module layer returns this call and does the negotiation asynchronously. Once the keying module layer has completed the negotiation the keying module layer calls the IPSec SA Acquire Complete method to notify the user firewall engine that the negotiation is complete. The following is an exemplary form of the IPSec SA Acquire method.

acquire includes the necessary information for negotiating the SA according to known protocols such as IKE.

The Expire Notify method is called to pass an expire notify to the keying module layer that added the inbound SA. The following is an exemplary form the Expire Notify method.

expireNotify contains information identifying the expiring SA. For example in the case of an outbound SA the SPI is provided.

The IPSec SA Acquire Complete method is called by a keying module to close the user policy engine s context after it has finished negotiation and added all the SAs or after it has come across an error. After this method is executed the keying module does not reuse the ipsecContext for any other API method. The following is an exemplary form the IPSec SA Acquire Complete method.

status provides status and other details of the SA negotiation. The status is returned by the user policy engine if the acquire was externally initiated via FwpKeyingModuleInitiate0.

The Keying Module Register method is called by a keying module to register with the user policy engine and pass its function pointers. The following is an exemplary form of the Keying Module Register method.

keymodInfo includes registration information about the keying module layer such as pointers to process IPSec SA Acquire and process IPSec SA Expire functions.

The Keying Module Deregister method is called by the keying module to deregister the keying module from the user policy engine . The following is an exemplary form of the Keying Module Deregister method.

The IPSec Inbound Get SPI method is called by the keying module to obtain the SPI for a new inbound SA. The IPSec Inbound Get SPI method is usually used when the keying module executes in a responding network device. The following is an exemplary form the IPSec Inbound Get SPI method.

ipsecTrafficDescription is a 5 tuple description for creating an inbound larval SA. The 5 tuple includes source and destination IP addresses source and destination ports and transport layer protocol type.

udpEncapInfo is UDP encapsulation data for creating the larval SA. UDP encapsulation is a known method of embedding a packet formatted according to a security protocol into an unencrypted UDP packet.

The Add Inbound SA method is called by the keying module layer to add an inbound SA i.e. update the larval SA. The user policy engine uses the SPI in the SA to map this call to its internal state and ioctl the SA down to the IPSec driver. The following is an exemplary form of the Add Inbound SA method.

The Add Outbound SA method is called by a keying module layer to add an outbound SA. The user policy engine uses an inbound SPI parameter to map this call to its internal state and ioctl the SA down to the IPSec driver. The following is an exemplary form the Add Outbound SA method 

The Inbound SA Expire method is called by the keying module to expire the inbound SA that was previously added. The following is an exemplary form the Inbound SA Expire method .

The Keying Module Initiate method is called by known external application like RAS Winsock API and the like to initiate the keying module layer and setup SAs before an application starts sending its network traffic. The user policy engine asynchronously pends the RPC call gets the SPI from an IPSec driver and passes the acquire to the appropriate keying module. Once the keying module layer calls FwplPSecSAAcquireComplete0 the user firewall engine completes the asynchronous RPC with the negotiation status. The following is an exemplary form of the Keying Module Initiate method.

waitEvent is a handle to an event that is triggered when negotiation status is available. If a client i.e. calling external application is not interested in waiting for the negotiation to complete it can set this parameter to NULL. Internally the client proxy optionally passes this event to RPC and request it to set the event once the asynchronous RPC call completes.

negotiationStatus includes an outcome of the negotiation. The negotiationStatus is NULL if waitEvent is NULL. Otherwise negotiationStatus remains valid until the waitEvent is triggered.

In step the user firewall engine receives new policy from one of the policy providers . As previously described the policy providers are any suitable source such as stored data in volatile or non volatile memory or through user entered data via a GUI.

The user firewall engine then renders the new policy as a new filter by defining the new policy in terms of filter properties an action and filter conditions as shown in step . A filter Id and policy context may also be provided.

The filter properties include the priority class the override allowance and the weight . The priority class is a function of identity of the user or process responsible for the new policy e.g. user administrator firewall client or guest each of which has an assigned value. The higher the value of the priority class the higher the priority of the filter.

The override allowance specifies actions in lower priority filters that can override the new filter i.e. actions that will be taken even though the filter has a lower priority class. The override allowance is specified by the policy provider and has a default of none.

The weight identifies the precedence of the new filter relative to other installed filters. The weight is automatically calculated by the user firewall engine or alternatively is determined by the policy provider . A method for automatically calculating the weight is described with reference to .

In step the user firewall engine determines whether the new filter conflicts with any of the installed filters that are included on the active filter list . The installed filters are stored in the kernel firewall engine or alternatively in filter module . Filters may be assigned to a particular user or kernel layer in which case conflicts only exist between the new filter and installed filters assigned to the same layer. Alternatively the user firewall engine determines whether the new filter conflicts with any installed filter regardless of whether filters are assigned to a particular user or kernel layer. A method of identifying whether a conflict exists is described with reference to . If no conflict is identified the new filter is added to the set of installed filters using for example the Add Filter method and is added to the active filter list as shown in step .

If the new filter conflicts with at least one installed filter the user firewall engine determines whether the new filter has a lower priority class than the conflicting installed filter as shown in step . If the new filter does have a lower priority class the new filter is added to the set of installed filter and is added to the disabled list as shown in step . Installed filters on the disabled list are not identified as matching filters by the user or kernel firewall engine when responding to a classification request issued by a requesting layer.

If the new filter has a higher priority class than the conflicting installed filter the new filter is added to the set of installed filters and added to the active list as shown in step . The conflicting installed filter is then removed from the active list and added to the disabled list as shown in step .

In the case where the conflicting installed filter is moved to the disabled filter list the user firewall engine also determines whether any filters identified in the disabled filter list can now be moved to the active filter list . This occurs when a filter was disabled because it conflicted with the filter being moved from the active filter list to the disabled filter list . If possible any such filters are removed from the disabled filter list and moved to the active filter list . This process may be recursive. Specifically as each filter is added to the active filter list it is necessary to disable any lower priority conflicting filters. As any filter is added to the disabled filter list it is desirable to activate any previously overridden disabled filters.

As illustrated by the foregoing method the new filter is always added to the set of installed filters and is either included in the active filter list or the disabled filter list . Conflicting installed filters may be changed from the active list to the disabled filter list as a result of the new filter.

Referring to a method for removing a filter from the set of installed filters will now be described. In step the user firewall engine is invoked to remove a particular filter.

In step the method removes the filter from the set of installed filters . A method for removing a filter was described with reference to the Delete Filter method .

In step the method determines whether the removed filter was in the disabled filter list . If the filter was in the disabled list the method ends as generally shown. If the filter was not in the disabled filter list i.e. was in the active filter list the method optionally identifies any filters in the disabled filter list that were overridden i.e. conflicted with the removed filter. The overridden filters are then removed from the disabled filter list and added to the active filter list as shown in step . In this manner a previously disabled filter is activated when a higher priority conflicting filter is removed from the set of installed filters . Alternatively the method does not execute steps and and overridden filters are maintained in the disabled filter list.

In step the user firewall engine identifies a set of potential at odds filters. Potential at odds filters are filters with a common set of i.e. overlapping filter conditions differentactions e.g. permit and block and no common override allowance. A common override allowance exists where a lower priority filter designates a different action but that action is identified as an override allowance in the higher priority filter. A method of identifying filters matching a set of criteria such as filter conditions and actions was described with reference to the Enum Layer method . In an embodiment of the invention the user firewall engine only identifies potential at odds filters for installed filters assigned to the same layer as the new filter.

In step the user firewall engine determines whether actual at odds filters exist. Actual at odds filters are potential at odds filters wherein the first filter has a higher weight value but a lower priority class value than the second filter or vice versa. If actual at odds filters do not exist then the method determines that no conflict exists as shown in step and the process ends as generally shown. If actual add odds filters do exist the process determines that a conflict does exist as shown in step .

Turning to a method for automatically calculating a weight value for a new filter will now be described. The weight depends on the specificity of the filter. The specificity of the filter is a function of the filter conditions . As a general rule the fewer packets that a filter potentially matches as determined by the filter conditions the higher the weight value given to the filter.

As shown in step the user firewall engine identifies a per layer weight definition for the new filter. The per layer weight definition includes bit assignments from the weight value field for filter conditions for the layer assigned to the filter. In an embodiment of the invention the weight value field is a 32 bit number. Accordingly the per layer weight definition assigns specific bits from the 32 bits to the filter conditions for the layer. Table B illustrates an exemplary per layer weight definition for the transport layer with bit being the most significant bit and bit being the least significant bit.

It will be noted that some filter conditions are more significant than other filter conditions in the per layer weight definition. For example in the per layer weight definition shown in Table B the source IP address filter condition occupies the 8 most significant bits and thus is more significant in the overall weight value than any other filter condition . The destination IP addresses filter condition occupies the next 8 most significant bits is more significant than any other filter condition except for the source IP address filter condition. Each layer has its own per layer weight definition and the per layer weight definition in Table B is by way of illustration not limitation.

In step a scaling factor is determined for each filter condition in the per layer weight definition so that the filter condition can be scaled to fit in the number of allocated bits. Any method can be used for this purpose. The following is an exemplary method used for determining the scaling factor. Log Max Filter Condition Range Size Max Weight 

Max Filter Condition Range Size is the maximum range of the filter condition. For example in the case of IPv4 addresses the Max Filter Condition Range Size is 32 bits which translates into 2or approximately 4.3 billion. In the case of source and destination ports the Max Filter Condition Range Size is 2or 65 536.

Max Weight is the maximum value that can be placed in the number of bits assigned to the filter condition in the weight value field . For example in the above example the source and destination IP addresses are each allocated 8 bits which renders a maximum weight value of 2 1 or 255. The protocol is allocated 2 bits which renders a maximum weight of value of 2 1 or 3. The source and destination ports are each allocated 4 bits which renders a maximum weight value of 2 1 or 15.

Using the above scaling method the user firewall engine solves for the scaling factor N. As a specific example if the filter condition is the source IP address and it is allocated 8 bits in the weight value field solving for N in the equation Log 2 255 yields N 1.09051.

In step each of the filter conditions is scaled to fit in the number of assigned bits in the weight value field using the scaling factor. The following illustrates how the filter condition is scaled using the previoulsy described scaling method. Scaled Weight Value Max Weight Log Total Num Filter Condition Values 

Max Weight is the Maximum value that can be placed in the number of bits assigned to the filter condition in the weight value field .

Total Num Filter Condition Values is the number of values specified in the filter condition. For example if a single IP addresses is specified as the filter condition the Total Num Filter Conditions Values is 1. If a range of 10 IP addresses is specified the Total Num Filter Conditions is 10 and so on.

As a specific assume that the filter condition specifies a source IP range of 1.2.3.0 to 1.2.3.255. The number of source IP addresses in the range of 1.2.3.0 to 1.2.3.255 is 256 addresses. The Scaled Weight Value equals 255 Log 255 193.

In step the Scaled Weight value is placed in the weight value field in the bits assigned to the filter condition. In the example the value of 193 is placed as a binary number into to bit fields through .

The per weight layer weight definition may allocated a number of bits to a tiebreaker condition usually the least significant bits. The tiebreaker value is used to ensure that each filter has a unique weight value . The tiebreaker value may be determined using an suitable method. For example it may be a value that is incremented by a value of 1 for each new installed filter. Alternatively it may be a random number provided that the same random number is not used for more than one filter.

The method is completed for each filter condition that is specified in the per layer weight definition thereby rendering the 32 bit weight value field . Alternatively two or more filter conditions are combined into a single weight space. For example a single weight space includes 2 scaled source IP address scaled destination IP address .

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

