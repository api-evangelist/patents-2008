---

title: Techniques for managing a storage environment
abstract: Techniques for managing a storage environment. According to an embodiment of the present invention, high-level application programming interfaces (APIs) are provided that can be used by applications such as storage management applications (e.g., ERM applications, SRM applications) to manage a storage environment. Using these APIs, an application can issue simple high-level commands to perform storage management operations without having to worry about the low level storage array-specific commands. Embodiments of the present invention handle the necessary translations between the high-level commands and the low-level storage array-specific commands or protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08001284&OS=08001284&RS=08001284
owner: Hitachi, Ltd.
number: 08001284
owner_city: Tokyo
owner_country: JP
publication_date: 20080318
---
This is a continuation of U.S. patent application Ser. No. 10 374 319 filed Feb. 25 2003 now U.S. Pat. No. 7 363 390 which is a continuation of U.S. Patent Application No. 60 393 097 filed May 23 2002. The entire disclosure of which is incorporated herein by reference.

The present invention relates to techniques for managing computer systems and more particularly to techniques for managing storage environments.

With the proliferation of computers and network systems an increasing amount of information is being stored in electronic form. This has given rise to large and heterogeneous storage environments for storing the information. Due to their heterogeneity and complexity managing these storage environments is a difficult and complex task.

Several application programs e.g. enterprise resource management ERM applications storage resource manager SRM applications are presently available for managing storage environments. Many of these use standardized protocols such as the Simple Network Management Protocol SNMP protocol for communicating with the storage environments. However controlling a storage environment using conventional protocols such as SNMP is a complex endeavor. In order to accomplish even a simple task the storage management application program typically has to issue multiple SNMP commands to the storage environment. For example as shown in in order to add a volume to a storage array an ERM application has to send a series of SNMP commands to the storage array. Even though some commands can be grouped into SNMP PDUs Protocol Data Units multiple commands are required and the ERM application has to constantly monitor the results of the commands. As another example a commonly performed task such as discovering a storage array and getting configuration information for the storage array takes several SNMP commands to accomplish.

Issuing multiple commands and monitoring responses to the multiple commands is difficult and tedious for storage management applications and is very processing intensive. Further since SNMP uses the User Datagram Protocol UDP protocol that does not guarantee message delivery the storage management application has to implement techniques to verify delivery of the SNMP messages to the storage environment and to ensure that responses are not lost. As a result conventional storage management applications have to implement techniques such as polling loops techniques for detecting SNMP traps and other like techniques to ensure that the SNMP command was delivered to the storage environment and to detect responses to the SNMP commands. As a result conventional storage environment management programs are generally quite complex and difficult to develop.

Additionally configuration data related to a storage environment is usually stored and represented as a table. For example information related to each Port of a storage array may be stored as a table row and properties of a Port e.g. port identifier are stored in columns of the table. SNMP version 1 does not support the ability to retrieve values stored in a table in a single operation. As a result using SNMP version 1 if a storage management application needs to get information from a table storing information for elements of a storage array and their properties e.g. information for all ports of a storage array the application has to issue a separate request for each property of the element and then repeat that for each row of the table. This can be quite tedious and further increases the complexity of the storage management software.

From the above it can be seen that improved techniques for managing storage environments are desired.

Embodiments of the present invention provide improved techniques for managing a storage environment. According to an embodiment of the present invention high level application programming interfaces APIs are provided that can be used by applications such as storage management applications e.g. ERM applications SRM applications to manage a storage environment. Using these APIs an application can issue simple high level commands to perform storage management operations without having to worry about the low level storage array specific commands. Embodiments of the present invention handle the necessary translations between the high level commands and the low level storage array specific commands or protocols.

According to an embodiment of the present invention a technique is provided for managing a storage environment. An embodiment of the present invention receives a request to perform a first command on a storage array in the storage environment. A first plurality of commands corresponding to the first command is determined. Commands in the first plurality of commands belong to a first communication protocol used for communicating with the storage array. The first plurality of commands is then communicated to the storage array. One or more responses to the first plurality of commands are detected and a first response to the request to perform the first command is generated based upon the one or more responses.

According to another embodiment of the present invention techniques are provided for managing a storage environment where a signal is received indicating invocation of a first application programming interface API . A first command to be performed corresponding to the first API is determined. A first plurality of commands belonging to a first communication protocol used for communicating with the storage array are then determined for the first command. The first plurality of commands is then communicated to the storage array. One or more responses to the first plurality of commands are detected and a first response to the first API is generated based upon the one or more responses.

The foregoing together with other features embodiments and advantages of the present invention will become more apparent when referring to the following specification claims and accompanying drawings.

Embodiments of the present invention provide improved techniques for managing a storage environment. According to an embodiment of the present invention high level application programming interfaces APIs are provided that can be used by applications such as storage management applications e.g. ERM applications SRM applications to manage a storage environment. Using these APIs a storage environment management application management application can issue simple high level commands to perform storage management operations without having to worry about the low level storage array specific implementation e.g. SNMP commands of the operations. Embodiments of the present invention handle the necessary translations between the high level commands and the low level storage array specific commands or protocols and thus hide the low level storage array specific implementation details from the management application. As a result the present invention simplifies development and complexity of management applications. Embodiments of the present invention also use communication protocols e.g. TCP IP that guarantee delivery of a message or command. Embodiments of the present invention also support table operations. As a result management applications can acquire or set multiple values from a storage environment e.g. information for ports of a storage array by issuing a single command rather than multiple commands.

For purposes of this application the term client application is intended to include any program application or process that makes use of services and APIs provided by command server . Client applications may include storage management applications such as ERM applications SRM applications proprietary applications and the like. These applications may use a command line interface CLI based a graphical user interface GUI based or other types of interfaces. Client applications may execute on computer system or on other computer systems as shown in that are able to communicate with computer system via communication links . System depicted in is merely illustrative of an embodiment incorporating the present invention and does not limit the scope of the invention as recited in the claims. One of ordinary skill in the art would recognize other variations modifications and alternatives.

Communication links depicted in may be of various types including hardwire links optical links satellite or other wireless communications links wave propagation links or any other mechanisms for communication of information. Various communication protocols may be used to facilitate communication of information via the communication links. These communication protocols may include TCP IP HTTP protocols extensible markup language XML wireless application protocol WAP protocols under development by industry standard organizations vendor specific protocols customized protocols and others. The communication links may traverse one or more communication networks including the Internet an intranet a wireless network a private network a public network a switched network or any other suitable communication network.

Storage environment may comprise one or more storage arrays . For purposes of this application the term storage environment is intended to refer to a configuration or environment including one or more storage arrays. For purposes of this application the term storage array is intended to comprise one or more storage devices and associated one or more controllers processors and or communication ports. Examples of storage devices include memory disks drives raid structures optical disks drives tapes solid state disks SSDs etc. For purposes of this application managing a storage environment may include operations for configuring one or more components e.g. storage arrays of the storage environment modifying the storage environment getting status of the storage environment adding components to the storage environment deleting components from the storage environment and other operations affecting or relating to the storage environment.

As described above command server provides high level command APIs or function calls that may be used by client programs to manage storage environment . According to an embodiment of the present invention an API represents a command request or function call requesting performance of a command or function when the API is invoked. An API may include parameters if any needed to perform the requested command or function. A response may also be defined for an API. A response for a command request includes the result or status of performing the requested command. The response may be based on one or more responses received by command server from storage environment in response to performing one or more operations corresponding to the command request. Various message formats and protocols may be used to communicate command requests from client applications to command server and to communicate responses from command server to client applications . According to an embodiment of the present invention command requests and responses are communicated using XML messages.

According to an embodiment of the present invention command server and client applications communicate using a communication protocol that guarantees delivery of command requests to command server and of corresponding responses to client applications . According to an embodiment of the present invention clients and command server communicate using the TCP IP protocol. A HTTP messaging protocol over TCP IP may also be used. Various other protocols may also be used. As a result of using protocols that guarantee delivery of commands requests to command server and of corresponding responses to client applications unlike prior art systems client applications do not have to provide their own techniques for verifying delivery of command requests.

A client application and command server may communicate with each other in one of several command modes. In a synchronous command mode a client invokes an API provided by command server requesting performance of a command and waits until a response to the command request is communicated to client application by command server upon completion of processing corresponding to the command request. In an asynchronous mode after invoking an API provided by the command server client application does not have to wait to receive a response from command server to the command request corresponding to the API. In an asynchronous embodiment client application may periodically poll command server to determine if the requested command has been completed. If the requested command has not been completed command server may return a Processing status to client application . When the processing has been completed command server may return a Completed status to client application along with the response generated for the requested command.

According to another embodiment a publish subscribe command mode may be used. In this mode a client application subscribes to events or topics on the command server that are of interest to the client application. For example client application may subscribe to a response to a command request or event invoked by the client application. Accordingly when the particular event occurs e.g. the command request has been completed command server notifies client or publishes to the client of the event and client can receive the response to the command request.

Command server is configured to receive a command request in response to an API invoked by a client application and to determine processing necessary for servicing the command request. According to an embodiment of the present invention command server determines a particular storage array to which the command request is directed. Upon determining the particular storage array command server determines a communication protocol for communicating with the particular storage array. Examples of communication protocols used by a storage array may include SNMP using UDP IP TCP IP protocols proprietary to the storage array and various other protocols. Upon determining a protocol used by the particular storage array command server determines one or more commands also referred to as low level commands in the protocol used by the storage array to perform the command requested by client application .

Command server is configured to communicate the one or more low level commands to the storage array. Command server controls and manages the order and sequence in which the one or more commands are communicated to the storage array. Command server is configured to monitor one or more responses received from the storage array in response to the low level commands. Various different techniques such as polling traps etc. may be used to monitor responses received from the storage array in response to the low level commands. Based upon the responses received from the storage environment command server generates a response to the command request received from client application and communicates the generated response to client application . Further details related to processing performed by command server are described below.

It should be understood that a command request from a client application may be directed to multiple storage arrays in the storage environment. In this embodiment command server is configured to communicate the low level commands corresponding to the requested high level command to the multiple storage arrays and monitor responses from the multiple storage arrays. A response based upon responses received from the multiple storage arrays is then communicated to the client application that invoked the API resulting in the command request.

As depicted in processing is initiated when command server receives a command request from a client application in response to a command server API invoked by client application step . As described above command server may receive the request using various communication protocols such as XML or HTML messaging over TCP IP etc. According to an embodiment of the present invention the command request is received using a communication protocol that guarantees delivery of the command request to command server .

Command server then determines one or more storage arrays to which the command request received in is directed step . It is assumed for purposes of explaining flowchart that a single storage array is determined in step . Command server then determines a communication protocol used by the storage array determined in step step . The communication protocol may correspond to a set of APIs used by the storage array for communication. Examples of communication protocols used by a storage array include SNMP using UDP IP TCP IP protocols proprietary to the storage array and various other protocols.

Command server then determines one or more commands low level commands corresponding to the command request received in step step . The low level commands determined in step are in the communication protocol e.g. part of the APIs determined in step . For example if it is determined in step that the storage array is configured to receive SNMP commands in step command server determines one or more SNMP commands corresponding to the command request received in step .

Command server then communicates the one or more low level commands determined in step to the storage array s determined in step step . According to an embodiment of the present invention command server controls the manner and sequence in which the low level commands are communicated to the storage array. For example command server may generate SNMP PDUs to communicate the SNMP low level commands to the storage array.

Command server then monitors or detects one or more responses received from the storage environment in response to the commands communicated to the storage array step . Various different techniques such as polling detection of traps etc. may be used to detect responses to the commands. Command server may detect a response by receiving the response from the storage environment by monitoring trap conditions by using polling etc. The storage environment may generate a response for each low level command communicated to the storage array or alternatively may generate a response for a group of low level commands.

Depending on the number and nature of the low level commands the sequence in which the commands are to be communicated to the storage array and the responses to be monitored steps and may be performed in sequence one or more times. For example a first subset of low level commands determined in step may be communicated to the storage array responses to the first subset determined then a second subset of the low level commands determined in step may be communicated to the storage array responses to the second subset determined and so on until all the low level commands determined in step have been processed.

After all the commands determined in step have been processed or earlier if there was a special condition or failure of some sort command server generates a response to the command request received in step based upon the responses determined for the low level commands in step step .

The response generated in step is then communicated to the client application that was the source of the command request received in step step . As described above the manner in which the response is communicated to the client application may depend on the command mode of the client application. For example in a synchronous mode command server may communicate the response to the client application after processing of the command request has been completed. In an asynchronous command mode the response may be communicated to the client application when the client application polls command server . In a publish subscribe mode the response may be communicated to the client application when command server determines that an event e.g. completion of the command request has occurred to which the client application has subscribed. Other command modes may also be used.

The processing described above may be implemented in hardware or software or combinations of hardware and software. According to an embodiment of the present invention the processing is implemented by computer programs or code modules executing on a computer system such as computer system depicted in . depicts a simplified block diagram of computer system according to an embodiment of the present invention. As depicted in computer system may include a processor a memory subsystem including volatile and non volatile memory and or storage elements coupled to processor and readable by processor an input subsystem an output subsystem and a communication subsystem . Bus subsystem provides a mechanism for letting the various components and subsystems of computer system to communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may utilize multiple busses.

Input subsystem may include a keyboard a pointing device a mouse a trackball a touchpad a graphics tablet a scanner a barcode scanner a touchscreen incorporated into the display an audio input device such as a voice recognition system a microphone and other types of input devices. In general input subsystem may include all possible types of devices and ways to input information to computer system .

Output subsystem may include a display subsystem a printer a fax machine or non visual displays such as audio output devices. The display subsystem may be a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD a projection device and the like. In general output subsystem may include all possible types of devices and ways to output information from computer system .

Memory subsystem may store the code modules programs and data constructs that provide the functionality of the present invention. These code modules and programs may be executed by processor . Memory subsystem may include one or more volatile and or non volatile memories.

Communication subsystem provides an interface to other computer systems storage environments communication networks etc. Communication subsystem facilitates communication of data to and from computer system .

Computer system can be of varying types including a personal computer a portable computer a workstation a network computer a mainframe a kiosk a personal digital assistant PDA or any other data processing system. Due to the ever changing nature of computers and networks the description of computer system depicted in is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations of a computer system are possible having more or fewer components than the computer system depicted in .

Client applications may include applications that use services and APIs provided by command server . Examples of client applications include storage management applications third party applications other command server applications and other applications. Client applications may use different message types formats and communication protocols to communicate command requests to command server . Examples include XML format HTTP format command line interface format various proprietary formats and others.

Translation layer is configured to receive command requests from client applications in response to command server APIs invoked by the client applications. For example translation layer may receive a command to add a volume to a storage array. The command may be received responsive to an AddVolume API provided by command server and invoked by a client application. According to an embodiment of the present invention translation layer comprises communication modules that are configured to interface with client applications . Communication modules are configured to receive command requests from client applications and to communicate responses to client applications . Communication modules may use various protocols and formats for interfacing with client applications . Each module may be configured to handle command requests and response for a particular protocol. For example translation layer may include a HTTP XML client interface module for communicating with a client application using the HTTP XML protocol a command line interface CLI module for communicating with CLI applications and the like.

Translation layer makes use of services provided by security layer interface to authenticate and authorize command requests received from client applications . As part of the authentication and authorization process security layer authenticates the originator client application or user using the client application of the command request determines if the originator is permitted to access command server and if the originator is permitted to perform the requested command. Security layer may make use of information e.g. user identification and access rights information stored in a security database to perform the authentication and authorization process. Processing of the command request is terminated if it is determined that the user or originator could not be authenticated or that the user or originator was not authorized to perform the requested command.

According to an embodiment of the present invention translation layer also comprises a translation interface that is configured to convert or translate the command requests received from client applications into a standard message format with a standard interface. The translated command request is then forwarded to agents layer for further processing.

Agent layer comprises an agent dispatcher and a set of agents or modules . For each translated command request received from translation layer agent dispatcher is configured to select and invoke one or more agents for processing the command request. For example agent dispatcher may select an AddVolume agent for processing an AddVolume command request received from a client application.

Each agent is configured to perform a specific set of operations. For example the AddVolume agent is configured to perform operations related to adding a volume to a storage array. Operations for an AddVolume command request may include gaining exclusive access to or locking the storage array getting the latest data configuration of the storage array adding a volume to the storage array verifying that the volume was properly added releasing the lock on the storage array and other operations.

According to an embodiment of the present invention an agent directs performance of an operation by invoking one or more APIs or functions provided by transport layer . For example the AddVolume agent may invoke a first transport layer API to lock the storage a second API to get the latest data configuration of the storage array a third API to add a volume to the storage array a fourth API to verify that the volume was properly added a fifth API to release the lock on the storage array and so on.

Agent layer is also configured to accumulate responses received from transport layer in response to APIs invoked by the agents. Agent layer is configured to generate a response for the command request received from translation layer based upon the responses received from transport layer . The generated response is then communicated to the client application via translation layer .

According to an embodiment of the present invention agent layer validates the requested command using validation engine . Validation includes several tasks including ensuring that the parameters if any provided for the requested command are correct e.g. the values of the parameters are within a correct range the specified object such as Port or storage device sometimes also referred to as a logical device or LDEV in short actually exists on the array . Validation engine makes use of database interface and information stored in configuration database to perform the validation. According to an embodiment of the present invention configuration database stores a cached copy of the configuration ports paths storage devices LDEVs for each storage array in the storage environment. Agent layer may also make use of services provided by security layer .

Transport layer comprises a transport interface and one or more transport modules . Transport interface provides APIs that can be used by agents to perform operations corresponding to the command request. The APIs provided by transport interface are independent of the storage arrays on which the operations are to be performed. For each transport interface API invoked by an agent from agent layer transport interface selects a transport communication module for performing processing for the invoked API. According to an embodiment of the present invention a transport communication module is selected that can communicate with the storage array to which the API function is directed. Accordingly in order to select a transport communication module transport interface determines a communication protocol that can be used to communicate with the storage array to which the API is directed and selects an appropriate transport module that is configured to communicate with the storage array using the protocol. For example if SNMP commands are used to communicate with the storage array an SNMP transport module may be selected. One or more transport modules may be provided for the communication protocols supported or used by the storage arrays. For examples modules may be provided for supporting the SNMP protocol Disk Array Management Program DAMP protocol of Hitachi Ltd. Command Control Interface CCI protocol of Hitachi Ltd. proprietary protocols and other protocols.

Each transport module selected by transport interface is configured to determine low level commands corresponding to the transport interface API invoked by an agent from agent layer . The low level commands represent commands or APIs selected from the communication protocol or set of APIs supported by the storage array. For example if the AddVolume agent from agent layer has invoked a transport interface API to lock a storage array and SNMP protocol is used to communicate with the storage array the transport module selected by transport interface for handling processing for the API may determine the following SNMP low level commands for locking the storage array Set Manager Set CmdKind Set CmdStatus. The transport module communicates the low level commands to the particular storage array. The transport module also monitors responses received from storage environment in response to the low level commands communicated to the storage array. The transport module may forward the responses to the selected agent in agent layer .

As described above a modular architecture is used to implement command server . For example each layer represents a module of code that can be easily replaced for a particular application of command server . For example the security interface can be easily replaced to enhance security without affecting the other layers of command server . New hardware interfaces and storage arrays can be supported by plugging in an appropriate transport layer module.

Due to the layered architecture new releases of storage array microcode implementing new features can also be easily supported. Different version levels of the microcode can also be easily supported. For example in a storage environment two identical storage arrays may have different levels of microcode with different functionalities e.g. a first storage array may have microcode level that supports feature X while a second storage array may have microcode level that does not support feature X . In this scenario two different transport layer modules configured to the different microcode levels may be used to talk to each array. In this manner multiple versions of microcode can be easily supported.

An example of a XML API with an AddVolume request and response is provided below in the XML API this is called AddLUN or AddVolume 

Translation layer authenticates and authorizes the requested command and translates it to a common standard format shown as an internal message format . The translated command request is then forwarded to agent layer in an internal message format. Agent dispatcher validates the command request using validation engine . Upon successful validation agent dispatcher selects and invokes an AddVolume agent to process the command request.

AddVolume agent determines the various operations corresponding to the requested command. AddVolume agent invokes APIs or functions provided by transport layer to perform the various operations. As shown in AddVolume agent determines that the command to add a volume comprises the following operations gaining exclusive access to or locking the storage array getting the latest data configuration of the storage array adding a volume to the storage array verifying that the volume was properly added and releasing the lock on the storage array. For each of these operations AddVolume agent invokes an API provided by transport layer e.g. Lock API Refresh Data API AddPath API and Unlock API . AddVolume also accumulates results for the invoked APIs.

Transport layer is configured to communicate with storage array using a communication protocol understood by storage array . As shown in transport layer communicates with storage array using the SNMP protocol. For each API or function invoked by AddVolume agent transport layer determines command functions or APIs in the communication protocol of the storage array. As shown in transport layer determines SNMP commands for functions APIs invoked by AddVolume agent . These SNMP commands are then communicated to storage array .

Transport layer receives responses results of the SNMP commands communicated to storage array . Various different techniques such as polling detection of traps etc. may be used by transport layer to detect the responses. For example since SNMP uses the UDP protocol in order to ensure that response messages are not missed transport layer may use polling techniques wait for SNMP traps and use combinations of polling and trap detection techniques to detect the responses. Transport layer communicates these responses to agent layer . Agent layer accumulates the results and responses received from transport layer . Based upon the results and responses received from transport layer agent layer generates a result response that is communicated to translation layer . Translation layer then communicates the response to ERM application . In the embodiment depicted in the result is communicated to ERM application as an XML message.

Service layer comprises a service module selector a set of service modules and a set of agents . For each translated command request received from translation layer service module selector is configured to select one or more service modules for processing the command request. For example service selector module may select a StorageManager module for processing an AddVolume command request received from a client application.

Each selected service module is configured to select one or more agents for processing the command request. For example the StorageManager module may select an AddVolume agent to process the AddVolume command request. As described above each agent is configured to perform a specific set of operations. For example the AddVolume agent is configured to perform operations related to adding a volume to a storage array. These operations may include gaining exclusive access to or locking the storage array getting the latest data configuration of the storage array adding a volume to the storage array verifying that the volume was properly added releasing the lock on the storage array and other operations.

According to an embodiment of the present invention an agent directs performance of an operation by invoking one or more APIs or functions provided by transport layer . For example the AddVolume agent may invoke a first transport layer API to lock the storage a second API to get the latest data configuration of the storage array a third API to add a volume to the storage array a fourth API to verify that the volume was properly added a fifth API to release the lock on the storage array and so on.

Service layer is also configured to accumulate responses received from transport layer in response to APIs invoked by the agents. Service layer is configured to generate a response for the command request received from translation layer based upon the responses received from transport layer . The generated response is then communicated to the client application via translation layer .

According to an embodiment of the present invention service layer validates the requested command using validation engine . Validation includes several tasks including ensuring that the parameters if any provided for the requested command are correct e.g. the values of the parameters are within a correct range the specified object such as Port or storage device e.g. LDEV actually exists on the array . Validation engine makes use of database interface and information stored in configuration database to perform the validation. According to an embodiment of the present invention configuration database stores a cached copy of the configuration ports paths storage devices LDEVs for each storage array in the storage environment. Service layer may also make use of services provided by security layer .

Each storage array may comprise several elements such as ports disk drives logical devices LDEVs and so on . Each element may be characterized by multiple properties. For example a port has a number of properties that help define characteristics of the port such as port identifier port type e.g. Fibre Fibre Address Port world Wide Name and so on. Using conventional techniques such as SNMP multiple commands are required to obtain the multiple properties for the multiple elements of a storage array. For example a storage array may comprise three elements X Y and Z as shown in Table 1 see below .

According to an embodiment of the present invention the values for the various properties of elements of a storage array can be obtained or set using a single command API. For example a single API may be provided for obtaining the values depicted in Table 1. The present invention thus provides simplified APIs for obtaining multiple values of a storage array. Accordingly a single API may be used to perform table operations i.e. operations to set or get multiple values for a storage environment that may be stored or represented as a table . For example an API may be provided for requesting a list of all storage arrays under management in a storage environment and a list of Ports in each storage array. A response to the request includes information listing all the storage arrays Port elements for each storage array and properties of the Port elements.

Table 2 depicts examples of high level commands that can be invoked by client applications according to an embodiment of the present invention. Table 2 also list APIs that are provided by command server and that may be invoked by client applications for performing the high level commands. A brief simplified description of each high level command is also provided. Table 2 is not intended to reduce the scope of the present invention. Various other high level commands and APIs are also included within the scope of the present invention.

Although specific embodiments of the invention have been described various modifications alterations alternative constructions and equivalents are also encompassed within the scope of the invention. The described invention is not restricted to operation with certain specific data processing environments but is free to operate within a plurality of data processing environments. Additionally although the present invention has been described using a particular series of transactions and steps it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.

Further while the present invention has been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. The present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that additions subtractions deletions and other modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

