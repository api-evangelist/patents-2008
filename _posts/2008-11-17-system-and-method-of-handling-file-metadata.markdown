---

title: System and method of handling file metadata
abstract: A network storage system comprises data storage, one or more file system APIs, and a metadata handler. The data storage can comprise file data and associated metadata. The file system APIs can be configured to read and write file data and metadata to and from the data storage. The metadata handler can have a library of functions for handling the metadata. The library can include a metadata blob creation function and a metadata blob extraction function. The metadata blob creation function cooperates with the file system APIs to read source metadata associated with specified file data and creates and populates a metadata blob from which a substantial copy of the source metadata can be generated. The metadata blob extraction function receives at least a metadata blob, extracts information from the metadata blob, and cooperates with the file system APIs to generate destination metadata, a substantial copy of the source metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589449&OS=08589449&RS=08589449
owner: Overland Storage, Inc.
number: 08589449
owner_city: San Diego
owner_country: US
publication_date: 20081117
---
This application is a continuation of U.S. patent application Ser. No. 11 118 617 filed Apr. 29 2005 which is hereby incorporated herein by reference in its entirety to be considered part of this specification.

Network attached storage provides a system architecture for providing centralized data storage for a computer network. In this architecture one or more network attached storage devices NAS devices are connected to storage devices including for example hard drives. A system administrator configures the computer network such that individual computers store network accessible data files centrally on one or more of the NAS devices.

A NAS device is connected to a network and can be accessed by other devices and computers connected to the same network. NAS devices generally have specialized operating systems that allow them to efficiently handle file operations including for example file read and write operations file storage file retrieval file backup file restore and the like. These specialized operating systems however generally are not optimized to perform operations associated with application programs. Rather in a network with NAS devices a traditional server typically performs operations related to applications and NAS devices perform file operations.

One function of a NAS device is to provide a mechanism to backup restore and migrate data files from different file systems including UNIX file systems Macintosh file systems Windows file systems and the like. Note that this application uses several terms including UNIX Macintosh Windows and Linux that may be trademarks or registered trademarks. These operations which we herein generally call data replication operations require faithful replication of each file s raw data and extended attributes or metadata associated with each file. Each file system stores such metadata in a different way. Accordingly while operating systems typically provide data replication operations that can successfully replicate metadata associated with native files developers face difficulty in creating generic data replication operations that can successfully replicate metadata associated with files from multiple file systems.

This application describes various systems and methods that allow for the replication of metadata associated with files from multiple file systems. Advantageous embodiments of such systems and methods reduce or eliminate loss of metadata caused by transmitting or storing the metadata using one or more non native file systems. This summary provides a concise overview of some advantageous embodiments described herein but does not describe every embodiment and does not define the invention.

Embodiments of a metadata handler can advantageously be used in a network storage system to support various data replication operations. One embodiment of such a network storage system comprises data storage one or more file system APIs and a metadata handler. The data storage can be configured to store file data and metadata associated with the file data. The data storage can store file data and associated metadata of multiple file systems. For example a portion of the metadata can be native to one file system while another portion of the metadata can be native to another file system.

In one embodiment the file system APIs are configured to define operations for writing file data and metadata to the data storage and reading file data and metadata from the data storage. In a preferred embodiment the metadata handler has a library of functions for handling the metadata from the multiple file systems. This library can include for example a metadata blob creation function and a metadata blob extraction function. These functions preferably execute when called by a calling application.

In one embodiment when a calling application calls the metadata blob creation function the function cooperates with at least one of the file system APIs to read from the data storage source metadata associated with specified file data. The function creates a metadata blob and populates at least a portion of this metadata blob with information from which a substantial copy of the source metadata can be generated. Preferably the populated portion corresponds to metadata fields used by the source metadata s native file system.

In one embodiment when a calling application calls the metadata blob extraction function the function receives at least a metadata blob and extracts information from this metadata blob. The function cooperates with at least one of the file system APIs in order to generate destination metadata from the extracted information. The function in cooperation with the APIs stores the destination metadata in the data storage. Advantageously if the received metadata blob was generated by the metadata blob creation function from source metadata the destination metadata is a substantial copy of the source metadata.

Embodiments of a network storage system can also include one or more client applications configured to use the metadata handler. For example a backup application can call the metadata handler s metadata blob creation function in order to receive a metadata blob that encapsulates the file s metadata. The backup application can store the file and the metadata blob on a backup storage device such as for example an external tape drive. Conversely a backup application can also call the metadata handler s metadata blob extraction function in order to restore the metadata blob to the file effectively restoring the file s metadata. Data migration applications can call the metadata blob creation function and the metadata blob extraction function in turn in order to transfer a file s associated metadata from one storage device to another.

Accordingly embodiments of the metadata handler can be used in a network storage system to support data replication operations that allow for an exact or substantially exact replication of metadata even when the metadata is temporarily stored on a file system that cannot read the metadata. This is because the metadata handler creates and reads metadata blobs that encapsulate sufficient information to faithfully reproduce or at least substantially reproduce the metadata. Multiple file systems can be configured to store such metadata blobs without even knowing how to read the blobs and the blobs can later be restored on a system that has access to a metadata handler. Many advantageous alternative embodiments of the metadata handler storage systems for using the metadata handler and methods enabled by the metadata handler exist. The Detailed Description of Preferred Embodiments the Drawings and the Claims explicitly describe many such embodiments and render other embodiments apparent to a skilled artisan.

Embodiments of the metadata handler as described herein can be used in a network storage system to support data replication operations that allow for an exact or substantially exact replication of metadata even when the metadata is temporarily stored on a file system that cannot read the metadata. The metadata handler creates and reads metadata blobs that encapsulate sufficient information to faithfully reproduce or at least substantially reproduce the metadata. Multiple file systems can be configured to store such metadata blobs without even knowing how to read the blobs and the blobs can later be restored on a system that has access to a metadata handler.

This section describes with reference to the drawings a general architecture that implements various features of the embodiments described herein. The drawings and the associated descriptions illustrate preferred embodiments but do not limit the scope of the invention to those preferred embodiments. Throughout the drawings reference numbers are re used to indicate correspondence between referenced elements. In addition the first digit of each reference number indicates the figure in which the element first appears.

The data storage comprises file data and metadata . The file data comprises raw data files or directories including for example word processing documents text documents directories executable files compressed data files image files movie files audio files spreadsheet documents slide presentation documents and the like. A skilled artisan will appreciate in light of this disclosure that many other types of data files exist and can be stored in the file data .

The metadata comprises metadata as generally understood by a skilled artisan and at least encompasses attributes associated with each data file or directory that assists a file system an automated process or a user to classify the associated data file. Metadata can include but need not include one any subset of or all of the following name description keywords access permissions size date and time created date and time modified whether the file is read only whether the file is archived and the like. Accordingly the metadata can be used by a file system an automated process or a user in order to index data files find a particular data file sort data files allow or deny access to data files display data files that meet certain criteria automatically modify backup or delete data files that meet specified criteria and the like. A skilled artisan will appreciate many other types of metadata and uses for metadata all of which may be encompassed by the metadata in certain embodiments.

Each file and its corresponding metadata stored in the file data and the metadata corresponds to a particular native file system. For example some of the file data may represent native Windows files while other portions of the file data may represent native Unix files native Linux files native Macintosh files and the like. Similarly some of the metadata may correspond to native Windows files native Unix files native Linux files native Macintosh files or the like.

Despite storing file data and metadata that may natively correspond to several different file systems the data storage resides in one or more host storage devices with preferably one file system for storing and accessing the file data and metadata . Accordingly despite each file s underlying native format each file and its associated metadata are stored in the file data and metadata in files or records formatted in accordance with the host storage device s file system. For example if the host storage device is a NAS device the file data and metadata are stored in files formatted in accordance with the NAS file system. In one embodiment the host storage devices comprise NAS devices. Alternatively the host storage devices can comprise Windows file servers Unix file servers Linux file servers Macintosh file servers or file servers running any other known operating system.

Generally storing data files and metadata natively formatted for one file system in data storage residing in a different host file system can cause loss of data or metadata. Embodiments of the systems and methods described herein provide a mechanism for storing file data and metadata in a non native file system while preserving native data and native metadata such that such data and metadata can be accessed by a native file system without loss of the file data or the metadata . Embodiments of the systems and methods focus primarily on preserving metadata because loss of metadata is more common than loss of data. This is because many data files are stored in standard formats that can be read by many operating systems and applications with little or no modification.

In a preferred embodiment the metadata handler assists with preserving native metadata by generating and reading a metadata blob that encapsulates the metadata . Preferably the metadata blob one or more advantageous features for facilitating the preservation of metadata of many different formats such as for example UNIX metadata Windows metadata Macintosh metadata Linux metadata and other formats of metadata known to a skilled artisan. This section describes many such advantageous but not necessarily required features of embodiments of the metadata blob . This section describes preferred embodiments but does not limit the invention to these preferred embodiments. Rather a skilled artisan will appreciate that many variations exist that do not have all features of the preferred embodiments but which are nevertheless advantageous and useful.

In a preferred embodiment the metadata blob is a binary large object. However the metadata blob is not required to be a binary large object but may be any digital object of any format suitable for storing metadata and capable of being stored and retrieved by a file system or a database. By way of example an object can be any data aggregation suitable for encapsulating information including but not limited to components attributes databases tables arrays variables binary large objects and the like. In a preferred embodiment the metadata blob which the metadata handler is configured to create and to read has sufficient data fields to store metadata used by many different file systems. Preferably the metadata handler supports at least Windows Unix Linux and Macintosh file systems and therefore the metadata blob that the metadata handler generates and reads has sufficient data fields to store some or all of the metadata used by these file systems. Alternatively the metadata handler can be configured to support any subset of two or more of the foregoing file systems or any group of two or more file systems that includes other known file systems.

As used herein the term file system encompasses traditional file systems such as Windows and Unix and further encompasses systems in which files are stored in one or more database records. A skilled artisan will appreciate that variations exist of the listed file systems and other file systems and that each variation may be treated as a separate file system. Alternatively in cases where variations use substantially similar metadata fields two or more variations may be treated as a single file system.

While it is preferable for the metadata blob to be able to store all of the metadata used by every supported file system the metadata blob can be configured to store only some of the metadata used by one or more of the supported file systems. For example several alternatives are that the metadata blob supports at least 2 3 4 5 6 7 or more file systems and stores every metadata field or at least 90 of the fields 80 70 60 50 or 25 of the fields used by the at least 2 3 4 5 6 7 or more supported file systems.

Advantageously the metadata blob stores sufficient information to allow the metadata handler to extract and store in data storage the metadata from the metadata blob even though each metadata blob may store differing metadata formats. For example the metadata handler may perform a first operation in which it extracts and stores the metadata stored in a metadata blob A having Unix metadata and perform a second operation in which it extracts and stores the metadata stored in a metadata blob B having Windows metadata. The metadata blob advantageously stores sufficient information to allow the metadata handler to perform each of these operations.

In a preferred embodiment the metadata blob includes a data field for every supported metadata field of every supported file system. In this embodiment for each file only data fields that correspond to the file system of that file are populated. Alternatively other data fields not used by the file system of the file are also populated but are either ignored or are used to store other information that the metadata handler does not store in the metadata . Advantageously this format simplifies the logic of the metadata handler .

Alternatively the metadata blob can include a file system identification field and a data field for the supported metadata fields of an identified file system. For example in this embodiment the metadata blob corresponding to a Unix file may have Unix in the file system identification field followed by metadata fields corresponding to Unix such as user group and other file access permissions. An advantageous of this alternative embodiment is that it reduces the size of each metadata blob because unpopulated fields are not used. A skilled artisan will appreciate however that this alternative requires additional logic in the metadata handler in order to generate and read multiple blob formats.

In another embodiment the metadata blob has a specific format for each file system but no file system identification field. When metadata blobs according to this embodiment are used the metadata handler is configured to recognize by differences in formatting which file system corresponds to each metadata blob . A skilled artisan will appreciate that still more complexity is needed in the logic of the metadata handler to support this type of metadata blob .

By way of example and not limitation a non exhaustive list of metadata fields that the metadata blob can store includes name description keywords access permissions size date and time created date and time modified whether the file is read only whether the file is archived and the like. A non exhaustive list of Windows metadata that the metadata blob can store includes DOS attributes Windows Security Descriptors Windows Access Control Lists ACLS etc. A non exhaustive list of Unix metadata that the metadata blob can store includes POSIX Access Control Lists Extended Attributes etc. A non exhaustive list of Macintosh metadata that the metadata blob can store includes Resource Fork shortcuts etc. A non exhaustive list of Linux metadata that the metadata blob can store includes POSIX Access Control Lists Extended Attributes etc. A skilled artisan will appreciate in light of this disclosure that many other metadata fields exist.

As indicated above in a preferred embodiment the metadata handler assists with preserving native metadata by generating and reading a metadata blob that encapsulates the metadata . In one embodiment the metadata handler comprises library functions including a GetBlob module and a SetBlob module . Preferably the GetBlob module is configured to retrieve file data and metadata corresponding to a specified file from data storage to extract the file from the file data to generate a metadata blob corresponding to the extracted file and to transmit the file and the metadata blob to a calling client application . Preferably the SetBlob module is configured to receive a file and a metadata blob from a calling client application to extract metadata from the metadata blob and store the metadata in the data storage and to store the file in the file data of the data storage .

In one embodiment the metadata handler interacts with the data storage using the APIs . The APIs comprise file system APIs for the host file systems in which the data storage resides and provide an interface for communicating with the host file system of the data storage retrieving files and associated metadata from the data storage and storing files and associated metadata in the data storage . In one embodiment the metadata handler performs these and other known file system operations by calling standard file system API functions. The APIs provided can include without limitation NAS APIs Windows APIs Unix APIs Macintosh APIs Linux APIs and the like.

It is expected that the metadata handler will be updated from time to time in order to read or generate metadata blobs that store additional metadata. This may occur for example when new file systems or file system variants are introduced which use additional metadata fields. After such an update has occurred the metadata handler may generate blobs of a different format. Accordingly after updates have occurred multiple blob versions may exist. To allow the metadata handler to continue to read all blob versions the metadata handler is preferably configured such that the SetBlob module can detect and read multiple blob versions. Additionally the GetBlob module can be configured such that it can selectively generate different blob versions. Such embodiments of the GetBlob module are advantageously able to communicate with previous versions of the metadata handler that may not recognize newer blob versions. In one embodiment however the GetBlob module generates a single blob version. One advantage of this embodiment is that it allows for simpler logic of the GetBlob module .

As described above embodiments of the GetBlob module and SetBlob module store and retrieve both file data and associated metadata . Alternatively or additionally the metadata handler can be configured to have separate library functions that allow storage and retrieval of metadata only or of file data only. Further as described above retrieving and storing file data generally involves little or no modification of the file data because file data is more often than metadata stored in standard formats that can be read by many operating systems or applications with little or no modification. Accordingly in one embodiment the metadata handler simply retrieves the file data and transmits it without modifying its format or conversely receives the file data and stores it without modifying its format. However a skilled artisan will appreciate in light of this disclosure that the metadata handler can be configured using principles described for the generation and reading of metadata blobs to also generate and read data blobs if desired or necessary to reduce or eliminate loss of data for native data stored on non native file systems.

In one embodiment the client applications communicate with the metadata handler send and receive files and blobs to and from the metadata handler by invoking the GetBlob module and SetBlob module and perform additional operations on the file and metadata blob . In one preferred embodiment the client applications each comprise one or more wrapper libraries . The wrapper libraries provide at least two public interfaces and to the GetBlob module and SetBlob module respectively. Preferably the public interfaces and include references to the library functions of the metadata handler rather than copies of those library functions. Advantageously this simplifies system maintenance by ensuring that if the library functions of the metadata handler are updated properly that the wrapper libraries will invoke the most current GetBlob module or SetBlob module without requiring constant modifications to the public interfaces and . Nevertheless in alternative embodiments the public interfaces and can include copies of the library functions.

Advantageously the GetBlob module SetBlob module and the public interfaces and allow the metadata handler to hide many implementation details from client applications that call the library functions of the metadata handler . For example to store a file and its associated metadata on a host storage device the client applications need not know the host storage device s file system. Rather the client applications merely invoke the SetBlob module using its public interface and provide the file and metadata blob for storage and the metadata handler invokes the appropriate APIs in order to store the file and metadata blob in the data storage of the host storage device. The GetBlob module and the SetBlob module are configured to work in a consistent fashion for any of the client applications regardless of whether the host storage device is a NAS device or operates on a Unix file system a Windows file system a Linux file system a Macintosh file system or any other file system.

Furthermore the GetBlob module SetBlob module and the public interfaces and allow the metadata handler to provide a consistent mechanism for storing any file that is native to any supported file system and the file s associated metadata while preserving the metadata such that it can later be read natively. The client applications need not know the implementation details of the GetBlob module and the SetBlob module in order to use this functionality.

Advantageously the GetBlob module and the SetBlob module and the public interfaces and allow the client applications to perform many file operations on the file and the metadata blob without knowing what native format the file and the metadata blob are in. Such operations include for example backup restore data migration and the like. Thus for example the client applications can perform backup operations to backup storage such as backup disk storage and backup tape storage .

In one preferred embodiment at least one of the client applications resides within the same host storage device as the data storage . Preferably however while the client applications may reside within the same host storage device the backup storage and are external to the host storage device. In one embodiment the backup storage and are connected to a separate computer or other device which is connected via computer network to the client applications .

As illustrated the File A Metadata and the File B Metadata can but do not necessarily have different metadata fields. This typically occurs for example when the File A Metadata is associated with a file of one file system and the File B Metadata is associated with a file of another file system. For example as illustrated the File A Metadata corresponds to Unix metadata including owner group and other file permissions. The illustrated File B Metadata corresponds to Windows metadata including DOS attributes such as Hidden and Read only. A skilled artisan will appreciate that the illustrated metadata fields are simplified and illustrative and do not include all metadata fields. Additionally while the File A Metadata and the File B Metadata are illustrated as having only the particular metadata fields corresponding to each file system in one embodiment the metadata stores many possible fields from different supported operating systems and populates the relevant fields. Accordingly in this embodiment the File A Metadata may have a field for storing the Hidden attribute and the Read only attribute but these fields are not populated because they do not correspond to a Unix file. Similarly the File B Metadata may have unpopulated owner group and other access permissions fields.

In one embodiment the metadata handler upon accessing the File A Metadata and the File B Metadata extracts the stored metadata generates a Metadata Blob A corresponding to the File A Metadata and a Metadata Blob B corresponding to the File B Metadata . In one embodiment as part of generating the Metadata Blob A and the Metadata Blob B the metadata handler determines which fields of each blob to populate extracts appropriate metadata values for populating such fields from the File A Metadata and the File B Metadata and stores the values in the appropriate metadata fields. As illustrated in one embodiment the Metadata Blob A and the Metadata Blob B have additional metadata fields beyond those necessary for storing the particular metadata that applies to each file. Preferably the Metadata Blob A and the Metadata Blob B have sufficient fields to be able to store any possible metadata for any of the file systems supported by the metadata handler . This is not a requirement however. Alternatives exist as described above in the Metadata Blob section.

Upon determining how to populate the File A Metadata and the File B Metadata the metadata handler interacts with the APIs in order to request that the File A Metadata and the File B Metadata be created and stored in the data storage . The APIs in turn create and store the File A Metadata and the File B Metadata .

As illustrated by the metadata handler advantageously can both generate and read metadata blobs that store metadata associated with two or more file systems. Accordingly the metadata handler encapsulates and abstracts the functions of storing and retrieving metadata in a way that preserves metadata and prevents or reduces loss when such metadata is transmitted across or stored on non native file systems. This allows the client applications to rely on the storage and retrieval functions of the metadata handler and to provide for the preservation of metadata without requiring the client applications to know the structure of native metadata for files of multiple file systems. Indeed the client applications can access the metadata handler in order to perform storage retrieval and data migration operations on files and metadata without even knowing the file system of each file.

In the illustrated backup operation the backup application invokes the GetBlob module of the metadata handler using a GetBlob wrapper function . The GetBlob wrapper function requests a file such as for example File A. The metadata handler receives the file request and in cooperation with the APIs retrieves the File A from the file data and generates a Metadata Blob A based on information in the metadata that corresponds to File A. The metadata handler returns the File A and the Metadata Blob A to the backup application . The backup application backup application stores the File A and the Metadata Blob A on the external tape data storage . As illustrated by a segment of tape this process can be repeated for multiple files such as a File B and a File C such that the external tape data storage can backup multiple files. Advantageously the files stored on the external tape data storage may be of different file systems. Advantageously the backup application can store each of these files and their associated metadata without knowing which file system pertains to each file. Furthermore the backup application or a different backup application can use the metadata handler to restore the files and their associated metadata with reduced loss or no loss of data to the data storage or to different data storage without knowing the file system of each file.

In the illustrated restore operation the backup application retrieves a file and an associated metadata blob from the external tape data storage . The backup application invokes the SetBlob module of the metadata handler using a SetBlob wrapper function . The SetBlob wrapper function provides the retrieved file and associated metadata blob as input to the SetBlob module of the metadata handler . The metadata handler receives the file and associated metadata and in cooperation with the APIs stores the file in the file data of the data storage unpacks the associated metadata from the metadata blob and stores the associated metadata in the metadata of the data storage .

Other hardware configurations can also use the metadata handler to perform restore operations. For example similar to the backup operation of a restore operation can be controlled by a backup server that is external to the backup application .

A data migration operation is an operation in which data is copied or moved from one host data storage device to another. is a block diagram illustrating how two or more metadata handlers in accordance with one embodiment can be used to support a data migration operation. The illustrated data migration operation transfers a file from a first NAS device to a second NAS device . The first NAS device has or is in communication with a first metadata handler a first data storage one or more first APIs and a first data migration application . The first NAS device can optionally also have or be in communication with a first identification resolver . The second NAS device has or is in communication with a second metadata handler a second data storage one or more second APIs and a second data migration application . The second NAS device can optionally also have or be in communication with a second identification resolver . The Identification Resolvers section below describes the first identification resolver and the second identification resolver .

As illustrated the data migration operation proceeds as follows. A GetBlob wrapper function of the first data migration application requests a file such as File A by invoking a GetBlob module not shown of the first metadata handler . The GetBlob module cooperates with the first APIs to retrieve the File A and associated metadata from file data and metadata of the first data storage . The first metadata handler generates from the information retrieved from the metadata Metadata Blob A . The first metadata handler returns the File A and the Metadata Blob A to the GetBlob wrapper function . Optionally as part of transmission of the File A and the Metadata Blob A to the GetBlob wrapper function the File A and the Metadata Blob A are processed by the first identification resolver as described in the section Identification Resolvers. 

The first data migration application transmits the File A and the Metadata Blob A to the second data migration application . A SetBlob wrapper function of the second data migration application requests the second metadata handler to store the File A and its associated metadata by invoking a SetBlob module not shown of the second metadata handler . The SetBlob wrapper function provides the File A and the Metadata Blob A to the SetBlob module as input. Optionally as part of transmission to the second metadata handler the File A and the Metadata Blob A are processed by the second identification resolver as described in the section Identification Resolvers. The SetBlob module of the second metadata handler cooperates with the second APIs in order to store the File A in file data of the second data storage to extract metadata from the Metadata Blob A and to store the extracted metadata in metadata of the second data storage .

For many file systems metadata associated with each file includes access permissions and other metadata that depends at least in part on identifying a particular user. For example Unix uses a UID user identifier to identify users and to assign file owners and associate permissions with files. Windows similarly uses an SID security identifier . Under some circumstances data migration operations such as the operation described above in the section Data Migration Operations can alter permissions that depend on such UIDs and SIDs. This is because UIDs and SIDs are not guaranteed to be unique. Accordingly an SID that corresponds to Alice Jones in one Windows domain may correspond to Bob Smith in a different Windows domain. Furthermore Alice Jones may have an SID of 100 in one Windows domain but an SID of 200 in a different Windows domain.

Accordingly in order to reduce or eliminate modifications or corruption of permissions that occur as a result of a data migration operation embodiments of the systems described herein have an identification resolver such as the first identification resolver and the second identification resolver . In one embodiment during a data migration operation the first identification resolver receives a File A and a Metadata Blob A . Part of the Metadata Blob A includes a user identifier such as an SID or a UID. The first identification resolver converts the user identifier for example to a full user name such as for example Alice Jones. The first identification resolver does this for example by looking up user information in a central database such as one maintained by a Windows primary domain controller. One function for looking up such information is the getpwdent function. Any function suitable for retrieving a full user name based on a user identifier can be used. The first identification resolver stores the full user name as part of the Metadata Blob A .

On the other end of the data migration operation the second identification resolver performs an inverse operation to determine a local user identifier. For example the second identification resolver may query a central database such as one maintained by a Windows primary domain controller to determine which user identifier pertains to Alice Jones. Since the second NAS device may exist in a different Windows domain Alice Jones may have a different user identifier and the second identification resolver may determine that this user identifier is 200. The second identification resolver modifies the Metadata Blob A to reflect Alice Jones 200 user identifier in this local domain. Advantageously this reduces or eliminates the chances that the File A will have associated metadata that is incorrect for the local domain in which the second NAS device resides.

A skilled artisan will appreciate in light of this disclosure that the preferred embodiments described herein and other embodiments that are apparent to a skilled artisan can be implemented with some degree of flexibility. For example while the systems described herein are generally described as being implemented in software executed on one or more hardware devices a skilled artisan will appreciate in light of this disclosure how to implement equivalent systems in any combination of hardware software and firmware. For example any module described herein could be implemented in any combination of hardware software and firmware. For a software implementation a module comprises a logical grouping of one or more computer executable instructions that collectively define a function or other algorithm that is performed by a processor when the processor executes the instructions. For a hardware implementation a module comprises a configuration of logic gates and other circuits configured to performed a function or other algorithm.

Additionally while separate functions are sometimes described herein as being performed by separate modules a skilled artisan will appreciate in light of this disclosure that any two modules can be combined into a single module and that any one module can be divided into two modules without departing from the principles described herein. All such modifications and any other modification that is apparent to a skilled artisan in light of this disclosure are within the scope of this disclosure.

In light of the foregoing a skilled artisan will appreciate that the invention is not limited to the preferred embodiments. For example some of the features and components described herein are preferred but not required and can be omitted from certain embodiments. Accordingly only the following claims whether originally presented or added by amendment or in any subsequent application set forth the limitations of the invention.

