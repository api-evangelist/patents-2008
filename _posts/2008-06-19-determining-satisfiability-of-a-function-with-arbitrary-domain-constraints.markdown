---

title: Determining satisfiability of a function with arbitrary domain constraints
abstract: A function can be represented as a canonical decision diagram structure. Each vertex of the diagram is associated with a respective function variable. The vertices include at least one vertex that represents a domain of more than two values for the variable associated with the vertex. The decision diagram is used to evaluate the function to determine whether the function is satisfiable or unsatisfiable for given values of the variables.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08001072&OS=08001072&RS=08001072
owner: Microsoft Corporation
number: 08001072
owner_city: Redmond
owner_country: US
publication_date: 20080619
---
The classic Boolean satisfiability problem can be generally stated as follows for a given Boolean function of variables determine whether it is possible to assign values to the variables such that the function is satisfied that is the function evaluates to true or whether no such assignment exists. The Boolean satisfiability problem is of significance in both theoretical research and in practical applications such as artificial intelligence planning circuit testing software verification and database validation.

The satisfiability problem can be solved by representing the Boolean function as a directed acyclic graph DAG where each vertex of the DAG represents a variable assignment with the exception of two sink nodes. One sink node represents false function results e.g. binary zero and the other sink node represents true function results e.g. binary one . Each vertex of the DAG likewise has a binary domain. Generally speaking the function is satisfiable if there is a path through the DAG from a root node to the one sink the true node .

The amount of time and resources needed to determine satisfiability of a function using a DAG such as that just described increases as the number of variables in the function increases. A more efficient approach that saves time and resources would be valuable.

Instead of constructing a decision diagram where each vertex has only a binary domain a decision diagram that has at least one vertex representing a domain of more than two values can be constructed.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Some portions of the detailed descriptions which follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present application discussions utilizing the terms such as accessing representing evaluating mapping transforming deriving determining or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments described herein may be discussed in the general context of computer executable instructions residing on some form of computer usable medium such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.

According to embodiments described herein the classic Boolean satisfiability problem can be efficiently solved. In overview a function can be represented as a canonical decision diagram structure. Each vertex of the diagram is associated with a respective function variable. The vertices include at least one vertex that represents a domain of more than two values for the variable associated with the vertex. The decision diagram demonstrates whether the function is valid satisfiable or unsatisfiable.

In one embodiment logical functions are represented using the hierarchy shown in . All classes are immutable with the exception of the knowledge base class which aggregates facts. In the example of a term TermExpr and a term TreeExpr are forms of the Boolean expression BoolExpr. The term TermExpr exposes in its T Identifier property either a DomainConstraint or a DomainVariable in the latter case the term is treated as a Boolean variable with domain true false. The terms NotExpr AndExpr and OrExpr are forms of the term TreeExpr. 

Generally speaking the system includes at least some form of computer usable media. Computer usable media can be any available media that can be accessed by the system . By way of example and not limitation computer usable media may comprise computer storage media and communication media.

Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM electrically erasable programmable ROM EEPROM flash memory or other memory technology compact disk ROM CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can accessed by the system . Any such computer storage media may be part of the system . The memory removable storage and non removable storage are all examples of computer storage media.

Communication media can embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media. The communications connection s is an example of communication media.

The system may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. All these devices are well know in the art and need not be discussed at length here.

The system may operate in a networked environment using logical connections to one or more remote computers which may be a personal compute PC a server a router a network PC a peer device or other common network node and which may include many or all of the elements described above relative to the system . The logical connections may include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When used in a networking environment the system can be connected to the network through the communication connection s .

In the example of the memory includes computer readable instructions data structures program modules and the like associated with a satisfiability solver application programming interface API . However the satisfiability solver API may instead reside in any one of the computer storage media used by the system or may be distributed over some combination of the computer storage media.

An example of a decision diagram is shown in which is described further below. Continuing with reference to the decision diagram is canonical in the sense that all functionally equivalent definitions are represented in the same manner. More specifically in one embodiment the decision diagram has the following properties 

Generally speaking in contrast to conventional decision diagrams in which variables have only a binary domain the satisfiability solver described herein improves efficiency by representing functions as decision diagrams in which variables have arbitrarily sized domains. As a simplification domain constraints that are always true can be set to 1 while domain constraints that are always false can be set to 0 in which case variables with domains of size 0 or 1 are disqualified from consideration.

As noted above the decision diagram is ordered. Vertices in the decision diagram have the following structure 

The function s variables may have a continuous domain. If so then before the function is decomposed into a decision diagram the function is first mapped to a different representation in which the function is represented using Boolean expressions of variables that have discrete finite domains D 1 2 . . . f. More specifically a relational expression of the form variable equal to not equal to less than greater than less than or equal to greater than or equal to a constant can be mapped to a discrete domain by examining all of the constants used with respect to a variable and then decomposing the continuous domain into a series of discrete domains linked by Boolean expressions.

In one embodiment a normal form e.g. a disjunctive normal form and or a conjunctive normal form of the function can be derived from the decision diagram . This is discussed further below in conjunction with .

In block a function to be evaluated is accessed from memory. The function includes some number of arguments variables some or all of which may have a continuous domain.

In block if the function includes variables with a continuous domain then the function is represented in a different form function of in which the variables have discrete domains as previously described herein.

In block of the function is transformed by mapping each of its expressions to a respective if then else statement. A mapping of expression to if then else form is shown in Table 1.

In block each if then else statement is transformed into a vertex of the decision diagram . In one embodiment the following recursive function is used to affect the transformation from if then else form to vertex 

In the above EvaluateFor evaluates a vertex for a particular value of the variable corresponding to that vertex. In essence a vertex representing the function when the variable value is bound to the particular value is returned. EvaluateFor can be implemented as follows 

In the implementation just described one child is generated for each member of the variable domain in contrast to conventional implementations that generate a fixed pair of children. Each vertex can be viewed as defining the Shannon decomposition of the function at the vertex on the vertex s variable.

In the implementation above IfThenElse will return a vertex that evaluates to true if and only if the given if then else statement evaluates to true and that the ordering invariant is preserved. With a canonical vertex representation a single instance of any function will exist by remembering all vertices and returning an existing equivalent vertex where one exists according to CreateVertex. 

As previously noted herein the resulting decision diagram is used to evaluate the function to determine whether the function is valid satisfiable or unsatisfiable for given values of the variables. To determine validity satisfiability unsatisfiability the decision diagram generated in block is merely examined. All unsatisfiable functions resolve to 0 and all valid functions resolve to 1 otherwise the function is satisfiable but not valid.

The structure is generated as described above and satisfies each of the properties presented above in conjunction with . In the example of the vertex corresponds to the variable v and the vertices and correspond to the variable v. Looking at vertex for instance the outgoing edge is associated with v in the domain and the outgoing edge is associated with v in the domain . The edge can be alternatively represented as two edges one for the domain and one for the domain . The structure can be used to evaluate the function v v to determine whether the function is satisfiable or unsatisfiable for given values of the variables. In the example of the function is satisfiable for the following variable assignment v in v in and v in v in .

The normal form of the function can be derived from the decision diagram derived in block of . A disjunctive normal form can be read directly from the decision diagram where every clause corresponds to a path from the root to the true node. In other words every variable combination that results in the function being satisfied is a clause in the disjunctive normal form. The example of can be used to demonstrate the derivation of the disjunction normal form. As already mentioned the following paths lead to the true node v in v in and v in v in . The disjunctive normal form is therefore v in AND v in OR v in AND v in .

The conjunctive normal form can be readily derived as well by considering the disjunctive normal form of the negation of the function or the set of all paths that lead to the false node v in v in v in v in and v in resulting in v in AND v in OR v in AND v in OR v in . Taking the negation of the negated function and pushing down the not yields the conjunctive normal form the literals are the same but the constraint ranges are inverted v in OR v in AND v in OR v in AND v in .

In summary for a class of functions taking n arguments and returning either true or false the satisfiability solver described herein can efficiently determine whether any assignment to those variables will return true. In particular the satisfiability solver can handle functions that can be represented in the following grammar 

By virtue of this concise grammar fairly involved queries can be answered for instance whether given facts imply some statement. Given a knowledge base a determination can be made whether a query is always true entailment . One practical use of the satisfiability solver described herein is in the ADO.NET Entity Framework by Microsoft in particular to validate relational database to object mappings.

In the foregoing specification embodiments have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicant to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

