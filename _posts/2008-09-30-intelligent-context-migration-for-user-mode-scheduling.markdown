---

title: Intelligent context migration for user mode scheduling
abstract: Performing directed switches between user mode schedulable (UMS) threads and primary threads enable proper execution of the UMS threads. A primary thread user portion is switched to a UMS thread user portion so that the UMS thread user portion is executed in user mode via the primary thread user portion. The primary thread is then transferred into kernel mode via an implicit switch. A kernel portion of the UMS thread is then executed in kernel mode using the context information of a primary thread kernel portion.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321874&OS=08321874&RS=08321874
owner: Microsoft Corporation
number: 08321874
owner_city: Redmond
owner_country: US
publication_date: 20080930
---
This application is related to concurrently filed U.S. patent application Ser. No. 12 242 648 entitled Transparent User Mode Scheduling on Traditional Threading Systems which is incorporated herein by reference.

User mode scheduling enables processes to switch user threads for better concurrency and control. User mode schedulable UMS threads are divided into distinct user and kernel portions. However the division of a UMS threads into a user portion and kernel portion may cause difficulties during thread execution.

This Summary is provided to introduce a selection of concepts in a simplified form that is further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Described herein are embodiments of various technologies for directed switches for the proper execution of UMS threads. In at least one embodiment a user portion of primary thread is switched to a user portion of a UMS thread so that the user portion of the UMS thread may be executed by the primary thread in user mode. The primary thread may then transfer into kernel mode via an implicit switch. A kernel portion of the UMS thread is then executed in kernel mode using the context information migrated from the kernel portion of the primary thread that was executing the user portion of the UMS thread prior to entry into kernel mode. Other embodiments will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings.

This disclosure is directed to embodiments of directed switches for the proper execution of user mode schedulable UMS threads. In a multi processor environment the UMS threads are program threads that may be executed by one or more central processor units CPUs in the context of an operating system process. The UMS threads are similar to process threads currently in use on computing platforms in that each UMS thread includes a kernel portion and a user portion.

The execution of a typical process thread may involve the recurring processing of the kernel portion of the thread in kernel mode in conjunction with the recurring processing of the user portion in user mode and the automatic switching between the two modes. In contrast due to the unique architecture of the computing platform on which the UMS threads are executed the operating system does not generally switch to the user portion of UMS threads to cause them to execute in user mode. In other words the user portion of a UMS thread is normally not directly executed by the operating system. Instead inside the application running in user mode the user portions of UMS threads are switched with the user portions of special threads which are referred to herein as primary threads.

In turn the user portions of the primary threads may then be executed in user mode. However this substitution of a primary thread user portion by a UMS thread user portion may create a mismatch of identities between the primary thread user portion and the kernel portion of the UMS thread once the primary thread executing on behalf of the user portion of UMS thread returns to kernel mode. This is important since state required to execute properly in kernel mode is attached to the kernel portion of the UMS thread. For example but not as a limitation such states may include security context. Accordingly a process referred to as a directed switch may be performed to remedy such mismatches and provide smooth transition between the user portion and the kernel portion of the UMS thread and vice versa. In some instances such directed switches may be optimized to increase performance speed and reduce the use of processing resources. Further directed switches may enable UMS threads to be executed transparently in an operating system that is in the same way as standard threads. The embodiments described herein are directed to the implementations and optimizations of directed switches. Accordingly various examples of directed switch implementation and optimization are described below with reference to .

Each of the threads in the exemplary multi processor environment comprises a kernel portion that resides in kernel mode and a user portion that resides in user mode . The kernel and user modes are standard ways of dividing the execution of threads in a computer system between operating system activities such as activities performed by an operating system OS kernel and application activities such as those performed by a user s program. In various embodiments kernel mode is implemented by the operating environment for a kernel of an operating system i.e. the OS kernel. Kernel mode is generally a privileged mode of operation with direct access to the hardware resources in the machine. Generally speaking the OS kernel is responsible for managing a computing system s resources i.e. hardware and software components . As a basic component of an operating system the OS kernel provides the lowest level abstraction layer for computing resources e.g. memory processors and I O devices that an application needs to control for the performance of various functions.

For example the UMS thread may include a kernel portion and a user portion . Likewise the primary thread may include a kernel portion and a user portion . Additionally the standard thread may include a kernel portion and a user portion .

Moreover the kernel and user portions of each thread in the exemplary multi processor environment may also include additional memory structure. For example the kernel portion may include a kernel stack registers and a kernel structure that describes the kernel portion which is the kernel thread descriptor . Furthermore the user portion may include a user thread descriptor which is a block of memory in the user portion . The user portion may further include registers and a user mode stack .

It will be appreciated that the UMS thread is distinguishable from a standard thread such as the standard thread . In various embodiments a UMS thread may differ from a standard thread in that the scheduling assignments of CPUs to the UMS kernel portion and the UMS user portion may be independently managed by an application while the kernel and user portions of a standard thread generally are assigned in unison. Thus while switching between the kernel portion and the user portion of the standard thread usually occurs implicitly during thread execution on a central processing unit CPU the UMS thread may provide applications with the ability to control the switch between the various user portions of its threads during execution. This capability allows applications to achieve higher performance because it is not always necessary to also switch the kernel portions of threads.

The UMS threads such as the UMS threads and may be created from standard threads such as standard thread . In embodiments where the multi processor environment is running on IA 64 Itanium CPU architecture for example the creation of a UMS thread may involve the use of a special pointer to the UMS states that are stored in the user thread descriptor of the UMS thread. The special pointer may be stored in a register that is accessible by other threads.

Alternatively in embodiments where the multi processor environment is running on one of an x86 and x64 CPU architecture the creation of a UMS thread may involve the use of a segment selector that points to the user thread descriptor of the UMS thread. Accordingly the special pointer and or the segment selector of a UMS thread may enable other threads such as the primary threads to access the states of the UMS thread as stored in its corresponding user thread descriptor.

The primary threads such as primary thread and the may act as virtual processors for an application. In some embodiments the number of primary threads present in the multi processor environment may correlate with the number of CPUs present in the environment. For example the primary thread may execute on the CPU while the primary thread may execute on the CPU . However in other embodiments the number of primary threads present may be greater or fewer than the number of CPUs in the multi processor environment .

A primary thread may act as virtual processor for executing the user portions of a UMS thread. For example but not as a limitation an application running the user portion of primary thread on the CPU can switch execution to the user portion of the UMS thread . The application can subsequently switch to execution other user portions of its threads without any intervention from the OS kernel.

In various embodiments a primary thread may be constructed from a standard thread such as an NT thread with the addition of an extra state. Thus a primary thread may convert back and forth from a standard thread based on application resource availability and scalability requirements.

As shown in the exemplary UMS thread may include a kernel portion that resides in kernel mode and a user portion that resides in user mode . It will be appreciated that the execution of the UMS thread differs from the execution of the standard thread . Standard thread processing is generally dependent on the automatic that is implicit switch between a kernel portion of a thread and a user portion of a thread. For example during the execution of the standard thread a CPU may process the kernel portion of the standard thread in kernel mode . Subsequently the CPU may change from kernel mode to user mode by automatically switching from the kernel portion of the standard thread to the user portion . The user portion of the standard thread is then further processed in user mode. Additionally when the execution is to be switched to the user portion of another standard thread the current user portion needs to switch to its kernel portion which then switches to the kernel portion of the next standard thread to run. The kernel portion of the next standard thread may also further switch to its user portion in the same manner. Typically this also involves processing kernel data structures shared across the system in order to select the next thread for execution.

However during the processing of a UMS thread the kernel portion of the UMS thread is generally not required to switch to the user portion of another thread. The prevention of automatic switching from a user portion to a kernel portion of a UMS thread during processing is a fundamental principle of the UMS computing architecture. This architecture may enable computer applications to have greater control over the concurrency and efficiency of threads in both single processor and multi processor environments.

Instead the UMS threads may use alternative implementations to perform tasks in user mode . A particular alternative implementation is illustrated in with respect to the UMS thread . As shown the CPU has performed the necessary tasks for the kernel portion of the UMS thread . Accordingly the UMS thread is ready to switch to user mode . At this point the kernel portion of the UMS thread may cause user portion of the UMS thread to queue to a UMS completion list . The UMS completion list is a UMS data structure on which the OS kernel queues user portions of the UMS threads that are ready for execution in user mode . Applications may then retrieve the UMS threads from the UMS completion list for execution.

Subsequently the kernel portion of the UMS thread may place itself in a parked state i.e. a type of ready waiting state . The queuing of the user portion may be observed by a user mode scheduler . In some embodiments the completion list may include an object that informs the user mode scheduler that a thread has been queued.

In various embodiments the user mode scheduler may be configured to pull threads from the UMS completion list . In one embodiment the user mode scheduler may periodically check the completion list for threads that have been queued in user mode. In another example the user mode scheduler may only check the completion when it is informed that a thread has been queued to the completion list through an asynchronous notification event.

During the pulling of the UMS thread the user mode scheduler may cause the user portion of the primary thread to switch to the user portion of the UMS thread . In various embodiments the switch may be accomplished by saving the context state of the user portion and loading the context state of the user portion as queued in the completion list . In at least one such embodiment the transfer of context state of the user portions and includes the switching to the user thread descriptor of the UMS thread using one of the pointer or the segment selector . Subsequently the user thread may execute in user mode in place of the primary thread .

In other embodiments the queuing of the user portion of the exemplary UMS thread as well as the placement of the kernel portion in a parked state may also occur during creation of a UMS thread. UMS thread creation refers to the conversion of a process thread such as standard thread into a UMS thread such as the UMS thread . During the UMS thread creation the UMS thread may perform kernel side initialization of its kernel portion . Next the kernel portion may cause the user portion of the UMS thread to be queued to the completion and then park the kernel portion of the UMS thread in a waiting state.

At some point in the execution of the user portion of UMS thread the user portion may need to re enter kernel mode and switch to its kernel portion . In various instances this need may arise due to the occurrence of one of the operations . The operations may include a system call synchronous entry into kernel mode an exception asynchronous entry into kernel mode or an interrupt asynchronous entry into kernel mode . As used herein synchronous refers to a situation where entry to kernel mode is synchronized with the execution design of the user portion and thus only a certain portion of the information in a register of a UMS thread needs to be saved and later re loaded while asynchronous refers to a situation where the execution of the user portion is interrupted essentially at a random point and thus all the information in the register is critical to entry of kernel mode. It will be appreciated that while system calls and exceptions are thread specific interrupts are not specific to any thread.

The switch from the user portion of UMS thread to the kernel portion may need special steps that are not necessary for the implicit switch from the user portion to the kernel portion of a standard thread . To provide isolation between application and operating system execution user mode and kernel mode provide special register state to reduce how much saving and loading is required when switching from the user portion of a standard thread to the kernel thread such as providing a separate register pointing to the kernel mode stack . These special facilities in the CPU architecture make some of the state save restore when switching between the user and kernel portions of the same thread implicit .

However in the instance of the primary thread an implicit switch does not produce the desired result because the user portion of the primary thread has been replaced by the user portion of the UMS thread . In other words as far as the OS kernel last knew the state of what was running in user mode on the processor it was the user portion of the primary thread . This is because a switch from user portion to the user portion in the UMS thread can occur without the awareness of the OS kernel. Thus when the user portion enters kernel mode the implicit switch will take it to the kernel portion of the primary thread . However since the user portion was really replaced by the user portion of the UMS thread the user portion will actually enter kernel mode .

Accordingly when the user portion of UMS thread not the user portion of the primary thread enters kernel mode the OS kernel that is expecting the user portion of primary thread may detect the mismatch based on the identities of each user portion. For example the OS kernel may detect the mismatch via a sentry . The sentry is further described below with respect to . In various embodiments the identity of each user portion of each thread which is part of the context information of each thread may be stored in the kernel thread descriptors. For example the identity of the UMS thread may be stored in its thread descriptor while the identity of the primary thread may be stored in its corresponding kernel thread descriptor not shown .

For correct operation of the system the OS kernel needs to handle this case where the implicit switch will run the kernel portion of the wrong thread. Therefore in the example of the UMS thread the OS kernel may switch from the kernel portion of the primary thread to the kernel portion once the UMS thread enters kernel mode . This cross thread switching process is referred to as a directed switch. Thus directed switches may enable UMS threads to be executed transparently in an operating system that is in the same way as standard threads.

In various embodiments the directed switch may be facilitated by a sentry and a sentry . The sentry may be a piece of code that resides in kernel mode for each primary thread such as primary thread . Likewise the sentry may be a piece of code that resides in kernel mode for each UMS thread such as UMS thread . In other words the sentries and are code algorithms that run synchronously with each thread execution.

The sentry may check primary thread components that come into kernel mode . For example but not as a limitation the sentry may check to see whether a primary thread is entering kernel mode on its own behalf or whether the primary is entering kernel mode while running as a UMS thread such as the UMS thread . In some embodiments the sentry may make this determination by ascertaining whether the identity e.g. identification information in the user thread descriptor of the user portion of the primary thread matches the identity of the kernel portion of the primary thread .

When the sentry detects that the kernel portion of the primary thread is running on behalf of the user portion of another thread such as the kernel portion running on behalf of the user portion a directed switch needs to be performed. The directed switch will rectify the mismatch and make it so that the kernel portion of UMS thread is running on behalf of the user portion of the UMS thread .

During the directed switch the CPU and register states of the UMS thread are initially saved to a memory stack such as the kernel stack as context information . In various embodiments the actual amount of the CPU and register states saved to the memory stack may depend on whether the primary thread entered kernel mode as a result of a synchronous or asynchronous event as described above. Moreover in at least one embodiment the saved context information may also include data on the size of the context information . For example in a synchronous event a user code generally knows what to expect on return from the call to the kernel in terms of processor state. Thus during the occurrence of system calls volatile register states do not generally need to be saved to the memory stack.

Once the context information has been saved the kernel portion of the primary thread may prepare a pointer to the context information . The pointer may enable another thread to locate the context information . The primary thread may then deliver the pointer to the kernel portion of the UMS thread .

Subsequently the UMS thread may replace its context information with the context information . The UMS thread may accomplish this replacement via a copy and override operation. In at least one embodiment the UMS thread may replace the context information utilizing data on the size of the context information . Following the replacement of context information the kernel portion of the UMS thread will not retain any memory that was previously in a parked state. Subsequently the UMS thread may be executed by a CPU in kernel mode . It will be appreciated that since only the UMS thread is executed in kernel mode the primary thread does not actually need to retain any knowledge regarding the nature of the request e.g. system call exception etc. that made it enter kernel mode . Moreover following the replacement of the context information the primary thread may be disassociated from the UMS thread . In various embodiments the UMS thread may go into a blocked state following execution in kernel mode . Further in at least one embodiment the UMS thread may exit its blocked state when called upon by the user mode scheduler to perform another execution. In some embodiments the user mode scheduler may choose to switch to the user portion of the UMS thread so that the user portion may be executed.

As shown the primary thread may automatically wake up if the UMS thread becomes blocked i.e. enters into a blocked state or goes back into a parked state e.g. when execution of the kernel portion is completed or otherwise gives up its use of the CPU in some manner. For example but not as a limitation the UMS thread may enter into a blocked state when it has to perform data retrieval from a remote memory location that results in a long latency stall. In other examples the kernel portion of the UMS thread may return itself to a parked state.

In such instances kernel queues may wake up the primary thread. In various embodiments a kernel queue is a mechanism that may be configured to monitor system operations and registers events. The kernel queue may also notify appropriate components of changes to the system operation and register events. Upon waking up the kernel portion of the primary thread may clear itself of the register states that are associated with the UMS thread . In some embodiments having cleared its register states the primary thread may switch to its own user portion and enter the user mode scheduler which may then switch to a UMS threads user portion such as user portion for processing in user mode .

When the UMS thread is ready to exit user mode the UMS thread may activate the sentry to detect whether the kernel portion of the primary thread has exited kernel mode . For example as described in the primary thread may exit kernel mode to switch to another thread.

If the sentry detects that the primary thread has already exited kernel mode the sentry may send the user portion of the UMS thread into the UMS completion list . At that time the context information of the user portion may be extracted to a memory such as the user stack . In some embodiments a primary thread such as the primary thread may subsequently schedule another switch of the user portion with the user portion of a primary thread so that the execution described above may be repeated again.

However if the sentry detects that the primary thread has not exited kernel mode the sentry may not send the user portion of the UMS thread into the UMS completion list . Instead in some embodiments the UMS thread may undergo the optimization described below with respect to

It will be appreciated that while only a single primary thread is depicted in the there may be one or more primary threads in the multi processor environment . Accordingly a primary thread other than the primary thread may return to the user mode scheduler in user mode . In turn the user mode scheduler may switch the primary thread s user portion with the user portion of UMS thread that had been put on the completion list .

As further described above the UMS thread is normally prevented from execution in user mode . In other words the kernel portion of the UMS thread is normally prohibited from switching to its corresponding user portion . Instead when the processing of the kernel portion is completed the user portion of the UMS thread is transferred to the UMS completion list so that it may be picked up by the user mode scheduler running on a primary thread. This is to avoid over subscribing the CPU resources on the system.

However when the UMS thread is not blocked in kernel mode and the primary thread is also still present in kernel mode after having been released after the context switch the optimization described in may allow the UMS thread to enter user mode .

As shown the sentry may be configured to determine whether the primary thread is still in kernel mode in the event that the kernel portion attempts to exit from kernel mode to user mode . More specifically the sentry may check whether the kernel portion of the primary thread is still present in kernel mode after it has been released after the context switch. If that is the case the sentry may permit the UMS thread to exit into user mode and perform operations via its user portion . In essence the UMS thread is permitted to act as a standard thread such as the standard thread . Otherwise the sentry will not permit the UMS thread to exit into user mode .

Furthermore when the sentry decides to deny permission for the UMS thread to exit into user mode the sentry may place the user portion into the UMS completion list . Also the kernel portion of the UMS thread may park itself. Additionally because the kernel portion of the primary is no longer in kernel mode the primary thread may have cleared its states and switch to the user portion of another UMS thread such as user portion to execute in user mode .

When the UMS thread exits to user mode the UMS thread is nevertheless susceptible to being blocked. However the UMS thread may only be blocked in kernel mode . Thus if the UMS thread is to be blocked while it is in user mode e.g. in response to a page fault a system call etc. the UMS thread may re enter kernel mode . Moreover such a blocking action will also release the primary thread from its association with the UMS thread if the primary thread was not previously released.

Once the UMS thread re enters kernel mode the UMS thread may be subject to the same check by the sentry when it once again attempts to exit from kernel mode to user mode . As described above the outcome of this check is either the UMS thread being permitted to exit into user mode if primary thread is still present in kernel mode or the user portion of the UMS thread being queued to the UMS completion list if primary thread is not present in kernel mode . It will be appreciated that during the optimization described in the UMS thread may freely move back and forth between kernel mode and user mode to carry out processing so long as the primary is present in kernel mode . This avoids the repeated cost of directed switch if the UMS thread is generally performing non blocking work.

Thus in order to ensure that the primary thread is in kernel mode under the first scenario and not the second scenario the sentry may check a thread sequence number given to the kernel portion of the UMS thread against a thread sequence that is given to the kernel portion of the primary thread . In various embodiments if the thread sequence number matches the thread sequence number then the sentry may permit the UMS thread to enter into user mode and perform operations via its user portion . However if the thread sequence number does not match the thread sequence number the sentry will not permit the UMS thread to enter into user mode . It will be appreciated that it is not an incorrect behavior if the UMS thread enters into user mode when the sequence numbers and does not match. However such an occurrence would not be the best mode of operation as an extra thread will be running on the multi processor environment .

Moreover if the UMS thread completes kernel mode execution without blocking and continues to execute the user portion of UMS thread the UMS thread may then perform a voluntary disassociate operation to revert to the primary thread in user mode. Since the yield operation is executing on the UMS thread in user mode the yield operation requires assistance from the OS kernel. Accordingly such a voluntary yield may be referred to as a kernel assisted yield and may be made by the UMS thread running its user portion as the UMS thread enters a co operative yield point. It will be appreciated that the kernel assisted yield is necessary for the proper operation of the UMS thread. Otherwise the kernel portion of the UMS thread may begin to behave like a primary thread i.e. it will be executing the user portion of other threads . This may pose a difficulty for some embodiments as it is expected when the user portion enters kernel mode on some kernel thread that the kernel portion of the user thread is available for a directed switch.

The kernel assisted yield is illustrated in the context of primary thread and the UMS thread . As shown in and b the kernel assisted yield may occur after the primary thread has switched to the UMS thread the UMS thread has replaced its own context information with the context information of the primary thread and the primary thread has been suspended and released from its association with the UMS thread . As described above these steps are performed after the primary thread has entered into kernel mode so that the kernel portion of the primary thread may be switched with the kernel portion of the UMS thread for proper execution.

Thus as shown in when the UMS thread attempts to exit from kernel mode the sentry will block the kernel portion of the UMS thread from exiting into user mode thereby causing the kernel portion to park that is enter into a waiting state. Moreover the sentry will also move the user portion of the UMS thread to the UMS completion list . In certain instances the blocking of the kernel portion will cause the kernel queues to wake up the primary thread from its blocked state if it is not already awake.

When the primary thread wakes up the kernel portion of the UMS thread will inform the primary thread that it should pick up UMS thread for execution. This information is passed from the kernel portion to the primary thread because the UMS thread is voluntarily yielding to the UMS thread .

Accordingly the kernel portion of the primary thread may clear itself of the register states that are associated with the UMS thread . Subsequently the primary thread may return to user mode and pick up the UMS thread e.g. switch its user portion with a user portion of the UMS thread for execution.

Thus when the user mode scheduler determines that such inefficiencies may result the user mode scheduler may perform the optimization. The optimization may cause the CPU to execute the UMS thread while the CPU still retains the context information of the primary thread .

In various embodiments the primary thread may notify the UMS thread to place itself on standby for the CPU . The CPU may be configured to be ready to execute the primary thread while the context information of the primary thread is in the cache of the CPU . For example the UMS thread may queue itself as the next item in a list of threads to be executed by the CPU. Accordingly once the primary thread has blocked itself a CPU scheduler may cause the CPU to execute the UMS thread using the context information of the primary thread . In some embodiments the CPU scheduler and or another verification mechanism may verify that the affinity of primary thread and the affinity of the UMS thread have a non zero intersection. The affinity of a thread determines what CPUs the thread may be scheduled on by the CPU scheduler . So in other words the verification mechanism may ensure that the UMS thread is executed after the primary thread only if such an execution sequence will not cause execution conflicts. In at least one embodiment the CPU scheduler may be the user mode scheduler .

The selected components stored in memory may in the form of program instructions. The program instructions or modules may include routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The modules may be implemented as software or computer executable instructions that are executed by one or more processors . As shown in the selected components may include a user mode scheduler and a kernel queue . However it will be appreciated that the environment may also include other modules that perform other functions related to thread execution.

The user mode scheduler may be configured to create primary threads and manage UMS threads. The user mode scheduler may be further responsible for exposing UMS thread mechanisms to higher level components in applications and may also control and implement scheduling policies specific to an application and its instances that uses the threads. In various embodiments the user mode scheduler may be configured to select the next thread to run from among the user portions of UMS threads that are ready to execute such as user portion and switches the CPU to run the selected. In some embodiments the user mode scheduler may further perform the various optimization functions described above.

The user mode scheduler may include a primary thread API module a UMS thread API module a UMS completion list API module and an accessory API module . The primary thread API module may be configured to enable an application to start a new instance of the user mode scheduler . The UMS thread API module may be configured to create a new UMS thread such as the UMS thread from a standard process thread such as the standard thread . In one at least one embodiments the thread API module may convert a standard thread into a new UMS thread by adding a special state or convert a standard thread into a primary thread and vice versa

Moreover the thread API module may enable a primary thread to switch to a UMS thread. Additionally the thread API module may further enable a first UMS thread to yield to a second UMS thread by providing a hint to the primary thread such as the primary thread which indicates that the UMS thread should execute as a result of the yield. Finally the thread API module may be implemented to convert a UMS thread or a primary thread back into a standard thread with the removal of the special state. In some embodiments the thread API module may be further configured to handle the thread execution optimizations described in .

The UMS completion list API module may be configured to create and manage a UMS completion list such as the UMS completion list . In other embodiments the UMS completion list API module may withdraw from the UMS completion list all queued UMS thread user portions. In additional embodiments the UMS completion list API module may be implemented to delete a UMS completion list.

The accessory API module may be configured to fetch various UMS thread states. For example the accessory API module may fetch a UMS thread user portion from a UMS completion list so that it may be switched with a user portion of a primary thread for execution on a CPU. In various embodiments the accessory API module may obtain the latest queued UMS thread from the UMS completion list as well as obtain the next queued UMS thread. In other embodiments the accessory API module may be further configured to provide each of the UMS threads with thread information as well as retrieve thread information from each of the UMS threads.

Finally the kernel queue is a mechanism that may be configured to monitor system operations and registers events and notify appropriate components of changes. The kernel queue may also used by the OS kernel to control the concurrency level of threads associated with a particular queue. In various embodiments the kernel queues may wake up the primary thread such as the primary thread when the user portion of the UMS thread enters into a parked state or otherwise blocks in kernel mode e.g. due to a synchronous wait in a system call or a page fault . This may be accomplished by ensuring that the kernel queues used with the UMS mechanism only allow a concurrency level of a single thread.

At block an application may create a user mode schedulable UMS thread such as the UMS thread . In at least one embodiment involving the IA 64 Itanium CPU architecture the UMS thread may be created from a standard thread such as the standard thread with the use of the special pointer to the states that are stored in a user thread descriptor of the UMS thread .

However in other embodiments involving x86 and x64 CPU architectures the UMS thread may be created from a standard thread such as the standard thread with the use of a segment selector that references the user thread descriptor of the UMS thread .

At block once kernel side initialization of the UMS is completed the kernel portion of the UMS thread may direct a code algorithm running in kernel mode such as the sentry to move the user portion of the UMS thread to a UMS completion list .

At block having directed the move of the user portion to the UMS completion list the kernel portion of the UMS thread may enter into a parked state that is a type of waiting state.

At block the parking of the UMS thread may signal a kernel queue to activate the primary thread e.g. wake it up from a suspended state. An application may create a primary thread from a standard thread such as the standard thread by the addition of a special state. Accordingly primary threads such as thread may be dynamically converted from and into standard threads as application requirements dictate. Once the kernel portion of primary thread wakes up it may switch to its user portion in user mode . In various embodiments the primary thread may purge the context information in its kernel portion during wake up. The purging of the context information may serve to ensure that it is ready to switch to and execute a newly assigned UMS thread.

At block the user portion of the primary thread may be switched for a user portion of a UMS thread such as one of the UMS threads that is queued in the UMS completion list . In some instances the user portion may be switched for the user portion of the UMS thread . In at least one embodiment the switch may be accomplished with the use of one of the special pointer or segment selector . At block the switch between the user portion and the user portion may enable the primary thread to execute on behalf of the UMS thread in user mode .

At block once the user portion has finished executing in user mode and may need to move to kernel mode in order to perform additional executions in its kernel portion .

At block a directed switch may be performed between the UMS thread and the primary thread . In various embodiments the directed switch may be implemented with the replacement of the context information in the UMS thread with the context information of the primary thread . Following the directed switch the primary thread may be released from its association with the UMS thread . Subsequently the UMS thread may go into a blocked state. In at least one instance the UMS thread may exit its blocked state when called upon by the user mode scheduler to perform another execution.

At block following the directed switch the kernel portion of the UMS thread may be executed in kernel mode .

At decision block the kernel queue may determine whether the kernel portion of the UMS thread becomes blocked during execution. As long as the kernel queue determines that the kernel portion is not blocked no at decision block the process may proceed to decision block .

At decision block the kernel queue may determine whether the kernel portion of the UMS thread has completed its kernel mode execution on a CPU such as CPU . If the kernel portion did not complete its execution on the CPU no at decision block the process may loop back to decision block . However if the kernel queue determines that the kernel portion has completed its execution on the CPU yes at decision block the process may proceed to block .

At block the primary thread may awake from its blocked state at block . During this awake state the primary thread may exit kernel mode into user mode where the user portion of the primary thread may execute the user mode scheduler and switch to the user portion of another UMS thread such as user portion for execution. In various embodiments the primary thread may purge the context information in its kernel portion during wake up. The purging of the context information may serve to ensure that it is ready to switch to and execute a newly assigned UMS thread.

At decision block it may determined that whether an optimization such as the optimization described in may be performed to enable the UMS thread to enter user mode for additional execution. As described above the performance of this optimization may eliminate the repeated cost of directed switch if the UMS thread is generally performing non blocking work. Thus if the optimization is not to be performed no at decision block the process may loop back to block where the UT portion of the UMS thread may be moved to a UMS completion list .

However if it is determined that the optimization is to be performed to enable the UMS thread to enter user mode for additional execution yes at decision block the process may proceed to block .

At decision block the sentry may detect that the UMS thread is attempting to exit kernel mode . Accordingly the sentry may determine whether the primary thread is still present in kernel mode . If the sentry determines that the user portion of the primary thread is not present in kernel mode no at decision block the process may return to block . The user portion of the primary thread may have begun executing in user mode. Upon returning to block the user portion of the of the UMS thread may be moved to the UMS completion list .

However if the sentry determines that the user portion of the primary thread had not yet returned to user mode yes at decision block the sentry may permit the UMS thread to begin execution in user mode . In other words the sentry may allow the UMS thread to act as a standard thread such as standard thread and implicitly begin running in user mode without waiting to be chosen by the user mode scheduler .

At block the UMS thread may return to kernel mode . In some embodiments the UMS thread may return to kernel mode because its execution in user mode is completed so that additional processing of the UMS thread in kernel mode is performed. In other embodiments the UMS thread may return to kernel mode because the UMS thread encountered a blocking system call or page fault while its user portion is executing in user mode . As described above since the UMS thread is only capable of handling a block or page fault in kernel mode the process may loop back to block to return to kernel mode .

Return to block if the OS kernel determines that the kernel portion of the UMS thread is blocked yes at decision block the primary thread may awake from its blocked state at block . During this awake state the primary thread may exit kernel mode into user mode where the user portion of the primary thread may execute the user mode scheduler and switch to the user portion of another UMS thread such as user portion for execution. In various embodiments the primary thread may purge the context information in its kernel portion during wake up. The purging of the context information may serve to ensure that it is ready to switch to and execute a newly assigned UMS thread.

At block the kernel portion of the UMS thread may become unblocked. For example but not as a limitation a blocking event may time out or the block may become unnecessary. When the kernel portion of the UMS thread becomes unblocked the process may proceed to block where the process will further progress as previously described.

At block an application may determine that a particular UMS thread such as the UMS thread will yield to another UMS thread such as the UMS thread during a directed switch. In other words a recipient UMS thread may be determined for the yield.

At block the application may make a system call to kernel mode to prevent the UMS thread from exiting kernel mode . In one embodiment the system call is directed to the sentry .

At block when the UMS portion of the UMS thread attempts to exit to user mode the sentry may move the user portion of the UMS thread to the UMS completion list . Subsequently at block the kernel portion of the UMS thread may park itself that is enter into a waiting state.

At block the kernel queue may detect that the UMS thread has entered into the parked state and wake up the primary thread . The kernel portion of the UMS thread may inform the primary thread that it has yielded to the UMS thread .

At block the primary thread may execute the UMS thread . In at least one embodiment the primary thread may switch its user portion with the user portion of the UMS thread .

At decision block a checking mechanism such as the user mode scheduler may make a determination as to whether the affinity of the primary thread and the affinity of the UMS thread shares a non zero intersection. In at least one embodiment the sharing of non zero intersection indicates that the execution of the primary thread and the UMS thread on the same CPU will not cause conflicts. If the user mode scheduler determines that the affinities of the primary thread and the UMS thread shares a non zero intersection yes at decision block the process may proceed to block .

At block the primary thread may notify the UMS thread to be on standby for execution on the same CPU that is executing the primary thread .

At block while the context information of the primary thread is in a memory cache of the CPU the user portion of the UMS thread may be executed using the context information . Thread priorities are also adjusted to ensure the sequential execution is not a violation of the general thread prioritization rules observed by the kernel thread scheduler. For example the thread priority on the target UMS thread kernel portion may be boosted to equal that of the incoming primary as appropriate. Thus the sequential execution of the kernel portion of the UMS thread following the execution of the user portion on the same CPU may eliminate the need to perform a full context switch of the context information with the context information of the UMS thread that may involve signaling another CPU to run the thread. However if the user mode scheduler determines that the that the affinities of the primary thread and the UMS thread do not shares a non zero intersection no at decision block the process may proceed to block .

At block the primary thread and the UMS thread may implement a directed switch that includes the context switch of the context information with the context information of the UMS thread as described above.

At block the kernel stacks of the primary thread and the UMS thread respectively may be swapped. For example the kernel stack of the primary thread may include the context information and the kernel stack of the UMS thread may include the context information . In various embodiments the kernel stacks may be swapped by a mechanism that swaps the stack pointers of the respective kernel stacks.

In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more program modules and may include program data . The operating system include a component based framework that supports components including properties and events objects inheritance polymorphism reflection and provides an object oriented component based application programming interface API such as but by no means limited to that of the .NET Framework manufactured by Microsoft Corporation Redmond Wash. The device is of a very basic configuration demarcated by a dashed line . Again a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and are not discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. These networks may include wired networks as well as wireless networks. Communication connections are one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules etc.

It is appreciated that the illustrated computing device is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well known computing devices systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor base systems set top boxes game consoles programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and or the like.

The use of directed switches for primary threads and the UMS thread in conjunction with pure user mode context switches and completion ports for thread notifications may provide an architecture and or platform for applications such as high performance enterprise applications to better control thread execution and concurrency. Moreover the use of directed switches on a multi processor platform may enable applications to scale efficiently. With the use of directed switches and optimizations described herein applications may have the ability to utilize all system services and or application programming interface API on UMS threads transparently that is in the same manner as standard NT threads without compatibility issues.

In closing although the various embodiments have been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended representations is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed subject matter.

