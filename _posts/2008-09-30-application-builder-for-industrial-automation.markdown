---

title: Application builder for industrial automation
abstract: A control system development platform is provided. The platform includes a shell component adapted to support development of a control systems application. An abstract model is associated with the shell component to facilitate development of the control systems applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08255875&OS=08255875&RS=08255875
owner: Rockwell Automation Technologies, Inc.
number: 08255875
owner_city: Mayfield Heights
owner_country: US
publication_date: 20080930
---
The claimed subject matter relates generally to industrial control systems and more particularly to a development tool that employs language independent models to facilitate automation software design.

Industrial controllers are special purpose computers utilized for controlling industrial processes manufacturing equipment and other factory automation such as data collection or networked systems. Controllers often work in concert with other computer systems to form an environment whereby a majority of modern and automated manufacturing operations occur. These operations involve front end processing of materials such as steel production to more intricate manufacturing processes such as automobile production that involves assembly of previously processed materials. Often such as in the case of automobiles complex assemblies can be manufactured with high technology robotics assisting the industrial control process.

In many automated processes including the basic production of commodities such as food beverages and pharmaceuticals complex state logic is often designed and programmed by Systems Engineers or provided in some cases by automated equipment manufacturers. This logic is often programmed with common PLC ladder logic or higher level languages supported by Sequential Function Charts SFC . Sequence logic can be employed for a plurality of tasks such as material movement and conveying operations packaging operations or as part of an assembly process itself wherein various stages of an assembly are sequenced from stage to stage until a final assembly occurs. As can be appreciated much planning and design is required to implement an automated production process that can involve hundreds of machines computers and program logic to facilitate proper operation of the respective sequences.

Various software platforms are available from many different controls manufacturers that implement languages such as ladder logic and SFC. Many control software development platforms exist as stand alone entities however that require many man years of development and testing before such platforms can be utilized by the development community. Due to the nature of such platforms they are often designed in an inflexible manner where newer versions of software paradigms and models are unsupported unless a new platform is designed to support such versions.

The following summary presents a simplified overview to provide a basic understanding of certain aspects described herein. This summary is not an extensive overview nor is it intended to identify critical elements or delineate the scope of the aspects described herein. The sole purpose of this summary is to present some features in a simplified form as a prelude to a more detailed description presented later.

A flexible and extensible architecture exposes the underlying control models and features of an Automation Collaborative Framework yet provides a familiar software design environment to create new features and functions. A design shell is adapted to support rapid software development for a control and industrial automation platform. Such shell can be adapted from available Windows technologies but substantially any type of shell could be similarly constructed such as from UNIX Java Linux and so forth. The shell provides an interface development platform that is tailored to the needs of control systems designers.

The development platform employs abstract programming models that enable developers to design control solutions in an abstract setting while facilitating code deployment and execution on substantially any type of end hardware platform. In one aspect an Abstract Automation Model AAM is derived from common base model solutions or standards such as IEC 61131 and 61499 for example. Although any programming standard can be utilized for the underlying model 61131 and 61499 support a majority of known automation languages in the world today. The AAM defines control structures that represent abstract data objects having properties of a configuration resource program and so forth. As part of a larger framework or development environment a Concrete Automation Model CAM provides data interfaces associated with the generic data objects and according to a designated project format of differing development environments. For instance various versions of a development program may have associated CAMs that link or map the respective versions to the underlying abstraction of the AAM.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth in detail certain illustrative aspects. These aspects are indicative of but a few of the various ways in which the principles described herein may be employed. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

A software development platform is provided that employs abstract models to support substantially any type of control language yet not constrain designers to any particular language format or interface. In one aspect a control system development platform is provided. The platform includes a shell component adapted to support development of a control systems application. An abstract model is associated with the shell component to facilitate development of the control systems application.

It is noted that as used in this application terms such as component module shell model and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution as applied to an automation system for industrial control. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and a computer. By way of illustration both an application running on a server and the server can be components. One or more components may reside within a process or thread of execution and a component may be localized on one computer or distributed between two or more computers industrial controllers or modules communicating therewith.

Referring initially to a shell interface is provided that employs abstract automation models to facilitate software development in a controls environment. As shown the shell is adapted for various features that facilitate rapid development debug and deployment of control systems solutions. Such features include version control components to allow revision control of software. Human machine interface HMI support is provided at along with a language dictionary . Various editors are provided and are described in more detail below. Device content components are included along with I O configuration capabilities . Dependency tree support is provided at in addition to project comparators and modification history components . Software debug tools include device views error outputs cross references tracing tools along with script modules spy lists and result search tools . Project controls are provided at and including import and export capabilities at . Library and property configurations are provided at . All the features that have been briefly mentioned here will be described in more detail below.

In general the interface provides a flexible and extensible architecture that exposes the underlying control models and features of an Automation Collaborative Framework yet provides a familiar software design environment to create new features and functions. A design shell is adapted to support rapid software development for a control and industrial automation platform. Such shell can be adapted from available Windows technologies but substantially any type of shell could be similarly constructed such as from UNIX Java Linux and so forth. The shell provides an interface development platform that is tailored to the needs of control systems designers.

The development platform and shell employs abtract programming models that enable developers to design control solutions in an abstract setting while facilitating code deployment and execution on substantially any type of end hardware platform. In one aspect an Abstract Automation Model AAM is derived from common base model solutions or standards such as IEC 61131 and 61499 for example. Although any programming standard can be utilized for the underlying model 61131 and 61499 support a majority of known automation languages in the world today. The AAM defines control structures that represent abstract data objects having properties of a configuration resource program and so forth. As part of a larger framework or development environment a Concrete Automation Model CAM provides data interfaces associated with the generic data objects and according to a designated project format of differing development environments. For instance various versions of a development program may have associated CAMs that link or map the respective versions to the underlying abstraction of the AAM.

It is noted that components associated with the interface can include support for various computer or network components such as servers clients controllers industrial controllers programmable logic controllers PLCs batch controllers or servers distributed control systems DCS communications modules mobile computers wireless components control components and so forth that are capable of interacting across a network. Similarly the term controller or PLC as used herein can include functionality that can be shared across multiple components systems or networks. For example one or more controllers can communicate and cooperate with various network devices across the network. This can include substantially any type of control communications module computer I O device sensors Human Machine Interface HMI that communicate via the network that includes control automation or public networks. The controller can also communicate to and control various other devices such as Input Output modules including Analog Digital Programmed Intelligent I O modules other programmable controllers communications modules sensors output devices and the like.

The network can include public networks such as the Internet Intranets and automation networks such as Control and Information Protocol CIP networks including DeviceNet and ControlNet. Other networks include Ethernet DH DH Remote I O Fieldbus Modbus Profibus wireless networks serial protocols and so forth. In addition the network devices can include various possibilities hardware or software components . These include components such as switches with virtual local area network VLAN capability LANs WANs proxies gateways routers firewalls virtual private network VPN devices servers clients computers configuration tools monitoring tools or other devices.

Turning now to an example platform architecture is illustrated. The architecture is also referred to as Application Builder that includes a Core and Common namespaces . The Core groups system related reusable components such as a logger rights manager and shell described below. The Common namespace combines reusable Application Builder data Services and views. The lower portion of also identifies that multiple project formats and add ins are supported. The Application Builder also provides generalizations editors e.g. Visual Studio adapted for controls to perform an easier inter connection of project format files and the common views.

The core rights namespace described below defines the major proactive security mechanism. Security mitigates possibilities of project data hijacking and corruption. In one aspect component protection is provided. This includes ensuring business components are protected with security roles. For instance a method call fails when the role e.g. manager technician engineer has not been granted permission. Each role is associated with a licensed feature. This feature naming policy should allow a fine grain role assignment to each component method.

At run time the protected method should query for its role permission either using .Net role based declaration attributes or using an algorithm preamble. The algorithm preamble presents the advantage to disable the security validation for intensive processing such as parsing a source code file or generating target execution image. Failure to this test is logged and results in a security exception.

In another security aspect role mappings are provided. This includes adopting dynamic role mappings based on business rules process context or user role. Role mappings are under control of the feature matrix described in more detail below. The feature matrix maps roles on permission sets. The set delegates each one of its sub permissions and retains the most restrictive access. Rich client authentication can also be provided that includes adopting a .Net main thread principal instead of sending username password credentials through objects. The thread principal connects role validation on the feature matrix. Contextual permission objects mapped by the features matrix are hosted by each instance of concrete model.

Secure auditing can also be provided. This includes deploying a secure logging and auditing mechanism audit interceptor to record and provide a means of identifying and auditing failed direct access attempt policy violations undefined user role memberships and exceptions. In one aspect secure auditing is optional. The usual logging may be configured to redirect log entries on a console to cause special alarms. Data validation includes adopting well defined validation procedures in the business component for handling data format and business data. This ensures data integrity and protects against malicious data injection. Data validation is performed on input parameters and assigned property values. An algorithm preamble block performs assertion tests. Failure of the respective tests is logged and results to an invalid argument exception.

In yet another security aspect deployment components can be restricted. For example do not store unused components in a production environment. For instance each facultative component can be stored in a specific assembly DLL. The production team could also avoid building an edition with unused components. Security also includes protecting an editor s intellectual property. For example do not provide DLL or EXE that may be easily replaced or disassembled. Typically all stored DLL or EXE are signed to avoid easy replacement that hackers may perform to hijack from normal behaviors. Disassembling could be harder with code obfuscation. Signing is systematically applied even in development process. Obfuscation could be applied to released versions only.

Referring now to example system core components and system rights components are illustrated. At Log4net is a port of an Apache log4j framework to a .Net runtime. The core components also include a shell and rights component . The logging framework follows that the speed of logging or rather not logging is an important consideration. It is designed so that log statements can remain in shipped code without incurring a high performance cost. Log filters may be configured to avoid logging events according to criteria such as Mapped Diagnostic Contexts MDC Nested Diagnostic Contexts NDC error level match and so forth. New filter types could be created to allow more arbitrary filtering.

The framework writes log events to multiple outputs such as a database a remote sink using .Net remoting for example a web service a plane text file with or without multiplexing and so forth. New target types could be created to redirect events in some other outputs.

The framework supports hierarchical logging. This is a suitable fit with component based development where each component has its own logger. When individually tested the properties of these loggers may be set as the developer requires. When combined with other components the loggers inherit the properties determined by the integrator of the components. One can selectively elevate logging priorities on one component without affecting the other components. This can be achieved through configuration files. The framework can be configured using an XML configuration file. Configuration information can be embedded within other XML configuration files as described by .Net configuration specifications. The framework can also be configured programmatically.

The Rights namespace is based on a license manager a user roles manager and a feature matrix . The feature matrix combines constraints on features and provides resulting permissions to other products or modules.

The license manager includes a license object that conforms to .Net Component Model s licensing specification. It is a serialized collection of command features permissions and constraints. A command feature is the simplest unit of action allowed on a data object. The system may count thousands of features that are grouped under features. The hierarchy shown provides an example of feature bundles and features relationships for basic edition operations such as the following example 

A feature may be optionally related to constraints such as a counter range. A constraint specifies the condition to set the feature s availability status among the following possibilities Full Read Only or Deny. Constraints are serialized in the license object next to the related feature.

The License also defines events and delegate types. Other components may be notified when some licensing change arise such as unplugged USB device or network cord for example. A License Provider conforms to Component Model s rights specification. It provides a license serialization service. The license object itself may be serialized in a file stored either in the host file system or in a signed USB key. It may also be provided by a license server. In such case the License Provider is connected on a license server from which the license is retrieved. The license provider has methods activate license keys from a corporate web site. In such case the provider sends the license key and retrieves the license object. The retrieved license is serialized on the provider s storage location. The provider retrieves licenses storage location data using a setup mechanism in conformity with .Net configuration specifications. A License Editor is a .Net User Control. It provides a user interface to display the available features permissions and constraints. The editor also provides license key activation UI and license object edition. As shown the rights components include a services component an abstract mode component and a common views component .

The features matrix is a decision table that dynamically update feature s permission from different sources. This matrix is used in at least 3 areas of the application 

The feature matrix maps all features on root access permission objects. The structure of the feature extends the permission object defined in .Net Security Specifications. The extension adds a combination of the three following command status flags 

The feature matrix creates a permission set for each feature declared by loaded modules. At the initial feature declaration it retrieves the feature status from the License Provider . The set aggregates license user role or element status permission objects. Any module project format or add in can register additional permission objects to this set. Any unknown feature name is considered as custom and the matrix assumes they are enabled. In this case the licensing validation is under the control of this extension. A permission set is used by a standard command update handler and licensed methods. A licensed method invokes the permission s Demand method which raises a Security Exception when the command status isn t Enabled. Command update handlers assign the permission set s command status.

A debugger engine delegates debugging commands to Field Bus Protocol instances which are described below that are delegating back event notifications to the debugger engine . The debugger engine also manages multiple resource connections. The debugger engine provides component interfaces to cause the Locals the Watch and the Call Stack tool windows to operate. Locals and Watch tool windows are indirectly subscribing to Field Bus Protocol s variables groups and reflect user changes on the protocol s subscription interfaces. The Call Stack tool window is also indirectly querying stack frames from the protocol s connections. Breakpoints and stepping commands and events are also translated by the engine .

The startup navigation window fills the client design area with a web page style pane that enumerates shortcuts on the last opened solutions projects documents other shortcuts to create new designs and other designating how to help topics. It is a suitable instrument to introduce new users enables the Application Builder to be easier to use and provides a marketing platform to announce related products and services.

A Start up Editor Pane is a document that opens on start up. The user may disable it using option pages. The editor loads a page view indicated by configuration files.

At project types are considered. Packages a provide deep integration directly in the IDE by enabling access to the same tools and components used by the IDE frameworks. The part of the Managed Package Framework MPF that deals with creating new project types isn t provided as part of the assemblies. Source code called ProjectBase is provided that the Project Type Package assembly includes. The Project Type Package makes the association between a project file extension and a managed class GUID. The IDE shall instantiate this class when a project file opens. This package class is also a suitable place to register common tool windows and commands. At a minimum the package should register and process About Box query commands.

Implementing a project type implies to manage the project file system hierarchy tree according to desired behavior. A Shell Service specialization defined with the Project Type provides the Service s methods for an integration package. The project package instantiates this specialization to retrieve module information from unloaded packages and add ins. A distinct project type represents each supported programming language. In addition to project types the IDE defines solutions which are an aggregation of many projects. The inter language power of .Net is provided by the solution and not by the project.

Integrated mode The integrated application shares a common platform with other languages and tools and

Isolated mode The integrated application is made available in a branded IDE container that is one of the services without the common languages and tools.

As shown a shell controller and a field bus component can also be provided. The Field Bus component provides a common API to manage dialog download upload and on line change with targets. The API should be extensible to support any Automation protocol. A Field Bus namespace defines abstract interfaces to communicate with the target. This implies a fa ade interface and a set of sub Service interfaces to manage dialog. The abstract service unifies communication error messages in the .Net exception pattern. The protocol s message codes are converted to the Field Bus s counterparts packaged and raised back to the caller not the target channel in a Protocol Violation Exception.

The abstract service structure has some similarities with an OPC DA and EA server. More specifically it provides methods to subscribe on a group of variables and to set or lock unlock variable values. Any variable value set or locked unlocked are delegated to the protocol s specific language and channel. A value change notification that arises from the protocol channel is packaged in an event argument and notified back to the group s subscribers thru an event. The abstract service structure has also some similarities with a debug engine. More specifically it provides methods to perform step by step debugging to manage break point notifications and stack frames. A break point notification that arises from the protocol s channel is packaged in an event argument and notified back to the engine s subscriber thru an event. Stack frame construction takes part of the event packaging. An empty stack frame object may be set if a target does not support this feature. The Field Bus abstract service finally provides methods to support downloading uploading and on line change. These operations are asynchronous and provide progress status to a client application.

The Application Builder provides a common data model UI components and collection of processing services to manage automation projects. This namespace defines reusable classes without any relation to a particular IDE framework. provides the architecture of the Application Builder Common namespace 

1. An abstract model captures an automation domain s commonly used data structures. It groups programming interfaces where each one reflects a possible aspect that could be exposed in data of an automation project.

3. Views are user interface controls for presenting data to a user. They use or change data exposed by the abstract model using data abstract interfaces or indirectly through the services .

The model is a set of abstract interfaces. Each interface defines an aspect of project element with the related basic edition methods. This abstraction layer should be superposed on a concrete project format data model and reflect the changes on specific project structure. The concrete models project elements implements a .Net interface IServiceProvider. This provides contextual service providers that are conforming to .NET services specifications. The abstract model s interfaces are defining properties and methods commonly attributed to IEC 61131 or IEC 61499 elements. Some interfaces may define events and delegate types to provide change notifications.

Services are data processing components. It is to be appreciated that not all the possible Services that the Application Builder could ultimately provide are illustrated. It is however possible to enumerate some example services. Each service has an abstract interface . A concrete model implements and publishes its services to make them working within the appropriate context.

A Document Generator produces a formatted document according to user s preferences and choice of chapters. The document formatting is based on a template. The document may be generated in the common formats such as PDF for example or directly sent to a printer. The generator uses the views printing methods for diagrams and charts. The generated pictures are sliced to fit in the generated document s page layout. This service has a dialog box to specify the document generation parameters. An example dialog is illustrated in .

Referring back to an Import Export component is an abstract controller fa ade to standardize calls and make it available to service providers as defined by .Net services specifications. Importing includes parsing archive files to populate a Model using abstract interfaces. Exporting includes generating archive files from a Model using abstract interfaces. An import controller works in collaboration with a Parser. It makes preliminary operations such as decompressing and launches a parser to populate a model. An export controller works in collaboration with a Generator . It launches a generator and performs post operations such as compressing.

The Parser controller performs the analysis of the source files and reflects results in the concrete project format model. The project format defines a complementary abstract model to complete the general abstract model. The parser uses those abstract interfaces to indirectly fill the concrete project format model.

The Generator controller writes formatted files according to a project format. This generator traverses data made available by the Abstract Model and the project format s complementary Abstract Model. This service could be used to provide interoperability among project formats. The generator should generate files without its project format complementary Abstract Model. In such case the generator uses default values to maintain compatibility with the generated file s target.

A Global Find Replace controller defines an abstract fa ade interface. The default controller performs a tree traversal in the Abstract Model. It delegates each visited contextual Find Replace controller. A general element Find Replace controller is provided. A project format may also extend or even replace it. Each contextual service provider stores an instance of this controller. A Cross Reference controller performs a tree traversal within the Abstract Model . It retains derived types usage function block instances as well as function block calls and function calls from Abstract Syntax Tree AST .

Except for the Diagram namespace views are .Net user controls but other types of controls can be provided. They could delegate services or use abstract object interfaces to modify or query data. Deployment makes a document that specifies a connection between project elements. It can take the appearance of a network diagram with the various project elements and communication devices.

A trace tool and display is used to display signals in a graphical chart. It receives signal change notifications on time and reflects this change on the chart. It should allow real time tracing and possibility serialize historical data.

An I O Configuration component not shown browses the hardware devices in a tree structure and provides direct I O variables addresses. In cooperation with the Dictionary View described above an I O Configuration component allows to mapping direct IO variables with symbolic variables. The mapping should be visible from both the I O Configuration and the Dictionary. This component is a client of the Project Model and the Feature Matrix services. In some situations the user may perform drag and drop of variables from the dictionary and in such case the component also becomes the client of the Dictionary component.

At a binding component is illustrated. This component sets all variables to exchange between resources. The component loads the binding producer and consumer groups or variables. It enumerates them in a view that helps the user to make pairs connecting producers of a resource to consumers of another resource.

A diagram editor not shown can be provided for automation deployment and programming. It provides an edition surface to display shapes from a Language Stencil and applies the shapes semantic rules and on line behaviors. The shapes that make a diagram are grouped by language or diagram type. In the editor surface drawing areas are mixing shapes of the same groups and those areas may be linked to exchange data. A Language Stencil Designer not shown allows creating new diagramming shapes to be presented in a General Multi Layer Editor. Shapes are saved in files called Language Stencils and made available by the Diagram namespace.

Proceeding to abstract models are defined. As noted previously abtract programming models can be provided in an abstract setting while facilitating code deployment and execution on substantially any type of end hardware platform. In one aspect an Abstract Automation Model AAM is derived from common base model solutions. Although any programming standard can be utilized for the underlying model 61131 and 61499 support a majority of known automation languages in the world today. The AAM defines control structures that represent abstract data objects having properties of a configuration resource program and so forth. As part of a larger framework or development environment another abstract model is a Concrete Automation Model CAM that provides data interfaces associated with the generic data objects and according to a designated project format of differing development environments. At a design shell is modified to support software development for a control and industrial automation platforms. The shell can be adapted from substantially any type of shell could be constructed from technologies such as UNIX Java Linux and so forth. The shell provides an interface development platform that is tailored to the needs of control systems designers.

At the shell is adapted for various control software functions that facilitate rapid development debug and deployment of control systems solutions. As noted previously such features include version control components to allow revision control of software and Human machine interface HMI support. Other features include a language dictionary and various editors. Device content components are included along with I O configuration capabilities. Dependency tree support is provided in addition to project comparators and modification history components. Software debug tools include device views error outputs cross references tracing tools along with script modules spy lists and result search tools. Project controls include import and export capabilities. Library and property configurations are also provided. At various user interfaces are provided to access the control software functions provided at .

The subject matter as described above includes various exemplary aspects. However it should be appreciated that it is not possible to describe every conceivable component or methodology for purposes of describing these aspects. One of ordinary skill in the art may recognize that further combinations or permutations may be possible. Various methodologies or architectures may be employed to implement the subject invention modifications variations or equivalents thereof. Accordingly all such implementations of the aspects described herein are intended to embrace the scope and spirit of subject claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

