---

title: Apparatus for thread-safe handlers for checkpoints and restarts
abstract: A method, apparatus, and computer instructions for executing a handler in a multi-threaded process handling a number of threads in a manner that avoids deadlocks. A value equal to the number of threads executing in the data processing system is set. The value is decremented each time a lock count for a thread within the number of threads is zero. A thread within the number of threads is suspended if the thread requests a lock and has a lock count of zero. A procedure, such as a handler, is executed in response to all of the threads within the number of threads having no locks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07653910&OS=07653910&RS=07653910
owner: International Business Machines Corporation
number: 07653910
owner_city: Armonk
owner_country: US
publication_date: 20080211
---
This application is a continuation of application Ser. No. 10 339 753 filed Jan. 9 2003 now U.S. Pat. No. 7 337 444.

The present invention relates generally to an improved data processing system and in particular to a method and apparatus for processing data. Still more particularly the present invention provides a method and apparatus for managing threads executing in a data processing system.

Checkpoints are often used in a method for recovering from a system failure. A checkpoint is a copy of the state of the data processing system which is periodically saved. This state includes for example the contents of the memory in the data processing system as well as current register settings. These register settings may include for example the last executed instruction. In the event of a failure the last checkpoint may serve as a recovery point. A restart program may copy the last checkpoint into memory reset the hardware registers and start the data processing system from that checkpoint.

A checkpoint is thus used to save the state of the processes of an application. A process is the execution state of a program. Often a process can be broken into multiple execution states which can run in parallel. Each of these execution states share the same data and global state such as open files shared memory and program text etc. however they have their own execution context with their own stack and registers. These are called threads of a process. When multiple threads in a user space are multiplexed to run on a single kernel thread the user threads are called lightweight processes. In Advanced Interactive Executive AIX these threads also are referred to as pthreads and the library that handles the switching of pthreads in a user space is the pthreads library. From the kernel perspective there is only a single thread however the pthreads library may run several pthreads on a single kernel thread. The two popular models are the M N model where N pthreads are serviced by or multiplexed on M kernel threads and M is usually less than N or the 1 1 model where there is one kernel thread for each pthread.

Processes often require special handling at checkpoint and restart time which is handled by running application handlers one at checkpoint time and one at restart time. These are usually implemented as signal handlers or event handlers which execute under the context of one of the threads of the process. The thread is interrupted from its current execution its execution state is saved and control is passed to the handler. When the handler completes the state of the thread is restored and the thread resumes execution from the point it was interrupted. A process will need to register for handlers if the process owns non checkpoint safe resources like Internet sockets whose complete state cannot be saved in the checkpoint file because the other end of the socket is on a different system. In this case the handler can save the details of the socket at checkpoint time reopen the socket at restart time and perform any other initialization necessary to restore the socket to the state it was at checkpoint time. Checkpoint handlers may also be needed to convert the process into a checkpointable state.

Currently signal handlers and checkpoint handlers which are usually implemented as signal handlers are restricted to a limited set of application program interface calls API or system calls which do not require taking of any internal pthread locks. The restricted set of calls is currently used because if a thread is interrupted to handle a signal and the thread is in the middle of an API that has taken a lock and the signal handler invokes the same API a deadlock occurs. This deadlock occurs because the signal handler would block and wait for the lock to be released. A lock is used to prevent other threads or processes from accessing a resource such as a memory location or a register. The lock owner the interrupted thread will block waiting for the signal handler to complete resulting in a deadlock. This same situation exists in the case in which the signal handler tries to acquire a mutex. A mutex is a programming flag used to grab and release an object. A mutex may be set to lock such that other attempts to use the object are blocked. A mutex is set to unlock when the data is no longer needed or the routine finishes.

Signal handlers checkpoint and restart handlers are examples of procedures. A procedure is a series of steps followed in a regular definite order for example a legal procedure or a surgical procedure. In computer systems a procedure is a series of instructions that has a name by which the procedure can be called into action.

Many calls used in a data processing system will take internal locks when running in a multithreaded state to serialize execution. For example the call malloc takes a lock to protect its internal heap structure. The problem of deadlocking is a bigger problem with respect to checkpoint restart processes. Specifically requirements for a checkpoint handler are usually more complex than a signal handler. As described earlier the purpose of the checkpoint handler is often to make a process quiescent to enable it be checkpointed. For parallel applications that execute across many nodes this requirement may involve making calls to the MPI or Message Passing Interface library and the LAPI or Low Level Application Programming Interface a high performance communication library on IBM SP systems subsystems and closing devices that cannot be checkpointed like Internet sockets. It is often impossible to code these calls without taking mutexes or making non thread safe calls.

In addition with respect to deadlocks at restart time the restart handler is called before the rest of the application threads start running. This is to handle resources that were not checkpointed by the system and hence not restored automatically such as Internet sockets devices with non checkpoint aware device drivers and pipes to processes outside the group of processes being checkpointed. The primary task of the restart handler is to restore the state of the application such that threads using these resources run successfully and do not have to be aware of checkpoint restart happening asynchronously.

With these requirements the threads in a process are suspended until the restart handler completes execution or exits. Hence if any of the threads were in the middle of an API call that took a lock or owned a mutex and the restart handler invoked the same API call or tried to acquire the same mutex these threads would block the use of that resource indefinitely causing a deadlock.

Therefore it would be advantageous to have an improved method apparatus and computer instructions for checkpoint and restart handlers in multi threaded processes to avoid deadlocks.

The present invention provides a method apparatus and computer instructions for handling a number of threads in a manner that avoids deadlocks when executing checkpoint and restart handlers in a 1 1 environment. Each thread maintains a lock count which identifies the number of locks and mutexes held by the thread. When a checkpoint becomes pending for a process a value equal to the number of threads executing in the process is set. The value is decremented by each thread that has no locks to start with at the time the value is set. The value also is decremented each time the lock count for the other threads those whose lock count was not 0 when checkpoint became pending becomes 0. A thread is suspended if the thread requests a lock and has a lock count of zero. When the value becomes 0 then the handler is executed in one of threads in the process.

With reference now to the figures and in particular with reference to a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer is depicted which includes system unit video display terminal keyboard storage devices which may include floppy drives and other types of permanent and removable storage media and mouse . Additional input devices may be included with personal computer such as for example a joystick touchpad touch screen trackball microphone and the like. Computer can be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a computer other embodiments of the present invention may be implemented in other types of data processing systems such as a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

With reference now to a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system is an example of a computer such as computer in in which code or instructions implementing the processes of the present invention may be located. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Accelerated Graphics Port AGP and Industry Standard Architecture ISA may be used. Processor and main memory are connected to PCI local bus through PCI bridge . PCI bridge also may include an integrated memory controller and cache memory for processor .

Additional connections to PCI local bus may be made through direct component interconnection or through add in boards. In the depicted example local area network LAN adapter small computer system interface SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM drive .

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as Windows XP which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java is a trademark of Sun Microsystems Inc. Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash read only memory ROM equivalent nonvolatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

For example data processing system if optionally configured as a network computer may not include SCSI host bus adapter hard disk drive tape drive and CD ROM drive . In that case the computer to be properly called a client computer includes some type of network communication interface such as LAN adapter modem or the like. As another example data processing system may be a stand alone system configured to be bootable without relying on some type of network communication interface whether or not data processing system comprises some type of network communication interface. As a further example data processing system may be a personal digital assistant PDA which is configured with ROM and or flash ROM to provide non volatile memory for storing operating system files and or user generated data.

The depicted example in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system also may be a kiosk or a Web appliance. The processes of the present invention are performed by processor using computer implemented instructions which may be located in a memory such as for example main memory memory or in one or more peripheral devices .

The present invention provides a mechanism that allows for a checkpoint or restart handler to make thread API calls or acquire any mutexes without any deadlocks occurring. The mechanism of the present invention guarantees that no blocking will occur on a lock or mutex. The mechanism of the present invention ensures that a handler such as a checkpoint or restart handler is invoked only when no threads are holding locks within a process. The mechanism of the present invention waits until such a condition is reached before starting a checkpoint handler instead of handling the checkpoint signal immediately. Once the checkpoint handler starts running any thread that attempts to take a lock is automatically suspended.

To handle conditions in which threads are continually taking and releasing locks two rules are enforced in the depicted examples. First once a checkpoint is pending a thread that does not own any locks is suspended if that thread attempts to take a lock. Additionally a thread that owns one or more locks is allowed to take additional locks.

Because no thread owns any locks or mutexes and because the checkpoint handler thread releases all mutexes before the checkpoint handler completes or exits the restart handler also will be able to make any thread calls or acquire any mutexes as necessary. As an optimization because all threads are suspended the restart handler does not need to acquire any mutexes unless the restart handler creates new threads and needs to serialize with them.

In the depicted examples the checkpoint handler can be called only when no locks are owned by any of the threads in the process. A global lock field in the pthread library may be used to keep track of the number of locks taken at the pthread level. Mutexes are represented internally by structures in the heap that contain a pthread lock and the owner of the lock is the owner of the mutex. Thus the global lock field represents the total lock count of the thread including mutexes. However when a checkpoint is issued on a process an atomic check cannot be made to determine if the lock count is 0 for every pthread in the process. This situation is present because walking the pthread list and checking each pthread s lock count can only be performed asynchronously and the lock count may change while the count is being read.

In the depicted examples pthreads that own locks may be made to detect and report the condition when their lock count goes to 0 if the checkpoint is pending by suitably modifying the unlocking primitives. A primitive or locking primitive is a lowest level lock routine performing an implementation of a lock. However this procedure does not work for pthreads that never take a lock. Additional code is executed under the context of each pthread when the checkpoint is issued to make an initial check of the pthread s lock count. This code may be implemented as a handler for a special signal SIGADVH.

With reference now to a diagram illustrating components used in managing threads for avoiding deadlocks when using a checkpoint or restart handler is depicted in accordance with a preferred embodiment of the present invention. Components illustrated in may be implemented as instructions and data structures in a data processing system such as data processing system in .

In these examples kernel includes kernel system call handler and kernel heap . User includes library code user code and application data . Checkpoint handler and restart handler are located with user code . Library code contains SIGADVH handler locking primitives and unlocking primitives . A locking primitive is the lowest level lock routine to implement a lock on a resource or object. An unlocking primitive is similarly the lowest level routine to implement the unlocking of the lock on the resource or object.

Application data contains pthread library data with pthread structures and . A pthread structure is present for each pthread. As illustrated three pthread structures are shown for purposes of illustration. Of course other numbers of pthread structures may be used depending on the particular implementation. In this example pthread structure includes lock count CHKPNT PENDING flag and UPDATE PENDING flag . All of the pthread data structures contain this counter and the flags. Lock count indicates the number of locks taken by the thread associated with pthread structure . The CHKPNT PENDING flag is a flag used in a modified locking routine as described below in . If this flag is set and the thread does not own any locks the thread will be suspended when the thread tries to take a lock. The UPDATE PENDING flag is used to determine whether to run a decrementer procedure as described in below. This procedure is used to decrement n threads as part of a determination of when a mechanism such as checkpoint handler may be called. Checkpnt pending is a variable that is set to true when a checkpoint system call is made. The address of the checkpnt pending variable can be passed to the kernel when registering the checkpoint and restart handlers. The registering of the checkpoint and restart handlers can be accomplished through a system call which can be implemented as a procedure in a kernel system call handler such as kernel system call handler . When a checkpoint becomes pending the kernel will set the value of the checkpnt pending variable to 1. At restart time the kernel will reset the variable to 0. The purpose of this flag is to override the pthread level CHKPNT PENDING flag. After a checkpoint completes it is undesirable for a pthread to see the CHKPNT PENDING flag set block when taking a lock. The thread first checks if checkpnt pending is set if not the thread can clear the CHKPNT PENDING pthread flag and carry on.

Kernel system call handler contains checkpnt checkpnt kill thread tsleep chkpnt and checkpnt deliver . These calls illustrated in kernel system call handler are calls presently available in operating systems such as AIX. Within kernel system call handler checkpnt is used to handle checkpoint calls. Checkpnt kill is used to initiate sending of a SIGADVH signal to other threads within a process in response to this function being called by a thread from that process. Thread tsleep chkpnt is used to suspend or cause a thread to go into a sleep state. Checkpnt deliver is used to indicate that the execution of a handler such as checkpoint handler may occur without deadlocks. The call is made for this function from a last thread whose lock count goes to 0.

Kernel heap contains thread structures and in these examples. As illustrated a one to one correspondence is present for thread structures in kernel heap and pthread structures in pthread library data because this is for a 1 1 model. Depending on the particular implementation a one to one correspondence may not be present between pthread structures in pthread library data and thread structures in kernel heap . Each thread structure contains a flag. In this example thread structure contains CHKPNT THREAD flag . The other thread structures also contain this type of flag. CHKPNT THREAD flag is used to indicate the thread that ran the checkpoint handler. At restart the kernel will run the restart handler on the same kernel thread. In this example three thread structures are illustrated for purposes of illustration. Other numbers of thread structures may be used depending on the particular implementation.

Turning now to a diagram illustrating data flow used in a checkpoint operation is depicted in accordance with a preferred embodiment of the present invention. Process and process are illustrated along with kernel to provide an example of signals and messages passed between different components in controlling a checkpoint operation. Kernel may be implemented using components from kernel in in these examples. Process contains threads and in these examples. Process initiates the checkpoint request on process by sending a checkpoint call to kernel message M . In response kernel sends a SIGADVH signal to process in which this signal is received by thread message M . In response to receiving this signal from kernel thread sets the value of a variable such as n threads in to the number of pthreads in the process and then issues a request to send a SIGADVH signal to all of the other threads within process using a checkpnt kill call message M .

In response to receiving this request kernel sends a SIGADVH signal to threads and messages M . As a result of receiving this signal a code is executed by each of these threads in the form of special signal handlers namely the SIGADVH handler in in these examples. These signal handlers automatically decrement the value of a variable such as n threads in if the lock count such as lock count in reaches 0 for the thread on which the handler is running. Otherwise the special signal handler will set a flag such as CHKPNT PENDING flag in on the thread to indicate that a checkpoint is pending that will be checked by the thread locking and unlocking primitives.

Locking primitives such as locking primitives in check for a checkpoint pending flag CHKPNT PENDING flag before taking a lock. If this flag is set and no locks are owned by the threads the thread is suspended. This suspended thread will not run until either the checkpoint fails or after the restart when the restart handler such as restart handler in completes. If a thread owns one or more locks this thread is allowed to take additional locks.

Unlocking primitives such as in can call a procedure at the end of the routine which is entered after unlocking the resource or object. The called procedure begins by checking to see whether the checkpoint pending flag is set if the lock count such as lock count in is 0. If this flag is set the value of a variable n threads in is decremented by 1. The last thread whose lock count goes to 0 thread in this example informs kernel that a checkpoint handler such as checkpoint handler in may be invoked using a checkpnt deliver call message M . The kernel invokes a checkpoint handler such as checkpoint handler in on thread message M . The kernel detects that the checkpoint handler has exited message M and control returns to the kernel. The kernel now suspends all the threads of the process message M and writes the process state to a checkpoint file.

With reference now to a flowchart of a procedure used for initiating a checkpoint operation is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a kernel such as kernel in .

The procedure begins by receiving a checkpnt system call step . This call may be received from a process such as process in . The checkpnt pending library variable such as checkpnt pending in is set to true step in the process to be checkpointed such as process and the SIGADVH signal is sent to this target process step and the procedure terminates thereafter. This initiates a checkpoint on process in .

Turning now to a flowchart of a procedure used for a SIGADVH handler is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a SIGADVH handler such as SIGADVH handler in . This handler is run by each thread that receives a SIGADVH signal such as the one generated in step in .

The procedure begins by making a determination as to whether the checkpnt pending equals true step . The checkpnt pending variable remains true as long as the checkpoint is pending for the process. If the checkpnt pending variable equals true a determination is made as to whether this is the first thread to receive the SIGADVH signal step . If this thread on which the process is running is not the first thread a determination is made as to whether the lock count is equal to 0 step . If the lock count is not equal to 0 the UPDATE PENDING flag is set on the thread step and the procedure terminates thereafter. The UPDATE PENDING flag is used later by the unlocking routine to determine if the decrementer procedure has been run for this thread. The decrementer procedure is described in more detail in below

Referring again to step if the lock count is equal to 0 the decrementer procedure is initiated step and the procedure terminates thereafter. With reference again to step if the thread on which the handler is running is the first thread n threads is set equal to the number of threads in the process step . The checkpnt kill is called to send a SIGADVH signal to all other threads in the process to initiate execution of this handler in those threads step and the procedure returns to step as described above. Referring again to step if the checkpnt pending does not equal true the procedure terminates. This could happen for special cases where a checkpoint was canceled after it was initiated in which case the kernel would set checkpnt pending to false.

With reference now to a flowchart of a procedure used for a modified locking primitive is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a thread such as thread or in .

The procedure begins by making a determination as to whether the checkpnt pending equals true step . If the checkpnt pending equals true a determination is made as to whether lock count for the thread is equal to 0 step . If lock count for the thread is equal to 0 a determination is made as to whether the CHKPNT HANDLER flag is set step . The CHKPNT HANDLER flag identifies the thread on which the checkpoint handler is running and if the flag is set the thread is allowed to take locks even if the checkpoint is pending. This can be implemented as a flag in the pthread structure such as CHKPNT PENDING flag and UPDATE PENDING flag in . If the CHKPNT HANDLER flag is not set a determination is made as to whether the CHKPNT PENDING flag is set step . The CHKPNT PENDING flag indicates the thread has already run the decrementer procedure.

If the CHKPNT PENDING flag is set the thread tsleep chkpnt is called to place the thread in a sleep state step . The thread is only awakened when the restart handler completes. The lock count for the thread is incremented step before initiating the standard locking routine is initiated step and the procedure terminates thereafter.

With reference again to step if the CHKPNT PENDING flag is not set the procedure proceeds to step as described above. Turning again to step if the CHKPNT HANDLER flag is set the procedure proceeds to step as described above. Referring again to step if the lock count is not equal to 0 the procedure proceeds to step as described above. With reference again to step if the checkpnt pending does not equal true the CHKPNT PENDING flag is reset if the flag is already set step and the procedure proceeds to step as described above. In all the above steps which proceed directly to step from steps and the thread is allowed to take the lock and the thread is not put to sleep as in step .

Turning now to a flowchart of a procedure used for an unlocking routine is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a library code such as library code in .

The flowchart specifically depicts the modifications at the back end of the unlocking routine. After completing the standard unlocking procedure to release a lock the present invention adds the following procedure which begins by decrementing lock count for the thread step . A determination is made as to whether lock count is equal to 0 step . If lock count is equal to 0 a determination is made as to whether the UPDATE PENDING flag is set step . The UPDATE PENDING flag indicates that a checkpoint is pending on this process but the decrementer procedure has not been run to decrement count in n threads in . If the UPDATE PENDING flag is set the decrementer procedure is initiated step and the procedure terminates thereafter. The decrementer procedure is described in more detail in below.

Referring again to step if the UPDATE PENDING flag is not set the procedure terminates. Turning again to step if lock count is not equal to 0 the procedure terminates.

With reference now to a flowchart of a procedure used for a decrementer procedure is depicted in accordance with a preferred embodiment of the present invention. This decrementer procedure is used to determine when a handler should be invoked. The procedure illustrated in may be implemented in library code such as library code in . These steps are executed by all of the threads with the last thread whose lock count is 0 initiating invocation of the handler. The procedure begins by resetting the UPDATE PENDING flag on the thread if the flag is already set step . The CHKPNT PENDING flag is set on the thread step . N threads is decremented atomically step . Next a determination is made as to whether n threads is equal to 0 step . If n threads is equal to 0 the CHKPNT HANDLER flag is set on the pthread step as the kernel will invoke the checkpoint handler on this thread. The checkpnt deliver is called to invoke the handler step and the procedure terminates thereafter.

Turning now to a flowchart of a procedure used for initiating execution of a handler when all of the threads have released all of their locks and have been suspended or placed in a sleep state is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a kernel system call handler such as kernel system call handler in . In particular this procedure is initiated when a call is made for the function checkpnt deliver in .

The procedure begins by setting the CHKPNT THREAD kernel flag on the caller thread step . The checkpoint handler on the caller thread is invoked step and the procedure terminates thereafter.

With reference now to a flowchart of a procedure used for a restart procedure is depicted in accordance with a preferred embodiment of the present invention. The procedure illustrated in may be implemented in a kernel system call handler such as kernel system call handler in .

The procedure begins by setting the checkpnt pending library variable to false step . The thread that has the CHKPNT THREAD flag set is resumed step . The restart handler is invoked on this thread is invoked step with the procedure terminating thereafter. At the completion of the restart handler all the suspended threads are resumed and restarted.

Thus the present invention provides an improved method apparatus and computer instructions for handling checkpoint processes in a manner that avoids deadlocks. The mechanism of the present invention does not initiate a checkpoint handler automatically when a signal is received requesting a checkpoint. Instead the mechanism of the present invention keeps count of threads which hold locks. Threads with no locks are suspended if the threads try to take a lock. After all of the threads which own locks have released all their locks the checkpoint handler is invoked. This mechanism ensures that no locks are being held. As a result a checkpoint handler may make many types of calls without a block or a lock occurring. Thus deadlocks are avoided in the checkpoint and restart operation.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

