---

title: Static typing of xquery expressions in lax validation content
abstract: Systems and methods that extend static typing rules/algorithms of the World Wide Web Consortium (W3C) rules, with a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section. The Lax validation can be identified, and associated expressions known with particularity, wherein types can be inferred for XQuery expressions that navigate down into the Lax validation section. An annotation component annotates elements (e.g., wild card sections) with additional information about wild card sections, and a mapping component maps Lax wild cards to type systems.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08606806&OS=08606806&RS=08606806
owner: Microsoft Corporation
number: 08606806
owner_city: Redmond
owner_country: US
publication_date: 20080725
---
As programming approaches and foundations have evolved application programming interfaces APIs and programming schemas have been developed to standardize and unify programming methodologies that were previously multi variant and relatively incompatible. Modern programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Such Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution. For example a significant component in functionality of Web Services is programmatic interaction with web data.

In general there are three major components that make up the world of web data relational data e.g. SQL self describing data e.g. XML and a runtime environment. A popular method of implementing a relational data model is by means of SQL Structured Query Language . SQL is a language used to communicate with a relational database management system such as SQL Server Oracle or Access data in a relational database system is typically stored in tables. An accepted standard for self describing data is XML eXtensible Markup Language . XML is a World Wide Web Consortium W3C standard language that describes data via a schema or Document Type Definition DTD . XML data is stored through the use of tags. A runtime environment is a general purpose multilanguage execution engine e.g. Common Language Runtime CLR that allows authors to write programs that use both relational data and self describing data.

XML provides syntax for describing heterogeneous graph s of data where typing rules usually called schema validation are optional and loosely bound to those type instances. Furthermore the XML schemas associated with those documents can describe more complex structures with sequences choices unbounded type collections and a combination of typed and untyped data. Such constructs are designed to allow a loosely coupled architecture that minimizes hard dependencies between different parties that make up a complex distributed system and have proven to be an effective way to make distributed systems scale up to a level of complexity required for today s interconnected business systems.

Accordingly wildcard characters can be employed to increase flexibility in what is allowed to appear in a content model. These characters are supported in the XSD language in ways such as element wildcard characters represented by the element Attribute wildcard characters represented by the element. Moreover both wildcard character elements and support the use of a processContents attribute. Such enables specifying a value that indicates how XML applications handle the validation of document content associated with these wildcard character elements. For example the strict value specifies that the contents are fully validated the skip value specifies that the contents are not validated the lax value specifies that only elements and attributes for which schema definitions are available are validated.

Furthermore the XQuery language provides for static type analysis and static type checking. Typically to perform static type analysis XQuery employs any available XML Schema information tied to the queried data if available to improve the preciseness of the inferred type. XML Schemas can contain very strict type constraints for which inferring a type is fairly straight forward but it also provides so called laxly validated content models and attributes expressed by the content type xs anyType the xs anyAttribute and xs any wildcard sections with the processContent property set to Lax. Such process content lax requires content model data to be strictly validated correct whenever a schema component can be found. Alternatively if no schema component is found no requirement of validation exists and such data can be considered very loosely typed.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The subject innovation extends static typing rules algorithms of the World Wide Web Consortium W3C rules to a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section wherein such Lax validation can be identified and the associated expressions known with particularity. Accordingly types can be inferred for XQuery expressions that navigate down into the Lax validation section and a more precise type rule is obtained as compared to current W3C algorithms. Such facilitates checking compatibility of types at time when operations are to be performed with expected types e.g. a check for numeric types as opposed to any type for mathematical operation wherein expressions can be compiled with knowledge for the types involved and errors mitigated optimizations introduced. In a related aspect an annotation component annotates elements e.g. wild card sections with additional information about wild card sections. Such annotation component can further be associated with a mapping component that maps Lax wild cards to type systems. As such nodes can be annotated for a path expression when a parser traverses nodes of a tree.

According to a methodology of the subject innovation initially a Lax wildcard section in a collection of XML schemas is mapped into the XQuery type system. Subsequently elements and attributes that are Laxly validated can be annotated with additional wild card constraint information. As such when an XQuery is received that queries using path expressions into a Lax validation section the subject innovation can supply type information and type inference rules to infer new static type information. This preserves knowledge of what types can be encountered within a Lax validation section to enable a more precise inference as compared to W3C rules.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject invention are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

In general conventional and existing XQuery standard provides minimal rules for the type inferencing of queries that delve into lax validation sections. For example such conventional approaches merely consider all lax elements and attributes to be of the most generic content type xs anyType for elements xs anySimpleType for attributes and hence do not provide more exact information. As such many perfectly legitimate queries typically fail static type checks because the inferred type is too broad and hence needs to be rejected. For example assuming one has the following XML Schema components where the element E has a lax validation xs anyType content model and the element integer is of the xs integer type 

The subject innovation provides for an extension to the typing rules algorithms of the World Wide Web Consortium W3C rules to create a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section wherein such Lax validation can be identified and associated expressions known with particularity. As illustrated in the types can be inferred for XQuery expressions based on the XML schemas that are associated with the in scope schema definitions of W3C to obtain a more precise type rule as compared to current W3C algorithms. Such facilitates checking compatibility of types at time when operations are to be performed with expected types e.g. a check for numeric types as opposed to any type for mathematical operation wherein expressions can be compiled with knowledge for the types involved and errors mitigated optimizations introduced.

To better appreciate novelties of the subject innovation the following discussion provides for two particular use case examples of what users deem important when employing Lax validation semantics.

A SQL Server system employs an XML datatype that is constrained by an XML Schema collection the SQL Server mechanism to define the inscope schema components that contains a base XML Schema describing the generic properties and uses an element of type xs anyType to allow users to either use some pre defined markup in the schema or use its own. An information worker e.g. Irene authors XML documents that makes use of the lax semantics of the element s xs anyType. In addition a database developer e.g. Dave writes queries against the data in the xs anyTyped element and desires such queries to exploit the schema type knowledge and obtain the type information of the pre defined markup elements.

A SQL Server system employs an XML datatype that is constrained by an XML Schema collection that contains a base XML Schema describing the generic properties and uses a lax wildcard section that allows other XML Schemas in the XML Schema collection to define the types in the section or allows the use of unknown elements.

 Dave the database developer writes an application that augments the base XML Schema with another schema that describes the application specific extensions in the lax wildcard section. Dave can write queries against the data in the lax wildcard section and desires the queries to exploit the schema type knowledge and obtain a similar behavior and experience as if the data was typed strict for the data that he knows he has a schema. As described in detail infra the subject innovation enables static typing rules for querying into laxly validated wildcards and xs anyType sections that supersedes and augments current W3C algorithms.

In general XML Schema provides two wildcard sections and the type xs anyType that implies a laxly validated wildcard content model. The attribute wild card section can be defined as 

Typically Lax validation of an element content wild card represents that given a sequence of elements se that are inside a lax wildcard or the content of an element typed with xs anyType the following rules can be applied 

Assuming that the given XML Schema collection consists of the set of schema components SC and that the lax validation section is constrained with the namespace constraints NS . For every element e in se one can check that 

Lax validation of an attribute content wildcard indicates that given a sequence of attributes sa that are validated according to the lax wildcard the following rules will be applied 

As a consequence of a successful lax validation every element and global attribute are either guaranteed to be valid according to their global XML Schema constraint with the given name or are considered to be of an unknown most general type e.g xs anyType for elements and xs anySimpleType for attributes .

In one aspect the subject innovation can improve static typing rules that capture the semantics implied by the lax validation rules and the available schema components as constrained by the in scope schema components and the namespace wildcards. As such when a path expression with an explicit name test enters into a lax wildcard section the subject innovation identifies whether the path selects an element or attribute that is known in the static schema context or it selects an element or attribute that is basically considered as any type. Moreover since a global element or attribute declaration can trigger a validation and thus typing of an element at any level within the lax wildcard section sub tree the type inference has to carry the information about the accessible global components down the tree. Once a known element or attribute is encountered or hit that type can be used and the wildcard can be dropped if possible.

In order to resolve a name inside a lax validation section one particular aspect of the subject innovation can employ namespace wildcard constraints as an additional filter against the statically known XML schema components to ensure absence of names that are disallowed while inferring the static type. According to a further particular aspect the subject innovation can introduce a name subtraction to the wildcard element. For example 

It is to be appreciated that such approach can require special rules for the subtractions and hence logically carry around a large amount of subtractions that are to be propagated since the schema element can appear within the xs anyType again.

In a related aspect the annotation component of the subject innovation can annotate the element and attribute wildcards with an optional namespace constraint. Basically elements and attribute wildcards element xs anyType and attribute xs anySimpleType obtain an additional constraint that indicates the set of namespaces that are used to constrain the wildcard section. Subsequently a mapping component can perform the mapping as in the first approach yet employ the namespace constraint. Thus the type of the example above can be 

NS for attributes and elements can be determined when mapping the schema components to the type system as explained in detail infra. Such can be based upon following rules 

1. If the namespace wildcard constraint is any a special indicator any is used to indicate that all the namespaces that belong to the static in scope schema components may appear as well as any other namespace 

2. If other is specified the set of all namespaces any minus the target namespace that contains the content model 

5. If the target namespace or the XML Schema collection contains the no namespace or local is specified then the no namespace is identified with local in the set.

6. Note that 1 and 2 can be considered open world namespace constraints meaning that NS does contain an infinite number of namespace uris beyond the ones contained in the XML Schema collection while c and d are closed world and NS only contains namespace uris as explicitly given.

7. The intuition of evaluating step expressions now is that whenever the NS is present it assumes the following 

The following are the formal rules following the syntax used by the XQuery Formal Semantics that show mapping via the mapping of the XML Schema component to the XQuery type system. It can be assumed that TGNS is the target namespace URI where the any section is being defined in local if it is the no namespace target namespace .

Typically the xs any wildcard can be mapped to the union of all top level elements allowed by the namespace constraint and the catch all of the element wildcard constrained by the namespace constraint. As such 

Conventional elements of type xs anyType are typically mapped to normal elements of type xs anyType. The subject innovation enables implementing standard semantics with lax validation and the mapping component can map the element of type xs anyType in the same way as an xs any wildcard section wherein the name of such element is known. Accordingly 

The following are the formal rules following the syntax employed by the XQuery Formal Semantics that show the mapping of the XML Schema component to the XQuery type system. It can be assumed that TGNS is the target namespace URI where the anyAttribute section can be defined therein. It is to be appreciated that union of all the global attribute declarations allowed by the namespace constraint is added later during the expansion phase of the containing element.

Subsequently and at elements of attributes that are Laxly validated can be annotated with additional wild card constraint information. As such when an XQuery is received that queries using path expressions into a Lax validation section the subject innovation can supply type information and type inference rules to infer new static type information at . Such can further preserve knowledge of what types can be encountered within a Lax validation section to enable a more precise inference as compared to W3C rules a .

In one aspect upon mapping wildcard sections to the type system and finding an element or attribute marked with a name space wild card constraint the type inference can be affected as described in detail below. Typically most rules can propagate the type with the namespace wildcard constraint. Yet rules for forward step expressions can exploit annotations to infer more precise types. In particular the axes and filter steps can be adjusted for the cases where they operate on a namespace wildcard constrained element or attribute.

The self axis rule does not change. As such element and attribute types with namespace wildcard constraints can be passed through unchanged.

In the case of an element type the static type of the child axis can be obtained by static name or type lookup in the static element declaration context. statEnvs.elemDecl and expansion of the type reference to the resulting type including the necessary adjustment and the extraction of the types which are not attributes e.g. the content type . Typically extraction allows any comments and processing instructions to be interleaved with the actual schema types. If the element type is marked with a namespace wildcard constraint then one can assume that a lax validation section has been entered wherein every step can be applied to every part of the union and that the inference is performed according to the general rules on all of the unmarked elements.

Initially one has to extend the static type lookup to ensure that the wildcard constraint is returned on global elements of type xs anyType. For example the In scope schema definitions ISSD contains the following declarations using XQuery SequenceType syntax 

Then the static type lookup of element e4 can supply no Nillable indication and the type reference xs anyType and the namespace wildcard constraint any. On the other hand the static type lookup of element e5 can supply no Nillable indication and the type reference eT5 and no namespace wildcard constraint.

Subsequently it can be required to augment the Expansion phase rules. Basically one needs to expand the attribute part of an element with an attribute having an attribute wildcard card constraint to include all the optional global attributes of the in scope schema components of the given XML Schema collection subject to the namespace constraint plus the catch all. Such can indicate additions to the all group of all specified attributes the all group. NS where NS is the namespace wildcard constraint on the anyAttributes section the catch all is already there . Note that the BuiltInAttributes of the xsi namespace still get type checked according to their types.

And when one extends content part of an element with an element namespace wildcard constraint then one can include all global elements of the in scope schema components of the given XML Schema collection subject to the namespace constraint plus the catch all. The catch all is any since the XML Schema validation rule does not typically provide for a restriction of the namespaces at deeper nesting levels. Accordingly any of the any sections within the element will be mapped to the already familiar

It is to be appreciated that in alternative approach mapping can also be performed from NS to any for deeper levels as part of the name filters.

The rule variable NS denotes the namespace wildcard constraint. The semantics of the rule about child axis filter on elements with simple content type of the XQuery Formal Semantics recommendation remains unaffected by the lookup and extension phase changes.

In case of an element type with complex content type the static type of child axis is obtained by static type lookup and expansion of the type then the extraction of the content type. It is assumed that in case of expansion of the complex content type one obtains all the comments and processing instructions added to the element and text node content models.

If the element s type allows mixed content a Child Type is obtained that is a union of either xdt anyAtomicType and the original type expanded with text nodes and PIs and comments. Thus neither of previous rules can apply and the following third rule can be introduced 

Finally if the element s type allows either simple or complex content type via xs anyType it is required to expand the original type with the namespace wildcard constraints and with text nodes e.g. the type inferred by the child axis filter can be pi comment element of type xs anyType text . Hence typically the previous rules do not apply and the following rule can be introduced 

It is noted that the ChildType already contains expansions with comments and processing instructions and in all three cases includes the expansions due to the namespace wildcard constraint. All the other child axis filter rules stay the same.

In case of an element type the static type of the attribute axis is obtained by static type lookup and expansion of the resulting type and extractions of the attribute types. Rule EXP A1 attribute axis filter on elements 

Again expansion can expand the AttributeType with the top level attribute types allowed by the attribute wildcard section if the element type contains an attribute namespace wildcard. All the other attribute axis filter rules can remain the same.

Since such improvement does not typically improve the static inference for parent axis the rules do not change in general. Note that the element of type xs anyType is not typically constrained by a namespace wildcard section. Therefore all the parent axis inference rules can remain the same.

The descendant axis is a depth first application of the child axis on all the descendant nodes until all leaf nodes have been reached. Inferring a precise static type is complex in the non recursive case we would need to make sure that the structure of the inferred type expression is correctly reflecting the structure of the depth first traversal of the descendants and impossible in the case of a recursive schema we would get an endless recursive type . Therefore the type inference infers the prime occ of all the types that we can find going down the child descendants including text pi and comments as provided by the child axes . Recursions don t have to be followed since the prime type factorization already has all the types that we could detect by following the recursion.

Since the descendant axis can not readily indicate whether the final step is selecting a global or local element inside a namespace wildcard section a union of both can be inferred. Also a descendant axis can encounter a variety of elements with different namespace wildcard constraints. Nonetheless since any descendant axes delves into deeper nesting levels of a wildcard section one can preserve one element wildcard section of the form element any xs anyType NillableAttribute as part of the prime type.

 d1 descendant e will still infer element e eT element e xs int Even if one of the other schemas would contain a local unqualified element name that name would be added to the inference but the catch all would not be needed. d1 descendant e will infer element e eT element e xs int element any e xs anyType since there can be elements from other namespaces with local name e. As explained earlier the subject innovation enables annotation of the element xs anyType with additional information about the wild card section.

Upon extending the wildcard section all the added element and attribute types can be addressed by the normal filter rules. However a special filter can be applied when one encounters a namespace wildcard constrained element or attribute type. Typically the Rules below follow a syntax of the conventional static typing specification. The sequence type notation that is used above of the form 

The first rule merely checks if the element type actually has the name of the filter and if so returns the element. If the name of the element can be matched even if the namespace wildcard constraint is present the result of the filter can match the element type e.g. if the element type is element any foo bar and the filter is element foo then the element type can be inferred. Note that one can obtain such element type by either an explicit declaration of the element foo to be of type xs anyType or by inferring it as part of a query into a laxly validated content model. Thus in general one needs to expand the rule slightly to match on elements with the namespace wildcard 

It is to be appreciated that every time a namespace constraint NS is part of the element type the type reference can be xs anyType and Nillable is true for this and all subsequent rules on name filters on element nodes. The next rule checks if the element type has no name since the element may have been created with a dynamic name or there existed an untyped document or a type inference lost the name . If no name existed then either an element with that name exists with the type of the element or it does not exist. If a namespace constraint is present then the constraint is to be checked. In general if any of the namespaces allowed by the constraint are defined in the in scope schema components as defined by the XML Schema collection associated with the document defining an element of the given name then this filter has been satisfied more precisely elsewhere and thus this rule can infer empty. In all other cases where the namespace matches but the name does not or neither is matching but the namespace is allowed the type gets exposed with the name added and carrying on the namespace constraint.

Several rules below perform the checks above for the case where one does not have a QName as filter but a QName wildcard. Rule FIL E3 element QName filter on element node with name NCName and namespace constraint 

The following rules perform the checks above for the case where one does not have a QName as filter but a QName wildcard. Initially one can check for the NCName case. If the element with the wildcard constraint has a given name then it can be permitted with the given name and propagate the wildcard constraint

If a namespace wildcard constraint is encountered one can return either NCName for the given name if the namespace wildcard is open any other or a wildcard for everyone of the explicitly allowed namespace URIs with the given name assuming that that name has not been found. The union can then collapse it into a single element all NCName xsanyType . Note that one can infer a more complex union of all names from the namespaces allowed that have not a more precise definition.

Rule FIL E6 element NCName filter on element node without name and open namespace wildcard constraint 

Rule FIL E7 element NCName filter on element node without name and closed namespace wildcard constraint 

Rule FIL E8 element NCName filter on element node with name NCName and open namespace wildcard constraint 

Rule FIL E9 element NCName filter on element node with name NCName and closed namespace wildcard constraint 

The following rule manages a name test filter where the name is given and all namespaces can be employed against an element node with a namespace wildcard constraint that has the namespace uri preserved but no name. The namespace uri on that element is in the allowed set of namespaces of the namespace wildcard constraint since otherwise validation would have rejected the element.

Moreover to ensure that the local name has not been covered by one of the globally declared elements the following rule can further be added Rule FIL E10 element NCName filter on element node with name NCName and namespace wildcard constraint 

The next additional rules check for the NCName case where the element has a namespace wildcard. As explained earlier if the element node name has already a name space one can assume that it is part of the allowed namespace constraint due to the validation guarantee that no other namespace is allowed. Likewise when there is no name it can be ensured that the namespace is allowed.

Rule FIL E13 element NCName filter on element node with name NCName and namespace wildcard constraint 

Rule FIL E14 element NCName filter on element node with name NCName and namespace wildcard constraint 

In case of the general wildcard one can preserve the type regardless of whether the element type had a name or not and propagate the namespace wildcard constraint if present. Thus the existing rule can be maintained. Hence Rule element filter on element node . Similarly other rules on other node types do not change either.

Substantially similar rules apply if the principle node kind is attribute . However since the attribute namespace wildcard constraint is not being propagated down one typically does not require to preserve it in its inference. As explained earlier again it can be assumed that matching any globally known attribute has been added in the expansion phase and is otherwise checked. Accordingly they can be excluded as described below. It is to be appreciated that the TypeReference can typically refer to xs anySimpleType with namespace constraints.

Accordingly the first rule just can check if the attribute type actually has the name of the filter and if so returns the attribute type under an assumption that the globally known attributes are checked elsewhere.

The next rule can check if the attribute type has no name. If there existed no name then either an attribute with that name exists with the type of the attribute or it does not exist. Again one can infer empty if the namespace of the filter is not allowed by the namespace wildcard constraint or already exists globally.

Moreover later rules below perform the checks above for the case where one does not have a QName on the node but a QName wildcard. Since they infer wildcards one has to add rules for filtering on an attribute type that contains such wildcards and have to take the namespace wildcard constraints into account. As in the element case if one can infer a complete name one will have to apply such rules only if the name does not match a globally declared attribute and one does not have to check for the namespace to be allowed by the namespace wildcard constraint.

Rule FIL A3 attribute QName filter on attribute node with name NCName and namespace wildcard constraint 

Rule FIL A4 attribute QName filter on attribute node with name NCName and namespace wildcard constraint 

In addition the following rules perform checks above for the case wherein one does not have a QName as filter but a QName wildcard. Since wild cards are inferred wildcards one can add rules for filtering on an attribute type that contains such wildcard and has to take the namespace wildcard constraints into account. As in the element case if one can infer a complete name one can further apply such rules only if the name does not match a globally declared attribute and one has to check for the namespace to be allowed by the namespace wildcard constraint. First one can check for the NCName case.

If the attribute node to be checked has no name given or has a wildcard for its attribute name one can infer a wildcard of xs anyType in the case that the namespace wildcard constraint is closed. Otherwise one can infer the wildcard wherein one can infer an all group for all the known namespaces in the closed case for the attributes for which no global definition exists.

Rule FIL A6 attribute NCName filter on attribute node without name and closed namespace wildcard constraint 

It is to be appreciated that such rule can be written as FIL A6alt if one desires to preserve the all group of all the names.

Rule FIL A6alt attribute NCName filter on attribute node without name and closed namespace wildcard constraint 

Rule FIL A7 attribute NCName filter on attribute node without name and open namespace wildcard constraint 

Rule FIL A8 attribute NCName filter on attribute node with name NCName and closed namespace wildcard constraint 

It is to be appreciated that such rule can be written as FIL A8alt if one desires to preserve the all group of all the names 

Rule FIL A8alt attribute NCName filter on attribute node with name NCName and closed namespace wildcard constraint 

Rule FIL A9 attribute NCName filter on attribute node with name NCName and open namespace wildcard constraint 

Likewise the following rule s can preserves prefix from the input and adds the name from the filter. As in the element case one already has inferred a more precise type if the name exists as a global declaration.

Rule FIL A10 attribute NCName filter on attribute node with name NCName and namespace wildcard constraint 

Subsequently one can heck for the NCName case. Again in this case if the attribute node name has already a name space it can be assumed that it is part of the allowed namespace constraint due to the validation guarantee that no other namespace is allowed. Moreover no name exists and one has ensure that the namespace is allowed.

Rule FIL A12 attribute NCName filter on attribute node without name and namespace wildcard constraint 

Rule FIL A13 attribute NCName filter on attribute node with name NCName and namespace wildcard constraint 

Moreover in case of the general wildcard one preserve the type and do not care about whether the attribute type had a name or not. However one can still drop the NS constraint and thus change the rule of the original static typing specification as follows 

The compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include various expressions and associated functions methods and or other programmatic constructs. The compiler can process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things.

The converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which can then provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component or another component can inject code corresponding to facilitate efficient and proper execution. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but output code that is executable by a virtual processor can also be provided.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various stages during processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors. Upon detection error checker component can halt compilation and generate a message indicative of the error.

As used in herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component can be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

Furthermore all or portions of the subject innovation can be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures and the like which perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the innovation can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the subject innovation is described that includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile nonvolatile computer storage media. illustrates a disk storage wherein such disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 60 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes various exemplary aspects. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the aspects described herein are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims.

Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

