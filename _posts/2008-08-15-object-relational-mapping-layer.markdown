---

title: Object relational mapping layer
abstract: An integration server system for mapping data objects on a database schema offers a strongly-typed model API, complex constraint management, and association balancing. The integration server system also has improved performance through optimized handling of ordered associations of data object and of string-valued attributes. The integration server system comprises a database schema configured to store a set of data object instances. A metadata model represents a configuration of the set of data object instances in the database schema. A model application programming interface provides a client application with access to the set of data object instances, and a metadata application programming interface provides a client application with access to the set of data object instances via the metadata model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08145685&OS=08145685&RS=08145685
owner: Oracle International Corporation
number: 08145685
owner_city: Redwood Shores
owner_country: US
publication_date: 20080815
---
This application is a continuation of U.S. patent application Ser. No. 10 684 055 entitled Object Relational Mapping Layer filed Oct. 10 2003 which is hereby incorporated herein by reference for all purposes.

A wide variety of software applications need to create modify store and analyze large quantities of data. Relational database management systems are ideally suited towards this need providing the resources needed to handle large quantities of data. However many typical software applications handle data in the form of data objects and it is difficult for these applications to manipulate data in databases directly. In contrast relational database management systems often cannot operate on data objects directly.

To address this difficulty object relational mapping tools translate data stored in a database into data objects to be manipulated by software applications. Object relational mapping tools hide the complexity of the underlying database from the end application. However these object relational mapping tools do not provide full object management features and integration with the database. Further the performance of prior object relational mapping tools is limited and allows for errors to be introduced by applications.

It is desirable to have an integration server system with object relational mapping tools that provides a strongly typed model application programming interface complex constraint management and association balancing. The system also has improved performance through optimized handling of ordered associations of data object and of string valued attributes.

An embodiment of an integration server system for mapping data objects on a database schema offers a strongly typed model API complex constraint management and association balancing. This embodiment of the system also has improved performance through optimized handling of ordered associations of data object and of string valued attributes.

In one embodiment the integration server system comprises a database schema configured to store a set of data object instances. A metadata model represents a configuration of the set of data object instances in the database schema. A model application programming interface provides a client application with access to the set of data object instances and a metadata application programming interface provides a client application with access to the set of data object instances via the metadata model.

In a further embodiment the database schema includes a table having a plurality of rows and columns to store the set of data object instances and the metadata model includes a representation of the table. In yet a further embodiment the model application programming interface accesses the set of data object instances via the metadata application programming interface.

In another embodiment the database schema includes a sequence attribute to preserve an ordered association between the set of data object instances such that an intermediate sequence attribute instance has a random value between a pair of values of a pair of adjacent sequence attribute instances. In a further embodiment the intermediate sequence attribute instance has a floating point value.

In yet another embodiment the database schema alternately stores an instance of a string valued attribute of the set of data object in a first data type or a second data type in response to the length of the instance of the string valued attribute. The first data type is a fixed length data structure and has a predetermined size. The first data type stores the instance of the string valued attribute in response to the instance of the string valued attribute having a length less than the predetermined size. Alternatively the second data type is a variable length data structure that stores the instance of the string valued attribute in response to the instance of the string valued attribute having a length greater than the predetermined size.

In a further embodiment the model application programming interface receives the instance of the string valued attribute from a client program determines the length of the instance of the string valued attribute and directs the instance of the string valued attribute to either the first data type or the second data type in response to the length of the instance of the string valued attribute. In still a further embodiment the first data type is associated with a first column of a table of the database schema and the second data type is associated with a second column of the table of the database schema.

In an additional embodiment the database schema includes a database constraint adapted to ensure that the set of data object instances include a set of valid attribute values. A class type attribute identifies each of the set of data object instances as a member of at least one of a plurality of classes and the database constraint is conditioned on the value of the class type attribute. An examples of database constraints includes a not null constraint.

In yet another embodiment of the invention the model application programming interface includes an association balance method adapted to balance an association attribute of the set of data object instances.

A further embodiment of the invention includes a generator to create the database schema in response to a model description. The generator may also create a database constraint to ensure that the set of data object instances include a set of valid attribute values. Furthermore the generator may create a fixed length data structure having a predetermined size and a variable length data structure adapted to alternately store an instance of a string valued attribute. In one example implementation the model description defines a data object hierarchy using the unified modeling language. In another embodiment of the invention the generator creates a definition of a data object in the database schema.

A web server is used to process requests for web pages or other electronic documents from user computers and . In an embodiment of the invention the data analysis software operates within a web browser on a user computer. In this embodiment all user interaction with the data analysis software is via web pages sent to user computers via the web server .

Web application server operates the data analysis software. In an embodiment the web application server is one or more general purpose computers capable of executing programs or scripts in response to the user computers and . The web application can be implemented as one or more scripts or programs written in any programming language such as Java C or C or any scripting language such as Perl Python or TCL.

In an embodiment the web application server dynamically creates web pages for displaying the data analysis software. The web pages created by the web application server are forwarded to the user computers via web server . Similarly web server receives web page requests and input data from the user computers and and forwards the web page requests and input data to web application server .

The data analysis application on web application server processes input data and user computer requests and can be stored or retrieved data from database . Database stores data created and used by the enterprise. In an embodiment the database is a relational database such as Oracle 9i that is adapted to store update and retrieve data in response to SQL format commands.

An electronic communication network enables communication between computers and web server web application server and database . In an embodiment network may further include any form of electrical or optical communication devices including wireless and wired networks. Network may also incorporate one or more local area networks such as an Ethernet network wide area networks such as the Internet and virtual networks such as a virtual private network.

The system is one example for executing a data analysis software according to an embodiment of the invention. In another embodiment web application server web server and optionally database can be combined into a single server computer system. In an alternate embodiment all or a portion of the web application functions may be integrated into an application running on each of the user computers. For example a Java or JavaScript application on the user computer is used to retrieve or analyze data and display portions of the data analysis application.

Computer readable storage media and machine readable storage media for containing code or portions of code executable by computers user computers and and servers and can include any appropriate media known or used in the art such as but not limited to volatile non volatile and removable non removable media. Examples of computer readable storage media include RAM ROM EEPROM flash memory CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store data and or program code and that can be accessed by a computer.

In response to the model description the model generator creates a database schema a model application programming interface API and model metadata. The database schema is adapted to store instances of the data objects defined by the model description in a database. In an embodiment the database schema includes one or more database tables adapted to be implemented in a relational database system. In a further embodiment each database table corresponds to a class of data objects. For an inheritance hierarchy of classes a single table is created to encompass all classes in the hierarchy.

The model API enables client applications to create instances of the data objects and to store read or modify the attributes of the data objects. The model API in conjunction with the rest of the integration server automatically handles the conversion of data objects from their format as stored in the database schema into a format used by the client applications . Because client applications may use data objects in a variety of different formats the integration server is also capable of converting data objects between different formats specific to two or more client applications.

In an embodiment the model API creates a direct representation of the data objects defined by the model description. Client applications written in an object orientated programming language such as Java can access the data objects in the same manner as any other object in the programming language. In a further embodiment the model API includes a set of functions or methods corresponding to the attributes of the data objects defined by the model description . These accessor functions or methods enable client applications to read or set attributes of instances of the data objects. The model API creates the appropriate database commands to perform the desired operation on the data object instance in the database schema . In addition as data object attributes may be defined according to a specific data type these accessor methods provide a strongly typed interface to client applications ensuring that only appropriate data types are used.

In addition to the model API the generator generates metadata describing the data objects and its corresponding database schema . illustrates an example metadata model enabling persistency services and generic user access for data objects according to an embodiment of the invention. The metadata model is accessed by client applications via metadata API . Unlike the model API which enables client applications to access instances of data objects as separate objects the metadata API enables client applications to access definitions of data objects directly within the database schema . Additionally client applications can create and update objects generically i.e. without using the model API generated for the object by using the metadata API to specify one or more pairs of attribute names and their corresponding values. For example a client application can specify that the attribute name should have a value of Fred by calling a generic metadata API function setProperty with the parameters name Fred . In a further embodiment the model API internally translates each of its object specific method calls into a generic metadata API method call with the appropriate set of attribute name and value parameters.

The metadata model includes a MetaManager a MetaClass a MetaAttribute and a MetaAssociationEnd . In an embodiment there is an instance of the MetaClass for every class of data objects defined by the model description . Client applications can use the metadata API to access both attributes of data objects and their associated metadata. For example the metadata API includes the method getAllAttributes which retrieves a list of all attributes for a given class. In addition the metadata API can access the MetaClass attribute tableName to get the name of the database table containing the class of data objects in the database schema . Similarly there is an instance of the MetaAttribute for each of the attributes of a data object. Client applications can use the metadata API to access both individual attributes of data objects and their associated metadata. For example the MetaAttribute has an attribute columnName identifying the column of a database table containing the attribute of a data object.

In a further embodiment the metadata is stored both statically within the metadata model and within the database schema . Storing metadata in the metadata model improves performance by reducing the number of database accesses. Storing metadata redundantly in the database schema enables metadata to be accessed outside of the metadata API for example through database commands in PL SQL.

The integration server includes additional modules to enable operations of persistency caching versioning consistency access control and impact analysis.

In yet another embodiment the additional modules are used to instantiate or create instances of data objects in the database schema. In this embodiment client applications request the creation of one or more new data objects via the model API. The model API communicates this request with the additional modules which in turn creates the instance of the data object in the database schema . The additional modules also returns a reference to the data object instance to the requesting client application which enables the client application to access the data object instance. This embodiment allows the integration server to change database schemas persistency service implementations or even generators without changing the model API thereby reducing the need to recompile and or modify client applications for different database schemas and persistency service and generator implementations.

Data objects can be associated with one or more other data objects. For example an instance of a Purchase Agreement object may be associated with two or more instances of Trading Partner objects representing the parties to the agreement. The database schema stores the associations between data objects. In an embodiment each association is an attribute of a data object represented by a column of a table in the database schema. Each instance of a data object is assigned an ID number in the database schema. The ID number of a first instance of a data object is stored in the association column also referred to as a foreign key column of a second instance of a data object to define an association between two data objects.

For example illustrates a table of transformation mappings . Each transformation mapping specifies how to convert data objects from one format to another. Example table includes two transformation mappings entitled MAP and MAP . In order to convert data objects between different formats each transformation mapping has at least one and typically many transformation rules. In the example of transformation rules are stored in a transformation rule table . In this embodiment all of the transformation rules are stored in the same table regardless of the transformation mapping they belong to.

In table each transformation rule includes a foreign key attribute stored in the MAP ID column. The foreign key attribute identifies the transformation mapping associated with each transformation rule. For example transformation rules and are associated with transformation mapping MAP and transformation rule is associated with transformation map MAP . 

For some types of data objects it is necessary to preserve the order of associations. For example transformation rules typically need to be executed in a specific order to properly convert data objects between formats. Typically database systems retrieve data in the order it is read from disk which does not preserve association order.

In one embodiment association order is done by utilizing an additional sequence attribute column that contains a numeric value corresponding to the association position. When the association is queried from the database the resulting data can be sorted by the sequence attribute to construct a list with data in the proper order.

As the associations of a data object are manipulated for example by adding new data objects removing old data objects or reordering data objects the values of the sequence attribute must be computed. Although this is trivial when objects are added to the beginning or end of the sequence it is difficult and time consuming for data objects in the middle of a sequence. One prior solution requires that the sequence attributes for the entire sequence by recomputed when data objects within a sequence are changed. This requires a large number of database updates which decreases performance.

For a new data object inserted within a sequence between two preexisting data objects the new sequence value equals the average of the adjacent sequence values plus or minus a random portion of the difference between the adjacent sequence values. The use of a random number in determining the sequence value enables two different applications to manipulate the same association at the same time and to add different data objects to the sequence. In this embodiment it should be noted that sequence values can be positive or negative floating point numbers. This enables data objects to be added within a sequence without resorting the entire sequence up to the limits of numerical precision used by the floating point numbers. It should also be noted that this embodiment of the invention can be applied to data objects of any type in which association order must be preserved.

When data objects are read back from the database schema they are sorted according to their sequence values. This ensures that the ordering of associations is always consistent.

For example if rule of table is to be associated between rules and a sequence value for rule is determined to be twenty five the average of the adjacent sequence values plus 0.8 a random portion of the interval between rules and resulting in a sequence value of 25.8. In order to retrieve the rules of transformation mapping MAP in the correct order a database query such as select from TRules where map ID 1 order by map seq can be used.

In a typical prior database schema implementations strings of characters referred to as strings can be stored in an array of characters of a predetermined and fixed length or in a variable length array or other data structure such as a database CLOB data structure. Although variable length data structures offer flexibility in being able to handle strings of arbitrary length they often suffer from slow performance. Fixed length arrays can be accessed quickly but cannot accommodate strings longer than the size of the array.

In an embodiment the model API associated with the integration server automatically assigns attribute values to the appropriate column of the database schema. For example upon receiving a new or updated attribute value from a client application the model API determines the length of the attribute value and issues a database command to store the attribute value in the appropriate column associated with the attribute. In a further embodiment the generator automatically creates the string and a variable length data structure columns in the database schema for each string valued attribute defined by the model description. Additionally the generator also creates the corresponding model API methods for assigning attribute values to the appropriate column of the database schema.

In a further embodiment when an attribute is stored in column in a fixed length data structure the corresponding location in column associated with a variable length data structure is set to a null value and vice versa. This ensures that only one attribute value is stored for each attribute. Additionally when reading an attribute value from the database schema the values of both columns and are read and the non null value is then returned as the attribute value. If the values of both columns and are both null values then a null string is returned as the attribute value.

As discussed above the model description can define a hierarchy of related data objects. In an embodiment a hierarchy is implemented in the database schema as a single table with a set of database constraints to ensure each data object has a set of valid attributes. illustrate an example object hierarchy and a corresponding database schema implemented using database constraints according to an embodiment of the invention.

In example data object hierarchy Party is a super class. Data objects Organization Application and Person are subclasses of Party . Trading Partner is subclass of Organization . An embodiment of a database schema implementing this hierarchy includes a single table for implementing all of the data objects of the hierarchy . Because all of the data objects in hierarchy are stored in a single table in this example database schema table includes columns for all of the attributes of all of the data objects in the hierarchy .

Different data objects depending upon their relationship in the hierarchy may only include a portion of the total set of attributes. For example data objects and all inherit the name and description attributes from party data object . However only data object includes the password attribute. Database constraints are used to ensure that each instance of a data object has only the proper attributes. For example the name and description columns are used for all data objects in the hierarchy . In contrast the password column is only used for instances of person objects. In an embodiment the database constraints use the contents of a Class Type column added by the generator to distinguish different object types stored in the table and to apply the appropriate constraints associated with that object type.

In an embodiment the generator creates a single table for the class hierarchy. The generator creates a column name for each attribute. A class type column is also created to differentiate the data objects.

Attributes and associations can be classified as mandatory or optional for each class and subclass. For mandatory attributes a NOT NULL database constraint should be generated for mandatory attributes. For example in hierarchy attribute name is mandatory for party and the association between Organization and person is mandatory for the person class. As party is a super class all subclasses will inherit the mandatory name attribute. Thus the name attribute should be associated with a NOT NULL database constraint for all classes. Similarly the password attribute should be associated with a NOT NULL database constraint only for instances where the Class Type column has a value of person. Table 1 illustrates example source code used by the generator to create table with the appropriate database constraints.

The following pseudo code illustrates an example algorithm for generating NOT NULL database constraints and XOR or Arc database constraints discussed below according to an embodiment of the invention.

Database constraints can be used to implement a variety of conditions on a database schema. In addition to ensuring that mandatory attributes are provided constraints can ensure that attribute values fall within a predetermined valid range or that associations with other data objects either within the same table or a separate table have valid foreign key values. In a further embodiment database constraints can ensure that only one of a pair of mutually exclusive attributes has a value in each instance of a data object. illustrates an example object hierarchy to be implemented using database constraints according to an embodiment of the invention. In example hierarchy the InteractionSpecType can be associated with either translator via either inboundTranslator or outboundTranslator or adapter provider via interactionSpecs as indicated by XOR operator . Table 3 illustrates example code implementing a database schema enforcing this constraint.

In a further aspect of the invention updating one end of an association between two data objects automatically updates the data object at the other end of the association. For example if a Department data object adds an association to an Employee data object the Employee data object should automatically be updated with association back to the Department data object. To achieve this data classes include additional WithoutBalance accessors methods. Upon updating one end of an association the WithoutBalance accessor method of the data object at the other end of the association is invoked.

The WithoutBalance method updates the association on just one end of the association as opposed to a regular accessor method that updates both ends of the association by calling WithoutBalance methods. In the latter case the accessor methods would each end up calling update methods on their counterparts resulting in an infinite loop.

As discussed above database constraints are used to ensure that valid attribute values are stored in the database schema. In an embodiment the database constraints are immediate constraints which are checked immediately as an instance is written rather than at the end of a complete database transaction. Immediate constraints have the advantage of generating an error immediately when an instance is written enabling applications to easily trace the source of the error. However using immediate constraints requires that data object instances be written in a specific order to ensure that the foreign key constraints are not violated for valid data. For example parent data objects must be written prior to their child data objects to ensure that the child objects reference valid foreign keys for their parent associations.

Table 4 illustrates example pseudo code for an algorithm used to ensure proper write through order according to an embodiment of the invention.

As shown with the algorithm of table 4 data objects can have a number of different states such as queried created updated and deleted. illustrates a state diagram for storing data objects in a database according to an embodiment of the invention. The state diagram of determines whether an object needs to be updated or stored in the database according to the state associated with the object. Additionally the model API can create and store temporary data objects. Temporary data objects can be used to collect and store data from applications in stages. Once data collection has been completed the temporary data objects can be converted into permanent data objects and stored in the database schema.

This invention provides a system for mapping data objects on a relational database schema that offers a strongly typed model API complex constraint management and association balancing. The system also has improved performance through optimized handling of ordered associations of data object and of string valued attributes. Although the invention has been discussed with respect to specific examples and embodiments thereof these are merely illustrative and not restrictive of the invention. Thus the scope of the invention is to be determined solely by the claims.

