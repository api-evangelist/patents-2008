---

title: Highly efficient guarantee of data consistency
abstract: The disclosed embodiments are directed to improving the efficiency of guaranteeing data consistency to clients, such as for one or more objects stored on a plurality of volumes configured as a Striped Volume Set. In particular, the disclosed embodiments optimize requests from clients which span multiple Data Volumes and which require strong serialization. The disclosed embodiments provide a “viral ticket book” model that provides lower latency while improving compatibility with client protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08949614&OS=08949614&RS=08949614
owner: NetApp, Inc.
number: 08949614
owner_city: Sunnyvale
owner_country: US
publication_date: 20080418
---
The present application is related to the following U.S. patent applications the contents of all of which are hereby incorporated by reference 

U.S. patent application Ser. No. 10 727 169 entitled METHOD AND APPARATUS FOR DATA STORAGE USING STRIPING by Michael L. Kazar et al filed on Dec. 2 2003 

U.S. patent application Ser. No. 11 119 278 entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER by Michael Kazar et al. filed Apr. 29 2005 and

U.S. patent application Ser. No. 11 261 007 entitled SYSTEM AND METHOD FOR EFFICIENTLY GUARANTEEING DATA CONSISTENCY TO CLIENTS OF A STORAGE SYSTEM CLUSTER by Michael Kazar et al. filed on Oct. 28 2005.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on volumes as a hierarchical structure of data containers such as files logical units or other objects. For example each on disk file may be implemented as a set of data structures i.e. disk or data blocks configured to store information such as the actual data for the file.

A known type of file system is a write anywhere file system that does not over write data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network.

A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. However often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system.

 Weak serialization may refer to the servicing of multiple data access requests distributed among multiple volumes from clients which do not require that multiple requests to access the same data container or portion thereof be serviced in any particular order. In storage systems which service clients of this type mechanisms may be provided to service those requests in a manner that promotes efficient operation of the storage system. Strong serialization may refer to the servicing of requests for clients which do require that multiple requests from one or more clients to the same data container or portion thereof at least appear to be serviced in an order expected by those clients. With regards to these types of clients additional mechanisms may be required to efficiently service their requests.

By way of introduction the disclosed embodiments relate to improving the efficiency of guaranteeing data consistency to clients such as for one or more data containers e.g. files or other objects e.g. directories stored on a plurality of volumes configured as a Striped Volume Set SVS . Data consistency refers to the expectation by a given client as to the order in which requests at least appear to be serviced by a file system. Clients may validate an expected ordering by observing attributes associated with the object such as data modification timestamps returned by the file system in response to data access requests referred to as post operation attributes. In particular the disclosed embodiments optimize requests from clients for objects which span multiple Data Volumes and which require strong serialization i.e. that requests at least appear to be serviced in an expected order based on for example the attributes such as the data modification timestamps of the object. The disclosed embodiments provide a viral ticket book model that provides lower latency while improving compatibility with client protocols by caching the ticket book i.e. allocations of data modification timestamps at the network interfaces of the storage system. Thereby the network interfaces become proxies for the requesting clients e.g. represent the clients expectations with respect to the attributes that are provided by the storage system via the network interfaces in response to data access requests from those requesting clients.

In prior file systems centrally allocated non overlapping blocks ranges of data modification time stamps referred to herein as ticket books described in more detail below may be employed to improve storage system performance for clients that do not require strong serialization semantics i.e. do not require for example that particular data operations on the same data be performed in the order in which they were received. When the file system performs requested operations which modify objects or portions thereof a modification time attribute referred to as an mtime is assigned to the object indicative of the state of the file or portion thereof at the time the modification request is performed. This mtime may be returned to the requesting client in response to a request to perform an operation. In systems which utilize ticket books these mtimes are assigned from a ticket book. Because different portions of the file system may be performing modification operations at any given time and need to assign mtimes each may hold a ticket book as described below from which they can assign mtimes without assigning duplicate mtimes. For clients using file system protocols that support weak serialization semantics i.e. allow operations to occur in an order different from the order in which they are received such as CIFS a data volume DV may utilize a ticket book in a manner that obviates the need to guarantee that each subsequently assigned data modification time stamp always increases i.e. are always later in time. That is a DV may assign an mtime from its ticket book to a particular portion of a file stored therein while another DV storing a different portion of the file subsequently assigns an earlier mtime from its ticket book e.g. the modification appears to have occurred earlier in time to the client when in fact it occurred later in time.

However in these prior systems for clients using file system protocols that require strong serialization semantics the DV may only use the ticket book if it received file operations prior to requesting and granting of that ticket book. This further includes clients requiring strong serialization semantics which may share data with other clients using file system protocols that do not require strong serialization semantics. Otherwise a new ticket book is requested and granted from the Container Attribute Volume CAV also referred to as the File Attribute Volume FAV or File Attribute Server FAS to process the received file operations. This new ticket book will contain a new allocation of non overlapping time stamps which will all be greater later in time than prior allocations. This allows the DV to assign an mtime therefrom which is guaranteed to be greater than previously the assigned mtime and thereby ensure that client receives the expected results of their request i.e. that the particular operation was serviced later in time as expected. Use of the ticket book in connection with weak serialization semantics thus reduces the number of round trip exchanges needed between the DV and CAV to service file operations. In other words because the DV does not have to stall operation requests waiting for the grant of a new ticket book the number of round trip exchanges between the DV and CAV is reduced compared to the number of round trip exchanges needed for protocols that require strong serialization semantics.

To improve efficiency the disclosed embodiments optimize requests from clients which span multiple DV s and which require strong serialization to ensure perception by a client of a sequence of operations with respect to a given object based on its attributes at any one of a number of interfaces to the file system. The disclosed embodiments provide a new form of ticket book as described above referred to as a viral ticket book that provides lower latency while improving compatibility with client protocols. While the embodiments below are described in relation to files it will be appreciated that the disclosed mechanisms may be used with other objects such as directories which span multiple DV s.

As discussed above a plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. However often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system. However a noted disadvantage arises when only a single data container such as a file is heavily accessed by clients of the storage system environment. As a result the storage system attempting to service the requests directed to that file may exceed its processing resources and become overburdened along with a concomitant degradation of speed and performance.

This may be overcome by striping the file across a plurality of volumes configured as a striped volume set SVS where each volume such as a data volume DV is serviced by a different storage system thereby distributing the load for the single file among a plurality of storage systems. According to the data container striping arrangement each storage system may service access requests i.e. file operations from clients directed to the same file. File operations such as read and write operations are forwarded directly to the storage systems that are responsible for their portions of the data for that file.

In addition to the file data there are metadata such as timestamps and length associated with the file. As was described a timestamp is a file attribute that provides an indication of the last time the file was modified i.e. the modification time mtime for the file. The mtime is typically consulted on every operation directed to the file and in the case of a write operation is changed. For example in response to a read operation issued by a client the storage system returns the data and the current mtime on the file whereas in response to a write operation the storage system returns an incremented mtime. Effectively every successive write operation is accorded a greater mtime than the one before it.

Many client protocols such as the Network File System NFS protocol allow use of client side caching of data retrieved from a storage system. In response to a read operation issued by a client for a file the storage system returns the requested data along with the current mtime of the file. The client stores the information in a cache memory so that future read operations directed to that file data may be serviced locally at the client from the cache instead of remotely over the network. For such client side caching to operate properly there should be guarantees that the data subsequently retrieved from the cache is consistent with the actual file system and not stale i.e. that the file data has not changed since it was cached at the client. To that end the NFS protocol enables periodic pinging polling of the state of the file by the client through requests for the current mtime of the file from the storage system If the mtime has not increased since the data was cached the client side cache is maintained fresh and the client continues to use the cached data. If the mtime has changed then the client discards its cached data and reissues a read operation to the storage system for file data.

Note that as used herein file operations are serializable if they can be replayed in a reported order and the result is identical to the actual file system. File operations are causally connected if they affect the same metadata or the same region of the same file. Some client protocols like NFSv2 require strong serialization semantics that is mtimes must always increase for operations that complete with increasing wall clock time even if they are not causally connected. Weak serialization semantics on the other hand only require that mtimes always increase for operation that complete with increasing wall clock time if the operations are causally connected.

Certain file system protocols such as the Common Internet File System CIFS protocol support weak serialization semantics because of the nature of soft locks such as opportunistic locks op locks which is a mechanism by which the file system allows one client to control i.e. read and write a range of file data to the exclusion of other clients. An op lock is an automatically revocable soft lock that allows a client to operate on a range of file data until such time as a server e.g. the storage system instructs the client to stop. That is the client can cache the data and perform read and write operations on the cached data until the storage system instructs it to return that data to the system. The client can cache the results of write operations since it knows that no other access is allowed to that same region of the file as long as it has an op lock on the region. As soon as a second client attempts a conflicting operation on that region of the file the storage system blocks the conflicting operation and revokes the op lock. In particular the storage system instructs the client to return flush any write modifications to the system and then discard the entire content of its client side cache. Once that happens the storage system unblocks the second client and grants it an op lock to the conflicting region.

NFSv2 and NFSv3 protocols do not utilize op locks and thus do not employ the above revocation system. For these protocols the storage system typically relies on strong serialization semantics. Other protocols such as the NFSv4 protocol use a type of soft lock called delegations that allows the storage system to use weak serialization semantics. Because CIFS and NFSv4 clients rely on such a rough protocol for guaranteeing consistency of cached data they are not concerned with mtimes associated with read and write operations. This in turn enables the storage system to service such operation requests with weak serialization semantics.

In typical data container striping arrangements there is one volume i.e. the container attribute volume CAV which is responsible for all the timestamps of a particular file stored on the SVS. As a result for each file operation the DV accesses the CAV to determine the mtime for the file. In response the CAV updates the mtime on disk and returns the updated mtime to the DV which in turn returns the mtime and any associated data to the client. This arrangement places a substantial load on the storage system serving the CAV with an associated decrease in system performance. Moreover depending on the load of the SVS the metadata requests to from the CAV may become a bottleneck that adversely impacts performance of the system by e.g. causing certain storage systems to stall wait until their metadata requests have been processed before servicing client data access requests.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named data containers such as directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N blade on the node while the other processor executes the functions of the D blade .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory elements including various computer readable media may be used for storing and executing program instructions pertaining to the embodiments described herein.

The network adapter comprises a plurality of ports adapted to place the node in communication with one or more clients such as over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network or combinations thereof. As used herein in communication with means in direct communication with or indirect communication with through one or more components that or may not be shown herein. Such components may include wired or wireless hardware components or software components or combinations thereof. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to predefined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the embodiments described herein.

To facilitate access to the disks the storage operating system may implement a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as a set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the embodiments described herein. As such where the term WAFL is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings herein.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a volume striping module VSM a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. The VSM illustratively implements a striped volume set SVS described herein. As described further herein the VSM cooperates with the file system to enable the storage server to service a volume of the SVS. In particular the VSM implements a Locate function to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte kB blocks and using index nodes inodes to identify files and file attributes such as timestamps access permissions size and block location . The file system uses files to store metadata describing the layout of its file system these metadata files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware software or combinations thereof.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkemel an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the embodiments described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose node or computer including a standalone computer or portion thereof embodied as or including a storage system. Such storage systems may support file level access block level access or other granularity of access or combinations thereof. Moreover the teachings herein can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write anywhere file system the teachings herein may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D blade of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N blade to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N blade and D blade cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each blade includes a cluster fabric CF interface module adapted to implement intra cluster communication among the blades including D blade to D blade communication for data container striping operations described herein.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N blade function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D blade . That is the N blade servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D blades of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D blades in the cluster . Thus any network port of an N blade that receives a client request can access any data container within the single file system image located on any D blade of the cluster.

Further to the illustrative embodiment the N blade and D blade are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the blades may be implemented as pieces of code within a single operating system process. Communication between an N blade and D blade is thus illustratively effected through the use of message passing between the blades although in the case of remote communication between an N blade and D blade of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between blades processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system commands among the blades of cluster . Communication is illustratively effected by the D blade exposing the CF API to which an N blade or another D blade issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N blade encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D blade residing on the same node or ii a remote procedure call RPC when communicating the command to a D blade residing on a remote node of the cluster . In either case the CF decoder of CF interface on D blade de encapsulates the CF message and processes the file system command.

The disclosed embodiments are related to a storage system architecture illustratively comprising two or more volumes distributed across a plurality of nodes of cluster . The volumes are organized as a SVS and configured to store content of data containers such as files and luns served by the cluster in response to multi protocol data access requests issued by clients . Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. To facilitate a description and understanding data containers are hereinafter referred to generally as files .

The SVS comprises a metadata volume MDV and one or more data volumes DV . The MDV is configured to store a canonical copy of certain metadata including access control lists ACLs and directories associated with all files stored on the SVS whereas each DV is configured to store at least data content of those files. For each file stored on the SVS one volume is designated the container attribute volume CAV and to that end is configured to store cache certain rapidly changing attribute metadata including time stamps and file length associated with that file to thereby offload access requests that would otherwise be directed to the MDV.

In the illustrative embodiment described herein determination of the CAV for a file is based on a simple rule designate the volume holding the first stripe of content data for the file as the CAV for the file. Not only is this simple rule convenient but it also provides an optimization for small files. That is a CAV may be able to perform certain operations without having to communicate with other volumes of the SVS if the file is small enough to fit within the specified stripe width. Ideally the first stripes of data for files are distributed among the DVs of the SVS to thereby facilitate even distribution of CAV designations among the volumes of the SVS. In alternate embodiments data for files is striped across the MDV and the DVs.

In one embodiment data consistency is guaranteed to clients for one or more data containers stored on a plurality of volumes configured as a SVS. As noted the SVS comprises one MDV configured to store a canonical copy of certain metadata including access control lists and directories associated with all data containers stored on the SVS and one or more DVs configured to store at least data content of those containers. In addition for each data container stored on the SVS one volume is designated the CAV and as such is configured to store certain rapidly changing attribute metadata including timestamps and length associated with that container.

Twelve data containers e.g. files files 1 12 are illustratively stored on the volumes of the SVS wherein each volume serves as the CAV for any file whose first stripe is stored therein. Notably the CAV is a role that the MDV or DV serves for a particular file to store and serve rapidly changing attribute metadata for the file. Thus for example volume B serves as the CAV for files 1 5 9. Similarly volume C serves as the CAV for files 2 6 and 10 volume D serves as the CAV for files 3 7 and 11 and volume E serves as the CAV for files 4 8 and 12. Volume A which serves as the MDV for the SVS does not in the illustrative embodiment serve as the CAV for any files. In alternate embodiments the MDV may serve as the CAV for files. By distributing the role of the CAV among the SVS volumes each volume serves as a CAV for an approximately equal number of files.

The metadata associated with the files stored on the SVS are illustratively organized into various categories e.g. MD1 MD3 along functional boundaries and are resident on various volumes to optimize data access e.g. read and write paths through the SVS. These categories include i MD1 metadata that changes on every data access read write request served by the SVS ii MD2 metadata that may be retrieved but not changed on every request and iii MD3 metadata that is unused for the read write requests. Since it changes on every read write request served by the DVs of the SVS the MD1 metadata is canonically resident on the CAV and generally cached on the DVs. Likewise since it may be retrieved but does not change on every request served by the DVs the MD2 metadata is canonically resident on the MDV and generally cached on all DVs of the SVS including the volume designated as CAV. Finally since it is unused for a read write request the MD3 metadata is canonically and solely resident on the MDV.

In the illustrative embodiment the CAV cooperates with the MDV and DVs of the SVS to provide a multi tier caching and distribution architecture that offloads metadata access requests that would otherwise be directed to the MDV. is a schematic block diagram of an exemplary multi tier metadata caching and distribution hierarchical environment in accordance with one embodiment. As noted MDV stores a canonical copy of MD2 and MD3 metadata for all of the files stored on the SVS. Here the CAV is utilized as a first tier caching and distribution point for storing and distributing most metadata e.g. MD1 and MD2 for use by the DVs .

As noted above every volume within the SVS serves as a CAV for a portion of the files stored on the SVS. Illustratively the volume storing the first stripe of the file is deemed to be the CAV. Thus different volumes of the environment may serve as the CAV depending on the particular files. Moreover the MDV may serve as the CAV for certain files. In such a case the roles of the CAV and MDV are merged due to the fact that the volume contains a canonical copy of all MD1 MD3 metadata. For those files stored on a SVS volume having a merged CAV MDV role no first tier caching and distribution point is utilized in the hierarchical environment .

Data consistency guarantees of data containers e.g. files stored on the SVS are generally provided by delegating to the DVs sufficient authority to autonomously service I O requests directed to the files using at least some of the rapidly changing attribute metadata e.g. the timestamps of the files. As noted each node includes a D blade configured to service a volume such as the MDV DV or CAV . To further facilitate a description and understanding references to the MDV DV and CAV may include the D blades configured to service those volumes. Specifically a DV is only allowed to service I O requests e.g. read and write operations to a file if it has a valid ticket book for the file. A DV requests and is granted the ticket book from the CAV on a per file basis although a DV may have any number of allocated ticket books based on the number of outstanding or currently active files.

As described the ticket book may be employed to improve storage system performance for clients that do not require strong serialization semantics. That is for clients using file system protocols that support weak serialization semantics such as CIFS the DV may utilize the ticket book in a manner that obviates the need to guarantee that the mtimes as perceived by the clients always increase. For clients using file system protocols that require strong serialization semantics the DV may only use the ticket book if it received file operations prior to requesting and granting of that ticket book. Otherwise a new ticket book is requested and granted from the CAV to process the received file operations. Use of the ticket book in connection with weak serialization semantics thus reduces the number of round trip exchanges needed between the DV and CAV to service file operations. In other words because the DV does not have to stall operation requests waiting for the grant of a new ticket book the number of round trip exchanges is reduced compared to the number of round trip exchanges needed for protocols that require strong serialization semantics.

When servicing a read operation each DV returns the lowest mtime in its current ticket book to the requesting client. When servicing a write operation however the DV increases e.g. increments the mtime before returning it to the client. Moreover the DV assigns a ticket from the ticket book to the write operation atomically with the step of committing the write to disk. These two aspects combine to guarantee that every new write operation that a DV completes will be assigned a post operation mtime value that is higher than any mtime that the DV has associated with any earlier operation.

In addition each DV allocates the mtimes of its delegated range in sequence. For example assume DV1 has a ticket book for file A with an mtime range of 101 to 150. In response to a first read operation directed to the file DV1 returns mtime 101 with the data. Subsequently in response to a first write operation directed to the file DV1 increments the mtime from 101 to 102 and returns mtime 102 with the request s post operation attributes. DV1 then removes ticket reflecting mtime 102 from its book such that the new range is 103 to 150. Any subsequent read operations directed to the file return current mtimes of 102 until a second write operation is issued at which time the incremented mtime 103 is returned. When it depletes those mtimes i.e. when it returns mtime 150 and runs out of tickets DV1 requests a new ticket book from the CAV. Alternatively if a DV only has a read ticket book then it must obtain a new range of the timeline from the CAV before it can service any more write operations.

Notably there is no guarantee that the mtime always reflects wall clock time i.e. the actual time of day. That is in some circumstances it is possible and acceptable for a particular client to issue an I O request e.g. a first write operation and receive an acknowledgment with a first mtime e.g. 100 and then synchronously issue a second write operation and receive a smaller mtime e.g. 50 even though the client has knowledge that the second write operation occurred after the first write operation. For example assume that a client issues a first write operation to a first region e.g. a stripe of a file that is serviced by DV2 and waits for a response before proceeding with any further operations. DV2 performs the first write operation and returns mtime 201 to client for that operation. The client then issues a second write operation to a second different stripe of the file that is serviced by DV1. DV1 performs the second write operation and returns mtime 101 to the client for that operation. Essentially the client perceives the returned mtimes as proceeding backwards the mtime for the second write operation is earlier even though the client is aware that the first write operation fully completed before the second operation began.

Certain client protocols such as NFSv2 cannot support this situation and thus require strong serialization semantics . As used herein all file operations are serializable using a timeline indexed by a file s mtime. For causally connected operations i.e. operations which affect the same metadata or the same region of the same file increasing modification times mtimes correlate with increasing wall clock time. If a client protocol requires strong serialization semantics i.e. that operations are performed in the order of receipt increasing mtimes correlate with increasing wall clock time. However those client protocols that can support the situation described above accept weak serialization semantics and the disclosed embodiments provide optimizations to accommodate those protocols. CIFS and to some extent NFSv4 client protocols are configured to support weak serialization semantics accordingly the ticket book provides an optimization in support of such semantics. That is weak serialization semantics allow DV1 to exploit the use of its ticket book by e.g. obviating the need to guarantee that the mtime as perceived by the client always increases. Note that this situation only manifests when a client s operation requests traverse DVs i.e. the client transitions from writing to one DV to writing to another DV. As long as the client directs requests to one DV the mtimes always increase.

In the illustrative system there are rules governing when a ticket book currently held by a DV can be used. Alternatively other rules may be defined in addition to or in lieu of these exemplary rules and may be more or less restrictive depending upon the implementation thereof and the required operational semantics. If any of these exemplary rules fails then the DV has to obtain a new ticket book from the CAV before servicing certain operation requests. According to a first exemplary rule a DV preferably has sufficient up to date metadata to service an I O operation to a file. Otherwise if the metadata is out of date for the file the DV obtains that metadata and in the process of obtaining that metadata the DV obtains a new ticket book. In general whenever a DV accesses the CAV for additional attributes or metadata the CAV issues a new ticket book to the DV.

A second exemplary rule states that if the ticket book expires or is otherwise unusable i.e. all tickets are exhausted such that no further write operations can be performed then the DV must in at least one embodiment obtain a new ticket book. Here the ticket book itself may be considered a form of metadata that the DV may need to retrieve from the CAV. A ticket book may expire based on wall clock time. It is preferable that the timestamps returned to a client be generally close to actual wall clock time. After a predetermined time e.g. 100 milliseconds or approximately 10 times a second the DV discards its current ticket book and obtains a new ticket book the next time a request is issued to the DV. Notably the new ticket book is obtained on demand i.e. when a request is received at the DV that cannot be satisfied using the current ticket book.

Illustratively an optimization may be invoked for this second rule. If there may still be activity directed to the file and the current ticket book for the file is set to expire shortly the DV can proactively request a new ticket book for the file so that by the time that the next request is received the DV has the new ticket book. This optimization is based on a heuristic to decide how frequently the DV should proactively obtain a ticket book without being prompted by an incoming client request. This optimization is similar to a metadata read ahead operation that prepares for a new ticket book in case one is needed. However if proactive requests are performed too aggressively the CAV would be overloaded.

A number of different algorithms may be employed that specify when a DV should request a new ticket book from the CAV. An example of an illustrative algorithm specifies that if at least one I O operation to a particular file is serviced using a current ticket book for that file and if the ticket book is about to expire within a predetermined time equal to the round trip time to the CAV e.g. the next 20 milliseconds then the DV proactively obtains a new ticket book from the CAV.

A third exemplary rule involves a situation where an I O operation such as a write operation spans the end of file EOF . Write operations that span the current EOF change the length of the file. File length changes are considered causally connected with all other I O operations that is if a file is extended by a write operation and that operation returns post operation mtime X to the client then all subsequent I O operations return mtime values greater than X and all these subsequent operations use the correct new file length. This is accomplished by providing the following third rule when a DV wants to extend the file it must at least in the exemplary system always go to the CAV to request a new ticket book.

Therefore this aspect of the exemplary system is directed to the use of the ticket book with a file extending operation e.g. a write operation that spans EOF and increases the length of a file. In response to servicing a write operation that attempts to extend the file the DV advises the CAV as to the new length of the file and in return the CAV grants a new ticket book reflective of that new file length. In particular the CAV invalidates all outstanding ticket books to all DVs updates the length of the file and returns the new ticket book to the advising DV. Since no other valid ticket books are in use each DV polls the CAV for an updated ticket book before servicing a new I O operation. The new ticket book has tickets reflective of higher mtimes and includes the correct new file length .

For example assume DV1 services stripes 0 to 2 megabytes of a file DV2 services stripes 2 to 4 megabytes of the file and the file is currently exactly 2 megabytes in length. While a client issues read operation requests to DV1 for the file another client decides to extend the length of the file so it issues a write operation request to DV2. However DV1 is not notified about that write operation and as such its ticket book is not modified or discarded. Therefore DV1 continues to service read operations to the file as if the length of the file has not increased. The third exemplary rule states that if a client tries to span EOF as perceived by a DV e.g. DV then the DV obtains a new ticket book from the CAV. Notably the new ticket book includes the current length of the file.

This situation is also relevant for write operations because the CAV is the authority for the file s length. When a DV needs to extend a file via a write operation it sends a message to the CAV requesting a change of length for the file. The CAV then returns a new ticket book with a new file length attribute that is sufficient to accommodate the write operation. In sum if any operation request directed to a DV exceeds the EOF associated with its current ticket book the DV does not reject that request but rather contacts the CAV for a new ticket book. This third rule provides a way for the DV to obtain a new ticket book from the CAV.

If the new ticket book is returned and the file length has not changed then the DV proceeds through normal semantics. If a read operation is performed that attempts to span EOF then the DV returns the number of bytes it was able to read and fills the rest of the request buffer with zeros. If a write operation is performed that attempts to span EOF the DV advises the CAV as to the new length of the file. The CAV makes the necessary change to the file length and returns a new ticket book reflecting the change in file length up to the end of the write operation.

The fourth exemplary rule relates to strong serialization semantics. Specifically the contents of a ticket book can be trusted used if a weak serialization semantics are used in which case this rule does not apply or b strong serialization semantics are used and at least one of two tests is satisfied. The first test is whether the DV has a kinetic token. If so then the DV can use the current ticket book. If not then the DV considers the time on the local machine e.g. the filer when the ticket book was requested and the time that the incoming file operation request arrived. If the ticket book was requested after that file operation arrived then the DV can use the ticket book otherwise the DV cannot use the ticket book i.e. the ticket book is discarded and new one obtained from the CAV .

For example the DV may have started servicing Read A but encountered a portion of the file for an indirect block it does not yet have and accordingly Read A is stalled. Meanwhile DV services Read B. If all three Reads A B and C are outstanding at the same time from the client s point of view there is no guarantee as to the order in which the storage system i.e. D blade will service the requests. Note that this also applies to outstanding write operations. The only requirement is that once it chooses an order in which to service the read and or write operations the DV must for example return mtimes that are consistent with that order. Since all three operation requests were in flight simultaneously the client provides no guarantees for which one is actually going to reach the D blade first much less which one gets serviced first. Client protocols that can handle weak serialization semantics are not concerned about the ordering of the operations in real time versus the ticket book mtimes. As noted the only requirement is that the order in which the operations are serviced e.g. Reads B A C is consistent with the mtimes that are returned.

In the case of strong serialization semantics graph the DV receives a first I O operation Read A and in response sends a message to the CAV requesting a new ticket book TB 1 . Meanwhile two more operations Reads B and C are received by the DV. When the new ticket book is returned by the CAV the DV determines that the ticket book is acceptable for servicing Read A but cannot be used to service Reads B and C because those latter read operations B and C arrived at the D blade after the DV had requested the new ticket book. Accordingly the DV sends another message to the CAV requesting another new ticket book TB 2 . If Reads A B and C had arrived before the new ticket book was requested then the DV would be able to service all three operations with the ticket book TB 1. The last rule states that the DV can only trust i.e. use the ticket book for file operations that arrived before the DV had requested the ticket book.

According to yet another aspect of the exemplary system a kinetic token is provided that represents an optimization that enables the storage system to defeat caching behavior at the client and improve the performance of file operations. A kinetic token is a guarantee that every time a client requests the current mtime on the file the client will receive a higher value than has ever been previously reported. Issuance of a kinetic token by the CAV effectively disables client side caching because every time the client requests the current mtime it will receive a higher mtime value. As soon as that guarantee is provided then the ordering problem for strong serialization semantics is eliminated because the clients no longer caches any data and as such it does not matter what mtime value the storage system returns . The kinetic token provides a guarantee that client side caching is disabled as clients will always see higher mtimes returned. If the DV receives a request that requires strong semantics the DV utilizes the technique described above and obtains a new ticket book before servicing the request.

The kinetic token is illustratively granted in recognition that there is a relatively common file access pattern. For example if many write operations are received by a DV to a particular file then the mtimes returned to the clients issuing those operations are constantly being updated incremented . Recall that every write operation results in updating incrementing of the mtime on the file. In the case of client side caching this pattern of activity forces the client to discard the contents of its cache. The CAV may decide to issue kinetic tokens with the ticket book for heavy write access to the file where the mtimes are changing frequently. That is frequent activity on the file denotes that the CAV is servicing many requests for ticket books for the same file often to one or more DVs. If the CAV heuristically determines that many ticket book requests are received for a particular file it can choose to issue kinetic tokens for that file. Illustratively the kinetic token is implemented as a Boolean flag within the ticket book that when asserted specifies existence of the token.

At some point the ticket book with kinetic token expires or the CAV may revoke the kinetic token. In order for a DV to manipulate metadata on the file the CAV instructs all DVs that currently have kinetic tokens to relinquish those tokens. Illustratively the CAV broadcasts to the DVs a message instructing them to relinquish their kinetic tokens. Once all the DVs have acknowledged that they have given up their tokens the CAV may halt automatic incrementing of mtimes on query.

The disclosed embodiments are directed to a system and method which improves the efficiency of guaranteeing data consistency to clients such as for one or more data containers e.g. files or other objects e.g. directories stored on a plurality of volumes configured as a SVS. In particular the disclosed embodiments optimize requests from clients which span multiple DV s and which require strong serialization and ensure perception by a client of an expected sequence of operations with respect to a given object at any one of a number of interfaces to the file system. The disclosed embodiments provide a new form of ticket book that provides lower latency while improving compatibility with client protocols. While the embodiments below are described in relation to files it will be appreciated that the disclosed mechanisms may be used with other objects such as directories which span multiple DV s.

As was described above in a clustered system like the ONTAP GX provided by Network Appliance Inc. an NFS request say a Read call is sent by a client to an N blade which as described is a network interface to the storage system. That N blade routes the request to an appropriate D blade which as described above is an interface to the storage devices for servicing as part of its response the D blade will return not only the answer for the call success or error any data being read etc but also the post operation attributes for the affected object including in particular an mtime or modification time the client associates the response with this timestamp in effect thinking At time T the file contained this data. The NFS client might manage a client side cache using these attributes if the cache already has data for time T 2 for this region of a file it will update the cache to contain this new data instead since this response is newer.

Ticket books are a mechanism by which multiple clustered filers i.e. DV s or storage devices such as devices which do not inherently share the same internal data can service requests for a single striped object at the same time each ticket book contains represents a series of timestamps that the individual filers DV s can use as post operation attributes. When a DV s ticket book runs out of timestamps tickets or when the ticket book can t be used for some other reason the DV has to stall all inbound requests while it obtains a new ticket book from the CAV. Best performance is therefore realized when a DV can obtain a ticket book once then use it for a long period of time before being forced to obtain a new ticket book each request for a new ticket book not only represents stalled I Os but also increases intra cluster traffic.

As described in detail above in one implementation a weak serialization ticket book model may be used for clients that for example do not guard a client side cache by post operation time stamps. Clients in this category are effectively exempted from the first rule above that is sequential operations can involve time rolling backwards provided that rule two is not thereby violated. For example such a client might perform a 32 kb write at offset 1 MB and receive post operation mtime 100 then perform a non overlapping write at offset 5 MB and receive post operation mtime 90 without ill effect. And yet if those two writes were overlapping for example performed at offsets 1 kB and 5 kB instead then the second operation would still be required to return an mtime of 101 or higher to ensure safe replay ordering. 

As shown by example in when an incoming I O request is received at a DV the DV determines whether it can use its current ticket book or must request a new ticket book. In this model the cached ticket book can be used if it meets all of the following criteria 

When safe to employ weak serialization semantics are preferred because they are highly efficient once a ticket book is received it can be used for all incoming I O requests until it expires or is explicitly revoked. This not only reduces the load on the CAV by reducing the sheer number of ticket books that are requested but it also significantly reduces the typical latency observed by a client since there is one less hurdle to be overcome before an I O request can be serviced.

In the case of a client requiring strong serialization however a strong serialization ticket book model may be used as was described above. The strong serialization model is implemented exactly like the weak model with the addition of a rule regarding cached ticket book usage no cached ticket book can be used for operations that arrive after the ticket book was requested. An exemplary event sequence under the strong serialization model is shown in .

This additional rule strengthens serialization semantics significantly but as a result dramatically increases latency for clients. The latency increase is a result of forcing every incoming file operation to stall while a new ticket book is obtained. This latency increase is further worsened because in the current implementation no DV will have more than one ticket book request outstanding for a file at once. Therefore when a new I O request is received it must wait behind any ongoing current ticket book request and then wait behind a full second request.

Fortunately maximum throughput is only slightly affected if there is significant load many requests will end up waiting for the same ticket book request and so all will be fulfilled when that ticket book is obtained successfully. Because of the additional latency a higher amount of simultaneous load is required to reach maximum throughput and the additional load on the intra cluster network and the CAV as it services far more ticket book requests impacts peak performance throughout the cluster.

The above described process for handling strong serialization requirements however solves at least the problem that any single client that is issuing I O requests waiting for them to complete and then issuing more will invariably see increasing mtimes for every operation. This allows the system to return post operation attributes with full confidence that all clients will behave correctly which would not otherwise be true if the NFS traffic were treated using weak serialization semantics.

As was described above kinetic tokens allow the system to take advantage of a particular feature in the NFSv3 protocol that post operation attributes are technically optional. The idea is if the system manages to omit returning post operation mtimes then it is impossible for the client to observe mtimes rolling backwards and so the system is free to use the higher performing weak serialization model.

However there are problems with omitting post operation attributes the first is that many clients when seeing a lack of such attributes will immediately or at least frequently issue requests to obtain the post operation attributes e.g. NFS getattr requests to the DV to find the current modification time. The getattr calls themselves are not expensive but it is essential that the system use this opportunity to inform the client that writes have been happening since the last time the client looked otherwise the NFS client side cache will become out of date.

To regulate this process the system detects periods of heavy write load on a file for example N requests in one second for write ticket books and begins issuing kinetic tokens back along with further ticket books. If a DV has a kinetic token it can service NFSv3 I Os using weak serialization semantics and omitting post operation attributes because it knows that so long as the kinetic token is outstanding the CAV will be intercepting NFS getattr requests and returning continually increasing mtimes with each one.

The second problem with omitting post operation attributes relates to the observed behavior NFS clients when they do not receive post operations attributes. In particular many clients may behave very poorly when post operation attributes are omitted they may stop sending requests for 5 10 ms and thereafter send only one request at a time. The result is that kinetic token usage either offers a client the best performance or the very worst and this may not be apparent for a given client until they are in operation.

Further even in the comparably fast weak serialization model a cached ticket book cannot be used to service an inbound request that spans the current end of file EOF . This means that all file extending writes must stall while obtaining a new ticket book a side effect that may significantly degrade streaming write performance.

This is compounded by the fact that a file s CAV is the owner for that file s length during a file extending write the CAV must extend the file while the DV receiving the write is the only entity that knows the data to be written at EOF. This split opens a window during which the CAV has increased the file s length but the DV has not yet written data to populate that tail. A failure during this window leaves a sparse tail on the file and even during the success path there are complications involving which I O to awaken first at the DV to ensure no other reads or writes observe that sparse tail until it can be populated .

To address these problems metadata ownership delegation also referred to as write extend token is implemented. When a DV wants to extend a file instead of asking the CAV to do it the DV will simply ask the CAV to yield ownership of the file s metadata for a time. The CAV writes a persistent marker on the inode indicating which DV now has ownership of the metadata and tells the DV to proceed. So long as the DV has ownership of the file s metadata it can service all the file extending writes it wants.

Later when another DV wants to obtain a ticket book or other metadata the CAV can revoke the metadata ownership. During this process the DV invalidates its own ticket book and informs the CAV of the final metadata when the CAV writes the metadata to its disk it erases the ownership delegation marker. Now the CAV is once again in control of the file s metadata and can proceed normally.

Because metadata ownership delegation is used only when metadata is in flux for example the file s length is changing the CAV does not yield ownership until all other meta data caches downstream have been invalidated. This means that a caller who is streaming data to the file will end up in competition with other callers who want random access to the file. Metadata ownership must therefore be governed by appropriate heuristics to ensure that neither party is starved for access.

One mechanism to address this conflict is that when a DV sends a request to the CAV for a ticket book the CAV can choose to reflect that request to the current metadata owner rather than always revoking meta data ownership. There are limitations on the use of ticket books granted in this way since the metadata for the file is in flux for example such ticket books cannot be used as part of a cross stripe or EOF spanning I O. But for most random I O which occurs interior to a stripe and behind EOF this optimization is important. For further details see the Single use ticket book description below.

The disclosed embodiments address the problem that kinetic tokens may be unreliable in the field because of pathological NFS client behavior and that ticket books must be expanded to service striped directories as well as striped files as the slow performance offered by the strong serialization model described above would increase directory manipulation latency to an unacceptable level. The disclosed embodiments implement a new ticket book model and a supporting metadata ownership delegation mechanism as described above.

Each N blade further includes a data structure for caching mtimes as will be described. The data structure may be implemented as a hash table and may be stored in the memory described above with respect to . Each D blade further includes a ticket book cache which may also be stored in the memory .

The viral ticket book model of the disclosed embodiments addresses the primary four rules discussed above in the following fashion 

In one embodiment a storage architecture is provided which is capable of ensuring perception of a sequence of operations meets a client s expectations with respect to the order of operations performed with respect to an object at any one of a plurality of interfaces to a file system. The storage architecture as described above includes a plurality network interfaces e.g. N Blades capable of being in communication with a network and a plurality of storage interfaces e.g. D Blades . Each network interface is capable of receiving a request from a client via the network the request being associated with an object such as a file directory or combination thereof wherein a particular network interface which receives the request is further operative to provide the request to at least one of the plurality of storage interfaces.

Each of the plurality of storage interfaces is capable of being in communication with at least one of the plurality of network interfaces and at least one of a plurality of storage devices which stores at least a portion of the object each storage interface being operative to process the request and based thereon return a response to the particular network interface to send to the client. Each of the plurality of network interfaces further includes a memory such as a hash table or other memory for storing a first timestamp associated with the object.

The particular network interface which receives the request is further operative to provide the first timestamp if stored in the memory along with the request to the at least one of the plurality of storage interfaces. The at least one of the plurality of storage interfaces is operative to determine a second timestamp not less than the first timestamp if provided and return the second timestamp along with the response to the particular network interface. The second timestamp may be determined based on an allocation of timestamps such as a ticket book associated with the object.

The allocation of timestamps may be obtained if not already obtained or if invalid. In one embodiment one of the plurality of storage devices may be the owner of the object and operative to provide the allocation of timestamps associated therewith each allocation comprising at least one larger non overlapping timestamp then previously allocated. Each of the plurality of storage interfaces may be further operative to discard the allocation of timestamps and obtain a new allocation of timestamps when metadata associated with the object is modified. The at least one of the plurality of storage interfaces may be further operative to determine the second timestamp to be greater than any other timestamp previously returned for the object by another of the plurality of storage interfaces.

The particular network interface is operative to store the second timestamp in the memory in association with the object in place of the first timestamp if stored and provide the second timestamp to the client along with the response. In one embodiment wherein the file is associated with metadata and where the request may result in modification of the metadata such as a request to extend the file the at least one of the plurality of storage interfaces may obtain exclusive control of modifying the metadata. In another embodiment the at least one of the plurality of storage interfaces may be further operative to provide another of the plurality of storage interfaces with a timestamp to be returned by that other of plurality of storage interfaces to a network interface which sent a request associated with the object to the other of the plurality of storage interfaces.

Note that there is no requirement that a given DV must return timestamps that never overlap with those returned by that DV. That is the appearance of delegating one timeslice to one DV and another timeslice to another DV is not a requisite part of the process for addressing the four rules governing correct ticket book usage.

To the contrary it is actually beneficial if the various D blades can end up sharing ticket books so long as each D blade returns higher timestamps than any it has returned before and so long as each N blade advises the D blade to return higher timestamps to it than any it has seen before. There are no causal violations from this sharing. Rather this sharing can enable D blades to service requests far more often without obtaining new ticket books 

As compared with prior ticket book implementations which improved efficiency in the case of weak serialization the disclosed embodiments permit cached ticket book usage more often while safely returning post operation attributes for every operation. This provides improved performance while avoiding the client side difficulties exposed by kinetic token usage describe above.

In an alternate embodiment where metadata ownership delegation as described above is provided single use ticket books may also be provided as an optimization. Single use ticket books reduce latency in operations that would otherwise have to stall behind revoking metadata ownership delegation i.e. operations that would otherwise have to wait for the CAV to revoke delegated ownership of metadata from the DV. The single use ticket book is identical to the ticket books used to implement strong serialization. An operation can only use a single use ticket book if it arrived at the DV before the ticket book was requested from the CAV. When a DV requests a ticket book it sets a flag indicating whether a single use ticket book can be used to process the operation that prompted the request. When a ticket book request arrives at the CAV for an Mode whose meta data ownership has been delegated the CAV sends a revoke to the DV that holds the delegation and passes the flag indicating whether a single use ticket book is acceptable. When a DV receives a revoke for meta data ownership it normally stalls the revoke until it is done with the work that affects the delegated meta data. If the revoke request indicates that a single use ticket book is acceptable the DV can refuse the revoke request and supply a single use ticket book in its response to the CAV. This allows some operations to proceed without waiting for the metadata delegation to be revoked.

One of the side effects of this ticket book model is that a client may observe identical mtimes for disjoint operations that are in flight simultaneously this occurs because a particular ticket book might be shared by two DVs and both DVs might pull the same ticket off as a post operation mtime.

Alternatively if this does become a problem within each range of tickets 0 . . . N constituent volume V can be instructed to return only tickets where mtime dvcount V . The result is that two DVs can use the same ticket book and yet never return precisely the same time stamp. This change does not affect any of the other properties described above the N blade s till always sees increasing times regardless of D blade and the D blade still always returns increasing times regardless of N blade .

The disclosed embodiments permit the use of cached ticket books far more often than non cached models described above and yet ensure that all responses to clients include valid post operation attributes. This combines a dramatic performance improvement with better client compatibility.

To clarify the use in the pending claims and to hereby provide notice to the public the phrases at least one of . . . and or at least one of . . . or combinations thereof are defined by the Applicant in the broadest sense superceding any other implied definitions herebefore or hereinafter unless expressly asserted by the Applicant to the contrary to mean one or more elements selected from the group comprising A B . . . and N that is to say any combination of one or more of the elements A B . . . or N including any one element alone or in combination with one or more of the other elements which may also include in combination additional elements not listed.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. In addition while the disclosed embodiments have been described in relation to files it will be appreciated that they may be applicable to other objects such as directories. Furthermore while this description has been written in terms of N and D blades the teachings of the present invention are equally suitable to systems where the functionality of the N and D blades are implemented in a single system. Alternately the functions of the N and D blades may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Also the data structures described herein may include additional fields for storing additional information. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

