---

title: Lazy handling of end of interrupt messages in a virtualized environment
abstract: Techniques enable reducing a number of intercepts performed by a hypervisor by reducing a number of End Of Interrupt (EOI) messages sent from a virtual central processing unit (CPU) to a virtual advanced programmable interrupt controller (APIC). The EOI path of the guest operating system running on the virtual CPU is altered to leave a marker indicating that the EOI has occurred. At some later time the hypervisor inspects the marker and lazily updates the virtual APIC state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08032680&OS=08032680&RS=08032680
owner: Microsoft Corporation
number: 08032680
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
The computer industry is trending towards more and more virtualization at the hardware level. In these environments operating systems are run on top of a virtual machine monitor or hypervisor where interaction with the computer hardware by a guest operating system is mediated by a virtualization layer. This allows multiple guest operating systems OSs to run concurrently on a single computer making it possible to run multiple workloads on the same physical machine. Each workload may execute on a different guest OS with strong isolation between guest OS. This is particularly beneficial for information technology IT departments or any operation that requires running multiple workloads or multiple server applications.

Allowing multiple guest OSs to run on a single computer may be accomplished by apportioning hardware resources to each guest OS in a safe yet efficient way. Traditionally a hypervisor apportions hardware resources by exposing hardware devices to each guest OS as virtual hardware devices. Some physical hardware devices are virtualized by mediating direct access to the physical hardware device. Other physical hardware devices are virtualized by intercepting requests to the underlying device and implementing the requested functionality by utilizing the underlying hardware device in a related way. Still other physical hardware devices are completely emulated. Depending on the amount of intervention and emulation necessary to implement the virtual hardware device the added cost of executing a function on a virtual hardware device may vary significantly. While mediating access to physical hardware devices may increase the computing cost by a modest percentage software emulation of a physical hardware device may be extremely costly.

For instance when a guest OS accesses a virtual hard disk to read a block of data the hypervisor may intercept the function call. The hypervisor may implement the functionality by allowing direct access to the hard disk or alternatively by reading a block of data from a file containing the contents of a virtualized hard disk. These two levels of hypervisor intervention may modestly increase the system resources necessary to complete the function call. On the other hand virtualization of hardware devices such as an Advanced Programmable Interrupt Controller APIC may require many multiples of the system resources that are necessary to access a physical APIC.

This document describes techniques capable of lazily communicating End Of Interrupt EOI messages from a guest OS to an Input Output Advanced Programmable Interrupt Controller I O APIC virtualization module executing in a hypervisor. Lazily communicating an EOI entails writing to a memory indicating that the EOI occurred allowing the I O APIC virtualization module to read the memory at a later time. Some implementations employ a memory page shared between the hypervisor and the guest OS to lazily communicate when an EOI has taken place on the virtualized CPU the guest OS is running on. Some implementations may also employ the shared memory page for the hypervisor to communicate to the guest OS when an EOI may be communicated lazily. Some implementations utilize an enlightened guest OS executing an enlightened EOI handler to process EOI messages according to the indication given by the hypervisor. The techniques therefore allow many EOI messages to be processed by the hypervisor without the unnecessary cost of the hypervisor intercepting and emulating EOI messages generated by the guest OS.

The following discussion targets techniques capable of lazily communicating End Of Interrupt EOI messages from a guest OS to an Input Output Advanced Programmable Interrupt Controller I O APIC virtualization module. These techniques enable a guest OS to accurately and more efficiently handle interrupt requests without unnecessarily causing the hypervisor to trap and intercept an EOI communication. These techniques may utilize a shared memory page to facilitate communication between the hypervisor and the guest OS. Using the shared memory page the hypervisor may communicate to the guest OS when an EOI must be immediately transmitted to the hypervisor or alternatively when an EOI may be lazily retrieved by the hypervisor. Also when the hypervisor has indicated that an EOI may be processed lazily and when the virtualized CPU executing the guest OS issues an EOI the guest OS may use the shared memory to indicate that an EOI has occurred. The hypervisor may check for this indication while it is executing for other reasons saving the cost of trapping and intercepting an immediate transmission of the EOI.

A first section entitled Illustrative Virtualized Operating Environment sets forth an environment that may enable these and other actions. An Illustrative virtualized I O APIC environment and interrupt handling process section follows which describes how interrupts received by a virtual I O APIC may be processed. The third section entitled Illustrative processing of an interrupt depicts illustrative steps a virtual I O APIC may take when processing an interrupt. The fourth section entitled Determining when to immediately communicate an EOI to the hypervisor describes conditions under which the hypervisor may indicate to the guest OS that EOI messages should be sent immediately to the hypervisor. The fifth section entitled graphical interrupt representation depicts two common types of interrupts.

This brief introduction is provided for the reader s convenience and is not intended to limit the scope of the claims nor the proceeding sections.

The following discussion describes an illustrative virtual operating environment to assist the reader in understanding some ways in which various aspects of the techniques may be employed. The environment described below constitutes but one example and is not intended to limit application of the techniques to any one particular operating environment. Other environments may be used without departing from the spirit and scope of the claimed subject matter.

In one implementation the hypervisor executes directly on the physical hardware devices coupled to the computing device managing and allocating these physical hardware devices. Additionally or alternatively the root OS may own the physical hardware devices coupled to the computing device . In one implementation the computing device includes a physical Central Processing Unit CPU coupled to a physical memory . The physical CPU may comprise a physical local Advanced Programmable Interrupt Controller APIC and may be coupled to a physical Input Output Advanced Programmable Interrupt Controller I O APIC .

Hardware devices may request that the CPU interrupt its current execution to service the interrupting hardware device. Traditionally there have been two types of interrupts level triggered interrupts and edge triggered interrupts. Edge triggered interrupts are a so called fire and forget interrupt in which an interrupting device transmits an edge triggered interrupt to an I O APIC by asserting on its line a positive voltage followed immediately by de asserting the line. This change of voltage creates an edge that may be interpreted by the APIC as an interrupt. Once the interrupt is sent the line from the device to the APIC remains de asserted. A level triggered interrupt is also initiated by asserting a positive voltage on a line connecting the interrupting device to the APIC. Unlike the edge triggered interrupt when sending a level triggered interrupt the interrupting device does not de assert the line until the interrupting device receives an indication originating from the CPU that the interrupt has been handled. Thus one purpose for a CPU to send an EOI is to signal to the interrupting device that the interrupt has been completed so that the asserting device may de assert its line. Level triggered interrupts are used on some busses such as the PCI bus so that interrupts are not lost during processing. Edge triggered interrupts may be lost if a first edge overlaps a second edge in which case the second edge will not be seen by the receiving I O APIC.

The physical I O APIC may receive interrupt signals from a hardware device such as a hard disk drive or a serial port . For instance the hard disk drive may use an interrupt to indicate to the physical CPU that an asynchronous DMA transfer has completed. In this scenario the hard disk drive sends an interrupt to the physical I O APIC to request that the physical CPU execute the interrupt request handler associated with the hard disk drive . The physical I O APIC may then interrupt the physical CPU causing the physical CPU to save the current execution context and begin executing the interrupt request handler associated with the hard disk drive .

The physical I O APIC may have a number of pins on which interrupt request signals are received. In one implementation the physical I O APIC may have 255 pins where each pin corresponds to a vector from 0 to 255 although I O APICs with different numbers of pins are contemplated. In one implementation an operating system assigns a vector to each hardware device where devices having a higher priority are assigned greater numbered vectors than devices having lesser priority. In one implementation interrupt requests from a hardware device are identified by the vector assigned to that hardware device. The operation of the I O APIC is described in more detail below in .

Additionally or alternatively an I O APIC provides for inter processor interrupts IPIs . The physical I O APIC may provide a mechanism for the physical CPU to send an interrupt to another CPU perhaps as part of a multiprocessor system. To perform an IPI the CPU writes to an Interrupt Control Register ICR which in turn sends an interrupt to the destination processor. Additionally or alternatively the physical CPU may request an interrupt for itself via the ICR.

In one implementation the physical CPU may contain the physical local APIC . The physical local APIC may comprise 255 pins each corresponding to a vector from 0 255. In other embodiments different numbers of pins are contemplated typically corresponding to the number of pins contained by the physical I O APIC . The physical local APIC may receive messages from the physical I O APIC and send messages to the physical I O APIC .

In one implementation the hypervisor may virtualize the physical devices coupled to the computing device presenting virtual hardware devices to each guest OS executing on top of the hypervisor . In one implementation the virtual hardware devices provide identical or nearly identical functionality as their non virtual counterparts. In one implementation the root OS owns all of the physical hardware devices contained in the computing device such as the physical CPU the physical memory the physical I O APIC the hard disk drive and the serial port . In this embodiment the root OS provides virtual hardware devices to the other guest operating systems. Additionally or alternatively the hypervisor may own all of the physical hardware devices contained in the computing device and provide virtual hardware devices to the guest operating systems and .

In one implementation the root OS provides a virtual CPU to the guest OS and a virtual CPU to the guest OS . The virtual CPU and the virtual CPU may include a virtual local APIC and a virtual local APIC respectively. In one embodiment the virtual CPU and the virtual CPU are thinly wrapped virtual devices that allow the guest OSs to directly access the underlying physical CPU . In one embodiment the virtual local APIC and the virtual local APIC may be emulated in software in the root OS . By the nature of emulation receiving and processing interrupts at the virtual local APICs and may be significantly more costly than the when performed by the physical local APIC .

Additionally or alternatively a memory virtualization module may provide each guest OS with a virtual memory such as a virtual memory associated with the guest OS and a virtual memory associated with the guest OS . The virtual CPU and the virtual CPU may each be coupled to a virtual I O APIC and a virtual I O APIC respectively. Similar to the virtual local APICs the virtual I O APICs may be emulated in the root OS or the hypervisor by an I O APIC virtualization module .

In one implementation interrupts generated by hardware devices are received by the virtual I O APIC forwarded to the virtual local APIC and handled by the virtual CPU . Upon receipt of the interrupt the virtual CPU changes its execution context to a service routine associated with the interrupt. The service routine may be responsible for handling the interrupt in one implementation by communicating with the device that sent the interrupt. Once the virtual CPU has finished executing the service routine the virtual CPU notifies the virtual I O APIC that it is done with the interrupt using an End Of Interrupt Acknowledgement EOI .

On a traditional computer a CPU such as the physical CPU transmits an EOI message to the physical I O APIC via a Memory Mapped I O page . On a traditional computer the memory mapped I O page allows the physical CPU to communicate with the physical I O APIC by writing to what appears to be a page of memory but is actually a means of communicating with the physical I O APIC . In a virtualized environment multiple virtual CPUs may each access a different virtual memory each of the virtual memories backed by the single physical memory . If multiple virtual CPUs were allowed to naively access the physical I O APIC at the same time the physical I O APIC and hence the entire computing device could crash. In order to prevent this an I O APIC virtualization module installs a memory intercept module on a memory mapped I O page and a memory mapped I O page so that any attempts by a virtual CPU to communicate with the physical I O APIC will trap into the I O APIC virtualization module . The APIC virtualization software may then executing in the context of the root OS or alternatively the hypervisor emulate a physical APIC in software.

For instance the virtual CPU may issue a self interrupt by writing to the memory mapped I O page . The virtual CPU may be programmed to expect that writing to this page of memory will communicate to the physical I O APIC . Instead the memory operation intended to be received by the physical I O APIC is trapped by the I O APIC virtualization module executing in the root OS . The I O APIC virtualization module may then emulate the physical I O APIC . In the case of a self interrupt the I O APIC virtualization module may call immediately into the hypervisor to issue an interrupt to the virtual local APIC which is also emulated in software. In this scenario the self interrupt issued by the virtual CPU may be processed without using the physical I O interrupt or the physical local interrupt .

In another embodiment the virtual CPU may issue an Inter Processor Interrupt IPI to one or all processors in a Multi Processor MP system such as the virtual CPU . In this case the memory intercept module in the root OS traps the instruction intended for the physical I O APIC . Similar to the processing of the self interrupt described above the I O APIC virtualization module may call in to the hypervisor to issue an interrupt to the virtual local APIC .

In one implementation interrupts received by the virtual I O APIC may trigger an intercept in the memory intercept module . Then the I O APIC virtualization module may process the received interrupt emulating the virtual I O APIC . These intercepts may happen frequently sometimes tens of thousands of times per second. Every interrupt received and processed by the virtual I O APIC may be followed by an EOI sent from the virtual CPU to the virtual I O APIC . On a native system an EOI is not expensive the physical CPU simply talks to the physical I O APIC . However in a virtualized environment it may take thousands of physical CPU cycles to emulate an EOI in the I O APIC virtualization module in addition to the CPU cycles required to perform the intercept.

In one implementation the hypervisor puts a piece of information into a shared page indicating whether the guest OS should or should not send an EOI to the virtual I O APIC . If the hypervisor tells the guest OS to send the EOI the guest OS will generate an intercept by writing to the memory mapped I O page while attempting to communicate with the virtual I O APIC . If on the other hand the hypervisor tells the guest OS via the shared memory to lazily process the EOI the guest OS may not generate an intercept and instead may write to the shared page indicating that the EOI occurred.

Once the guest OS has indicated that an EOI occurred by setting a flag in the shared memory the hypervisor may later read the shared memory to determine whether an EOI was generated. If the hypervisor determines that an EOI was generated by the virtual CPU it notifies the I O APIC virtualization module which may update its state as described below with reference to . In this embodiment the fact that an EOI has occurred is transmitted to the I O APIC virtualization module which implements the virtual I O APIC without unnecessarily generating a potentially time consuming intercept.

The virtual I O APIC may be coupled to a virtual CPU that contains a virtual local APIC . In one implementation the virtual CPU may be connected to a virtual memory that contains a shared page and a memory mapped I O page . Additionally the virtual memory may comprise a virtual serial port interrupt service routine and a virtual network card interrupt service routine .

The virtual I O APIC may comprise two registers each register containing one bit for each of the pins . In one implementation the two registers each contain 256 bits. One register may be an Interrupt Request Register IRR which may contain bits . . . . The other register may be the Interrupt Service Register ISR which may contain bits . . . . In one implementation an interrupt may be received by the virtual I O APIC from the virtual serial port on the pin . In one implementation the bit corresponding to the pin on which the interrupt was received is set to 1 indicating the interrupt has been received. The interrupt may then be forwarded to the virtual local APIC located on the virtual CPU and the virtual local APIC may in turn interrupt the execution of the virtual CPU .

Once the virtual local APIC has interrupted the virtual CPU the virtual CPU may acknowledge to the virtual I O APIC that it has received the interrupt causing the virtual I O APIC to clear the bit by setting its value to 0. The virtual I O APIC may also set the bit in the ISR corresponding to the pin the interrupt was received on. In this scenario the bit may be set to 1. Once the bit is cleared and the bit is set the virtual CPU is in the process of handling the interrupt. While the virtual CPU is handling the interrupt a second interrupt may be received by the virtual I O APIC on the pin .

Upon receipt of the interrupt the virtual CPU may save its current execution context that is the current state of its registers and call the virtual serial port interrupt service routine associated with the interrupt. Once the virtual CPU has finished executing the virtual serial port interrupt service routine the virtual CPU notifies the virtual I O APIC by writing to the memory mapped I O page which may cause an intercept by the hypervisor . In one implementation this notification comprises an End Of Interrupt Acknowledgement or EOI. The EOI notifies the virtual I O APIC that the virtual CPU has completed handling the highest priority and therefore most recently completed pending interrupt. In response to the EOI the virtual I O APIC clears the highest priority bit in the ISR. In the above example the virtual I O APIC may clear the bit .

In one embodiment the guest OS may infer from a flag set by the hypervisor whether to immediately send an EOI or whether to lazily evaluate the EOI. The hypervisor may determine whether an EOI must be immediately sent based on the state of the virtual I O APIC . What follows below are three illustrative scenarios when an EOI must be sent immediately.

In one scenario two devices may send an interrupt to the virtual I O APIC . By way of example the network card and the serial port may send an interrupt vector X and interrupt vector Y respectively during the same clock cycle. In one implementation the priority of interrupt vector Y is greater than the priority of interrupt vector X. In one implementation the virtual I O APIC may set a bit corresponding to interrupt X to 1 in the IRR and also set a bit corresponding to interrupt Y to 1 in the IRR . Then at every clock cycle the virtual I O APIC may determine the highest numbered bit that is set in the IRR register. The virtual I O APIC then via the virtual local APIC interrupts the CPU with interrupt Y the highest priority interrupt. Once the virtual CPU acknowledges the receipt of interrupt Y the virtual I O APIC sets the ISR bit corresponding to Y to 1 and sets the IRR bit corresponding Y to 0 indicating that Y is being handled by the virtual CPU .

Continuing the scenario interrupt vector X has remained waiting for the higher priority interrupt Y to finish and will continue waiting until the virtual CPU indicates to the virtual I O APIC that Y has completed. If interrupt Y were the only interrupt pending in the virtual I O APIC then the hypervisor would indicate via the shared page that the guest OS may evaluate the EOI lazily. However because interrupt X is waiting to be processed lazily updating the EOI may delay the time by which interrupt X is processed degrading system performance. Therefore when the hypervisor via the I O APIC virtualization module detects a second lower priority interrupt is pending at the virtual I O APIC the hypervisor may indicate via the shared page that any EOI generated by the virtual CPU must be transmitted immediately.

Another common scenario may occur when a first interrupt is being handled by the virtual CPU and a second higher priority interrupt is received by the virtual I O APIC . In this scenario the virtual I O APIC uses the ISR register to maintain a stack of nested interrupt handlers that are executing on the virtual CPU . By way of example if interrupt X is being handled by the virtual CPU and the virtual I O APIC receives interrupt Y Y having a higher priority than X then the virtual I O APIC will interrupt the CPU with interrupt Y.

Interrupt Y will literally interrupt the execution of X s service request handler before the virtual CPU is finished executing X s service request handler. X s service request handler is placed on a stack of service request handlers. Once both of the interrupt requests X and Y have been sent to the virtual CPU the IRR bits associated with these interrupts will be set to 0 while the ISR bits associated with interrupts will be set to 1 indicating that both interrupts have been sent to the virtual CPU . In one embodiment the shared page may contain a single bit to indicate whether an EOI has occurred. Because there are two interrupts pending and only one bit of information it would be impossible for the hypervisor to determine whether one or both interrupts had generated an EOI. Therefore the guest OS is configured to send an EOI when the first of the two interrupts completes.

Continuing the example once the service request handler for interrupt Y completes the virtual CPU will return an EOI to the virtualized I O APIC because there are at least two bits set in the ISR . The virtualized I O APIC will clear the ISR bit associated with interrupt Y and the CPU will continue processing the service request handler for interrupt X. Upon processing the EOI for interrupt Y the virtual I O APIC will re prioritize and determine that there is only one interrupt pending at the virtual CPU . Accordingly the hypervisor will set the bit in the shared page indicating that the guest OS may lazily evaluate an EOI.

Level triggered interrupts comprise the third scenario requiring a guest OS to immediately send an EOI to the hypervisor for processing. A level triggered interrupt may not be lazily evaluated because the hardware device triggering the interrupt will continue to assert its line longer than necessary and therefore will be prevented from issuing a subsequent interrupt. As a result the hypervisor will require that an EOI associated with a level triggered interrupt be immediately transmitted generating an intercept in the hypervisor so that the interrupting device can de assert its line.

At act the priority of the highest priority IRR bit is greater than the priority of the highest priority ISR bit causing the I O APIC to send the received interrupt to the CPU. At act the APIC updates the IRR and ISR registers associated with the received interrupt setting the bit in the IRR to 0 the bit in the ISR . These bits indicate that the interrupt is no longer pending in the APIC IRR bit 0 and that the interrupt is currently being executed by the CPU ISR bit 1 .

Act meanwhile determines whether the interrupt for which an EOI was just received was an edge triggered interrupt or a level triggered interrupt. At act when the interrupt to which the EOI is responding is an edge triggered interrupt the APIC is finished processing the EOI. Act however is performed when the interrupt was a level triggered interrupt at which point the I O APIC signals to the device that asserted the interrupt that the interrupt request has been completed and that the device can de assert its line to the I O APIC.

A level triggered interrupt may be communicated from the hard disk drive to the virtual I O APIC by asserting the line until an indication that the interrupt completed is received by the hard disk driver .

Moreover any of the acts of any of the methods described herein may be implemented by a processor or other computing device based on instructions stored on one or more computer readable media. Computer readable media can be any available media that can be accessed by a hypervisor guest OS and or I O APIC virtualization module as appropriate. Computer readable media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer readable media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the hypervisor guest OS and or I O APIC virtualization module. Combinations of the any of the above should also be included within the scope of computer readable media.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

