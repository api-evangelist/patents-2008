---

title: Platform for enabling terminal services virtualization
abstract: Disclosed are techniques for providing a platform and application program interface (API) that leverages a terminal services session broker infrastructure to support third party plug-in applications. In a typical scenario, when a user requests for a connection to access third party plug-in applications, the application program interface may interact with the session broker process to identify sessions or suitable servers to which the user can be connected. The user may access the third party plug-in applications through the identified sessions or suitable servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009329&OS=09009329&RS=09009329
owner: Microsoft Technology Licensing, LLC
number: 09009329
owner_city: Redmond
owner_country: US
publication_date: 20081125
---
This application is related to the subject matter disclosed in the following commonly assigned applications the entirety of which are hereby incorporated by reference herein U.S. patent application Ser. No. 12 114 582 Session Broker Extensibility Application Program Interface filed on May 2 2008 and U.S. patent application Ser. No. 11 771 921 Virtual Desktop Integration with Terminal Services filed on Jun. 29 2007.

Remote computing systems may enable users to access resources hosted by the remote computing systems. Servers on the remote computing systems can execute programs and transmit signals indicative of a user interface to clients that can connect by sending signals over a network conforming to a communication protocol such as the TCP IP protocol. Each connecting client may be provided a session i.e. an execution environment that includes a set of resources. Each client can transmit signals indicative of user input to the server and the server can apply the user input to the appropriate session. The clients may use protocols such as the Remote Desktop Protocol RDP to connect to a server resource. Protocols such as RDP typically handle graphics device traffic such as USB printer keyboard and mouse and in addition virtual channels for application between server and a client. The terminal server hosts client sessions which can be in hundreds in a typical server configuration.

Enabling remote connections to centralized desktops hosted in virtual machines is commonly used for centralized computing scenarios. Deployment of virtual desktops requires load balancing of host computers that host virtual machines placement of virtual machines on the hosts and properly orchestrating the startup wake up and preparation of virtual machines for receiving connections. Thus it would be advantageous to provide an infrastructure that enables a user to individually customize each of the above steps to provide fast and efficient load balancing placement and orchestration of virtual machines using services such as RDP.

Methods and systems are disclosed for providing terminal services virtualization TSV that enables remote desktop connections to virtual desktops. In the disclosed TSV platform the balancing placement and orchestration steps may be performed seamlessly from a single remote desktop client connection to give the end user the same experience as connecting to a physical desktop. In various embodiments such a platform may include an infrastructure including one or more APIs that provide interfaces to enable terminal services virtualization. The platform may include a component called a session broker that brokers remote desktop connections to final destinations by communicating with various plug ins via the APIs and TSV infrastructure.

The disclosed methods and systems provide extensibility to allow plug ins to perform or optimize individual steps such as load balancing placement and orchestration. The disclosed methods and systems may further allow third parties to implement resource and filter plug ins that specialize in individual tasks such as placement and manage one or more farms of virtual machines and their relationship to the session broker.

In addition to the foregoing other aspects are described in the claims drawings and text forming a part of the present disclosure. It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and or programming for effecting the herein referenced aspects of the present disclosure the circuitry and or programming can be virtually any combination of hardware software and or firmware configured to effect the herein referenced aspects depending upon the design choices of the system designer.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail. Those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the presently disclosed subject matter. Certain well known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosed subject matter. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosed subject matter without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the disclosed subject matter and the steps and sequences of steps should not be taken as required to practice this subject matter.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the presently disclosed subject matter or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the disclosed subject matter. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and nonvolatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosed subject matter e.g. through the use of an application programming interface API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network e.g. using protocols based on the International Telecommunications Union ITU T.120 family of protocols such as Remote Desktop Protocol RDP to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client computer system. The client computer system presents the output data. Thus input is received and output presented at the client computer system while processing actually occurs at the terminal server. A session can include a shell and a user interface such as a desktop the subsystems that track mouse movement within the desktop the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program etc. In another example embodiment the session can include an application. In this example while an application is rendered a desktop environment may still be generated and hidden from the user. It should be understood that the foregoing discussion is exemplary and that the presently disclosed subject matter may be implemented in various client server environments and not limited to a particular terminal services product.

In most if not all remote desktop environments input data entered at a client computer system typically includes mouse and keyboard data representing commands to an application and output data generated by an application at the terminal server typically includes video data for display on a video output device. Many remote desktop environments also include functionality that extend to transfer other types of data.

Communications channels can be used to extend the RDP protocol by allowing plug ins to transfer data over an RDP connection. Many such extensions exist. Features such as printer redirection clipboard redirection port redirection etc. use communications channel technology. Thus in addition to input and output data there may be many communications channels that need to transfer data. Accordingly there may be occasional requests to transfer output data and one or more channel requests to transfer other data contending for available network bandwidth.

As discussed above clients may use a remote protocol such as Remote Desktop Protocol RDP to connect to a resource using terminal services. When a remote desktop client connects to a terminal server via a terminal server gateway the gateway may open a socket connection with the terminal server and redirect client traffic on the RDP port or a port dedicated to remote access services. The gateway may also perform certain gateway specific exchanges with the client using a terminal server gateway protocol transmitted over HTTPS.

A virtual machine monitor such as a hypervisor is a program that creates virtual machines each with virtualized hardware resources which may be backed by underlying physical hardware resources. illustrates a virtual machine environment with a plurality of virtual machines comprising a plurality of virtual processors and corresponding guest operating systems . The virtual machines are maintained by a virtualizing layer which may comprise of a scheduler and other components not shown where the virtualizing layer virtualizes hardware for the plurality of virtual machines . The plurality of virtual processors can be the virtual counterparts of underlying hardware physical processors .

All of these variations for implementing the above mentioned partitions are just exemplary implementations and nothing herein should be interpreted as limiting the disclosure to any particular virtualization aspect.

The present disclosure is directed to a system that provides virtual desktop integration with terminal services. An example of a remote access system is Terminal Services systems provided by the Microsoft Corporation. A Terminal Services system is discussed in the examples below however it is to be appreciated that the techniques discussed are applicable to other remote access systems such as Virtual Network Computing VNC Citrix XenApp and the like.

A session broker controls the allocation of sessions to users communicating in a remote access system environment. A session broker allocates a session to a user based on session state information stored in the session broker. Session state information may include for example session IDs user names names of the servers where sessions are residing the number of active sessions in each server computer and so on.

In a remote access system environment a server may receive a user request for a connection. The server may initially accept the connection request and then query the session broker to determine where the user can be redirected. The session broker analyzes the session state information of that particular environment and identifies a server to which the user can be redirected. A suitable server may possess a session previously accessed by the user but later disconnected to which the user can be reconnected again. In an implementation a suitable server may provide a new session to which the user can be connected provided the user does not possess any other existing sessions. The session broker sends information to the requested server enabling the server to establish a connection with the suitable server. For example the information may include a machine ID a session ID and location of the suitable server. The requested server analyzes the information received and redirects the user to the suitable server. Once the user establishes the connection with the suitable server the user can access applications present in the suitable server. These applications may be compatible to the session broker logic that was used in identifying the suitable server from the terminal services environment. In one embodiment a client computer is connected via a redirector broker device to one the virtual desktops running on a server or a terminal server. The client computer examines a redirector token in a remote desktop protocol RDP compliant packet. The client computer connects to one of the many virtual desktops based on information contained in the redirector token. Use of the redirector token enables integration of the session hosted with one or more VMs or terminal servers with the existing terminal session deployment model. The client computer using the token can be appropriately directed to either a virtual desktop or terminal session.

In another embodiment an RDP client computer is connected to one of the virtual desktops using a session broker and a pool manager. The session broker assigns the virtual desktops to the client computer when the client computers connected to a virtual desktop hosted on a VM and the pool manager indicates which of the virtual desktops are available to be assigned. The session broker can be abstracted from code that creates and manages VM images on the fly. This abstraction can be achieved by extensibility points within the broker. Thus the virtual desktop hibernation and state transition may occur and be transparent to the RDP client.

In a further embodiment the RDP client computer is connected to a virtual desktop. The RDP client computer indicates a network name that is used by the broker to generate an internet protocol IP address to establish connection between the client computer and the virtual desktops. By hiding the individual virtual desktop IP addresses from the RDP clients only a single network name of the broker is initially required to be externally exposed to the terminal server clients. The construction of the virtual desktop and terminal services integration system and an environment in which this integration system may be enabled by techniques is set forth first below with reference to the figures.

Client devices may be any computing device capable of communicating with a network and are also referred to as terminal services clients. In one embodiment the client devices are general purpose desktop computing devices assigned to users e.g. employees that are connected to the wired network . Although the illustrated client devices are depicted as a desktop PC the client devices may be implemented as any of a variety of conventional computing devices including for example a server a notebook or portable computer a workstation a mainframe computer a mobile communication device a PDA an entertainment device a set top box an Internet appliance a game console and so forth. In one embodiment client devices transmit requests for content send content and receive content using an RDP protocol . Client devices receive content in an RDP packet format from redirector device .

Network may be any type of communications network such as a local area network wide area network cable network the internet the World Wide Web or a corporate enterprise network. Content is transmitted from and received by client devices in a packetized format via network for delivery to and from redirector device .

Redirector device includes a processor . Included in memory not shown may be a redirector module . Broker module includes a session broker module a policy module and a pool manager module . Broker module may be disposed in a server such as server may be disposed in a standalone server or may be disposed within redirector device .

Server includes a plurality of virtual desktops generally known as virtual machines. Although the illustrated virtual desktops are shown as a blade within server the virtual desktops may be individually implemented as any of a variety of conventional computing devices including for example a server a notebook or portable computer a workstation a mainframe computer a mobile communication device a PDA an entertainment device a set top box an Internet appliance a game console and so forth. Redirector receives RDP packets from clients and incorporates those packets for delivery to broker module . Redirector also transmits requests from broker module to establish a connection between one of virtual desktops and client devices . Such requests are received in broker by session broker . Broker also receives from server an indication of which virtual desktops are available.

Session broker also receives a policy indication from policy module indicating criteria for selection of virtual desktops . Session broker then provides an indication to redirector indicating which one of the virtual desktops are available for connection to one of the client devices . In one embodiment session broker may indicate that one of client devices may connect to terminal server . The redirector feeds a packet to one of client devices containing a redirection token indicating an IP address of the virtual desktop. Also the redirector sends an indication of connection to one of client devices but in one embodiment does not expose the IP address of the virtual desktop that the client device is connected. In this embodiment the re director maintains a list of the names of the virtual desktops indicated by each of the client devices and the corresponding IP address of the virtual desktop . Thus when a connection name is provided with the request the re director establishes a connection between one of the client devices with the corresponding virtual desktop . In another embodiment redirector may supply the IP address of the virtual desktop to the client device so that client device may directly connect to the virtual desktop.

The client device has process capabilities and memory suitable to store and execute computer executable instructions. In this example client device includes one or more processors memory and is coupled with network interface . The memory may include volatile and nonvolatile memory removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Such memory includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices RAID storage systems or any other medium which can be used to store the desired information and which can be accessed by a computer system.

Stored in memory are operating system module application s and RDP protocol handler module . The modules may be implemented as software or computer executable instructions that are executed by the one or more processors .

The operating system module contains an operating system that may enable the other modules of the client device to receive process and exchange data. In addition the operating system module may also enable the client device to communicate with other devices across a network using network interface .

The virtual desktop has process capabilities and memory suitable to store and execute computer executable instructions. In this example virtual desktop includes one or more processors and memory . The memory may include volatile and nonvolatile memory removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Such memory includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices RAID storage systems or any other medium which can be used to store the desired information and which can be accessed by a computer system.

Stored in memory are operating system module one or more application s and database . The modules may be implemented as software or computer executable instructions that are executed by the one or more processors .

The operating system module contains an operating system that may enable the other modules of the virtual desktop to receive process and exchange data. In addition the operating system module may also enable the virtual desktop to communicate with other devices via redirector device .

The flow diagram in depicts exemplary processes used by processor see in redirector device and broker see and represents a sequence of operations that can be implemented in hardware software and a combination thereof. The flow diagram in depicts exemplary processes used by processor see in client device see and also represents a sequence of operations that can be implemented in hardware software and a combination thereof. The flow diagram in depicts exemplary processes used by processor not shown in server see and additionally represents a sequence of operations that can be implemented in hardware software and a combination thereof. In the context of software the blocks represent computer executable instructions that when executed by one or more processors perform the recited operations.

Generally computer executable instructions include routines programs objects components data structures and the like that perform particular functions or implement particular abstract data types. The order in which the operations are described is not intended to be construed as a limitation and any number of the described blocks can be combined in any order and or in parallel to implement the process. For discussion purposes the processes are described with reference to system of and system of although it may be implemented in other system architectures.

In block the session broker reads a table in policy module indicating which of the virtual desktops may be used with a particular client device . Such elements of the table may be set by an administrator. In accordance with the table the virtual desktop is selected and the IP address for the virtual desktop is provided to redirector in block . Redirector then stores the IP address and the corresponding name provided by the client device . In block a connection is established by feeding an acknowledgment of the connection request to client device .

Once the connection is established in block the redirector device then receives content during a session from either one of the virtual desktops or one of the client devices . In block the origin of the content is determined. If the content originates from one of the virtual desktops in server in block the redirector feeds retrieved content to the client device If the content originates from one of the client devices in block the redirector reads the address for the device originating the content and feeds the client content using redirector device to the corresponding virtual desktop or terminal server in block .

Further described in the present disclosure are techniques for a remote access system session broker infrastructure that may support third party plug in applications. A challenge that the remote access system environment faces is to provide users access to third party applications and in particular plug in applications. The techniques described herein addresses this challenge by providing an application program interface API that leverages the remote access system session broker infrastructure to support third party plug in applications. In a typical scenario when a user requests for a connection to access third party plug in applications the API may override the session broker logic and interact with the session broker process to identify sessions or suitable servers to which the user can be connected. The user may access the third party plug in applications through the identified sessions or suitable servers.

In one embodiment the third party plug in applications may be updated from changes made in the remote access system environment for example creation of new sessions deletion of sessions configuration changes in servers connection and disconnection information of sessions etc. The session broker process may manage the changes in the remote access system environment and notify the changes to the third party plug in applications upon receiving instructions from the API.

The techniques described herein may be used in many different operating environments and systems. Multiple and varied implementations are described below. An exemplary environment that is suitable for practicing various implementations is discussed in the following section.

Exemplary systems and methodologies for leveraging a remote access system session broker infrastructure to support third party plug in applications are described in a general context of computer executable instructions program modules being executed by a computing device such as a personal computer. Program modules generally include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. While the systems and methods are described in the foregoing contexts acts and operations described hereinafter is implemented in hardware or other forms of computing platforms.

The network may be a local area network LAN a wide area network a wireless network an optical network a metropolitan area network MAN etc. The client devices may be a general purpose computing device a laptop a mobile computing device and so on.

The server collection may include a number of servers . . . N collectively referred to as servers . The servers may have plug in s available for the client devices . The plug in s may include for example third party plug in applications and any other software applications. As discussed above sessions created between the servers and the client devices enable the client devices to access the plug in s hosted in the servers . The servers create these sessions based on instructions received from the session broker server .

In one embodiment a client device may send a request to the server collection to access the plug in s hosted there. A server from the server collection accepts the request and establishes a connection with the client device . The server may send a query to the session broker server to determine where to redirect the client device . It is to be noted that any server from the server collection may accept the connection request from the client device . In another implementation the server may act as a dedicated redirector and accepts the connection request from the client device . In such an implementation the client device requesting for a connection may initially connect to the server .

The session broker server may implement a session broker module and an extensible API to process the query sent by the server and identify a session that can be provided to the client device . The extensible API may be a Distributed Component Object Model DCOM based interface that enables several software components distributed across server network computing devices to communicate with each other. In one implementation the extensible API may be a Component Object Model COM based interface that enable communication between various software components in a network environment.

In one embodiment the session broker module may receive the query and notify the extensible API of the receipt of the query. The extensible API generates a function call that may trigger the session broker module to identify the session. The identified session may be an existing session that was earlier associated with the client device . The session broker module may then instruct the server to redirect the client device to any one of the servers for example the server having an existing session. In this instance the server redirects the client device to establish a connection with the server . In another implementation the session broker module may also redirect the client device to the server having an existing session located outside the server collection .

In yet another embodiment the session broker module may identify any suitable server having a new session that can be provided to the client device which may not have any existing session in the remote access system environment. The session broker module then instructs the server to redirect the client device to a suitable server out of the servers . In yet another implementation the session broker module may identify the server as capable of providing the new session to the client device .

The server initially connects with a client device and receives a request from the client device for connection to a session. The session broker client collects the request along with client information. The client information may include for example machine ID and location of the client devices in the remote access system environment. The session broker client sends both the request and the client information to the session broker module . The session broker module may perform various functions shown as a part of a session broker process to identify a server out of the servers to which the client device can be redirected.

In operation the session broker module may inform the extensible API about the receipt of the request. In one implementation the session broker module may perform a function namely initialization to initialize the plug in s . During the process of initialization the session broker module determines a class ID of the plug in s from the registry . The registry may include for example class IDs of various plug in applications information about settings of hardware operating system nonoperating system client devices servers and so on. Pursuant to identifying the class IDs of the plug in s the session broker module may create an instance for the plug in s which in turn initialize the plug in s . Once an instance is created the extensible API may trigger the session broker module to initiate a function call TSSDRpcGetUserDisconnectedSessions depicted as disconnected session to identify the session to which the client device can be redirected. In one implementation disconnected session may determine an existing session to which the client device was connected previously but later disconnected. In such a scenario the session broker module may make function calls namely TSSDRpcPingSD and TSSDRpcQuerySDVersion to identify an existing session from the session directory and at the same time determine the version of the session directory. The above function calls may be shown as ping session directory and session directory version respectively. The existing session may be a session associated with any one of the servers in the server collection . In another implementation the existing session may be associated to the server located external to the server collection .

Upon identifying an existing session the session broker module may collect session details for example session ID machine ID and location related to the server that may provide the existing session e.g. server . For example the session broker module may then send the session details along with instructions to establish a connection to the remote connection manager . The remote connection manager identifies the server out of the servers based on the session details and redirects the client device to the server to establish a connection. During the process of redirecting the client device the remote connection manager may send a request for a connection to the server .

The session broker module continuously monitors the status of the connection and updates the extensible API of any changes that occur in the remote access system environment. During the monitoring process the session broker module may make a function call i.e. TSSDRpcSetServerReconnectPending shown as server reconnection pending to inform the extensible API that a request for connection with the server is pending.

Once the connection is established the session broker module may report the connection status to the extensible API . For example the session broker module may make a function call TSSDRpcSetSessionReconnected shown as session reconnected to confirm the extensible API that the client device is connected.

The extensible API may initiate the session broker module to generate another function call i.e. disconnected session to identify a new session that can be provided to the client device . In such a case the session broker module collects server details associated with the server that may be either from the server collection for example server or the external server and sends the server details to the remote connection manager . The remote connection manager directs the client device to create a new session with the server or the server . In an implementation the session broker module confirms whether a new session is created and accordingly initiates a function call namely TSSDRpcCreateSession depicted as create session to inform the plug in s about the creation of the new session.

In the above implementations the extensible API may randomly but continuously initiate the session broker module to make a function call i.e. TSSDRpcSetSessionDisconnected depicted as session disconnected to inform the plug in s that the session connecting the client device and the server or the server is disconnected. In such a situation the session broker module may instruct a local session manager to monitor the disconnected session.

In addition to the above the extensible API may trigger the session broker module to provide information regarding configuration changes made in the remote access system environment. In such a scenario the session broker module may initiate a function call i.e. TSSDRpcUpdateConfigurationSetting shown as configuration setting that may collect information related to configuration changes and reports the changes if any to the plug ins .

The extensible API may instruct the session broker module to identify the status of the server or server connected to the client device . The session broker module after receiving instructions may make function calls namely TSSDRpcServerOnlineEx and TSSDRpcServerOffline respectively shown as server online and server offline to inform the plug in whether the server or server is offline.

The extensible API may interact with the session broker module to determine the status of various sessions running at a specific time in the remote access system environment. In such an implementation the session broker module may initiate a function call for example TSSDRpcDeleteSession shown as delete session to inform the plug in s that the session is deleted. The session broker module may initiate a function call namely TSSDRpcRepopulateAllSession shown as repopulate all sessions to check status of all the sessions managed by the session broker module .

The system memory stores program modules and program data . The program modules may include the session broker module an extensible API and other application program modules e.g. an Operating System OS to provide a runtime environment networked communications between multiple users .

The session broker module has several responsibilities including acting as a central unit to the remote access system environment allocating sessions to the client devices requesting for connection and monitoring the sessions in the remote access system environment. The session broker module may include an initializing module a function calling module a monitoring module and a rejoining module .

As discussed above the session broker module may be employed to receive a request for a session sent by the client device through the server . Based on the request received the initializing module initializes the extensible API . The initializing module may determine a class ID of the plug in s from the registry . Once the class ID of the plug in s matches with the class ID as stored in the registry the initializing module may create an instance to initialize the extensible API .

The extensible API instructs the session broker module to generate appropriate function calls as discussed previously to identify the session to which the client device can be redirected. Therefore a function call for example WTSSBX GetUserExternalSession shown as external session collection is called to identify external sessions present in the remote access system environment. The external session may be sessions provided by the server located outside the server collection . In such a case the external session collection may trigger the function calling module to generate a function call such as disconnected session to determine whether the server can offer an external session to the client device and also collect the session details if connected externally. Thereafter the session broker module may collect the session details and direct the client device to the server through the server . The function call made by the function calling module may be monitored by the monitoring module to determine whether the function call is pending beyond a predefined time. The predefined time may be preset by a user such as an administrator. In case the function call remains pending beyond the predefined time the monitoring module may instruct the session broker module to log an error message if the plug in s fails. Thereafter the session broker module may initiate the extensible API again.

In one embodiment the external session collection may trigger the function calling module to generate a function call to determine an existing session associated with the client device from the remote access system environment. The function calling module in turn generates function calls such as ping session directory and session directory version to identify an existing session of the client device from the session directory. The function calling module may identify any one of the servers in the server collection for example server capable of providing an existing session. In such a scenario the function calling module collects server details of the server and provides their server details to the session broker module . Based on the server details the session broker module may direct the client device to the server . In another implementation the existing session may be provided by the server located external to the server collection .

The extensible API may initiate the function calling module to make a function call namely suitable server collection to identify a suitable server from the server collection or external server that can provide a new session to the client device . For example the function calling module may make a function call namely WTSSBX GetMostSuitableServer to identify the suitable server that can provide a new session to the client device . Therefore the function calling module collects server details associated with a suitable server that looks suitable for connection and enables the session broker module to instruct the server to establish a connection between the client device and the suitable server.

The function call as discussed above may be monitored by the monitoring module to determine whether the function call is pending beyond a predefined time. In case the function call remains pending beyond the predefined time the monitoring module may instruct the session broker module to log an error message if the plug in s fails. Thereafter the monitoring module redirects the extensible API to interact with a load balancing algorithm of the session broker module . The load balancing algorithm enables the session broker module to identify a list of suitable servers. The session broker module identifies a suitable server having the least number of sessions and instructs the server to redirect the client device to the suitable server.

In the above embodiments the extensible API may be configured to make a call session change notification that triggers the session broker module to update the plug in s about changes occurring in the sessions. For example the extensible API may make a function call namely WTSSBX SessionChangeNotification to enable the session broker module to collect information about any changes occurring in the sessions such as creation of new sessions disconnection of existing sessions reconnection of sessions and deletion of sessions.

In one embodiment when the function call namely WTSSBX SessionChangeNotification remains pending more than the predefined time and plug in s fails an error event is logged.

In addition the extensible API may make a call WTSSBX MachineChangeNotification shown as machine change notification to initiate the session broker module to gather information and then report about changes occurring in the servers and external server in the remote access system environment to the plug in s . The changes that occur may include configuration changes in the servers and changes in status of the servers i.e. online or offline status of the servers . In an implementation when a function call WTSSBX MachineChangeNotification remains pending for more than a predefined time and the plug in s fail an error event is logged.

Exemplary processes for leveraging a remote access system session broker infrastructure to support third party plug in applications are described with reference to . These processes may be described in the general context of computer executable instructions. Generally computer executable instructions can include routines programs objects components data structures procedures modules functions and the like that perform particular functions or implement particular abstract data types. The processes may also be practiced in a distributed computing environment where functions are performed by remote processing devices that are linked through a communications network. In a distributed computing environment computer executable instructions may be located in both local and remote computer storage media including memory storage devices.

The order in which the method is described is not intended to be construed as a limitation and any number of the described method blocks can be combined in any order to implement the method or alternate method. Additionally individual blocks may be deleted from the method without departing from the spirit and scope of the subject matter described herein. Furthermore the method can be implemented in any suitable hardware software firmware or a combination thereof without departing from the scope of the disclosed subject matter.

At block a user requests for a connection to a session. In one implementation user of the client device makes a request to the server for a session in order to access the plug in s or any other applications hosted on the servers. The session broker module receives the request for a session from the server that is initially connected with the client device . Thereafter the session broker module initializes the extensible API associated with the plug in s .

At block a function call i.e. GetUserDisconnectedSession is called to obtain a session. In one implementation the server acting a redirector for the client device makes the function call to the session broker server . The session broker module of the session broker server receives the function call and informs the extensible API of the function call.

At block a function call namely GetUserExternalSession is made in response to the call GetUserDisconnectedSession . The session broker module may send the server function call made by the server to the extensible API . The extensible API upon receipt of this server function call may make a function call GetUserExternalSession to identify a session for the client device .

At block an external session for the user of the client device is searched. A function call GetUserExternalSession initiated by the extensible API may trigger the session broker module to identify a user external session present in the remote access system environment.

At block a determination is made whether the external session is present or not. If an external session is present i.e. the YES path from block the client device is redirected to the server to establish the external session. If there are no external sessions present in the remote access system environment i.e. the NO path from block an exiting session associated with the client device is identified at block .

At block after an existing session is identified session details of that existing session is collected. Such session details may be stored in the session directory stored in the session broker server . At block a connection with the server having an existing session is established. The session broker module may send instructions along with the session details of the suitable server having an existing session to the server configured to redirect the client device . The server identifies the suitable server based on the session details and redirects the client device to the suitable server to establish a connection.

At block a function call GetUserDisconnectedSession is made to obtain a session. In one implementation the server acting as a redirector for the client device may make the function call to the session broker server . The session broker module of the session broker server receives the function call and informs the extensible API of the function call.

At block a function call GetUserExternalSession is made in response to a call GetMostSuitableServer . The session broker module may send the server function call made by the redirecting server to the extensible API . The extensible API upon receipt of this server function call may call the function call GetMostSuitableServer that may initiate the session broker module to identify a suitable server for example any server out of the servers or the external server to which the client device can be redirected.

At block the server ID associated with the suitable server is collected. The session broker module gathers the server ID of the suitable server in the remote access system environment.

At block the server ID of the suitable server is validated. In one implementation the session broker module may check the registry to identify whether the server ID is present in the registry or not and also checks whether the server ID relates to the suitable server.

In another implementation the session broker module may determine whether the suitable server having the server ID is in drain mode or not. If the suitable server is in drain mode the suitable server may deny any new remote logon from other users. Further in such a condition the users in the remote access system environment having existing session with the servers may be reconnected. In yet another implementation the session broker module may check whether the suitable server having the desired server ID has crossed the maximum number of sessions allocated to suitable server.

At block a determination is made whether the server ID is valid or not. If the server ID is valid i.e. the YES path from block the client device is redirected to establish a connection with the suitable server at block . If the server ID is not valid i.e. the NO path from block a plug in error event is logged. For example a warning is logged when the function call WTSSBX GetMostSuitableServer called by the extensible API returns an invalid server ID.

In another scenario if the function call WTSSBX GetMostSuitableServer redirects the client device to the suitable server in drain mode the plug in error event is logged as a warning. Similarly in yet another scenario a plug in error event is logged when the function call WTSSBX GetMostSuitableServer provides the suitable server that has violated a predefined session limit.

At block a suitable server is identified from a list of servers having their corresponding weights. The session broker module may employ a load balancing algorithm to assign weights to each server in the remote access system environment based on the number of sessions handled by each server. The session broker module generates a list of servers and identifies a suitable server from the list. The server identified may possess a lesser number of sessions and thus shows the capability of providing a session to the client device . At block the client device is redirected to establish a connection with the identified server.

The following exemplary description of an API for TSV may be better understood in conjunction with the exemplary functions provided in the Appendix. Referring to depicted is a client redirector a session broker virtual machine farm and terminal server farm . The terminal service client may connect to a terminal server redirector which in turn may contact the session broker through an RPC call. The redirector may be a component that acts as a proxy for an RDP connection to communicate with session broker in order to send back a redirection packet to the terminal service client . The session broker is the component that may handle load balancing and redirection of terminal service sessions and invoke a policy plug in to determine an appropriate end point.

A plug in may for example be a software object such as a Component Object Model COM based dynamic link library DLL . Typically only administrators can install resource and filter plug ins for security purposes. The following interfaces may be implemented by plug ins and supported by the session broker 1 Resource 2 Policy 3 Filter Resource 4 Load Balancing 5 Placement and 6 Orchestration. Plug ins may implement one or more of these interfaces. A plug in that implements one of these interfaces may further determine the type of resource that may be managed such as terminal server farm resources virtual machine resources or other resources. A filter plug in may implement load balancing placement and orchestration interfaces invoked during connection time. A resource plug in manages a farm in addition to implementing balancing placement and orchestration interfaces. Thus a resource plug in implements various other interfaces that relate to farm management. The session broker may manage the plug ins as follows 

3. While the scenario where multiple plug ins manage a single resource type and identical farms may be discouraged for example a Citrix Terminal Server Plug in and Microsoft Terminal Server Plug in should not manage the same farm the policy plug in may be responsible to determine which of these plug ins should actually be used.

Plug ins may be loaded when session broker service is initiated. In some embodiments plug ins may be dynamically loaded at run time. Plug ins may further register under a registry key. Each subkey may be enumerated by the session broker and treated as a plug in.

The endpoint may be a virtual machine farm a personal desktop or a terminal server. The client may connect to this final endpoint. While the above process is described in terms of a farm scenario the principles may be applied to other embodiments.

Returning to a terminal server client may connect to a redirector terminal server that can reside either on the session broker machine or a dedicated machine. The redirector terminal server may call the session broker to request a redirection packet in order to redirect the client to a final destination terminal server or virtual machine.

The session broker may call the policy plug in to determine which farm or personal desktop the user should be redirected to. A policy plug in determines the target farm or machine for the client requested connection. The policy plug in may implement an assignment policy or other policies. The policy plug in may return at least two pieces of information 

If the endpoint is a personal desktop PD the policy plug in may communicate to a central publishing service which in turn communicates with an Active Directory AD to obtain assigned personal desktops to a user using an updated AD schema for personalized desktops in TSV scenarios.

The session broker may call at least one filter plug in and or a resource plug in identified by the policy described above. A filter plug in may be a third party plug in that can override some of the load balancing placement and orchestration functions of a resource plug in. Filter plug ins may also be loaded without resource plug ins. In some embodiments a filter plug in may be implemented with the resource plug in functions. Resource plug ins may implement all of the resource plug in functions. A resource plug in may also responsible for reporting host session state changes to the session broker. When a resource plug in reports host or session changes to the session broker notification of the changes may be provided to the filter plug ins.

Both resource and filter plug ins may exist independently of each other. For example in a non farm case with a single terminal server desktop or personalized virtual machines that are not part of a virtual machine pool a load balancing decision is not required since the target host is known. Accordingly it may not be necessary for the session broker to maintain host session states.

Typically a resource plug in may be used when a pool of resources are present such as virtual machines terminal servers and blades in a farm. The plug in s may make a load balancing decision to decide a target host. Since the endpoints are not dedicated to a particular client the plug in should also keep track of disconnected or logged off sessions. Such a decision may be driven by the host session states maintained by the session broker based on the notifications triggered by the resource plug in to the broker.

Some of the actions of a resource plug in may be overridden by a filter plug in. Such actions may comprise four methods GetMostSuitableTarget QueryHostEnvironmentForTarget CreateHostEnvironmentForTarget and PrepareTargetForConnect. Notifications from a resource plug in cannot be overridden by a filter plug in. Resource plug in may notify the session broker about any changes to host session configurations using the above described methods. Examples of notifications include Machine join to a farm and user disconnected from a session on a machine. The session broker may thus be able to maintain the host session states. This state information can be queried by a resource plug in generally used to make load balancing decisions. A single filter plug in can override multiple resource plug ins in the calls for load balancing placement or orchestration

A filter plug in may register with the session broker to receive notifications from the session broker in order to track host session state changes. The session broker may then forward host or session change notifications to the filter plug ins whenever a resource plug in notifies the broker.

The session broker may allow multiple filter plug ins to implement the same method. To enforce an order in which the filter plug ins may be called the filter plug in may register a priority. In one embodiment this may be a positive integer value. The priority may vary between 1 to N where 1 is the highest priority and N is the lowest priority where N number of filter plug ins. Each filter plug in may have an entry in the registry where the priority is entered as a registry sub key.

Continuing with the session broker may ask the filter plug ins and or the selected resource plug in for the functions described below. Filter plug ins may override a resource plug in for any or all of the below functions. More than one filter plug in may be loaded. As described above filter plug in priority may be enforced by using a integer sub key in the registry for each plug in. These integer sub keys determine the order in which filter plug ins are called.

c. place if machine is not already placed Placement is the process of locating the virtual machine image and making sure it is placed in the right virtual machine host. When an end user finishes using a VM that VM is available to be moved off of the VM host into a fileshare or data library. Thus a filter plug in which implements placement may optionally consider whether the filter should un place or remove the VM when the end user is finished using the VM. 

Filter plug ins and or resource plug ins may respond to the above steps and return an IP address for the selected endpoint machine. In the filter plug in may be the default resource plug in that performs load balancing and orchestration. The plug in may communicate to a VM host agent on the VM host machine in order to orchestrate the virtual machine and initialize the virtual machine. Orchestration is the process of preparing the machine VM image to start up a VM boot up the VM and accept terminal server connections. The plug in may then obtain an IP address using key value pairs KVP . KVP may be implemented for exampled by a hypervisor in Windows . The IP address may then be returned to the session broker .

The session broker may send the target IP address to the redirector . The redirector may then send a redirection packet to client . Finally the client may connect to the IP address received in the redirection packet.

In accordance with the above features disclosed herein is an application programming interface API that provides terminal server session broker extensibility to enable load balancing and remote desktop connections to various types of machines such as virtual machines terminal servers or other types of endpoint entities. The API may be exposed to the above described plug ins in order to manage a farm of virtual machines a farm of terminal servers and the like.

In one embodiment the session broker may query for GetMostSuitableTarget to determine an endpoint to return to the client. The session broker may query filter plug in to determine if the GetMostSuitableTarget function is implemented. In the example shown in the filter plug in has implemented the function and may inform the session broker . The filter plug in may then determine a suitable target and return the target name to session broker . Since filter plug in was able to handle the request session broker need not query additional filter plug ins or resource plug ins to fulfill the GetMostSuitableTarget function.

In another embodiment the session broker may query for PrepareTargetForConnect to prepare the identified host environment. The session broker may query filter plug in to determine if the PrepareTargetForConnect function is implemented. In the example shown in the filter plug in has implemented the function and may inform the session broker . Since filter plug in was able to handle the request session broker need not query additional filter plug ins or resource plug ins to fulfill the PrepareTargetForConnect function. This method may be a no operation in the case of a terminal server farm or terminal server desktops. In the case of a virtual machine farm filter plug in may check if the host environment is ready for a connection. If not filter plug in may prepare the identified host environment for a connection. Filter plug in returns the host object to the session broker .

In another embodiment the session broker may query for PrepareTargetForConnect to prepare the host for a connection. In the example shown in the filter plug in has implemented the function and may inform the session broker . The filter plug in may call the session broker s PrepareTargetForConnect which signals to the broker that the host is ready for connection. Although filter plug in can override some processes of a resource plug in filter plug in is typically not permitted to override processes that signal host related events to the session broker . It is the responsibility of the resource plug in to handle such events.

In the case where no filter plug ins have implemented a requested function session broker may query the resource plug in . Resource plug in may monitor host related events and inform the broker about the host related events. Such events may include for example AddTargetToStore AddSessionToStore and the like.

Generally the extensibility principles disclosed herein provide for plug in interoperability in a way that any plug in can be plugged in as long as they adhere to the API interfaces.

Operation illustrates invoking the one or more secondary plug ins and requesting the following 1 a selected virtual machine 2 indication of whether the selected virtual machine is instantiated 3 a location when the selected virtual machine is not instantiated and 4 preparing the selected virtual machine for accepting a new connection. Operation illustrates identifying an internet protocol IP address for said selected virtual machine and returning the IP address. Operation illustrates embedding said IP address in said redirection packet and transmitting the redirection packet to the client computer. Operation illustrates connecting the client computer to one of the plurality of virtual machines based on information contained in the redirection packet.

Operation illustrates that the redirector and service broker resides on the same server. Operation illustrates that the selected virtual machine is a personal desktop the first plug in communicates with a central publishing service to obtain personal desktops assigned to said client computer using an Active Directory AD schema for personalized desktops wherein the central publishing service communicates with the Active Directory. Operation illustrates that said one or more secondary plug ins comprises filter plug ins and resource plug ins.

Operation illustrates that the filter plug ins can override the resource plug ins. Operation illustrates that more than one of said filter plug ins may be loaded. Operation illustrates that filter plug in priority can be enforced by using an integer sub key in a registry for each filter plug in wherein the integer sub keys determine the order in which filter plug ins are called.

Continuing with operation illustrates that said one or more secondary plug ins comprises a virtual machine plug in wherein the virtual machine plug in is a default resource plug in. Operation illustrates communicating to a virtual machine host agent on a host virtual machine in order to initiate and orchestrate the host virtual machine. Operation further illustrates obtaining the IP address using key value pairs. Operation illustrates that in a further embodiment the key value pairs is implemented by a hypervisor. Operation illustrates that said target destination may be a terminal server farm virtual machine farm or personal desktop.

Continuing with system may further be configured as follows. Operation illustrates that the virtual machine is executing on a server farm. Operation illustrates that the virtual machine is a personal desktop and the session broker is further configured to communicate with a central publishing service to obtain personal desktops assigned to said client computer using an Active Directory AD schema for personalized desktops. Operation illustrates that the redirector further effects the connecting of the client computer to one of the plurality of virtual machines based on information contained in the redirection packet.

Any of the above mentioned aspects can be implemented in methods systems computer readable media or any type of manufacture. For example per a computer readable medium can store thereon computer executable instructions for connecting a remote client computer to one of a plurality of virtual machines executing on a plurality of servers. Such media can comprise a first subset of instructions for receiving at one of said plurality of servers a request from the client computer for a virtual machine session a second subset of instructions for requesting a redirection packet for redirecting the client computer to a target destination on said plurality of servers a third subset of instructions for invoking one or more plug in modules for determining the target destination performing load balancing and orchestrating said redirecting a fourth subset of instructions for identifying an internet protocol IP address for said target destination and a fifth subset of instructions for embedding said IP address in said redirection packet and transmitting the redirection packet to the client computer . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein and that the three presently disclosed subsets of instructions can vary in detail per the present disclosure.

For example the instructions can further comprise instructions for implemented said connecting using Remote Desktop Protocol RDP . The instructions can further comprise instructions for implementing said one or more plug in modules as policy plug ins resource plug ins or filter plug ins .

As described above aspects of the presently disclosed subject matter may execute on a programmed computer. and the following discussion is intended to provide a brief description of a suitable computing environment in which the those aspects may be implemented. One skilled in the art can appreciate that the computer system of can in some embodiments effectuate the server and the client of . In these example embodiments the server and client can include some or all of the components described in and in some embodiments the server and client can each include circuitry configured to instantiate specific aspects of the present disclosure.

The term circuitry used through the disclosure can include specialized hardware components. In the same or other embodiments circuitry can include microprocessors configured to perform function s by firmware or switches. In the same or other example embodiments circuitry can include one or more general purpose processing units and or multi core processing units etc. that can be configured when software instructions that embody logic operable to perform function s are loaded into memory e.g. RAM and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic and the source code can be compiled into machine readable code that can be processed by the general purpose processing unit s .

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computer a server a router a network PC a peer device or other common network node a virtual machine and typically can include many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer can be connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer can typically include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external can be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are examples and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the presently disclosed subject matter are particularly well suited for computer systems nothing in this document is intended to limit the disclosure to such embodiments.

The foregoing detailed description has set forth various embodiments of the systems and or processes via examples and or operational diagrams. Insofar as such block diagrams and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof.

While particular aspects and embodiments of the subject matter described herein have been shown and described it will be apparent to those skilled in the art that based upon the teachings herein changes and modifications may be made and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of the subject matter described herein.

