---

title: Model build in the presence of a non-binding reference
abstract: One or more hardware description language (HDL) files describe a plurality of hierarchically arranged design entities defining a digital design to be simulated and a plurality of configuration entities not belonging to the digital design that logically control settings of a plurality of configuration latches in the digital design. The HDL file(s) are compiled to obtain a simulation executable model of the digital design and an associated configuration database. The compiling includes parsing a configuration statement that specifies an association between an instance of a configuration entity and a specified configuration latch, determining whether or not the specified configuration latch is described in the HDL file(s), and if not, creating an indication in the configuration database that the instance of the configuration latch had a specified association to a configuration latch to which it failed to bind.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08453080&OS=08453080&RS=08453080
owner: International Business Machines Corporation
number: 08453080
owner_city: Armonk
owner_country: US
publication_date: 20081216
---
The present application is related to U.S. patent application Ser. Nos. 10 902 628 now U.S. Pat. No. 7 386 825 and 12 336 019 now U.S. Pat. No. 8 160 857 which are incorporated herein by reference in their entireties.

The present invention relates in general to designing simulating and configuring digital devices modules and systems and in particular to computer aided design simulation and configuration of digital devices modules and systems described by a hardware description language HDL model.

In a typical digital design process verifying the logical correctness of a digital design and debugging the design if necessary are important steps of the design process performed prior to developing a circuit layout. Although it is certainly possible to test a digital design by actually building the digital design digital designs particularly those implemented by integrated circuitry are typically verified and debugged by simulating the digital design on a computer due in part to the time and expense required for integrated circuit fabrication.

In a typical automated design process a circuit designer enters into an electronic computer aided design ECAD system a high level description of the digital design to be simulated utilizing a hardware description language HDL such as VHDL thus producing a digital representation of the various circuit blocks and their interconnections. In the digital representation the overall circuit design is frequently divided into smaller parts hereinafter referred to as design entities which are individually designed often by different designers and then combined in a hierarchical manner to create an overall model. This hierarchical design technique is very useful in managing the enormous complexity of the overall design and facilitates error detection during simulation.

The ECAD system compiles the digital representation of the design into a simulation model having a format best suited for simulation. A simulator then exercises the simulation model to detect logical errors in the digital design.

A simulator is typically a software tool that operates on the simulation model by applying a list of input stimuli representing inputs of the digital system. The simulator generates a numerical representation of the response of the circuit to the input stimuli which response may then either be viewed on the display screen as a list of values or further interpreted often by a separate software program and presented on the display screen in graphical form. The simulator may be run either on a general purpose computer or on another piece of electronic apparatus specially designed for simulation. Simulators that run entirely in software on a general purpose computer are referred to as software simulators and simulators that run with the assistance of specially designed electronic apparatus are referred to as hardware simulators. 

As digital designs have become increasingly complex digital designs are commonly simulated at several levels of abstraction for example at functional logical and circuit levels. At the functional level system operation is described in terms of a sequence of transactions between registers adders memories and other functional units. Simulation at the functional level is utilized to verify the high level design of digital systems. At the logical level a digital system is described in terms of logic elements such as logic gates and flip flops. Simulation at the logical level is utilized to verify the correctness of the logic design. At the circuit level each logic gate is described in terms of its circuit components such as transistors impedances capacitances and other such devices. Simulation at the circuit level provides detailed information about voltage levels and switching speeds.

In order to verify the results of any given simulation run custom developed programs written in high level languages such as C or C referred to as a reference model are written to process input stimuli also referred to as test vectors to produce expected results of the simulation run. The test vector is then run against the simulation execution model by the simulator. The results of the simulation run are then compared to the results predicted by the reference model to detect discrepancies which are flagged as errors. Such a simulation check is known in the verification art as an end to end check.

In modern data processing systems especially large server class computer systems the number of latches that must be loaded to configure the system for operation or simulation is increasing dramatically. One reason for the increase in configuration latches is that many chips are being designed to support multiple different configurations and operating modes in order to improve manufacturer profit margins and simplify system design. For example memory controllers commonly require substantial configuration information to properly interface memory cards of different types sizes and operating frequencies.

A second reason for the increase in configuration latches is the ever increasing transistor budget within processors and other integrated circuit chips. Often the additional transistors available within the next generation of chips are devoted to replicated copies of existing functional units in order to improve fault tolerance and parallelism. However because transmission latency via intra chip wiring is not decreasing proportionally to the increase in the operating frequency of functional logic it is generally viewed as undesirable to centralize configuration latches for all similar functional units. Consequently even though all instances of a replicated functional unit are frequently identically configured each instance tends to be designed with its own copy of the configuration latches. Thus configuring an operating parameter having only a few valid values e.g. the ratio between the bus clock frequency and processor clock frequency may involve setting hundreds of configuration latches in a processor chip.

Conventionally configuration latches and their permitted ranges of values have been specified by error prone paper documentation that is tedious to create and maintain. Compounding the difficulty in maintaining accurate configuration documentation and the effort required to set configuration latches is the fact that different constituencies within a single company e.g. a functional simulation team a laboratory debug team and one or more customer firmware teams often separately develop configuration software from the configuration documentation. As the configuration software is separately developed by each constituency each team may introduce its own errors and employ its own terminology and naming conventions. Consequently the configuration software developed by the different teams is not compatible and cannot easily be shared between the different teams.

In at least one embodiment one or more hardware description language HDL files describe a plurality of hierarchically arranged design entities defining a digital design to be simulated and a plurality of configuration entities not belonging to the digital design that logically control settings of a plurality of configuration latches in the digital design. The HDL file s are compiled to obtain a simulation executable model of the digital design and an associated configuration database. The compiling includes parsing a configuration statement that specifies an association between an instance of a configuration entity and a specified configuration latch determining whether or not the specified configuration latch is described in the HDL file s and if not creating an indication in the configuration database that the instance of the configuration latch had a specified association to a configuration latch to which it failed to bind.

All objects features and advantages of the present invention will become apparent in the following detailed written description.

With reference now to the figures and in particular with reference to there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized for example as a workstation server or mainframe computer.

As illustrated data processing system includes one or more processing nodes which if more than one processing node is implemented are interconnected for communication by node interconnect and respective node controllers . Processing nodes may each include one or more processors a local interconnect and a system memory that is accessed via a memory controller . In addition to the registers instruction flow logic and execution units utilized to execute program instructions which are generally designated as processor core each of processors also includes an on chip cache hierarchy that is utilized to stage data to the associated processor core from system memories .

Local interconnect which is governed by arbiter is coupled via mezzanine bus bridge to a mezzanine bus . Mezzanine bus bridge provides both a low latency path through which processors may directly access devices among I O devices and storage devices that are mapped to bus memory and or I O address spaces and a high bandwidth path through which I O devices and storage devices may access system memory . I O devices may include for example a display device a keyboard a graphical pointer and serial and parallel ports for connection to external networks or attached devices. Storage devices may include for example optical or magnetic disks and or flash memory that provide non volatile storage for operating system middleware and application software. In the present embodiment such application software includes an ECAD system which can be utilized to develop verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.

Simulated digital circuit design models created utilizing ECAD system are comprised of at least one and usually many sub units referred to hereinafter as design entities which are described in detail in U.S. patent application Ser. No. 10 902 628 incorporated by reference above. By instantiating one or more design entities within one or more other design entities a hierarchical description of an overall design is achieved. For example a microprocessor may contain multiple instances of an identical functional unit. As such the microprocessor itself will often be modeled as a single design entity. Within the microprocessor entity multiple instantiations of any duplicated functional entities will be present. Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.

With reference now to there is illustrated a diagrammatic representation of an exemplary simulation model that may be employed by ECAD system to represent a digital design e.g. an integrated circuit chip or a computer system in a preferred embodiment of the present invention. For visual simplicity and clarity the ports and signals interconnecting the design entities within simulation model have not been explicitly shown.

Simulation model includes a number of hierarchically arranged design entities. As within any simulation model simulation model includes one and only one top level entity encompassing all other entities within simulation model . That is to say top level entity instantiates either directly or indirectly all descendant entities within the digital design. Specifically top level entity directly instantiates i.e. is the direct ancestor of two instances and of the same FiXed point execution Unit FXU entity and a single instance of a Floating Point Unit FPU entity . FXU entity instances having instantiation names FXU0 and FXU1 respectively in turn instantiate additional design entities including multiple instantiations of entity A having instantiation names A0 and A1 respectively.

Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name which must be unique among all descendants of the direct ancestor entity if any. For example top level entity has a description including an entity name i.e. the TOP preceding the colon and also includes an instantiation name i.e. the TOP following the colon . Within an entity description it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example single instances of entity B and entity C instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However this naming convention is not required by the present invention as shown by FPU entity i.e. the instantiation name is FPU0 while the entity name is FPU .

The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity provided that all entities instantiated whether singly or multiply have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.

Associated with each design entity instantiation is a so called instantiation identifier . The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top level entity instantiation name. For example the design instantiation identifier of instantiation of entity C within instantiation of FXU entity is TOP.FXU0.B.C . This instantiation identifier serves to uniquely identify each instantiation within a simulation model.

As discussed above a digital design whether realized utilizing physical integrated circuitry or as a software model such as simulation model typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies which employ stand alone configuration software created after a design is realized to load values into the configuration latches preferred embodiments utilize a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design as illustrated and described with reference to FIG. 4A of U.S. patent application Ser. No. 10 902 628 or in one or more external configuration files referenced by the one or more HDL files specifying the digital design as depicted and described with reference to FIG. 4B of U.S. patent application Ser. No. 10 902 628 .

As discussed further below with reference to configuration specification statements whether embedded within an HDL file or collected in one or more configuration files are processed by a compiler together with the associated HDL files. In accordance with a preferred embodiment of the present invention configuration specification statements facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a Dial. A Dial s function is to map between an input value and one or more output values. In general such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently by virtue of their association with particular design entities which all have unique instantiation identifiers Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent many different types of Dials can be defined beginning with a Latch Dial or LDial .

Referring now to there is depicted a representation of an exemplary LDial . In this particular example LDial which has the name bus ratio is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.

As illustrated LDial like all Dials logically has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . That is mapping table specifies a one to one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches each output of LDial logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations it is preferred that each configuration latch is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .

At input LDial receives an enumerated input value i.e. a string among a set of legal values including 2 1 3 1 and 4 1 . The enumerated input value can be provided directly by software e.g. by a software simulator or service processor firmware or can be provided by the output of another Dial as discussed further below with respect to . For each enumerated input value the mapping table of LDial indicates a selected binary value i.e. 0 or 1 for each configuration latch .

With reference now to there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model of which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model of illustrates two properties of Dials namely replication and scope.

Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example in order to instantiate the six instances of LDials illustrated in the designer need only code two LDial configuration specification statements. That is the designer codes a first LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity A in order to automatically instantiate LDials and within entity A instantiations and respectively. The designer codes a second LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity FXU in order to automatically instantiate LDials and within FXU entity instantiations and respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values different instances of the same Dial can be set to generate different outputs by providing them different inputs.

The scope of a Dial is defined herein as a set of entities including the design entity with which the Dial is associated e.g. the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated and any design entity contained within the associated design entity i.e. the associated design entity and its descendents . Thus a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated but can also specify configuration latches at least at any lower level of the design hierarchy within its scope. For example LDials and even though associated with FXU entity instantiations and respectively can specify configuration latches within entity C instantiations and respectively.

Referring now to there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of .

As shown simulation model of includes an LDial associated with top level design entity . LDial specifies the signal states of each signal sig1 which is determined by a respective configuration latch the signal states of each signal sig2 which is determined by a respective configuration latch the signal state of signal sig4 which is determined by configuration latch and the signal state of signal sig3 which is determined by configuration latch . Thus LDial configures the signal states of numerous different signals which are all instantiated at or below the hierarchy level of LDial which is the top level .

As discussed above LDial can be instantiated within top level entity of simulation model for example by embedding within the HDL file of top level entity a configuration specification statement specifying LDial or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case an exemplary configuration specification statement for LDial is as follows 

The exemplary configuration specification statement given above begins with the keyword LDial which specifies that the type of Dial being declared is an LDial and the Dial name which in this case is bus ratio. Next the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above the signal identifier for each signal is specified hierarchically e.g. FXU0.A0.SIG1 for signal relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Several different syntaxes can be employed to specify the signal states. In the example given above signal states are specified in either binary format which specifies a binary constant preceded by the prefix 0b or in hexadecimal format which specifies a hexadecimal constant preceded by the prefix 0x . Although not shown signal states can also be specified in integer format in which case no prefix is employed. For ease of data entry the configuration specification language of ECAD system also preferably supports a concatenated syntax in which one constant value which is automatically extended with leading zeros is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax the mapping table of the configuration specification statement given above can be rewritten as 

Referring now to there is depicted a diagrammatic representation of an Integer Dial IDial in accordance with a preferred embodiment of the present invention. Like an LDial an IDial directly specifies the value loaded into each of one or more configuration latches by indicating within mapping table a correspondence between each input value received at an input and an output value for each output . However unlike LDials which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables the legal input value set of an IDial includes all possible integer values within the bit size of output . Input integer values containing fewer bits than the bit size of output s are right justified and extended with zeros to fill all available bits. Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table mapping table preferably simply indicates the manner in which the integer input value received at input is applied to the one or more outputs .

IDials are ideally suited for applications in which one or more multi bit registers must be initialized and the number of legal values includes most values of the register s . For example if a 4 bit configuration register comprising 4 configuration latches and an 11 bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial the designer would have to explicitly enumerate up to 215 input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement 

IDials may also be utilized to specify the same value for multiple replicated configuration registers as depicted in . In the illustrated embodiment an IDial which can be described as an IDial splitter specifies the configuration of three sets of replicated configuration registers each comprising 15 configuration latches based upon a single 15 bit integer input value. An exemplary configuration specification statement for instantiating IDial may be given as follows 

Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials in many cases it would be inefficient and inconvenient to do so. In particular for hierarchical digital designs such as that illustrated in the use of LDials and or IDials alone would force many Dials to higher levels of the design hierarchy which from an organizational standpoint may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result proper configuration of the configuration latches would require not only significant organizational coordination between design groups but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.

In view of the foregoing the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower level Dials and control of the lower level Dials by one or more higher level Dials. The configuration specification language of the present invention terms a higher level Dial that controls one or more lower level Dials as a Control Dial CDial .

Referring now to there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial like all Dials preferably has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . Unlike LDials and IDials which directly specify configuration latches a CDial does not directly specify configuration latches. Instead a CDial controls one or more other Dials i.e. CDials and or LDials and or IDials logically coupled to CDial in an n way Dial tree in which each lower level Dial forms at least a portion of a branch that ultimately terminates in leaves of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.

In the exemplary embodiment given in CDial receives at input an enumerated input value i.e. a string among a set of legal values including A . . . N . If CDial or an LDial or IDial is a top level Dial i.e. there are no Dials above it in a Dial tree CDial receives the enumerated input value directly from software e.g. simulation software or firmware . Alternatively if CDial forms part of a branch of a dial tree then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input CDial specifies a selected enumerated value or bit value for each connected Dial e.g. Dials and in mapping table . The values in mapping table associated with each output are interpreted by ECAD system in accordance with the type of lower level Dial coupled to the output . That is values specified for LDials and CDials are interpreted as enumerated values while values specified for IDials are interpreted as integer values. With these values each of Dials and ultimately specifies either directly or indirectly the values for one or more configuration latches .

With reference now to there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top level CDial that controls multiple lower level LDials. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of and contains the same configuration latches and associated signals as simulation model of .

As shown simulation model of includes a top level CDial associated with top level design entity . Simulation model further includes four LDials and . LDial which is associated with entity instantiation A0 controls the signal states of each signal sig1 which is determined by a respective configuration latch and the signal state of signal sig2 which is determined by configuration latch . LDial which is a replication of LDial associated with entity instantiation A1 similarly controls the signal states of each signal sig1 which is determined by a respective configuration latch and the signal state of signal sig2 which is determined by configuration latch . LDial which is associated with top level entity controls the signal state of signal sig4 which is determined by configuration latch . Finally LDial which is associated with entity instantiation FPU0 controls the signal state of signal sig3 which is determined by configuration latch . Each of these four LDials is controlled by CDial associated with top level entity .

As discussed above CDial and each of the four LDials depicted in can be instantiated within the associated design entity for example by embedding a configuration specification statement or a configuration file reference statement pointing to a configuration file containing a configuration specification statement within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in is given below 

By implementing a hierarchical Dial tree in this manner several advantages are realized. First the amount of software code that must be entered is reduced since the automatic replication of LDials within FXU entity instantiations and allows the code specifying LDials to be entered only once. Second the organizational boundaries of the design process are respected by allowing each designer or design team to specify the configuration of signals within the design entity for which he is responsible. Third coding of upper level Dials i.e. CDial is greatly simplified reducing the likelihood of errors. Thus for example the CDial and LDial collection specified immediately above performs the same function as the large LDial specified above with reference to but with much less complexity in any one Dial.

Many Dials for example LDials utilized to disable a particular design entity in the event an uncorrectable error is detected have a particular input value that the Dial should have in nearly all circumstances. For such Dials the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment a Default value is specified by including default value following the specification of a Dial and prior to the concluding semicolon. For example a default value for a CDial can be given as follows 

The configuration specification language of the present invention also permits control of the time at which particular default values are applied. Control of the application of defaults is important for example in simulating or executing in hardware the boot sequence for an integrated circuit. During the initial stages of the boot sequence the clock signals to different sections of the integrated circuit may be started at different times meaning that latches in different sections of the integrated circuit must be loaded at different times in accordance with the specified Dial default values.

In accordance with the present invention control of the timing of the application of default values is supported through the association of one or more phase identifiers IDs with a default value. Phase IDs are strings that label collections of Dials to which default values should be applied substantially concurrently. Multiple phase IDs may be associated with a particular Dial to promote flexibility. For example in different system configurations the boot sequence for a constituent integrated circuit may be different. Accordingly it may be necessary or desirable to apply a default value to a particular Dial during different phases depending upon the system configuration.

In one exemplary syntax one or more phase IDs e.g. phaseid0 and phaseid1 can optionally be specified in a comma delimited list enclosed by parenthesis and following a default declaration in a Dial declaration statement as follows 

The use of default values for Dials is subject to a number of rules. First a default value may be specified for any type of Dial including LDials IDials including those with split outputs and CDials. Default values are preferably not supported for Dial groups which are discussed below with respect to . Second if default values are specified for multiple Dials in a multiple level Dial tree only the highest level default value affecting each branch of the Dial tree is applied including that specified for the top level Dial and the remaining default values if any are ignored. Despite this rule it is nevertheless beneficial to specify default values for lower level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated as discussed above. In the event that the combination of default values specified for lower level Dials forming the branches of a Dial tree do not correspond to a legal output value set for a higher level Dial the compiler will flag an error. Third a default value is overridden when a Dial receives an input to actively set the Dial.

By specifying default values for Dials a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition as discussed further below use of default values assists in auditing which Dials have been actively set.

As described above every Dial has a one to one mapping between each of its input values and a unique output value of the Dial. In other words each input value has a unique output value different than the output value for any other input value. For CDials and LDials the mapping table must explicitly enumerate each legal input value and its associated mapping. The requirement that the input values must be explicitly enumerated in the mapping table limits the overall complexity of any given LDial or CDial. For example consider the case of an integrated circuit e.g. a memory controller containing 10 to 20 configuration registers each having between 5 and 20 legal values. In many cases these registers have mutual dependencies the value loaded in one register can affect the legal possibilities of one or more of the other registers. Ideally it would be convenient to specify values for all of the registers utilizing a Dial tree controlled by a single CDial. In this manner the configuration of all of the 10 to 20 registers could be controlled as a group.

Unfortunately given the assumptions set forth above the 10 to 20 registers collectively may have over 300 000 legal combinations of values. The specification of a CDial in such a case although theoretically possible is undesirable and practically infeasible. Moreover even if a looping construct could be employed to automate construction of the configuration specification statement of the CDial the configuration specification statement although informing simulation software which input values are legal would not inform users how to set a CDial of this size.

In recognition of the foregoing the configuration specification language of the present invention provides a Dial group construct. A Dial group is a collection of Dials among which the designer desires to create an association. The runtime APIs utilized to provide Dial input values observe this association by preventing the individual Dials within a Dial group from being set individually. In other words all Dials in a Dial group must be set at the same time so that individual Dials are not set independently without concern for the interactions between Dials. Because software enforces an observance of the grouping of the Dials forming a Dial group use of Dial groups also provides a mechanism by which a designer can warn the downstream user community that an unstated set of interdependencies exists between the Dials comprising the Dial group.

With reference now to there is illustrated a diagrammatic representation of a Dial group . A Dial group is defined by a group name e.g. GroupG and a Dial list listing one or more Dials or other Dial groups. Dial groups do not have any inputs or outputs. The Dials listed within Dial list which are all top level Dials may be LDials CDials and or IDials.

One motivation for implementing Dial groups hierarchically is to coordinate configuration of groups of Dials spanning organizational boundaries. For example consider a digital system in which 30 Dials logically belong in a Dial group and 10 of the Dials are contained within a first design entity that is the responsibility of a first designer and 20 of the Dials are contained within a second design entity that is the responsibility of a second designer. Without a hierarchical Dial group a single Dial group explicitly listing all 30 Dials in its Dial list would have to be specified at a higher level of the design hierarchy encompassing both of the first and second design entities. This implementation would be inconvenient in that the designer or design team responsible for the higher level design entity would have to know all of the related Dials in the lower level design entities and specifically identify each of the 30 Dials in the Dial list of the Dial group.

An alternative hierarchical approach would entail creating a first Dial group containing the 10 Dials within the first design entity a second Dial group containing the Dials within the second design entity and a third higher level Dial group that refers to the first and second Dial groups. Importantly the Dial list of the higher level Dial group must only refer to the two lower level Dial groups thus shielding designers responsible for higher levels of the design hierarchy from low level details. In addition code maintenance is reduced since changing which Dials belong to the two lower level Dial groups would not affect the Dial list of the upper level Dial group.

Dial groups are subject to a number of rules. First no Dial or Dial group may be listed in the Dial list of more than one Dial group. Second a Dial group must refer to at least one Dial or other Dial group in its Dial list . Third in its Dial list a Dial group can only refer to Dials or Dial groups within its scope which by convention and like the concept of scope as applied to Dials is that of its associated design entity i.e. the design entity itself and any lower level design entity within the design entity . Fourth each Dial referred to in a Dial list of a Dial group must be a top level Dial.

Referring now to there is depicted an exemplary simulation model illustrating the use of Dial groups. Exemplary simulation model includes a top level design entity having instantiation identifier TOP TOP . Within top level design entity two design entities and are instantiated which have entity names FBC and L2 respectively. FBC entity instantiation in turn instantiates a Dial instance having Dial name C a Z entity instantiation containing a Dial instance having Dial name B and two instantiations of entity X which are respectively named X0 and X1 . Each entity X instantiation contains two entity Y instantiations each further instantiating a Dial instance having Dial name A . L2 entity instantiation contains a Dial instance having Dial name D and two entity L instantiations each containing a Dial instance having Dial name E .

As shown FBC entity instantiation has an associated Dial group instance having a group name F . As indicated by arrows Dial group instance includes each of Dials instances and within FBC entity instantiation . L2 entity instantiation similarly has an associated Dial group instance that includes each of Dial instances and within L2 entity instantiation . Both of these Dial group instances in turn belong to a higher level Dial group instance having group name H which is associated with top level design entity .

Each Dial group instance is created for example by including within the HDL file of the associated design entity an appropriate configuration statement. For example exemplary syntax for configuration statements creating Dial groups F G and H are respectively given as follows 

In each configuration statement a Dial group is declared by the keyword GDial which is followed by string e.g. F representing the group name. Within the parenthesis following the group name the Dial list for the Dial group is specified. As indicated in the configuration statement for Dial group H the Dial list for a hierarchical Dial group specifies other Dial groups in the same manner as Dials. It should also be noted that the compact dial expression syntax discussed herein can be employed in specifying Dials or Dial groups in the Dial list as indicated in the configuration statements for Dial groups F and G .

With reference again to recall that an exemplary configuration specification statement for LDial includes a parenthetical signal enumeration of the form 

In order to reduce the amount of input required to input the signal or Dial enumeration sections of configuration specification statements and to reduce the burden of code maintenance as new signal and Dial instances are added to the digital design an ECAD system in accordance with at least some embodiments of the present invention also supports a compact expression syntax for the signal or Dial enumeration sections of configuration specification statements as described in of U.S. patent application Ser. No. 10 902 628. This syntax is referred to herein more specifically as compact signal expression when applied to the configuration specification statements of LDials and IDials and is referred to as compact Dial expression when referring to the configuration specification statements of CDials or Dial groups.

In the foregoing description functional signal s that are referenced by a configuration specification statement generally reside within the design entity with which the Dial is associated or within the associated design entity s descendent entity or entities. The practice of referring to signals within the associated design entity and or its descendants which is referred to herein as the scope of the associated design entity can further be enforced if desired during the model build process shown in . One rationale for enforcing a scope rule during the model build process is that if all signal references of configuration specification statements are confined to the scope of the associated design entity the signal s referenced will generally with some exceptions be present in the simulation model. If however references outside of the scope of the associated design entity are permitted at least some references may refer to signals or configuration entities that are not present within the given simulation model.

For example referring again to assume a designer of design entity FPU wants to create a Dial that references a signal within design entity FXU. If signal references are limited to the scope of the design entity associated with a Dial then the configuration specification statement defining the Dial must be contained within or otherwise referenced by or attached to the HDL file for TOP design entity i.e. a level of the design hierarchy that encloses all the necessary signals . However this requirement may be inconvenient because in many cases the owner controlling the content and functionality of a lower level design entity e.g. design entity FPU during the design process may not be the owner of the higher level design entities e.g. TOP . Further the requirement may necessitate the separation of configuration specification statements describing logically related Dials into different HDL files increasing the difficulty of managing the configuration code. Thus in at least some embodiments it is desirable to permit the configuration specification statements of a Dial or Dial group to reference signals or Dials outside of the scope of the Dial or Dial group.

One exemplary syntax that permits out of scope references to signals can be given with reference to the scope of design entity FPU as follows 

As noted above if out of scope references are permitted during the model build process there are some situations in which references to signal and configuration entity names cannot be resolved within the simulation model. For example in a simulation model including only design entity C any of the out of scope references will fail to find the referenced signals or configuration entities because for that simulation model the higher hierarchy levels simply do not exist. In a preferred embodiment identifying a referenced signal or configuration entity that cannot be resolved due to an out of scope reference is not flagged as an error but entails special handling as described further herein.

It should also be noted that in certain cases even in scope signal and configuration entity references may fail to resolve. For example VHDL supports definition of multiple alternative architectures for an entity and the use of a VHDL configuration to specify which of the multiple architectures is to be used for the entity. A VHDL configuration can also be used to replace one entity with another entity or OPEN an entity to leave it empty.

If a design entity is OPEN any reference to a signal supposed to be within the design entity will obviously fail to resolve. As above this situation is not considered an error and any configuration entity or entities that depends on an unresolved signal reference must be appropriately handled. If however a signal reference resolves for one or more architectures of a design entity and fails to resolve for at least one other architecture of the design entity it may be desirable to flag this situation as an error in at least some cases depending for example upon the designer s preference.

Again assuming the scope of design entity FXU0.B.C of an exemplary syntax for expressing that it is permissible for a reference to sig1 to fail to resolve without error is given as follows 

Referring now to there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files which include configuration specification statements and or configuration file reference statements and optionally one or more configuration specification reference files . HDL compiler processes HDL file s and configuration specification file s if any beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file s describing a complete simulation model. As HDL compiler processes each HDL file HDL compiler creates markers in the design intermediate files produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.

Thereafter the design intermediate files in memory are processed by a configuration compiler and model build tool to complete the model build process. Model build tool processes design intermediate files into a simulation executable model that when executed models the logical functions of the digital design which may represent for example a portion of an integrated circuit an entire integrated circuit or module or a digital system including multiple integrated circuits or modules. In this processing model build tool preferably generates an m way tree indicating the hierarchical relationships between the design entities comprising the simulation model.

Configuration compiler processes the configuration specification statements marked in design intermediate files and creates from those statements a configuration documentation file and a configuration database . Configuration documentation file lists in human readable format information describing the Dials associated with the simulation model. The information includes the Dials names their mapping tables the structure of Dial trees if any instance information etc. In addition as noted above configuration documentation file includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a bottom up fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design simulation laboratory hardware evaluation and commercial hardware implementation of the digital design.

Configuration database preferably contains the m way tree generated by model build tool that describes the hierarchical relationships of the design entities within simulation executable model as well as a number of data structures pertaining to Dials and other configuration entities. As described in detail below these data structures include without limitation Dial data structures describing Dial entities latch data structures and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design i.e. simulation executable model . In a preferred embodiment the configuration values can be specified in terms of either signal states or configuration latch values and the selection of which values are used is user selectable. Configuration database is accessed via Application Programming Interface API routines during simulation of the digital design utilizing simulation executable model and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment the APIs are designed so that only top level Dials i.e. LDials IDials or CDials without a CDial logically above them can be set and all Dial values can be read.

Now that basic types of Dials syntax for their specification and the application of Dial groups have been described a description of an exemplary implementation of configuration database and its use will be provided. To promote understanding of the manner in which particular Dial instantiations or multiple instantiations of a Dial can be accessed in configuration database a nomenclature for Dials within configuration database will be described.

The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity i.e. the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.

Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model e.g. due to replication use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly in a preferred embodiment the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an extended Dial identifier for each Dial within the simulation model.

As an aside it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example conventional VHDL entity naming constructs permit two design entities to share the same entity name entity name. However VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance the entity name is equivalent to the VHDL library name concatenated by a period . to the entity name as declared in the entity declaration. Thus pre pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.

In a preferred embodiment an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields an instantiation identifier field a design entity name and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period . as follows 

In the extended Dial identifier the design entity field contains the entity name of the design entity in which the Dial is instantiated and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers proceeding from the top level entity of the simulation model to the direct ancestor design entity of the given Dial instance with adjacent instance identifiers separated by periods . . Because no design entity can include two Dials of the same name the instantiation identifier is unique for each and every instance of a Dial within the model.

The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier each design entity is in effect given a unique namespace for the Dials associated with that design entity i.e. Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is due to the uniqueness of instantiation identifiers Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However such a naming scheme does not associate Dials with a given design entity. In practice it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.

As noted above use of extended Dial identifiers permits the unique identification of a particular instantiation of a Dial and permits the re use of design entities within any arbitrary model without risk of Dial name collisions. For example referring again to Dial A entity instantiations and can be respectively uniquely identified by the following extended Dial identifiers 

As described above the configuration specification language of the present invention advantageously permits the specification of the output values of LDials and IDials by reference to signal names e.g. sig1 . As noted above a key motivation for this feature is that designers tend to think in terms of configuring operative signals to particular signal states rather than configuring the associated configuration latches. In practice however a signal that a designer desires to configure to a particular state may not be directly connected to the output of an associated configuration latch. Instead a signal to be configured may be coupled to an associated configuration latch through one or more intermediate circuit elements such as buffers and inverters. Rather than burdening the designer with manually tracing back each configurable signal to an associated configuration latch and then determining an appropriate value for the configuration latch configuration compiler automatically traces back a specified signal to the first storage element i.e. configuration latch coupled to the signal and performs any necessary inversions of the designer specified signal state value to obtain the proper value to load into the configuration latch as described in U.S. patent application Ser. No. 10 902 628.

With an understanding of a preferred nomenclature of Dials reference is now made to which is a diagrammatic representation of an exemplary format for a configuration database created by configuration compiler . In this exemplary embodiment configuration database includes at least four different types of data structures Dial definition data structures DDDS Dial instance data structures DIDS latch data structures and top level pointer array . Configuration database may optionally include additional data structures such as Dial pointer array latch pointer array instance pointer array and other data structures depicted in dashed line illustration which may alternatively be constructed in volatile memory when configuration database is loaded as described further below. Generating these additional data structures only after configuration database is loaded into volatile memory advantageously promotes a more compact configuration database .

A respective Dial definition data structure DDDS is created within configuration database for each Dial or Dial group in the digital system. Preferably only one DDDS is created in configuration database regardless of the number of instantiations of the Dial or Dial group in the digital system. As discussed below information regarding particular instantiations of a Dial described in a DDDS is specified in separate DIDSs .

As shown each DDDS includes a type field denoting whether DDDS describes a Dial or Dial group and if a Dial the type of Dial. In one embodiment the value set for type field includes G for Dial group I for integer Dial IDial L for latch Dial LDial and C for control Dial CDial . DDDS further includes a name field which specifies the name of the Dial or Dial group described by DDDS . This field preferably contains the design entity name of the Dial or Dial group followed by a period . followed by the name of Dial or Dial group given in the configuration specification statement of the Dial or Dial group . The contents of name field correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.

DDDS also includes a mapping table that contains the mapping from the input of the given Dial to its output s if required. For LDials and CDials mapping table specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output mapping table is an empty data structure and is not used. In the case of an IDial with a split output mapping table specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields.

Finally DDDS may include an instance pointer array containing one or more instance pointers pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array facilitates access to multiple instances of a particular Dial or Dial group.

As further illustrated in configuration database contains a DIDS corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS contains a definition field containing a definition pointer pointing to the DDDS of the Dial for which the DIDS describes a particular instance. Definition pointer permits the Dial name Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.

DIDS further includes a parent field that in the case of an IDial CDial or LDial contains a parent pointer pointing to the DIDS of the higher level Dial instance if any having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group parent pointer points to the DIDS of the higher level Dial group if any that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS is a top level Dial and does not belong to any Dial group parent pointer in parent field is a NULL pointer. It should be noted that a Dial can be a top level Dial but still belong to a Dial group. In that case parent pointer is not NULL but rather points to the DIDS of the Dial group containing the top level Dial.

Thus parent fields of the DIDSs in configuration database collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described below the hierarchical information provided by parent fields advantageously enables a determination of the input value of any top level Dial given the configuration values of the configuration latches ultimately controlled by that top level Dial.

Instance name field of DIDS gives the fully qualified instance name of the Dial instance described by DIDS from the top level design entity of the digital design. For Dial instances associated with the top level entity instance name field preferably contains a NULL string.

DIDS may further include a default field a phase ID field and a instance set field . At compile time configuration compiler preferably initially inserts a default field into at least each DIDS for which the configuration specification statement for the associated Dial has a default specified. Default field stores the specified default value if no default value is specified default field is NULL or is omitted. Configuration compiler subsequently analyzes configuration database utilizing a recursive traversal and removes or set to NULL the default field of any Dial instance that has an ancestor Dial instance having a default. In this manner default values of Dial instances higher in the hierarchy override defaults specified for lower level Dial instances. For each remaining or non NULL default field configuration compiler inserts into the DIDS a phase ID field for storing one or more phase IDs if any associated with the default value. The phase ID s stored within phase ID field may be specified within a Dial definition statement within an HDL file or configuration specification file or may alternatively be supplied by direct manipulation of configuration database by a downstream user.

As indicated by dashed line notation an instance set field is preferably inserted within each DIDS in configuration database when configuration database is loaded into volatile memory. Instance set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set.

Finally DIDS includes an output pointer array containing pointers pointing to data structures describing the lower level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically in the case of IDials and LDials output pointers refer to latch data structures corresponding to the configuration latches coupled to the Dial instance. For non split IDials the configuration latch entity referred to by output pointer receives the high order bit of the integer input value and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial output pointers refer to other DIDSs corresponding to the Dial instances controlled by the CDial. For Dial groups output pointers refer to the top level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS . As discussed further below one or more output pointers may be NULL pointers if the configuration statement instantiating the instance represented by DIDS references a signal or configuration entity that is not present in the simulation.

Configuration database further includes a respective latch data structure for each configuration latch in simulation executable model to which an output of an LDial or IDial is logically coupled. Each latch data structure includes a parent field containing a parent pointer to the DIDS of the LDial or IDial directly controlling the corresponding configuration latch. In addition latch data structure includes a latch name field specifying the hierarchical latch name relative to the entity containing the Dial instantiation identified by parent pointer . For example if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name a.b.c.d.latch1 latch name field will contain the string d.latch1 . Prepending contents of an instance name field of the DIDS identified by parent pointer to the contents of a latch name field thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .

Still referring to as noted above configuration database includes top level pointer array and optionally Dial pointer array and latch pointer array . Top level pointer array contains top level pointers that for each top level Dial and each top level Dial group points to an associated DIDS for the top level entity instance. Dial pointer array includes Dial pointers pointing to each DDDS in configuration database to permit indirect access to particular Dial instances through Dial and or entity names. Finally latch pointer array includes latch pointers pointing to each latch data structure within configuration database to permit easy access to all configuration latches.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which instances of configuration entities such as Dials and Dial groups are connected to instances of signals or configuration entities within a simulation model of a design in the presence of reference s to one or more possibly unavailable signals or configuration entities. The illustrated process may be performed for example by configuration compiler during the model build process of for each configuration statement that instantiates a configuration entity and includes a reference to an instance of a signal or a configuration entity. In the following description the full expression syntax described above is assumed for simplicity.

The process of begins at block and then proceeds to block which illustrates configuration compiler determining while parsing a configuration statement in design intermediate files including a reference to a signal or a configuration entity whether a next term in the statement includes a character indicating that the reference to a signal or configuration entity name can fail to resolve without an error. If not the process proceeds directly to block . If so configuration compiler sets a REF flag to signify that a failure to resolve the signal or Dial reference should not be treated as error as shown at block and then proceeds to block . At block configuration compiler determines whether it has reached the final signal name or Dial name in the reference. If so the process proceeds through page connector D to block which is described below. If however configuration compiler determines that it has not reached the final signal or Dial name in the reference the process passes to block .

Block illustrates configuration compiler determining whether the portion of the signal or configuration entity reference under consideration contains a move up character e.g. a indicating a move upward in the design entity hierarchy. If not the process proceeds to block which is described below. If however the portion of the signal or configuration entity reference contains a move up character configuration compiler determines whether or not moving up one level in the design entity hierarchy would move beyond the top level of the design hierarchy defined by design intermediate files block . If so the process passes through page connector E to block of which is described below. If however configuration compiler makes a negative determination at block configuration compiler moves the current scope up one level in the design hierarchy block . The process then passes through page connector A to block which depicts configuration compiler moving to the next portion of the signal or configuration entity reference i.e. the portion following the next . . The process thereafter returns to block which has been described.

Referring now to block in response to a determination that the portion of the signal or configuration entity reference under consideration does not contain a move up character e.g. a configuration compiler determines whether or not the design entity referenced by the portion of the signal or configuration entity reference exists in the current simulation model. If not the process passes through page connector B to block of which is described below. If however configuration compiler determines at block that the referenced design entity exists in the simulation model configuration compiler determines at block whether the entity has been altered by an HDL configuration. If so configuration compiler sets an ALTER flag at block . From block or in response to a negative determination at block configuration compiler moves the current scope to the indicated design entity block . The process then passes through page connector A and processing continues at block and following blocks.

Referring now to block of if the referenced design entity does not exist in the current simulation model configuration compiler determines whether the ALTER flag has been set for the reference under consideration. If so the failure to resolve or bind to the referenced design entity does not necessarily represent an error condition and the process passes to block which is described below Otherwise configuration compiler flags the reference to the signal or Dial name as an error block and terminates processing of the statement at block .

Referring now to block of configuration compiler determines whether or not the signal or Dial name referenced by the statement exists within the current scope. If so configuration compiler logically binds the referenced instance of a signal or configuration entity to the Dial parameters in configuration database block . For example if the reference is a signal reference configuration compiler creates in configuration database a latch data structure for the configuration latch that sources the referenced signal and an output pointer in the appropriate DIDS pointing to the latch data structure . Thereafter processing of the statement by configuration compiler ends at block .

If however configuration compiler determines at block that the referenced signal or configuration entity instance does not bind i.e. is not present in the simulation model configuration compiler determines at block if the REF flag is set. If not an error condition has occurred and the process passes through page connector C to blocks and which have been described. If however configuration compiler determines that the REF flag is set meaning that a failure to bind is not an error for this reference the process passes to block . Block depicts configuration compiler indicating the failure to bind by setting a corresponding output pointer e.g. output pointer in output pointer array of the appropriate DIDS to a predetermined NULL value e.g. all ones or all zeros . Following block the process terminates at block .

Once a configuration database is constructed the contents of configuration database can be loaded into volatile memory such as system memory of data processing system of in order to appropriately configure a simulation model for simulation. In general data structures and can be loaded directly into system memory and may optionally be augmented with additional fields as described below. However as noted above if it is desirable for the non volatile image of configuration database to be compact it is helpful to generate additional data structures such as Dial pointer array latch pointer array and instance pointer arrays in the volatile configuration database image in system memory . A process for expanding configuration database within volatile memory is described for example in of U.S. patent application Ser. No. 10 902 628.

With the configuration database loaded into volatile memory a simulation model can be configured and utilized to simulate a digital design through the execution of simulation software. With reference to there is illustrated a block diagram depicting the contents of system memory during a simulation run of a simulation model. As shown system memory includes a simulation model which is a logical representation of the digital design to be simulated as well as software including configuration APIs a simulator and an RTX Run Time eXecutive .

Simulator loads simulation models such as simulation model into system memory . During a simulation run simulator resets clocks and evaluates simulation model via various APIs . In addition simulator reads values in simulation model utilizing GETFAC API and writes values to simulation model utilizing PUTFAC API . Although simulator is implemented in entirely in software it will be appreciated in what follows that the simulator can alternatively be implemented at least partially in hardware.

Configuration APIs comprise software typically written in a high level language such as C or C that support the configuration of simulation model . These APIs which are dynamically loaded by simulator as needed include a first API that loads configuration model from non volatile storage and expands it in the manner described above with reference to to provide a memory image of configuration database . Configuration APIs further include additional APIs to access and manipulate configuration database as described in detail below.

RTX controls simulation of simulation models such as simulation model . For example RTX loads test cases to apply to simulation model . In addition RTX delivers a set of API calls to configuration APIs and the APIs provided by simulator to initialize configure and simulate operation of simulation model . During and after simulation RTX also calls configuration APIs and the APIs provided by simulator to check for the correctness of simulation model by accessing various Dials configuration latches counters and other entities within simulation model .

RTX has two modes by which it accesses Dials instantiated within simulation model interactive mode and batch mode. In interactive mode RTX calls a first set of APIs to read from or write to one or more instances of a particular Dial within configuration database . The latch value s obtained by reference to configuration database take immediate effect in simulation model . In batch mode RTX calls a different second set of APIs to read or write instantiations of multiple Dials in configuration database and then make any changes to simulation model at the same time.

In either interactive or batch mode RTX must employ some syntax in its API calls to specify which Dial or Dial group instances within simulation model are to be accessed. Although a number of different syntaxes can be employed including conventional regular expressions employing wildcarding in an illustrative embodiment the syntax utilized to specify Dial or Dial group instances in API calls is similar to the compact expression hereinbefore described. A key difference between the compact expressions discussed above and the syntax utilized to specify Dial or Dial group instances in the RTX API calls is that in the illustrative embodiment Dial and Dial group instances are specified in the RTX API calls by reference to the top level design entity of simulation model rather than relative to the design entity in which the Dial or Dial group is specified.

In the illustrative embodiment each RTX API call targeting one or more Dial or Dial group instances in simulation model specifies the Dial or Dial group instances utilizing two parameters an instance qualifier and a dialname qualifier. To refer to only a single Dial or Dial group instantiation the instance qualifier takes the form a.b.c.d which is the hierarchical instantiation identifier of the design entity in which the single Dial or Dial group instantiation occurs. To refer to multiple Dial or Dial group instances the instance qualifier takes the form a.b.c. X which identifies all instantiations of entity X within the scope of entity instance a.b.c. In the degenerate form the instance qualifier may simply be X which identifies all instantiations of entity X anywhere within simulation model .

The dialname qualifier preferably takes the form Entity.dialname where Entity is the design entity in which the Dial or Dial group is instantiated and dialname is the name assigned to the Dial or Dial group in its configuration specification statement. If bracketed syntax is employed to specify the instance qualifier the Entity field can be dropped from the dialname qualifier since it will match the bracketed entity name.

Referring now to there is depicted a high level logical flowchart of an exemplary process by which configuration APIs locate particular Dial or Dial group instances in configuration database based upon an instance qualifier and dialname qualifier pair in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of an API call from RTX containing an instance qualifier and a dialname qualifier as discussed above. In response to the API call the configuration API enters configuration database at Dial pointer array as depicted at block and utilizes Dial pointers to locate a DDDS having a name field that exactly matches the specified dialname qualifier as illustrated at block .

Next at block the configuration API determines whether the instance qualifier employs bracketed syntax as described above. If so the process passes to block which is described below. However if the instance qualifier does not employ bracketed syntax the configuration API follows the instance pointers of the matching DDDS to locate the single DIDS having an instance name field that exactly matches the specified instance qualifier. As indicated at blocks if no match is found the process terminates with an error. However if a matching DIDS is located a temporary result pointer identifying the single matching DIDS is created at block . The process thereafter terminates at block .

Returning to block if bracketed syntax is employed the configuration API utilizes instance pointers of the matching DDDS to locate one or more DIDSs of Dial or Dial group instances within the scope specified by the prefix portion of the instance identifier preceding the bracketing. That is a DIDS is said to match if the instance name field of the DIDS contains the prefix portion of the instance qualifier. Again if no match is found the process passes through block and terminates with an error at block . However if one or more DIDSs match the instance qualifier temporary result pointers identifying the matching DIDSs are constructed at block . The process shown in thereafter terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial instances in interactive mode in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of a read Dial API call by RTX . As indicated at block a configuration API responds to the read Dial API call by locating within configuration database one or more DIDSs of Dial instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API determines by reference to type field of the DDDS associated with the DIDS identified by the current result pointer whether the DIDS corresponds to a Dial group. If so the process illustrated in terminates with an error condition at block indicating that RTX has utilized the wrong API call to read a Dial instance.

In response to a determination at block that the DIDS identified by the current result pointer does not correspond to a Dial group instance the process proceeds to block . Block depicts configuration API utilizing output pointers of the DIDS and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the Dial instance specified in the API call. Of course any NULL output pointers are simply skipped over when building the data set of latch names as NULL pointers do not ultimately bind to configuration latches in the simulation model. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

Configuration API then verifies the latch values obtained from simulation model by reference to configuration database as shown at block . In order to verify the latch values configuration API utilizes mapping tables to propagate the latch values up the Dial tree from the corresponding latch data structures through intermediate DIDSs if any until an input value for the requested Dial instance is determined. If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

It will be appreciated that in some cases the existence of one or more NULL pointers within output pointer array can leave the Dial input value corresponding to the latch values read from simulation model indeterminate in that the latch values correspond to a set of possible Dial input values rather than to a single Dial input value. In such cases it is preferable that the set of possible Dial input values is returned with a success indication at block .

As indicated by the process returning to block the above described process is repeated for each temporary result pointer returned by the process of . Once all result pointers have been processed the process passes from block to blocks which illustrate the configuration API returning the result data structure to RTX and then terminating.

RTX reads Dial instances in interactive mode utilizing the method of for example to initialize checkers that monitor portions of simulation model during simulation runs. The Dial settings of interest include not only those of top level Dial instances but also those of lower level Dial instances affiliated with the portions of the simulation model monitored by the checkers.

Referring now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial group instances in interactive mode in accordance with the present invention. As can be seen by comparison of the process of reading a Dial group instance is similar to the process of reading a Dial instance but returns the value of one or more top level Dial instances of possibly different Dial entities rather than one or more instances of the same Dial entity.

As shown the process shown in begins at block in response to receipt by a configuration API of a read Dial group API call by RTX . As indicated at block a configuration API responds to the read Dial group API call by locating within configuration database one or more DIDSs of Dial group instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API identifies and creates temporary pointers to all of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The top level Dial instances are identified by locating the highest level DIDS for each output pointer for which the type field in the associated DDDS specifies a type other than Dial group. In other words the configuration API may have to search down through one or more hierarchical Dial groups to locate the relevant top level Dial instances. In constructing the temporary pointers any NULL output pointers are skipped.

The process illustrated in then enters a loop beginning at block in which each of the top level Dial instances belonging to the Dial group corresponding to the Dial group DIDS referenced by the current result pointer is individually processed to obtain the value s of the top level Dial instance s . The process next proceeds to block which depicts configuration API utilizing output pointers of the DIDS of the first or next top level Dial instance and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the top level Dial instance. As noted above with reference to any NULL output pointers are simply skipped over when building the data set of latch names as NULL pointers do not ultimately bind to configuration latches in the simulation model. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

At block configuration API then verifies the latch values obtained from simulation model by reference to configuration database utilizing the same technique described above with reference to block of . If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

It will be appreciated that in some cases the existence of one or more NULL pointers within output pointer array can leave one or more top level Dial input values corresponding to the latch values read from simulation model indeterminate in that the latch values correspond to a set of possible top level Dial input values for at least one top level Dial instance rather than to a respective specific Dial input value for each top level Dial instance. In such cases it is preferable that the set of possible Dial input values for each affected top level Dial instance is returned with a success indication at block .

Following either block or block the process returns to block which represents a determination of whether or not all top level Dials belonging to the Dial group corresponding to the DIDS referenced by the current result pointer have been processed. If not the process returns to block which has been described. However if all top level Dials have been processed the process returns to block which illustrates a determination of whether or not all result pointers have been processed. If not the next result pointer is processed at block and following blocks which have been described. If however all result pointers have been processed the process passes to block which illustrates the configuration API returning the result data structure to RTX and then terminating.

Reading Dial and Dial group instances in a batch mode of RTX is preferably handled by configuration APIs in the same manner as interactive mode with one exception. Whereas in interactive mode latch values are always read from simulation model via calls to GETFAC API at blocks and in batch mode a latch value is preferably obtained from latch value field of a latch data structure in configuration database if latch set field indicates that the corresponding configuration latch has been set. If the configuration latch has not been set the latch value is obtained from simulation model by a call to GETFAC API . This difference ensures that Dial settings made in batch mode which may not yet have been reflected in simulation model are correctly reported.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which an RTX sets a Dial instance in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial API call from RTX . In response to the set Dial API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial instance s specified in the set Dial API call utilizing the technique described above with reference to as illustrated at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial instances. This determination can be made for example by examining the parent pointer of each such DIDS and that of any higher level DIDS linked by a parent pointer and the type fields of the associated DDDSs . The DIDS of a top level Dial instance will have either a NULL parent pointer or a non NULL parent pointer pointing to another DIDS that the type field of the associated DDDS indicates represents a Dial group. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial instance the process terminates at block with an error condition.

In response to a determination at block that all of the DIDSs referenced by the result pointers correspond to top level Dial instances a further determination is made at block whether or not the specified value to which the Dial instance s are to be set is one of the values specified in the mapping table of the associated DDDS . If not the process terminates with an error at block . However in response to a determination at block that the specified value to which the Dial instance s are to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set a respective Dial instance.

At block configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified in the set Dial API call down the Dial tree headed by the top level Dial instance associated with the DIDS referenced by the current result pointer. In order to propagate the desired Dial setting mapping table in the DDDS associated with the DIDS referenced by the current result pointer is first referenced if necessary i.e. for CDials and LDials to determine the output values for each of output pointers in the output pointer array of the DIDS referenced by the current result pointer. These output values are propagated down the Dial tree as the input values of the next lower level Dial instances if any corresponding to the DIDSs referenced by output pointers . This propagation continues until a latch value is determined for each configuration latch terminating the Dial tree which are represented in configuration database by latch data structures . NULL output pointers if any are simply skipped over as the output values are propagated down the Dial tree.

As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure . Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer. After all result pointers are processed the process terminates at block .

Referring now to there is depicted a high level logical flowchart of an illustrative process by which an RTX sets a Dial group in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial group API call from an RTX . In response to the set Dial group API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial group instance s specified in the set Dial group API call utilizing the technique described above with reference to as depicted at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial group instances. This determination can be made for example by examining the parent pointer of each such DIDS to ascertain whether the parent pointer is NULL. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial group i.e. has a non NULL parent pointer the process terminates at block with an error condition.

In response to a determination at block that each of the DIDSs referenced by the result pointers corresponds to a top level Dial group the process passes to blocks . Block illustrates configuration API locating all of the top level Dial instances within each Dial group for which the corresponding DIDS is referenced by a result pointer. Then as depicted at block the configuration API determines whether or not the specified value to which each top level Dial instance is to be set is one of the values specified in the mapping table of the corresponding DDDS . If not the process terminates with an error at block .

In the illustrated embodiment the prevalidation steps illustrated at blocks and are performed prior to setting any Dial instances because it is deemed preferable to implement setting a Dial group instance as an atomic operation that either successfully sets all relevant top level Dial instances or completely fails. In this manner a complex condition in which some top level Dial instances within the Dial group instance are set and others are not can be avoided.

In response to a determination at block that the specified value to which each top level Dial instance is to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set the top level Dial instance s belonging to each Dial group instance.

At block the configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified for each top level Dial in the set Dial group API call down the Dial trees of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The propagation of Dial settings down the Dial trees is performed in the same manner discussed above with reference to block of . As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure . Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer if any.

With reference now to there is illustrated a high level logical flowchart of an exemplary method of setting Dial and Dial group instances in batch mode in accordance with the present invention. As illustrated the process begins at block and thereafter proceeds to block which illustrates RTX initializing configuration database by calling a configuration API e.g. start batch in order to initialize configuration database . The start batch API routine initializes configuration database for example by setting each instance set field latch set field and set history field in configuration database to FALSE. By resetting all of the set fields in configuration database the Dials and configuration latches that are not set by the current batch mode call sequence can be easily detected as discussed below.

Following initialization of configuration database at block the process shown in proceeds to block . Block illustrates RTX optionally issuing one or more read Dial or read Dial group API calls to read one or more Dials or Dial groups as discussed above with respect to and optionally issuing one or more batch mode set Dial or set Dial group API calls to enter settings for Dial instances and their underlying configuration latches into configuration database . A configuration API responds to the set API calls in the same manner described above with respect to for setting Dial instances or for setting Dial group instances with two exceptions. First when any top level or lower level Dial instances are set whether as a result of a set Dial or set Dial group API call the instance set field of the corresponding DIDS is set to TRUE. Second no latch values are written to simulation model by the set API routines as illustrated at blocks and of . Instead the latch values are written into latch value fields of the latch data structure corresponding to each affected configuration latch and the latch set field is updated to TRUE. In this manner the Dial instances and configuration latches that are explicitly set by the API call can be readily identified during subsequent processing.

Following block the process passes to block which illustrates RTX calling an end batch API routine among configuration APIs to complete the present phase of default application. As indicated at block and as described in detail below with respect to the end batch API routine applies selected default values if any to specified Dial instances and propagates these default values to underlying configuration latches into configuration database . The latch values of all configuration latches set explicitly or with a default value are then potentially applied to latches within the simulation model. Finally preparation is made for a next phase if any.

If RTX has an additional phase of default application the process passes from block to block and then returns to block which represents RTX initiating a next phase of default application. If however all phases of default application have been processed the process illustrated in passes from block through block to block where the batch process terminates.

Referring now to there is depicted a high level logical flowchart of an exemplary embodiment of the end phase API routine called at block of . As shown the process begins at block when the end phase API routine is called by RTX for example with the following statement 

In this exemplary API call the phases parameter is a string specifying the phase ID s of defaults to be applied at the end of the current phase unnamed is a Boolean parameter indicating whether or not defaults values without any associated phase ID should be applied during the current phase apply is a Boolean valued parameter indicating whether or not configuration latch values should be immediately applied to simulation model and instance qualifier is one or more regular expressions that can be utilized to limit which instances of a particular Dial are processed to apply defaults.

By specifying an instance qualifier parameter for the end phase API routine a user can limit the application of defaults to only a portion of simulation model . The ability to restrict the application of defaults in this manner is particularly useful in cases in which two sections of the simulation model e.g. sections representing two different integrated circuit chips have different phasing requirements but use the same phase IDs. Thus collisions in phase IDs can be resolved by appropriate specification of the instance qualifier used in conjunction with the phase ID.

The end phase API routine then enters a processing loop including blocks in which DIDSs within configuration database are processed to apply appropriate Dial default values if any. Referring first to block the end phase API determines whether or not all top level pointers within top level pointer array have been processed. If so the process proceeds from block to block which is described below. If not all top level pointers within top level pointer array have been processed the process proceeds to block . Block represents the end phase API routine recursively scanning the DIDSs pointed to by a next top level pointer and its descendant DIDSs if any to apply the default values indicated by the parameters of the end phase API call. If the end phase API routine determines at block that it has processed all necessary DIDSs in the subtree of the top level DIDS identified by the current top level pointer then the process returns to block which has been described. If however at least one DIDS in the subtree of the top level DIDS identified by the current top level pointer remains to be processed the process passes from block to block .

Block illustrates the end phase API routine examining a next DIDS to determine whether or not its default field has a non NULL value. If the current DIDS does not contain a non NULL default field the process returns to block representing the end phase API routine continuing the recursive processing of DIDSs in the subtree of the top level DIDS pointed to by the current top level pointer . If the default field contains a non NULL value the process passes to block which depicts a determination of whether or not the instance set field is set that is whether the Dial instance was previously explicitly set at block of . If the instance set field is set the default value contained in default field is ignored since the simulation user has already explicitly specified a value for the associated Dial instance . And because simulation database is constructed so that any descendant of a DIDS having a specified default cannot have a default value the process passes to block which illustrates the end phase API routine skipping the processing of any DIDS in the subtree of the current DIDS . Thereafter the process returns to block which has been described.

Returning to block in response to a determination that the instance set field of the current DIDS is not set the process proceeds to block . Block illustrates end phase API interrogating phase ID field of the current DIDS to determine whether the default value stored in default field has one or more associated phase IDs. If not the process passes to block which is described below. In response to a determination at block that phase ID field stores at least one phase ID the end phase API next determines at block whether the phases parameter of the end phase API call specifies a phase ID that matches a phase ID contained within phase ID field . If no match is found the process passes from block to block which has been described. If on the other hand a phase ID specified in the phases parameter of the end phase API call matches a phase ID contained within the phase ID field of the current DIDS the end phase API next determines at block whether or not the Dial instance name contained in instance name field of the current DIDS matches the qualifying expression passed as the instance qualifier parameter of the end phase API call. Again in response to a negative determination at block the process passes to block which has been described. If on the other hand the Dial instance name contained within instance name field is qualified by the instance qualifier parameter the process proceeds to block which is described below.

Returning to block if the current DIDS does not have one or more phase IDs specified within phase ID field a further determination is made whether or not the unnamed parameter of the end phase API call has a value of TRUE to indicate the default values without any associated phase information should be applied during the current phase. If not the process passes from block to block which has been described. If on the other hand the end phase API determines at block that defaults without associated phase information should be applied during the current phase the process proceeds to block which has been described above.

Thus when the end phase API reaches block end phase API has by the determinations illustrated at and determined that the default specified for the Dial instance corresponding to the current DIDS should be applied in the current phase of batch mode execution. Accordingly at block the end phase API routine applies the default value specified in the default field to mapping table to generate one or more Dial output signal s which are then propagated down the Dial tree of the current DIDS in the manner hereinbefore described. Ultimately the latch value fields and latch set field of each of the underlying latch data structures within configuration database are set to values corresponding to the Dial default value. The process then proceeds from block to block which has been described.

Returning to block in response to a determination that the Dial trees of all of the DIDS pointed to by top level pointers have been processed to apply any appropriate default values in the manner described above the process next passes to block . Block depicts end phase API examining the apply parameter of the end phase API call to determine whether or not the configuration latch values within latch data structures should be applied to simulation model . The added degree of control represented by this determination is advantageous in that different sections of simulation model which may have colliding phase IDs can be independently configured within configuration database in different phases but the resulting configuration latch values can be applied to simulation model at the same time if desired. If the apply parameter has the value FALSE meaning that the configuration latch values are not to be applied to simulation model during the current phase the process passes directly to block .

If however configuration latch values are to be applied to simulation model during the current phase as indicated by an apply parameter value of TRUE the end phase API routine proceeds to block . At block the end phase API utilizes latch pointer array to examine each latch data structure in configuration database . For each latch data structure in which latch set field has the value TRUE the end batch API routine issues a call to PUTFAC API of simulator to update simulation model with the latch value contained in latch value field . In addition as shown at block the end phase API performs a logical OR operation between the value of latch set field and set history field storing the result within set history field . In this manner each set history field maintains an indication of whether or not the corresponding configuration latch has been set during any phase of the batch mode process.

Following block the end batch API proceeds to block which depicts the end batch API routine resetting all of Dial set fields in DIDS and all latch set fields in preparation of a next phase if any. Thereafter the end phase API routine terminates at block .

In summary the end phase API routine applies Dial default values to configuration database that match the limiting phase and instance qualifiers and then optionally applies the resulting configuration latch values to simulation model in accordance with the apply parameter. Finally the end phase API routine tracks which latch data structures have been set utilizing set history fields and resets various set fields to prepare for a next phase if any.

As has been described in at least one embodiment one or more hardware description language HDL files are utilized to describe a plurality of hierarchically arranged design entities defining a digital design to be simulated and a plurality of configuration entities not belonging to the digital design that logically control settings of a plurality of configuration latches in the digital design. The HDL file s are compiled to obtain a simulation executable model of the digital design and an associated configuration database. The compiling includes parsing a configuration statement that specifies an association between an instance of a configuration entity and a specified configuration latch determining whether or not the specified configuration latch is described in the HDL file s and if not creating an indication in the configuration database that the instance of the configuration latch had a specified association to a configuration latch to which it failed to bind.

While the invention has been particularly shown as described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration entities than those disclosed herein. In addition those skilled in the understand upon reference to the foregoing that any of a wide variety of rules may be applied to determine which configuration entities are presented meaning that the particular syntax and presentation rules described herein are merely exemplary and not exhaustive.

Furthermore although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Program code defining the functions of the present invention can be delivered to a data processing system via a variety of signal bearing or computer readable storage media as is known in the art. It should be understood therefore that such signal bearing or computer readable storage media when carrying or encoding program code that direct the functions of the present invention represent alternative embodiments of the present invention.

