---

title: Key-controlled object-based memory protection
abstract: A processing unit includes an authority check for controlling access by the processing unit to pages of memory according to whether a hardware protection key set currently loaded in an authority mask register allows access to the pages. In particular, each page of memory is assigned a page key number that indexes into the hardware protection key set. The currently loaded hardware protection key set specifies those page key numbers that are currently accessible to the processing unit for the execution context. Each hardware key within the hardware protection key set is associated with a particular data object or group of data objects. Thus, effectively, the currently loaded hardware protection key set identifies which data objects or groups of data objects are currently accessible. Software keys are assigned to data objects and dynamically mapped to hardware protection key sets, such that when a module is called, the software keys assigned to that module are mapped to the hardware protection key set to be loaded for controlling current access to memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07890727&OS=07890727&RS=07890727
owner: International Business Machines Corporation
number: 07890727
owner_city: Armonk
owner_country: US
publication_date: 20080324
---
This application is a continuation of commonly assigned U.S. patent application Ser. No. 10 916 981 now U.S. Pat. No. 7 424 584 filed Aug. 12 2004 which is hereby incorporated herein by reference.

The present invention relates in general to improved memory protection and in particular to improved object based memory protection. Still more particularly the present invention relates to providing key controlled object based memory protection where keys are assigned at a page level granularity to indicate page association with a data object and each module is allowed access to the pages assigned to at least one data object.

It is common for computer software to be programmed to use a flat address space within memory. In particular the flat address space may be implemented within a global address space that is shared among multiple software components. The global address space provides an easy programming mode and efficient memory access performance.

Within a computer system it is important that the components of an operating system and other program components are protected from one another s activities. In particular when a global address space is shared among multiple software components it is important to ensure that memory files and other objects can be operated on by only those components that have gained proper authorization from the operating system.

One reason that protection of memory and other objects is important is that there is a need to prevent mischievous intentional violation of memory and other objects. In addition protection of memory and other objects is important to protect against accidental memory overlays that degrade data.

One method of providing memory protection for a flat address space is by updating page table entries holding a memory address for each page of memory with a page protector specifying the access allowed to each page by a current module as that module is loaded for execution. Changing memory protection by changing page protectors in page table entries however is extremely time consuming. In particular the page protector for a single page may be stored in multiple locations such as a translation lookaside buffer cache and page table wherein changing the protection levels of memory requires changing the page protector value in multiple buffers and memory locations which is both time consuming and an inefficient manner of changing memory protection.

To avoid the time consuming nature of changing memory protection at the page table level some operating systems implement memory hierarchies for memory protection. In particular in a hierarchical memory scheme memory is arranged in a hierarchy such that each software component can be programmed to have access to a particular ring within the hierarchy and all rings surrounding the particular ring. A core component such as an operating system kernel may be programmed to be fully addressable with access to the core of the hierarchical rings access to all memory rings other components are programmed to have limited addressability to a particular ring or rings.

Within a hierarchical memory protection scheme memory protection can be adjusted by changing the memory included in a ring without requiring updates to the page table and buffers however existing software components are not organized to support hierarchical memory. Thus hierarchical memory schemes are limited because software modules must be restructured to fit into a hierarchical memory protection scheme. In addition organizing memory in a hierarchical fashion is limited because the way that memory must be grouped into protection levels does not necessarily correlate with object oriented software components.

Therefore in view of the foregoing there is a need for a method system and program for an efficient and inexpensive memory protection scheme that organizes and protects pages of memory allocated within a flat global address space. In particular there is a need for a method system and program to quickly change the protection level of a page of memory without requiring a change of a protection key in the page table and buffers.

The invention provides memory protection and in particular provides object based memory protection. The provides a system and program for key controlled object based memory protection where keys are assigned at a page level granularity to indicate page association with a data object and each module is allowed access to the pages assigned to at least one data object.

A processing unit includes an authority check. The authority check controls access by the processing unit to pages of memory according to whether a hardware protection key set currently loaded in an authority mask register allows access to the pages. In particular each page of memory is assigned a page key number that indexes into the hardware protection key set. The currently loaded hardware protection key set specifies those page key numbers that are currently accessible to the processing unit for the execution context. Each hardware key within the hardware protection key set is associated with a particular data object or group of data objects. Thus effectively the currently loaded hardware protection key set identifies which data objects or groups of data objects are currently accessible.

Software keys are assigned to a data object or group of data objects. Programmers specify the sets of software keys needed by each module. At initialization each software key assigned to a module is dynamically mapped to one from among multiple hardware protection keys. Then the set of software protection keys assigned to each module is mapped to a hardware protection key set for the module at initialization. When a processing unit enters a new module the hardware protection key set for the module is efficiently loaded into the authority mask register such that sets of keys for controlling memory protection are quickly changed. In particular modules are wrapped with a protection gate that controls loading the hardware protection key set when a new module is entered. In one example protection gate may store the hardware protection key set previously loaded for quick restoration of the authority mask register at an exit point.

In particular when a page request is received from the processing unit at the authority controller a translation look aside buffer is searched for the page request. If a page entry for the page request is located in the translation look aside buffer then the key number stored with the page entry is retrieved. Otherwise a page table is accessed to retrieve the key number for the page request. The key number is then compared with the hardware protection key set to determine if access to pages assigned to that key number is allowed. If the hardware protection key set allows the access the page protection bit is also checked to determine if access to the page is allowed.

In one embodiment the hardware protection key set is a bit vector indexed to the page key numbers. In addition the hardware protection key set may be indexed to the page key numbers for read requests and indexed to the page key numbers for write requests. A bit set at each of the indexed page key number locations specifies whether a particular type of access is allowed.

The key controlled object based memory protection method system and program allow for efficient adjustment of the data objects accessible to the currently loaded module by assigning page key numbers associated with data objects at a page level granularity and controlling access to those pages of memory assigned with page key numbers as specified by a hardware protection key set efficiently loaded in association with the currently loaded module. In particular it is important to note that modules are groups of instructions defined at a granularity such that software keys may be assigned to a module. Multiple groups of modules may be referred to as a software component. Components may include but are not limited to application programs kernel processes procedures services methods and other groups of modules that are executable on a processing unit.

Referring now to the drawings and in particular to there is depicted one embodiment of a system through which the present method system and program may be implemented. The present invention may be executed in a variety of systems including a variety of computing systems and electronic devices.

Computer system includes a bus or other communication device for communicating information within computer system and at least one processing device such as processor coupled to bus for processing information. Bus preferably includes low latency and higher latency paths that are connected by bridges and adapters and controlled within computer system by multiple bus controllers. When implemented as a server system computer system typically includes multiple processors designed to improve network servicing power.

Processor may be a general purpose processor such as IBM s PowerPC processor that during normal operation processes data under the control of operating system and application software accessible from a dynamic storage device such as random access memory RAM and a static storage device such as Read Only Memory ROM . The operating system preferably provides a graphical user interface GUI to the user. In one embodiment application or operating system software contains machine executable instructions that when executed on processor carry out the operations depicted in the flowcharts of and other operations described herein. Alternatively the steps of the present invention might be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

The present invention may be provided as a computer program product included on a machine readable medium having stored thereon the machine executable instructions used to program computer system to perform a process according to the present invention. The term machine readable medium as used herein includes any medium that participates in providing instructions to processor or other components of computer system for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Common forms of non volatile media include for example a floppy disk a flexible disk a hard disk magnetic tape or any other magnetic medium a compact disc ROM CD ROM or any other optical medium punch cards or any other physical medium with patterns of holes a programmable ROM PROM an erasable PROM EPROM electrically EPROM EEPROM a flash memory any other memory chip or cartridge or any other medium from which computer system can read and which is suitable for storing instructions. In the present embodiment an example of a non volatile medium is mass storage device which as depicted is an internal component of computer system but will be understood to also be provided by an external device. Volatile media include dynamic memory such as RAM . Transmission media include coaxial cables copper wire or fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio frequency or infrared data communications.

Moreover the present invention may be downloaded as a computer program product wherein the program instructions may be transferred from a remote computer such as a server to requesting computer system by way of data signals embodied in a carrier wave or other propagation medium via a network link e.g. a modem or network connection to a communications interface coupled to bus . Communications interface provides a two way data communications coupling to network link that may be connected for example to a local area network LAN wide area network WAN or directly to an Internet Service Provider ISP . In particular network link may provide wired and or wireless network communications to one or more networks.

Network link in turn provides data communication services through network . Network may refer to the worldwide collection of networks and gateways that use a particular protocol such as Transmission Control Protocol TCP and Internet Protocol IP to communicate with one another. Network link and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

When implemented as a server system computer system typically includes multiple communication interfaces accessible via multiple peripheral component interconnect PCI bus bridges connected to an input output controller. In this manner computer system allows connections to multiple network computers.

In addition computer system typically includes multiple peripheral components that facilitate communication. These peripheral components are connected to multiple controllers adapters and expansion slots coupled to one of the multiple levels of bus . For example an audio output device and audio input device are connectively enabled on bus for controlling audio outputs and inputs. A display device is also connectively enabled on bus for providing visual tactile or other graphical representation formats and a cursor control device is connectively enabled on bus for controlling the location of a pointer within display device . A keyboard is connectively enabled on bus as an interface for user inputs to computer system . In alternate embodiments of the present invention additional input and output peripheral components may be added.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. Furthermore those of ordinary skill in the art will appreciate that the depicted example is not meant to imply architectural limitations with respect to the present invention.

With reference now to a more detailed block diagram of the processing and memory components of a computer system which provide key controlled object based memory protection. As depicted computer system includes multiple central processing units CPUs such as a CPU for processing CPU programs and a main storage for storing programs and data. In particular main storage is organized into pages of memory where an address or frame number for each page s physical location in main storage is stored one of multiple page tables such as a page table . Main storage may include RAM caches and other available storage devices. In addition the address for each page of memory such as the page entry identified at reference numeral includes a physical page number a page key and a page protector PP bit . As will be further described page key is a multiple bit field that identifies a protection key with which the page is associated. PP bit can be set to define a page to be read write read only or no access for example.

CPU sends memory address access requests typically in the form of a logical or virtual address which may include a page number and page offset to a translation lookaside buffer TLB . In the example TLB and other components are depicted within a memory management unit outside CPU however it will be understood that memory management unit may be a component within CPU or an independent component. Further it will be understood that one method of memory management within a computer system is the use of TLB in conjunction with page tables and translation units however in alternate embodiments alternate memory management infrastructure may be implemented.

TLB stores page numbers and translated frame numbers for previously translated page numbers. In addition according to the present invention TLB stores the page key and may store the page protector bit for a page. If the page number in the requested logical address from CPU is located in TLB a TLB hit occurs and the frame number or physical address for the page number is accessed from TLB . If the page number in the requested logical address is not located in TLB then a TLB miss occurs and translator performs dynamic address translation. In particular translator accesses page tables and computes the physical address for the page. In addition the page key and PP for the page are retrieved and stored in TLB .

An authority check determines whether the execution context in which a request for access to memory is received is allowed access. For each memory access request the page key and PP for the requested page are accessed and passed from TLB to authority check . Then authority check determines whether to allow a current execution context to access a page of memory and what type of access to allow by comparing the page key with a hardware protection key set currently loaded into authority mask register AMR . In addition authority check determines whether the PP bit is set to allow the requested access. It is important to note that while authority check is depicted as a component of memory management unit the operation of authority check may be performed by CPU or may be performed by an independent controller. Further it is important to note that while authority check is depicted at the hardware level authority check may be performed within a software layer such as a software emulation of a CPU.

In the example AMR holds a bit vector where bit vector illustrates one structure of a hardware protection key set. In one embodiment the first half of the bits in bit vector specify the write authority mask and the second half of the bits in bit vector specify the read authority mask. Bits in each half of AMR are indexed by hardware key numbers. For example a 64 bit vector is designated by 32 hardware key numbers each mapped to both the write authority mask and the read authority mask. The bit settings of the read hardware key number and write hardware key number of bit vector are searched by a current page key to determine whether a program access is allowed. For example if the bits of a page key indicate page key 3 then the value in the position of the bit vector indexed to hardware key number 3 is retrieved depending on whether the request is for a read or write operation. If the value retrieved is a 0 for example then the request is allowed if also allowed by the PP bit setting but if the value retrieved is a 1 for example the request is not allowed regardless of the PP bit setting.

It is important to note that updates to the bit vector loaded in AMR are fast and that updates may be performed as control passes between modules. In particular software keys are assigned to data objects or specific regions of memory. Modules are assigned sets of software keys by programmers to designate the data objects that each module needs to access. At initialization the kernel maps each of the assigned software keys to one of the hardware keys. In the example each software key would be mapped to one of the 32 hardware keys. When the CPU switches modules a hardware protection key set mapped to from the software key set for the module is loaded into AMR . Advantageously by protecting memory according to the hardware protection key set currently loaded in AMR access to pages can be changed by efficiently changing the value of a bit vector rather than requiring time consuming adjustments to keys in page table and TLB . Further by protecting memory according to the settings of a hardware protection key set memory is not limited to hierarchical accesses but rather any module may be programmed to have access to any data object or set of data objects.

In addition it is important to note that in the example memory is defined to assign page keys at a page boundary or in other words at a page level of granularity. In other embodiments page keys may be assigned at other levels of granularity. Advantageously however by assigning page keys at a page level of granularity individual pages can be associated with a data object rather than associating groups of pages with a particular level of a memory hierarchy.

Referring now to there is depicted a block diagram illustrating the operating system view of data objects and modules organized for memory protection in accordance with the method system and program of the present invention. As depicted a kernel includes multiple modules that perform different functions. The kernel views each module in association with a private memory space viewed as a data object. In addition each module may access a shared memory designated in the example as global memory .

In the example a selection of the modules depicted includes the modules for a disk driver a virtual memory manager VMM and a file system . The associated private data objects depicted are a disk table a page table and a buffer cache . It will be understood that private data objects may also be shared across multiple components of the kernel. Further it will be understood that the private data objects are distributed within a flat addresses space.

Multiple software keys may be defined where each software key is assigned to describe a particular data object or memory region. Software keys may be statically defined for an operating system or may be dynamically allocated through an application programming interface API .

In the example a software key is assigned to describe each of the data objects. For example disk table is assigned software key disk key page table is assigned software key vmm key and buffer cache is assigned software key fs key . In addition global memory is assigned software key gkey . Table 1 illustrates examples of software keys mapped to memory regions accessible to kernel modules.

Programmers may assign a software key or set of software keys needed by each module. At initialization the operating system may gather the software keys assigned to modules and map each assigned software key to one of multiple hardware protection keys. In general there may be more software keys than hardware protection keys such that the operating system may assign a particular hardware key to multiple software keys that are associated with similar data objects. As a result each hardware protection key may be associated with a region of memory that includes multiple data objects mapped to multiple software keys. In addition the operating system may assign page keys to the pages of memory to identify the regions of memory associated with each hardware protection key at a page level granularity.

In one example Table 2 illustrates the software key to hardware protection key mapping that may be performed. In the example the disk key and the fs key are both mapped to hardware protection key 1 . Thus the operating system may mark the pages of memory corresponding to the disk table and the file system with a page key that indexes into hardware protection key 1 . It is important to note that while the example depicted describes modules of a kernel and the data objects accessed by modules of a kernel in alternate embodiments program application modules and the data objects associated with those program application data objects may implement the present invention of mapping software keys to hardware protection keys.

In addition at initialization the operating system may determine the hardware protection key set required by a module. In particular at initialization once the software keys are mapped to hardware protection keys the software key set for each module may be mapped to a hardware protection key set and stored in an initialization table. Table 3 illustrates one example of hardware protection key sets mapped to from the software key sets assigned to each module. In the example disk driver module is assigned the software key set including disk key and global key that map to hardware protection keys 1 and 3 respectively. Thus a hardware protection key set for disk driver module indicates the hardware protection keys allowed for the disk driver module are 1 and 3 . It will be understood that when loaded into the AMR the hardware protection key set will include a full bit vector with the positions indexed to hardware protection keys 1 and 3 set to allow access.

It is important to note that by implementing object based memory protection errors that occur in one module can be more easily detected and maintained within the object based memory region accessed by the module. For example in an operating system rather than mapping all the data objects used by the modules of the operating system into a single global address space where problems in one module can easily propagate throughout the global space each data object is protected at the page level from interference from errors in modules that do not have access to the pages of that data object.

With reference now to there is depicted an illustration of a protection gate for updating the authority masking register when a module call crosses module boundaries. As depicted when the load module shifts from calling file system to VMM a protection gate is invoked by VMM . Another protection gate is invoked by device driver for example when the load module shifts from calling VMM to device driver .

Protection gates are functions that include steps such as those described in and are managed by the called module. In particular all entry and exit points of a module are wrapped with protection gates such as protection gates and . Protection gates change the AMR value as modules are entered and exited by changing the hardware protection key set currently loaded in the AMR. In one example a protection gate may store AMR values when a processing units enters a new modules such that when the new module reaches an exit point the AMR stored on entry may be restored.

While protection gates are managed by the called module protection gate wrapping may be added by the operating system or by the programmer. In one embodiment the operating system may insert the protection gate code around the entry and exit points. In particular the protection gate code may be inserted either when the module is loaded or when the module is bound. In another embodiment the protection gate code may be included by the programmer of the module.

Referring now to there is depicted a high level logic flowchart of a process and program for controlling an authority check to determine whether access to a copy of a page is allowed. As depicted the process starts at block and thereafter proceeds to block . Block depicts looking up a virtual address in the TLB for a received page access request. Next block depicts a determination whether a virtual address is found. If a virtual address is found then the process passes to block . If a virtual address is not found then first the process passes to block . Block depicts reloading the virtual address from the page table and the process passes to block .

Block depicts selecting the page key and PP from the TLB for the virtual address. Next block depicts a determination whether the page key is allowed access in the AMR. If the page key is not allowed access in the AMR then the process passes to block . Block depicts returning an error and the process ends. Otherwise at block if the page key is allowed access in the AMR then the process passes to block . Block depicts a determination whether the PP bit allows access. If the PP bit does not allow access then the process passes to block . If the PP bit does allow access then the process passes to block . Block depicts allowing a reference to the page at the virtual address for the load or store access requested and the process ends.

With reference now to there is depicted a high level logic flowchart of a process and program for controlling memory protection initialization in accordance with the method system and program of the present invention. As depicted the process starts at block and thereafter proceeds to block . Block depicts mapping each software key to a hardware protection key. In particular if there are less software keys than hardware protection keys then each software key may map to a unique hardware protection key. However if there are more software keys than hardware protection keys multiple software keys may be mapped to the same hardware protection key where similar software keys may be mapped together to the same hardware protection key. Next block depicts marking the pages of memory in the page table with the page keys corresponding to the regions of memory effectively mapped to a hardware key. Thereafter block depicts mapping the hardware protection key set for each module from the software key set assigned to each module and the process ends. In particular the hardware protection key set associated with each module may be stored in an initialization table or added to the entry point of each module.

Referring now to there is depicted a high level logic flowchart of a process and program for controlling a protection gate in accordance with the method system and program of the present invention. As depicted the process starts at block and thereafter proceeds to block . Block depicts entering a module. Next block depicts storing the current AMR value. Then block depicts retrieving the hardware protection key set from the initialization table. Thereafter block depicts loading the new hardware protection key set value in the AMR and block depicts performing the load or store operations. Then block depicts restoring the AMR to the prior hardware protection key set and the process ends. It will be understood that in other embodiments protection gates may change the state of the AMR in alternate manners.

