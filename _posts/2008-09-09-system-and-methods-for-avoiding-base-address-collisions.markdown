---

title: System and methods for avoiding base address collisions
abstract: Processes are monitored as components are loaded into memory. Relocation of a component to an alternate base address instead of its preferred base address, causes an alternate component to be created corresponding to the relocated component. The alternate component is a copy of the relocated component, but the preferred base address of the alternate component is reset to be the alternate base address of the relocated component. Additional alternate components may be created for each relocated component, with each additional alternate component being optimized in a different manner. Alternate components may be implemented as alternate data stream of the corresponding relocated components. In response to subsequent requests to load a selected component into memory, it is determined whether the selected component has at least one corresponding alternate component. If so, one of the corresponding alternate components is loaded into memory instead of the selected component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694098&OS=07694098&RS=07694098
owner: RTO Software, Inc.
number: 07694098
owner_city: Alpharetta
owner_country: US
publication_date: 20080909
---
The present application is a continuation of co pending of U.S. patent application Ser. No. 11 376 705 entitled System and Methods for Avoiding Base Address Collisions and filed Mar. 15 2006 which is a continuation of U.S. patent application Ser. No. 10 719 781 entitled Systems and Methods for Avoiding Base Address Collisions Using Alternate Components and filed Nov. 21 2003 and which issued on Jun. 6 2006 as U.S. Pat. No. 7 058 775 which claims the benefit of U.S. Pat. No. 6 950 916 entitled Dynamically Setting the Optimal Base Addresses of Process Components all of which are entirely incorporated herein by reference.

The present invention relates generally to the elimination or reduction of base address collisions in computer software programs. More particularly the present invention relates to the use of alternate data streams for setting the optimal base address of process components in order to eliminate or reduce base address collisions.

A computer s operating system such as the Microsoft Windows operating system Windows may be configured to specify that each process have its own private virtual address space. By way of example Windows uses a technique known as memory mapping to load the components of a process such as the executable file and any associated dynamic link libraries from persistent storage e.g. disk or tape into memory e.g. random access memory RAM . In order to allow memory mapping to operate more efficiently each component of a process may be assigned what is known as a preferred base address within the memory. As is known in the art it is possible to set the preferred base address of a component at design time.

While many developers do set preferred base addresses at design time this process does not ensure that a component will always load at its preferred base address. For example an operating system may not be able to load a component of a process at its preferred base address if the operating system has already loaded some other process component at that address. If any component of the process cannot be loaded into memory at its preferred base address the operating system must perform additional logic to relocate that component to a different location in memory. The process of relocating a component consumes valuable time and memory resources.

Thus there remains a need for ensuring that components of a process load at their preferred base addresses. There further remains a need for optimally determining the correct preferred base addresses of a component prior to run time.

The present invention meets the needs described above by providing systems and methods for attempting to ensure that some or all components of a process load at their preferred base addresses. In one embodiment the present invention detects that a process has been loaded from persistent storage into memory. The present invention then determines if any of the original components of the process have been relocated by the operating system to an alternate base address instead of that original component s preferred base address. At least a first alternate component is created corresponding to each relocated original component.

Each first alternate component is a copy of its corresponding relocated original component but the preferred base address of each first alternate component is reset to be the alternate base address of its corresponding relocated original component. Optionally a second alternate component may also be created corresponding to each relocated original component. A second alternate component may be another duplicate of the selected original component with its preferred base address reset to the alternate base address and may also be bound to the alternate base address. Additional alternate components may be created for each relocated original component with each additional alternate component being optimized in a different manner. Alternate components may be implemented as alternate data stream of their corresponding relocated original components.

In response to a request to load a selected original component into memory a determination is made as to whether the selected original component has at least one corresponding alternate component. If so one of the corresponding alternate components is loaded into memory instead of the selected original component. Loading one of the corresponding alternate components into memory in response to the request may involve for example intercepting the request and modifying it to substitute therein an identifier of the first alternate component or an identifier of another alternate component for an identifier of the selected original component. The modified request may then be passed to a file system driver for processing.

These and other aspects features and advantages of the present invention may be more clearly understood and appreciated from a review of the following detailed description of the disclosed embodiments.

The present invention is directed to systems and methods for monitoring the initialization of a software process in order to determine if all of the components of the process load at their preferred base addresses. Should any component of the process load at a new base address as opposed to its preferred base address the on disk representation of that component may be updated to reflect the new base address. In other words the preferred base address of the component may be re set to the new base address. Thus the next time a request is made to open the component for execution it will load at the new base address and a base address collision should be avoided.

In certain alternative embodiments the original on disk representation of a process component may be left in tact and an alternate data stream may be created. The alternate data stream may be a duplicate of the component with its preferred base address set to the new base address. A base address collision should be avoided by loading the alternate data stream into memory at the new base address instead of the original on disk representation of the component at the original preferred base address in response to subsequent requests to open the component for execution. A file system filter driver or other software program module may be used to redirect such requests to the alternate data stream.

The following description will hereinafter refer to the drawing in which like numerals indicate like elements throughout the several figures. and the following discussion are intended to provide a brief and general description of a suitable computing environment for implementing the present invention. Although the system shown in represents a conventional personal computer system those skilled in the art will recognize that the invention also may be implemented using other types of computer system configurations. The computer system includes a processing unit a system memory and a system bus that couples the system memory to the processing unit . The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing basic routines that help to transfer information between elements within the personal computer system such as during start up is stored in ROM .

The personal computer system further includes a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading a CD ROM disk or to read from or write to other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage for the personal computer system . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD ROM disk it should be appreciated by those skilled in the art that other types of media that are readable by a computer system such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges and the like may also be used in the exemplary operating environment.

A number of program modules may be stored in the persistent storage devices e.g. hard disk drive and the memory e.g. RAM including an operating system one or more application program module and other program modules and . Program modules and may comprise components of the application program module . An application program module is also referred to generally as a process. The present invention may be implemented at least in part as a program module referred to herein as the Base Address Collision Monitoring Program Module comprising computer executable instructions for performing some or all of the methods described below with respect to and . Certain embodiments of the invention may also rely on a program module referred to herein as the Alternate Component Filter comprising computer executable instructions for performing the methods described below with respect to .

Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a game port or a universal serial bus USB . A display device is also connected to the system bus via an interface such as a video adapter . In addition to display device personal computer systems typically include other peripheral output devices not shown such as speakers or printers.

The personal computer system may operate in a networked environment using logical connections to one or more remote computer systems such as a remote computer system . The remote computer system may be a server a router a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer system although only a storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer system is connected to the LAN through a network interface . When used in a WAN networking environment the personal computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer system or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computer systems may be used. It will be further appreciated that the invention could equivalently be implemented on host or server computer systems other than personal computer systems and could equivalently be transmitted to the host computer system by means other than a CD ROM for example by way of the network connection interface .

At step a first component is selected from the list of components of the process . Then at step a determination is made as to whether the in memory base address of the selected component is equivalent to the on disk representation of its preferred base address. If the in memory base address of the selected component is equivalent to the on disk representation of its preferred base address the method advances to step for a determination as to whether the selected component is the last component in the list of process components. However if at step the in memory base address of the selected component is determined not to be equivalent to the on disk representation of its preferred base address i.e. the selected component has been relocated to a new in memory base address due to a conflicting component or other file having previously been loaded at the preferred base address of the selected component the name of the conflicting component is determined at step .

From step the method moves to step where the name of the conflicting component the relocated component s filename the new in memory base address of the relocated component and the original on disk representation of the relocated component s preferred base address are persisted written to a file referred to herein as a relocation file for further processing and for reporting purposes see and . Next at step a determination is made as to whether the selected component is the last component in the list of process components. If the selected component is not the last component in the list of process components the method returns to step for selection of the next component . The method is repeated from step to step as previously described until any selected component is determined to be the last component in the list of process components. When a selected component is determined at step to be the last component in the list of process components the method returns to step to await detection that another process has been loaded into memory .

The method of was described above by way of illustration only and is not intended to limit the scope of the present invention. Those skilled in the art will appreciate that there are a variety of methods to determine that the in memory base address of a component is different from the on disk representation of its preferred base address. By way of example the Rt1QueryProcessDebugInformation function returns a structure that enumerates all of the components of a process that have been relocated. Alternatively one could use the PSAPI functions to enumerate though each component of each process to determine its in memory base address for comparison against the on disk representation of its preferred base address.

For example while a component is loaded in memory it is possible to rename the on disk representation of the component make a copy of the renamed on disk representation of the component and then rename the copy back to the original filename of the component . This technique causes the in memory component and its associated on disk representation to be assigned a new filename while the original filename of the component is assigned to a new on disk representation of that component . The new on disk representation of the component should no longer have an associated in memory component meaning that the preferred base address of the new on disk representation can be modified. Subsequent calls by the operating system for the original filename of the component will cause the new on disk representation to be loaded into memory at the modified base address location.

Those skilled in the art will appreciate that other techniques may be employed to modify the preferred base address of an on disk representation of a component . By way of example a copy on reboot method may be employed. However such a method may not be desirable in some circumstances because it requires that the computer be restarted. As another option the process es to which the component belongs may be terminated so that the on disk representations can be modified.

Returning to if it determined at step that the selected relocated component is not still in memory the method can proceed directly to step . At step the on disk representation of the relocated component s preferred base address is changed to match the new in memory base address of that component as determined from the relocation file loaded at step . However if it is determined at step that the selected component is still in memory the method proceeds to step . At step the on disk representation of the selected component is renamed to a back up filename. Then at step a copy is made of the renamed on disk representation. Next at step the copy of the renamed on disk representation is renamed back to the original filename of the relocated component . At step a determination is made as to whether the original filename of the relocated component is still associated with an in memory component. If the original filename of the relocated component is still associated with an in memory component the renaming trick of steps is deemed to have failed and the selected relocated component is momentarily skipped as the method advances to step to determine if there are any other relocated components of the process .

However if it is determined at step that the original relocated component name is no longer associated with an in memory component the renaming trick of steps is deemed to have succeeded and the method proceeds to step where the preferred base address of the on disk representation having the original filename of the relocated component is changed to match the new in memory base address of that component as determined from the relocation file loaded at step . Those having ordinary skill in the art will know that the Microsoft Windows operating system provides the Application Programming Interface API call RebaseImage for the purpose of changing on disk representations of base addresses. Other operating systems may provide similar API calls. Also familiar to those having ordinary skill in the art will be the option to bind the selected relocated component to its updated on disk representation of its preferred base address. Windows provides the API call BindImageEx for the purpose of binding components to base addresses and other operating systems may provide similar API calls. At step the selected relocated component is bound to its new preferred base address if desired.

At step a report file is written out for auditing purposes. Then at step a determination is made as to whether the selected relocated component is the last relocated component of the process . If the selected relocated component is not the last relocated component of the process the method returns to step for selection of the next relocated component . The method is repeated from step to step as previously described until it is determined that any selected relocated component the last relocated component of the process . When a selected relocated component is determined at step to be the last relocated component of the process the method ends at step .

The optimization methods described above with respect to contemplate the dynamic modification of the preferred base addresses of process components so as to specify optimal base addresses at which no base address collisions should occur. In other embodiments the present invention provides similar base address optimizations without modifying the on disk representations of process components. In particular instead of changing the preferred base address of a particular component a duplicate of the component referred to herein as an alternate component A may be created and its preferred base address can be set to the optimal base address. In such embodiments requests to load the component into memory may be intercepted and processed in such a way as to call the alternate component A instead of the original component . The alternate component A may be loaded into memory at its preferred base address i.e. the optimal base address.

The Base Address Collision Monitoring program module or other program module s may be configured for creating alternate components A C A C. is a block diagram illustrating an exemplary method for creating alternate components A C A C in accordance with certain embodiments of the present invention. The exemplary method begins at starting block and proceeds to step where a relocation file created during the exemplary method of is retrieved from memory or from persistent storage. In addition to the method of other methods for creating relocation files will occur to those of skilled in the art. Again a relocation file includes relocation information for all components that were relocated to new in memory base addresses referred to hereinafter as alternate base addresses due to base address collisions.

Those skilled in the art will appreciate that not all of the relocation information collected according to the exemplary method of may be required for the creation of alternate components A C A C. At a minimum the relocation file should identify the filename of each relocated component and its alternate base address. Conversely the same relocation information and or other relocation information as described with respect to the method of may be desired for reporting analysis and or other purposes. Accordingly the same more or less relocation information as collected according to the method of may be included in a relocation file used in connection with this method and similar methods.

After the relocation file is retrieved the first relocated component listed therein is selected at step . Then at step a first alternate component A is created by creating a copy of the on disk representation of the relocated component and resetting the preferred base address of the copy to be the alternate base address of the relocated component . As described previously Windows provides the API call RebaseImage for the purpose of changing on disk representations of base addresses. Other operating systems may provide similar API calls. For convenience the on disk representation of the relocated component may be referred to herein as the original component. The alternate component A is assigned a filename that is distinct from the filename of the original component and is stored in persistent storage.

Preferably a logical naming convention or other file identification convention is used to distinguish the different types of alternate components A C A C. For example by convention a certain type of filename or other identifier may be used to identify each different alternate component type. Various suitable naming conventions will occur to those of ordinary skill in the art all of which are included within the scope of the present invention. In certain embodiments as will be described below the alternate component A may be physically or logically linked to the original component . Otherwise a look up table or other file may be maintained to record the association between and the persistent storage locations of the alternate component A and the original component .

In certain embodiments of the present invention only a single alternate component A may be created for each original component . However the exemplary method contemplates the creation of multiple alternate components A C per original component each alternate component A C offering different levels or types of optimization. Thus at step a second alternate component B is created comprising for example a duplicate of the original component having its preferred base address re set to the component s alternate base address and being bound to the alternate base address. As described previously Windows provides the API call BindImageEx for the purpose of binding components to base addresses. Other operating systems may provide similar API calls.

Next at step a third alternate component C is created. The third alternate component C may be for example a duplicate of the original component that is bound to the component s original preferred base address. The third alternate component may not have its preferred base address re set to the alternate base address of the original component because in some cases any base address collision may be resolved by relocating a different component or through other methods. This exemplary third alternate component C may also be used in embodiments where alternate components A C A C are created for every component of a process not only those that have been determined to result in a base address collision.

The second alternate component B and the third alternate component C were described above by way of example only. Those skilled in the art will appreciate that other types of optimizations may be used in the creation of alternate components A C and any number of alternate components may be created. Multiple alternate components A C provide differing levels and types of optimizations each of which may be useful in particular situations. As will be described in further detail below the use of multiple alternate components A C provides flexibility for performing optimizations on a component by component basis.

At step a determination is made as to whether the selected relocated component is the last relocated component listed in the relocation file. If the selected relocated component is not the last relocated component the method returns to step for selection of the next relocated component . The method is then repeated from step to step in the manner previously described until it is determined that any selected relocated component is the last relocated component listed in the relocation file. When a selected relocated component is determined at step to be the last relocated component the method ends at step .

The exemplary method described above for creating alternate components A C A C contemplates the existence of a relocation file that may be stored in memory or in persistent storage so that the alternate components A C A C may be created at a later time such as a time when the computer system is idle. In certain other embodiments however it may be desirable to create one or more alternate components A C A C on the fly each time an original component is involved in a base address collision. In such embodiments a relocation file may not be a prerequisite to creating alternate components A C A C. Accordingly the above described method is provided by way of example only and other methods for creating alternate components A C A C are considered to be within the scope of the present invention.

In certain embodiments the Alternate Component Filter is implemented as a file system filter driver . The concept of a file system filter driver is well known in the art. Generally a file system filter driver attaches to a file system driver and intercepts requests directed to the file system driver . A file system filter driver allows the addition of functionality beyond that provided by the file system driver . A file system filter driver might use the services of the file system driver or the services of other kernel mode drivers to provide the additional functionality. Those skilled in the art will understand how to design and implement a file system filter driver to accomplish the functions described herein and therefore no particular programming techniques related thereto are described herein.

The exemplary configuration shown in involves an operating system that describes file I O services by way of discrete packets called I O Request Packets IPR . As an example an IRP may describe file related services known as ReadFile and CreateFile. When a process requests that a particular file e.g. a process component be accessed from persistent storage the request is communicated to an I O Manager . The I O Manager invokes one or more file related services by creating an appropriate IRP. The I O Manager prepare the resulting IRP for delivery to the file system driver responsible for managing the particular file. In the example of there is only one file system driver but other configurations with multiple file system drivers and or multiple file system filter drivers are possible.

In the exemplary model of the operating system may use device objects to represent a device such as a persistent storage device . Those skilled in the art will appreciate that device objects serve as the target of all operations on the device. Devices are usually represented by multiple device objects one for each driver in the driver stack that handles I O requests for the device. The device objects for a device are organized into a device stack. Whenever an operation is performed on a device the system passes an IRP data structure to the driver for the top device object in the device stack. Each driver either handles the IRP or passes it to the driver that is associated with the next lower device object in the device stack.

Thus the I O Manager would typically pass an IRP to the file system driver by locating a device object of the file system driver . The file system filter driver however creates device objects that attach to i.e. sit on top of within the device stack the device objects of the file system driver . Thus in attempting to pass IRP to the driver that is associated with the next lower device object in the device stack the I O Manager will route IRP to the file system filter driver . The file system filter driver may be configured to receive and inspect all IRP directed to the file system driver .

The file system filter driver may be further configured to identify those IRP that request that an original component be opened for execution. Any IRP that do not request than an original component be opened for execution are passed on to the file system driver to be processed as normal. However those IRP that request that an original component be opened for execution are modified to substitute an identifier e.g. a filename or pointer of an alternate component A C A C for an identifier of the original component . The modified IRP is then passed to the file system driver for further processing. Any IRP received by the file system driver are eventually passed to the storage device driver which interacts with the persistent storage device to retrieve the component or other file identified in the IRP.

The file system filter driver may substitute identifiers of alternate components A C A C for identifier of original components based on associations stored in a look up table or by way of any other process that may occur to those of skill in the art. In certain embodiments the file system filter driver may be configured to substitute a default type of alternate component A A for an original component unless a particular exception occurs. By way of example alternate components A C A C may be classified by type with each type being optimized in a different way. A certain type of alternate component A A may then be designated as the default type to be loaded into memory when a corresponding original component is called. An exceptions table or other look up table may be maintained to list those situation when an alternate component B C B C other than the default alternate component A A is to be loaded into memory .

An exceptions table may specify a particular alternate component B B to be loaded into memory upon the occurrence of an exception. Alternatively multiple tiers of default alternate component types may be specified e.g. first default second default third default etc. and conditions may be set for determining which tier of default alternate component type should be loaded into memory. As mentioned above naming conventions or other file identification conventions may be used to distinguish the different types of alternate components A C A C.

Similar to the concept of an exception table an exclusion table may also be created. An exclusion table may specify certain components which are not to be optimized for some reason. By way of example in certain embodiments it may be desirable to optimize only system components but not any other components. There may be many other reasons why it might be preferable not to optimize one or more certain components. The Base Address Collision Monitoring program module or other program module may be configured to consult the exclusion table prior to creating alternate components.

An exceptions table and or an exclusions table could thus be used to turn off optimizations for some or all components as desired. In addition optimization methods of the present invention could be tuned off by disabling the file system filter driver disabling the file system filter driver would obviously result in all original components being loaded into memory as requested. The ability to turn off the optimizations of the present invention allows the state of the computer system to be returned to a pre optimization state which may be desirable for bug fixing or other problem solving activities.

Those skilled in the art will appreciate that additional functionality may need to be added to the file system filter driver or otherwise provided in order to maintain consistency between alternate components A C A C and original components . In particular when an original component is modified corresponding modifications must be made to any associated alternate components A C A C. Several methods for maintaining consistency between alternate components A C A C and original components will occur to those of skill on the art. For example any existing alternate components A C A C may be deleted when it is determined that an associated original component has been modified. When the alternate components A C A C are deleted new alternate components may be created by copying the modified original component and re setting the preferred base address of the copy to the previously determined optimal base address of the original component and or performing other previously mentioned optimizations. As another option the modified original component may be left without any corresponding alternate components for the time being and the optimization process described herein may be repeated from the beginning see for example to create one or more new alternate components when the original component is next loaded into memory .

The file system NTFS used by certain operating systems such as Windows NT Windows 2000 Windows XP and Windows 2003 includes native functionality known as alternate data stream. In certain embodiments alternate data streams may be particularly useful for implementing alternate components A C A C. Alternate data streams are hidden files that are linked to normal visible files referred to herein as original files . Alternate data streams are not limited in size and there can be more than one alternate data stream linked to an original file. An alternate data stream can include any type of data including executable code.

When an original file is created the data for that original file is written to an unnamed data stream associated with the filename of the original file. Other named data streams i.e. alternate data streams can be created behind the unnamed data stream. The file system is configured to maintain a record of attributes for each original file which may include pointers to each alternate data stream effectively linking that alternate data streams to the original file. Those skilled in the art will be familiar with the commands and techniques for creating alternate data streams representing alternate components A C A C.

Alternate data stream functionality thus provides a suitable mechanism for managing multiple related alternate components A C as a single unit. Through the use of alternate data stream functionality no additional logic needs to be provided for managing alternate components A C A C. A file system filter driver may be configured for substituting an identifier e.g. a filename of an alternate data stream representing an alternate component A C A C for an identifier of an original file representing an original component when desired. Alternate data streams are automatically deleted when the corresponding original file is modified. Thus there is no need to update alternate data streams representing alternate components A C A C when corresponding original components are modified. If an alternate data stream representing an alternate component A C A C is deleted the optimization process described herein is repeated from the beginning see and one or more new alternate components A C A C are created the next time the original component is loaded into memory .

However if the IRP is a request to open an original component for execution the method advances to step where a determination is made as to whether at least one alternate component A C exists corresponding to the original component . If no alternate component A C exists corresponding to the original component the IRP is passed unmodified to the file system driver or other appropriate portion of the file system at step . If an alternate component A C does exist corresponding to the original component the method proceeds to step where an exceptions table is examined to determine whether the original component is listed therein.

If the original component is not listed in the exceptions table the method moves to step where the IRP data structure is modified to substitute therein an identifier e.g. filename or pointer of a default alternate component A for the identifier of the original component . Again there may be multiple alternate components A C corresponding to the original component . Such multiple alternate components A C may be distinguished according to the type of optimization performed thereon. For example a first type of alternate component A may be optimized by re setting its preferred base address to its optimal base address a second type of alternate component B may be optimized by re setting its preferred base address to its optimal base address and binding the alternate component B to the optimal base address and a third type of alternate component C may be optimized by binding the alternate component C to its original preferred base address. One type of alternate component A may be designated as the default type to be loaded into memory unless an exception occurs. From step the method advances to step where the modified IRP is passed to the file system driver or other appropriate portion of the file system for processing. From step the method ends at step .

Returning to step if the original component is determined to be listed in the exceptions table the method moves to step where a determination is made as to whether the exception requires execution of the original component . If the exception requires execution of the original component the method proceeds to step where the IRP is passed unmodified to the file system driver or other appropriate portion of the file system. If the exception does not require execution of the original component the method advances to step where the IRP data structure is modified to substitute therein an identifier of the alternate component B specified by the exception for the identifier of the original component . As mentioned previously an exception may specify that a particular alternate component B or a particular type of alternate component B e.g. second default type or third default type etc. be substituted for the original component . From step the method advances to step where the modified IRP is passed to the file system driver or other appropriate portion of the file system for processing. From step the method ends at step .

Those skilled in the art will appreciate that the exemplary method described above represents but one method for substituting alternate components for original components in order to avoid base address collisions. The use of an exceptions table to identify only those situations in which a first default type of alternate component should not be substituted for an original component is believed to be an efficient method for handling such substitutions. However the use of an exceptions table is not required in other embodiments. Other methods for substituting alternate components for original components will occur to those of ordinary skill in the art and are therefore considered to be within the scope of the present invention.

It should be appreciated that the optimization techniques of the present invention may be implemented on stand alone computing devices and or in networked computing environments. For example in a client server environment the client device and or the server may execute the exemplary Base Address Collision Monitoring program module and or the exemplary Alternate Component Filter for optimizing process components to avoid base address collisions. As another example in a thin client or terminal server environment the optimization techniques of the present invention may be performed at the terminal server where processes are executed for the terminal devices. In fact any computing device which performs the function of loading process components from persistent storage into memory may benefit from the optimization techniques of the present invention.

A terminal server executes multi user server software that provides the ability to host multiple simultaneous client sessions. Thus a terminal server is capable of running many processes simultaneously for one or more terminals . The terminal server software is designed to share common components among as many processes as possible so as to reduce consumption of memory and processing resources. However each time any process is required to write to or otherwise modify a shared component a new copy of that component must be created so as not to disturb any other processes that are already running.

During execution a copy of a first process and its required components are loaded into memory i.e. physical memory at their preferred base addresses and are then mapped to corresponding virtual memory addresses in the virtual memory space allocated to the first process . Ideally the same copy of any components shared by a second process would be mapped from the same physical memory location to the corresponding virtual memory addresses in the virtual memory space allocated to the second process . However mapping a shared component to the virtual memory space of the second process may result in a base address collision if another component is already mapped to the desired virtual memory address.

In the terminal server environment a base address collision again results in a relocation of the component that is being mapped into virtual memory space. The relocation requires that the component be modified to specify its new relocated base address. As mentioned the need by one process to modify a component means that a separate copy of that component must be created and so modified so as to not disturb the other copy that is used by other processes . The more copies of a component that are created the more physical memory is consumed and the slower the terminal server performs. In addition the more processes executed simultaneously by a terminal server the more often base address collisions will occur.

Therefore the terminal server environment may achieve significant performance gains as a result of the optimization techniques of the present invention. In certain exemplary embodiments a terminal server may be configured to execute a Base Address Collision Monitoring program module for monitoring base address collisions and creating alternate components in response thereto. In such embodiments each terminal server also executes an Alternate Component Filter for filtering commands related to original components. As described above commands for loading a process component into memory for execution will be processed by the Alternate Component Filter in such a way as to load an alternate component instead. Alternate components may be optimized as previously explained to load at an optimal base address.

In the terminal server environment determination of the optimal base address for loading of an alternate component may be an iterative process. For example in certain embodiments the base address to which a component is relocated as a result of a base address collision may be chosen as an optimal base address for an alternate component . The optimal base address may reduce or eliminate base address collisions based on the current performance conditions of the terminal server . However as new processes are executed by the terminal server the alternate component may become involve in another base address collision when being mapped to a new virtual memory space. In such a case the optimization methods of the present invention would be performed again to determine a new optimal base address for the alternate component

In some embodiments the optimization method of the present invention may be performed continuously with respect to a particular alternate component in an attempt to find its true optimal base address. However in other embodiments the optimizations may be discontinued as long as a certain level of performance improvement is realized. In other words an alternate component may be given an new base address that is not its true optimal base address because some base address collisions will occur in certain situations. However if it is determined that the new base address of the alternate component will result in an acceptable or desired percentage reduction in base address collisions further base address optimizations may be deemed unnecessary.

As mentioned naming conventions may be used to manage multiple alternate components . In certain embodiments naming convention can include or be extended to include identifiers for each terminal device . In this way alternate components may be created to be specific to a given terminal . Thus different optimizations could be performed for different terminals . As a result more precise and relevant optimizations may be made on a terminal by terminal basis. The optimizations of the present invention could also be turned off with respect to one or more terminal by creating an appropriate exceptions table for the process components identified with that terminal.

Those skilled in the art will appreciate that the foregoing description of the invention was provided by way of example only and that many other modifications features embodiments and operating environments of the present invention are possible. It should also be appreciated that the exemplary aspects of the present invention as described above are not intended to be interpreted as required or essential elements of the invention unless explicitly stated otherwise. Accordingly the foregoing relates only to certain embodiments of the invention and numerous changes may be made thereto without departing from the spirit and scope of the invention as defined by the following claims.

