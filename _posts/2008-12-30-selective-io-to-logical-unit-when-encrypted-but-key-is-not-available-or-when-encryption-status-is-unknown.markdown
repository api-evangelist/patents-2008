---

title: Selective I/O to logical unit when encrypted, but key is not available or when encryption status is unknown
abstract: A method is provided for controlling I/O request access to an encrypted storage device when the encryption key for the encrypted storage device is not available. The method comprises the unordered steps of: providing an I/O filter driver in operable communication with an encrypted storage device, such that all I/O requests to the encrypted storage device are processed first through the I/O filter driver; receiving at the I/O filter driver an I/O request to the encrypted storage device; determining, for each I/O request, the type of the I/O request and, if the I/O request comprises a read, SCSI read, write, or SCSI write, determining a location on the storage device to which the I/O request is directed; determining, in a processor, whether a time period for obtaining the encryption key is still running; and, based on at least one of the I/O request type, whether the time period for obtaining the encryption key is still running, and, if applicable, the location on the device to which the I/O is requested, determining, in a processor, whether the I/O request to the encrypted storage device will be allowed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08166314&OS=08166314&RS=08166314
owner: EMC Corporation
number: 08166314
owner_city: Hopkinton
owner_country: US
publication_date: 20081230
---
Embodiments of the invention generally relate to devices systems and methods for data storage in computer systems. More particularly the invention relates to systems and methods to provide selective input and output to an encrypted logical unit when the encryption key is not available or when it is not known whether or not the logical unit is encrypted.

Organizations have many options for securing data at rest including authentication controls logical separation physical security and encryption of information. Although each option has advantages and disadvantages when extremely large amounts of data are involved encryption can provide the most workable solution. Encryption of data as is well known involves converting data to an unintelligible form called ciphertext which cannot be read unless a key is used to decrypt the data in some types of encryption the same key also is used to encrypt the data . Encryption also can be an important way to protect data at rest in other situations including the electronic and physical movement of data for backup data recovery and or maintenance. In addition encryption helps to limit exposure to security breaches so even if someone is able to access the storage media the data is still protected to prevent unauthorized access to sensitive information on the storage media.

The best place to implement encryption in a computer system especially a networked or enterprise computer system can vary depending on the use case and or the customer. For example in an enterprise level computer system encryption can be provided at the application level the host or operating system level within the network and or at the level where the physical device resides.

Encrypting at the application level allows for a significant amount of control over the encryption process because application users can dictate how to classify information who can access it and when. In addition application level encryption allows for granular specific information to be secured as it leaves the application. However encrypting at the application level has several disadvantages. For example one disadvantage of application based encryption is that it requires modification of the application which can be costly time consuming and difficult to implement especially if lots of legacy data that needs to be encrypted is involved.

Another disadvantage is that application based encryption does not take into account the impact of the encryption it provides on replicated data especially backed up or mirrored data data stored for disaster recovery purposes etc. . This makes some use cases of replication more difficult. For example data that is written by one application and encrypted cannot be used by another application without the first application also decrypting the data or providing a consistent encryption key management interface for applications to share data. Also for Disaster Recovery an application may have to be configured to use the same key s on both sites resulting in an extra management step

Network based encryption may be appropriate when network or storage level threats are a concern to the organization and network based encryption offloads the cost of encryption from the host. Here a network appliance can be used to present an unencrypted side and an encrypted side to the network. Network based encryption also presents challenges when coupled with storage based functionality such as replication. In particular network level encryption doesn t take into account its impact on replicated data. Any locally replicated information in storage e.g. a mirror or clone does not have visibility into the network device management and the keys and the network device does not have visibility into the replication process. Key management can become more complex and require more manual intervention as well as coordination between the security and storage domains which is time consuming and more expensive.

Encryption done where the physical device resides such as encryption on intelligent arrays includes encryption of storage media such as arrays disks or tapes which protects sensitive information residing on the storage media. Data written to the physical device is encrypted and stored as such and is decrypted when read from the device. Encryption done where the physical device resides is application and host independent and can be transport independent as well. This type of encryption can be advantageous when theft of the storage media is a concern. However because data is decrypted immediately off the storage media when accessed security breaches can occur throughout the network on the host and at the application. Keys can be acquired at the disk or tape level.

Organizations have sometimes been reluctant to deploy encryption of data at rest for various reasons. Some reasons include the complexity of managing many keys the need to add extra steps to existing processes for data storage which can be difficult and time consuming especially if existing management scripts for replication need to be modified the expense the time and for some implementations the need to add one or more appliances to a network. Other issues with deployment of encryption include management complexity the cost and complexity associated with deploying and managing multiple encryption technologies and key manager scalability across an enterprise many point solutions for encryption do not scale across application types or infrastructure elements and disruption to service levels installing encryption technologies and appliances may require a network outage and or reconfiguration .

Encrypting in the host below the applications or encrypting in the network or encrypting on the array is simpler to deploy than techniques such as application level encryption because applications don t have to be modified and the same encryption deployment can benefit multiple applications. Other advantages include that implementation can be immediate and non disruptive requiring no application or hardware modifications. Host based encryption involves encrypting information on host based systems and host based encryption can be used to encrypt data on the host before the data is sent to the storage systems. Host based encryption can be done in software using host processing resources and encryption keys stored in host memory. Alternatively the host can be configured to offload encryption to specialized hardware. For example a host bus adaptor HBA resident on the host can dedicate encryption to a particular transport connection from the host such as Fibre Channel.

With host based encryption encryption can be performed at the file level for all applications running on a host. In some instances implementations of host based encryption can be implemented to encrypt any data leaving the host as files blocks or objects. For example a host based implementation operating on a logical unit at the block level can be implemented by providing the encryption as part of an operating system OS independent input output I O filter system with I O filter driver such as is done with the EMC POWERPATH ENCRYPTION with RSA product available from EMC Corporation of Hopkinton Mass.

If the encryption is implemented using an OS independent I O filter system including an I O filter driver running on a host as is described for at least some embodiments herein the host based encryption can support multiple operating systems running on enterprise servers or across a domain. Another advantage is that this type of host based encryption can be storage and array independent for example to support legacy storage systems without requiring new hardware. Still another advantage is that host based encryption can support multiple applications and multiple arrays.

Some problems can occur with systems such as the aforementioned POWERPATH ENCRYPTION with RSA and other systems that use host based encryption such as systems that use or work with an I O filter driver within a host operating system to encrypt data on one or more logical units of storage . One problem that occurs happens in the situation where it is necessary to be able to read or write to an encrypted device where a data encryption key must be securely obtained every time the host restarts. For this situation however in some implementations key lookup at reboot requires certain libraries and code access that aren t available in early boot thus in the early stages of booting up a host the data encryption key DEK is not available. As will be described further herein at least some embodiments of the invention help to address this problem.

Note that the situation where a key is unavailable during early boot is not the only situation where at least some embodiments of the invention may be advantageous. Other situations include but are not limited to situations such as when a device is in an unknown state because device metadata cannot be read which can for example occur if a device is not turned on as well as situations where it is not possible to access the key server to get an encryption key e.g. for a new device .

One type of problem occurs when the encryption key is not available but access to at least a portion of the encrypted logical unit is required for other programs to run. For example some code may execute above the encryption I O filter driver such as a volume manager or cluster software and may try to access an encrypted device e.g. an encrypted logical unit LU before the DEK is available. Until the DEK is available I O to the encrypted logical unit must either be failed or pended. However failing or pending that I O while waiting for the key to be looked up can cause failures in certain higher layers of code. For example when all I O is failed or pended before the DEK is available higher software layers such as volume managers or cluster software can have failures or other malfunctions that can be unworkable enough to cause significant delays system hangs and potentially other system problems

One solution to this problem is to make key lookup happen much earlier during the host restart process but this solution is not always simple to implement in existing systems that incorporate encryption management code that was not originally designed to execute in early boot or from the kernel of an operating system.

In accordance with at least some embodiments of the invention described herein the inventors have discovered that certain types of I O requests directed to an encrypted device can be allowable I O requests even if the DEK is not available.

One example of types of I O requests that the inventors have discovered can be allowable includes I O requests e.g. from higher level processes that do not actually require access to encrypted data itself but instead involve performance of actions such as I O control functions opening or closing devices checking device status configuring devices etc. In addition the inventors have discovered that other types of I O requests from higher level processes may also be allowable such as get requests and reads to known fixed unencrypted regions of the device because such requests are non destructive to a given encrypted logical unit the meaning of non destructive is more fully explained further herein in connection with B and. .

Furthermore the inventors have discovered that certain types of I O requests e.g. set requests such as the Advanced Array Set AAS SCSI CDB Command Descriptor Block can be allowed to occur even if such requests have the potential for destructive action on the encrypted device. What happens with such an I O request is that a change caused by the I O request might create a condition that would lead to a device that currently cannot be used read written in encrypted regions to become usable because the change in the condition allows the encryption key which currently is not available for the device to be obtained. One change in the condition for example might be a transition from an UNKNOWN state to a known state e.g. one of NO KEY WAITING FOR KEY ENCRYPTED or UNCENCRYPTED each of which is explained further herein 

Thus in accordance with at least some embodiments of the invention the problem of having to pend I O to higher layers of code because a data encryption key is not available is solved by determining using the inventive processes described herein which requests and actions are allowable to an encrypted device without the DEK and failing or pending all other I O requests until the DEK is available. In one embodiment to enable allowance of some types of I O requests it has been found that the behavior of the encryption I O filter driver can be carefully orchestrated to allow such I Os that don t actually require the DEK i.e. don t require the encryption function to work while either failing or pending those I Os such as reads and writes to encrypted areas that require the data encryption key to execute.

Solving the problem of code that that needs to access an encrypted logical unit before the key is available by providing selective I O as described in the embodiments described herein provides several advantages. For example this solution allows better interoperability with volume managers cluster software and other such codes that execute above the block level I O encryption driver in the kernel or that execute in userspace.

As is explained further herein the embodiments of invention are not limited to use with systems providing an I O filter system with an I O filter driver as part of a host based implementation those of skill in the art will recognize that at least some of the embodiments of the invention described herein are applicable in many different environments including but not limited to environments where I O filtering is or can be used including but not limited to in a switch in a virtualization appliance in a network and in an intelligent array of storage. In addition at least some embodiments of the invention are applicable to any environment where access is required to an encrypted file and or an encrypted device but the encryption key is not yet available. Further at least some embodiments of the invention have applicability in an environment where access is required to a file and or device but it is not known whether or not the file or device is encrypted e.g. the state of the file and or device is unknown .

Advantageously at least some embodiments of the invention described herein simultaneously help to keep applications and processes operating at a level in the I O stack above the I O filter driver working correctly protect and keep correct encrypted data on an encrypted device and protect and keep correct metadata used to virtualize a logical unit LUN all of these goals being accomplished under at least either of the following conditions a it is not known whether or not a given device is encrypted or b it is known that the device is encrypted but the key is not available or not yet available .

In one aspect the invention provides a method of controlling I O request access to an encrypted storage device when the encryption key for the encrypted storage device is not available. The method comprises the unordered steps of providing an I O filter driver in operable communication with an encrypted storage device such that all I O requests to the encrypted storage device are processed first through the I O filter driver receiving at the I O filter driver an I O request to the encrypted storage device determining for each I O request the type of the I O request and if the I O request comprises a read SCSI read write or SCSI write determining a location on the storage device to which the I O request is directed determining in a processor whether a time period for obtaining the encryption key is still running and based on at least one of the I O request type whether the time period for obtaining the encryption key is still running and if applicable the location on the device to which the I O is requested determining in a processor whether the I O request to the encrypted storage device will be allowed.

In an embodiment of this aspect the method further comprises the unordered step of allowing the I O request to be processed if the I O request comprises at least one of an Open Close SCSI Reset SCSI Reset All or non destructive non SCSI IOCTL. In a further embodiment the method further comprises the unordered step of tracking the I O request if the I O request comprises a Device State Check wherein the Device State Check represents a check as to a state of the encrypted device and whether the state of the encrypted device has changed.

In at least some embodiments the state provides an indication as to whether or not a given device is encrypted and if a given device is encrypted whether the key is available or may become available or whether a device s state cannot be determined. In at least some embodiments the determination of whether the I O request to the storage device will be allowed is further based at least in part on whether allowing the I O request enables an entity that sent the I O request to avoid a malfunction in its operation. The entity can for example comprise a software component that executes above the I O filter driver in an I O stack that includes the entity the I O filter driver and the encrypted storage device where the encrypted storage device is below the I O filter driver in the I O stack.

In further embodiments the determination of whether the I O request to the storage device will be allowed is further based at least in part on whether allowing the I O request could allow access to encrypted information on the encrypted storage device without the key or change damage destroy or otherwise alter any portion of encrypted information stored on the encrypted storage device.

The encrypted storage device can in some embodiments further comprise at least a first location that is unencrypted and a second location that is encrypted. For example the encrypted storage device can further comprise a first unencrypted region the first unencrypted region having a location and size and storing therein unencrypted metadata relating to the encryption of the encrypted device and wherein the determination of whether the I O request to the encrypted storage device will be allowed is further based at least in part on whether allowing the I O request could damage destroy change provide access to or otherwise alter any portion of any one or more of the first unencrypted region the location of the first unencrypted region the size of the first unencrypted region the location of the first unencrypted region and the metadata stored in the first unencrypted region.

In another embodiment the method further comprises the unordered steps of a determining in a processor if the encrypted device is in a Startup Mode and the encryption key still is not available b allowing if the encrypted storage device is in the Startup Mode and the encryption key still is not available an Inquiry SCSI CDB request I O requests that comprise reads to unencrypted regions of the device I O requests that comprise SCSI CDB reads to unencrypted regions of the device and I O requests that comprise one of Open Close SCSI Reset and SCSI Reset All and c failing all other I O requests while the encrypted device is in a Startup Mode.

In a further embodiment if the time period for obtaining the encryption key has ended or has been cancelled and the encryption key still is not available the method further comprises the unordered steps of a determining in a processor if the I O request is directed to an encrypted location on the encrypted device b determining in a processor if the I O request comprises a read or SCSI CDB read to an unencrypted area on the encrypted device c determining in a processor if the encrypted device is in a Post Startup Mode d allowing if the encrypted storage device is in Post Startup Mode I O requests that comprise reads or SCSI CDB reads if the I O request is not directed to any encrypted locations on the encrypted storage device e allowing if the encrypted device is in Post Startup Mode I O requests that comprise non destructive SCSI CDBs and h failing if the encrypted device is in Post Startup Mode all other I O requests that are not one of d through e above or that do not comprise one of Open Close SCSI Reset and SCSI Reset All.

In a still further embodiment if a key lookup fails and the encryption key still is not available the method further comprises the unordered steps of a determining in a processor if the I O request is directed to an encrypted location on the encrypted device b determining in a processor if the I O request comprises a read or SCSI CDB read to an unencrypted area on the encrypted device c determining in a processor if the encrypted device is in a Post Startup mode d allowing if the encrypted storage device is in Post Startup Mode I O requests that comprise reads or SCSI CDB reads if the I O request is not directed to any encrypted locations on the encrypted storage device e allowing if the encrypted device is in Post Startup mode I O requests that comprise non destructive SCSI CDBs and h failing if the encrypted device is in Post Startup mode all other I O requests that are not one of d through e above or that do not comprise one of Open Close SCSI Reset and SCSI Reset All.

In yet another embodiment if the time period for obtaining the encryption key has not ended or has been cancelled and the encryption key still has not been retrieved the method further comprises the unordered steps of a determining in a processor whether the location on the device to which the I O request is directed includes any encrypted locations on the device b determining in a processor if the I O request comprises a read or SCSI CDB read to an unencrypted area c allowing I O requests that comprise reads or SCSI CDB reads if the I O request is not directed to any encrypted locations on the device d allowing I O requests determined to comprise non destructive IOCTLS non destructive non SCSI IOCTLs or non destructive SCSI CDBs and e pending all other I O requests that are not one of c or d above or that do not comprise one of Open Close SCSI Reset and SCSI Reset All.

In a further aspect the invention provides a method of controlling I O request access to a storage device when it is not known if the storage device is encrypted. The method comprising the unordered steps of providing an I O filter driver in operable communication with a storage device such that all I O requests to the storage device are processed first through the I O filter driver receiving at the I O filter driver an I O request to the storage device determining for each I O request the type of the I O request and if the I O request comprises a SCSI read determining a location on the storage device to which the I O request is directed and based on at least one of the I O request type and if applicable the location on the device to which the I O is requested determining in a processor whether the I O request to the storage device will be allowed.

The method can further comprise the unordered step of tracking the I O request if the I O request comprises a Device State Check wherein the device state check represents a check as to the state of the device and whether the state of the device has changed. In a further embodiment the state provides an indication as to whether or not a given device is encrypted and if a given device is encrypted whether the key is available or may become available or whether a device s state cannot be determined.

In still another embodiment the method can further comprise the unordered steps of a allowing the I O request to be processed if the I O request comprises at least one of an Open Close SCSI Reset SCSI Reset All or a non destructive non SCSI IOCTL b allowing the I O request if the I O request comprises a SCSI CDB read to a known unencrypted location on the device c allowing the I O requests if the I O request comprises a non destructive SCSI CDB d allowing the I O request if the I O request comprises a destructive SCSI CDB that is capable of enabling a determination as to whether or not the device is at least one of unencrypted and encrypted and e failing all I O requests that aren t one of a through d .

In still another aspect the invention provides a method of controlling I O request access to an encrypted storage device when the encryption key for the encrypted storage device is available the method comprising the unordered steps of providing an I O filter driver in operable communication with an encrypted storage device such that all I O requests to the encrypted storage device are processed first through the I O filter driver receiving at the I O filter driver an I O request to the encrypted storage device determining for each I O request the type of the I O request and if the I O request comprises a read SCSI read write or SCSI write determining a location on the storage device to which the I O request is directed and based on at least one of the I O request type and the location on the device to which the I O is requested determining in a processor whether the I O request to the encrypted storage device will be tracked.

In some embodiments wherein the determination of whether the I O request to the storage device will be tracked is further based at least in part on whether allowing the I O request could change or otherwise alter any portion of encrypted or unencrypted information stored on the encrypted storage device. In still further embodiments the determination of whether the I O request to the storage device will be tracked is further based at least in part on whether allowing the I O request could change or otherwise alter any portion of encrypted or unencrypted information stored on the encrypted storage device.

The above summary is intended to present a simplified summary in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention and is neither intended to identify key or critical elements of the invention nor to delineate the scope thereof. Rather the primary purpose of the summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

The drawings are not necessarily to scale emphasis instead generally being placed upon illustrating the principles of the invention. In the Figures like numbers denote like elements.

Before discussing the details of the invention a preliminary discussion is provided giving an overview of the type of computing environment in which at least some embodiments of the invention are realized followed by a brief overview of operation of one embodiment of the invention. The methods and apparatus of at least some embodiments of the invention may take the form at least partially of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives universal serial bus USB memory devices memory cards random access or read only memory or any other machine readable storage medium including a transmission medium. When the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. The methods and apparatus of the invention also may be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits. The program code software based logic for carrying out the method is embodied as part of the system described below.

Systems and methods in accordance with at least some embodiments of the invention can be implemented using any type of general purpose computer system including but not limited to a personal computer PC laptop computer client network appliance server workstation personal digital assistant PDA mobile communications device interconnected group of general purpose computers host computer systems enterprise computer system etc. running any one of a variety of operating systems. The general purpose computer system advantageously includes and or is capable of communicating with storage devices or systems including enterprise storage systems remote storage systems intelligent storage systems disaster recovery systems etc. that store data and or computer programs used by the general purpose computer system. An example of a system that includes a general purpose computer system and storage systems usable with at least one embodiment of the invention is shown in .

Referring now to the host computer also referred to herein as a general purpose computer includes a processor which can include one or more central processing unit CPU chips and one or more host bus adapters that each controls communication between the processor and one of the storage systems via a corresponding one of the communication buses . Each bus can be any of a number of different types of communication links with the host bus adapter and storage bus directors being adapted to communicate using an appropriate protocol via the communication buses coupled there between. For example each of the communication buses can be implemented as a SCSI bus with the directors and adapters each being a SCSI driver. Alternatively communication between the host computer and the storage systems can be performed over a Fibre Channel fabric. In still another alternative embodiment communication between the host computer and the storage systems can be performed in accordance with standards for the Internet Small Computer System Interface iSCSI or the Fibre Channel over Ethernet FCoE . Other implementations are of course possible.

In addition those of skill in the art who are familiar with such general purpose computer systems know that such systems can include elements not explicitly illustrated in such as random access memory RAM for storing programs and or data an input output I O controller a network interface a display device one or more input devices and optionally one or more removable storage devices including but not limited to a CD DVD drive unit a floppy disk drive unit a tape drive unit a PCMCIA or other card drive a USB based flash drive unit and the like and a data bus coupling these components to allow communication therebetween.

The CPU can be any type of microprocessor such as a PENTIUM processor made by Intel of Santa Clara Calif. The display device can be any type of display such as a liquid crystal display LCD cathode ray tube display CRT light emitting diode LED and the like capable of displaying in whole or in part any outputs generated in accordance with the systems and methods of the invention. The input device can be any type of device capable of providing the inputs described herein such as keyboards numeric keypads touch screens pointing devices switches styluses and light pens. The network interface can be any type of a device card adapter or connector that provides the computer system with network access to a computer or other device such as a printer a computer network a storage area network etc.

In at least some embodiments of the invention one or more computer programs such as applications and an operating system define the operational capabilities of the computer system . Operating systems usable with at least some embodiments of the invention include but are not limited to systems available from Sun Microsystems and running the Solaris operating system a version of Unix HP UX a Hewlett Packard operating system running a Hewlett Packard version of the Unix operating system available from Hewlett Packard Corporation AIX an IBM version of Unix available from IBM Corporation and or any other operating system such as LINUX WINDOWS VISTA WINDOWS XP or WINDOWS NT the latter three are available from Microsoft Corporation . These programs can be loaded into the computer system in many ways including but not limited to a hard disk drive a CD DVD drive and the network interface. Alternatively the programs can reside in a permanent memory portion e.g. a read only memory ROM chip of the main computer system memory. Further those of skill in the art will recognize that the computer system can include specially designed dedicated hard wired electronic circuits that perform all functions described herein without the need for instructions from computer programs.

The I O filter system includes an I O filter driver . The I O filter driver portion of the I O filter system facilitates the sending of I O requests from applications running on the computer system which can for example be a host to the data storage subsystem . For example in at least some embodiments the I O filter driver queues I O requests from the computer system directed to data storage subsystems note that data storage subsystem is illustrated further in as comprising a combination of primary storage systems and replica storage systems . In addition in some embodiments the I O filter driver implements algorithms to decide which I O requests to send how many I O requests to send and the speed at which to send I O requests. The I O filter driver in some embodiments keeps a record of I O requests that are sent to data storage subsystems until the I O request is processed by data storage subsystems . An exemplary host I O filter system that includes an I O filter driver is the POWERPATH ENCRYPTION WITH RSA software available from EMC Corp.

At least some embodiments of the systems methods and apparatuses of the invention described herein are intended for use in connection with storage area networks SANs that include data storage systems such as the SYMMETRIX Integrated Cache Disk Array System or the CLARIION Disk Array System available from EMC Corporation of Hopkinton Mass. as well those provided by vendors other than EMC Corporation especially SANs including arrays where replication takes place such as by using array or switch facilities.

The storage systems which can be logical units make storage resources available to the host computer for assignment to entities therein such as a file system a database manager not shown a logical volume manager an I O filter system with driver a block driver and an HBA driver . If the storage systems are so called dumb storage systems the storage resources that are made available to the host computer will correspond in a one to one relationship to physical storage devices within the storage systems. However when the storage systems are intelligent storage systems they will present logical units of storage to the host computer that need not necessarily correspond in a one to one relationship to any physical storage devices within the storage system. Instead the intelligent storage systems may map each logical unit of storage presented to the host across one or more physical storage devices.

One environment in which the storage systems of may be used is as part of an enterprise storage system. Enterprise storage systems store data in large scale environments and differ from consumer storage systems in both the size of the environment and the types of technologies that store and manage the data. SANs are commonly used in enterprise storage systems to transfer data between computer systems and storage devices. An exemplary SAN provides a communication infrastructure including physical connections between computer systems storage devices and a management layer which organizes the connections storage devices and computer systems.

In a SAN environment computer systems typically referred to as hosts connect to the SAN via one or more host bus adapters. The SAN itself may include thousands of different inter related logical and physical entities. In the case of a Fibre Channel SAN these entities which comprise the connections between hosts and storage devices may include Fibre Channel host bus adapters Fibre Channel switches Fibre Channel routers and the like. The entities may be physically connected through the use of twisted pair copper wire optical fiber or any other means of signal transmission.

As shown in storage devices may include multiple disk drives that combine to form a disk array. A typical disk array includes a disk array controller a cache disk enclosures and a power supply. Examples of disk arrays include the SYMMETRIX Integrated Cache Disk Array System and the CLARIION Disk Array System both available from EMC Corporation of Hopkinton Mass. Such a data storage device system and its implementation is fully described in U.S. Pat. No. 6 101 497 issued Aug. 8 2000 and also in U.S. Pat. No. 5 206 939 issued Apr. 27 1993 each of which is assigned to EMC the assignee of this invention and each of which is hereby incorporated by reference. Consequently the discussion herein makes only general references to the operation of such systems.

The disk array controller cooperates with the storage bus director which helps to provide storage services to computer systems that access the disk array. The disk array controller may attach to a number of disk drives that are located in the disk enclosures. For example the disk drives may be organized into RAID groups for efficient performance and data protection. RAID redundant array of inexpensive disks is a system that uses multiple disk drives that share or replicate data among the drives. Accordingly in a RAID system instead of identifying several different hard drives an operating system will identify all of the disk drives as if they are a single disk drive. The storage systems also include internal buses over which storage bus directors disk controllers and caches communicate

The storage bus director helps to couple the disk array controller to a SAN or directly to a host as is shown in via a port. A port serves as an interface between the disk array controller and other devices such as the hosts in the SAN. Each storage bus director typically includes two or more ports. A storage bus director may communicate with other devices using various protocols such as the SCSI Small Computer System Interface command protocol over a Fibre Channel link to the SAN. In the SCSI command protocol each device is assigned a unique numerical identifier which is referred to as a logical unit number LUN . Further communication using the SCSI protocol is said to occur between an initiator e.g. a host and a target e.g. a storage device via a path. For example a path may include a host bus adapter an associated SCSI bus or Fibre Channel cabling and a single port of a disk array controller. For example the aforementioned path management software e.g. EMC POWERPATH can be used to manage the paths used to communicate data in the SANs and among other things can detect load imbalances for disk array controllers in a SAN and can select alternate paths through which to route data.

Several definitions of terms referenced herein are now provided. A physical disk is formatted into a physical volume as presented by the storage device for use by management software such as Logical Volume Manager LVM software available from EMC . Each physical volume is split up into discrete chunks called physical partitions or physical extents. A logical volume consists of some number of physical partitions extents which can be treated as one large storage area. A logical volume may also be referred to as a logical unit LU . An identifier of a logical volume also called a logical volume identifier includes information specific to the logical volume it identifies. One example of a logical volume identifier is the Fibre Channel World Wide Names WWN of the logical volume. Another example of a logical volume identifier is information that was assigned by the array manufacturer and that is provided in response to a SCSI inquiry. Still another logical volume identifier is the world wide name WWN which also can be provided in response to a SCSI inquiry. Note also that as used herein a device is a generic term for any number or kind of logical unit especially used for storage.

In addition an I O request as used herein is a term that includes but is not limited to read requests write requests I O commands SCSI reads SCSI writes SCSI CDBs IO controls IOCTLs Device State Checks device opens device closes SCSI resets SCSI reset all and both destructive and non destructive IOCTLs. Non destructive is generally defined herein as any operation that gets data or state from a device or about a device. Conversely destructive is generally defined herein as anything that is not non destructive or anything that potentially can change device data or state. More definitions are provided as part of the legend for the table of which legend is in the table of each of these is described further herein.

In one embodiment the I O filter system is implemented to use pseudodevices to represent devices that it is managing. The pseudodevice is a logical representation of the device that assigns it a name chosen by the filter driver instead of the name assigned it by the operating system . Use of pseudodevices to represent devices that the I O filter system is managing is advantageous when the filter driver is transforming those devices in some way such as using a part of the device to write metadata.

As is understood in the art a pseudodevice is a special type of port located in the kernel of an operating system that acts like a device but does not correspond to any actual hardware and doesn t interface to a hardware device instead the pseudodevice interfaces to a managing device driver that maps it to one or more underlying hardware devices. Thus a host interacting with a pseudodevice treats the pseudodevice as sort of a forwarding mechanism through which a physical device can be reached such that the host treats a pseudodevice as if it were a physical I O device even though it is not. With some embodiments of the invention which can use multipathing the I O filter system of the invention a pseudodevice represents a single logical device as defined by I O filter system and the path set leading to it which can contain any number of physical paths. In at least some further embodiments of the invention a pseudodevice explained further herein is used to represent the eVLU which has a hidden private region of metadata that is only available to the filter driver . A pseudoname is the name used to identify the pseudodevice.

In at least one embodiment of the invention the computer system of is networked to other devices such as in a client server or peer to peer system. This is illustrated and described in greater detail in connection with herein which include example embodiments showing first and second computer systems A B networked to each other via a host interconnect network which can for example be a local area network LAN or a wide area network WAN as well as embodiments showing a host computer running a client application that communicates with a remote server application running at a remote host. The network could be an internet protocol IP network but many other types of networks are usable as will be appreciated by those of skill in the art. The computer system thus includes elements that can act as a client system a server system or a peer system and the entire computer system likewise can act as a client server or peer. It should be noted however that although the computer host can act as a server in a general sense the key manager server is a very specific and particular type of server as explained elsewhere herein and will not necessarily have the same behavior as when the host acts as a server.

As will be explained further herein the client can be any entity such as a the system host computer and or or specific components thereof e.g. terminal personal computer mainframe computer workstation hand held device electronic book personal digital assistant peripheral etc. or a software program e.g. an I O filter driver system program running on a computer directly or indirectly connected or connectable in any known or later developed manner to any type of computer network such as the Internet. A client may also be a notebook computer a handheld computing device e.g. a PDA an Internet appliance a switch a mobile communications device a telephone an electronic reader device and or any other such device capable of connecting to a computer network or a storage network.

Of course those skilled in the art will appreciate that computer systems embodying the invention need not include every one of the aforementioned elements and that equivalents to each of the elements are intended to be included within the spirit and scope of the invention.

A brief summary of the overall operations of one embodiment of the invention is now provided followed by detailed descriptions of the various aspects components and processes of embodiments of the invention.

In one aspect the invention provides an I O filter system that provides an information centric protection mechanism for data e.g. user data stored on logical units LUs . The I O filter system encrypts and decrypts all data although not necessarily operating system OS metadata or the I O filter system metadata on an encrypted virtualized logical unit eVLU where the virtualization is done by the I O filter system . Data on such an LU is encrypted and decrypted transparently by the I O filter system no application changes are required. This also means however that data on such an LU is encrypted and thus accessible only through I O filter system note that backup applications that run on plaintext data above the I O filter system are backing up plaintext and not ciphertext and thus such applications are accessible independent of the I O filter system 

A user is able to encrypt existing data by copying it from a plaintext LU to an eVLU using a data migration or data copying tool one example of such a tool usable with at least some embodiments of the invention is the POWERPATH MIGRATION ENABLER PPME product available from EMC Corporation of Hopkinton Mass. These features also enable protection of data on storage devices e.g. drives that are removed from arrays. Because metadata on the LU stores information in plaintext that can be used to obtain the key for the data on the LU given permission to obtain the key it is possible for replicas to be made of a logical unit where the replica keeps intact the encryption and also includes in the replica the information necessary to obtain a key for decryption.

In a further aspect of the invention to protect an entire drive s contents all the LUs that are using the physical drive are encrypted. However in another embodiment if it is desired to protect only some of the content on an LU e.g. to protect only the sensitive and or confidential data on an LU but not necessarily all data it may be sufficient for only those LUs that contain such data to be encrypted on a particular physical drive. The I O filter system described herein also is useful to prevent unauthorized access to a volume s content on a per host basis.

In one embodiment the I O filter system provides a command line interface CLI to perform various actions needed to manage the eVLU. For example the CLI allows an administrator to designate a particular LU to be encrypted which renders any previously existing user data on the LU inaccessible through the I O filter system . When an LU is designated to be encrypted it will be converted to an eVLU and a key will be provisioned for it and cached in the I O filter system kernel. At the same time a key identifier key id associated with that key is stored in the I O filter system s metadata region see on the LU. In some embodiments of the invention for example some embodiments that use the RSA Key Manager as the key manager the key id is a globally unique key id. In at least some other embodiments e.g. some embodiments that use a key manager other than the RSA Key Manager the key id is unique within a given domain but not necessarily globally unique. In still further embodiments the key id need not be unique

Once the key id is stored in metadata all writes to the eVLU are encrypted and all subsequent reads are decrypted. The device can then be put into service as a new LU or it can be used as the target e.g. of a PPME migration where the source is an LU with existing data. Note that when migrating from an existing LU for some of the embodiments of the invention the target may need to be slightly larger in order to accommodate the I O filter system metadata required for a virtualized LU.

When the I O filter system starts up after a host boot the I O filter system detects all encrypted virtualized LUs. Reads and writes to encrypted parts of the VLU will be disabled to these devices until the key is looked up and cached in the kernel. The I O filter system gets the key for each eVLU based on information stored in the I O filter system metadata which is in a private region of the LU.

Advantageously in the I O filter system data at rest encryption is built on top of VLUs to enable the I O filter system to detect and properly handle replicas such as replicas created by products such as EMC Symmetrix Remote Data Facility SRDF EMC MirrorView EMC Snapview EMC Timefinder as well as other mirroring disaster recovery and or replication products. An eVLU contains metadata that enables the I O filter system to identify the LU as virtualized and as encrypted. In the case of a replica the I O filter system metadata ensures that the key associated with the eVLU is the same as the key of the source eVLU for the replica.

As those of skill in the art will appreciate embodiments of the invention can greatly simplify making replicas of encrypted storage devices and managing the associated encryption keys. In prior art systems a manual operation is needed to associate each replica with the key that was provisioned for the primary device. Thus without the advantages provided in the embodiments of the present invention every time a device being used as a replica is re purposed another manual operation is required.

Having described the environment of the invention and provided a brief overview of one embodiment of the invention including its advantages for replication the details of at least some embodiments of the invention are now provided.

Note also that two separate protected perimeters can share selected elements i.e. have elements in common . Consider for example which is an illustration showing a second protected perimeter configuration in which two protected perimeters A B share both a key manager server and a set A that includes primary storage devices A and replica storage devices A. It should be understood that protected perimeters that share components are not required to share any or all of the shared components specifically shown in . The specifically illustrated shared components in are provided by way of illustration only and are not limiting. In other embodiments for example the storage interconnect could be the shared component. Generally however the host and I O filter system are not shared between protected perimeters .

A pair of protected perimeters also can be in communication over a network and arranged so that a first protected perimeter A serves as a primary protected perimeter and a second protected perimeter B serves as a replica of the primary protected perimeter A. Together the interconnected protected perimeters A B can form a third protected perimeter C. Consider for example which is an illustration showing a third protected perimeter configuration C that consists of first protected perimeter A and a second protected perimeter B connected via a remote network in which there is a key manager server for each of the primary and replica logical units in accordance with one embodiment of the invention. The embodiment and configuration of can be especially useful for disaster recovery applications. For example the configuration of can be used with replication for disaster recovery where the arrays of the storage devices A A A of protected perimeter A are replicated into the arrays of the storage devices B B B respectively of protected perimeter B and where the replica key manager server B is a replica of primary key manager server A In a disaster recovery application e.g. SRDF the replica key manager server B is a disaster recovery replica of primary key manager server A primary storage device B is a disaster recovery replica of primary storage device A and the primary portion of replica set B is a disaster recover replica of the primary portion of replica set A. Thus for disaster recovery all the primary storage of protected perimeter A is replicated in protected perimeter B. In some embodiments however local replicas within a protected perimeter e.g. the replica A of perimeter A has a remote replica in protected perimeter C as those of skill in the art will appreciate.

Referring now to each protected perimeter also illustrates some components used to implement at least one embodiment of the invention including a pair of host computers A B similar to the computer of each host computer A B having a respective I O filter system with encryption A B. The host computers A B in this embodiment are shown for illustrative purposes to be in operable communication with each other but it should be noted that the host computers A B being in operable communication is entirely optional so long as each host computer is in communication with the key manager server . The host computers A B communicate with the external key manager server via a host interconnect . In addition the host computers A B communicate via a storage interconnect with a plurality of primary storage devices replica storage devices and a set that includes both primary and replica storage devices.

A host computer that is initialized and configured with the I O filter system with encryption which can for example be provided as the EMC POWERPATH ENCRYPTION with RSA product are considered to be within the protected perimeter . As will be explained further herein using the I O filter system with encryption helps to ensure that if any storage devices within the protected perimeter are physically removed from the protected perimeter the data contained on the storage devices will be encrypted so as to maintain confidentiality.

The storage interconnect of can be any type of network capable of interconnecting storage devices with host computers. In some embodiments the storage devices and host computers are interconnected in a manner such that to the operating systems running on the host computers A B the storage devices appear as locally attached but this is not required for the invention. The storage interconnect provides communications between the various entities in the protected perimeter such as the host computers A B and storage devices . The storage interconnect may be a shared public or private network and encompasses a wide area or local area and can be implemented through any suitable combination of wired and or wireless communication networks. Furthermore the storage interconnect may include a local area network LAN a wide area network WAN an intranet or the Internet. For example in one embodiment the storage interconnect works with Fibre Channel connectivity and is implemented via a SAN. In another embodiment the storage interconnect works with internet protocol IP connectivity and is implemented via an Internet Small Computer System Interface iSCSI for Fibre Channel . Those of skill in the art will recognize that other implementations are of course possible.

The key manager server provides key manager functionality and the key manager server communicates and cooperates with a key manager client running at each host A B for simplicity the key manager client is not shown in but is illustrated in . The key manager server is in one embodiment a server appliance that includes all components required to be a key manager for the datacenter within the protected perimeter and which is capable of looking up a globally unique identifier. An illustrative example of a key manager server usable with at least some embodiments of the invention is the RSA KEY MANAGER appliance manufactured by EMC Corporation of Hopkinton Mass. however the invention is not of course limited to use of the RSA KEY MANAGER.

The key manager server in cooperation with the key manager client which operates remotely and in concert with the key manager server running at the host controls the generation protection storage replacement and elimination of encryption keys. In particular the key manager server creates encryption keys and also creates the key id an identifier that is associated with the encryption key and can be used to obtain the encryption key provided that all permissions and credentials are in place and is responsible for that association and for allowing lookup of an encryption key using the key id. Note that the key id in some embodiments e.g. those using the RSA KEY MANAGER is globally unique. In some embodiments the key id is unique within a domain. In other embodiments the key id might not necessarily be unique. Thus one role of the key manager server in is to securely create store and return keys to authorized entities such as the I O filter system with I O filter driver of e.g. such as EMC POWERPATH ENCRYPTION WITH RSA . It should be understood however that the key id could instead be created at the host . It is more advantageous to create the key id at the key manager server as this results in fewer process steps overall.

As will be explained in greater detail herein plaintext data e.g. data generated by an application running at the host transmitted from a host system to a storage device is encrypted using an encryption key provided by the key manager server . As will also be explained in greater detail herein the encrypted data is stored on an encrypted virtual logical unit eVLU B on one or more of the storage devices along with the key id which is later used to get an encryption decryption key from the key manager server . An eVLU B also known as a ciphertext logical unit is a logical unit with encryption turned on. Note that all eVLUs are also virtual LUs. is a first block diagram illustrating a first input output I O stack configuration illustrating the location of the I O filter driver of the I O filter system of relative to other components in the stack in accordance with one embodiment of the invention and is a block diagram illustrating a second input output I O stack configuration that includes a SCSI driver in the stack and illustrates the location of the I O filter driver of the I O filter system relative to other components in the stack in accordance with one embodiment of the invention also provides a schematic representation of a number of mapping layers that exist in exemplary embodiments of the computer system of as well as schematic illustrations of an eVLU B.

Referring to the I O stack configuration includes an application layer which includes application programs executing on the processor of the host computer . The application layer generally will refer to storage locations used thereby with a label or identifier such as a file name and will have no knowledge about where the file is physically stored on the storage system . Below the application layer is the file system layer followed by the logical volume manager LVM layer . The LVM layer presents a logical volume to the file system layer . The LVM layer maps that logical volume to what appears to be a physical volume to the LVM but which may be another logical construct presented by a layer lower in the stack. In the illustration of for example the LVM maps to the logical unit LU B also referred to herein as a virtual logical unit when the LU has been virtualized .

In the embodiments of the invention both the file system layer and the LVM layer are optional layers. An optional database manager layer also could be implemented in connection with the embodiments of the invention and the database manager layer would be outside the kernel at the same level or below the application layer . Of course one of skill in the art will recognize any particular application can make use of none some or all of the layers described herein and or illustrated in .

The virtual logical unit VLU A represents a device presented by the I O filter driver to the layers above it. In contrast an LU represents the VLU A as seen without virtualization. The VLU A as illustrated in is shown as containing plaintext data also referred to as clear text . A virtualized LU A represents what any entity above the I O filter driver gets when accessing the eVLU B that is the entity gets the plaintext version of the data the VLU A is a logical representation of the eVLU B as seen by entities above the I O filter driver . The plaintext data will be encrypted via the I O filter driver and written to the storage device represented by the eVLU B. The eVLU B is used in the same manner as any other logical unit that is the eVLU B can be used for raw access file systems can be mounted on it and it can be placed under control of the LVM . Encrypted Data on the eVLU B excepting the metadata which is unencrypted is returned as cipher text to any application or other entity user that accesses the data without going through the I O filter system . For example if a database is configured to read the native device corresponding to a device containing an eVLU B and the database does not go through the I O filter driver the database retrieves cipher text.

In the embodiments of the I O filter driver which is part of I O filter system not shown sits below the applications file system and LVM in the I O stack . Note that the invention does not require that the I O filter driver be implemented below the LVM or file system in the I O stack . In the particular embodiment illustrated in the OS includes an I O filter driver that sits above a SCSI device driver . For some embodiments of the invention that include the SCSI device driver the LU that happens to be an eVLU B is read by portions of the OS that live below the I O filter driver or execute before the I O filter driver is loaded such as the SCSI device driver . As explained further herein in connection with certain embodiment of the invention if the eVLU B can be read by portions of the OS that live below the I O filter driver or execute before the I O filter driver is loaded then the I O filter driver stores information indicating the portions of the eVLU B that can be read by those portions of the OS so that the portions read by the OS can be left unencrypted. The information can be stored for example in the metadata of the eVLU B but that location is not limiting. Those of skill in the art will appreciate that information designating unencrypted regions can be stored in many different structures in other embodiments e.g. tables the actual code itself etc.

In general in accordance with one embodiment of the invention the I O filter driver can be situated above or below any component in the I O stack except that preferably the I O filter driver is not situated below the HBA driver . The I O filter system in which the I O filter driver resides includes functionality to act as an encryption manager in the I O stack . As described previously the I O filter system in one embodiment is the EMC POWERPATH ENCRYPTION with RSA system.

The I O filter driver creates a virtualized LUN designating some space in the LUN to store its metadata and the key id in that metadata space. For example a given storage device is virtualized into a Virtual Logic Unit VLU A and at least one metadata storage space is allocated in the physical space of the device where the key id is stored in the metadata storage space so as to indicate that the LU is encrypted i.e. the LU becomes an eVLU B see . For example a primary eVLU can be replicated to a replica eVLU where the replica eVLU contains the same key id as the primary eVLU indicating that the replica eVLU is encrypted with the same key as the primary eVLU . described further below provide more details about the components of the I O filter system itself.

Referring again to anything executing above the I O filter driver e.g. user applications databases file systems logical volume managers etc. but that is using the I O filter driver sees data stored on the LU as plaintext and cannot see the metadata region on the underlying logical unit. That is an application or other component executing above the I O filter driver sees only a virtualized LUN minus the metadata the metadata is invisible to the component above the I O filter driver . 

In at least some embodiments of the invention the virtualizing of the LUN is more of a host based virtualization than a switch based or array based virtualization. With at least some embodiments of the invention the virtualization of the LUN is a generalized facility added to the I O filter system that allows for storing metadata or properties on a device for any reason. The Xcrypt Manager extension described further below in connection with uses this abstraction layer to store the key id information for an encrypted device. The presence of the key metadata or key property on a device indicates the device is encrypted and should be treated by the Xcrypt Manager as such. It should be understood however that the actual encryption key is not stored in the metadata as this would violate security requirements. Rather as explained herein what is stored in the metadata is information about the key that allows lookup of the key from the Key Manager server assuming the requester is allowed access to that key.

With the eVLU B and metadata herein the metadata is created during virtualization where the virtualization driver I O filter driver which can be accomplished using many techniques known to those of skill in the art ensures that code running above the I O filter driver can see only the virtualized logical unit portion of the eVLU B without ever knowing that the metadata is there. In one embodiment this virtualization is accomplished using size spoofing of the LU where the size spoofing involves showing the code running above the I O filter driver that the size of the device e.g. LU is the size minus the size of the metadata area which has the effect that no entity other than the I O filter system and I O filter driver is able to access the metadata region .

In a still further embodiment areas of the LU that need to remain unencrypted such as the metadata and OS specific areas can be put into a partition not used for data and or put in some other area of the storage device and protected from unwanted access by the I O filter driver .

The metadata itself is not encrypted. Note also that the metadata can in at least some embodiments be used to implement functions such as mirroring and or partitioning in addition to providing a location on the eVLU B for storage of the key id. In certain embodiments the metadata stores information about regions of the eVLU B that are to be left as plaintext. In addition note that although only a single metadata region is illustrated in in some implementations there can be more than one metadata region .

Referring again to the eVLU B includes a logical unit portion which stores the encrypted data as well as a metadata portion which stores metadata which itself is unencrypted . In at least one embodiment of the invention the logical unit portion includes at least a section A that stores unencrypted data and a section B that stores encrypted data and the I O filter system keeps track of these sections. The order of the sections shown is not limiting that is the first section need not be the one that stores unencrypted data it could for example store encrypted data . The sections storing encrypted and unencrypted data can be anywhere in the eVLU B and there can be more than one section of each type.

In one embodiment described further herein the metadata portion includes information about which regions in the logical unit portion are designated plaintext unencrypted regions. The metadata provides enough identification information but not the actual encryption key itself to enable a host miming the I O filter system and in communication with the eVLU B to get the actual encryption key from the key manager server as is described further in connection with and A B.

Providing a key id in metadata where the key id is presented to a key manager server to get a key provides advantages especially for replication that would not be available with other arrangements. Consider for example an alternate arrangement where instead of a key manager server storing a database that associates a key id with a key as is done with the present invention the key manager server instead stored a database associating a given key with the unique identifier associated with a source LUN itself e.g. a device id . On the one hand because every LUN has its own unique device id such an arrangement would provide a way to get an encryption key for a given LUN from a key manager server based only on the device id of a given LUN and furthermore this alternative arrangement would not even require an area of metadata on a LUN. However this alternate arrangement might not be as optimal for situations where replicas are made of a LUN because the replica being a different device would have its own device id and the replica device id that would not be the same as the device id of the source from which it was replicated.

Thus if a source LUN in this alternately considered arrangement were encrypted with a given key stored at a key manager server and the key manager server stored info linking just the source LUN device id with the encryption key a replica LUN made of the source LUN would not be able to access the appropriate encryption key at the key manager server because the replica is on a LUN with a different device id. Thus extra steps would be required for the replica to obtain the device id of the source LUN and to present the source device id to the key manager so that the key could be obtained. This would require considerable extra steps as compared to the implementations of the invention described herein. Replication also could require extra steps potentially requiring changes in existing scripts for replication. Further this alternate arrangement would not permit replication writing data reading data etc. to be transparent as it is with the embodiments of the invention described herein.

In contrast in accordance with embodiments of the invention described herein providing a metadata area that stores an identifier that can be used to acquire an encryption key helps to ensure that creating and reading encrypted replica eVLUs is transparent and requires no additional steps beyond a regular replication process assuming security requirements are met . The information needed for decryption is inherently made part of any replica made with any replication method in accordance with the embodiments of the invention. Furthermore a replica eVLU created in accordance with embodiments of the invention described herein will still be subject to the protections that the key manager server provides as to unauthorized access. Even if an unauthorized entity gains custody of a replica eVLU the unauthorized entity still will not be able to access data because the key manager will fail any unauthorized attempts to look up the key that is the security checks on the key manager see will not be met.

The invention can be implemented in many alternative embodiments as well. For example in one alternative embodiment the device id of a replica eVLU is registered in the Key Manager server and is associated in some way there with the key of the source eVLU. In still another alternative embodiment the device id of the primary eVLU is written in metadata and then used to look up the key.

Referring again to the key id in metadata also serves as identifier of sorts for the eVLU B to help the kernel see of an operating system running on the host recognize that a given LU is in fact an eVLU this is discussed in more detail in connection with . That is when the I O filter driver is running and encounters a new logical unit the I O filter driver can check first to see if the metadata region is present and can be read and second to see if the metadata includes a key id which indicates that the logical unit contains encrypted data which tells the I O filter driver that the LU is an eVLU B and that it needs to get the encryption key from the key manager server this process is described more fully in connection with . Another advantage of writing the key id in metadata is with replication any host that has permissions to communicate with the key manager server and which meets all security requirements can access every replica made of an eVLU B and get the key and decrypt the replica. In addition in at least some embodiments of the invention there are two or more separate pieces of information stored in the metadata such as one that says the LU is encrypted and another that gives information used to look up the key.

Accordingly whatever protections a key manager server has in place for restricting a host from obtaining the key for an eVLU B are likewise in place for replicas of the eVLU B. Thus even if an unauthorized entity physically takes a storage device containing a replica of an eVLU B and mounts it to a different unauthorized host the unauthorized entity won t be able to access the data on the replica because unauthorized host will not be able to meet the security requirements of the key manager server and therefore will not be successful in obtaining the key. Further this requires no extra steps or added management scripts to implement. These and other processes are explained in greater detail in connection with the flow charts of herein.

In the eVLU B the location of the metadata is platform specific and may depend further on the formatting of the device on that platform. Its illustration in as being at the end of the eVLU B is not limiting although it is applicable for at least some embodiments of the invention.

In at least one embodiment of the invention the eVLU B includes two copies of metadata referred to as the primary and alternate copies. The primary and alternate copies need not be in contiguous segments but could be in separate segments such as at the beginning and the end . A valid primary copy of metadata is always the authoritative copy as metadata updates are always performed on the primary copy first more below . The alternate copy of metadata is for robustness to rollback to previous metadata state as appropriate. A copy of metadata is composed of two parts header and data areas. The metadata header is a single block 512 bytes in size but this size is not limiting. The metadata data area is a variable length list of property name property value pairs. Each property name is also variable length. In one embodiment the key id stored in the data portion of the metadata has a size of 16 bytes and this size is illustrative and not limiting.

In addition in at least some embodiments of the invention the processes that perform encryption have predetermined knowledge that certain blocks or other regions in the LU should be kept as plaintext e.g. region A of and not be encrypted. For example with certain operating systems the first block in a volume corresponds to the volume table of contents VTOC and must be kept as plaintext in addition the VTOC can include information identifying the location of the beginning of alternate cylinders where all data from that point on is to be kept as plaintext. The point is that any OS metadata that is accessed below the I O filter driver or prior to the loading of the I O filter driver at startup of the host must be kept in plaintext because for OS metadata that is accessed below the I O filter driver the data is accessed without use of the I O filter driver and for OS metadata that is accessed prior to the loading of the I O filter driver the I O filter driver has not yet been loaded to decrypt it. However only OS metadata not any application data is accessed in this way.

As an example in one embodiment the eVLU B can be implemented where some areas of the eVLU B other than the metadata are left unencrypted that is the entire logical unit portion is not encrypted but is divided into unencrypted region A and encrypted region B as shown in . This helps to support the needs of certain operating systems to access their own metadata when it is accessed at different places e.g. lower in the I O stack than where the I O filter driver metadata resides and or at different times e.g. startup than the I O filter driver is running. For example when using the IBM AIX OS sector in a logical unit cannot be encrypted. For WINDOWS the device signature written to the logical unit is accessed below I O filter driver or before I O filter driver is loaded and must be kept in plaintext.

In another example on THE SUN SOLARIS OS VTOC formatted devices hold the label VTOC and geometry information in the first block block . This block is not encrypted so that the kernel layers below the I O filter driver that need to access this information can do so without use of the Xcrypt Manager see . Access to this information does not in itself constitute a security violation. Another unencrypted region for VTOC formatted devices are areas known as the alternate cylinders. Other platforms may be different based on device format and operating system specifics.

Leaving certain areas A of the eVLU B unencrypted other than the metadata areas helps to prevent the I O filter system from encrypting operating system metadata stored on the eVLU B. In one embodiment the I O filter driver of the I O filter system determines whether a request to write data is to a portion of the eVLU B used by the operating system . In such instances the I O filter driver keeps certain data unencrypted that an operating system accesses below the level of the I O filter driver . In one embodiment this is accomplished by recording in code a data structure a map a table or in the metadata itself the block ranges that are and or must be in plaintext. The block ranges that are left as plaintext depend on the operating system as will be appreciated by those of skill in the art.

The C clamp I O filter driver supports components for providing platform independent functionality for the I O filter driver system see and also supports various platform dependent components for supporting specific operating systems.

Referring again to the OS interface may be for example an interface to any operating system such as Sun s SOLARIS IBM AIX HPUX LINUX and or Microsoft s WINDOWS NT. The HBA interface includes platform dependent code comprising an interface to relevant host bus adapters. The Common APIs comprises a series of common Application Programming Interfaces APIs . An advantage of the C clamp configuration of is that extensions can be written in a platform independent manner because the OS Interface HBA Interface and Common APIs translate all of the platform dependent communications into more generic communications. Various extensions through are enveloped between the OS Interface and the HBA Interface . Note that although each extension is illustrated as a single extension each extension could consist of a plurality of extensions.

The vertical line in running vertically from the operating system through the host bus adapter and pointing downward helps to indicate the direction and order that data takes from the operating system through the I O filter driver and to an eVLU B and generally corresponds to the order in which the extensions are executed in response to an IO request. As those of skill of the art will appreciate if a first extension needs processing or input provided by a second extension then the second extension must be processed before the first extension in the I O stack. For example input to the I O filter driver from the operating system is acted upon by the OS Interface then the Xcrypt Manager then the virtual LU metadata manager vlumd before it passes out through the HBA interface to the host bus adapter . Similarly the vertical line running upward from the host bus adapter towards the operating system indicates the direction of that data takes when it is output from an eVLU to the operating system . This is the direction of configuration of a device LU as will be described further in connection with as well.

In addition to a plurality of existing extensions all are not illustrated but the data migration extension is illustrative two new extensions are added in the embodiment of to manage I O requests and encryption and decryption as well as a number of other features of the present invention. These extensions are explained below and further herein.

The Xcrypt Manager extension xcrypt is an extension that includes functionality to turn encryption on or off for a given logical unit in response to a command from userspace. The Xcrypt Manager extension is the only extension that interacts with the crypto kernel see and can interface with various userspace components see using both kernel events mapped to the libemcp events library and IOCMDs see The Xcrypt Manager supports several input output commands IOCMDs that are used by a component called libemcp xcrypt see to communicate with it. The libemcp xcrypt component services user commands from the powervt API component and coordinates the lookup key event in the kernel . These commands which are explained more fully as part of the flowcharts of herein do the following things 

Whenever an eVLU B is encountered by the I O filter driver usually at startup of the host it is configured into the I O filter system by the Xcrypt Manager . At that point the Xcrypt Manager requests the key lookup of the encryption key by passing the key id to a xcrypt userspace daemon the xcrypt daemon see where the xcrypt daemon is running a key manager client that communicates with the key manager server to get the key see the processes of . Once the key lookup is accomplished the xcrypt daemon sends the encryption key to the Xcrypt Manager which then has it available for doing I O see . This request and response also contains a device id which identifies the underlying LUN that is encrypted and is used to lookup the data structure where the encryption key is stored in the kernel. As further described in connection with both read and write operations require the Xcrypt Manager to allocate an additional buffer to hold the encrypted data. The original buffer will always hold the plaintext version of the data.

The virtual logical unit metadata MD manager vlumd extension takes care of establishing a metadata region on a device where the metadata region can be unambiguously recognized and provides controlled access to the metadata protecting it from inappropriate access. The vlumd extension also sets name value pairs into metadata and gets the value back when presented with the name it will be understood by those of skill in the art however that there are many other alternatives to the use of name value pairs. The vlumd extension provides a vlumd interface usable by the Xcrypt Manager extension . In one embodiment of the invention the only user of the vlumd interface is the Xcrypt Manager extension . However in other embodiments the vlumd manager is able to be extended to support other types of LU virtualization and LU functions such as mirroring striping and thin provisioning.

The general purpose extension is an intermediary between certain of the extensions e.g. the xcrypt extension the data migration extension and the vlumd extension and the C clamp and provides more flexibility to the extensions by allowing dynamic loading.

Referring now to the I O filter system includes components in both userspace and kernel space . The I O filter system components in kernel space are the ones that interact with the storage arrays . In kernel space the I O filter system includes an I O filter driver having the previously described in C clamp architecture that includes an Xcrypt Manager and a vlumd manager along with kernel events . The kernel space portion of the I O filter system is in communication with a crypto kernel which is illustrated in as the B SAFE CRYPTO KERNEL and in by the combination of the cryptography key manager CKM kernel and encryption decryption library which together form a crypto kernel . The crypto kernel including the CKM kernel portion is in communication with the Xcrypt Manager of the I O filter driver .

In one exemplary embodiment the crypto kernel is implemented using the B SAFE CRYPTO KERNEL product available from RSA Security which is owned by EMC Corporation of Hopkinton Mass. to provide a cryptographic foundation for other security products that interact with the I O filter system such as the key manager server . In one embodiment the crypto kernel provides a collection of cryptographic algorithm implementations including for example at least one of Advanced Encryption Standard AES also known as Rinjdael cipher block chaining AES CBC encryption 256 bit keys and or AES tweakable block ciphers encryption two 128 bit keys . Other cipher key strengths e.g. a 128 192 256 or 512 bit encryption key sizes are also usable with embodiments of the invention.

Use of a symmetric encryption technique such as AES based encryption is advantageous for embodiments of the invention where it is required that the size of the block remain the same after encryption as before as those of skill in the art are aware a number of encryption algorithms increase the size of a data block . As will be understood by those of skill in the art the invention is not limited to only AES based encryption algorithms. In certain embodiments any encryption algorithm that does not change block size is usable. In at least some other embodiments it may be possible to use encryption algorithms that do change the block size. Note that in the embodiment of the crypto kernel protects its data via encryption using a data encryption key DEK .

The kernel provides abstraction layers for hardware memory processors and input output I O and makes these tools available to the userspace through system calls. The kernel events support input output commands IOCMDs such as waiting for an event getting an event argument and one call that any kernel extension can use to notify an event that is put it on a queue for a userspace entity to retrieve through a wait.

Referring again to the userspace components of the I O filter system include a common security toolkit CST an xcrypt daemon which runs a key manager client several userspace data files including a set of configuration files signed and made tamper proof by CST a lockbox also provided by CST and a key cache a powervt command line interface CLI a powervt application programming interface API a cryptographic key manager CKM client interface a key manager client a libemcp xcrypt userspace library and a libemcp events userspace library . One or more applications also run in userspace but the applications are not part of the I O filter system . The I O filter system also includes several userspace scripts including the xcrypt config script and the xcrypt startup script. The xcrypt config script is run only once after the initial installation of the I O filter system to execute all the commands that configure all the I O filter system components for performing encryption functions using the configuration files see e.g. block of the process of . The xcrypt startup script is run to start the xcrypt daemon after reboot of the host and is also called from the xcrypt config script to start the xcrypt daemon for the first time.

The key manager client is a component of the key manager server that operates remotely incorporated into the 10 filter driver system on host and the key manager client operates in concert with the key manager server server. In the embodiment of keys are only provisioned by the key manager server by going through the key manager client . Referring again to provisioning happens starting in the powervt CLI going through the powervt API libemcp xcrypt to CKM client through key manager client not going through the xcrypt daemon . It will be appreciated by those of skill in the art however that embodiments of the invention could be implemented where a different component provides keys to the key manager server for provisioning to the I O filter system that is it is possible to generate keys outside of the key manager itself but later store the keys on the key manager .

The key manager client can cache certain encrypted keys and therefore does maintain and obtain encryption keys but only as a cache of what is on the key manager server which advantageously is the definitive source for encryption keys . The encryption keys include keys for encrypting and decrypting data. Note that there also are master keys for encrypting the encryption keys i.e. key encryption keys KEKs to provide further key security but the KEKs are stored in the lockbox and are used in at least some embodiments of the invention including but not limited to embodiments that are implemented in hardware based environments to encrypt the data encryption keys DEKs stored in the client key cache . Only encrypted keys are stored in the key cache . Note that in some embodiments the KEK is not used.

The I O filter system can be configured to work with various types of keys such as 64 128 or 256 bit keys and with various encryption algorithms. In one embodiment the key cache is accessible only in userspace . In another embodiment the key cache grants read only access to the kernel .

The CST includes command line interfaces CLIs application programming interfaces APIs and libraries to help provide functions such as user authentication e.g. via CST Authentication A role management authorization e.g. via CST role management B account verification security functionality and password protection. In addition the CST includes a lockbox to securely store security information configurations and passwords including a CST master key. Passwords are encrypted using CST facilities and stored in the lock box or in the configuration files in the encrypted form. The Lockbox keeps the key for these encryptions in a secure fashion. The CST also stores configuration files in a tamper proof fashion by implementing configuration services to securely sign configuration files for the key manager client and the configuration files are signed to detect tampering with configuration information . The CLI uses the CST to authenticate users of the CLI . Authorization happens in the API using role management and the authentication token passed in to the API from the CLI .

The key manager client can cache encryption keys also referred to as data encryption keys DEK locally in the secure key cache along with other key attribute information. Usually this is done at the time the encryption key is first created and sent to the key manager client by the key manager server as will be explained further herein. These locally cached data encryption keys in the key cache are encrypted using a locally and automatically generated key encryption key KEK that is secured using a master key provided via lockbox and the CST encryption function. In one embodiment the key cache is accessible only in userspace . In another embodiment the key cache grants read only access to the kernel . Note that the KEK is automatically generated at the time the host is setup to use encryption services.

Communications between the I O filter system including those of the key manager client and key manager server are protected in various ways including use of trusted root and key manager server certificates to prevent spoofing of the key manager server and an encrypted secure sockets layer SSL protecting the communications themselves.

The CKM client provides an abstract interface to the key manager client . For at least some embodiments of the invention it is advantageous to abstract the interface to the key manager client and key manager server components so that other code providing these functions could be used in the future and to separate cryptography from the I O control and operational paths. One concept for this abstraction is to create a context used by encrypt decrypt in the kernel . The context includes a keyblob.

The keyblob is an abstraction that contains all the information stored by the key manager server that is needed by the encrypt decrypt code. None of the information stored internally in the keyblob is needed by the I O filter system so it is possible for the structure of the keyblob to be opaque to the I O filter system . There is a unique keyblob for each logical unit and as explained further in the flowcharts of herein the keyblob is looked up by key id a globally unique identifier and provisioned by a policy such as key class. A keyblob includes the actual encryption key plus other information used by a given encryption algorithm provided in accordance with a class definition provided to the key manager server . The key class definition includes information relating to information stored in the keyblob which include but are not limited to Key key length encryption algorithm and mode of encryption algorithm. Note that although the keyblob is a data structure handled in both userspace and the kernel in at least some of the embodiments described herein the keyblob is primarily used for encryption in the kernel and the keyblob s handling in userspace is primarily related to getting the keyblob to the kernel .

The xcrypt daemon launches the key manager client to look up keys actually keyblobs on behalf of the Xcrypt Manager running in the kernel . The xcrypt daemon calls into the library libemcp xcrypt see to wait for key lookup requests and once the xcrypt daemon receives the request the xcrypt daemon looks up the keyblob which may involve requesting it form the key manager server or could involve getting it from the client cache and then pushing the keyblob back into the kernel . The xcrypt daemon is launched when the one time use script xcrypt config is run and every time the host is rebooted.

As shown in the powervt CLI interface is a command interface to the powervt API . In other implementations a web based interface not shown may be included in addition to or in alternative to the powervt CLI interface . The powervt API represents an implementation of an application program interface API that provides a set of routines in libraries for implementing encryption on logical units.

The libemcp xcrypt library is the userspace interface to the Xcrypt Manager running in the kernel. The xcrypt library interfaces with the libemcp events event subsystem the Xcrypt Manager and the CKM client and provides functions to do the following 

The libemcp events is a userspace library that supports the events subsystem. The userspace calls go through this library to wait for events from the kernel events . Libemcp events is used by the xcrypt daemon to wait for key lookup events posted by the Xcrypt Manager through the kernel events subsystem .

The processes of are illustrated approximately in the order that they would occur. Note however that not every process shown in the blocks of necessarily will occur for every I O filter system . Initially the host is configured block using e.g. the process of block . When configuration is done encryption is turned on for a storage device and the storage device is established as an eVLU B block e.g. via the process of . Note that the VLU A represents a logical version of eVLU B and the LU is the combination of A and B together the actual device. Block includes provisioning a key as well via the process of . Another process that can occur is configuring the eVLU B to a host after the host has restarted or is rebooted block which process is discussed in greater detail in block .

A process for looking up a key for an already configured eVLU B also can occur block as further shown in block . Processes for writing encrypted data to and reading encrypted data from an eVLU B blocks respectively also are provided corresponding to the flowcharts of . The source eVLU B can be replicated to a replica eVLU B block via the process of and the metadata on an eVLU B can be re read to determine if the state of an eVLU B has changed block via the process of . Finally an optional process is provided for turning encryption off for an eVLU B block via the process of .

Note that in some embodiments of the invention the host must receive a license for the I O filter system e.g. a license for EMC POWERPATH ENCRYPTION WITH RSA before running the configuration script below.

In block a configuration script e.g. xcrypt config as described herein is run to enable the host for encryption. The xcrypt config is run once and only once on a host . Running xcrypt config implements a number of components and actions including

If the Xcrypt Manager indicates that the state of the device LU also referred to herein as device state is already encrypted i.e. a valid key id already exists in the metadata an error is returned block and the process ends block . If the device state is not one of the following states ENCRYPTED WAITING FOR KEY NO KEY or UNENCRYPTED also referred to herein as NOT ENCRYPTED then the device state is UNKNOWN and an error also is returned block and the process ends block . If at block a device s state is returned as UNENCRYPTED a process begins to turn on encryption for the device LU .

If the device e.g. LU state is UNENCRYPTED the process begins to get a key. A key and key id are requested from the key manager server blocks and in the context of a call into libemcp xcrypt to turn encryption on for a particular LU . At this point the code in libemcp xcrypt calls into the key manager client code through the CKM interface to provision a key. Referring briefly now to is a flow chart showing a method of provisioning a key id and key keyblob for a device configured in accordance with the process of in accordance with one embodiment of the invention. The blocks of are processed at and in cooperation with the key manager server in one embodiment of the invention. When the request for a key and key id are received block an encryption key is provisioned block . A key id also is generated in one embodiment the key id is unique block note that generation of the key id could take place at another entity other than the key manager server and then be provided in response to the request of block .

A copy of the key key id and associated key information which is used to accomplish encryption decryption and which will later become part of a keyblob is stored at the key manager server block . The key id key and associated key information also are returned block to the requester. Note that the key lookup of can in one embodiment be accomplished locally via a lookup to the key cache that the key manager client keeps on the host and or in the host file system where the key cache can be preloaded with a new key however in this alternate embodiment the steps of FIG. would be performed in advance of turning on encryption for a particular device LU . Alternately as described herein the key can be obtained directly from the key manager server .

Referring again to at block the key id key and associated key information e.g. key length key algorithm are received block at the I O filter system into libemcp xcrypt . A keyblob is created e.g. by the CKM client based on the received key and associated key information block . The libemcp xcrypt then calls into the kernel to push the keyblob into the kernel. The keyblob and key id are sent to the Xcrypt Manager through an IOCMD. In addition a flag is set to indicate that the VLU is new i.e. this is a device newly having encryption turned on . block 

After the keyblob and key id are pushed a check is made as to whether the VLU is in use block . If Yes then an error is returned block . If no then the Xcrypt Manager writes the key id into the metadata via the vlumd manager block which allocates metadata space writes a signature into metadata space and writes the key id into metadata space. After the completion of block the LU will be recognized by a host or other entities as an eVLU because the key id has been written into metadata . The Xcrypt Manager stores the keyblob and key id in a device data structure kept in non pageable kernel memory block which ensures that the keyblob and key id are protected by the kernel and never get written to a persistent storage device like a disk. The device data structure on the eVLU also includes device identifier device id information where the device id is used to identify the underlying LUN that is encrypted and is used to lookup the data structure where the encryption key is stored in the kernel. Once block is complete the state of the eVLU is set to ENCRYPTED in the device data structure and the device is now an eVLU B. At this point the I O filter driver is ready to handle I O to the newly created eVLU B.

First a determination is made as to whether metadata can be read block . For example the Xcrypt Manager attempts to read the key id from the metadata via the vlumd manager . If the metadata region cannot be read it is presumed that the device state is UNKNOWN and the device state is set to UNKNOWN in the device data structure block . If the device state is UNKNOWN certain types of I O requests are permitted. The types of I O requests that are permitted when the device state is UNKNOWN are specified in the Tables of and in which are discussed further herein. All other types of I O requests that are not deemed allowable per the tables of B and or per are failed block . Note that in at least some embodiments of the invention the I O filter system keeps track of regions or blocks of a device that are kept in plaintext even if the device is encrypted. For example in the embodiments using the EMC POWERPATH ENCRYPTION with RSA when the Xcrypt Manager receives a Device State Check request code in the Xcrypt Manager tracks that I O request to test whether the currently known encrypted regions have changed after the request has been processed in the lower layers of the I O stack.

It also should be understood that when a device state is UNKNOWN then I O requests that are not directed to a particular region of the device may be allowable as will be discussed further in connection with B and .

Furthermore in accordance with at least some embodiments of the invention there are two types of regions that are unencrypted. Some regions are known to be unencrypted for any device block on Solaris or Windows or AIX for instance . Other unencrypted regions are device dependent stored in the metadata or can t be known at this point the regions are known only after metadata can be read. So I O requests directed to a region that is known to always be unencrypted are allowable when the device is in an UNKNOWN state.

Referring again to block of if the metadata location was able to be read block a check is made as to whether there is valid metadata in the location and whether that metadata contains a key id block . For example in one embodiment the Xcrypt Manager of the I O filter driver checks whether there is valid metadata in the location. Note that a virtualized LUN could have a defined metadata region with metadata on it but the metadata might not include a key id. As those of skill in the art are aware there are other types of metadata.

If the answer to either of those questions is no then it is presumed that the device is unencrypted the device state is set to UNENCRYPTED in the device data structure and all I O requests to all regions of the device are permitted block in accordance with the Tables of and with which are discussed further herein. Of course the processing of the I O requests will be consistent with the type of device for example if the device is read only write I O requests will not be processed. All I O requests to all regions of the device are permitted by the Xcrypt Manager .

If the metadata region contains a key id block then the key id can be used to get a key for access to data on the eVLU B block . A request for key lookup is made to the key manager server such as via the xcrypt daemon block . The request includes the device id and the key id which is provided for key lookup. The device id in one embodiment is used to identify the underlying LUN that is encrypted and is used to lookup the data structure kept by the Xcrypt Manager where the encryption key is going to be stored in the kernel . The key lookup request goes into a queue of kernel requests block as part of the kernel events . Note that there is a queue of requests in the I O filter driver and this request is added to the queue. The userspace daemon e.g. xcrypt daemon is constantly waiting for requests to be added to the queue in the I O filter driver .

At the kernel in the Xcrypt Manager the Xcrypt Manager stores the key id in the device data structure for the device denoted by the device id for later checks i.e. lookups by the Xcrypt Manager block . The state of the eVLU is set to WAITING FOR KEY in the device data structure block . In the WAITING FOR KEY state for an eVLU I O requests to all encrypted areas are disabled and or pended until the key is looked up and cached in the I O filter driver in Xcrypt Manager . Selected I O requests are permitted however in the WAITING FOR KEY state as discussed further herein in connection with B and . For example if there are device specific regions that are in plaintext the device specific regions can also have I O request access because the metadata can be read to get this information as to the regions that are in plaintext. Note that the permitted I O requests in the WAITING FOR KEY state include I O requests that are not directed to specific encrypted or unencrypted regions and generally more I O requests are permitted in the WAITING FOR KEY state than in the UNKNOWN state.

As illustrates the state of each device also is stored in the device data structure that is the state as kept by the Xcrypt Manager which also keeps the device data structure . While the state of the eVLU B is set to WAITING FOR KEY block a timeout is set on the device block to provide a time period e.g. a predetermined time period to retrieve the key which is done in the process of block . If the timeout period expires before the key is retrieved during the process of . e.g. block then in the kernel the state of the device is set in the device data structure to NO KEY see block of . In addition certain conditions cause the timeout set in block to be cancelled such as if the key is received block of if a security check block fails or if the key lookup fails blocks and of .

Referring again to after the timeout is set in block processing moves block to which is a flow chart that continues the method of further showing a method for getting a key for a device that is being configured to a host and has encryption turned on in accordance with one embodiment of the invention. This process is executed by the xcrypt daemon .

Referring now to at block a call is made into the kernel into I O filter driver to wait for a key lookup request. If the key lookup request is not received at the kernel block after a period of waiting then a timeout occurs block and the call is made again into the kernel and the xcrypt daemon waits in the kernel until either a key lookup request arrives or the timeout occurs. If the key lookup request is received by the xcrypt daemon xcrypt daemon goes through the key manager client to request the key associated with the key id in the request. The key manager client first attempts to find the key in the key cache block . If the key is in the key cache then the keyblob is returned block and a call is made into the kernel with the keyblob and key id block . Note that in this block when the keyblob is pushed a flag is not set unlike block of because the device in this block is not newly having encryption turned on.

A check is made block as to whether the key id provided in the IOCMD sending the keyblob into the kernel matches the key id that was previously stored in the device data structure at the time the key lookup request was made i.e. at block of FIG. A . For example the IOCMD sending the keyblob into the kernel includes the key id and device id that were part of the key lookup request in block . The Xcrypt Manager uses the device id to locate the device data structure and then matches the key id. If there is no match block it is assumed that a later request in the queue of requests will have the correct key id and the process returns to the xcrypt userspace daemon running at block to wait for such a request.

If the key id matches at block the keyblob is stored in the device data structure block and the eVLU device state is set to ENCRYPTED block . Because the encryption key is available pended I O requests for this device are restarted that were previously disabled in block of or in block of discussed further herein block in accordance with B and discussed further herein .

Note that per the processes and tables of B and if the pended I O request is of a type that affects the state of the device or that affects subsequent I O requests slice layout and or the arrangement of encrypted and unencrypted areas then after the pended I O request is complete i.e. I O Done it is further tracked via the processes of discussed further herein . This tracking process in one embodiment re reads the metadata and the state of the device. Note that I O requests that access encrypted regions of the device also are processed according to but do not cause the state of the device to be checked. After block is complete the process of returns to the xcrypt userspace daemon running at block to wait for further key lookup requests.

If at block the key was not in the key cache then the key must be obtained from the key manager server . Note that although not illustrated explicitly in if the key server is not found or cannot be connected to an error can be returned as would be expected by those of skill in the art. First security checks are performed between the key manager client and the key manager server to verify that the host where the client is running is allowed access to the server and that the server is authentic blocks . If the security checks fail an error is returned block and the kernel Xcrypt Manager is informed that the key lookup failed block . The timeout set in block of is cancelled as well block . If security checks pass then the key id is provided to the key manager server to request a key and keyblob related information from the key manager server block . An additional security check is performed at the key manager server block to verify that the host where the client is running is allowed to access the key associated with the key id. If the security is not OK an error is returned block indicating that key lookup failed block and the timeout set in block of is cancelled block . If the security is OK however a check is made as to whether the key manager server has returned a keyblob block . If the keyblob was returned aforementioned blocks through are performed as discussed previously.

If the keyblob was not returned at block a call is made into the kernel Xcrypt Manager to indicate that the key lookup failed block . The timeout set in block of is cancelled block . In addition when key lookup fails the state of the device is set to NO KEY block . All pended I O requests e.g. those pended at block of discussed later herein are restarted. The state of the device also is set to NO KEY block if the timeout set in block expires block . Note that in accordance with the tables of B and with since the state stored in the device data structure is now NO KEY these pended I O requests will be failed. Except in the case of the timeout set in block of expiring the process proceeds back to the xcrypt userspace daemon and block block .

With the flowcharts of it is still important to remember that having the key id alone is not enough to get a key to decrypt data. It is still necessary to fulfill all other security requirements including for replicas. These security requirements include but are not limited to 

Of course those of skill in the art will appreciate that many different security techniques and implementations are usable with one or more embodiments of the invention.

If at block the answer is NO then the device state is one of UNKNOWN WAITING FOR KEY and NO KEY block . A check is made whether the device state is WAITING FOR KEY block . If the answer is Yes block then the processing jumps to block of which is a flowchart that processes the I O request for the WAITING FOR KEY device state in accordance with the tables of discussed further herein.

If at block the answer is No then the device state is checked to determine if it is NO KEY block . If the answer is Yes block then the processing jumps to block of which is a flowchart that processes the I O request for the NO KEY state in accordance with the tables of discussed further herein. If at block the answer is No block then the device state is UNKNOWN and the processing jumps to block of which is a flowchart that processes the I O request for the UNKNOWN state in accordance with the tables of discussed further herein.

Referring again to block of if the device state is ENCRYPTED an optional check is made as to whether the request to write data involves writing data at least partially to an encrypted area of the eVLU B block . Note that I O requests that straddle encrypted and unencrypted regions of a device are treated the same as writes that are directed only to an encrypted region of a device with the caveat that the data on the unencrypted portion of the I O request is not encrypted as part of I O request processing. Recall that in some embodiments the eVLU B can be configured so as to have in addition to the metadata region an unencrypted area A and an encrypted area B. If the eVLU B is configured such that all areas of it excepting the metadata are encrypted then the optional check at block may not be necessary.

Referring again to if the device state is ENCRYPTED at block but the I O request is to write data to an unencrypted area or block of the eVLU B that is the answer at block is NO then per block of processing proceeds to block of where the I O request is allowed block of . If the device state is ENCRYPTED and the I O request is to write data to an encrypted area of the eVLU B whether by default because the entire eVLU B is encrypted or because the Xcrypt Manager in the I O filter driver is aware that the blocks to be written to are encrypted blocks then the process to encrypt data written to the eVLU B is begun block . The Xcrypt Manager is used to accomplish this as well as the other steps of except for the encrypt call itself block which is made from the Xcrypt Manager to the crypto kernel module code.

Optionally the existing user buffer is mapped into the kernel virtual address space in order to make it accessible from the kernel block . The Xcrypt Manager allocates a private local buffer as an encryption buffer to hold the encrypted data before it is written to the eVLU B block . To ensure that the data to be written is going to be encrypted before being written the I O request is modified so as to temporarily use the encryption buffer in place of the user buffer block . The location of the original user buffer is retained for later restoration.

The Xcrypt Manager calls encrypt by passing the device specific keyblob to the CKM kernel of the crypto kernel and the CKM kernel passes the keyblob to the encrypt decrypt lib of the crypto kernel . The crypto kernel uses the keyblob to encrypt data as it is moved from the user buffer to the encryption buffer block . The encryption buffer now contains encrypted data block . The I O request to write data is passed down the I O stack block . I O then passes through its normal places in the I O stack e.g. as partially shown in eventually passing through the HBA and to the storage device. Processing at this point proceeds to the process of block .

When an I O request to read data from a device is received block the Xcrypt Manager within the I O filter driver checks whether the device state stored in the device data structure is ENCRYPTED block . If the device state isn t ENCRYPTED then processing proceeds to block .

If the device state stored in the device data structure is not set to ENCRYPTED a check is made as to whether that state is set to UNENCRYPTED block . If the state of the device is set to UNENCRYPTED block then the I O request is passed down the I O stack and read I O requests are permitted in accordance with B and block .

If at block the answer is NO then the device state is one of UNKNOWN WAITING FOR KEY and NO KEY block . A check is made whether the device state is WAITING FOR KEY block . If the answer is Yes block then the processing jumps to block of which is a flowchart that processes the I O request for the WAITING FOR KEY device state in accordance with the tables of discussed further herein.

If at block the answer is No then the device state is checked to determine if it is NO KEY block . If the answer is Yes block then the processing jumps to block of which is a flowchart that processes the I O request for the NO KEY state in accordance with the tables of discussed further herein. If at block the answer is No block then the device state is UNKNOWN and the processing jumps to block of which is a flowchart that processes the I O request for the UNKNOWN state in accordance with the tables of discussed further herein.

As was true for the method for writing data to a device of for I O requests that involve reading data from a device I O requests that straddle encrypted and unencrypted regions of a device are treated the same as reads to an encrypted region of a device with the caveat that the data on the unencrypted portion of the I O request is not decrypted as part of I O request processing. Referring again to block of if the answer was YES i.e. the device is ENCRYPTED and is an eVLU B a check is made as to whether the request to read data involves reading data at least partially from an encrypted area of the eVLU B block . Recall that in some embodiments the eVLU B can be configured so as to have in addition to the metadata region an unencrypted area A and an encrypted area B. If the eVLU B is configured such that all areas of it excepting the metadata are encrypted then the optional check at block may not be necessary.

Referring again to if the eVLU B is ENCRYPTED but the I O request is to read data from an unencrypted area or block of the eVLU B per block of processing proceeds to block of where the I O request is allowed block of . If the eVLU B is ENCRYPTED and the I O request is to read data from an encrypted area of the eVLU B whether by default because the entire eVLU B is encrypted or because the Xcrypt Manager in the I O filter driver is aware that the blocks to be read from are encrypted blocks then the process to decrypt data written to the eVLU is begun block . The Xcrypt Manager is used to accomplish this as well as the other steps of except for the decrypt call itself block of which is made from the Xcrypt Manager to the crypto kernel module code.

Optionally the existing user buffer is mapped into the kernel virtual address space in order to make it accessible from the kernel block . The Xcrypt Manager allocates a private local buffer as a decryption buffer to hold the encrypted data ciphertext when it is read from the eVLU B block . To ensure that the data to be read is going to be decrypted before being returned to the caller the I O request is modified so as to temporarily use the decryption buffer in place of the user buffer block . The location of the original user buffer is retained for later restoration. The I O request to read data is then passed down the I O stack block . I O then passes through its normal places in the I O stack e.g. as partially shown in . Processing at this point proceeds to the process of block .

Referring again to during processing an I O request to a logical unit which can be an eVLU B but need not be in accordance with the processes of and for asynchronous I O as is known in the art whenever data is sent an acknowledgement such as an I O Done interrupt is received block . Per block a check is made as whether the original I O request is a Device State Check request or whether the I O request is an I O request that requires tracking per where the original request was not a read or write to an encrypted region. If the answer at block is Yes then per block of processing jumps to block of which process if further described herein.

Referring again to block if the answer is No then the I O Done indication was received after a write or read to an encrypted region block . A check is made whether the original I O request was for a write block . If the answer at block is Yes then the eVLU B now contains encrypted data and the write data request was successful block . It is possible that the I O request will return I O done whether or not the I O request succeeded and as those of skill in the art are aware it may be necessary to check for errors to determine if the I O request was completed as errors may mean that the action being requested a write or a read will not occur.

Referring again to for the case where the original I O was a write after block the encryption buffer is de allocated block . If necessary the user buffer is unmapped from kernel if such mapping occurred in block of . The I O request is modified so that it again points to the user buffer block .

Referring again to block of if the answer at block is No then the original I O request was not a request for a write and is instead an I O read request. If the original request was to read data block and the I O Done interrupt is received then the Xcrypt Manager calls decrypt by passing the device specific keyblob to the crypto kernel block . The crypto kernel decrypts data as it is moved from the decryption buffer to the user buffer block . The user buffer now contains plaintext block and the read request was successful. The encryption buffer is de allocated block . If necessary the user buffer is unmapped i.e. if such mapping was done at block of . The I O request is modified so that it again points to the user buffer block .

The primary source eVLU B is replicated to a replica LUN. The replication can be by methods that include but are not limited to methods such as those used in the aforementioned SRDF Timefinder and Mirrorview products from EMC. As part of replication the data on the replica LUN is synchronized with the data on the source eVLU B. Known replication technology such as Timefinder replication within an array or SRDF replication between arrays over a network that connects them directly for the SYMMETRIX line of disk arrays available from EMC Corp. can for example be used for synchronization. In another example an appliance or switch in the network can replicate between two devices on the network on the same or different arrays. In still another example where the source and replica logical volumes are located within a single array data can be transmitted from the source logical volume to the target logical volume without involving a network or a host. During the synchronization an application on host may have continued access to the information on the source eVLU B.

The synchronization part of replication involves moving or copying the data from the source or primary eVLU to the replica LUN. As is understood in the art various techniques can be used to perform synchronizations. For example a mirroring facility such as the SYMMETRIX Remote Data Facility SRDF available from EMC Corporation Hopkinton Mass. may be used to create mirrors between source and target volumes on different storage systems and to then synchronize them so that the storage systems themselves perform the copy.

In another situation the replica eVLU might be removed from the host while synchronizing and is then configured back to the host when synchronization is complete. Note that removing a device from the host causes the host to notice that the device has been removed and the host discards its cached information about the device.

Referring again to after replication and synchronization the replica LUN becomes a replica eVLU and because the metadata was also replicated the replica eVLU has in its metadata the same key id as the metadata on the source primary eVLU block . Optionally the source primary eVLU can be separated or split from the replica eVLU if that step is required by the replication method block . If the replica eVLU was already configured to the host with which it is to be used block then processing proceeds to block block . If however the replica eVLU is not yet configured to the host with which it is to be used then the process of is run to configure the replica eVLU to a host that has been configured to use the key manager server that holds the key for the primary eVLU per block . Depending on the protected perimeter desired the replica eVLU can be configured to the same host as the source eVLU or can be configured to a different host. However the replica eVLU and the source eVLU need access to the same key manager server or replicas of that key manager server.

Note that configuration will lead to looking up a key for the replica eVLU block where the key itself will be the same as that for the source eVLU. Once the replica eVLU is configured to a host and the key is available block encrypted data on the replica eVLU can be read such as via the process of .

One point that should be appreciated regarding the process of is that no extra steps are required over what is required to replicate a plaintext volume so long as each host that sees an eVLU is properly configured with the I O filter system and that all hosts that share replicas e.g. like the arrangement shown in the protected perimeter of use have access to the same key manager server. Generally for replica eVLUs the key to access encrypted data on the eVLU is looked up either by configuring the replica block or by opening the replica eVLU for those operating systems that have device open as a feature . The key id stored in the metadata in the replica eVLU is used to obtain the key the same as occurs with a non replica eVLU. For some situations e.g. those running on WINDOWS based operating systems and other situations where a replica LUN is not opened before access a command such as powervt update might need to be run to trigger the kernel to recognize the change in state of a device e.g. a LUN going from unencrypted to being an eVLU . This is further addressed in . In another situation the replica device is removed from the host while synchronizing and is then configured back to the host when synchronization is complete in this case the processes shown in will be executed and the powervt update command is not needed.

In block of a device open or powervt update has occurred or some other event has occurred that triggers a re read of metadata on a device. In one embodiment of the invention re reading of metadata occurs when a Device State Check is performed on a device. For example in the embodiments of the invention that are implemented using EMC POWERPATH ENCRYPTION WITH RSA the Device State Check serves as a hint to PowerPath managers and extensions in the I O stack that the state of the device may have changed. The Xcrypt Manager allows the Device State Check for all key states and tracks its completion. A Device State Check is a generalized mechanism that causes components in the I O stack e.g. the EMC POWERPATH ENCRYPTION with RSA I O stack to re evaluate device state which for the Xcrypt manage includes re reading metadata etc. in accordance with the process of . On the completion side Xcrypt attempts to read or re read the metadata region on a device e.g. an eVLU looking for a stored key Id.

Referring again to a process is begun to detect whether a particular device being opened or updated is an eVLU device B including detection of the state of the device starting with an attempt by the vlumd manager to read metadata on the device to determine if there is a key id in the metadata block . This check also can come in from block of . If the metadata location cannot be read block then the state of the device is set to UNKNOWN that is it cannot be determined if the device is an eVLU and certain types of I O requests are permitted in accordance with B and but all other I O requests are failed block . The situation of a metadata location being unable to be read can occur for example if a storage device is offline or not ready which is the state of a TIMEFINDER business continuance volume BCV for example when it is being synchronized with the primary device. 

If at block the metadata location can be read a check is made as to whether there is valid metadata containing a key id block . If the answer at block is No that is there is not valid metadata containing a key id a check is made whether a key id is stored in the device data structure in the Xcrypt Manager block . If no key id is stored in the device data structure i.e. the answer at block is no then there has been no change in the state of the device block and the device state stored in the device data structure remains UNENCRYPTED and all I O requests are permitted per B and per block . Note that all blocks in after block take place in one embodiment in the kernel.

If there is not valid metadata containing a key id but there was a key id stored in the kernel i.e. a Yes answer at block then that indicates that the device has changed state block namely going from having a key id to having no key id meaning that the device has changed state from ENCRYPTED to UNENCRYPTED. For the UNENCRYPTED device state all I O requests are permitted block in accordance with B and each of which is disclosed further herein.

Referring again to block if the answer was Yes i.e. if a key id was returned block then determinations need to be made as to whether this represents a change in state for the device whether the key id is the same as that previously stored in the device data structure and or also whether the keyblob associated with the key id is stored in the device data structure. If the key id returned in block is the same as that stored in the device data structure in the kernel blocks and then a check is made block as to whether the device state stored in the device data structure is ENCRYPTED. If the answer at block is Yes i.e. the state is ENCRYPTED then the associated keyblob is also stored in the device data structure block . If the device state stored in the device data structure is listed as ENCRYPTED that means that there has been no change in state block .

If at block the device state stored in the device data structure is not listed as ENCRYPTED then a check is made as to whether the device state stored in the device data structure is NO KEY block which means that there is no keyblob in the device data structure but the device is encrypted. If the answer at block is Yes the key needs to be retrieved and the process of is used to look up the key that goes with the key id block . If the answer at block is No than the device state is not NO KEY so by process of elimination it must be WAITING FOR KEY block . In this case the key id is unchanged no change in state in stored device data structure and the request to lookup the key has not yet been responded to by the xcrypt daemon .

Referring again to block if the key id on the device being read is not the same as the key id that was stored in the device data structure for that device i.e. the answer at block is No then one of two conditions has occurred. One alternative is that the key id changed e.g. from key id  to key id  which can indicate that a device that was synchronized with e.g. source device A has since system reboot or since the last time the device was opened been made the replica of and synchronized with source device B . Under this alternative the device state is set to WAITING FOR KEY block that is waiting for the key that goes with the key id that is currently in the device metadata. The other alternative is that the device went from no key id in metadata at the time of system reboot last device open to having a key id in metadata which can occur when an unencrypted device becomes synchronized with an encrypted device. In this situation as well the device state is set to WAITING FOR KEY that is waiting for the key that goes with key id that is currently in the device metadata. In the WAITING FOR KEY state as is explained elsewhere herein some I O requests are permitted in accordance with the tables of B and with . For either of the above cases the next step block is to discard the keyblob in the device data structure if applicable i.e. if there is one to discard as a correct one will be pushed into the kernel to the Xcrypt Manager when the correct key is returned. The process of starting at block is used to look up the key that goes with the key id.

If security is OK a check is made to see if the metadata on the device can be read as part of verifying that the device is in fact encrypted block . If the metadata cannot be read then the attempt to turn encryption off fails and an error is returned block . If the metadata location can be read the metadata is checked to see if the eVLU is already unencrypted e.g. by checking whether the metadata includes a key id block . If the device state is already UNENCRYPTED then it is unnecessary to remove the encryption property and the process stops block .

If the device state is not UNENCRYPTED and the metadata location can be read then the device cannot be in the UNKNOWN state and is an encrypted device although the device itself could be in one of three states at this point ENCRYPTED WAITING FOR KEY and NO KEY block . An attempt is made to undo the eVLU encrypted property by attempting to remove the key id from the metadata region of the eVLU such as by setting a property of the key id to null and size to zero which indicates that the name value pair for the key id is no longer stored in the metadata.

If the attempt to undo the encryption property in metadata was unsuccessful block then an error is returned. Note that all processes from block on take place in the kernel . If the attempt was successful then the keyblob and key id are removed from the device data structure in the Xcrypt Manager within the I O filter driver of the kernel block . The device state is set in the device data structure to UNENCRYPTED. block and all I O to the LU is permitted in accordance with B and herein although ability to decrypt the encrypted data is now lost block .

In addition in one embodiment of the invention for example describes I O behavior of the Xcrypt Manager see as it relates to the state of a device. It will be appreciated by those of skill in the art that that Table of can be tailored for different platforms e.g. Solaris Windows IBM AIX HP etc. . Essentially the Xcrypt Manager can act as a filter for I O requests made to devices that it manages thus in other embodiments of the invention filtering modules implemented via software hardware or both are used to provide the functionality shown in .

As shown in the table of an in accordance with at least some embodiments of the invention when a device is in one of the known encrypted key states ENCRYPTED WAITING FOR KEY and NO KEY the I O request is processed based on one or more factors such as I O request type whether the I O request is a read or write and even the location on the device i.e. to an unencrypted region or an encrypted region to which the I O request is directed. Even for encrypted devices there may be areas or regions on the device where the data is not encrypted. For example in embodiments of the invention implemented on the Solaris platform a device formatted in accordance with the Solaris VTOC volume table of contents holds the label VTOC and geometry information in the first block block of the device. This first block is not encrypted for two reasons 1 so that the kernel layers below the I O filter driver e.g. code processes that are executing below the I O filter driver in the I O stack that need to access the information in this first block can do so and 2 so that a process application program etc. that is already running earlier in time than when the I O filter driver is loaded i.e. when the Xcrypt Manager is running or before the encryption key is available to the Xcrypt Manager can access block if necessary. Access to the information in the first block of the device as described above for the Solaris implementation or the above two examples does not in itself constitute a security violation. Another unencrypted region for VTOC formatted devices are areas at and beyond the alternate cylinders. Other platforms may have different unencrypted regions based on device format.

Allowing at least some types of I O requests access to encrypted devices and or at least portions of the unencrypted regions of encrypted devices including encrypted devices that may be in a state of waiting for an encryption key or a state of not having an encryption key even before the data encryption key DEK is ready known or available provides certain advantages and may help to overcome certain types of problems. For example some processes may execute above the I O filter driver such as a volume manager or cluster software and these processes may try to access an encrypted device e.g. an encrypted logical unit LU before the DEK is available. It can be problematic to fail or pend these types of I O requests just because the DEK is not yet known or available because failing or pending the I O requests may cause failures in these other processes. Higher software layers such as volume managers or cluster software can have failures that can be unworkable enough to cause significant delays system hangs and potentially other problems.

In addition allowing at least some types of I O requests to access a device in an UNKNOWN state that is where it is not known if the device is encrypted or not provides similar advantages and help with overcoming similar types of problems as well as problems that are unique to the unknown state. As an example of the latter type of problem as further described herein some types of I O requests can help a device in an UNKNOWN state transition to a known state that is a state where it is known whether or not a device is encrypted and if encrypted it is known whether or not the key is available or if the device is waiting for the key .

As the Tables of show certain types of I O requests directed to a device in a state other than UNENCRYPTED e.g. one of ENCRYPTED WAITING FOR KEY NO KEY OR Metadata MD UNKNOWN also referred to herein as UNKNOWN can be allowable I O requests even if the DEK is not available or in the case of the UNKNOWN state when it isn t known whether the device is encrypted or not. Generally I O requests that are candidates for being allowable even without the DEK include but are not limited to I O requests that do not require access to the encrypted data on an encrypted device that do not change the locations of encrypted and unencrypted regions on the device there are some exceptions to this discussed further below and or that are I O requests that are reads including SCSI reads to an unencrypted region. Another requirement for determining whether an I O request is allowable even if the DEK is not available is whether allowing the request still allows for protection of the encrypted data in the device and protection of the metadata.

For example one family of I O requests that can be allowed includes I O requests from higher level processes i.e. processes running above the I O filter driver in the I O stack where such requests do not actually require access to encrypted data itself but instead involve performance of actions such as I O control functions opening or closing devices checking device status configuring devices etc. Recall that the I O filter driver in at least one embodiment described herein provides functionalities such as encryption and data protection for such higher level processes but does not provide these functionalities for entities components that sit lower than the I O filter driver in the I O stack where such entities components are considered to be trusted entities components having a functionality that does not interfere with the I O filter driver providing encryption. The I O filter driver cannot control the behavior of the entities components that are lower in the I O stack but in accordance with the embodiments of the invention described herein the I O filter driver appropriately accommodates the entities components e.g. keeping block unencrypted in a Solaris VTOC platform as described above .

In addition as the table of shows other types of I O requests from higher level processes also may also be allowable such as set types of requests and reads to known fixed unencrypted regions of the device because such requests are non destructive to a given encrypted logical unit that is they cannot change any data on the device even if given access and or do not redefine or reconfigure regions on the device such as slice layout which regions are encrypted and which are not etc. . As the Table of states non destructive I O requests generally are defined to include any operation that gets data or state from a device or about the device. General read I O requests for example as well as direct or pass through SCSI operations like Inquiry Mode Sense and Reads are all considered to be non destructive types of requests. Conversely destructive is defined as anything not non destructive or anything that can potentially change device data or state.

Furthermore certain types of I O requests can be allowed to occur even if such requests have the potential for destructive action on the encrypted device provided the I O request being allowed has the ability to help the device transition from an UNKNOWN to a known state.

Referring now to B and for devices in the UNENCRYPTED state first column of the table the Xcrypt Manager acts simply as a pass through. Most I O requests are simply passed through and effectively forgotten. Note that per Pass Through means that the I O request is allowed without any special processing and I O completion for asynchronous I O is not monitored I O is dispatched down the I O stack As shows the only exception in this behavior is for a Device State Check.

Referring again to block of if a device s state is unencrypted and if the I O request is not a Device State Check then the I O request is passed through i.e. allowed regardless of its type.

Referring to for devices in the ENCRYPTED key state most I O requests that are not reads or writes generally will be passed through e.g. by the Xcrypt Manager because being in the ENCRYPTED state means that the DEK is available. Note that per reads and writes including SCSI reads and SCSI writes to encrypted or partially encrypted regions are handled according to herein. These I O requests are encrypted on dispatch for writes and are tracked i.e. are passed down the stack with appropriate action taken upon completion of the I O and decrypted upon completion for reads . In some instances e.g. per SCSI writes to an unencrypted region Device State checks writes to unencrypted regions and destructive non SCSI IOCTLs a given I O request can affect the state of the device and thus subsequent I O requests and so the I O request is tracked e.g. via the Xcrypt Manager and action is taken on the completion side i.e. when the I O request is complete . Examples of I O requests that can affect the state of device include for the Solaris platform a DKIOCSVTOC IOCTL or a write to block . For example on the Solaris platform such I O requests can impact the slice layout of the device and hence the encrypted versus unencrypted areas of the device. Other types of I O requests that can affect change encrypted regions of the device even in the ENCRYPTED state include for example destructive IOCTLS. Such destructive IOCTLS are operating system specific as will be appreciated by those of skill in the art but generally include IOCTLS that format or partition of a given device. Other IOCTLs are passed through.

If the answer at block is No the I O is checked block to see if it is a Device State Check. Note that per the Device State Check is a generalized mechanism that signals software components in the I O stack to detect and react to possible device state changes. Such changes include anything related to the device state attributes such as device size and identity. Device State Checks are performed based on platform requirements. For example an open may be a trigger on certain platforms.

If the answer at block is a Yes the I O request is a Device State Check then the I O request is allowed and tracked per block . When I O Done is signaled for the Device State Check processing goes to block of discussed previously . If the answer at block is a No checks are made in blocks and to see if the I O request is a read a write a SCSI CDB read or SCSI CDB write that is directed towards an unencrypted region. If the I O request is a read or SCSI CDB read to an unencrypted region it is passed through block . If the I O request is a write or SCSI CDB write to an unencrypted region the request is allowed and tracked per B block . That is per Note of when a device is in the ENCRYPTED state writes to unencrypted regions are tracked if such writes potentially could change the encrypted regions on the device else the writes to encrypted regions are passed through without tracking. For example writes to block for some operating systems potentially can alter the encrypted areas of the device.

If the answer at block is a No and after processing blocks and the I O request is not one of a read a write a SCSI CDB read or SCSI CDB write to an unencrypted region and the I O request is checked block to see if it is a write or SCSI CDB write to an encrypted region. If the answer at block is Yes processing proceeds block to block of described previously above . If the answer at block is No the I O request is checked block to see if it is a read or SCSI CDB read to an encrypted region. If the answer at block is Yes then processing proceeds block to block of described previously above .

If the answer at block is No the I O request is checked block to see if it is a destructive non SCSI IOCTL i.e. the other rows of the table of that can change the locations of encrypted regions of the device. If the answer is Yes then the I O request is allowed and tracked per B block and at I O Done block processing proceeds to block of as discussed above . If the answer at block is No than the I O request falls into one of the categories in the table of where it is permitted to pass through and processing ends block .

Referring again to in general the I O request behavior when the device is in the WAITING FOR KEY state is to 1 Pass through read I O requests to unencrypted areas and pend remaining read and writes. 2 Pass through non destructive IOCTLs including non SCSI non destructive IOCTLS i.e. other in and pend rest. This is highly platform dependent. 3 Pass though non destructive SCSI CDBs and pend rest. 4 Pass through Open Close SCSI Reset and SCSI Reset All. Pended I O requests are restarted when one of two things happen 1 The device state changes to ENCRYPTED e.g. the xcrypt userspace daemon passes down the corresponding keyblob thereby causing the Xcrypt Manager to set the device state to ENCRYPTED or 2 The device state changes to NO KEY either when the xcrypt userspace daemon returns an indication that no key was found or when the timeout on waiting for the key set in block of expires e.g. blocks causing the Xcrypt Manager to set the device state to NO KEY. Those pended I O requests are then restarted and reevaluated based on the treatment of I O requests for the ENCRYPTED or NO KEY states respectively.

Referring again to if the answer to both and is No a check is made block as to whether the I O request is one of Open Close SCSI Reset or SCSI Reset All. If the answer is Yes the I O request is passed through block .

If the answer at block is No the I O is checked block to see if it is a Device State Check. If the answer at block is a Yes the I O request is a Device State Check then the I O request is allowed and tracked per block . When I O Done is signaled for the Device State Check block processing goes to block of discussed previously . If the answer at block is a No a check is made at block to see if the I O request is a SCSI CDB read from an unencrypted region. If the answer at block is Yes it is passed through block . If the answer at block is no a check is made at block to see if the I O request is a read from an unencrypted region. If the I O request is a read from an unencrypted region i.e. the answer at block is Yes it is passed through block . If the answer at block is no then the I O request is pended until the key is available block .

Note that a device can get into a NO KEY state during Startup Mode. Startup Mode is defined below. When I O requests are pended during Startup Mode of a host on some platforms it could delay processing of some processes operating above the I O filter driver in the I O stack or it could delay the entire Startup Mode process. Thus on some platforms rather than setting the state to WAITING FOR KEY when the key id is retrieved if the Xcrypt Manager is in the Startup Mode the state of the device is set immediately to NO KEY.

Referring again to the general processing for I O requests when the device in the NO KEY state e.g. the behavior of the Xcrypt Manager for conditions in Post Startup Mode is to 1 Pass through read IO to unencrypted areas and fail the rest. 2 Pass through non destructive non SCSI IOCTLs the other row in table of and fail the rest. This is highly platform dependent. 3 Pass though non destructive SCSI CDBs and fail the rest. 4 Pass through Open Close SCSI Reset and SCSI Reset All. Note this behavior is similar to the behavior already discussed in connection with the WAITING FOR KEY state except that where I O requests are pended in WAITING FOR KEY they are failed for devices in the NO KEY state.

As shows there is one exception in the NO KEY state depending on whether the I O request is being sent when the Xcrypt Manager is operating in Startup Mode or not. Note that Startup Mode refers to a point in time when it is not known whether or not the xcrypt userspace daemon is running and available to lookup DEKs. Until the xcrypt userspace daemon indicates to the Xcrypt Manager that it is running the Xcrypt Manager operates in Startup Mode.

If the I O request is a non destructive SCSI CDB request and the Xcrypt Manager is in Startup Mode the only type of I O request that is permitted is the Inquiry request all others are failed. Such limited availability during Startup Mode helps to prevent higher level processes from attempting access to a device when such a process has no chance of succeeding with such access because no key is available. Inquiry thus is the only non destructive SCSI CDB that is allowed. If Inquiry were not allowed i.e. failing an Inquiry request it would cause higher level processes to assume that the device no longer exists or is temporarily disconnected. Once an encryption key eventually is retrieved it would be harder to recover the higher level processes. In contrast allowing an Inquiry from such a higher level process to succeed while failing all other SCSI CDBs produces the desired behavior of causing the higher level processes to try again later to access the device when it is more likely that the Xcrypt Manager has the key.

The following example problem and solution helps to further illustrate this issue. Consider an example where a higher level process configures itself and SCSI Inquires all devices and then makes further SCSI I O requests that also succeed. The higher level process then attempts read operations looking for its data on the device however that data is encrypted for ENCRYPTED devices and so the I O filter driver has to fail the IO as the key not available yet . This would then cause the higher level process to look for alternate copies of its data on the device and those attempts would fail and other apparent attempts to recover its data. This ultimately causes Startup Mode to take a long time.

A solution to the above example that works is for the Xcrypt Manager to allow a SCSI Inquiry INQ but fail all other SCSI I O requests even non destructive requests during Startup Mode. With some higher level processes after the process sends a SCSI INQ request the process follows by sending a SCSI Test Unit Ready TUR CDB. TUR is a SCSI command used to determine if a device is up and ready to accept read write requests. By allowing INQ but not allowing TUR or other SCSI commands i.e. by failing TUR the Xcrypt Manager permits the higher level process to know device information and to let the higher level process note the existence of the device but nothing more during early Startup Mode. This helps to discourage the higher level process from attempting any I O request or other action that requires the encryption key because there s no possibility of getting the encryption key at this point in time during Startup Mode . The higher level process then gives up on the device and Startup Mode proceeds. This helps to avoid a long Startup Mode delay. When TUR fails the higher level process attempts the command later after a timeout period. Eventually when the Xcrypt Manager has the key TUR will be allowed and the higher level device can attempt I O access to the device at a point when it will be successful.

Referring now to is a flow chart showing a method for processing I O requests for a device in a NO KEY state block in accordance with one embodiment of the invention. When an I O request is received block a check is made block to see if the I O request is a non destructive non SCSI IOCTL i.e. the other row of . If the answer is Yes the I O request is passed through block . Examples of non destructive non SCSI IOCTLs in one embodiment of the invention include but are not limited to DKIOCGVTOC and DKIOCINFO on the Solaris platform.

If the answer is No at block the I O request is checked block to see if it is a non destructive SCSI CDB. If the answer at block is Yes a further check is made to determine if the Xcrypt Manager is past Startup Mode i.e. is Post Startup Mode block . In the table of the terms Startup Mode and Post Startup Mode refer to an internal state in the Xcrypt Manager where the initial state is Startup Mode. The transition from Startup Mode to Post Startup Mode occurs when the encryption xcrypt userspace daemon sends its first message from user space to the Xcrypt Manager . Thus the Post Startup Mode state describes the knowledge of the Xcrypt Manager that the xcrypt userspace daemon is up and running and responding to lookup requests . The timing of the transition during the Startup Mode Post Startup Mode cycle is platform dependent and on some platforms affects how I O is handled.

Referring again to block if the I O request is a non destructive SCSI CDB and the Xcrypt Manager is in Post Startup Mode then the I O request is passed through block . If however the answer at block is No then a further check is made of the I O request to see if it is an Inquiry block . If the answer at block is Yes then the I O request is passed though block . If the answer at block is No than the I O request is Failed block and processing jumps to block fail I O request .

Referring again to block if the I O request is not a non destructive SCSI CDB the I O request is checked to see if it is one of Open Close Reset or Reset All block . If the answer is Yes the I O request is passed through block .

If the answer at block is No the I O is checked block to see if it is a Device State Check. If the answer at block is a Yes the I O request is a Device State Check then the I O request is allowed and tracked per block . When I O Done is signaled for the Device State Check block processing goes to block of discussed previously . If the answer at block is a No checks are made in blocks and to see if the I O request is a SCSI CDB read from an unencrypted region or a read from an unencrypted region. If the I O request is a SCSI CDB read from an unencrypted region or a read from an unencrypted region the I O request is passed through block else the I O request is failed block .

Referring again to the I O request handling for I O requests when the device is in the UNKNOWN state is to 1 Pass through read I O to unencrypted areas and fail the rest. 2 Pass through non destructive IOCTLs including non destructive non SCSI IOCTLs the other row in and fail the rest. 3 Pass through non destructive SCSI CDBs and fail the rest. 4 Pass through Open Close SCSI Reset and SCSI Reset All. The behavior in the UNKNOWN state is similar to that of the device in the NO KEY state with some minor distinctions. For example certain destructive CDBs are allowed e.g. the AAS SCSI CDB which is otherwise considered a destructive CDB because they can help transition devices into an accessible state. For example in one embodiment the invention is implemented using POWERPATH ENCRYPTION with RSA in an environment using the EMC INVISTA product a storage virtualization product . During migration of data from one system to another INVISTA devices show up as having an UNKNOWN state. Allowing certain destructive CDBs like the AAS advanced array set SCSI CDB help to transition the INVISTA devices into an accessible state. Of course as those of skill in the art will appreciate allowing certain destructive CDBs can be helpful in other implementations using other products as well.

If the answer at block is No the I O request is checked block to see if it is a destructive SCSI CDB that enables transitioning out of the UNKNOWN state e.g. an AAS request . If the answer at block is Yes then the I O request is passed through block . If the answer at block is No then the I O is checked block to see if it is a Device State Check. If the answer at block is a Yes the I O request is a Device State Check then the I O request is allowed and tracked per block . When I O Done is signaled for the Device State Check block processing goes to block of discussed previously .

If the answer at block is a No a check is made to determine if the I O request is a SCSI CDB read from a fixed unencrypted region . A fixed unencrypted region means that it is a region that is known to be unencrypted and is configured so that it is fixed as unencrypted i.e. is not reconfigurable to later become encrypted . An example of a fixed unencrypted region for many platforms is block block zero . For example with VTOC type devices in Solaris it is known that block is a fixed unencrypted region and this is true for some other platforms e.g. Windows and AIX for instance . Fixed unencrypted regions can be differentiated from non fixed unencrypted regions because some regions can transition from unencrypted to encrypted upon execution of certain I O requests or other instructions. For example often the end blocks of a device are variable unencrypted locations because the size of a device can grow. If the device state is UNKNOWN it is not possible to know whether the locations of the encrypted and unencrypted regions will change by the time the state of the device is known note that the Device State Checks described herein and or the process of described herein will track such changes in the encrypted and unencrypted regions . Hence the safest way to protect the encrypted data and the metadata is to permit reads only from fixed unencrypted regions.

If the I O request is a SCSI CDB read from a fixed unencrypted region then the I O request is passed through block . If the I O request is not SCSI CDB read from a fixed unencrypted region then the I O request is failed block .

The methods disclosed herein are especially useful in computer systems utilizing an enterprise storage system however one of ordinary skill in the art will appreciate that the features and principles of the present invention may be implemented in many other types of computer systems. One of ordinary skill in the art will also appreciate that features and principles of the present invention may be implemented in different components of a computer system with at least one associated data storage subsystem.

In describing the embodiments of the invention illustrated in the figures specific terminology is used for the sake of clarity. However the invention is not limited to the specific terms so selected and each specific term at least includes all technical and functional equivalents that operate in a similar manner to accomplish a similar purpose.

As those skilled in the art will recognize the invention described herein can be modified to accommodate and or comply with existing and or newly developed technologies and standards. In addition variations modifications and other implementations of what is described herein can occur to those of ordinary skill in the art without departing from the spirit and the scope of the invention as claimed. Further virtually any aspect of the embodiments of the invention described herein can be implemented using software hardware or in a combination of hardware and software.

It should be understood that in the Figures of this application in some instances a plurality of system elements or method steps may be shown as illustrative of a particular system element and a single system s element or method step may be shown as illustrative of a plurality of a particular systems elements or method steps. It should be understood that showing a plurality of a particular element or step is not intended to imply that a system or method implemented in accordance with the invention must comprise more than one of that element or step nor is it intended by illustrating a single element or step that the invention is limited to embodiments having only a single one of that respective elements or step. In addition the total number of elements or steps shown for a particular system element or method is not intended to be limiting those skilled in the art will recognize that the number of a particular system element or method steps can in some instances be selected to accommodate the particular user needs. Moreover the steps of the disclosed methods may be modified in any manner including by reordering steps and or inserting or deleting steps without departing from the principles of the invention.

The processes flow charts and flow diagrams provided herein do not depict the syntax of any particular programming language. Rather they illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein the particular sequence of steps described is illustrative only and can be varied without departing from the spirit and scope of the invention.

It is believed that computer programs based on the written description and methods of this invention are within the skill of an experienced developer. The various programs or program modules can be created using any of the techniques known to one skilled in the art or can be designed in connection with existing software. For example program sections or program modules can be designed in or by means of Java C C HTML XML or HTML with included Java applets. In addition one or more of such software sections or modules can be integrated into a computer system or browser software.

Although the invention has been described and pictured in a preferred form with a certain degree of particularity it is understood that the present disclosure of the preferred form has been made only by way of example and that numerous changes in the details of construction and combination and arrangement of parts may be made without departing from the spirit and scope of the invention as hereinafter claimed.

