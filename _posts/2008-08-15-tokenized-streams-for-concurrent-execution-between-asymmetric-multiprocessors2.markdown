---

title: Tokenized streams for concurrent execution between asymmetric multiprocessors
abstract: A method for executing an application program using streams. A device driver receives a first command within an application program and parses the first command to identify a first stream token that is associated with a first stream. The device driver checks a memory location associated with the first stream for a first semaphore, and determines whether the first semaphore has been released. Once the first semaphore has been released, a second command within the application program is executed. Advantageously, embodiments of the invention provide a technique for developers to take advantage of the parallel execution capabilities of a GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542192&OS=09542192&RS=09542192
owner: NVIDIA Corporation
number: 09542192
owner_city: Santa Clara
owner_country: US
publication_date: 20080815
---
The present invention generally relates to data processing and more specifically to streams for concurrent execution between asymmetric multiprocessors.

As is known processing elements including central processing units CPUs and graphics processing units GPUs may be configured to execute instructions in parallel. Instructions are usually generated by a compiler that translates e.g. compiles programming code written by a developer into a series of instructions. However many programming languages are sequential languages meaning that commands within the programming code are compiled into corresponding instructions that are executed sequentially based on the order of the commands provided in the programming code. Thus there is generally no way for a developer to take advantage of the parallel nature of the GPU.

Accordingly what is needed in the art is a system and method for exposing the parallel nature of processors to a developer.

Embodiments of the invention provide a method for executing an application program using streams. A device driver receives a first command within an application program and parses the first command to identify a first stream token that is associated with a first stream. The device driver checks a memory location associated with the first stream for a first semaphore and determines whether the first semaphore has been released. Once the first semaphore has been released a second command within the application program is executed.

Advantageously embodiments of the invention provide a technique for developers to take advantage of the parallel execution capabilities of a GPU. Using streams developers are able to create programming code that is executed in parallel when there are no dependencies between different sets of data. Using embodiments of the invention the overall efficiency of processing data is greatly improved.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs may output data to display device or each PPU may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .

Referring back now to each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. For example in a graphics application a first set of GPCs may be allocated to perform tessellation operations and to produce primitive topologies for patches and a second set of GPCs may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per vertex attributes. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed e.g. surface patch data primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . Work distribution unit may be configured to fetch the indices corresponding to the tasks or work distribution unit may receive the indices from front end . Front end ensures that GPCs are configured to a valid state before the processing specified by the pushbuffers is initiated.

A work distribution unit may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs for processing. By contrast in conventional systems processing is typically performed by a single processing engine while the other processing engines remain idle waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention portions of GPCs are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation a second portion may be configured to perform tessellation and geometry shading and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. Intermediate data produced by GPCs may be stored in buffers to allow the intermediate data to be transmitted between GPCs for further processing.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the partition units within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to one or more SPMs . In one embodiment each Shader Primitive Engine Mpipe SPM includes three modules a shader module primitive engine and Mpipe Controller MPC not shown .

In one embodiment each GPC includes a number M of SPMs where M 1 each SPM configured to process one or more thread groups. Also each SPM advantageously includes an identical set of functional units e.g. arithmetic logic units etc. that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SPM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM in which case processing will take place over consecutive clock cycles. Since each SPM can support up to G thread groups concurrently it follows that up to GXM thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SPM . This collection of thread groups is referred to herein as a cooperative thread array CTA . The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SPM uses space in a corresponding L1 cache that is used to perform load and store operations. Each SPM also has access to L2 caches within the partition units that are shared among all GPCs and may be used to transfer data between threads. Finally SPMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory.

In graphics applications a GPC may be configured such that each SPM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from L1 cache and is fetched from an L2 cache parallel processing memory or system memory as needed. Each SPM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A color preROP pre raster operations is configured to perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing engines e.g. primitive engines SPMs texture units or color preROPs may be included within a GPC . Further while only one GPC is shown a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing engines L1 caches and so on.

In graphics applications ROP is a processing unit that performs raster operations such as stencil z test and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be displayed on display device or routed for further processing by CPU or by one of the processing entities within parallel processing subsystem . Each partition unit includes a ROP in order to distribute processing of the raster operations. In some embodiments ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Persons skilled in the art will understand that the architecture described in in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

As described above the parallel processing subsystem may be configured to perform computations not related to graphics processing. For example a developer may write programming code containing operations that are to be executed by the parallel processing subsystem . The operations are executed by default in sequential order since many programming languages are sequential languages. The parallel processing subsystem however is capable of executing instructions in parallel. Embodiments of the invention provide a technique to expose this parallelism in an application programming interface API .

Embodiments of the present invention provide a software abstraction known as a stream that may be used to provide parallelism across execution of program commands. Streams enable applications to exploit parallelism between execution units that are not the same. In contrast threads generally enable applications to exploit parallelism between execution units that are identical. Threads in Win32 and Linux are intended to run on symmetric multiprocessing SMP machines where each CPU and or each CPU core has the exact same instruction set and has a uniform address space. Streams expose parallelism between compute cores SMs that process sub routines and the copy engines that can concurrently perform copy operations between system memory and local memory of the GPU while sub routines are processing.

For example when a developer understands that a first series of commands has no dependencies with a second series of commands then the developer may utilize the stream abstraction to direct the GPU to process the first series of commands in parallel with the second series of commands. More specifically a command in an application program may be designated by the developer to correspond to a particular stream by associating a stream token with the command. Various commands associated with different streams may then be compiled into one or more operations that are executed by the GPU. The operations that occur within the same stream occur sequentially but operations that occur within different streams may occur in any order. In contrast using conventional techniques program commands are processed sequentially in the order that they appear in the program.

For example a first series of commands may direct data to be copied from system memory to local memory of a GPU. A second series of commands may then direct the GPU to execute various functions using the data to modify the data. A third series of commands may direct the modified data to be copied from the GPU local memory to the host memory . In one embodiment a first copy engine may process the first series of commands an SPM may process the second series of commands and a second copy engine may process the third series of commands. The first and second copy engines are separate from the SPM and can simultaneously perform data transfers while the SPM is processing the data. By associating each of the first series the second series and the third series of commands with different streams a developer is able to take advantage of the parallel architecture of the GPU.

Additionally when computationally expensive tasks are involved executing a single command may take a significant amount of time. For example a financial analysis program may include three commands. A first command may copy stock data associated with each stock listed on a stock exchange from the system memory to the GPU local memory. A second command may process the stock data to modify the stock data. A third command may copy the modified data from the GPU local memory to the system memory . With conventional approaches the entire stock data would be copied to the GPU local memory in one large copy operation then the second command would be executed by the GPU to modify the stock data and finally the entire set of modified data would be copied to the system memory . For example each of these 3 operations may be very computationally expensive because of the large amount of data involved.

In contrast alternative embodiments of the invention allow for sub streams to be utilized to further break up computationally expensive tasks into several portions when there are no dependencies among those portions. Continuing with the stock analysis example there may be no dependencies between individual stocks in the context of executing the second command. In such a situation further parallelism may be achieved by breaking apart the stock data and associating each portion with a different sub stream. In this fashion copy operations corresponding to a first portion of the stock data may be performed in parallel with execution operations corresponding to a second portion of the total stock data and copy operations corresponding to a third portion of the stock data. Implementing sub streams hides the costs associated with downloading a large amount of data to the GPU local memory because the copy operations are performed in parallel with operations that modify the data.

Using streams or sub streams is advantageous because additional data parallelism may be achieved. Commands within an application programs that would normally be executed serially may be performed in parallel to decrease the amount of time needed to finish executing the application program. In one embodiment highly efficient stream processing may be achieved by implementing approximately eight to twelve concurrent streams or sub streams. Additionally streams unlike threads may be implemented across non uniform hardware architectures thereby providing more flexibility than threads.

The GPU includes one or more SPMs and copy engines A B. The GPU may be configured to access the GPU local memory when executing instructions. The copy engines A B may be configured to perform copy operations between the local memory and the system memory . In one embodiment a first copy engine A is configured to perform copy operations from the system memory to the local memory whereas a second copy engine B is configured to perform copy operations from the local memory to the System memory . In alternative embodiments the copy engines A B are bi directional and may copy data both from the system memory to the local memory and from the local memory to the system memory .

In one embodiment dependencies between streams may be resolved using semaphores. A first channel may include a buffer of pending operations to be executed by the SPMs . A second channel may include a buffer of pending operations to be executed by a first copy engine A. Additional channels may include buffers of pending operations to be executed by additional copy engines e.g. copy engine B . A semaphore may be acquired from a memory location when a particular stream is being executed and the semaphore may be released when execution of the stream is complete. In this fashion the device driver is able to determine whether a stream is in the process of executing operations or whether execution of all operations associated with a stream is complete by querying a memory location associated with the stream for an acquired or released semaphore.

Advantageously embodiments of the invention provide a technique for developers to take advantage of the parallel execution capabilities of a GPU. Comparing the timing diagrams of the total time to finish executing the operations is greatly decreased when utilizing techniques involving streams.

Several API mechanisms are provided to aid developers when using streams in application programs. A first API call is designated as cuStreamQuery stream . cuStreamQuery takes a stream as an input and returns a value indicating whether each operation associated with the stream has finished executing. A developer may use this API call to poll the GPU to determine if a particular stream has finished executing. In one embodiment to determine whether a stream has finished executing cuStreamQuery may query a memory location associated with the semaphore associated with the stream. If the semaphore is acquired then the stream is not finished executing. If the semaphore has been released then the stream is finished executing. For example cuStreamQuery may be used for applications that are exploiting CPU GPU concurrency. There may be tasks designated for execution by the CPU other than the task of submitting work to the GPU and receiving results back. Such applications may want to check in with the GPU to see if the GPU is done with the work for a given stream. The CPU may want to submit more commands for the stream process results that are now available or both. If processing the stream by the GPU is not complete then the application can perform other tasks e.g. manage network traffic.

A second API call is designated as cuStreamSynchronize stream . cuStreamSynchronize takes a stream as an input and blocks execution of subsequent commands in the application program until the stream has finished executing. No subsequent API calls are processed until the specified stream is finished executing. cuStreamSynchronize functions as a blocking mechanism that halts execution of all subsequent commands in the application program until the input stream has finished executing. In one embodiment cuStreamSynchronize may determine whether a particular stream has finished executing using semaphores as described above. cuStreamSynchronize is implementable in terms of cuStreamQuery . For example applications that might otherwise find themselves busy waiting on cuStreamQuery because they do not have anything else for the CPU to do. The driver can perform this synchronization more efficiently.

A third API call is designated as cuStreamWaitStream streamA streamB . cuStreamWaitStream takes two streams as inputs streamA and streamB. cuStreamWaitStream instructs streamA to wait until all operations associated with streamB have finished executing before operations associated with streamA can begin executing. cuStreamWaitStream may be used when there are dependencies between streamA and streamB. Other subsequent commands in the application program that do not depend on streamB however may continue to be executed. In one embodiment cuStreamWaitStream may determine whether a particular stream has finished executing using semaphores as described above. The functionality of cuStreamWaitStream is different from the functionality of cuStreamSynchronize because when using cuStreamWaitStream only those commands that have a dependency on streamB are halted. In constrast cuStreamSynchronize is a global halt operator that halts all subsequent commands from being executed until the particular stream is finished executing. cuStreamWaitStream may be useful for applications where some operations may be performed concurrently but others cannot so synchronization must be performed on the GPU side. Referring to if there were a computation C g A B streamX to be performed after command then stream X associated with this computation would have to wait until commands and both have completed. If streamX is associated with this computation then a call to cuStreamWaitStream may be inserted into the set of operations to be performed by streamX so that the computation waits on streamY to finish executing. Since the computation is performed in streamX the ordering within the stream guarantees that the dependencies are dealt with correctly. For example the commands may include 

In alternative embodiments a developer could use a third stream and call cuStreamWaitStream twice once for each of streamX and streamY.

As described above alternative embodiments of the invention allow for sub streams to be utilized to further break up computationally expensive commands into several sub commands when there are no dependencies among those sub commands. Continuing with the stock analysis example there may be no dependencies between individual stocks in the context of executing the first command copy data A to GPU the second command execute stock A to generate data A or the third command copy data A to system memory . Thus each of the three command may be divided into sub commands that operate on only a portion of the total data. Each sub command may then be associated with a sub stream. As shown in 

Advantageously embodiments of the invention provide a technique for developers to create programming code that is executed in parallel when there are no dependencies between different sets of data to achiever better efficiency.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

