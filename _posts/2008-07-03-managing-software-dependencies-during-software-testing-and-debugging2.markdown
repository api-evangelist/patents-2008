---

title: Managing software dependencies during software testing and debugging
abstract: A solution for managing software dependencies during software testing and debugging includes a capture module configured to capture a software call stack of a software execution environment, each software call of the software call stack including a call signature and a call result. The solution defines a set of proxied software calls within the software call stack suitable for simulating conversation responses to runtime software calls by a target application. Once a set of proxied software calls is defined, a playback module recognizes runtime software calls by the target application that are within the set of proxied software calls and responds to the recognized runtime software call with a captured call result corresponding to the recognized software call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09594670&OS=09594670&RS=09594670
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09594670
owner_city: Armonk
owner_country: US
publication_date: 20080703
---
This invention relates to testing software applications and has particular application in a software test environment where the software being tested has dependencies on many applications.

Computing systems are comprised of many hardware and software components and dependencies between software applications are now common. An application may depend on another application running on the same hardware enclosure or on applications executing anywhere within a Local Area Network LAN or Wide Area Network WAN . A thorough test of a software application and any interfaces or dependencies is important to the successful delivery of a software product. Conventional technology can require that the dependencies of an application be present in the system in order for the application to communicate with each of its dependencies.

In a production runtime environment the dependent applications are present and the maintenance of the dependencies is relatively low. Once the applications are loaded changes to the system are generally infrequent. For this reason a production system is a good testing environment. However a production system running live code with real customers and disrupting customers from doing their work due to a software bug can have a significant financial impact. A second issue with a production environment is that the production facilities may be geographically removed from the developer testers or due to security reasons removed from developers and testers needing to test an application. A testing or debugging environment on the other hand is dynamic. Frequent changes in software and hardware are common. It is built and maintained specifically for the purpose of testing hardware and software. Access to a test system is generally more open than that of a production facility. In a test lab code can be instrumented using intrusive and non intrusive tools. The system can be rebooted or restarted generally at will to debug or test an application.

A rigorous and exhaustive test tests the logic paths varying the inputs validating the outputs and testing the calls to and returns from dependent applications. A thorough test of the application may include testing under many different test scenarios such as 1 initial power on 2 rebooting 3 reset 4 power cycle 5 hardware malfunction and 6 software aborts to name a few.

For the same reasons that a test lab is a good test environment the ability to frequently reboot reset and frequent hardware and software changes made at will make a test environment a difficult environment for testing. Due to the frequent reboots and code changes the testers need to assume that the dependencies and applications may not be running and therefore put checks in place to verify that the application dependencies are running. This can be an enormous task requiring many man hours to verify that the dependencies are executing. If a dependency or application fails time is spent debugging the malfunction and it may require special skills to determine the cause of the error for example it may require someone with special knowledge of the dependent application to determine why the application failed. Due to the number of dependencies that a single application can have determining the cause of the error can be very time consuming and resource intensive. In one implementation a developer writes scripts or programs to discover if the dependent application is loaded. While this automates the dependency discovery process separate code must be written to check that each dependency is loaded and running before an application is tested. If a dependency is not running a tester needs to investigate why.

Another issue that arises when testing is that the testers may not have access to all of the dependent applications either due to licensing issues or the financial cost of acquiring the dependent applications for the testing environment.

Therefore from the foregoing discussion it should be apparent that a need exists for an improved testing tool. A test harness that can identify the dependent applications input parameters and return values. A test harness that can present the software calls made by a target application to the dependent applications that the target application calls. Preferably such a method would in certain embodiments include the capability to save and playback the same return value for a given set of input parameters.

The present invention has been developed to provide an apparatus method and system for managing software dependencies during software testing and debugging.

The apparatus for managing software dependencies during software testing and debugging is provided with four modules configured to functionally execute the necessary steps to capture a software call stack present the captured call stack to a user recognize a software call and respond with a captured call result.

The capture module in one embodiment captures a software call stack of a software execution environment each software call of the software call stack comprising a call result. Each software call may also comprise a call signature.

The determination module in one embodiment defines a set of proxied software calls within the software call stack suitable for simulating conversation responses to runtime software calls by a target application.

The playback module in one embodiment recognizes a software call by the target application that is within the set of proxied software calls and responds to the recognized software call with a captured call result corresponding to the recognized software call.

The determination module in one embodiment includes a user interface module that presents the captured software call stack to a user. An identification module identifies in response to user input the set of proxied software calls from the target application within the software call stack that reference an external software application the target application defined by the user.

The capture module in another embodiment stores each software call of the proxied set of software calls in persistent storage each software call comprising at least one of a call name a call parameter set and a call result.

The capture module in another embodiment captures a pre call global variable set representative of a state of global variables in the execution environment prior to calling the external application. In addition the capture module captures a post call global variable set representative of a state of the global variables in the execution environment after calling the external application. Further the capture module captures the call result from the software stack after calling the external application and stores the pre call global variable set post call global variable set and call result.

The capture module in another embodiment stores each call signature and a conversation result as a call signature record in a relational database. The captured call signature comprises a key for a table storing a plurality of software call stack records. The call signature comprises the call name call parameter set and the pre call global variable set and the conversation result comprises the call result and the post call global variable set.

The identification module in another embodiment filters the call signature records retrieved from the relational database to produce a set of playback call records comprised of a call signature and a conversation result associated with the target application identified by the user.

The playback module in another embodiment watches the runtime software stack for a runtime call signature originating from the target application to the external application. In addition the playback module searches the playback call records for an exact match between the runtime call signature and a call signature of the playback call records.

In one embodiment the call signature comprises at least a call name a call parameter set and a global variable set. The playback module adjusts global variables in the software execution environment to reflect the values of global variables in the global variable set.

The method for managing software dependencies during software testing and debugging may in one embodiment capture a software call stack of a software execution environment. Each software call of the software call stack comprises a call signature and a call result. Additionally the method presents the captured software call stack to a user by way of a user interface module and defines a set of proxied software calls within the software call stack suitable for simulating conversation responses to runtime software calls by a target application. In addition the method identifies in response to user input a set of proxied software calls from the target application within the software call stack that reference an external software application. Further the method recognizes a software call by the target application that is within the set of identified software calls and responds to the recognized software call with a captured call result corresponding to the recognized software call.

In one embodiment the method includes capturing a software call stack to a user and identifies in response to user input the set of software calls from the target application and within the software call stack that reference an external software application.

In another embodiment the method stores each software call of the software call stack in persistent storage each software call comprising at least a call name a call parameter set and a call result.

The capture method in another embodiment captures a pre call global variable set representative of a state of the global variables in the execution environment prior to calling the external application. Further the method includes capturing a post call global variable set representative of a state of the global variables in the execution environment after calling the external application. In addition the method captures the call result from the software stack after calling the external application and storing the pre call global variable set post call global variable set and call result.

In another embodiment the method stores each call signature and a conversation result as a call signature record in a relational database. The captured call signature comprises a key for a table storing a plurality of software call stack records. The call signature comprises the call name call parameter set and the pre call global variable set. The conversation result comprises the call result and the post call global variable set.

The method for managing software dependencies during software testing and debugging may in one embodiment filter the call signature records retrieved from the relational database to produce a set of playback call records. The records comprise a call signature and a conversation result associated with the target application identified by the user.

The method may in one embodiment watch the runtime software stack for a runtime call signature originating from the target application to the external application. Additionally the playback method may search the playback call records for an exact match between the runtime call signature and a call signature of the playback call records.

The method may in another embodiment adjust global variables in the software execution environment to reflect the values of global variables in the global variable set.

The system for managing software dependencies during software testing and debugging in one embodiment may include a processor and memory in communication with the processor. The memory may comprise a java virtual machine JVM configured to execute at least one target application and one or more java software applications external to the target application. The JVM configured to implement a Java Platform Debugger Architecture JPDA and execute a test harness plugin. The system may include the test harness java plugin comprising a capture module configured to capture a software call stack of a software execution environment. Each software call of the software call stack may comprise a call signature and a call result.

The method for managing software dependencies during software testing and debugging may in one embodiment provide a set of proxied software calls from a target application within a software call stack that reference an external software application. The software call stack captured from a first software execution environment and each software call of the software call stack comprise a call name a call parameter set and a call result. In addition the method may include executing the target application within a second software execution environment. In another embodiment the external software application is inaccessible to the target application executing within the second software execution environment. The method may recognize a software call by the target application that is within the set of provided software calls and respond to the recognized software call with a captured call result. The captured call result corresponding to the recognized software call such that the captured call result substitutes for a runtime call result of the software call.

Many of the functional units described in this specification have been labeled as modules in order to more particularly emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like.

Modules may also be implemented in software for execution by various types of processors. An identified module of executable code may for instance comprise one or more physical or logical blocks of computer instructions which may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose for the module.

Indeed a module of executable code may be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and maybe embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices.

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus appearances of the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment.

As will be appreciated by one skilled in the art the present invention may be embodied as a method system or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product on a computer usable storage medium having computer usable program code embodied in the medium.

Any suitable computer usable or computer readable medium may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus device. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain store communicate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer usable program code may be transmitted using any appropriate medium including but not limited to the Internet etc.

Computer program code for carrying out operations of the present invention may be written in an object oriented programming language such as Java Smalltalk C or the like. However the computer program code for carrying out operations of the present invention may also be written in conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Furthermore the described features structures or characteristics of the invention may be combined in any suitable manner in one or more embodiments. In the following description numerous specific details are provided such as examples of programming software modules user selections network transactions database queries database structures hardware modules hardware circuits hardware chips etc. to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention may be practiced without one or more of the specific details or with other methods components materials and so forth. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

The target application may comprise a workstation application a servlet desktop application a server application a client application a web based application and the like. The target application is configured to run on similar computer hardware to that used in a production environment.

In one embodiment a target application is written in a programming language such as Java C C or the like and executes in the software execution environment . The target application includes at least one dependency on an external application . A dependency exists when the target application initiates a software call to a function or method of the external application . The software call from the target application to a function or method of the external application contains the function call name and the function call parameter set. The parameter set comprises values or pointers to values that the target application supplies to the function in the external application 

In addition the target application may include global variables used to maintain additional data for the function or method of the external application . The called function of the external application retrieves the parameter values passed from the target application and may optionally adjust or read the values of the global variables. The called function returns a call result to the target application.

In one embodiment the target application may be a database application spreadsheet application web application or the like and interfaces with other applications within the same physical enclosure or outside of the physical enclosure and is connected through a network. The target application may need to pass data control messages values or the like to external applications running on the same physical enclosure or anywhere on a network. The target application relies on one or more external applications to complete the purposes and functions of the target application . This reliance is referred to herein as a dependency. The interface between the target application and external applications may be defined using a variety of protocols or techniques including remote procedure calls messaging frameworks an Application Programming Interface API or the like.

In dependencies that utilize an API of the external application the API includes a function name and parameter set comprising values or pointers for passing information between the target application and the external applications . In this embodiment the target application is dependent on the external applications to complete parts of the processes of the target application . The target application calls an external application . The external application retrieves the parameter set and executes the dependant code. The external application then returns control to the target application . As explained above however the external application may not exist or may not be maintained to the proper version in a test lab that is testing the target application .

The external applications may execute in the software execution environment . In one embodiment the external applications may be a workstation application a servlet a desktop application a server application a client application a web based application and the like. The external applications are configured to run on similar computer hardware to that used in a production environment. The external applications may contain code that a target application is dependent upon. In one embodiment the external applications contain a function that the target application will call through an API.

An external application is a software application that a target application needs to have loaded. The external application is responsive to software calls from the target application . The target application depends on the external application for computing and returning of values.

In one embodiment the software execution environment may comprise a production environment consisting of a small or large system of laptops workstations or mainframe computer. The software execution environment is configured to execute applications and a Database Management System DBMS . The software execution environment may be connected to the World Wide Web WWW the target application may be executing in a geographically removed location from the external applications . In another embodiment the software execution environment may be a test environment. The testing environment containing the target application and may contain none or some of the external applications 

A test harness executes in the software execution environment and watches the software calls of the target application . The test harness may comprise a Java plugin configured to watch the software stack calls between target application and an external application 

In one embodiment an apparatus for managing software dependencies during software testing and debugging the test harness executes within the software execution environment to enable the target application to be tested with or without executing an external application . The test harness serves as a proxy for the external applications provided conversations between the target application and an external application have been previously captured. The test harness is configured to respond to software calls from the target application to the external application in the same manner as the external application would respond if the external application was responding to the software call. In this manner the test harness is used for testing of the target application without executing the external application . The external application need not even be present in the software execution environment .

In one embodiment the test harness is configured to capture conversations between the target application and one or more external applications . A conversation includes the messages between the target application and an external application and the messages back from the external application to the target application. The test harness stores the conversations such that they can be retrieved for subsequent testing scenarios.

In one embodiment the test harness presents captured conversations to a user in the form of a captured software call stack. The user identifies conversations in the captured software call stack that correspond to a software dependency upon a particular external application . The identified conversations define a proxied set of software calls that the test harness uses to simulate the conversation responses from the particular external application 

During testing of the target application the test harness watches conversations between the target application and the external applications for a match of the user identified conversation. This match occurs when the software calls on a software call stack match the proxied set of software calls for the user identified conversation. When a match occurs the test harness manages the software dependency.

In one embodiment the capture module stores each software call from the target application to the external application in a DBMS record. The software call in one embodiment comprises a call name a call parameter set and a call result. Optionally the software call may also include a set of global variables. The software call is unique for each software call to an external application 

In one embodiment the capture module captures the software call from the target application to the external application during execution of the target application . To perform the capture the capture module requires that the external application be executing and able to respond to the software call. In this embodiment no code additions or modifications to the target application or external application are required. In one embodiment the capture module watches the stack flow of a call stack captures the software call and saves the software call in the DBMS.

The external application picks up the value of the parameters and fulfills the software call. The external application returns the call result to the target application . Once the call result is on the call stack the capture module captures the call result value. With the captured call result the capture module has the complete conversation. In one embodiment the capture module saves the captured conversation in a DBMS record.

Exemplary pseudo code below illustrates the function of the capture module in capturing the software call stack comprised of a call name a call parameter set and a call result. Optionally the software call stack may include a pre call global variable set and a post call global variable set.

In one embodiment the determination module identifies a set of software calls within the software call stack suitable for simulation of a conversation between a target application and an external application . These software calls herein referred to as a set of proxied software calls simulate a conversation response to a runtime software call from the external application back to the target application .

In one embodiment the capture module captures a set of software calls and passes the set of software calls to the determination module and or a storage repository not shown . The determination module identifies all of the software calls as a set of proxied software calls for simulation of a conversation response to a runtime software call.

In another embodiment the determination module may through programmed logic identify some or all of the software calls as a set of proxied software calls. In addition to or alternatively a software hard coded switch may be selected to identify software calls as proxied calls for simulation. In this embodiment recompiling and relinking of the determination module may be necessary to modify the hard coded switch.

Advantageously the present invention saves time needed to debug test software by reducing the need to install update maintain and replicate the external applications in every test environment. The determination module communicates with the playback module and or a storage repository not shown to provide the proxied software calls.

The playback module serves as proxy for one or more external applications that the target application may depend on. In one embodiment the playback module operates with a target application in a software execution environment that does not include one or more of the external applications . The playback module communicates with the storage repository to retrieve the set of proxied software calls and respond to software calls from the target application to the external application on behalf of the external application

In one embodiment the playback module monitors the software stack for runtime software calls that match one of the software calls in the set of proxied software calls. When a runtime software call matches a proxied software call the playback module responds to the software call from the target application with a stored call result. The playback module returns the call result instead of the external application receiving the call and responding. In this manner the operations of the external application are simulated but the external application is not required to be executing within or in communication with the execution environment .

In one embodiment with the apparatus in playback mode the playback module executes a call to the Java Platform Development Architecture JPDA to watch the runtime software calls and compare these software calls with the set of proxied software calls.

In one embodiment the user interface module enables a user to interact with the test harness to define the proxied set of software calls. The user interface module communicates with the capture module and or a storage repository not shown to access stored software calls. In one embodiment the user interface module permits the user to select from a set of captured software calls the software calls that the user wants to have simulated. Alternatively or in addition the user interface module allows the user to define the set of proxied software calls prior to the capture of the software calls by the capture module .

In one embodiment the user interface module presents the captured software calls to a user in a user interface. The user interface may be a graphical user interface GUI text file a command line interface or the like. In such an embodiment the capture module may capture all software calls from the target application to any of the external applications . The user interface module may then allow the user to select the set of proxied software calls that will be simulated from among those captured software calls.

Alternatively or in addition the user interface module may define a set of software calls that the capture module watches for during a capture phase when both the target application and one or more external applications are executing. The user interface module may permit the user to select all software calls from the target application to a particular external application select certain software calls from the target application to a particular external application or a combination of software calls from the target application to two or more external applications either in whole or in part.

The selection and presentation mechanisms used by the user interface module may be implemented using a variety of user interface techniques well known to those of skill in the art including drop down boxes summary detail lists and the like. The user identifies from the presented software call stack proxied software calls to be simulated. As explained in certain embodiments certain proxied software calls may still need to be captured prior to performing the simulation. The proxied software calls may be stored in a playback record in the DBMS.

In one embodiment the identification module filters the software calls presented to the user. The identification module may filter the software calls by call name call parameter set and or call result. The user identifies from the presented software calls the set of proxied calls to simulate during runtime.

The pseudo code below illustrates the function of one embodiment of the playback module in watching the runtime software call stacks.

The method continues and the user interface module presents the set of proxied software calls and or the captured software calls to the user. By interacting with the identification module the user identifies the set of proxied software calls. The user may accept the defined set presented or modify or refine the set as desired.

At this stage the method is set up to begin simulating conversations between the target application and the one or more external applications . Advantageously the user interface module provides the user with a high level of flexibility and control regarding which conversations are simulated. Consequently the target application can be tested with some all or none of the dependent external applications operating or accessible to the software execution environment .

Next the target application is tested and the playback module recognizes software calls made during runtime of the target application that match members of the proxied set of software calls. The playback module intercepts the calls and responds to the software calls by providing the captured call result to the target application . illustrates one embodiment of a method for managing software dependencies during software testing and debugging. The operations may be implemented by the executed operations of a computer program product. The method begins and the playback module receives a proxied set of software calls . The proxied set of software calls may come from the determination module .

Optionally the playback module receives the proxied set of software calls from a repository such as a database a website a data file a configuration file an XML file a text file not shown or the like. At this stage the playback module is setup to recognize a runtime software call by the target application . The method continues and the playback module watches the software call stack for a match with a proxied software call.

Next the playback module recognizes if there is a match between a runtime software call and a proxied software call. If a match is recognized the playback module responds to the runtime software call with the call result . Optionally as part of responding the playback module may adjust global variables in order to more fully simulate the actions the external application would perform. If a match is not recognized the method processes the runtime software call normally. If the runtime software call does not match and the runtime software call is a call to an external application the external application is called. Next the method determines if testing is continuing if so the method returns to watching runtime software calls if not the method ends .

In certain embodiments of the system one or more of the external applications target application capture module and determination module may not be included in the same system . Instead these components may be distributed among other hardware or network devices in order to perform their respective functions. In this manner the present invention may be implemented in a variety of configurations while still facilitating the management of software dependencies during software testing and debugging.

In one embodiment the second software execution environment not shown differs from a first software execution environment . The first software execution environment may have the target application test harness and external applications . The second software execution environment may have the target application and test harness but may lack some or all of the external applications . The first software execution environment may be a production environment where a user captures the software call stack from a target application to external applications . The captured software call stack is transported to a second software execution environment not shown . In this embodiment the target application is debugged without the presence of the external applications in the execution environment.

The target application executes in the software execution environment. The target application makes a runtime software call to an external application . In this embodiment the second software execution environment is executing and the application does not have access to the external application . The playback module recognizes the runtime software call from the target application to the external application as one matching a member of the set of proxied software calls. The playback module responds by sending the call result to the target application . In one embodiment this software call result is the software call result captured in the first software execution environment.

Advantageously the capture of the software call stack in a first execution environment provides the user with a high level of flexibility and control regarding which conversations are simulated. Consequently the target application can be tested with some all or none of the dependent external applications operating or accessible to the software execution environment.

In another embodiment the determination module may read a configuration file such as an XML file text file or the like to identify a set of proxied software calls. For example the configuration file may define the set of proxied software calls as those calls directed towards a particular external application . Alternatively or in addition the configuration file may define the set of proxied software calls as those calls directed towards an external application having a certain characteristic. In this embodiment the configuration file may be generated in a production environment and returned to a test environment minus the external applications . This permits an engineer to debug a target application in a test environment without the external applications . Alternatively an engineer in a test environment may generate test configuration files with a proxied set of software calls for distribution to production environments for software testing.

The pseudo code below illustrates the function of the playback module in a second software execution environment. In one embodiment the second software execution environment is an environment without the external applications .

The device hereinafter by way of example a server may include one or more processors or CPUs . The CPU may be operably coupled to one or more memory devices . The memory devices may include a non volatile storage device such as a hard disk drive or CD ROM drive a read only memory ROM and a random access volatile memory RAM .

The server in general may also include one or more input devices for receiving inputs from a user or from another device. The input devices may include a keyboard pointing device touch screen or other similar human input devices. Similarly one or more output devices may be provided within or may be accessible from the server. The output devices may include a display speakers or the like. A network port such as a network interface card may be provided for connecting to a network.

Within an electronic device such as the server a system bus may operably interconnect the CPU the memory devices the input devices the output devices the network card and one or more additional ports. The ports may allow for connections with other resources or peripherals such as printers digital cameras scanners wireless devices and the like.

In the depicted embodiment the CPU Storage ROM and RAM combined with Input Devices Output Devices and Network Card may comprise a processing subsystem. In this embodiment the first software execution environment may execute in the depicted embodiment . The first software execution environment may include a target application test harness and external applications . The test harness may include a capture module determination module and playback module. The determination module may include a user interface module and identification module.

In the electronic device described above the test harness plugin may execute calls to the Java Platform Debugger Architecture JPDA . The test plugin may call the JPDA to capture software calls from the target application to the external applications in the first software execution environment . The test harness plugin may simulate calls from the target application in a second software application environment.

