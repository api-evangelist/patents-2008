---

title: Extracting previous messages from a later message
abstract: A message extraction system is described that extracts a previous message from a current message in a conversation thread. The message extraction system receives a current message and identifies a previous message candidate within the current message. The system determines a checksum of the previous message candidate and compares the determined checksum to a previously stored checksum of the previous message. If the two checksums match, the system extracts the previous message from the reply message rather than from the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08661082&OS=08661082&RS=08661082
owner: Microsoft Corporation
number: 08661082
owner_city: Redmond
owner_country: US
publication_date: 20080620
---
Collaboration servers provide interaction between users typically within an organization. For example an electronic mail server such as Microsoft Exchange provides electronic mail delivery shared calendaring and other services to users within a corporation or other enterprise. Using a collaboration server users can send email back and forth schedule meetings store contact lists and so forth.

Email and other forms of communication such as public folder and message forum posts often involve conversations. In a conversation one or more participants create messages on a particular topic. Each message after the original message that starts the conversation is a reply to either the original or a later message in the conversation. For example a participant Alicia may send a message or post to a forum regarding a topic such as politics. A participant Bob may then reply to Alicia s message. Another participant Carl may then reply to either Alicia or Bob s message and Alicia and Bob may make additional replies based on replies to their respective messages. The result is a large tree of messages that make up a conversation on the particular topic.

When a new participant enters a conversation he she often wants to go back and read what contributions previous participants have made to the conversation. For example the new participant may want to avoid adding redundant information that other participants have already contributed. Conversations can be very large and the new participant may open not only the latest message but also all of the previous messages in the conversation. It is not unusual for a conversation to contain 50 or more messages.

One of the most frequent problems for email and collaboration servers is scalability. Email and collaboration servers often provide services to thousands of users many of whom may simultaneously log on and attempt to access the services. The high level of concurrent use can exceed the server s available resources. The amount of information that can be held in memory often determines the number of users to which a server can scale because accesses to secondary storage devices e.g. hard drives often incur delays that are substantially greater than memory e.g. 100 . Thus when application developers build email and collaboration servers it is often a design goal to reduce the frequency of accesses of secondary storage devices.

Conversations compound the problem. When a conversation participant accesses a message in a conversation and begins reading through the conversation the participant may request many messages in the conversation stored by the server. For example a user may view the 50 previous messages in a particular conversation. Multiply this by the thousands of users that may be accessing the server simultaneously and the requests may quickly exceed the amount of messages that the server can keep in memory or the number of input output I O requests that the server can handle. Thus the server will inevitably end up accessing slower secondary storage devices which in turn reduces the number of users to which the email and collaboration server can provide services. The users of the server may also notice a degraded level of service based on the exhaustion of resources at the server.

A message extraction system is described that extracts a previous message from a current message in a conversation thread. The message extraction system receives a current message for which a conversation participant wants to open a previous message. The system identifies a previous message candidate within the current message. The system determines a checksum of the previous message candidate. The system compares the determined checksum to a previously stored checksum of the previous message. If the two checksums match the system provides an indication that the previous message candidate matches the known previous message and extracts the previous message from the reply message rather than from the server. Thus the message extraction system avoids accessing the disk or other secondary storage at the server to retrieve the previous message text.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A message extraction system is described that extracts a previous message from a current message in a conversation thread. Because each reply message in a thread typically contains the text of the previous message it is not necessary to access the previous message from the server if the content of the message can be verified as not having changed. The message extraction system receives a current message for which a conversation participant wants to open a previous message. For example a user may open the second message in a conversation and request that the system display the firmessage in the conversation. The system identifies a previous message candidate within the current message. For example the system may search for indented text or an Re line i.e. Latin in the matter of that often prefaces a message to which a reply is directed. The system determines a checksum of the previous message candidate. For example the system may calculate a CRC32 checksum of the text of the previous message candidate. The system compares the determined checksum to a previously stored checksum of the previous message. For example the system may store a checksum of each message in a conversation e.g. by inspecting the body of a message and adding the checksum when the message is sent . If the two checksums match the system provides an indication that the previous message candidate matches the known previous message and extracts the previous message from the reply message rather than from the server. Thus the message extraction system avoids accessing the disk or other secondary storage at the server to retrieve the previous message text.

In some embodiments the message extraction system stores the checksum for each message of a conversation in a message integrity tag associated with each message. The system receives a request to send a message. For example a conversation participant may compose a new message and send it to one or more recipients. The system creates a message integrity tag based on the contents of the message. For example the message integrity tag may include a checksum of the text of the message body. The system stores the message integrity tag as a property of the message. For example if the message is stored in a database of messages then the system may store the message integrity tag as a column in a message table. Finally the system sends the new message to the recipients.

The message store stores messages for a particular group of users. For example the message store may store messages for all users at a particular corporation internet service provider ISP or geographic site or may be one of several stores that cooperatively store messages for one of these types of entities. The message store holds the content of a message and all of the properties associated with the message. For example the message store may hold the message body any attachments and properties such as the message sender date the message was sent conversation identifier of a conversation to which the message belongs and so forth.

The message composition component creates new messages based on users requests. For example the message composition component may receive a request from a user to create a new message that has specified text in the body. When the user has completed the message the user indicates to the system that the message is ready for sending. For example the user may select a send button from the user interface of the user s client application. When the message is ready for sending the message extraction system adds a message integrity tag to the message using the components described below.

The message integrity tag creation component creates a message integrity tag based on the content of a new message. The message integrity tag may include a checksum of the body of the new message. For example the message integrity tag may include a CRC32 checksum of the message body text. The message integrity tag may also include a checksum of the formatting of the message and other information such as the count of words in the message. The contents of the message integrity tag are described in further detail herein.

The message tag association component associates the message integrity tag with newly composed messages stored in the message store . For example the message tag association component may store the tag as a property associated with the message in the message store . Even after messages are sent they remain in the message store particularly when the recipient of the message is a user of the same collaboration server. In this case sending a message is does not actually transport the message anywhere but rather associates the message with the inboxes of the message recipients. When the recipients or later recipients such as those to which the message is forwarded attempt to read the message the server will retrieve the message from the message store and the associated message integrity tag will also be available. The system may determine the message integrity tag at various levels within the collaboration server such as at submission to the server or within the transport of the server as the server is sending or delivering the message.

The previous message identification component scans a current message for the bodies of previous messages. A message in a conversation typically contains the body of the message to which it replies. Each message in a conversation except the original message will be a reply to a previous message. It is common to indent the text of the previous message or include a header within the message body to designate to a recipient reading the message where the new message body ends and the previous message body begins. The previous message identification component programmatically determines where the previous message body begins programmatically such as by searching for the header or indented text. The identified previous message body is called a previous message candidate until the system verifies that the body has not been modified. There may be multiple previous message candidates within a particular message representing the chain of replies that occur throughout the conversation. If there are ambiguities about where the previous message begins the previous message identification component may try several candidates in an attempt to find a match with the previous message.

The message integrity tag creation component described above is also used to create a message integrity tag for each previous message candidate. The message integrity tag comparison component retrieves the message integrity tag associated with each message in a conversation and compares this known tag with the tag created for each previous message candidate. If a match is found then the system determines that the previous message candidate contains the same body as the matching previous message in the message store . Note however that the match can be determined without ever retrieving the actual message body of the previous message from the message store . Because the tag associated with the previous message is potentially much smaller than the body of the previous message the message extraction system greatly reduces the memory and I O requirements of the message store and by extension the collaboration server .

The message reconstruction component reconstructs the previous message using the identified matching message body from the previous message. Reconstruction includes copying the text from the current message into a new message made to look like the previous message. Because the body of the message matches a conversation participant cannot tell the difference between the reconstructed message and a previous message retrieved from the message store . However because the reconstructed message is retrieved from the already available current message rather than the message store the burden on the collaboration server is reduced.

The computing device on which the system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives . The memory and storage devices are computer readable media that may be encoded with computer executable instructions that implement the system which means a computer readable medium that contains the instructions. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

In block the system compares the determined checksum of the previous message candidate with a checksum of the previous message. For example the system may retrieve a list of previous message checksums associated with the conversation of the current message from the message store. In decision block if the checksums match the system continues at block else the system continues at block . In block the system reconstructs the previous message based on the matching text of the current message. In block the system retrieves the previous message from the message store. In some embodiments before block if the checksums did not match the system loops to block to identify another previous message candidate until either no further candidates can be identified or a matching checksum is found.

The message extraction system can determine the checksum of a message in a variety of ways. Those of ordinary skill in the art will recognize that there are many available algorithms for computing a checksum of data such as message text. For example the message extraction system can use MD5 SHA1 CRC32 or any other suitable algorithm that provides a summary of data that can be compared to determine if the data has changed.

In some embodiments the message extraction system removes certain characters from the message text before computing the message text checksum. For example certain symbolic characters like smilies or emoticons may be modified by certain mail clients in ways that are not significant enough to cause the message extraction system to retrieve the previous message text from the collaboration server. As another example numbering may be converted to bullets or other characters by some email applications. Thus the message extraction system may mask out these characters when computing the checksum for storage in the message integrity tag and likewise mask out these characters when computing the checksum for previous message candidates. In this way minor inconsistencies do not cause extra message retrievals from secondary storage and thus do not prevent the performance gain that is possible using the message extraction system.

In some embodiments the message extraction system stores information in the message integrity tag in addition to the message text checksum. For example the system may store a count of words contained in the message to prevent collisions. Collisions occur when two different sets of data produce the same checksum value. Because the checksum value is smaller than the original data collisions are inevitable in checksum algorithms. However the likelihood of collisions among data of the same length is much less likely so storing the count of words is one way of avoiding an incorrect match due to a collision when the count of words is different.

Rather than only comparing the checksum the message extraction system first compares the count of words of a potentially matching message to the count of words in the tag stored for the known previous message. If the word counts do not match then the potentially matching message does not match the known previous message. If the count of words match then the system determines the checksum of the potentially matching message and if the checksum matches that of the known previous message the system determines that the potentially matching message is the same as the known previous message.

In some embodiments the message extraction system also uses the word count of the original message to identify previous message candidates. As discussed herein the system can identify the start of a previous message candidate by looking for a reply header and starting at the end of the reply header. The end of the previous message candidate can then be determined by using the word count to include as many words as are in the word count and stop rather than going all the way to the end of the message and potentially including other replies . This can be particularly helpful where a collaboration server or email client inserts a signature or footer at the end of each message after the user has sent the message. By stopping at the count of words that were in the message at the time of composition the system can avoid improperly including the later added footer that could cause two otherwise identical messages not to match.

In some embodiments the message extraction system determines a format checksum in addition to the message text checksum and includes the format checksum in the message integrity tag. The format checksum provides a summary of the formatting in the message that the message extraction system can check against a potentially matching message to determine whether the formatting of the message has changed after delivery. For example a sender may compose a message in HTML with substantial formatting but upon receipt a receiving client may convert the message to plain text and therefore may remove the HTML formatting from the message. By leaving formatting information out of the message text checksum and storing a separate format checksum the message extraction system can determine whether the text of the message has changed by comparing the message text checksum and whether the formatting has changed by comparing the format checksum.

In some embodiments the message extraction system determines the formatting checksum based on the formatting of a subset of the message text. It is often the case that the formatting of a message is either all the same as the original or all different. In other words it is rarely the case that a user replies to a message and modifies one or two characters or words of the previous message. More typically differences in email clients cause the formatting of the entire message to be modified such as changing the font of the message. Therefore the message extraction system may examine for example only the formatting of the first character of the message both original messages and previous message candidates to save time determining the format checksum. The format checksum is based on a data structure that contains relevant formatting data. For example the data structure may identify the font of the selected character whether the character is emboldened italicized or underlined the color of the character the font size the margins and padding of the paragraph the character is part of and so forth.

In some embodiments the message extraction system uses extracted message text without accessing the server even though the formatting of the message text has changed. For example the message client may display a preview of a message such as the first two or three lines that does not typically contain formatting. The extracted message text is sufficient for display as preview text and it is not necessary to access the server to retrieve the original message formatting. In other cases such as when the message is opened and the user wants to see the original message with all of its original formatting the message extraction system may retrieve the original message from the server to obtain the original formatting.

The message extraction system can associate the message integrity tag with the original message in numerous ways. In some embodiments the message extraction system is associated with a collaboration server that uses a database for storing messages in a table with multiple fields or columns. The collaboration server stores message text in one field and other properties of the message in separate fields. For example the collaboration server may store the message sender send time of the message recipients and other information about the message in separate fields. The message extraction system stores the message digest in one such field so that it can later be accessed with or without accessing the text of the message.

In some embodiments the message extraction system retrieves message integrity tags for each message in a conversation when the user opens a message in the conversation. For example when the system retrieves the current message that the user wants to open the system may also retrieve the message integrity tags of all previous messages in the thread. If the messages are stored in a database table then the systems requests the full row of information for the current message and only select columns for the previous messages. Because the select columns are smaller than the full message text they are more likely to be stored in memory by the email server and thus accessing them may not result in the email server accessing the disk or other secondary storage.

The message extraction system can create the message integrity tag at various times during the life of a message. For example the message extraction system can create the tag during message send and as noted above either at the client or the server. The message extraction system can also create the tag when a user reads the conversation when the message is received from the transport right before the message is placed in the recipient s mailbox in the backend and so forth.

There are many protocols for accessing messages in the manner described above. One example is the Messaging Application Programming Interface MAPI used by Microsoft Exchange Server. Using MAPI a server can define new message properties and a client can request specific properties of a message including the message integrity tag described.

In some embodiments the message extraction system provides an API for retrieving each message integrity tag associated with a conversation or subset of a conversation. Conversations can be identified by a conversation identifier that is stored as a message property. For example Microsoft Exchange Server assigns a globally unique identifier GUID to a new conversation and assigns the same GUID to all replies in the conversation. In addition for each reply in the conversation Microsoft Exchange adds a 5 byte message identifier to the conversation identifier. The 5 byte message identifier is composed from the date and time at which the reply was sent. Other collaboration servers provide similar identification of conversations and replies. The message extraction system provides an API through which an application can request the message integrity tag described herein for each message in the conversation. For example the API may use MAPI to allow the application to retrieve the MAPI property that contains the message integrity tag for each message in the conversation.

In some embodiments the message extraction system comprises components on the client that compute message integrity tags. Although determining such tags at the server has been described above the client may also participate in the process for additional performance benefits. For example a client email application e.g. Microsoft Outlook may determine the values to be placed in the message integrity tag and send these values to the server along with a new message. In this way the client saves server resources by taking on some of the computational burden that the server would otherwise perform. Similarly the client may examine a current message and determine message integrity tags for previous message candidates. The client can then send these tags to the server for comparison with the actual previous message integrity tags or the server can send the actual previous message integrity tags to the client for comparison. By performing these additional functions the client can save not only server processing time by reducing disk reads but may also save bandwidth by reducing the amount of data sent to the client when previous messages can be extracted from a current message at the client.

In some embodiments the message extraction system identifies previous message text even when the text has been modified. For example conversation participants often reply to messages by typing inline. A conversation participant may address a previous message paragraph by paragraph by entering new text below each paragraph. The new text is often prefaced by certain characters such as the initials of the replying participant in brackets and the new text may have different formatting e.g. italics color . The message system may attempt to identify and remove such text and determine the checksum of the text with the suspected inline reply text removed. If the checksum matches the known checksum for the previous message then the previous message can still be extracted from the current message. As another example when a conversation participant replies to a message the email client of the conversation participant may preface each line of the previous message with a greater than or other character. The message extraction system may attempt to remove such known characters and try the checksum to determine if a match can be found for the original text of the previous message.

From the foregoing it will be appreciated that specific embodiments of the message extraction system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. For example although email messages have been used in examples the message extraction system can be used equally well with any types of message or electronic conversations such as forms public folders and so forth. Accordingly the invention is not limited except as by the appended claims.

