---

title: Test driven deployment and monitoring of heterogeneous network systems
abstract: A test system (and corresponding method and computer program product) for generating unit tests for a heterogeneous network system and validating test results to ensure that the network system functions properly is described. In one embodiment, the test system is an appliance that is capable of normalizing communication protocols supported by component systems of the network system. The test system creates objects and methods corresponding to component systems and their supported protocol commands in the network system, and generates unit test cases based on the objects, the methods, and the normalized protocols. The test system transmits the unit test cases to the component systems, receives test results, and validates the test results to ensure that the network system functions properly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958230&OS=07958230&RS=07958230
owner: MU Dynamics, Inc.
number: 07958230
owner_city: Sunnyvale
owner_country: US
publication_date: 20080919
---
The present invention is related to U.S. Utility patent application Ser. No. 11 514 809 filed Sep. 1 2006 and U.S. Utility application Ser. No. 11 760 600 filed Jun. 8 2007 both of which are hereby incorporated by reference in their entirety.

The present invention generally relates to the field of network management in particular to unit testing and network monitoring.

With the emerging trend in real time Internet Protocol IP services e.g. Voice over IP VoIP Internet Protocol Television IPTV and web services e.g. Representational State Transfer REST Remote Procedure Call RPC the integration complexity of a wide array of network service elements has grown exponentially. These services typically are implemented by a heterogeneous network that includes a variety of interconnected heterogeneous component systems also referred to as component systems network service elements . Each of the component systems serves a unique role and works together with the rest to collectively provide the aggregate service to users. For example in VoIP session border controllers work in conjunction with gateways phones billing systems Domain Name System DNS servers Remote Authentication Dial In User Service RADIUS Lightweight Directory Access Protocol LDAP authentication servers and underlying IP infrastructure to constantly validate and ensure that phones can be registered phone calls can be made that the caller is authenticated and that the phone calls are billed properly.

Because of the interdependent nature of the heterogeneous network changes made in one component system e.g. configuration changes can inadvertently affect other component systems dependent upon it. The unintended impact can cause inter component dependencies to breakdown and thereby break the service. In addition because multiple component systems can share the same hosting computer resources changes made in one component system can also impact other component systems and cause service failure. Because heterogeneous networks tend to be large in scale the developer or administrator who made the changes may not be aware of these unintended consequences even if he is also in charge of the impacted component systems.

One traditional approach to ensure that a network system functions properly involves patch management log management and vulnerability scanning. Patch management merely checks to see whether certain known patches have been applied without any regard to ensure that the underlying component system is working properly. Log management records what has happened in the underlying component system without revealing the actual impacts or the causes. Vulnerability scanning uses a series of checks to ensure that component systems deployed are not susceptible to known software flaws vulnerabilities . All of these technologies are reactive in nature and cannot ensure that the network system functions properly.

Another existing approach to ensure that a network system functions properly involves sending test messages to the system and verifying the return message. This approach may be effective in a simple network system e.g. a website hosted by a web server . However this approach is not suited to test and monitor more complicated heterogeneous network systems because these network systems include interconnected and interdependent heterogeneous component systems each supporting different communication protocols. Currently there is no solution on the market that provides a single test framework that can independently verify that the heterogeneous system functions properly.

Therefore there is a need for a system and method for ensuring that a heterogeneous network system functions properly before during and after a change is introduced into the system.

The present invention overcomes limitations of the prior art by providing a test system and corresponding method and computer program product for generating unit tests for a heterogeneous network system and validating test results to ensure that the network system functions properly. In one embodiment the test system is an appliance that is capable of normalizing communication protocols supported by component systems of the network system. The test system creates objects and methods corresponding to component systems and their supported protocol commands in the network system and generates unit test cases based on the objects the methods and the normalized protocols. The test system transmits the unit test cases to the component systems receives test results and validates the test results to ensure that the network system functions properly.

In one aspect of the present invention the created objects and methods are made available to users in a programming interface e.g. Integrated Development Environment IDE . Users can program test cases using the objects and methods in a manner similar to traditional object oriented programming. The method invocations are parsed using corresponding normalized protocols to generate protocol messages. The method invocations can be executed on the fly and the results can be provided to the users promptly.

In another aspect of the present invention the test results include responding messages. The responding messages are parsed using corresponding normalized protocols to be expressed in canonical Document Object Models DOMs . Data in the canonical DOMs can serve as 1 baseline responses for subsequent tests and 2 parameters to other method invocations.

Other aspects of the disclosure include software systems components and methods corresponding to the above and applications of the above for other purposes.

The present invention describes a methodology and corresponding system to test and monitor heterogeneous network systems and to ensure that the heterogeneous network systems and their component systems work properly.

In one embodiment communication protocols are normalized into protocol grammars. Component systems and their supported protocol commands are represented by objects and methods and or properties . The methods accept canonical arguments and return Document Object Models DOMs that represent the results of the method invocations. Together these methods can be chained in arbitrary ways to program in the large. Methods related to the capabilities of component systems their dependencies to other component systems as well as assertions of expected canonical responses can be generated and organized as a set of unit tests. These unit tests can then be run periodically against the component systems to guarantee that their external behaviors remain unchanged due to modification or some other degradation.

Communications among computing devices generally involve the exchange of data or messages in a known structured format a protocol . Typically a computing device supports one or more protocols by implementing them in software or hardware modules within the device. Each of these protocols can be described by a concrete formal grammar e.g. a context free grammar through a process called normalization also known as canonization . The grammar can be represented by a generic data structure using source code and can be used to generate and verify protocol messages. Further information regarding normalization and representing protocols using source code is found in U.S. application Ser. No. 11 514 809 filed Sep. 1 2006 the content of which is incorporated by reference in its entirety.

A protocol typically includes one or more messages or commands . For example in one implementation the File Transfer Protocol FTP includes the following commands ALLO command CDUP command CWD command HELP command LIST command login attempt MDTM command MKD command NLST command PASS command PORT command RETR command SMNT command STAT command STRU command TYPE command and USER command. A protocol message typically includes one or more fields. For example in one implementation an INVITE message according to the Session Initiation Protocol SIP includes three fields a Universal Resource Indicator URI field a version field and a host field IP address .

A protocol message can be expressed as a method call. Continuing with the above SIP example the INVITE message can be expressed using the following method call invite URI Version IP where the three parameters represent the actual field values. It follows that a complex network transaction can be expressed as a collection of method calls each of which represents a protocol message involved in the transaction.

Similarly a responding protocol message can be expressed using markup language such as the Extensible Markup Language XML and stored in a normalized document object model DOM . Protocol messages can be parsed according to the corresponding protocol grammar. The parsing result can be expressed in XML and stored in the DOM.

For example some implementations of the Secure Sockets Layer SSL protocol have a command for users to inquire about digital certificate information. The command can be expressed using the following method call 

The method call can be parsed according to the SSL protocol grammar to generate the corresponding SSL message and transmitted to the target system as identified by the method parameter. The target system returns a response message which is parsed according to the SSL protocol grammar to generate the following canonical DOM 

As shown the method call returns the certificate information embedded in the responding message in a canonical DOM. As a result it is intuitive and simple to identify in the DOM the issuer s identity SomeOrganization the issuer s email address support tumbleweed.com and when the certificate is expiring.

It is noted that in the above example the complexity of the SSL protocol is hidden behind the method call and the returned canonical DOM. In addition the SSL protocol may be implemented above several other protocol layers see e.g. the Open Systems Interconnection OSI Reference Model which has seven layers . Details e.g. header information of these lower layer protocols used in actual transmission are also hidden to the user.

A heterogeneous network system typically includes interconnected computing systems hereinafter referred to as component systems serving a variety of roles. Multiple component systems can serve the same roles. For example a group of servers a cluster can be configured to run a web application simultaneously. Component systems serving the same role are collectively called an asset. Each component system supports one or more protocols each of which includes one or more protocol commands. Protocols supported and services provided by a particular component system can be found out by the rest. For example the supported protocols and commands can be described using the Web Services Description Language WSDL in a document that is available to other component systems upon request e.g. using Simple Object Access Protocol SOAP . In addition the services provided and protocols supported by component systems can be made available through the Universal Description Discovery and Integration UDDI . The component systems in the network system can be monitored externally e.g. by observing their inputs and outputs and the measured outputs can be audited to ensure that the component system works as expected.

Similarly software developed using object oriented programming languages e.g. Java Ruby typically includes classes instantiated by objects each of which supports one or more interfaces including one or more methods. An object can make available its supported interfaces and methods through a process called reflection. The implementation and performance of an object can be tested using approaches such as grey box testing and validated using assertions.

It is observed that certain concepts in network systems can be considered equivalent or analogous to certain concepts in object oriented software systems. As described above a protocol message can be expressed as a method call. Similarly assets can be conceptually considered analogous to classes and systems of an asset can be considered analogous to objects of the corresponding class. The following table maps concepts in network systems to their corresponding concepts in object oriented software systems.

The following examples further illustrate the correspondence between protocol and interface and transaction and method invocation. It is noted that parameter s to the methods are omitted for clarity. In one implementation the Domain Name System DNS protocol has the following commands query and zoneTransfer. Correspondingly the DNS interface has two methods query and zoneTransfer . Similarly the Internet Control Message Protocol ICMP has command isReachable and correspondingly the interface ICMP has function isReachable . The following table is an incomplete list of communication protocols and their corresponding methods and properties.

When viewed this way the traditional unit testing paradigm can be applied to operational heterogeneous network systems by treating the component systems as a set of objects each of which has methods exposed in the form of protocol commands. The supported protocols and or protocol commands can be discovered e.g. through SOAP and the assets or services can be obtained through means such as UDDI. Thus the corresponding classes objects and methods can be constructed accordingly. These rich set of objects and methods then can be chained in numerous ways to program at large.

The performance of the heterogeneous network system can be measured and validated through monitoring communications among the component systems using supported protocols. It follows that the component systems can be tested by sending them protocol messages and validating response messages or lack of response messages . Recall that protocol messages can be expressed as method calls and component systems can be considered analogous to objects or instances . Therefore the testing protocol messages directed towards various component systems can be expressed as method invocations of corresponding objects. Recall that a protocol can be described by a grammar represented by a generic data structure using source code. The method calls can be parsed using corresponding protocol grammars to generate the testing protocol messages. Similarly the responding messages can be parsed to be expressed in XML in DOMs. The application parsing the method calls and the responding messages is called a protocol engine.

In one embodiment the present invention extracts information regarding interdependencies among the system components and generates testing protocol messages reflecting and testing such interdependencies. For example a Lightweight Directory Access Protocol LDAP server may have one or more backup servers and or alternate servers based on how the service is configured. This dependency information can be retrieved from the primary LDAP server upon request. The primary LDAP server may redirect traffics to these backup alternate servers. These redirections together form a directed graph of the component systems. Test messages can be generated to verify that the interdependencies remain valid. For example testing protocol messages can be generated and sent to the primary LDAP server and the backup alternate LDAP servers and the response messages can be verified for consistency.

The test server is configured to test and or monitor the component systems in the heterogeneous network system . As shown in the test server includes a protocol engine an assertion engine and a data storage component . The protocol engine is configured to normalize protocols supported by the component systems to generate test messages also referred to as testing protocol messages for component systems based on corresponding protocol grammars and to transmit the test messages to their corresponding target component systems. The protocol engine is further configured to receive response messages and to parse the response messages into DOMs. The test messages are designed to check whether the target component systems are functioning properly. The assertion engine is configured to validate e.g. checking assertions the DOMs generated based on the response messages . The assertion engine ensures whether the component systems are working as expected based on the validation. The data storage component is configured to store information related to the test and or monitor of the test server . Examples of such information include generated test messages assertions normalized protocol grammars and information about the heterogeneous network system e.g. corresponding classes objects interfaces methods and or properties .

The test server and its components can be implemented in hardware software or a combination of both. Regarding software the test server can be for example a single application executing within a single operating system or single physical device or a collection of applications e.g. one for the protocol engine one for the assertion engine and one for the data storage component all of which executing within the same device and communicating with each other to correlate testing operations . Regarding hardware the test server can be for example a standalone computer or a collection of physical devices e.g. one for the protocol engine one for the assertion engine and one for the data storage component with out of band synchronization. In one embodiment the test server is a portable appliance that can be transported to different locations to test different network systems.

The heterogeneous network system includes multiple interconnected component systems not shown that functions together. Each of the component systems includes hardware and or software subject to test. Software includes for example applications operating systems and or communications systems. Hardware includes for example one or more devices. A device can be for example a server switch bridge router packet filter firewall Virtual Private Network VPN concentrator proxy intrusion detection prevention system or network protocol analyzer. A component system can include multiple devices that are coupled at various communication layers to form a system or network of devices. The component systems connected to each other through networks such as the Internet an intranet a wireless local area network LAN a cellular network or any combination thereof. The component systems receive the test messages from the test server and responds by sending the response messages .

In one embodiment the test server and component systems in the heterogeneous network system are structured to include a processor memory storage network interfaces and applicable operating system and other functional software e.g. network drivers communication protocols .

The test server discovers component systems in the heterogeneous network system and their provided services supported protocols protocol commands e.g. authentication methods and properties e.g. certificates ciphers supported capabilities exposed . The test server can discover such information automatically e.g. by interacting with an active directory or receive such information from an external source. For example a user can provide such information to the test server . As another example the test server can query a DNS server in the heterogeneous network system for information about web server s and email server s associated with a certain domain. The test server can also inquire the component systems for their provided services and supported protocols. For example in the context of web services the provided services and supported protocols are explicitly published in the form of WSDL and the set of services deployed on the network system can further be obtained through UDDI. In addition the test server may discover interdependencies among component systems e.g. backup servers alternate servers .

The test server normalizes the protocols supported by component systems in the heterogeneous network system . The test server can compile the protocols directly from their specification e.g. in External Data Representation XDR format . Certain classes of protocols may be already defined in machine parsable structured grammar as described in one of the prior patents . Further information regarding normalizing a communication protocol and representing it in a generic data structure using source code is found in U.S. application Ser. No. 11 514 809 filed Sep. 1 2006 the content of which is incorporated by reference in its entirety.

The test server represents the component systems in the heterogeneous network system as a set of objects with methods that can be invoked and properties that can be queried based on their supported protocols and protocol commands. Recall that component systems can be conceptually considered equivalent to objects or instances and their supported protocol commands can be considered equivalent to methods of the corresponding objects. Therefore the test server can create objects with methods that correspond with the content systems and their supported protocol commands.

The test server generates method calls for testing the component systems based on the objects and methods representing the component systems. The method calls can be generated based on user input. For example a list of the objects and their interfaces methods and properties may be made available to the user in an IDE and the user can selectively invoke method calls against the objects in any sequence he prefers to program a set of unit tests. For example to test a VoIP service the user can specify a method call to a DNS server to map a phone number into an IP address. This ensures that the IP address is reachable and more importantly the SIP Session Initiation Protocol is configured properly by correlating the phone number in the SIP protocol against the DNS server . The user can then specify a method call to the RADIUS server to test authentication. Thus the user can program a unit test case for testing a complex network transaction that involves multiple heterogeneous component systems. Alternatively the method calls can be retrieved from external sources or automatically generated based on traffic monitored between the component systems.

The test server converts the method calls into corresponding protocol messages using the applicable protocol grammars and transmits the protocol messages to the target component systems. It is noted that a method call may corresponds to one or more protocol messages.

The test server receives responding messages from the component systems parses them according to the applicable protocol grammar and stores the results in DOMs.

The test server verifies the responding messages to ensure that the component systems are working properly. The test server can compare information in a responding message with a standard value e.g. a value previously returned by the underlying component system responding to the same testing protocol message . The test server can also evaluate the factors other than the responding message content to determine the performance of the component system. For example the test server can measure the response time for the transaction to determine service degradation. Further information regarding characterizing device performance is found in U.S. application Ser. No. 11 760 600 filed Jun. 8 2007 the content of which is incorporated by reference in its entirety.

The test server can record the generated method calls and periodically invoke them to test the heterogeneous network system . Thus the test server can detect changes in system behavior either configuration or service degradation in the form of failing the verification on an on going basis. Alternatively the test server can use the results of the method calls as baseline responses for subsequent tests.

The principles described herein can be further illustrated through the following example in accordance with one embodiment of the invention. In this example the test server tests a DNS server in the heterogeneous network system . The DNS server is represented as an object named DNS. The object has the following method 

The represented object and method can be made available to a user e.g. an Information Technology professional in a user interface similar to an Integrated Development Environment listing classes and their members. The user can visually drag and drop methods into programming window to program unit test cases. For example the user can instruct the test server to invoke the DNS.query method for information about the uspto.gov domain. The test server in turn converts the method into corresponding protocol message and transmits the protocol message to the DNS server. The test server receives the responding message parses it and present the parsed result to the user as shown below.

As shown the DNS server returns a set of IP addresses associated with the uspto.gov domain. This result can serve as a baseline for future test result comparison and as indications of internal performance against certain measures. For example the user can choose to make assertions for this test message by visually placing pushpins onto the values the user wants to verify. The user can also specify criteria such as acceptable value ranges. When the method or corresponding protocol message is subsequently invoked the result is validated using these assertions.

In addition the user can also utilize e.g. cut and paste values in the result to generate other method calls. For example the user can use the IP address in the result 151.207.245.67 to make inquiries to the web server for the uspto.gov domain.

The above embodiments and examples show that the present invention can be used to test and monitor live network systems. The present invention can also be used in deploying network systems in a manner similar to the Test Driven Development for software development. For example the present invention can be utilized to progressively deploy a network system in the following manner 1 add unit tests to ensure that they fail 2 deploy some component systems against these unit tests 3 run the automated unit tests to make sure they pass 4 deploy new or make changes to existing component systems 5 verify that the automated unit tests continue to pass. This approach ensures that the impact of changes can be clearly identified and allows the Information Technology IT organization to deploy the network system rapidly while keeping the quality levels high. The unit tests ascertain that the changes do not break anything and that the network system works as expected. More importantly the unit tests serve as a baseline for the expected behavior and any changes in this behavior due to either configuration changes or implementation changes can be clearly identified. The unit tests can run periodically to ensure the ongoing integrity of the network system.

The unit tests might rely on standard unit testing frameworks like JUnit for Java or RUnit for Ruby using the classic setup test teardown metaphors. The queries are not necessarily restricted to just component systems but also the network system at large. For example to test a security policy that prohibits traffic between two networks the test server can connect to both networks and generate a valid transaction from the two networks and assert that it is not possible.

The present invention has the following advantages. The present invention thoroughly tests component systems to ensure that when they are deployed they will work together as designed to perform a specific function in the environment within acceptable thresholds. In addition when changes are made to the component systems the present invention ensures that the function or service remains operational within acceptable thresholds or identifies the impacts or degradations such that the IT organization can restore the function or service in a timely fashion. Also those responsible for ensuring the security of the environment can validate the change against approved baseline standards and mark any deviations from the baseline for remediation efforts. Because the test messages extract information directly from the component systems as opposed to parsing log files any behavior changes are directly visible in the exposed interface of the component system. The present invention can also validate interdependencies among component systems to ensure that they are continuing to work and that they are not changing since the last time unit tests were run. These unit tests in essence embody a positive model of how the service should be behaving.

In the preceding description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the disclosure. It will be apparent however to one skilled in the art that the disclosure can be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to avoid obscuring the disclosure.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

Some portions of the detailed descriptions that follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements objects symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present disclosure also relates to an apparatus for performing the operations herein. This apparatus is specially constructed for the required purposes or it comprises a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program is stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems are used with programs in accordance with the teachings herein or more specialized apparatus are constructed to perform the required method steps. The required structure for a variety of these systems appears in the description herein. In addition the present disclosure is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the disclosure as described herein.

