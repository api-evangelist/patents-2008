---

title: Method for managing message flow in a multithreaded, message flow environment
abstract: In one form, a method for managing message flow includes processing messages concurrently by processing nodes in a computer software application. The processing nodes include at least one set of lock acquisition, system resource access and lock release nodes interconnected in a flow path. In such a set, the nodes are interconnected in a flow path and process a respective one of the messages in a sequence defined by the flow path. The processing includes granting access to a system resource exclusively for the set's respective message responsive to the lock acquisition node processing its respective message. The system resource is accessed for the message responsive to the set's system resource node processing the message. The accessing of the resource for the message includes changing a certain system state. The exclusive accessing of the system resource is released responsive to the set's lock release node processing the message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08108860&OS=08108860&RS=08108860
owner: International Business Machines Corporation
number: 08108860
owner_city: Armonk
owner_country: US
publication_date: 20080629
---
This application is a continuation of prior application Ser. No. 10 326 147 which was originally filed on Dec. 20 2002.

The present invention concerns managing system state for a system having multiple messages for related transactions in a message flow environment and more particularly concerns nodes in such an environment for granting and releasing to a selected one of the messages exclusive access to a system resource.

To put business enterprise data to more productive use the data must be moved reliably among different software applications. That is businesses want applications located anywhere within their enterprise to be linked together and even to send messages to systems of other business enterprises such as those of their customers and suppliers. A simple example is of two payroll systems that need to communicate with each other. Numerous issues arise in this effort not the least of which concerns communication among disparate applications running on heterogeneous networked platforms using diverse data formats. In the payroll example for instance both of the systems may have employee names but with a name stored in one field in one system and in more than one field in the other system. Moreover the problem illustrated by the payroll example is relatively simple. Data produced by one application may have a data structure that is more unrecognizable to another application. It is of course possible to transform data between applications but as data is shared among more and more systems the overhead becomes unacceptable and future maintenance becomes a large and often messy job.

This situation has led to an increasing focus on integration tools such as IBM s WebSphere MQSeries Integrator WMQI for developing message processing applications with a common Application Programming Interface API . WebSphere MQSeries Integrator is a trademark of IBM. An enterprise integration application developed with software such as WMQI typically acts as a distribution hub i.e. a sort of a broker for messages passing among other applications and may accordingly be referred to herein as a Broker. In this centralized location definitions are configured specifying how messages are to be transformed and routed. This arrangement tends to eliminate the need for numerous interfaces between applications and to free developers from worrying about platform differences such as different operating systems.

This kind of enterprise integration application is typically characterized by graphical tools and a high level flow language for configuring a flow of messages on a structure of interconnected nodes including numerous predefined nodes creating what may be referred to as a workflow or message flow environment. That is within the Broker individual functions are assigned to a collection of interconnected nodes with the processing and transformation activities taking place in the nodes. Through the deployment of predefined and customized nodes a sophisticated processing environment is built in which nodes perform operations on message data within a message flow and have the ability to access information outside the message flow such as information in a database or an external application and to leave the message flow by placing a message on a queue.

Certain support is typically provided for multithreading in a Broker such as WMQI. A message can be read from a queue to begin the message flow and can be placed into a queue to terminate the flow of the message. There can be multiple flow paths between the input and terminating nodes with respective messages concurrently flowing through different paths each message handled by its own thread. Moreover even if there is only one flow path between the input and terminating nodes concurrent instances of the same message flow are supported with each instance processing its own respective message read from the queue.

For such multithreaded messages it is important to maintain system state. For example two multithreaded transactions or even two multithreaded messages for the same transaction may access a common resource such as a database. The manner in which the threads access the resource may be important for transactional integrity i.e. for maintaining the system in a proper state. However in conventional workflow applications processing nodes do not automatically and explicitly maintain transactional integrity of messages flowing through the system. Instead the developer must carefully maintain transactional integrity within the bounds of the message flow by diligently structuring the Broker application and applying its predefined transactional properties.

One known way to structure a message flow application to maintain transactional integrity among threads is to force related messages to join. See for example Notani et al. U.S. Pat. No. 6 397 192 B1 Synchronizing One or More Workflows Using One or More Synchronization Join Activities That Include Synchronization Logic May 28 2002. However this may cause a performance penalty particularly when this joining includes forcing multiple threads to become essentially single threaded. Therefore a need exists for improvements in a multithreaded message flow environment to manage multiple messages for related transactions.

The forgoing need is addressed in the present invention. In one form of the invention a method for managing message flows includes processing numerous messages concurrently by instructions associated with respective processing nodes also referred to as workflow nodes in a computer software application. Herein a message being processed by instructions associated with such a node may be referred to simply as being processed by the node. The processing nodes include at least one set of lock acquisition system resource access and lock release nodes interconnected in a flow path also referred to herein as a workflow flow path or simply a workflow . In such a set the lock acquisition system resource access and lock release nodes of the set are interconnected in a flow path and process a respective one of the messages in a sequence defined by the flow path. The processing includes granting access to a system resource exclusively for the set s respective message responsive to the set s lock acquisition node processing its respective message. The system resource is accessed for the message responsive to the set s system resource node processing the message. The accessing of the resource for the message includes changing a certain system state. The exclusive accessing of the system resource is released responsive to the set s lock release node processing the message.

Herein the term workflow process is used to refer to an instance of a process for processing a message by instructions associated with nodes in a flow path. It should be appreciated that according to the above description a system resource is selectively protected by a lock mechanism to lock out i.e. prevent multiple workflow processes from using the resource simultaneously. In order for a workflow to use the system resource that workflow must currently own the lock . Only one workflow process for a given transaction may own the lock at any given instance.

Objects advantages additional aspects and other forms of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings.

The claims at the end of this application set out novel features which applicants believe are characteristic of the invention. The invention a preferred mode of use further objectives and advantages will best be understood by reference to the following detailed description of an illustrative embodiment read in conjunction with the accompanying drawings.

Referring now to flow paths A and B first and second instances of a flow path are illustrated for a computer application program according to an embodiment of the present invention. The flow paths A and B are for processing financial transactions that require a finite state machine to manage the transactions from inception to completion. As used herein the term financial transaction includes a transaction involving updating of account information or a transfer of a financial asset of any sort including a depository account security mutual fund promissory note security agreement commercial paper or real estate. The flow paths A and B each have a number of nodes A through A and B through B respectively interconnected by connections. Connection A between node A and A is explicitly numbered for illustration. Although only two flow paths A and B are illustrated there may be multiple instances of the flow paths or there may only be one instance depending on the circumstances. That is a financial transaction is embodied by a message and requires access to a system resource in this case a database. A number of messages are shown waiting in an input queue for availability of a thread from a thread pool not shown . Upon thread availability a first instance of a flow path A is created and the input node A for the instance removes a message from the queue .

The actions that are proper for one of these financial transactions depend upon the state of the system in particular the state of a certain system resource i.e. the previously mentioned database. There may be messages in the queue for more than one transaction but there may also be numerous messages for the same transaction. Respective messages may be processed concurrently by the set of nodes associated with an instance of a flow path e.g. nodes A through A associated with flow path A. In the embodiment of there is a second message for the same transaction and the second message for the transaction is processed concurrently in another flow path instance i.e. flow path B. Consequently a transactional integrity issue arises according to which something must be done to ensure that only proper actions are performed for the transaction and the state of the database. That is when work is done on the transaction for each of the messages the database state will change and actions that were appropriate in the former state of the database may no longer be appropriate in the new state. For this reason only one set of actions for one message may properly be taken for the transaction at a given time and the set of actions must be completed before another action may begin for the other message related to the same transaction. Moreover the action but must be completed before the accessing for the other or else the integrity of state of the database will be corrupted or at least indeterminate.

To address this issue the flow paths A and B use respective lockTransaction nodes A and B i.e. a type of node referred to herein more generally as a locking node. With respect to those messages being processes by respective instances of nodes A and B which relate to the same transaction the locking nodes A and B grant exclusive access to the database to only one of the messages . According to an aspect of the embodiment such a lockTransaction node does not prevent access to the database or other such system resource for other concurrent messages that are related to different transactions. This aspect improves system performance. In other embodiments however a lockTransaction node does prevent access to the database or other such system resource for other concurrent messages regardless of whether the messages are related to different transactions.

As an example the transaction may be a payment regarding a particular bank account. One message may be a payment which would result in a transfer of funds from the account to another account while another message is to cancel the payment which of course would result in leaving the funds in the account. The accessing of the database is for posting information to the database concerning the transfer from the account such as a debit to the database in the case of the payment message or else in the case of the cancellation message posting of a stop payment indicating in the database to override the payment instruction if the payment message is processed later. The locking nodes A and B ensure that processing is serialized for the messages but just with respect to the messages relating to the same transaction and just with respect to accessing the database.

It is advantageous to system performance that the locking is limited in the above fashion rather than serializing to a broader extent. That is in some applications other processing of messages for the same transaction besides accessing the database may not be precluded. Since the locking is limited just to locking access to the database such other processing may proceed. Likewise it is advantageous that processing is not halted by the locking node for other messages that do not relate to the same transaction.

To illustrate in more specific detail processing by flow path A is now further described. If the account database is already locked by another instance of node A e.g. node B then the instance of node A waits for the lock on the database to be released. If the database is not already locked by another instance of node A then message is further processed by locking node A for the transaction. Responsive to this processing by node A the accessing of the database is locked for other messages relating to the same transaction. Then for the message that is granted exclusive access to the database by node A processing by a ReadStateDatabase node A reads the state of the database for the message . Next in an UpdateTransaction node A the transaction state is updated and in an UpdateStateDatabase node A the state of the database is updated for the message . The updating of the database would include for example the previously mentioned debit for the payment message or the stop payment indication for the cancel payment message. The updating of the transaction would include for example indicating a payment was made or stop payment had been approved. It may include changes regarding the date on which payment is expected changes in who is to be paid who is responsible from making payment currency to be used for payment or even some text string containing special instructions to buyer or seller.

Next after processing by node A has updated the database for the message the exclusive accessing of the database is released responsive to the FreeTransaction node A processing the message and the message is then placed in an output queue by processing responsive to node Output A. Responsive to the FreeTransaction node A releasing the lock on the database nodes are free to access the database for other messages in other instances of the flow path relating to the same transaction such as flow path B illustrated.

Referring now to an instance of a flow path is illustrated for a computer application program using locking and releasing nodes for messages in airline reservation transactions according to an embodiment of the present invention. The example of may also be applicable to reservations of any kind including reservations for a hotel or a performance event. The flow path has a number of nodes through interconnected by connections. An element number for connection between node and is explicitly set out for illustration. Once again although only one flow path is illustrated with sub paths in this case there may be multiple instances of the flow path . And also as in the previous example the reservation transaction is embodied by a message and requires access to system resources in this case a flight information database and a seat mapping database. Messages arise from ticketing agents web programs customers etc. seeking to book flights including seat assignments. The messages wait in an input queue for availability of a thread from a thread pool not shown . Upon availability of a thread the flow path is instantiated for the thread and the input node for the path instance removes a message from the queue .

In the embodiment of as in actions that are proper depend upon the states of the databases. Respective flight reservation messages may be processed concurrently by the set of nodes associated with an instance of the flow path . If there is more than one reservation message for the same flight and seat assignment and these multiple messages are processed concurrently an integrity issue arises. That is the potential problem of multiple bookings of the same seat on the same flight must be managed within the bounds of the message flow path instances.

Enter node passes its message via connector to LocateFlight node which locates the flight indicated by the message . Next IsFlightOpen node determines whether the flight is open to receive bookings. If not the message is passed to TryOtherFlight node which prompts the ticket agent customer etc. to request a different flight which may include informing the agent etc. about potential flights. Responsive to receiving a new request the message is passed by node once again to node the flight is located and node determines whether the flight is open to receive bookings. Alternatively if the agent customer etc. elects not to make a new request then the node passes the message to node to exit without reserving a flight.

Once an open flight is located by node the message is passed to LockFlight Access node . If the flight information database is not already locked by another instance of node then the present instance of node locks access to the flight information database for the particular flight thereby preventing other messages for the same flight from accessing the database and the present node grants exclusive access to its message . If the flight information database is already locked by another instance of node then the present instance of node waits for the lock on the flight information database to be released. This may be implemented by assigning a token to the flight information database for each flight. In this manner a node grants exclusive access to the database for the flight responsive to receiving the token. 

Next at LocateSeatPreference node information about seat preference is located for the message that was granted access to the flight information database. This may include looking up information in the passenger s account or prompting for and receiving manual input. Seat preference may include row seats versus aisle seats front seats versus back seats seats over a wing or not over a wing etc.

Once a seat preference has been obtained the message is passed to IsSeatOpen node which queries the seat mapping data base to determine whether specific seats of the type indicated by the preference are available. If a seat of the type preferred is not available then message is passed to TryOtherSeat node which asks the agent whether to try again or give up and just book nothing. If the agent selects to try again the flow returns the message to node which searches for or prompts for a manual input of a new preference.

Once it is determined at node that a seat is open of the type preferred the message is passed to LockSeatAccess node . If the seat mapping database is not already locked by another instance of node e.g. if the node receives a token for the seat mapping database for the particular flight then the present instance of node locks access to the database for the particular flight thereby preventing other messages for the same flight from accessing the database and the present node grants exclusive access to its message . Then the message that was granted access to the seat mapping database is passed to RecordReservation node which records the seat assignment and flight reservation in the flight information and seat mapping databases. The information recorded in the databases is also appended to the message for further processing.

Next the message is passed to ReleaseSeatAccess node which releases the seat mapping database with respect to the particular flight such as by once again making available the token for the seat mapping database that was assigned to node . Then the message is passed to ReleaseFlightAccess node which likewise releases the flight information database with respect to the particular flight such as by once again making available the token for the flight information database that was assigned to node . Next node passes the message to Exit node which in turn places the message in an output queue where it can await further processing not shown which may include generating a notification to the agent and customer printing a ticket etc. based on the information appended to the message .

Referring now to an instance of a flow path is illustrated for a computer application program using locking and releasing nodes for messages accessing a transmission line not shown to perform some communication transaction according to an embodiment of the present invention. The example of is generally applicable to a variety of communication transactions including transactions involving the sending and receiving data packets such as according to a TCP IP protocol. Once again there may be multiple instances of the flow path . That is messages wait in an input queue for availability of a thread from a thread pool not shown . Upon thread availability the flow path is instantiated and the Input node for the instance removes a message from the queue . The message is than passed to FormatData node which formats the data for the system or application to which the message is being transmitted.

The next proper action depends upon the state of the transmission line. Therefore the message is passed next to GetXmitLock node . If the line is already locked by another instance of node then the present instance of node waits for the lock on the line to be released. If the transmission line is not already locked by another instance of node then the present instance of node locks access to the transmission line thereby preventing other messages from accessing line and the present node grants exclusive access to its message . The message is then passed to FlowOrder node which passes the message to XmitData node and after the code associated with node is executed i.e. the message processing at node is completed then passes the message to ReleaseXmitLock node . At node the message is transmitted on the transmission line. Then the message is passed to node which releases the line such as by once again making available a token for the line that was assigned to node . Next node passes the message to Exit node which in turn places the message in an output queue where it can await further processing not shown .

Referring now to aspects are illustrated for of a method for managing message flows according to an embodiment of the present invention. As previously messages in queue may be processed concurrently by instructions associated with respective computer software application processing nodes. A first message . is processed by a first thread of instructions associated with a first set of processing nodes including lock acquisition node A system resource access node B and lock release node C. The nodes of the set are interconnected in a workflow A defining a sequence for processing the workflow s message .. A second message . is processed by a second thread of instructions associated with a second set of processing nodes including lock acquisition node B system resource access node B and lock release node B. The nodes of the second set are also interconnected in a workflow B. Workflow B may be another instance of workflow A.

The processing for workflow A includes granting exclusive access to a system resource for the workflow s message . responsive to the workflow s lock acquisition node A processing its respective message . at time t. The granting of access is illustrated as acquiring an instance of a lock . Likewise the processing for workflow B includes granting exclusive access to the system resource for the workflow s message . responsive to the workflow s lock acquisition node B processing its respective message . at time t.

The processing for workflow A also includes accessing A the system resource for the message . responsive to the workflow s system resource node A processing the message .. This includes the message . changing a certain system state. Since the system resource node A is after the grant node A in workflow A and the system resource is accessed responsive to processing by the system resource node A the system resource cannot be accessed until after the grant node A acquires the lock for message ..

Likewise the processing for workflow B also includes accessing B the system resource for the message . responsive to the workflow s system resource node B processing the message . which also includes the message . changing a certain system state.

The processing for workflow A also includes releasing the exclusive accessing of the system resource responsive to the workflow s lock release node A processing the message .. Likewise the processing for workflow B also includes releasing the exclusive accessing of the system resource responsive to the workflow s lock release node B processing the message ..

In the embodiment illustrated in the first message . is for a transaction X and the second message . is for the same transaction X. For both messages . and . the exclusivity of the access granted to the system resource by the respective lock acquisition nodes A and B is responsive to the identity of the respective message s transactions. Accordingly lock Thus if the lock acquisition node A for the first message . has granted the first message . access to the system resource as shown in the lock acquisition node B for the second message . denies the second message . access to the system resource until the lock release node A for the first message . releases the lock i.e. the exclusive accessing at time t since the first message and the second message are for the same transaction X.

In other words in the example depicted in since the system resource node B is after the grant node B in workflow B and the system resource is accessed responsive to processing by the system resource node B and since message . has acquired the lock before message . the system resource cannot be accessed for message . until after the release node A releases the lock at time t and grant node B acquires the lock for message . at time t. Note that this does not involve joining the instruction threads but merely involves the lock acquisition nodes A and B both checking for common transactions and if common transactions are found acquiring and releasing the lock for the common transactions responsively.

Referring now to the same workflows A and B are shown but with the messages . and . in this instance being for different transactions this time. Specifically message . is for a transaction U while message . is for a transaction V. According to the embodiment of the method depicted since the messages . and . are for different transactions the second message . is granted access to the system resource by the lock acquisition node B for the second message . independently of whether the lock release node A for the first message . has released the exclusive accessing. Thus as shown messages . is granted a lock while message . is granted a lock at the same time by their respective lock acquisition nodes A and B so both processing for messages . and . may access the system resource at the same time.

In another embodiment not shown the exclusivity of the accessing of the system resource is independent of identity of the transaction for a lock acquisition node s message. In this case independently of whether the first and second messages are for different transactions if the lock acquisition node for the first message has granted the first message access to the system resource the second message access is denied access to the system resource by the lock acquisition node until the lock release node for the first message releases the exclusive accessing just as shown in where the messages are both for the same transaction.

Referring now to a computer system is shown that is generally applicable for the embodiments described. The system includes a processor a volatile memory e.g. RAM a keyboard a pointing device e.g. a mouse a nonvolatile memory e.g. ROM hard disk floppy disk CD ROM and DVD and a display device having a display screen. Memory and are for storing program instructions which are executable by processor to implement various embodiments of a method in accordance with the present invention. Components included in system are interconnected by bus . A communications device not shown may also be connected to bus to enable information exchange between system and other data carriers.

In various embodiments system takes a variety of forms including a personal computer system mainframe computer system workstation Internet appliance PDA an embedded processor with memory etc. In one embodiment the system is an IBM RISC 6000 system running the AIX or Linux operating system and the WMQI application. In another the WMQI application is running on an IBM NetVista system and the Windows NT operating system. It should be understood that the term computer system is intended to encompass any device having a processor that executes instructions from a memory medium.

The memory medium preferably stores instructions also known as a software program for implementing various embodiments of a method in accordance with the present invention. In various embodiments the one or more software programs are implemented in various ways including procedure based techniques component based techniques and or object oriented techniques among others. Specific examples include XML C C Java and Microsoft Foundation Classes MFC .

While the present invention has been described in the context of a software application and a computer system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed as computer readable medium of instructions in a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such a floppy disc a hard disk drive a RAM and CD ROMs and transmission type media such as digital and analog communications links.

The description of the present embodiment has been presented for purposes of illustration but is not intended to be exhaustive or to limit the invention to the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art.

To reiterate the embodiments were chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention. Various other embodiments having various modifications may be suited to a particular use contemplated but may be within the scope of the present invention. Moreover it should be understood that the actions in the following claims do not necessarily have to be performed in the particular sequence in which they are set out.

