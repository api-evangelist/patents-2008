---

title: Apparatus and method for automatically analyzing program for detecting malicious codes triggered under specific event/context
abstract: Provided is an apparatus and method for automatically analyzing a program in order to detect window malicious codes that are programmed to perform malicious behaviors when a specific event occurs, when the specific event does not occur, when a specific program execution condition is satisfied, and when the specific program execution condition is not satisfied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08584101&OS=08584101&RS=08584101
owner: Electronics and Telecommunications Research Institute
number: 08584101
owner_city: Daejeon
owner_country: KR
publication_date: 20081114
---
This application claims priority to and the benefit of Korean Patent Application No. 2007 132763 filed Dec. 17 2007 the disclosure of which is incorporated herein by reference in its entirety.

The present invention relates to an apparatus and method for automatically analyzing a behavior of an application program operating in an operating system and more particularly to an apparatus and method for automatically analyzing a program in order to detect malicious codes that are programmed to perform malicious behaviors only when a specific event occurs or when a specific program execution condition is satisfied.

Current malicious code analysis is generally performed by a security company that creates a pattern for detecting malicious codes through the malicious code analysis. The malicious code analysis takes at least one or two hours or more than one day depending on the capability of an analyzer or an analysis interference level of the malicious code. Also a malicious code detecting scheme by pattern matching cannot positively cope with a new malicious code or a variant of an existing malicious code which does not have the corresponding malicious code sample.

In particular malicious codes such as Trojan horse backdoor and Bot normally operate like other Windows application programs in a general situation but are triggered to perform malicious behaviors only when a specific event incurs or when a specific program execution condition is satisfied. The specific event may include for example receiving a specific packet via a network downloading a command through accessing an external Universal Resource Locator URL etc. The specific program execution condition may include for example a specific time a case other than a debugging mode a case other than a virtual machine etc. Since a normal behavior and a malicious behavior coexist in one program and the malicious behavior generally does not work it is difficult to accurately analyze it with automatic analysis based on a static dynamic analysis scheme.

As to the static analysis scheme there are various techniques disturbing the static analysis. Particularly in the case of compressed execution file since only a decompressed portion of the file is analyzed through the static analysis it is difficult to analyze what kind of behavior the actual file performs.

In order to overcome the above limitation of the static analysis a program behavior analysis schemes using dynamic analysis is widely being studied. A representative example of the dynamic analysis scheme is a sandbox analysis scheme. The sandbox analysis scheme executes a program suspected as a malicious code separately from a currently used system and observes behaviors of the program in many ways for example application program interface API hooking. However the dynamic analysis scheme also may not accurately analyze behaviors of malicious codes such as Trojan horse backdoor and Bot. Since the malicious codes are likely to be programmed to detect that its executing environment is in sandbox and to perform only normal operations there is some constraint on such analysis.

The present invention is directed to an apparatus and method for accurately analyzing behaviors of a malicious code programmed to perform malicious behavior only when a specific event occurs or when a specific program execution condition is satisfied.

The present invention is also directed to an apparatus and method for automatically analyzing behaviors of a malicious code that waits for a specific event or is triggered only when a program execution environment satisfies a specific condition through forced execution that ensures executing each event handler and each statement in a program at least once both when a certain execution condition is satisfied and is not satisfied.

One aspect of the present invention provides an apparatus for automatically analyzing a program including an automatic analysis engine for analyzing statements in a program and generating program execution information by forcefully executing each statement in the program an execution information database for storing the program execution information generated by the automatic analysis engine an execution flow analyzer for analyzing execution flow of the program based on the execution information stored in the execution information database and an execution result provider for providing a user with an execution result based on the execution flow information analyzed by the execution flow analyzer.

Another aspect of the present invention provides a method of automatically analyzing a program including analyzing statements in a program generating and storing program execution information by forcefully executing each statement in the program analyzing execution flow of the program based on the stored execution information and providing a user with an execution result based on the analyzed execution flow information.

Here the forced execution may include determining whether the statement is a conditional branch or an API call when the statement is determined to be the conditional branch executing both a statement branched when a branch condition is satisfied and a statement branched when the branch condition is unsatisfied when the statement is determined to be the API call determining whether a call processing scheme is normally executed and when it is determined to be normal execution performing the API call and otherwise executing a handler registered by the user.

Hereinafter the present invention will be described in detail with reference to embodiments shown in the accompanying drawings. However the detailed descriptions are suggested for exemplary purposes of the present invention and thus the present invention is not limited to a specific physical configuration.

The automatic analysis engine includes a debugger a disassembler and a forced executer in order to generate program execution information through forced execution and statement analysis of a program.

The debugger is a program that executes statements in a program to be analyzed. In an embodiment a debugger engine provided by Windows based operating system may be used as the debugger . According to an embodiment of the present invention prior to executing each statement the debugger turns over control to the forced executer that determines whether forced execution is required.

The forced executer analyzes the statement that is converted to the machine language by the disassembler and determines whether the statement is a conditional branch or an API call to instruct the forced execution of the conditional branch and API handler to the debugger . For the forced execution checkpoint for the conditional branch or the API call is stored in the execution information database . For example in the case of the conditional branch execution state information or context is stored as the checkpoint in the execution information database . In case that the execution flow is selected to branch a statement when the branch condition is satisfied the execution state information including a register value and a memory address to be used by a program process which have been manipulated to go to the other statement branched when the condition is unsatisfied is stored as the checkpoint.

The feature of the present invention is to perform program analysis through forced execution that ensures at least one execution of each statement particularly a conditional branch statement and a statement of registering an event handler. Specifically malicious behavior hidden in a program can be analyzed and detected by forcefully executing a certain statement that is executed only when a specific event occurs or when a specific condition is satisfied. The term forced execution refers to arbitrarily changing execution flow of the program by changing context of the program. For example it is assumed that statement jinz 0x445555 is a statement that branches to 0x445555 when zero forcing ZF bit of a flag register is zero and a value of an Environmental Audio Extension EAX register is not zero and otherwise executes a subsequent statement. When forced execution is not performed an execution flow of the program goes either to a branch at 0x445555 or to the subsequent statement. However when forced execution is performed the execution flow of the program goes both to the branch and the subsequent statement at least once. For example in case of a malicious code that does distributed denial of service DDos attack on a specific site at only a specific time it is not possible to obtain satisfactory analysis results of the malicious cod because it does not DDos attack other time except for the specific time. However when the forced execution performs both a case where the branch condition is satisfied in the time comparison statement and a case where the branch condition is unsatisfied in the time comparison statement are both performed and thus it is possible to verify that behavior associated with the DDos attack is included in the malicious code.

In the Windows system since an event is generally registered by an Application Programming Interface API it is possible to know an address of an event handler. According to the present invention since the execution state i.e. context of a program is changed using the address obtained as above it is possible to analyze behaviors performed in all the registered event handlers even if an actual event does not occur. Also forced execution is performed with respect to the case where the branch condition is satisfied and the case where the condition is unsatisfied in all the conditional branch statements which results in making it possible to perform and analyze all the statements described in the program at least once.

The forced executer of the present invention has following important characteristics for effective forced execution.

First the forced executer accurately maintains program context. For this according to one embodiment program context in checkpoint of a forced execution is stored in a stack.

Second when a conditional branch is included in a loop it controls one conditional branch to be executed only once in one execution flow. When a program performs the loop and a conditional branch is included in the loop if the conditional branch is forcefully executed every time the loop is performed execution paths may increase in geometrical order. Accordingly the present invention aims to achieve 100 state coverage instead of code coverage in order to prevent the geometrically progressive increase in execution paths.

Third the forced executer does not let the program fall into infinite loop. For this according to one embodiment the forced executer informs a user of time taken for execution flow by a block basis. When the user determines that it takes much time for the analysis the forced executer temporarily suspends the analysis and shows the user an analyzed code part to determine whether there is an infinite loop. In this case when the user determines there is an infinite loop the forced executer completely suspends the current execution flow analysis and prepares another execution flow analysis.

Referring again to the execution information database stores checkpoint information processed by the forced executer and also stores statements executed by the forced executer . In an embodiment the checkpoint is stored in a stack structure.

The execution flow analyzer analyzes executed statements by a function unit with reference to the execution information database creates system call information API name a Control Flow Graph CFG a Call Site Flow Graph CSFG etc. and stores them in the execution information database .

The execution result provider responds to user queries based on information stored in the execution information database . The user queries may include variable values used in a specific conditional branch the CFG the CSFG the call location of a specific function etc.

In step when program analysis starts the forced executer stores process execution state or context information of a program to be analyzed in a stack.

In step the forced executer inspects the stack to determine whether context is stored in the stack. When the stack is empty the forced execution procedure is terminated.

In contrast when the context is stored in the stack the forced executer pops one context out of the stack in step and sets the popped context as a context of a process of the program executed by the debugger and starts a new execution flow in step .

In step when the debugger turns over control to the forced executer prior to executing each statement the forced executer monitors a statement to be executed in the debugger .

In step the forced executer determines whether the statement is a system call or an API call. In step when the statement is determined to be the system call or the API call the forced executer determines whether a call processing scheme is normal execution. In step when it is determined that the call processing scheme is set to the normal execution the forced executer executes the statement. However when it is not the normal execution the forced executer checks whether there is a handler registered by the user in step . When there is the registered handler the forced executer turns over program control to the registered handler to execute the handler in step . When it is not the normal execution and when there is no registered handler the forced executer ignores the corresponding call and goes to step .

In an embodiment when CreatRemoteThread or CreateThread that is ThreadCreate API is called the forced executer identifies a factor of the API called from API handler obtains a parameter and ThreadProc value and then stores central processing unit CPU register information and memory region currently used by the process of the program and changes EIP to the start address of ThreadProc to thereby execute the thread. Accordingly it is possible to analyze internal behaviors of the thread without creating the actual thread.

Similarly with respect to API registering a callback function it is possible to analyze behaviors of the callback function by obtaining an address of the call back function registered in the API handler and then performing forced execution on the callback function.

In step when the handler execution is completed the forced executer determines whether to terminate current forced flow. Also when there is no registered handler the forced executer determines whether to terminate current forced flow.

When it is not determined to be the API call in step the forced executer determines whether the corresponding statement is a conditional branch in step . When the corresponding statement is not the conditional branch the forced executer executes the corresponding statement in step and determines whether to terminate current execution flow in step . In contrast when the corresponding statement is the conditional branch the forced executer determines whether it is the conditional branch statement initially executed in the current execution flow through comparison between an address value of the statement and the statement.

When the corresponding statement is the initially executed conditional branch the forced executer changes program context for example a PC or EIP a flag register value and a variable value used for condition comparison for forced branch and then stores the changed program context in the stack in step . The variable for forced branch may be obtained by a symbolic expression matching scheme. Next the forced executer goes to step to execute the corresponding statement and then goes to step . For example when the conditional branch is if A B . . . it is expressed as combination of a statement of emp series comparing values of A and B and a statement of Jcc series for example jne je jnz etc. cmp is a statement to change the flag register value and execute branch of jne je etc. according to the changed flag register value. Here when a 10 b 5 if a b a 1 else b 1 syntax of a 1 is generally required to be executed but syntax of b 1 may be executed at this point in time. This is the forced execution syntax. Accordingly cmp indicates to designate subsequent EIP as b 1 for the forced execution and changes the flag resister value storing a result of a b cmp statement .

In contrast when the corresponding statement is an already executed conditional branch statement the forced executer executes the corresponding statement without storing context. This is to make one conditional branch statement be performed only once in one execution flow in order to prevent repetitive increase in execution paths to be executed by the conditional branch every time each loop is performed when the conditional branch exists in the program loop.

The forced executer determines whether the execution flow is terminated in step and when not terminated performs statement monitoring step and when terminated performs step to start the new execution flow and check whether context is stored in the stack.

According to the present invention the execution context of a program may change through a forced execution algorithm. Accordingly even when an actual event does not occur it is possible to analyze behaviors performed by all the registered event handlers. Also since the forced execution is performed with respect to a case where the condition is satisfied and a case where the condition is unsatisfied in all the conditional branch statements all the statements described in the program can be executed at least once. Through this it is possible to analyze and detect behaviors of a malicious code triggered only when a specific context is satisfied or a specific event occurs.

A first execution flow is 1 checkpoint 2 checkpoint 4 6 checkpoint 2 4 6 7 checkpoint 8 a checkpoint c b d and 9. A second execution flow is started after restoring checkpoint c by steps and of and thus is 1 2 4 6 2 4 6 7 8 a c d and 9. A third execution flow is 1 2 4 6 2 4 6 7 1 2 4 6 7 8 a checkpoint c b d and 9. Referring to the third execution flow it can be seen that checkpoint c is performed again after performing a. This is because the conditional branch statement performed initially appears in the third execution flow corresponding to the current execution flow in step . A fourth execution flow is 1 2 4 6 2 4 6 7 1 2 4 6 7 8 a c d and 9 and a fifth execution flow is 1 2 4 6 7 8 a checkpoint c b d and 9. When the above procedure is repeated and there is thereby no new execution flow the forced execution algorithm is terminated.

As described above according to the present invention all the statements in the program are automatically executed at least once through the forced execution to analyze behavior of the program. Therefore it is possible to analyze the behavior of a malicious program executed only when a specific event occurs or when a specific program execution condition is satisfied. According to the present invention since time and manpower for malicious code analysis can be reduced it is possible to rapidly cope with the malicious code.

According to the present invention it is also possible to provide analysis result about behavior of a program thereby enabling the analysis result to be used as reference data for determining whether the program is malicious. It is expected that analysis data about behaviors of carious programs will be used as reference data for developing a scheme that can detect new variant and unknown malicious codes.

While the invention has been shown and described with reference to certain exemplary embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.

