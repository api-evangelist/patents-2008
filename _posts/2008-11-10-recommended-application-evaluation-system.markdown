---

title: Recommended application evaluation system
abstract: A code evaluation tool greatly reduces time, cost, and other resource expenditures needed to validate that an application implements desired functionality. The tool is a search, navigation and visualization tool that accepts high-level processing concepts as inputs to identify, rank, and return the code of a recommended application. A software developer may use the tool to validate that functional requirements are met by the recommended application. The tool provides an efficient way to improve the evaluation of application logic to validate that the application meets specified functional requirement and implements the desired high-level processing concepts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021416&OS=09021416&RS=09021416
owner: Accenture Global Service Limited
number: 09021416
owner_city: Dublin
owner_country: IE
publication_date: 20081110
---
This application is a continuation in part of U.S. patent application Ser. No. 11 804 030 filed May 16 2007 which is incorporated herein by reference in its entirety.

This disclosure concerns evaluating applications identified as implementing desired functionality. In particular this disclosure relates to a search navigation and visualization tool that accepts high level processing concepts as inputs that drive a multi layered search of an application to validate that the logic of the application actually does implement desired functionality.

Software professionals widely recognize that applications often fail to implement functionality as described by the application descriptions and project summaries of the applications. Software professionals use various inadequate techniques to reduce the time money and other costs for validating that an application implements particular functionality. Software professionals recognize API calls as forms of abstraction for high level processing concepts and merely search for the existence of particular API calls to validate that the application implements a desired functionality. For example an API call may be identified and or described as implementing pull down menu functionality although the underlying logic may not actually include the logic necessary to deliver the functionality of a pull down menu. Current logic evaluation techniques and tools require significant resources and user expertise to accurately validate that an application implements functional requirements in support of high level processing concepts. Modern search engines do not ensure that the logic of applications identified by the search engines actually implement the functionality as described by the project summaries and documentation of the application.

Software professionals consider the mismatch between the high level processing concepts e.g. the intent reflected in the descriptions of applications and low level implementation details e.g. API calls and actual run time behaviour found in application logic a fundamental technical challenge to validating that an application implements particular functionality. Software professionals intend to author meaningful descriptions of applications in the course of depositing applications into software repositories. The mismatch between the description of an application and the actual behaviour of the application represents one example of the vocabulary problem which states that no single word or phrase best describes a programming concept.

In the spiral model of software development stakeholders describe high level processing concepts to development teams and together the stakeholders and development teams identify requirements in support of the high level processing concepts. In addition a development team builds a prototype based on the requirements and the development team demonstrates the prototype to the stakeholders to receive feedback. Prototypes attempt to approximate the desired high level processing concepts e.g. features and capabilities of the new application stakeholders desire development teams to build. The feedback from stakeholders often leads to changes to the prototype and the original requirements as stakeholders iteratively refine their vision. In the event the stakeholders make a substantial number of changes to the requirements the development team often discards the prototype and builds a new prototype and another iteration of refinements repeats. Building prototypes repeatedly without reusing existing application logic costs organizations a great deal in the form of wasted project resources and time. Deploying an application without adequately evaluating and validating that the logic of the application implements desired functionality further complicates software development.

Development teams find the task of evaluating and validating that the logic of an application approximates high level processing concepts and requirements of a software project resource intensive. In the context of application deployment software development professionals consider such application logic as highly relevant application logic HRAL . Many application repositories e.g. open source repositories and source control management systems maintained by stakeholders internally contain hundreds of thousands of different existing applications e.g. potential highly relevant applications HRAs . Unfortunately developers find it difficult to validate the logic of applications because of the time and expense involved in searching the application evaluating and validating that the logic of the application implements particular functionality.

The amount of intellectual effort that a developer must expend to move a software system from one stage of development to another may be considered the cognitive distance . For example using current search tools developers expend significant intellectual effort to validate that an application implements desired functionality. Many developers employ search engines that identify exact matches between keywords that are entered as part of the search query and the words found in an application. The application may include descriptions application logic comments program variables names and variable types of the application. Such search engines actually increase the difficulty of validating the application because of the poor quality of information contained in application and the inability to reduce the cognitive distance required to validate that the logic of the application implements the desire functionality as well as other factors. Additionally many applications include incomplete misleading and inaccurate descriptions of the application. Consequently even matching keywords with words found in the application description does not guarantee that the search engine will identify application logic that actually implements desired functionality e.g. highly relevant application logic HRAL .

Effective software evaluation techniques reduce the cognitive distance between the initial concept of a system e.g. high level processing concepts that expressly and implicitly describe the features and capabilities of an application validating discrete requirements and the production implementation of the application. Unfortunately current application evaluation tools lack the ability to reduce the cognitive distance related to validating application logic to identify HRAL.

For example an application description may indicate that an application includes an encryption feature when in fact the application uses compression as a crude form of encryption. A developer entering encryption e.g. as a high level processing concept and specific requirement as a keyword may waste precious time to review a search engine result containing the incorrectly described logic of an application and ultimately discard the result because the application fails to meet the encryption requirement. The developer must locate and examine fragments of the application logic that allegedly implements encryption before determining that the application fails to meet the requirement. The developer may spend scarce project development budget resources and significant amount of time to analyze the application before determining that the application is not relevant. The developer may even observe the runtime behavior of the application to ensure that the behavior matches the high level processing concepts desired by the stakeholders and meets the requirements in support of the high level processing concepts before establishing that the logic of the application qualifies as HRAL. Current evaluation tools also lack the ability to assist developers to rapidly identify requirements in support of high level processing concepts described by stakeholders.

Some evaluation tools return code snippets e.g. segments of application logic however code snippets do not give enough background or context to assist developers to rapidly evaluate and validate the logic and such evaluation tools require developers to invest significant intellectual effort e.g. cognitive distance to understand the broader scope of the code snippets. Other existing approaches and tools retrieve snippets of code based on the context of the application logic that developers work on but while these approaches and tools improve the productivity of developers they do not return highly relevant applications logic from high level processing concepts as inputs.

A need has long existed for a system and method that efficiently evaluates and validates application logic to identify HRAL and deployable application.

The recommended application evaluation system RAE provides a way to rapidly and efficiently evaluate the logic of recommended applications to validate that the recommended applications actually do implement highly relevant application logic HRAL . One implementation of RAE includes a machine readable medium and logic stored on the machine readable medium that implements RAE area logic. The RAE area logic is operable to obtain recommended applications e.g. highly relevant applications HRAs for evaluation. The recommended applications may be supplied to the RAE in the form of source code for the recommended application or in other forms.

The RAE area logic presents a concept query display region that displays topics concepts and words of a query used to find the recommended applications. The RAE area logic presents a concept distribution display region that displays a recommended application representation of one of the recommended applications. The recommended application representation includes concept distribution locators that identify potential implementation locations of one of the topics concepts and words. The RAE area logic presents a source code display region that is responsive to a selection of one of the concept distribution locators. The source code display region displays a portion of the source code that includes the potential implementation location for the selection of one of the concept distribution locators. The RAE area logic presents a metadata display region that displays metadata generated upon execution of the query.

In one implementation the recommended applications e.g. HRAs are identified using the EXEcutable exaMPLes ARchive system Exemplar . Exemplar identifies the location e.g. concept distribution locators in application logic where an API call implements a high level processing concept. Using Exemplar a developer enters high level processing concepts e.g. toolbar download smart card as input e.g. initial query keywords and Exemplar uses information retrieval and program analysis techniques to retrieve HRAs that implement the high level processing concepts in the application. Exemplar may also accept various types of inputs that describe high level processing concepts e.g. concept text identifiers concept visual identifiers concept audio identifiers and any other sensory identifier usable to identify high level processing concepts . Exemplar uses the help pages and help documentation of third party libraries software development kits and other middleware to produce a list of names of API calls that Exemplar in turn uses to expand an initial query query expansion to identify the highly relevant application logic of an application. Exemplar determines the behavior of the application logic and API call logic and ranks the API calls.

Exemplar uses help documentation or other trusted sources that describe API calls to expand queries. An application provider typically provides the help pages and help documentation for their applications which developers consider reliable and a trusted source. In particular developers consider application providers trusted sources for help pages and help documentation of popular and widely used applications written by large development teams produced under rigorous testing and development best practices and used by other developers who provide feedback regarding documentation using different forums e.g. user groups . Developers trust help documentation over the descriptions of applications included in application repositories because application providers generally produce more verbose and accurate help documentation than the descriptions of applications included in application repositories. Developers also trust help documentation because many different people and review procedures are typically used to produce help documentation.

Exemplar query expansion increases the probability of identifying logic matches that validate that the logic is highly relevant application logic and addresses the vocabulary problem mentioned above by expanding an initial query to include new keywords metadata and semantics information found in help pages and other help documentation determined to have similar meanings to the keywords originally used by a developer in the initial query. Exemplar expands an initial query to include the names of API calls with semantics that reflect in many cases unequivocally specific behaviour of the application. Exemplar locates application logic containing the API calls that exhibit desired semantics by identifying API calls through help pages and help documentation. Exemplar provides a user interface that developers can use to navigate directly to the various locations to determine how an HRA implements high level processing concepts.

Exemplar may rank HRAs according to the number of high level processing concepts implemented by each API call found in the HRAs or based on other ranking metrics. In other words since API calls implement high level processing concepts the more high level processing concepts implemented by an HRA the more relevant the HRA and the higher the rank assigned to the HRA. Exemplar considers keywords included in queries to represent logically connected concepts. Often a question structured as a sentence forms the basis for a query from which a developer extracts keywords to form the query. For example consider the query send receive secure XML. Where a query presents a relation between multiple concepts e.g. send secure XML then a relation should exists between API calls that implement the concepts in the corresponding application logic e.g. API calls that encrypt process or handle XML formatted content and transmit content . Application logic often preserves the relations between concepts e.g. control flow and data flow links an instance of the software reflection model concept and known as connectivity heuristics. Exemplar calculates HRAs rankings based on analyzing the connectivity heuristics of API calls that implement the concepts included in the queries. Exemplar uses program analysis algorithms and computes control flow graphs CFG and data flow graphs DFG to analyze the connectivity heuristics of API calls.

RAE provides a way to rapidly and efficiently evaluate the logic of recommended applications to validate that the recommended applications implement highly relevant application logic HRAL .

Other systems methods and features of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the following claims.

The recommended application evaluation system RAE solves the technical problem of providing a tool to easily and quickly evaluate a recommended application to validate that the recommended application implements a particular functionality. In one implementation the RAE may evaluate recommended applications obtained from the EXEcutable exaMPLes ARchive system Exemplar .

Exemplar provides a tool that accepts high level processing concepts as queries to identify determine the behavior rank and return the application logic of HRAs. Exemplar solves an instance of the difficult vocabulary problem that exists when users and developers describe processing concept with different words. Exemplar is not limited to basic keyword matching used in queries against application descriptions and comments included with application logic. Accordingly when an application is highly relevant and where a query contains keywords different from the words used by the developer to describe application logic and API call logic Exemplar nevertheless returns the application as a highly relevant application.

Exemplar matches high level processing concepts e.g. expressed using keywords with the descriptions of various API calls found in help documents or other trusted descriptive sources. Because a typical application invokes API calls from several different libraries several different people who use different vocabularies often author help documents associated with API calls. The richness of different vocabularies increases the probability of finding matches and producing a long list of potentially relevant applications and API calls. Searching help documents or other trusted descriptive sources produces additional benefits. For example help documents including an API call often indicate where the application logic implements the API call. Consequently Exemplar may direct a developer to the location in application logic where an API call implements a high level processing concept. The developer may then determine the relevance of the application logic and API call logic. In other words the developer may determine whether the application logic and API call logic actually support the high level processing concept.

Although specific components of Exemplar and RAE will be described methods systems and articles of manufacture consistent with Exemplar and or the RAE may include additional or different components. For example a processor may be implemented as a microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other type of circuits or logic. Similarly memories may be DRAM SRAM Flash or any other type of memory. Logic that implements the processing and programs described below may be stored e.g. as computer executable instructions on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. An example of such a signal is a physical layer Ethernet signal bearing TCP IP packets that include program source code or executable programs. Flags data databases tables and other data structures may be separately stored and managed may be incorporated into a single memory or database may be distributed or may be logically and physically organized in many different ways. Programs may be parts of a single program separate programs or distributed across several memories and processors. Furthermore the programs or any portion of the programs may instead be implemented in hardware.

In one implementation the EPAD user interface expanded search engine heuristic relevance ranking engine and logic analyzer form an Exemplar system within the Exemplar environment . The Exemplar system may include additional or different components. The Exemplar system may communicate with the help content processor help content API calls dictionary and logic repository as well as other systems through the networks e.g. Internet as external systems.

The logic repository may include application logic and API call logic . The Exemplar system accepts high level processing concepts e.g. send secure XML as input and produces output identifying which application logic and API call logic developers may use to prototype and develop new applications implementing the high level processing concepts. In one implementation the Exemplar environment implements the help content and the logic repository with multiple storage devices e.g. multiple databases on different disk drives and interfaces to help content application logic and API call logic from various available source e.g. local or remote help databases websites knowledge exchanges document repositories or other sources .

In one implementation the help content processor may be implemented as a web crawler that traverses available application repositories and downloads help content e.g. application descriptions and logic repository content e.g. application logic and API logic . The help content processor may also perform full text indexing on the help content and the logic repository content. The help content processor may further produce an API calls dictionary that includes sets of tuples a form of ordered list that link selected words from the descriptions of the API calls to the names of the API calls.

The description above used the examples of application logic and API call logic . These types of logic may be program source code e.g. C or C code for example. However the Exemplar environment may search analyze and determine relevance for many other types of logic. As examples the logic repository may include programs or program components expressed in a visual programming language using graphical program elements and spatial arrangements of text and graphic symbols. The visual programming logic may include icon based logic form based logic diagram based logic or other types of visual expression. The visual expression may be consistent with dataflow languages flow based programming domain specific modelling or other programming paradigms.

In one implementation the Exemplar environment and the RAE are present in a RAE environment . The RAE includes a RAE user interface generation logic that comprises RAE area logic . The RAE area logic comprises concept query display logic concept distribution display logic source code display logic and metadata display logic . Aspects of the RAE are discussed in further detail below.

The expanded search engine may combine the original query and the basis API call list to form an expanded query . The expanded search engine may execute an expanded search using the expanded query to search through the logic repository to obtain an expanded search result . In one implementation the logic repository may return the expanded search results to the heuristic relevance ranking engine . The expanded search result may contain a list of potentially relevant applications and potentially relevant API calls that the heuristic relevance ranking engine analyzes using the logic analyzer . In one implementation the heuristic relevance ranking engine may include the logic analyzer . The logic analyzer may include a parser generator such as ANTLR ANother Tool for Language Recognition available from www.antlr.org that provides support for generating data flow graphs and control flow graphs.

The logic analyzer may return connectivity rankings discussed in detail below to further determine an application heuristic relevance ranking and an API call heuristic relevance ranking . The heuristic relevance ranking engine may return the application heuristic relevance ranking and an API call heuristic relevance ranking to the EPAD user interface . The expanded search engine may also return a relevant applications list and a relevant API calls list to the EPAD user interface . The Exemplar system may assign an application heuristic relevance ranking to one or more relevant applications found in the relevant applications list to indicate how closely each relevant application supports the high level processing concept represented by the original query . Similarly Exemplar system may assign an API call heuristic relevance ranking to one or more relevant API calls found in the relevant API call list to indicate how closely each relevant API call supports the high level processing concept represented by the original query .

In one implementation the RAE area logic obtains the connectivity rankings the application heuristic relevance rankings the API call heuristic relevance rankings the relevant applications list and the relevant API call list . The RAE area logic may use the connectivity rankings the application heuristic relevance rankings the API call heuristic relevance rankings the relevant applications list and the relevant API call list to present a recommended application evaluation area discussed in detail below to evaluate recommended applications obtained from Exemplar .

Table 1 shows an example of an original query in the form of a structured query language statement SQL that represents the high level processing concept compress uncompress ZIP file . Table 1 shows that the original query will search the help content e.g. Java Help Documents to identify a basis API calls list .

Table 2 shows one example of the help content represented by a fragment of Java Help Documentation released by Sun Microsystems Inc. that describes the functionality of classes exported from the Java.util package. The Java.util package defines a number of classes primarily collections classes that a developer may use when working with groups of objects. Referring to Table 2 the help content processor may identify partial matches for the class ZipEntry to the original query . The help content processor may search the help content and identify a fragment of the help documentation for the ZipEntry class shown in Table 3.

Table 3 shows the descriptions of two different methods e.g. getCompressedSize and setMethod for the ZipEntry class that include the terms compress and uncompress found in the high level processing concept compress uncompress ZIP file . The basis API call list may include the getCompressedSize and setMethod methods.

Table 4 shows an example of two equivalent forms of an expanded query that expand the original search from the help content e.g. Java Help Documents to the logic repository using the basis API call list from the original query . Table 4 statement A shows the getCompressedSize and setMethod that may be included in the basis API call list . Table 4 statement B shows the expanded query as a nested query where the original query and the basis API call list e.g. getCompressedSize and setMethod drive the outer query that searches the logic repository for potentially relevant applications to obtain the expanded query result including potentially relevant applications and potentially relevant API calls . The expanded query may improve upon the original query by targeting the search performed against the logic repository to obtain application logic with a high probability of including potentially relevant applications and potentially relevant API calls .

Table 5 shows another example of two equivalent forms of an expanded query that expand the original search from the help content e.g. Java Help Documents to the logic repository by combining the original query and the basis API call list to form the expanded query . Table 5 statement A shows the getCompressedSize and setMethod e.g. the basis API call list combined with the original query . Table 5 statement B shows the expanded query as a nested query where the original query and the basis API call list e.g. getCompressedSize and setMethod drive the outer query that searches the logic repository for potentially relevant applications to obtain the expanded query result including potentially relevant applications and potentially relevant API calls . The expanded query may improve upon the original query by targeting the search performed against the logic repository to obtain application logic with a high probability of including potentially relevant applications and potentially relevant API calls .

Table 6 shows an example of a fragment of logic extracted from the logic repository e.g. potentially relevant application that includes a potentially relevant API call e.g. getCompressedSize .

The relevant API list display area may include the relevant API call list returned by Exemplar system based on the original query . The relevant API call list may include a relevant API call identifier 1 e.g. a function call name and a relevant API call identifier 2 of the relevant API call logic 1 e.g. source code for the function call and relevant API call logic 2 respectively. The EPAD project area may present the relevant API call identifier 1 and the relevant API call identifier 2 as user selectable indicated by the arrow to display and highlight the relevant API call logic 1 and the relevant API call logic 2 in the logic display area . In one implementation the logic display area may highlight the relevant application logic and relevant API call logic 1 and relevant API call logic 2 so that the user can further determine the relevance of the logic to the high level processing concept represented in the original query .

The heuristic relevance ranking results display area shown in may include an application relevance threshold an API call relevance threshold data flow graph control flow graph and an API call graph . The heuristic relevance ranking results display area may display heuristic relevance ranking engine information to assist the user to determine the relevance of user selected logic. As will be described in more detail below the heuristic relevance ranking engine may determine the application heuristic relevance ranking for the relevant application logic based on the number of relevant API calls e.g. relevant API call logic 1 and relevant API call logic 2 found in the relevant application logic in comparison to other relevant application logic identified by Exemplar system . For example the high level processing concept example compress uncompress ZIP file may be entirely implemented in relevant application logic but only partially implemented in the other relevant application logic . As a result the heuristic relevance ranking engine may assign the relevant application logic a higher application heuristic relevance ranking than the other relevant application logic . In another implementation the heuristic relevance ranking engine may determine the API call heuristic relevance rankings of the relevant API call logic 1 and the relevant API call logic 2 based on analyzing semantics derived from the expanded query and the expanded search result which establish the behaviour of the relevant API call logic 1 the relevant API call logic 2 and the relevant applications logic 1 .

The application relevance threshold and API call relevance threshold shown in may be user selectable and or pre configured with system default values. In another implementation Exemplar system may determine the application relevance threshold and the relevance threshold based a number of factors e.g. the complexity of the high level processing concept represented by the original query and the number of potentially relevant applications and potentially relevant API calls identified by the expanded search result . Exemplar system may use the application relevance threshold and the relevance threshold to further refine the relevant applications list and the relevant API calls list respectively. In one implementation the application relevance threshold and the relevance threshold may determine an application heuristic relevance ranking value that the potentially relevant applications must meet to be included on the relevant applications list . The API call relevance threshold may also determine the API call heuristic relevance ranking value that the potentially relevant API calls must meet to be included on the relevant API calls list . For example an application relevance threshold of 1 may indicate a low relevance requirement e.g. requiring loosely relevant applications and low application heuristic relevance rankings and allow a large number of potentially relevant applications to qualify as relevant applications e.g. relevant application logic 1 . In another example an application relevance threshold of 10 may indicate a high relevance requirement e.g. requiring highly relevant applications and high application heuristic relevance rankings and allow only a fewer number of potentially relevant applications to qualify as relevant applications. The heuristic relevance ranking engine may also use the data flow graph and control flow graph to determine the application heuristic relevance ranking and API call heuristic relevance ranking and visually describe the relationships between the relevant application logic the relevant API call logic 1 and the relevant API call logic 2 discussed in further detail below.

The relevant API call logic 1 and the relevant API call logic 2 may be user selectable indicated by the arrow and provide the user the ability to generate a new application with the selected logic. To that end the EPAD project area may implement point and click drag and drop functionality for a user to select relevant API call logic 1 and relevant API call logic 2 to generate the new application . The EPAD project area may also build the new application by combining user selectable other relevant application logic relevant API call logic 1 and relevant API call logic 2. The application creation display area may also identify requirements for the high level processing concept represented by the original query . For example a developer may desire to identify and confirm the requirements for implementing a high level processing concept e.g. send secure XML . In one implementation Exemplar may generate requirements documentation and end user documentation based on the help content related to the other relevant application logic the relevant API call logic 1 and the relevant API call logic 2 used to build the new application and identify the requirements in support of the new application .

The memory may also include expanded search logic . Table 5 above shows an expanded query where the search logic forms the expanded query by combining the original query and the basis API call list to form the expanded query . More generally the expanded search logic combines the original query and the basis logic results to form the expanded query and executes an expanded search using the expanded query . The basis logic results may include the basis API call list including zero or more basis API call identifiers e.g. the basis API call identifier 1 and a basis application list including zero or more basis application identifiers e.g. the basis application identifier 1 . The expanded search logic thereby obtains the expanded search results . The expanded search result may include potentially relevant applications and potentially relevant API calls that include zero or more potentially relevant application identifiers 1 and zero or more potentially relevant API call identifiers e.g. potentially relevant API call identifier 1 and potentially relevant API call identifier 2 .

The memory may also include analyzer logic that the processor executes to identify application metadata and API metadata of the potentially relevant applications and the potentially relevant API calls respectively. Examples of application metadata include application descriptions application logic comments application parameter names and application parameter types of existing applications. Similarly examples of API metadata include API descriptions API logic comments API parameter names and API parameter types.

The analyzer logic may generate the data flow graph and control flow graph to obtain the API call graph . The API call graph may include nodes e.g. node 1 and node 2 that represent potentially relevant API calls and data flow edges e.g. data flow edge between the potentially relevant API calls to indicate data flow. provides additional examples. The analyzer logic may determine the data flow edge count corresponding to the number of connections between potentially relevant API calls within the potentially relevant application . A graph with n nodes has as many as n n 1 edges between nodes. The data flow edge count provides insight into the degree of connectedness for the data flow graph . The analyzer logic may also assign link values to the edges between nodes discussed in detail below. In one implementation the analyzer logic may determine the connectivity rankings e.g. strong connectivity ranking and weak connectivity ranking for each connection between the potentially relevant API calls based on common API parameters discussed in detail below.

In one implementation the logic analyzer produces the API call graphs . The logic analyzer may identify the application metadata and API metadata of the potentially relevant applications and the potentially relevant API calls respectively to analyze the data flow paths and connectivity between the potentially relevant API calls . The logic analyzer may provide the application metadata and API metadata to the heuristic relevance ranking engine . In an alternative implementation the heuristic relevance ranking engine may identify application metadata and API metadata and produce the data flow graph and control flow graph using logic analysis formulas rules and equations to obtain the API call graphs . The data flow graphs control flow graphs and API call graphs may be represented as mathematical structures. The logic analyzer may obtain the API call graphs as a result of comparing data flow and control flow between potentially relevant API calls .

In one implementation the logic analyzer may perform control flow analysis on the potentially relevant application to obtain control flow graphs and perform data flow analysis on the control flow graphs to obtain data flow graphs. The data flow graphs control flow graphs and API call graphs may similarly include nodes and edges. The logic analyzer may obtain a control flow graph by logically partitioning a potentially relevant application as a result of parsing the logic of the potentially relevant application into nodes that represent logic that includes API calls. The logic analyzer may assign parsed logic of the potentially relevant application to an assigned node until the logic analyzer identifies a potentially relevant API call or branching logic e.g. if then switch case and do while and add the assigned node to the control flow graph . Where a program includes multiple potentially relevant applications the logic analyzer may merge the control flow graphs produced for each potentially relevant application into a single control flow graph . The logic analyzer may obtain the API call graph by comparing the edges in the control flow graphs with the edges in the data flow graph . For example where a control flow graph includes an edge that a data flow graph does not include the logic analyzer may not include the edge in the corresponding API call graph . However where a control flow graph includes an edge that the data flow graph also includes the logic analyzer may include the edge in the API call graph .

In one implementation the logic analyzer may receive user input to determine particular dependencies between API calls. For example where a potentially relevant application uses a function pointer e.g. a type of pointer used in C and C languages to reference a potentially relevant API call and a hash table e.g. a data structure that associates keys with values to store an object that represents a data element passed between API calls the logic analyzer may receive user input to determine dependencies between API calls because the logic analyzer may otherwise interpret multiple possible dependencies between API calls when in fact only one or a finite set of valid dependencies exists.

In another implementation the logic analyzer may analyze the data flow paths e.g. edges between nodes discussed below e.g. link heuristics of the potentially relevant applications and potentially relevant API call logic to determine the connectivity rankings of each connection between potentially relevant API calls . In one implementation the heuristic relevance ranking engine may determine the application heuristic relevance ranking for the potentially relevant application shown in as potentially relevant application A based on the total number of API calls n represented by nodes that represent different potentially relevant API calls found in the potentially relevant application the total number of connections between the potentially relevant API calls e.g. edges equal to n n 1 e.g. data flow edge count the quality of the connections e.g. strong connectivity or weak connectivity and the type of link e.g. loop link single link or no link between the potentially relevant API calls .

The applications metadata and API metadata may describe the data flow paths between the different potentially relevant API calls e.g. nodes within the potentially relevant application . For example the logic analyzer may determine common API parameters and logic branches e.g. if then else found within the potentially relevant application and potentially relevant API calls to generate the data flow graphs control flow graphs and API call graphs . The logic analyzer may as also illustrates identify the function e.g. K x J x S y P y F x and G z of each potentially relevant API call e.g. and to determine the connectivity rankings .

In one implementation the logic analyzer may assign a weight W e.g. connectivity ranking to each connection between the potentially relevant API calls e.g. nodes . The logic analyzer may assign weak connections a weight of 0.5 and strong connections a weight of 1.0 depending on multiple factors. For example edge edge and edge may represent weak connections between potentially relevant API calls represented by node pairs and and and and e.g. function pairs K x and F x K x and J x and S y and P y respectively . Following the above example where functions K x and F x share a common API parameter but neither function generates the value of the common API parameter then the logic analyzer may assign the connectivity ranking between node pair and represented by edge a weak connection weight of 0.5. A weak connection assigned to a node pair e.g. and may indicate a low relative probability e.g. in comparison to the connectivity rankings of other node pairs that the node pair implements the high level processing concept represented by the original query . The logic analyzer may use other heuristic analysis methods and tools to determine whether to assign a weak connection to a connectivity ranking .

Alternatively edge and edge may represent strong connections between potentially relevant API calls represented by node pairs and and and e.g. function pairs K x and P y and J x and S y respectively . The logic analyzer may determine that where function J x produces variable y which both J x and S y share then the node pair and represented by edge may be assigned a strong connectivity ranking . A strong connection assigned to a node pair e.g. and may indicate a high relative probability e.g. in comparison to the connectivity rankings of other node pairs that the node pair implements the high level processing concept represented by the original query . The logic analyzer may use other heuristic analysis methods and tools to determine whether to assign a strong connection to a connectivity ranking .

The logic analyzer may also assign a link value L e.g. link value to each connection between potentially relevant API calls . For example Exemplar system may assign a link value L equal to 1 where a loop link e.g. edges form a loop exists between potentially relevant API calls e.g. nodes . Exemplar system may assign a link value L equal to 0.5 where a single link e.g. edge exists between potentially relevant API calls e.g. nodes . In another implementation Exemplar system may assign a link value L equal to 0 where no link exists between potentially relevant API calls e.g. node represents a potentially relevant API call that does not have a connection with other potentially relevant API calls in a potentially relevant application . Additional different or fewer weights may be used. The heuristic relevance ranking engine may use the connectivity rankings and link values assigned to each connection between potentially relevant API calls to determine the application heuristic relevance ranking according to 

The logic analyzer may determine an API call heuristic relevance ranking for a potentially relevant API call based on the connectivity ranking and link value assigned to each edge that includes the potentially relevant API call . For example where m represents the number of node pair including a particular node e.g. and and and and and the number of edges e.g. and that include the node equals m m 1 and the assigned value for each connectivity ranking and link value for each edge that includes the node represent W and L respectively the API call heuristic relevance ranking for the node may be determined according to Equation 1 above where m substitutes for n 

The RAE area logic may include graphics libraries window rendering calls and other user interface logic operable to display interface elements receive input and pass the input to any particular program logic in the RAE . The RAE area logic may further include the concept query display logic the concept distribution display logic the source code display logic and the metadata display logic . The concept query display logic may include topics words and concepts of the original query and or the expanded query . The concept query display logic accepts the topics words concepts the original query and the expanded query from Exemplar and generates a window in the RAE user interface as described in more detail in connection with that presents the topics as selectable focus items for verifying recommended application functionality.

The concept distribution display logic may include recommended application representations of the recommended applications e.g. HRAs . In one implementation the recommended applications include the relevant application logic and relevant API call logic e.g. and obtained from Exemplar based on the original query and or the expanded query . The recommended application representations include concept distribution locators that identify potential implementation locations of one of the topics concepts and words. Exemplar identifies the location e.g. concept distribution locators in application logic where an API call implements a high level processing concept. The concept distribution display logic generates a visualization of a recommended application. The concept distribution display logic may for example generate a concept distribution display region that shows one or more of the modules source code files header files library files or other recommended application source files. The concept distribution display logic further locates within the recommended application source files the API calls that implement the topics words concepts the original query and the expanded query selected by an operator. The concept distribution display logic may denote each location with a concept distribution locator such as a solid horizontal line with hyperlink functionality through the recommended application source file at the location where the API call exists in the source file. Other concept distribution locators may be used such as geometric shapes e.g. circles squares and e.g. fonts graphics e.g. lines or pointers color and or sound .

The concept distribution display logic is operable to receive concept distribution locator selections . The concept distribution display logic may convey the concept distribution locator selection to the source code display logic . As described in more detail below the source code display logic generates a source code display region on the user interface which displays the actual code at the selection point. As a result an operator may evaluate the code to determine whether the code actually implements the search terms selected from the concept query display region.

The source code display logic may include source code portions of a recommended application . The source code portions may include the potential implementation location of source code e.g. highlighted concepts for a selected concept distribution locator . The source code display logic accepts a concept distribution location selection from the concept distribution display logic . In response the source code display logic retrieves the recommended application code at the selection point and presents the source code for review in the source code display region. Furthermore the concept distribution display logic highlights source code components in the display such as API calls in the source code that match the concepts selected from the concept query display region. Accordingly an operator may review the source code to determine whether the source code actually does implement the concepts selected from the concept query display region. The source code display logic may include read only and edit modes that allow the source code display logic to be responsive to source code edits entered by a developer in the course of evaluating the recommended application .

The metadata display logic may include application metadata and API metadata for the recommended applications based on the topics words concepts the original query and the expanded query . The metadata display logic may also include concept query statistics and semantics information based on the topics words concepts the original query the expanded query and or recommended applications . In one implementation concept query statistics and semantics information are determined by the heuristic relevance ranking engine as a product of determining the API call heuristic relevance rankings of the relevant API call logic 1 and the relevant API call logic 2 based on analyzing semantics derived from the expanded query and the expanded search result .

The concept distribution display region displays the recommended application representations RAR and of a recommended application . For example the RAR may represent the source code file that includes the main function while the RAR may represent the source code file with an alleged JPEG to BITMAP conversion routine. The recommended application representations and include concept distribution locators and inserted by the concept distribution display logic that identify potential implementation locations in the source code files of the topics words concepts the original query and the expanded query alone or in combination. The concept distribution locators and may employ different identifiers e.g. fonts graphics e.g. lines or pointers color and or sound to identify a relationship between the concept distribution locators and the topics words concepts of the original query and the expanded query . The source code display region includes highlighted concepts e.g. and . In one implementation the highlighted concepts e.g. and include identifiers e.g. fonts color and or sound to indentify a relationship between the highlighted concepts and the concept distribution locators e.g. and . The RAE area logic may use fonts color and or sound e.g. audio queues to indicate relationships between the topics words concepts concept distribution locators e.g. and and highlighted concepts as indicated by the arrows and .

In one implementation the recommended application representations and and or the concept distribution locators e.g. and are displayed in response to the selection of a particular topic word concept and or element of the original query and or the expanded query . In other words the recommended application representations and and or the concept distribution locators e.g. and displayed in the concept distribution display region may be responsive to selections made in the concept query display region .

The recommended application representation shows the source code at a specific concept location in a specific source code file as selected by an operator. Thus when an operator selects for example RAC and the concept distribution locator the concept distribution display logic responds by retrieving the RAC source code at and around the concept location. The concept distribution display logic displays the retrieved code in the recommended application representation area. Furthermore the concept distribution display logic highlights the sections of code that Exemplar s search techniques determined relate to the search terms shown in the concept query display region . As shown in for example the concept distribution display logic has highlighted using underlining the source code components new and .set as relevant to the selected search terms length and create in the concept query display region .

The RAE greatly reduces the time cost and other resource expenditures associated with evaluating a recommended application. The RAE produces relevant results starting with high level processing concepts. A software developer may deploy the highly relevant application into production upon successful evaluation.

Furthermore it is noted that the system carries out electronic transformation of data that may represent underlying physical objects. For example the RAE area logic visually transforms source code by adding search term locators and highlighting of relevant code that matches search terms. In addition the RAE may be implemented as a particular machine. For example the particular machine may include a CPU memory and a software library for carrying out the RAE area logic noted above.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other implementations are within the scope of the following claims.

