---

title: Methods and systems for space management in data de-duplication
abstract: The present invention is directed toward methods and systems for data de-duplication. More particularly, in various embodiments, the present invention provides systems and methods for data de-duplication that may utilize storage reclamation. In various embodiments, data de-duplication may be performed using data storage reclamation by reconciling a list of all active tags against a list of all tags present within the object store itself. Any tags found to be in the object store that have no corresponding active usage may then be deleted. In some embodiments additional steps may be taken to avoid race conditions in deleting tags that are needed by incoming data. In some embodiments the object store may request the lists. In other embodiments, a runtime list, in which each new tag is entered as they are returned from the object store. In another embodiment the object store may maintain this list directly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08650228&OS=08650228&RS=08650228
owner: 
number: 08650228
owner_city: 
owner_country: 
publication_date: 20080414
---
The present invention relates generally to data processing systems and more particularly some embodiments relate to methods and systems for performing data de duplication and data storage reclamation.

Vast amounts of electronic information are stored communicated and manipulated by modem computer systems. Much of this vast amount of electronic information is duplicated. For example duplicate or near duplicate copies of data may be stored on a hard drive or hard drives communicated across a communication channel or processed using a computer or other electronic device. This duplicated data might be used in many different applications and on many different electronic systems. Accordingly data de duplication technology may impact a broad range of applications.

Data de duplication is a method of reducing or eliminating redundant files blocks of data etc. In this way a data de duplication system attempts to ensure that only unique data is stored transmitted processed etc. Data de duplication is also sometimes referred to as capacity optimized protection. Additionally data de duplication may address rapidly growing capacity needs by reducing electronic information storage capacity required transmission capacity processor capacity etc.

In one example of how duplicate data might exist on a computer network an employee may email a Word attachment to 25 co workers. On some systems a copy is saved for every employee the file was sent to increasing the capacity requirement of the file by a factor of 25. In some cases data de duplication technology may eliminate the redundant files replacing them with pointers to the original data after it has been confirmed that all copies are identical. This example illustrates data de duplication at the file level. Data de duplication may also be implemented based on variable size blocks of data. In other words redundant variable sized blocks of data may be eliminated by replacing these blocks with a pointer to another instance of a matching block of data.

In some cases data duplication might occur in a data storage system. For example archived electronic information such as electronic documents files programs etc. exist on backup tapes backup hard drives and other media. In many cases a computer may store a large number of files which in some cases may be duplicates of the same file or document slightly differing versions of the same document etc. Accordingly duplicates or near duplicates might exist for many different types of files including documents graphic files and just about any other type of computer file.

Additionally duplication might occur when data is communicated. In computer based systems it is common for a computer to transmit one or more files over a computer network or other communication system to for example other computers in the computer network. This network may be wired wireless or some combination of the two. Additionally the network may use just about any computer data communication system to transmit the data.

Different types of duplication might exist. In one type a file or files may be repeatedly transmitted by a computer. For example it is common for data transmitted during a backup operation to be almost identical to the data transmitted during the previous backup operation. Accordingly a computer computer networks etc. might also repeatedly communicate the same or similar data.

In another type of duplication a duplicate or near duplicate file or files such as duplicate or near duplicate document graphic files etc. might be stored on a computer system. In other words multiple copies of a file might exist as in the emailed document example. Accordingly different types of file de duplication systems and methods might address various types of duplication. Some types of data de duplication systems and methods might relate to file duplication or near duplication that involves multiple copies of the same or similar files sent during the same transmission. Other types of data de duplication systems and methods may relate to file duplication that involves the same or similar files sent during a series of transmissions. Yet other types of data de duplication might relate to both types of file duplication or near duplication.

Data de duplication might include both transmission for backup and the backup itself. For example some data de duplication systems may transmit only data that has changed since a previous backup. This data might be stored on a daily basis or perhaps a weekly basis. In some systems these changes in the data might be what is saved for example on a backup drive disc tape etc. For example a backup system might initially transmit a full backup for example all files in a directory or series of directories all files on a disc or on a computer all files on all disks on an entire network etc. The full backup might simply be any files that a particular user selects for backup. The data for the full backup may be transmitted and stored using various communication and storage systems. After the full backup subsequent backups might be based on only files that have changed. These might be the only files subsequently transmitted stored or both. Of course a user might also select to do a full backup from time to time after the initial full backup.

Systems that only make full backups might be required to store a large amount of data. This may increase the expenses associated with these types of systems due to for example the cost of additional hard drives tape media data CD s or DVD s wear on disc drives CD or DVD drives tape drives etc. Accordingly incremental systems might be more efficient in terms of data storage mechanical wear on system components etc.

There are two main types of de duplication. These methods are inline or offline. Inline de duplication is performed by a device in the data path. This may reduce the disk capacity required to store electronic data thereby increasing cost savings. A disadvantage of inline de duplication is that the data is processed while it is being transmitted for backup which may slow down the backup process.

In contrast offline data de duplication does not perform the data de duplication in the data path but instead performs the process at the backup system. This may require more data storage capacity such as for example disk capacity. Performance may however be improved by having the process reside outside of the data path after the backup job is complete. In other words because the data is processed after being transmitted for backup it generally will not slow the transmission of data down.

When data de duplication technology is used to eliminate redundant sets of data the data de duplication storage systems might typically store a single copy of data or portions of data and then create references to these objects as the same data is encountered again. By using references to previously stored data systems built upon these object stores can de duplicate new data as it arrives to be stored. For example a file system can present original files but only retain the unique portions of data used to compose those files with references substituted for duplicate occurrences.

Over time however the object store may contain unreferenced objects. In other words over time every reference to a data object stored might be deleted such that the data object stored is no longer needed. For example when all references to an object have been deleted there is no longer a need for a valid representation of the data object stored. The data comprising the object may continue to be stored however. Unreferenced objects data objects that continue to be stored when all references to the object have been deleted still occupy storage space and it is desirable to reclaim that space for use by new data objects.

It is generally undesirable to simply delete a data object whenever a reference to that object is deleted. The reference currently being deleted might not be the only reference to the object. Accordingly the data object may still be needed for example if these other references are accessed. In some systems deleting a data object whenever something that points to it is deleted may be prohibited because there may still be other active references to the object. These additional references may not be known by the process currently deleting its own use of the object which further complicates the problem.

In a system that never or rarely deletes objects with multiple references the storage device s may become so full with unreferenced data objects that large portions of data storage are unnecessarily consumed by unused data objects. Further a system that does not delete any of the objects as the references change or are removed until a user removes the objects may become unusable until the manual intervention occurs. Accordingly a system that lets the object store become populated and is manually emptied may become so full of unused data objects that it is not usable. While a storage device may from time to time become full if some or all of this data is data that a user wishes to store then the system is generally performing its function. If on the other hand most or a large percentage of the storage device is filled with unreferenced data objects then the user will generally not have access to a large percentage of the storage space purchased.

The present invention is directed toward methods and systems for data de duplication. More particularly in various embodiments the present invention provides systems and methods for data de duplication that may utilize storage reclamation.

In accordance with some embodiments of the systems and methods described herein reclamation of data storage space may comprise generating a list of active tags that includes a tag used by a data object stored in an object store. In various embodiments a list of tags associated with data objects present within an object store may be generated. The list of active tags may be compared to the list of tags associated with data objects present within the object store. A data object that is in the object store but for which its associated tag is not in the active tag list may be deleted.

In accordance with some embodiments a reference count associated with a tag or a data object may be incremented based on the number of references to the tag and decremented based on the number of deletions of references to the tag. In this way a tag and the data object associated with the tag may be deleted when the reference count associated with the tag indicates that no references to the tag are active. Accordingly tags and the data objects associated with tags with active references might not accidentally be deleted.

In accordance with some embodiments further steps may be taken to avoid race conditions in deleting a tag or a data object associated to the tag that may be used again because for example the data associated with a tag matches data that is about to be saved. For example in various embodiments the deletion of a tag or data object associated with the tag may be delayed to determine if a reference to the tag is contained in the incoming data.

In accordance with various embodiments the object store may comprise a data storage device such as for example a disk drive a tape drive a memory based data storage device etc. In some embodiments the object store might include a combination of data storage devices such as multiple disk drives tape drives memory based data storage devices etc.

In some embodiments reclamation of data storage space may occur as a background task. In various embodiments reclamation of data storage space may occur after a predetermined period of time has passed. In another embodiment data reclamation may occur when the object store has a predetermined amount of data storage space available for example when the amount of data storage space available is low. For example if the object store comprises a disk drive data reclamation may occur when the disk drive is 75 85 or 95 full.

Other features and aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings which illustrate by way of example the features in accordance with embodiments of the invention. The summary is not intended to limit the scope of the invention which is defined solely by the claims attached hereto.

The figures are not intended to be exhaustive or to limit the invention to the precise form disclosed. It should be understood that the invention can be practiced with modification and alteration and that the invention be limited only by the claims and the equivalents thereof.

Various embodiments of the systems and methods described herein provide data de duplication. For each block hashes Cyclic Redundancy Codes CRCs or any other code that might represent a block may be calculated and stored. A hash or hash function is a reproducible method for converting one block of data into a number known as a tag that represents that block of data. The hash is generally smaller than the original block of data and might serve as a digital fingerprint of the block of data or tag . A CRC is a type of hash function that may be used to produce a checksum to detect errors in transmission or storage. Cryptographic strength hash functions may also be used such as MD5 or SHA 1.

The first block of the set may be written normally and its address and tag can be stored and noted. Subsequent block hashes may be compared with previously written block hashes. An address of a block with a hash or CRC that matches a previously written block may be written to indicate the location of the previously written block. Alternatively the hash or other code might be written to indicate a previously written block. In this way redundant data may be eliminated.

In accordance with some embodiments of the systems and methods described herein reclamation of data storage space in a data de duplication system may comprise generating a list of active tags that includes a tag used by a data object stored in an object store. In various embodiments a list of tags present within an object store may be generated. In other embodiments the list of tags present within an object store may be maintained as objects enter the object store. The list of active tags may be compared to the list of tags present within the object store. A tag that is in the object store but not in the active tag list may be deleted. Additionally the data that the tag points to or represents might also be deleted.

Before describing the invention in detail it is useful to describe an example environment with which the invention can be implemented. illustrates a data storage system with which the present invention can be implemented. System in the illustrated example includes computing devices a network a server an array of storage disks and a storage area network . Computing devices can be any of a variety of computing devices including for example laptops desktops workstations personal digital assistants PDAs handheld computing devices or other types of computing devices.

Network can be implemented using any of a variety of network architectures or topologies. Such networks might include for example the internet a local area network LAN a wide area network WAN a plain old telephone system POTS or any other suitable network or communications channel. In the illustrated example computing devices and server are connected to network . The connection to network can be wireless or through a wired connection.

Server can be any server system such as for example a conventional standalone file server configured to provide data services to a client device such as device Server can be scalable to increase storage capacity such as for example by adding storage disk array . Disk array can be implemented as for example a direct attached storage DAS system . In the example architecture illustrated in system includes a storage pool which includes switch disk array router and a tape server . Server disk array and the storage pool can be implemented using one or more types of storage architectures such as for example small computer system interface SCSI serial advanced technology attachment SATA serial attached SCSI SAS or fiber channel FC .

With continued reference to the illustrated exemplary system can provide data access and storage redundancy by storing data at multiple locations such as server disk arrays and or tape server . Server can be groups of remote servers each group may be locally or remotely connected with other groups via a network similar to network . As shown in server may access data or backup data to disk array or tape server through network or via a direct connection to switch . In this way server has the flexibility of accessing array or tape server via multiple connections and thereby avoids network bottlenecks.

In various embodiments switch is an FC data switch and tape server is SCSI type server. In this embodiment router is configured to transfer data between a FC data bus of FC switch and a SCSI bus of SCSI tape server . Although a specific architecture is described above components of the storage pool may have a different architecture or combination of architectures such as for example SATA SAS and FC.

From time to time the present invention is described herein in terms of this example environment. Description in terms of this environment is provided to allow the various features and embodiments of the invention to be portrayed in the context of an exemplary application. After reading this description it will become apparent to one of ordinary skill in the art how the invention can be implemented in different and alternative environments.

In accordance with various embodiments of the systems and methods described herein a data storage appliance such as a backup appliance with data de duplication and replication capability may include storage reclamation functionality. In various embodiments the backup appliance might implement the reclamation functionality using the method illustrated in . The backup appliance may be a disk based backup appliance a tape based backup appliance or any other data de duplication storage system that might use the systems and methods described herein in order to determine when to delete a tag for a block of data or when to delete a block of data that is not currently being used by any files stored on the device.

In a step a list of active tags may be generated. The active tags may be for example pointers to data that is currently needed by one or more data files stored on a data storage system. As discussed above data storage systems that use de duplication may store for example a single instance of data that might be used by multiple files stored on the data storage system. As long as one of these multiple files needs the single instance of data then that instance should not be deleted. By generating a list of active tags the systems and methods described herein may determine which tags are needed so that tags and any associated data that are needed are not deleted.

It will be understood that in some embodiments multiple instances of the same data might be stored so that for example if a tag or data object associated with a tag on one part of a storage system is corrupted it might be retrieved using another tag. The systems and methods described herein may still be used in such systems to determine which tags stored in multiple locations might be deleted or which data associated with the tags might be deleted.

In a step the list of active tags may be compared to the list of tags in the object store. In this way the systems and methods described herein may determine which tags and associated data if any are stored on a storage device that are not needed by any of the files stored on the storage device.

For example in various embodiments storage reclamation may be addressed by reconciling a list of all active tags against a list of all tags present within the object store itself. In various embodiments when reconciling the list of all active tags against the list of all tags present within the object store itself any tags and associated data found to be in the object store that have no corresponding active usage may be deleted. If a tag is in the object store but is not being used by any files being stored in the backup appliance then the tag may not be needed and might be deleted to for example allow the storage space to be used for other tags. Additionally data associated with a tag that is in the object store but not being used by any file might also be deleted.

In some embodiments further steps may be taken to avoid race conditions in deleting tags and data that may be used again because for example the data is currently being saved. For example the deletion of unneeded tags and associated data may lag the determination that the tags and data are no longer needed. Examples of additional steps that may be taken to avoid race conditions are discussed below.

In accordance with various embodiments an application programming interface API may use the object store to request a list of tags present within the object store. In some cases it may be advantageous for the systems and methods described herein to be self contained to the object store. For example by keeping the list self contained communication requirements between the disk based backup appliance and other devices may be minimized. Additionally the impact that the systems and methods described herein might have on other processors in for example a computer network may be minimized. In some examples however performance challenges might occur if the list is created on demand each time it is needed.

In accordance with another embodiment a runtime list may be maintained. In various embodiments each new tag may be entered as they are returned from the object store. In another embodiment the object store may maintain the list directly. In some cases this may avoid the need to create a new list on each request. It may however require additional storage. In various embodiments this list may be built over time instead of all at once to improve performance. For each tag its associated reference count e.g. how many times it is pointed to is also gathered.

In various embodiments the list of all active tags may be generated by reviewing all active file system namespaces to compile a list of all tags used to represent the data stored to those namespaces. In some embodiments a namespace snapshot might include this list as part of its metadata. Accordingly each of these lists may be extracted from the metadata. In various embodiments a namespace snapshot may be the result of a replication process and may be present only on systems that serve as replication targets. The namespace snapshots represent an active file system namespace In various embodiments the namespace snapshots may be stored in the object store to further conserve space.

In various embodiments once the list of tags present within the object store and the list of active tags are generated they may be compared to each other. Tags that are in the object store but not in the list of active tags and the associated data may be deleted.

In some embodiments instead of being directly deleted a counter might be maintained. For example in various embodiments a reference count might be based on the number of references to a tag. The reference count might be incremented whenever a new reference to a tag occurs and decremented when a reference to a tag is deleted. In various embodiments a tag and its associated data might be deleted if the reference count associated with the tag is for example zero. In various embodiments the deletion of the tag and the data associated with it might also be delayed to determine if a reference to the tag will occur based on in incoming data.

In various embodiments a reference count may be decremented by the value of the reference count that was gathered when the list was compiled. This may facilitate store operations continuing that may increment the reference count. These store operations may occur for example either locally or via remote replication sources. In this way tags may be kept active in the object store so that tags and the associated data are not deleted if they are used by data that is currently stored on a data storage device or data being written to the storage device.

In some embodiments tags may be found in the list of active tags that are not in the list of tags from the object store. This may occur based on the order in which processing occurs. For example in some embodiments the system may get a list of tags from the object store. After that a new object may be created and stored. This may generate a new tag. After this the system may get a list of active tags. As will be understood in this case the new tag would be in the list of active tags but not in the previously retrieved list of tags from the object store. Generally these new tags will be found when space reclamation is processed again. Delays in storing data to an object store will not cause this data to be lost because in some embodiments tags in the object store that are not in the active tags list might be deleted but tags that are found in the list of active tags that are not in the list of tags from the object store however are not deleted because they are not in the object store list yet. In various embodiments when a tag can be deleted deleting the associated data will also generally be allowed because this data may not be needed.

Tags and associated data that are identified for deletion can either be deleted immediately or a list can be generated periodically and the deletion process can take place later. For example in various embodiments deletion may be based on a schedule or event. In various embodiments deletion of a tag may occur when a storage device is 80 full for example or after a predetermined time has passed.

In various embodiments the space reclamation process may be invoked manually. For example a user or system administrator might be required to run a disk space reclamation process program. In another embodiment however the systems and methods described herein might run automatically. For example the reclamation of data storage space in a data de duplication system might occur automatically based on a timer or other event such as a low space threshold.

In various embodiments for example to avoid race conditions when replication is active the space reclamation process may run after all replication sources have completed their scheduled replication process. This may apply to systems used as a replication target for example. A target replication system may be a data storage system that might be used to replicate other data storage systems. Additionally this may apply only when these systems are performing such a replication. For example in various embodiments the replication target may track when each replication source has completed. When all replications are complete space reclamation may be processed. In other embodiments the space reclamation process may also run independently of replication processes.

In some embodiments the blocklet file store BFST may include for example a processor that breaks blocks of data into blocklets and further processes these blocklets. For example the processor might be used to perform data de duplication or other processing. A blocklet file store BFST may be used to store blocklets and might include disk storage tape storage memory based storage etc. For example as illustrated in blocklets may be stored in the blocklet file store . A tag to these blocklets might be communicated back and saved in the local file store.

As illustrated in reclamation of data storage space garbage collection may include both local and remote components. For example reclamation of data storage space may begin at by getting local tags from a metadata tag file in file storage . Additionally in some embodiments remote tags might be retrieved from the blocklet file store .

Contents such as for example local store data tag lists etc. might be sent to the local store list. In this way the system may keep track of this information using the local store list. Additionally contents such as for example remote store data tag lists etc. might be sent to the remote store list. In some embodiments both local store list and remote store list information might be added to a tag list.

In various embodiments the garbage collection process might get the contents of the BFST tag list e.g. the tags and as illustrated in each BFST tag list tag that is not a part of the metadata tags may be deleted . In some embodiments the BFST may refer to a blocklet server and blocklet disk storage. A file system client provides a local file system that may contain for example blocklets created by the blocklet processing engine.

In the embodiment of metadata may be transmitted to a local file store . The remote replication processing might also get tags from the local file store . The metadata and tags may be stored in the block file store or transferred to a remote file store using for example file transfer protocol ftp .

A garbage collection might occur at a time . During the garbage collection the BFST Tag List File may be emptied and the BFST Object Store may be copied into the BFST TagListFile. Additionally the Active Tag List may be generated. The Active Tag List and the BFST Tag List File may be compared and tag and its associated data may be deleted based on the compare. Accordingly the BFST Tag List may store the tags from the BFST Object Store List during garbage collections. Additionally during a garbage collection the Active Tag List may be generated. In some embodiments the Active Tag List may include a list of tags that are needed. In other words tags that should not be deleted. The tags on this list still reside in the name space. By comparing the tags in the Active Tag List to tags in the BFST Tag List the tags that may be deleted can be determined. As illustrated in the example of tag may be deleted. Accordingly after the garbage collection at time . the BFST Object Store may contain 1 and 3 rather than 1 2 and 3.

At a time a file D might be created and given the tag 4 and a file E might be created and given a tag 5 . Accordingly at time the BFST Object Store may contain 1 3 4 and 5. Additionally file A might be removed from the system. At a time another garbage collection might occur. The BFST Object Store may be copied to the BFST Tag List File. THe BFST Tag List File may be deleted prior to the copy. Additionally the Active Tag List may be generated to determine which files might still be needed. This file may then be compared with the BFST Tag List File and unneeded tags or data might be deleted based on the compare. As illustrated in after the garbage collection at time . the BFST Object Store might contain tags and . These are the tags that are still stored in the data storage system. It will be understood that some embodiments might use different lists to determine which tags might be deleted which might continue to be stored etc.

As illustrated in the functionality of BoxA may be similar to the systems and methods described with respect to . In the example of BoxA however as items are successfully sent to the replication destination they might be added to the BFST Object Store on the remote box which in some embodiments might list the tags or files that are transmitted to the replication destination. For example see the table entries from time and time in .

Additionally as illustrated in in various embodiments when a name space replication occurs the BFST Object Store on BoxA may be sent to the RepBox. In some embodiments the Active Tag List might also be transmitted to the RepBox. As discussed above in various embodiments the Active Tag List may be a list of tags that should be kept. In some examples the Tag Lists on the RepBox might be referred to as Remote Tag Lists.

In various embodiments as illustrated by the example of on the RepBox when a garbage collection occurs the RepBox may add the BFST Tag List File at BoxA and all RepBox Active Tag List file entries to the RepBox BFST Tag List File. These files can be compared at the RepBox with the Active Tag List at the RepBox for example to determine which tags and data associated with the tags is needed.

Similar to the example of at the RepBox the BFST Tag List File may be compared to the Active Tag List File. In various embodiments anything in the BFST Tag List File that is not in the Active Tag List may be deleted.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not of limitation. Likewise the various diagrams may depict an example architectural or other configuration for the invention which is done to aid in understanding the features and functionality that can be included in the invention. The invention is not restricted to the illustrated example architectures or configurations but the desired features can be implemented using a variety of alternative architectures and configurations. Indeed it will be apparent to one of skill in the art how alternative functional logical or physical partitioning and configurations can be implemented to implement the desired features of the present invention. Also a multitude of different constituent module names other than those depicted herein can be applied to the various partitions. Additionally with regard to flow diagrams operational descriptions and method claims the order in which the steps are presented herein shall not mandate that various embodiments be implemented to perform the recited functionality in the same order unless the context dictates otherwise.

Although the invention is described above in terms of various exemplary embodiments and implementations it should be understood that the various features aspects and functionality described in one or more of the individual embodiments are not limited in their applicability to the particular embodiment with which they are described but instead can be applied alone or in various combinations to one or more of the other embodiments of the invention whether or not such embodiments are described and whether or not such features are presented as being a part of a described embodiment. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments.

Terms and phrases used in this document and variations thereof unless otherwise expressly stated should be construed as open ended as opposed to limiting. As examples of the foregoing the term including should be read as meaning including without limitation or the like the term example is used to provide exemplary instances of the item in discussion not an exhaustive or limiting list thereof the terms a or an should be read as meaning at least one one or more or the like and adjectives such as conventional traditional normal standard known and terms of similar meaning should not be construed as limiting the item described to a given time period or to an item available as of a given time but instead should be read to encompass conventional traditional normal or standard technologies that may be available or known now or at any time in the future. Likewise where this document refers to technologies that would be apparent or known to one of ordinary skill in the art such technologies encompass those apparent or known to the skilled artisan now or at any time in the future.

A group of items linked with the conjunction and should not be read as requiring that each and every one of those items be present in the grouping but rather should be read as and or unless expressly stated otherwise. Similarly a group of items linked with the conjunction or should not be read as requiring mutual exclusivity among that group but rather should also be read as and or unless expressly stated otherwise. Furthermore although items elements or components of the invention may be described or claimed in the singular the plural is contemplated to be within the scope thereof unless limitation to the singular is explicitly stated.

The presence of broadening words and phrases such as one or more at least but not limited to or other like phrases in some instances shall not be read to mean that the narrower case is intended or required in instances where such broadening phrases may be absent. The use of the term module does not imply that the components or functionality described or claimed as part of the module are all configured in a common package. Indeed any or all of the various components of a module whether control logic or other components can be combined in a single package or separately maintained and can further be distributed across multiple locations.

Additionally the various embodiments set forth herein are described in terms of exemplary block diagrams flow charts and other illustrations. As will become apparent to one of ordinary skill in the art after reading this document the illustrated embodiments and their various alternatives can be implemented without confinement to the illustrated examples. For example block diagrams and their accompanying description should not be construed as mandating a particular architecture or configuration.

