---

title: Smart stub or enterprise java bean in a distributed processing system
abstract: A clustered enterprise distributed processing system. The distributed processing system includes a first and a second computer coupled to a communication medium. The first computer includes a virtual machine (JVM) and kernel software layer for transferring messages, including a remote virtual machine (RJVM). The second computer includes a JVM and a kernel software layer having a RJVM. Messages are passed from a RJVM to the JVM in one computer to the JVM and RJVM in the second computer. Messages may be forwarded through an intermediate server or rerouted after a network reconfiguration. Each computer includes a Smart stub having a replica handler, including a load balancing software component and a failover software component. Each computer includes a duplicated service naming tree for storing a pool of Smart stubs at a node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08069447&OS=08069447&RS=08069447
owner: Oracle International Corporation
number: 08069447
owner_city: Redwood Shores
owner_country: US
publication_date: 20081015
---
This application is a continuation of application Ser. No. 10 427 646 filed Apr. 30 2003 now U.S. Pat. No. 7 454 755 issued Nov. 18 2008 which is a continuation of application Ser. No. 09 405 260 filed Sep. 23 1999 now U.S. Pat. No. 6 581 088 issued Jun. 17 2003 which claims the benefit of U.S. Provisional Application No. 60 107 167 filed Nov. 5 1998 and which are incorporated herein by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates to distributed processing systems and in particular computer software in distributed processing systems.

The following copending U.S. patent applications are assigned to the assignee of the present application and their disclosures are incorporated herein by reference 

 A Ser. No. 09 405 318 filed Sep. 23 1999 by Dean B. Jacobs and Anno R. Langen entitled CLUSTERED ENTERPRISE JAVA HAVING A MESSAGE PASSING KERNEL IN A DISTRIBUTED PROCESSING SYSTEM now U.S. Pat. No. 6 385 643 issued May 7 2002 

 B Ser. No. 09 405 508 filed Sep. 23 1999 by Dean B. Jacobs and Eric M. Halpern entitled DUPLICATED NAMING SERVICE IN A DISTRIBUTED PROCESSING SYSTEM now U.S. Pat. No. 6 236 999 issued May 22 2001 

 C Ser. No. 09 803 467 filed Mar. 9 2001 by Dean B. Jacobs and Eric M. Halpern entitled DUPLICATED NAMING SERVICE IN A DISTRIBUTED PROCESSING SYSTEM now U.S. Pat. No. 6 928 457 issued Aug. 9 2005 and

 D Ser. No. 09 405 500 filed Sep. 23 1999 by Dean B. Jacobs and Anno R. Langen entitled CLUSTERED ENTERPRISE JAVA IN A SECURE DISTRIBUTED PROCESSING SYSTEM now U.S. Pat. No. 6 571 274 issued May 27 2003.

There are several types of distributed processing systems. Generally a distributed processing system includes a plurality of processing devices such as two computers coupled to a communication medium. Communication mediums may include wired mediums wireless mediums or combinations thereof such as an Ethernet local area network or a cellular network. In a distributed processing system at least one processing device may transfer information on the communication medium to another processing device.

Client server architecture illustrated in is one type of distributed processing system. Client server architecture includes at least two processing devices illustrated as client and application server . Additional clients may also be coupled to communication medium such as client .

Typically server hosts business logic and or coordinates transactions in providing a service to another processing device such as client and or client . Application server is typically programmed with software for providing a service. The software may be programmed using a variety of programming models such as Enterprise Java Bean EJB as illustrated in . The service may include for example retrieving and transferring data from a database providing an image and or calculating an equation. For example server may retrieve data from database in persistent storage over communication medium in response to a request from client . Application server then may transfer the requested data over communication medium to client .

A client is a processing device which utilizes a service from a server and may request the service. Often a user interacts with client and may cause client to request service over a communication medium from application server . A client often handles direct interactions with end users such as accepting requests and displaying results.

A variety of different types of software may be used to program application server and or client . One programming language is the Java programming language. Java application object code is loaded into a Java virtual machine JVM . A JVM is a program loaded onto a processing device which emulates a particular machine or processing device. More information on the Java programming language may be obtained at http www.javasoft.com which is incorporated by reference herein.

RMI is a distributed programming model often used in peer to peer architecture described below. In particular a set of classes and interfaces enables one Java object to call the public method of another Java object running on a different JVM.

An instance of EJB is typically used in a client server architecture described above. An instance of EJB is a software component or a reusable pre built piece of encapsulated application code that can be combined with other components. Typically an instance of EJB contains business logic. An EJB instance stored on server typically manages persistence transactions concurrency threading and security.

Client server architecture has many disadvantages. First architecture does not scale well because server has to handle many connections. In other words the number of clients which may be added to server is limited. In addition adding twice as many processing devices clients does not necessarily provide you with twice as much performance. Second it is difficult to maintain application code on clients and . Third architecture is susceptible to system failures or a single point of failure. If server fails and a backup is not available client will not be able to obtain the service.

In a platform specific distributed processing system each processing device may run the same operating system. This allows the use of proprietary hardware such as shared disks multi tailed disks and high speed interconnects for communicating between processing devices. Examples of platform specific distributed processing systems include IBM Corporation s S 390 Parallel Sysplex Compaq s Tandem Division Himalaya servers Compaq s Digital Equipment Corporation DEC Division OpenVMS Cluster software and Microsoft Corporation Windows NT cluster services Wolfpack .

TP architecture also has many disadvantages. First a failure of a single processing device or TP monitor may render the network inoperable. Second the scalability or number of processing devices both servers and clients coupled to TP monitor may be limited by TP monitor hardware and software. Third flexibility in routing a client request to a server is limited. For example if communication medium is inoperable but communication medium becomes available ATM typically may not request service directly from server over communication medium and must access TP monitor . Fourth a client typically does not know the state of a back end server or other processing device. Fifth no industry standard software or APIs are used for load balancing. And sixth a client typically may not select a particular server even if the client has relevant information which would enable efficient service.

Therefore it is desirable to provide a distributed processing system and in particular distributed processing system software that has the advantages of the prior art distributed processing systems without the inherent disadvantages. The software should allow for industry standard APIs which are typically used in either client server multi tier or peer to peer distributed processing systems. The software should support a variety of computer programming models. Further the software should enable 1 enhanced fault tolerance 2 efficient scalability 3 effective load balancing and 4 session concentration control. The improved computer software should allow for rerouting or network reconfiguration. Also the computer software should allow for the determination of the state of a processing device.

An improved distributed processing system is provided and in particular computer software for a distributed processing system is provided. The computer software improves the fault tolerance of the distributed processing system as well as enables efficient scalability. The computer software allows for efficient load balancing and session concentration. The computer software supports rerouting or reconfiguration of a computer network. The computer software supports a variety of computer programming models and allows for the use of industry standard APIs that are used in both client server and peer to peer distributed processing architectures. The computer software enables a determination of the state of a server or other processing device. The computer software also supports message forwarding under a variety of circumstances including a security model.

According to one aspect of the present invention a distributed processing system comprises a communication medium coupled to a first processing device and a second processing device. The first processing device includes a first software program emulating a processing device JVM including a first kernel software layer having a data structure RJVM . The second processing device includes a first software program emulating a processing device JVM including a first kernel software layer having a data structure RJVM . A message from the first processing device is transferred to the second processing device through the first kernel software layer and the first software program in the first processing device to the first kernel software layer and the first software program in the second processing device.

According to another aspect of the present invention the first software program in the first processing device is a Java virtual machine JVM and the data structure in the first processing device is a remote Java virtual machine RJVM . Similarly the first software program in the second processing device is a JVM and the data structure in the second processing device is a RJVM. The RJVM in the second processing device corresponds to the JVM in the first processing device.

According to another aspect of the present invention the RJVM in the first processing device includes a socket manager software component a thread manager software component a message routing software component a message compression software component and or a peer gone detection software component.

According to another aspect of the present invention the first processing device communicates with the second processing device using a protocol selected from the group consisting of Transmission Control Protocol TCP Secure Sockets Layer SSL Hypertext Transport Protocol HTTP tunneling and Internet InterORB Protocol IIOP tunneling.

According to another aspect of the present invention the first processing device includes memory storage for a Java application.

According to another aspect of the present invention the first processing device is a peer of the second processing device. Also the first processing device is a server and the second processing device is a client.

According to another aspect of the present invention a second communication medium is coupled to the second processing device. A third processing device is coupled to the second communication medium. The third processing device includes a first software program emulating a processing device JVM including a kernel software layer having a first data structure RJVM and a second data structure RJVM .

According to still another aspect of the present invention the first processing device includes a stub having a replica handler software component. The replica handler software component includes a load balancing software component and a failover software component.

According to another aspect of the present invention the first processing device includes an Enterprise Java Bean object.

According to still another aspect of the present invention the first processing device includes a naming tree having a pool of stubs stored at a node of the tree and the second processing device includes a duplicate of the naming tree.

According to still another aspect of the present invention the first processing device includes an application program coded in a stateless program model and the application program includes a stateless session bean.

According to still another aspect of the present invention the first processing device includes an application program coded in a stateless factory program model and the application program includes a stateful session bean.

According to still another aspect of the present invention the first processing device includes an application program coded in a stateful program model and the application program includes an entity session bean.

According to still another aspect of the present invention an article of manufacture including an information storage medium is provided. The article of manufacture comprises a first set of digital information for transferring a message from a RJVM in a first processing device to a RJVM in a second processing device.

According to another aspect of the present invention the article of manufacture comprises a first set of digital information including a stub having a load balancing software program for selecting a service provider from a plurality of service providers.

According to another aspect of the present invention the stub has a failover software component for removing a failed service provider from the plurality of service providers.

According to another aspect of the present invention the load balancing software component selects a service provider based on an affinity for a particular service provider.

According to another aspect of the present invention the load balancing software component selects a service provider in a round robin manner.

According to another aspect of the present invention the load balancing software component randomly selects a service provider.

According to another aspect of the present invention the load balancing software component selects a service provider from the plurality of service providers based upon the load of each service provider.

According to another aspect of the present invention the load balancing software component selects a service provider from the plurality of service providers based upon the data type requested.

According to another aspect of the present invention the load balancing software component selects a service provider from the plurality of service providers based upon the closest physical service provider.

According to another aspect of the present invention the load balancing software component selects a service provider from the plurality of service providers based upon a time period in which each service provider responds.

According to another aspect of the present invention the article of manufacture comprises a first set of digital information including an Enterprise Java Bean object for selecting a service provider from a plurality of service providers.

According to another aspect of the present invention a stub is stored in a processing device in a distributed processing system. The stub includes a method comprising the steps of obtaining a list of service providers and selecting a service provider from the list of service providers.

According to another aspect of the present invention the method further includes removing a failed service provider from the list of service providers.

According to still another aspect of the present invention an apparatus comprises a communication medium coupled to a first processing device and a second processing device. The first processing device stores a naming tree including a remote method invocation RMI stub for accessing a service provider. The second processing device has a duplicate naming tree and the service provider.

According to another aspect of the present invention the naming tree has a node including a service pool of current service providers.

According to another aspect of the present invention a distributed processing system comprises a first computer coupled to a second computer. The first computer has a naming tree including a remote invocation stub for accessing a service provider. The second computer has a replicated naming tree and the service provider.

According to another aspect of the present invention a distributed processing system comprising a first processing device coupled to a second processing device is provided. The first processing device has a JVM and a first kernel software layer including a first RJVM. The second processing device includes a first JVM and a first kernel software layer including a second RJVM. A message may be transferred from the first processing device to the second processing device when there is not a socket available between the first JVM and the second JVM.

According to another aspect of the present invention the first processing device is running under an applet security model behind a firewall or is a client and the second processing device is also a client.

Other aspects and advantages of the present invention can be seen upon review of the figures the detailed description and the claims which follow.

The invention will be better understood with reference to the drawings and detailed description below. In the drawings like reference numerals indicate like components.

A variety of different types of processing devices may be coupled to communication medium . In an embodiment a processing device may be a general purpose computer as illustrated in and described below. One of ordinary skill in the art would understand that and the below description describes one particular type of processing device where multiple other types of processing devices with a different software and hardware configurations could be utilized in accordance with an embodiment of the present invention. In an alternate embodiment a processing device may be a printer handheld computer laptop computer scanner cellular telephone pager or equivalent thereof.

Server transfers information over communication medium to server by using network software and network software respectively. In an embodiment network software and include communication medium software driver Transmission Control Protocol software and Internet Protocol software TCP IP . Client also includes network software for transferring information to server over communication medium . Network software in server is also used to transfer information to client by way of communication medium .

According to an embodiment of the present invention each processing device in clustered enterprise Java architecture includes a message passing kernel that supports both multi tier and peer to peer functionality. A kernel is a software program used to provide fundamental services to other software programs on a processing device.

In particular server server and client have kernels and respectively. In particular in order for two JVMs to interact whether they are clients or servers each JVM constructs an RJVM representing the other. Messages are sent from the upper layer on one side through a corresponding RJVM across the communication medium through the peer RJVM and delivered to the upper layer on the other side. In various embodiments messages can be transferred using a variety of different protocols including but not limited to Transmission Control Protocol Internet Protocol TCP IP Secure Sockets Layer SSL Hypertext Transport Protocol HTTP tunneling and Internet InterORB Protocol IIOP tunneling and combinations thereof. The RJVMs and socket managers create and maintain the sockets underlying these protocols and share them between all objects in the upper layers. A socket is a logical location representing a terminal between processing devices in a distributed processing system. The kernel maintains a pool of execute threads and thread manager software component multiplexes the threads between socket reading and request execution. A thread is a sequence of executing program code segments or functions.

For example server includes JVM and Java application . Server also includes a RJVM representing the JVM of server . If a message is to be sent from server to server the message is sent through RJVM in server to RJVM in server .

Clustered enterprise Java network is able to forward a message through an intermediate server. This functionality is important if a client requests a service from a back end server through a front end gateway. For example a message from server client and in particular JVM may be forwarded to client back end server or JVM through server front end gateway or JVM. This functionality is important in controlling session concentration or how many connections are established between a server and various clients.

Further message forwarding may be used in circumstances where a socket cannot be created between two JVMs. For example a sender of a message is running under the applet security model which does not allow for a socket to be created to the original server. A detailed description of the applet security model is provided at http www.javasoft.com which is incorporated herein by reference. Another example includes when the receiver of the message is behind a firewall. Also as described below message forwarding is applicable if the sender is a client and the receiver is a client and thus does not accept incoming sockets.

For example if a message is sent from server to client the message would have to be routed through server . In particular a message handoff as illustrated by between RJVM representing client would be made to RJVM representing server in server . The message would be transferred using sockets between RJVM in server and RJVM in server . The message would then be handed off as illustrated by dashed line from RJVM to RJVM in server . The message would then be passed between sockets of RJVM in server and RJVM in client . The message then would be passed as illustrated by the dashed line from RJVM in client to RJVM in client .

A RJVM in client server is able to switch communication paths or communication mediums to other RJVMs at any time. For example if client creates a direct socket to server server is able to start using the socket instead of message forwarding through server . This embodiment is illustrated by a dashed line and box representing client . In an embodiment the use of transferring messages by RJVMs ensures reliable in order message delivery after the occurrence of a network reconfiguration. For example if client was reconfigured to communication medium instead of communication medium as illustrated in . In an alternate embodiment messages may not be delivered in order.

An RJVM performs several end to end operations that are carried through routing. First an RJVM is responsible for detecting when a respective client server has unexpectedly died. In an embodiment peer gone selection software component as illustrated in is responsible for this function. In an embodiment an RJVM sends a heartbeat message to other clients servers when no other message has been sent in a predetermined time period. If the client server does not receive a heartbeat message in the predetermined count time a failed client server which should have sent the heartbeat is detected. In an embodiment a failed client server is detected by connection timeouts or if no messages have been sent by the failed client server in a predetermined amount of time. In still another embodiment a failed socket indicates a failed server client.

Second during message serialization RJVMs in particular message compression software abbreviate commonly transmitted data values to reduce message size. To accomplish this each JVM RJVM pair maintains matching abbreviation tables. For example JVM includes an abbreviation table and RJVM includes a matching abbreviation table. During message forwarding between an intermediate server the body of a message is not deserialized on the intermediate server in route.

Clustered enterprise Java architecture supports an explicit syntax for client server programming consistent with a multi tier distributed processing architecture. As an example the following client side code fragment writes an informational message to a server s log file 

The first line establishes a session with the acme server using the t protocol. If RJVMs do not already exist each JVM constructs an RJVM for the other and an underlying TCP socket is established. The client side representation of this session the TClient object and the server side representation communicate through these RJVMs. The server side supports a variety of services including database access remote file access workspaces events and logging. The second line obtains a LogServices object and the third line writes the message.

Clustered enterprise Java computer architecture also supports a server neutral syntax consistent with a peer to peer distributed processing architecture. As an example the following code fragment obtains a stub for an RMI object from the JNDI compliant naming service on a server and invokes one of its methods.

In an embodiment JNDI naming contexts are packaged as RMI objects to implement remote access. Thus the above code illustrates a kind of RMI bootstrapping. The first four lines obtain an RMI stub for the initial context on the acme server. If RJVMs do not already exist each side constructs an RJVM for the other and an underlying TCP socket for the t protocol is established. The caller side object the RMI stub and the callee side object an RMI impl communicate through the RJVMs. The fifth line looks up another RMI object an Example at the name acme.eng.example and the sixth line invokes one of the Example methods. In an embodiment the Example impl is not on the same processing device as the naming service. In another embodiment the Example impl is on a client. Invocation of the Example object leads to the creation of the appropriate RJVMs if they do not already exist.

In a processing device is able to provide a service to other processing devices in architecture by replicating RMI and or EJB objects. Thus architecture is easily scalable and fault tolerant. An additional service may easily be added to architecture by adding replicated RMI and or EJB objects to an existing processing device or newly added processing device. Moreover because the RMI and or EJB objects can be replicated throughout architecture a single processing device multiple processing devices and or a communication medium may fail and still not render architecture inoperable or significantly degraded.

RA RMI stub is a Smart stub which is able to find out about all of the service providers and switch between them based on a load balancing method and or failover method . In an embodiment an RA stub includes a replica handler that selects an appropriate load balancing method and or failover method . In an alternate embodiment a single load balancing method and or single failover method is implemented. In alternate embodiments replica handler may include multiple load balancing methods and or multiple failover methods and combinations thereof. In an embodiment a replica handler implements the following interface 

Immediately before invoking a method RA stub calls load balance method which takes the current server and returns a replacement. For example client may be using server for retrieving data for database or personal storage device . Load balance method may switch to server because server is overloaded with service requests. Handler may choose a server replacement entirely on the caller perhaps using information about server load or handler may request server for retrieving a particular type of data. For example handler may select a particular server for calculating an equation because the server has enhanced calculation capability. In an embodiment replica handler need not actually switch providers on every invocation because replica handler is trying to minimize the number of connections that are created.

Load balancing software begins as indicated by circle . A determination is then made in logic block as to whether the calling thread established an affinity for a particular server. A client has an affinity for the server that coordinates its current transaction and a server has an affinity for itself. If an affinity is established control is passed to logic block otherwise control is passed to logic block . A determination is made in logic block whether the affinity server provides the service requested. If so control is passed to logic block . Otherwise control is passed to logic block . The provider of the service on the affinity server is returned to the client in logic block . In logic block a naming service is contacted and an updated list of the current service providers is obtained. A getNextProvider method is called to obtain a service provider in logic block . Various embodiments of the getNextProvider method are illustrated in and described in detail below. The service is obtained in logic block . Failover method is then called if service is not provided in logic block and load balancing method exits as illustrated by logic block . An embodiment of failover method is illustrated in and described in detail below.

Still another embodiment of a getNextProvider method is illustrated in which obtains a service provider based upon the load of the service providers. A getNextProvider method is entered as illustrated by circle . A list of current service providers is obtained in logic block . The load of each service provider is obtained in logic block . The service provider with the least load is then selected in logic block . The new service provider is then returned in logic block and getNextProvider method exits as illustrated by circle .

An alternate embodiment of a getNextProvider method is illustrated in which obtains a service provider based upon the type of data obtained from the service provider. A getNextProvider method is entered as illustrated by circle . A list of current service providers is obtained in logic block . The type of data requested from the service providers is determined in logic block . The service provider is then selected based on the data type in logic block . The service provider is returned in logic block and getNextProvider method exits as illustrated by circle .

Still another embodiment of a getNextProvider method is illustrated in which selects a service provider based upon the physical location of the service providers. A getNextProvider method is entered as illustrated by circle . A list of service providers is obtained as illustrated by logic block . The physical distance to each service provider is determined in logic block and the service provider which has the closest physical distance to the requesting client is selected in logic block . The new service provider is then returned in logic block and the getNextProvider method exits as illustrated by circle .

Still a further embodiment of the getNextProvider method is illustrated in and selects a service provider based on the amount of time taken for the service provider to respond to previous requests. Control of getNextProvider method is entered as illustrated by circle . A list of current service providers is obtained in logic block . The time period for each service provider to respond to a particular message is determined in logic block . The service provider which responds in the shortest time period is selected in logic block . The new service provider is then returned in logic block and control from getNextProvider method exits as illustrated by circle .

If invocation of a service method fails in such a way that a retry is warranted RA stub calls failover method which takes the failed server and an exception indicating what the failure was and returns a new server for the retry. If a new server is unavailable RA stub throws an exception.

While illustrate embodiments of a replica handler alternate embodiments include the following functions or combinations thereof implemented in a round robin manner.

First a list of servers or service providers of a service is maintained. Whenever the list needs to be used and the list has not been recently updated handler contacts a naming service as described below and obtains an up to date list of providers.

Second if handler is about to select a provider from the list and there is an existing RJVM level connection to the hosting server over which no messages have been received during the last heartbeat period handler skips that provider. In an embodiment a server may later recover since death of peer is determined after several such heartbeat periods. Thus load balancing on the basis of server load is obtained.

Third when a provider fails handler removes the provider from the list. This avoids delays caused by repeated attempts to use non working service providers.

Fourth if a service is being invoked from a server that hosts a provider of the service then that provider is used. This facilitates co location of providers for chained invokes of services.

Fifth if a service is being invoked within the scope of a transaction and the server acting as transaction coordinator hosts a provider of the service then that provider is used. This facilitates co location of providers within a transaction.

The failures that can occur during a method invocation may be classified as being either 1 application related or 2 infrastructure related. RA stub will not retry an operation in the event of an application related failure since there can be no expectation that matters will improve. In the event of an infrastructure related failure RA stub may or may not be able to safely retry the operation. Some initial non idempotent operation such as incrementing the value of a field in a database might have completed. In an embodiment RA stub will retry after an infrastructure failure only if either 1 the user has declared that the service methods are idempotent or 2 the system can determine that processing of the request never started. As an example of the latter RA stub will retry if as part of load balancing method stub switches to a service provider whose host has failed. As another example a RA stub will retry if it gets a negative acknowledgment to a transactional operation.

A RMI compiler recognizes a special flag that instructs the compiler to generate an RA stub for an object. An additional flag can be used to specify that the service methods are idempotent. In an embodiment RA stub will use the replica handler described above and illustrated in . An additional flag may be used to specify a different handler. In addition at the point a service is deployed i.e. bound into a clustered naming service as described below the handler may be overridden.

As illustrated in access to service providers in architecture is obtained through a JNDI compliant naming service which is replicated across architecture so there is no single point of failure. Accordingly if a processing device which offers a JNDI compliant naming service fails another processing device having a replicated naming service is available. To offer an instance of a service a server advertises a provider of the service at a particular node in a replicated naming tree. In an embodiment each server adds a RA stub for the provider to a compatible service pool stored at the node in the server s copy of the naming tree. If the type of a new offer is incompatible with the type of offers in an existing pool the new offer is made pending and a callback is made through a ConflictHandler interface. After either type of offer is retracted the other will ultimately be installed everywhere. When a client looks up the service the client obtains a RA stub that contacts the service pool to refresh the client s list of service providers.

Stubs for the initial context of the naming service are replica aware or Smart stubs which initially load balance among naming service providers and switch in the event of a failure. Each instance of the naming service tree contains a complete list of the current naming service providers. The stub obtains a fresh list from the instance it is currently using. To bootstrap this process the system uses Domain Naming Service DNS to find a potentially incomplete initial list of instances and obtains the complete list from one of them. As an example a stub for the initial context of the naming service can be obtained as follows 

Some subset of the servers in an architecture have been bound into DNS under the name acmeCluster. Moreover an application is still able to specify the address of an individual server but the application will then have a single point of failure when the application first attempts to obtain a stub.

A reliable multicast protocol is desirable. In an embodiment provider stubs are distributed and replicated naming trees are created by an IP multicast or point to point protocol. In an IP multicast embodiment there are three kinds of messages Heartbeats Announcements and StateDumps. Heartbeats are used to carry information between servers and by their absence to identify failed servers. An Announcement contains a set of offers and retractions of services. The Announcements from each server are sequentially numbered. Each receiver processes an Announcement in order to identify lost Announcements. Each server includes in its Heartbeats the sequence number of the last Announcement it has sent. Negative Acknowledgments NAKs for a lost Announcement are included in subsequent outgoing Heartbeats. To process NAKs each server keeps a list of the last several Announcements that the server has sent. If a NAK arrives for an Announcement that has been deleted the server sends a StateDump which contains a complete list of the server s services and the sequence number of its next Announcement. When a new server joins an existing architecture the new server NAKs for the first message from each other server which results in StateDumps being sent. If a server does not receive a Heartbeat from another server after a predetermined period of time the server retracts all services offered by the server not generating a Heartbeat.

Applications used in the architecture illustrated in use one of three basic programming models 1 stateless or direct 2 stateless factory or indirect or 3 stateful or targeted depending on the way the application state is to be treated. In the stateless model a Smart stub returned by a naming service lookup directly references service providers.

In this example the two calls to example may be handled by different service providers since the Smart stub is able to switch between them in the interests of load balancing. Thus the Example service object cannot internally store information on behalf of the application. Typically the stateless model is used only if the provider is stateless. As an example a pure stateless provider might compute some mathematical function of its arguments and return the result. Stateless providers may store information on their own behalf such as for accounting purposes. More importantly stateless providers may access an underlying persistent storage device and load application state into memory on an as needed basis. For example in order for example to return the running sum of all values passed to it as arguments example might read the previous sum from a database add in its current argument write the new value out and then return it. This stateless service model promotes scalability.

In the stateless factory programming model the Smart stub returned by the lookup is a factory that creates the desired service providers which are not themselves Smart stubs.

In this example the two calls to example are guaranteed to be handled by the same service provider. The service provider may therefore safely store information on behalf of the application. The stateless factory model should be used when the caller needs to engage in a conversation with the provider. For example the caller and the provider might engage in a back and forth negotiation. Replica aware stubs are generally the same in the stateless and stateless factory models the only difference is whether the stubs refer to service providers or service provider factories.

A provider factory stub may failover at will in its effort to create a provider since this operation is idempotent. To further increase the availability of an indirect service application code must contain an explicit retry loop around the service creation and invocation.

This would for example handle the failure of a provider e that was successfully created by the factory. In this case application code should determine whether non idempotent operations completed. To further increase availability application code might attempt to undo such operations and retry.

In the stateful programming model a service provider is a long lived stateful object identified by some unique system wide key. Examples of entities that might be accessed using this model include remote file systems and rows in a database table. A targeted provider may be accessed many times by many clients unlike the other two models where each provider is used once by one client. Stubs for targeted providers can be obtained either by direct lookup where the key is simply the naming service name or through a factory where the key includes arguments to the create operation. In either case the stub will not do load balancing or failover. Retries if any must explicitly obtain the stub again.

There are three kinds of beans in EJB each of which maps to one of the three programming models. Stateless session beans are created on behalf of a particular caller but maintain no internal state between calls. Stateless session beans map to the stateless model. Stateful session beans are created on behalf of a particular caller and maintain internal state between calls. Stateful session beans map to the stateless factory model. Entity beans are singular stateful objects identified by a system wide key. Entity beans map to the stateful model. All three types of beans are created by a factory called an EJB home. In an embodiment both EJB homes and the beans they create are referenced using RMI. In an architecture as illustrated in stubs for an EJB home are Smart stubs. Stubs for stateless session beans are Smart stubs while stubs for stateful session beans and entity beans are not. The replica handler to use for an EJB based service can be specified in its deployment descriptor.

To create an indirect RMI based service which is required if the object is to maintain state on behalf of the caller the application code must explicitly construct the factory. A targeted RMI based service can be created by running the RMI compiler without any special flags and then binding the resulting service into the replicated naming tree. A stub for the object will be bound directly into each instance of the naming tree and no service pool will be created. This provides a targeted service where the key is the naming service name. In an embodiment this is used to create remote file systems.

Computer is a personal or office computer that can be for example a workstation personal computer or other single user or multi user computer system an exemplary embodiment uses a Sun SPARC 20 workstation Sun Microsystems Inc. Mountain View Calif. . For purposes of exposition computer can be conveniently divided into hardware components and software components however persons of ordinary skill in the art will appreciate that this division is conceptual and somewhat arbitrary and that the line between hardware and software is not a hard and fast one. Further it will be appreciated that the line between a host computer and its attached peripherals is not a hard and fast one and that in particular components that are considered peripherals of some computers are considered integral parts of other computers. Thus for example user I O can include a keyboard a mouse and a display monitor each of which can be considered either a peripheral device or part of the computer itself and can further include a local printer which is typically considered to be a peripheral. As another example persistent storage can include a CD ROM compact disc read only memory unit which can be either peripheral or built into the computer.

Hardware components include a processor CPU memory persistent storage user I O and network interface which are coupled to bus . These components are well understood by those of skill in the art and accordingly need be explained only briefly here.

Processor can be for example a microprocessor or a collection of microprocessors configured for multiprocessing.

Memory can include read only memory ROM random access memory RAM virtual memory or other memory technologies singly or in combination. Persistent storage can include for example a magnetic hard disk a floppy disk or other persistent read write data storage technologies singly or in combination. It can further include mass or archival storage such as can be provided by CD ROM or other large capacity storage technology. Note that file server provides additional storage capability that processor can use. 

User I O input output hardware typically includes a visual display monitor such as a CRT or flat panel display an alphanumeric keyboard and a mouse or other pointing device and optionally can further include a printer an optical scanner or other devices for user input and output.

Network I O hardware provides an interface between computer and the outside world. More specifically network I O lets processor communicate via connection with other processors and devices through LAN and through the Internet .

Software components include an operating system and a set of tasks under control of operating system such as a Java application program and importantly JVM software and kernel . Operating system also allows processor to control various devices such as persistent storage user I O and network interface . Processor executes the software of operating system application JVM and kernel in conjunction with memory and other components of computer system . In an embodiment software includes network software JVM RJVM and RJVM as illustrated in server of . In an embodiment Java application program is Java application as illustrated in

Persons of ordinary skill in the art will appreciate that the system of is intended to be illustrative not restrictive and that a wide variety of computational communications and information devices can be used in place of or in addition to what is shown in . For example connections through the Internet generally involve packet switching by intermediate router computers not shown and computer is likely to access any number of Web servers including but by no means limited to computer and Web server during a typical Web client session.

The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously many modifications and variations will be apparent to practitioners skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications thereby enabling others skilled in the art to understand the invention for various embodiments and with the various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.

