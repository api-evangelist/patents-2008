---

title: Crawling of object model using transformation graph
abstract: A transformation tree for an object model (OM) is defined. The transformation tree has nodes interconnected by edges, where each node is connected to at most one other tree node. Each node corresponds to a state of the OM; each edge corresponds to an event causing the OM to transition from the state of one node to the state of another node. A transformation graph for the OM is constructed by simulating the transformation tree. The transformation graph has nodes interconnected by edges, and is a directed graph in which each node is connected to one or more other nodes. Each node corresponds to a state of the OM; each edge corresponds to an event causing the OM to transition from the state of one node to the state of another node. Crawling-oriented actions are performed in relation to the OM by being performed in relation to the transformation graph.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08296722&OS=08296722&RS=08296722
owner: International Business Machines Corporation
number: 08296722
owner_city: Armonk
owner_country: US
publication_date: 20081006
---
The present invention relates generally to object models such as document object models DOM s for Internet web sites and more particularly to constructing transformation graphs for such object models to improve crawling of the models.

Internet web sites are vulnerable to a number of different security vulnerabilities. Such security vulnerabilities can include malware such as cross site scripting XSS and cross site request forgery CSRF as well as other types of security vulnerabilities. Therefore operators of web sites commonly attempt to determine whether their web sites are vulnerable in this way.

One way to determine whether a web site is vulnerable is to employ a vulnerability scanner. Such a scanner includes crawling functionality that collects all the universal resource locator URL addresses of the web site and that may become the targets of attackers. To collect the URL addresses a scanner loads the top page of a web site and scans the web site to collect URL addresses within this web page that refer to other web pages within the same web site. This process is repeated at each web page and is generally referred to as crawling. Each web page and its content can then be scanned for vulnerabilities.

However such crawling of a web site is difficult for some types of web sites that employ web applications with complex client side logic. For example asynchronous JAVA and eXtended markup language XML or Ajax technologies employ client side JavaScript updates of the presentation of a web page by dynamically modifying the document object model DOM of the web site and its style sheet such that the web site is considered to be dynamic . Other types of asynchronous communication also permit dynamic updates of data on a web page without having to reload the entire web page. JAVA is a trademark of Oracle Corporation of Redwood Shores Calif.

Crawling dynamic web sites employing such technologies is difficult because the DOM of a dynamic web site is dynamically generated and modified at run time. Thus a web application at the same URL address may have different vulnerabilities that originate from different DOM states. The dynamic modification of the DOM can occur in any order depending on how a user interacts with the web site in question. This flexible and dynamic nature of web applications renders them difficult to scan for security vulnerabilities because there is not a static collection of URL addresses that a vulnerability scanner can crawl to look for such vulnerabilities.

The present invention relates to the improved crawling of an object model by using a transformation graph. A method of one embodiment of the invention defines a transformation tree for an object model. The transformation tree has tree nodes connected to one another by tree edges and is a directed acyclic graph in which each tree node is connected to at most one other tree node. Each tree node corresponds to a state of the object model and each tree edge corresponds to an event causing the object model to transition from a state of one tree node to a state of another tree node.

The method constructs a transformation graph for the object model by simulating the transformation tree for the object model. The transformation graph has graph nodes connected to one another by graph edges. The transformation graph is a directed graph in which each graph node is connected to one or more other graph nodes. Each graph node corresponds to a state of the object model and each graph edge corresponds to an event causing the object model to transition from a state of one graph node to a state of another graph node. The method performs one or more crawling oriented actions in relation to the object model by performing the crawling oriented actions in relation to the transformation graph for the object model that has been constructed. The method then displays results of the crawling oriented actions performed in relation to the object model.

A computer readable medium of an embodiment of the invention may be a tangible computer readable medium such as a recordable data storage medium. The computer readable medium has stored thereon computer executable instructions for defining a transformation tree for a document object model DOM representing a dynamic web site. The transformation tree has tree nodes connected to one another by tree edges and is a directed acyclic graph in which each tree node is connected to at most one other tree node. Each tree node corresponds to a state of the DOM and each tree edge corresponds to an event causing the DOM to transition from a state of one tree node to a state of another tree node.

The computer readable medium further has stored thereon computer executable instructions for constructing a transformation graph for the DOM by simulating the transformation tree for the DOM. The transformation graph has graph nodes connected to one another by graph edges and is a directed graph in which each graph node is connected to one or more other graph nodes. Each graph node corresponds to a state of the DOM and each graph edge corresponds to an event causing the DOM to transition from a state of one graph node to a state of another graph node. The computer readable medium further has stored thereon computer executable instructions for performing one or more crawling oriented actions in relation to the DOM by performing the crawling oriented actions in relation to the transformation graph for the DOM that has been constructed. These computer executable instructions are also for displaying results of the crawling oriented actions performed in relation to the DOM.

A computerized system of an embodiment of the invention includes hardware and a number of components implemented via or by the hardware. A simulation component is to simulate a transformation tree for an object model. The transformation tree has tree nodes connected to one another by tree edges and is a directed acyclic graph in which each tree node is connected to at most one other tree node. Each tree node corresponds to a state of the object model and each tree edge corresponds to an event causing the object model to transition from a state of one tree node to a state of another tree node.

A construction component is to construct a transformation graph for the object model based on the transformation tree for the object model being simulated by the simulation component. The transformation graph has graph nodes connected to one another by graph edges and is a directed graph in which each graph node is connected to one or more other graph nodes. Each graph node corresponds to a state of the object model and each graph edge corresponds to an event causing the object model to transition from a state of one graph node to a state of another graph node.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and logical mechanical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

In particular it is noted that embodiments of the present invention are at least substantially described herein in relation to a document object model DOM for a dynamic web site. However other embodiments can employ other types of object models for other type of data constructs other than DOM s and other than for dynamic web sites. For instance one embodiment of the invention can pertain to a programming language model for a self mutating computer program. In general embodiments of the present invention are applicable to any type of model that is self mutating or otherwise dynamic where it may be difficult to crawl the state space of such a model.

The web page of node B is an asynchronous JAVA and eXtended markup language XML or Ajax style client side application where the user may add the items to a shopping cart view details of each item or proceed to checkout of node D. Each of the nodes A B C D and E collectively referred to as the nodes within the node B represents a state of the DOM of the web site. Together all the nodes constitute a DOM transformation graph for the node B which can be different than the DOM transformation graph for the node D.

At node C the user may continue clicking on the add item button to add more items into the shopping cart resulting in the addition of a row into a hypertext markup language HTML table that represents the shopping cart. Alternatively the user may click on a delete button that is associated with each item in the shopping cart. However the state of the DOM remains at the node C so long as there are some items in the shopping cart. The state of the DOM reverts back to the node B if the cart becomes empty again.

At node C the user may also click on a show detail icon on an item name to view the detailed specifications of the item in question such that the web application initiates an asynchronous hypertext transport protocol HTTP request to the server to retrieve the item details. The details may be presented as a popup message at node D and display of this message is removed when the mouse button is released. When the user clicks on a checkout button the state of the DOM transitions to node E where the total price of the items in the shopping cart is presented to the user. When the user finally clicks on a confirm button the browser loads another URL address at the state of the DOM represented by the node D in .

A transformation tree is defined for an object model of a dynamic web site . The transformation tree has a number of tree nodes that are interconnected to one another by tree edges. The transformation tree is a directed acyclic graph in which there are no loops and in which each tree node is connected to at most one other tree node. Each tree node corresponds to a state of the object model. Each tree edge corresponds to an event causing the object model to transition from the state of one tree node to which the tree edge is connected to the state of another tree node to which the tree edge is connected. An event of an edge may correspond to a user initiated JavaScript event an intrinsic event such as a timer event or another type of event. A transformation tree is similar to a transformation graph. However unlike a transformation graph a transformation tree has a tree structure. As such as described in the previous paragraph the transitions do not have any loops and each state has zero or one previous states.

The states of the tree nodes of the transformation tree are like the states of the graph nodes of a transformation graph but they do not make any loops and no states are shared by more than one transition. For example the states of the nodes B and G may seem identical but they are not merged in the transformation tree . The transformation tree is generally constructed by exploring the state space of the object model in question naively making state transitions at all possible event handlers and identifying resulting object model states as unique states.

Referring back to a transformation graph is constructed for the object model by simulating the transformation tree that has been constructed . In particular the state of each tree node of the transformation tree is simulated. The transformation graph has a number of graph nodes connected to one another by graph edges. The transformation graph is a directed graph that can have one or more loops. In the transformation graph therefore each graph node is connected to one or more other graph nodes where each graph node corresponds to a state of the object model in question. Each graph edge corresponds to an event causing the object model to transition from the state of one graph node to which the graph edge in question is connected to the state of another graph node to which this graph edge is connected. An event of an edge may correspond to a user initiated JavaScript event an intrinsic event such as a timer event or another type of event. 

A labeling function L can be defined on the state of each node of the transformation graph and of the transformation tree. The label of the state s is denoted as L s . A transformation graph is said to simulate a transformation tree when the following condition holds. This condition is that for all states of the transformation tree denoted by s and for the states on the transformation graph denoted by s if L s L s then for any transition s e t of the transformation tree there exists a transition s e t within the transformation graph where L t l t . In this condition s e t means that the state t can be transitioned to from the state s by the event e.

Next it is determined whether the characteristics of the state of any first graph node are similar to the characteristics of the state of any second graph node . That is it is determined whether the output of the labeling function L of the state of any graph node is similar to the output of the labeling function L of the state of any other graph node. In one embodiment similarity of two DOM states can be measured by any combination of one or more of the following criteria.

The first criterion includes the active properties of the web page in question. That is the first criterion is whether the active properties of a web page corresponding to the DOM state represented by a first graph node are similar to active properties of a web page corresponding to the DOM state represented by a second graph node. Active properties of a web page are represented by a set of JavaScript code and event handlers in a DOM state as well as a set of URL addresses to which HTTP requests may be issued from HTML or JavaScript within a given DOM state. In particular what are compared are the object scope the event handlers and the scripts of the two DOM states to determine similarity as to this criterion.

The second criterion is the DOM structure similarity. That is the second criterion is whether the structure of the DOM within the state of a first graph node is similar to the structure of the DOM within the state of a second graph node. Two DOM states are regarded as similar to one another when the DOM states have similar structures. Those of ordinary skill within the art can appreciate that a number of known techniques exist to determine whether the tree structure of one state is similar to the tree structure of another state as to this criterion.

The third criterion is script execution history. That is the third criterion is whether the state of a first graph node resulted from script execution similar to the script execution that resulted in the state of a second graph node. Two DOM states are regarded as similar to one another when they are generated as a result of similar script execution. In order to compare script execution a JavaScript engine may record script code execution.

This record of execution history can be referred to as a dynamic script fingerprint DSFP . Each DSFP is a list of instructions executed when an event handler in JavaScript is activated and executed. This can include not only the immediate event handler but all subsequent code or functions that are called from the event handler code. Typically the specific instructions such as the invocation of built in application programming interface API functions or access to built in DOM properties are recorded. However it may be chosen to record instructions at a finer granular order such as the execution of user defined JavaScript functions or even all byte code instructions.

Each DSFP corresponds to an edge in the transformation graph. As such similarity of two DOM states can be assessed by the similarities of invocation of one event handler. However in some situations a sequence of the event handlers in a particular order may be regarded as an edge. In such instance a sequence of multiple DSFP s may be considered to measure the similarity of DOM states. An approximation algorithm may also be employed for instance to ignore the looping execution of script code that does not have any effect on the similarity of the DOM states.

Each of these or other criteria can be converted into a numerical metric and aggregated in some manner to determine the similarity score of two graph nodes. Thus graph nodes that represent similar states of the object model are merged together within the transformation graph . That is if the similarity score is greater than a predetermined threshold then the graph nodes are considered to be similar and are merged together. It is said that two DOM states s and s are merged into the state s if L s L s L s where the operator implies similarity in accordance with some manner.

An example of simulation of a transformation tree to construct a transformation graph is presented by reference to . shows a representative example transformation tree according to an embodiment of the invention. The tree includes tree nodes A B C D E F G and H collectively referred to as the tree nodes . The tree nodes are connected to one another by tree edges which are represented by arrows in . shows a representative example transformation graph constructed by simulating the tree according to an embodiment of the invention. The graph includes graph nodes A B C D and E collectively referred to as the graph nodes . The graph nodes are connected to one another by graph edges which are represented by arrows in .

The label of each state in is represented as . There are five labels in . Consider the states having the label . The state sis such a state on the transformation tree and s is such a state on the transformation graph . The state shas the transition s b s and the state s has the transition s b s . The labels of sand s are thus the same and the condition noted above holds on the states having the label . On the states having the label s s and sare such states on the transformation tree and s is such a state on the transformation graph . These states have transitions corresponding to the events a and c . The transitions having the event a within the transformation tree are s a sand s a s. The transition having the event a within the transformation graph is s a s . The labels of these transitioned to states are the same. For instance L s L s L s . The transitions having the event c are likewise similar. Therefore on states having the label the condition noted above holds. Indeed the condition noted above holds for all states such that the transformation graph is said to simulate the transformation tree .

This is accomplished so that the pseudocode always terminates and does not fall into an infinite loop. In addition or alternatively a transformation graph state limit may be defined corresponding to the maximum number of states within the transformation graph. As such the pseudocode terminates when the number of states reaches the state limit. That is the transformation graph is constructed until a predetermined number of states of the object model within the transformation tree have been simulated.

Referring back to once the transformation graph has been constructed one or more crawling oriented actions can be performed in relation to the object model by performing these actions on the transformation graph . For instance the nodes of the transformation graph may have crawled to construct a list of all the unique nodes of the transformation graph and in the case of a web site for example the state of each node may be tested for security vulnerabilities. Ultimately the results of these actions are displayed for viewing by a user . As such the user can take concrete and tangible actions in response such as modifying the web site that corresponds to the object model or otherwise modifying the dynamic object model so that such security vulnerabilities or other aspects of the object model that have been highlighted by the actions can be corrected.

The state of each node in is represented by the combination of three classes of information. The first class of information is the sequence of API calls denoted in . The second class of information includes the active properties in each DOM state denoted in and . In this example the number of the onclick event handler is employed as the active property but other conditions may also be specified. The third class of information is document similarity denoted in and . In this example document similarity is assessed by detecting the presence of a table element.

In conclusion shows a rudimentary computerized system according to an embodiment of the invention. The computerized system may be implemented over one or more computing devices. The system includes hardware . The hardware may include processors memory storage devices and other types of hardware as can be appreciated by those of ordinary skill within the art. The system further includes a simulation component a construction component and a performance component each of which is implemented on or by the hardware such as one or more computer programs and or computer executable instructions that program the hardware .

The simulation component is to simulate a transformation tree for an object model as has been described. The simulation component may initially define the transformation tree prior to simulating the tree. The component may thus perform part of the method of as well as a portion of part of the method . The construction component is to construct a transformation graph for the object model as has been described based on the transformation tree that has been simulated by the simulation component . The component may thus perform a portion of part of the method as well as the method of . The performance component performs crawling oriented actions in relation to the object model by performing these actions in relation to or on the transformation graph that has been constructed for the model as has been described. The component also displays the results of these actions. As such the performance component may perform parts and of the method .

It is finally noted that although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is intended to cover any adaptations or variations of embodiments of the present invention. Therefore it is manifestly intended that this invention be limited only by the claims and equivalents thereof.

