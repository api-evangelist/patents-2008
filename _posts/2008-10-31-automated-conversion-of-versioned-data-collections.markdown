---

title: Automated conversion of versioned data collections
abstract: Various computing components (such as devices, operating environments, and processes) may communicate by exchanging instances of a data collection, such as a class or data structure. However, the definition of the data collection may evolve to specify different numbers, types, properties, and orderings of the items in the data collection, and it may be difficult to verify the structure and contents of an instance received from another component and possibly of a different version. This difficulty may be mitigated by exchanging versioning information about the instance (e.g., as part of the communications wire protocol) and by allocating the converting such that the sender may downconvert to earlier versions requested by a recipient, while the recipient may upconvert to later versions than a version provided by a sender. These techniques may promote the accuracy and consistency of information exchange among many components that operate on different versions of the data collection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898236&OS=08898236&RS=08898236
owner: NetApp, Inc.
number: 08898236
owner_city: Sunnyvale
owner_country: US
publication_date: 20081031
---
In many computing scenarios various components may use an instance of a data collection such as a class a data structure or a database record. These data collections are often stored and utilized according to a well defined format identifying the number types and properties of the elements of the data collection e.g. instances of a data structure may be structured as a four byte signed integer eight one bit Boolean values and a ten character string. Such data collections may also be shared among various components such as devices communicating over a network or processes communicating through interprocess communication. The sharing may often involve serializing the elements of the data collection in a manner that omits information about the structure of the elements represented therein and simply comprises a block of binary data. However if the communicating components have a mutual understanding of the structure of the data collection such instances may be exchanged and properly handled even in the absence of structural metadata.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Although many computing scenarios involve a defined structure of a particular data collection the defined structure may change over time. For example a first version of an application may define a structure of a data collection but a second version of the application may alter the definition and computers running different versions of the application may then be unable to exchange instances of the data collection. Some techniques for reducing such problems involve identifying the structure of the elements as part of the data collection e.g. the XML based Simple Object Access Protocol SOAP but these techniques may undesirably increase the size of such instances and may cause inefficiency and reduced computing performance.

An alternative technique for mediating the communication of instances of a variable data collection involves a versioning of the data collection. A version identifier such as a version number may be associated with respective versions of the data collection such that instances of the data collection that share a version identifier may be expected to conform to the structure of the data structure version. Two components sharing an instance of the data collection may then communicate the versioning information of an instance and the instance may be converted to meet the structural definition of a preferred version of the data collection. As a first example if a receiving component requests an instance of a versioned data item but specifies a preference for an earlier structural version the sending component may downconvert the data item to the earlier structural version before sending it to the receiving component. As a second example if a sending component delivers an instance of a particular version that precedes a version preferred by the receiving component the receiving process may receive and upconvert the data item to the preferred version. In this manner the communicating components may share structural version information about an instance of a data collection as part of the communications protocol and the components may convert a particular representation of the instance to meet the versioning preferences of the components.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Many computing scenarios involve an exchange of data among two or more components such as machines or devices that communicate across a network and processes in an operating environment that communicate through interprocess communication. This communication often involves an exchange of a data collection comprising a set of well formatted data items such as a database comprising records having particular attributes a structure comprising primitive data types e.g. an integer a Boolean value and a string and a class encapsulating various member fields methods interfaces etc.

The communicating components may share an understanding of the structure of the data collection. For example an application or program defining a particular structure may operate on two machines that exchange instances of the structure. It will be appreciated that the structure of the data collection may be viewed as a blueprint layout arrangement etc. for a particular type of data item whereas an instance of the structure may be viewed as a specific data item or occurrence of the data collection that is organized in a particular manner generally coincident with the layout of the structure. Many instances of the structure may concurrently or consecutively exist and while two or more instances may contain different data the data within the instances may be similarly organized according to the structure. The shared understanding of the structure of the data collection may be significant to the capacity of the components to communicate because the structure may not be apparent from the contents of the data collection. As one example an instance of a structure totaling 32 bytes of data might comprise four 64 bit long integers or eight 32 bit integers or 256 Boolean values. Moreover a one byte number might represent a signed value between 127 and 128 or an unsigned value between 0 and 256 etc. Because the data comprising a data collection may be construed as representing many sets of data items accurate communication among various components may significantly depend on the shared understanding of the structural semantics of exchanged data collections.

However as the information systems comprising such data collections evolve the structure of a data collection may change. For example the structure of records in a database may change as a database administrator alters the structure of database and the structure of instances of a class may change as a programmer creates new versions of an application. Thus a data collection such as a data structure may be structured in several versions that differ in various ways such as by adding or removing data items reordering the representation of the data items in the data collection and or modifying the format of particular data items. Moreover it may not be possible or even desirable to unify all instances and representations according the most recent structural version e.g. intercommunicating components may be executing different versions of an application that store instances of a data collection in different formats and or may operate on stored instances of the data collection that are variably formatted according to different versions of the data collection.

This variation may cause difficulties among components that exchange an instance of the data item because a receiving component may not recognize a particular structural version of the data collection that the sending component chose for structuring the instance. In some cases the receiving component may simply not understand the data collection e.g. where a 32 byte data collection is expected but a 36 byte data collection is received. In other cases the receiving component may misinterpret the data structure e.g. where the sending component has structured an instance as eight unsigned integers but the receiving component handles the instances as eight signed integers and may even be unable to detect that its understanding of the data collection is incorrect. In still other cases the variation may cause significant operating problems for one or more components e.g. where a larger than expected instance of the data collection causes a buffer overrun in the receiving component or where a misread pointer value in the data collection causes a memory access fault. 

Many techniques may be available to anticipate variable versioning of an exchanged data collection and to adjust the formatting of an instance in order to maintain an accurate representation of the data. The XML based Simple Object Access Protocol SOAP is one such technique wherein the representation of the data collection includes a large amount of metadata that identifies the number sizes types properties and ordering of the elements of the data collection. However the inclusion of metadata with an instance of the item may result in a significant increase in the size of the object. The increased size consequently consumes greater network resources in transmitting the instance and greater space in storing the instance which may represent several significant sources of inefficiency particularly where a large number of instances exist in only a few structural versions of the data collection. 

An alternative technique for exchanging versioned data collections involves a communication of versioning information among two or more communicating components while sharing a data collection. In this technique an instance of a data collection may be represented according to a native version of the instance i.e. the version of the data collection in which the instance is currently represented and stored by the sender . When the sender and recipient exchange the instance the recipient may specify a preferred version of the instance. If the preferred version is earlier than the native version of the data collection the sender may downconvert the data collection to the earlier version before sending it to the recipient. Conversely if the preferred version is later than the native version of the data collection the sender may send the data collection in the native version and the recipient may upconvert the instance to the preferred version upon receiving the instance. In this manner the sender and recipient may cooperate to establish a conveyance of the instance to the recipient according to the preferred version.

Before the instance is serialized and delivered the recipient specifies to the sender a recipient version indicator that indicates the second version as a preferred version of the instance that is preferred by the recipient . The sender compares the recipient version indicator with the native version of instance and determines that the preferred version is earlier than the native version. The sender therefore generates a converted data collection formatted according to the second version and sends a preferred serialization to the recipient . The recipient may then handle the instance according to the formatting specified by the second version which is consistent with the information represented in the first version in which the instance is natively represented. Conversely though not illustrated in if the comparison had indicated that the preferred version were later than the native version of the instance the sender may have sent the first serialization formatted according to the first version in which the instance is natively formatted and the recipient may have upconverted the instance to the preferred format upon receipt. Thus by communicating versioning information for the instance as part of the wire protocol in sending and receiving such data collections the sender and recipient cooperate to improve the accurate representation and use of the data represented therein.

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary method of and the exemplary method of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments of these techniques relates to the scenarios in which the techniques may be utilized. As a first example the components that cooperate in communicating the format may comprise many types of components such as e.g. two devices or computers communicating over a network or direct connection in a server client and or a peer to peer arrangement two hardware devices communicating within a machine over a bus two processes executing two different versions of an application each application version defining a different structure for a data collection etc. As a second example the sending and receiving of the instance may be performed in many ways such as a serialization serial transmission and deserialization of the instance discussed above a parallel delivery involving a parallel transmission of various items of the instance an on demand delivery of various members upon request of the recipient etc. As a third example the communication between the sender and the recipient may involve many elements such as a physical layer wherein the sender and recipient cooperate to exchange bitwise data in a reliable manner a transport layer wherein the sender and recipient cooperatively arrange to assemble exchanged data in a reliable manner with error correction and an application layer wherein the sender and recipient agree to use exchanged data in a particular manner that suits a particular application. The techniques discussed herein may be implemented in many such layers such as in a physical device e.g. a network adapter configured to exchange versioned instances a communication protocol e.g. a network layer implemented in a computer to permit applications to establish communications sessions of a particular type and or an application that involves exchanging instances of versioned data collections. As a fourth example the sender and or recipient may store data relating to these techniques such as a representation of an instance of the data collection or version indicators that are preferred or supported by each other in many ways such as e.g. in volatile system memory on a hard disk drive or on an optical disc. While various storage devices and techniques may have relative advantages or disadvantages in comparison with other storage devices and techniques the sender and recipient may utilize any suitable manner of storing such data while implementing the techniques discussed herein.

As a fifth example of this first aspect the exchange of the instance may arise in many scenarios such as a receiver requesting the specific instance from the sender the receiver requesting all instances of a particular data collection from the sender the client accepting any type of data from the sender which happens to include the instance of the data collection etc. As a sixth example many types of data collections may also be involved in the application of these techniques such as instances of data structures comprising primitive element types instances of a class comprising various member fields methods interfaces etc. and records of a database table that has been altered to embody a varying structure among different versions of the database table. As a seventh example the preference specified by the receiver may be based on many types of criteria e.g. the preference may represent the latest version of the data collection known to the recipient a version that the recipient is better able to handle than other versions etc. Those of ordinary skill in the art may devise many variations among these and many other aspects of the scenarios in which the techniques described herein may be utilized.

A second aspect that may vary among implementations of these techniques relates to the manner of specifying the version indicators for respective instances of the data collection. As a first example the version indicators may be specified ordered and compared in many manners such as an integer representation version 1 as earlier than version 2 a floating point number representation version 1.1.1 as earlier than version 1.1.2 a date representation version 2008.12.31 as earlier than version 2008.11.30 etc. As a second example the version indicators may be associated with an instance of the data collection in many ways. In one such embodiment the version indicator may be stored as an item of the data collection. For example an instance of a Medical Record class may include a version indicator member indicating the version of the instance e.g. as the first member of the instance or as part of a wrapper of the instance. The sender and receiver may reference the particular structural version of the Medical Record class indicated by the version indicator member in order to convert transmit and receive the instance e.g. in order to determine how to serialize and or deserialize the instance. Alternatively or additionally the version indicators may also be specified for the instances of a data collection that are exchanged or preferred by a particular component e.g. the version indicator may be associated with a process to identify the version of an application executing therein and the versions of the data collection that the process is capable of exchanging. For example the instance may be represented during a communication session with a recipient such as when a web browser connects to a webserver to request some items comprising a web page and the server and client may communicate information about versions of such items during the period of web service. In such scenarios the recipient may send the recipient version indicator while establishing the communication session e.g. during a communication session handshake. Upon receiving the recipient version indicator from the recipient the sender may store the recipient version indicator and while sending an instance of the data collection to the recipient the sender may identifying the recipient version indicator by retrieving the stored recipient version indicator. Alternatively or additionally the recipient version indicator may by specified with a request for the instance issued by the recipient and the sender may identify the recipient version indicator before sending the instance by referencing the recipient version indicator specified in the request. Conversely the sender may also specify the sender version indicator in a similar manner e.g. upon receiving a request for an instance accessible to the sender or during the establishing of the communication session. Those of ordinary skill in the art may devise many ways of specifying and communicating version indicators of various instances of data collections while implementing the techniques discussed herein.

A third aspect that may vary among implementations of these techniques relates to the organization of the process for converting an instance of a data collection during either a downconversion to an earlier version of the data collection or an upconversion to a later version of the data collection. As a first example the converting may be achieved through many conversion mechanisms. In one such embodiment the converting may be implemented in a method that generally converts instances of an arbitrary version x directly to an arbitrary version y . In a second embodiment the converting may be achieved through a set of methods that convert form a specific version x to a specific version y and may be chained together for other conversions e.g. converting from version 1 to version 3 by utilizing in series a Convert1To2 method and a Conver2To3 method. This embodiment might be devised e.g. as a set of methods that convert from any version to a common version and then convert from the common version to any other version. In a fourth embodiment the converting may be included as part of a method of serializing and or deserializing instances of the data collection according to a version indicator specified by a sender and or a recipient . In a fifth embodiment the converting may be achieved through the application of a transformation descriptor which may declaratively specify the types properties and organization of the items in an instance of the data collection formatted according to a particular version.

A specific scenario in which the factoring of the converting may be relevant involves a sequence of versions of the data collection in an application wherein a process that is executing a particular version of the application may be able to exchange data structures defined in that version of the application and all prior versions but not subsequent versions. The application may therefore include a function for upconverting earlier versions of an instance to the current version of the instance and for downconverting the current version of an instance to an earlier version of the instance but cannot convert instances to or from versions defined in later versions of the application i.e. the application is backwards compatible but not forwards compatible. Two processes that are executing different versions of the application may therefore utilize the techniques discussed herein to establish exchanges of such instances that both processes may utilize. For example if a sending process determines that it is using a later version of the application and data collection than a recipient process it may utilize the exemplary method of to downconvert the instance to the current version used by the recipient process prior to sending the instance. On the other hand if the sending process determines that it is using an earlier version of the application and data collection than the recipient process it may send its current native version of the instances and the recipient process may upconvert the instances to the current later version used by the recipient process upon receiving the instances. In this manner a compatible exchange of the versioned instances may be promoted as part of the wire protocol whereby the processes communicate. This example illustrates but one scenario wherein these techniques may be factored and applied but those of ordinary skill in the art may choose among many factorings for achieving the converting while implementing the techniques discussed herein.

A fourth aspect that may vary among implementations of these techniques relates to the particular manner in which an instance may be converted. As one such example the converting may reorder and reorganize the data in a binary representation of the instance e.g. by operating on a bytewise view of the instance . Alternatively or additionally where the instance comprises at least one member and where the preferred version specifies a representation format of the at least one member the converting may involve translating respective members of the instance to the representation format of the member in the preferred version. This variation may apply a memberwise conversion that translates each member of the instance to the format of the member in the preferred version. For example in the converting may involve converting the strName element from the variable length null terminated string specified in the first version to the fixed length 10 character string specified in the second version and converting the iAge element from the one byte unsigned integer format specified in the first version to the two byte unsigned integer format specified in the second version while leaving intact the representation of the iPulse element that is similarly represented in the first version and the second version . This memberwise converting may involve reordering elements e.g. where the order in which various members are serialized differs among versions of the data collection. This memberwise converting may also involve resizing blocks of memory. For example where a member of an instance comprising an array of an array size and where the preferred version of the instance specifies a preferred version array size that differs from the array size the converting may involve resizing the array to a preferred version array sized according to the preferred version array size. The converting may also involve omitting a member from the converted instance that is not included in the format specified by the preferred version and or inserting a member that is included in the format specified by the preferred version but that is not included in the native format of the instance. A newly inserted member may also be inserted e.g. with a default value and or by invoking a default constructor for the new member. Those of ordinary skill in the art may devise many ways of converting instances of a data collection while implementing the techniques discussed herein.

The exemplary cluster illustrated in is an example of an embodiment where the techniques and systems described herein may be implemented. For example the modules and may communicate with a distributed transactional database DTDB for example stored in the disk array of respective nodes in the cluster . In this example the modules and may be used to coordinate communication with instances of the DTDB on respective nodes in the cluster . The modules and may be configured to store exchange and use representations of a DTDB in different versions and to exchange representations or portions thereof in different formats. Thus one or both of the modules may be configured to upconvert or downconvert representations of the DTDB or portions thereof in order to provide a version that the other module is capable of processing and may utilize the techniques discussed herein to achieve such conversion. It may be appreciated that components features elements etc. described herein that have functionalities and or aspects related to accessing data may be comprised within and or comprise one or more disk elements . Similarly components features elements etc. described herein that have functionalities and or aspects related to networking and or communications may be comprised within and or comprise one or more network elements . It will also be appreciated that such N and D modules are commercially available from NetApp Inc. of Sunnyvale Calif.

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to apply the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method of versioning an instance of a data collection comprising a sender version indicator such as the exemplary method of and or a method of receiving from a sender an instance of a data collection comprising a sender version indicator and formatted according to a preferred version such as the exemplary method of . Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter recipient an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 13114 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

