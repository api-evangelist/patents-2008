---

title: Automating the life cycle of a distributed computing application
abstract: A system for automating the life cycle of a software application is provided. The software application utilizes computing resources distributed over a network. A representative system includes creating logic operable to create a task list which describes how at least one stage in the application life cycle is to be performed, and processing logic responsive to the creating logic, operable to process the task list to perform at least one stage in the application life cycle. The processing logic is integrated with a development environment, and the development environment is used to develop the software application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621419&OS=08621419&RS=08621419
owner: AT&T Intellectual Property I, L.P.
number: 08621419
owner_city: Atlanta
owner_country: US
publication_date: 20080910
---
This application is a continuation of U.S. Ser. No. 10 608 942 now U.S. Pat. No. 7 437 706 which was filed on Jun. 27 2003 and published as U.S. Patent Publication No. 2004 0268293 which is incorporated herein by reference in its entirety.

The present invention relates generally to distributed computing software and more particularly to tools used to develop and build distributed computing software.

For many years scientists academics and engineers have used computers to solve complex problems. Computers are used in many different disciplines for tasks such as modeling simulation and forecasting. For example the scientific community has used such networks to sequence genes analyze astronomic data and analyze weather forecast data. Because these tasks are computationally complex and or involve huge amounts of data high performance computers are generally used and many interesting problems are not investigated because access to such high performance computers is very limited.

A relatively new approach to complex computing relies on the aggregate computing power of networks of computers instead of individual high performance computers. These networks are known as computational grids or simply grids while the computers on the grid are called grid nodes. The infrastructure of these computational grids is designed to provide consistent dependable pervasive and inexpensive access to computing resources which in the aggregate provide high performance computing capabilities.

To take advantage of computational grids a computing task is decomposed so that it runs in parallel on multiple grid nodes. Some computing tasks are suited for data decomposition where the same application executes on many grid nodes in parallel using different data. Others are suited for task decomposition where different applications execute on many grid nodes in parallel using the same data. Other forms of decomposition are also possible as well as a combination of multiple forms of decomposition.

Grid computing began in the academic and scientific community. The tools first used to develop applications for the grid were therefore those familiar to academics and scientists and were typically based on the Unix operating system and the C programming language. These software developers are comfortable with the bare bones development environment provided by Unix with features such as command line interpreters shell scripts etc.

Grid computing is now beginning to spread to the business community. Software developers in the business community typically use a different set of tools and a different development environment. In order to make grid computing more accessible to the wider business community there is a need for systems and methods that address these and or other perceived shortcomings of the prior art.

One embodiment among others of the present invention provides systems and methods for automating the life cycle of a software application. The software application utilizes computing resources distributed over a network. A representative system includes creating logic operable to create a task list which describes how at least one stage in the application life cycle is to be performed and processing logic responsive to the creating logic operable to process the task list to perform at least one stage in the application life cycle. The processing logic is integrated with a development environment and the development environment is used to develop the software application.

One method among others includes creating a task list which describes how at least one stage in the life cycle is to be performed and processing the task list by a process engine to perform at least one stage in the life cycle. The process engine is integrated with a development environment and the development environment is used to develop the software application.

To execute a grid node application on a grid node nodes which can provide appropriate computing resources must first be identified and the grid node application must be submitted to the identified node s as a job for execution. Rather than using a centralized resource manager and or job submission manager the grid as it exists today uses a decentralized approach where each grid node provides grid services which support resource discovery job submission and other functionality and a grid client which uses the grid services provided by other grid nodes . This can best be illustrated by an example.

In grid node submits a grid node application for execution on grid node and grid node . This is accomplished by grid client using the grid services provided by grid node shown by path and using the grid services provided by grid node shown by path . Grid node also executes another grid node application using its own computing resources on behalf of grid node . This is accomplished by grid client using the grid services provided by grid node shown by path .

In grid client is shown as a single entity which communicates with the single entity grid services . Since grid services provides different types of services in some embodiments grid services may be implemented by multiple entities within grid node . For example the resource discovery functions could be implemented by a grid resource service and the job submission functions could be implemented by a job submission service. Similarly in some embodiments the grid client may be implemented by separate grid client utility programs executing on grid node . For example a Grid Info Search client program could communicate with grid services to access resource discovery services and a Grid Run client program could communicate with grid services to access job submission services.

In the packaging stage the grid node application is packaged so that all files required to run the application are packaged together. For example an application written in Java may require several different applets and classes in order to run and these components can be aggregated into a single archive file. Packaging is often used because it simplifies transfer of the application to another system but packaging stage is not necessary.

In the distribution stage grid node application is distributed to the target nodes where it will run. Distribution stage may involve the transfer of a single file particularly if packaging is used or it may involve transferring each required file individually. If a node requires additional installation after files are distributed for example setting up the run time environment on the target nodes then the installation stage performs installation.

At the execution stage grid node application executes on the target nodes. At the collection stage the results from the execution of the grid node application on one or more target nodes are collected. At the uninstall stage the grid node application is uninstalled removing it from the target nodes.

Life cycle does not always progress from one stage to another in a strict sequence. Instead it is common for a subset of stages in the life cycle to be repeated. For example while the grid node application is still under development the development stage and packaging stage may be repeated many times while the developer debugs the grid node application while the remaining stages are not required because the developer executes the grid node application locally rather than using the grid . As another example when development is complete the stages of distribution execution and collection may be repeated may times as the user runs the grid node application on several different sets of target nodes.

In the example shown in stage is the distribution stage. Grid Proxy Init is a grid client which obtains authenticated access to the grid . Grid Info Search is a grid client which invokes a query on the meta information grid service provided by grid services to identify target nodes. Grid Copy is a grid client which moves files between grid nodes . The files can be data files executable files or a package file containing a combination of these.

Install stage and Execute stage both use Grid Run to execute a specific program on the target nodes. Typically the install stage will execute shell commands or utility programs in order to create directories move files uncompress files etc. Execute stage executes the grid node application .

Collect stage is performed using Grid Status which is a grid client which checks the status of a grid node application which was executed on a target node. Collect stage also uses Grid Copy to copy output files produced by the execution of the grid node application on the target nodes. Uninstall stage is performed using Grid Run typically executing shell commands and utilities to delete files from the target nodes and restore environment variables and paths.

As discussed above in the prior art approach described by a developer of a grid node application performs some stages using standard software development tools and other stages using grid client programs . The developer may automate the stages to some degree by using one or more shell scripts which invoke grid client programs and pass appropriate parameters to the programs. While this level of automation is preferable to manually invoking grid client programs from the command line a shell script interpreter is a general purpose tool which has no concept of stages in a life cycle so that some degree of expertise in scripting is required to achieve the desired result of automating the life cycle of a grid node application .

In one embodiment process engine does not perform the tasks itself but relies on individual task subsystems to perform each type of task. In three types of tasks are performed Grid Run Grid Status Grid Copy and thus three task subsystems are shown. In one embodiment process engine invokes appropriate grid client utility programs to perform tasks. For example the Grid Run task subsystem of process engine invokes the grid client utility program Grid Run as discussed with regard to . In another embodiment process engine uses a toolkit see to access grid services .

Input file may allow one stage to be specified as dependent on another stage. In since an application cannot be distributed before it has been developed section of input file indicates that the distribution stage is dependent on the development stage . In one embodiment a parameter indicates which stage s the process engine is to perform and if dependencies are present then process engine determines which if any other stages must be performed first.

In the process engine is directed at to perform the collect task . Section of input file represents the collection stage and contains a task list with two tasks one to check the status of the submitted job and another to transfer a file containing the results. Process engine determines if grid node application should be executed before results are collected. This determination could be made for example by checking for the presence of the output files generated on a target node when grid node application executes. If the output files are not present then the execution stage should be performed before the collect stage . One skilled in the art will understand that process engine could employ a variety of methods to determine dependencies.

Process engine decides to perform at the task list associated with execution stage . The Grid Run task subsystem executes a grid node application on one or more target nodes. The particular grid node application and target nodes which are passed as parameters to grid services could be specified directly in input file or in another file referenced by input file .

At process engine decides to perform the task list associated with collect stage . The Grid Check Status task subsystem checks the status of a grid node application on one or more target nodes. The Grid Copy task subsystem copies files from one or more target nodes to the node which submitted the grid node application for execution. Processing by process engine is then complete as the last task in the collect stage has been performed.

In one embodiment the process engine verifies that pre conditions are satisfied before performing a specific task in task list . Pre conditions are specified at the task level as parameters in input file . For example if the distribution stage includes a task which copies a file to a target grid node preconditions for that task may include the source file exists the target grid node exists there is enough disk space on the target grid node the user has permissions to copy the file and to create and write the file to the target etc.

Pre conditions also allow process engine to take into account the specific requirements of a particular grid node application when performing a task. For example a grid node application may run only on an Intel platform with a Linux operating system so a precondition for the Grid Run task in this case is that the target grid node meets the specific requirements of the grid node application . In one embodiment the process engine tests preconditions iteratively on all available grid nodes within an organization. To determine whether or not pre conditions are satisfied for a particular grid node process engine uses grid services to obtain meta information about the resources available on grid node and compares this with the requirements of the grid node application .

While pre conditions are defined at the task level the resolution of pre conditions is handled at the stage level and job level. That is the section of input file which defines a stage also specifies how failure of a pre condition is handled. For example a pre condition for the collection stage which collects the results produced by an executed job would be that the submitted job has successfully completed execution. If this pre condition is not met then the submitted job is aborted and or resubmitted.

In this embodiment the user interface for integrated development environment consists of one window which is split into several panes the project pane the structure pane the content pane and the message pane . The content pane allows editing of source files. The structure pane shows in a hierarchical form the structure of the file that is currently displayed in content pane . The message pane displays messages which result from various operations such as building compiling debugging and testing.

The life cycle stages described by input file are displayed in project pane as nodes . In node corresponding to execution stage is selected a menu of possible actions for that node is displayed and the menu item Make is chosen. This action invokes process engine and directs process engine to perform the execution stage as described by input file .

In one embodiment the integrated development environment is Borland JBuilder the process engine is Apache Ant and the input file is an XML build file. In this embodiment stages correspond to Ant targets and the tasks are implemented as Java classes which extend the base classes in Ant .

The Process engine invokes grid services through whatever application programming interface API is provided by the toolkit. Grid client presents an interface API . Each toolkit uses the GRID client API to programmatically call grid client . Grid client uses GRID protocols to communicate over data network with the grid services residing on another grid node .

The peripherals may include input devices for example but not limited to a keyboard mouse scanner microphone etc. Furthermore the peripherals may also include output devices for example but not limited to a printer display etc. Finally the peripherals may further include devices that communicate both inputs and outputs for instance but not limited to a modulator demodulator modem for accessing another device system or network a radio frequency RF or other transceiver a telephonic interface a bridge a router etc.

The processor is a hardware device for executing software particularly that stored in memory . The processor can be any custom made or commercially available processor a central processing unit CPU an auxiliary processor among several processors associated with the grid node a semiconductor based microprocessor in the form of a microchip or chip set a microprocessor or generally any device for executing software instructions.

The memory can include any one or combination of volatile memory elements e.g. random access memory RAM such as DRAM SRAM SDRAM etc. and nonvolatile memory elements e.g. ROM hard drive tape CDROM etc. . Moreover the memory may incorporate electronic magnetic optical and or other types of storage media. Note that the memory can have a distributed architecture where various components are situated remote from one another but can be accessed by the processor .

The software in memory may include one or more separate programs each of which comprises an ordered listing of executable instructions for implementing logical functions. In the example of the software in the memory includes the system for automating the life cycle of a distributed computing application and a suitable operating system . The operating system essentially controls the execution of other computer programs such as the system for automating the life cycle of a grid node application and provides scheduling input output control file and data management memory management and communication control and related services.

The system for automating the life cycle of a grid node application is a source program executable program object code script or any other entity comprising a set of instructions to be performed. When a source program then the program needs to be translated via a compiler assembler interpreter or the like which may or may not be included within memory so as to operate properly in connection with the operating system .

If the grid node is a PC workstation or the like the software in the memory may further include a basic input output system BIOS omitted for simplicity . The BIOS is a set of essential software routines that initialize and test hardware at startup start the operating system and support the transfer of data among the hardware devices. The BIOS is stored in ROM so that the BIOS can be executed when the grid node is activated.

When the grid node is in operation the processor is configured to execute software stored within the memory to communicate data to and from the memory and to generally control operations of the grid node pursuant to the software. The system for automating the life cycle of a grid node application and the operating system in whole or in part but typically the latter are read by the processor perhaps buffered within the processor and then executed.

When the system for automating the life cycle of a grid node application is implemented in software it should be noted that the system for automating the life cycle of a grid node application can be stored on any computer readable medium for use by or in connection with any computer related system or computer readable medium. In the context of this document a computer readable medium can be any means that can store communicate propagate or transport the program for use by or in connection with the instruction execution system system or device. The computer readable medium can be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system system device or propagation medium. A nonexhaustive example set of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM EEPROM or Flash memory and a portable compact disc read only memory CDROM . Note that the computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory.

In an alternative embodiment where the system for automating the life cycle of a grid node application is implemented in hardware the system for automating the life cycle of a grid node application can be implemented with any or a combination of the following technologies which are each well known in the art a discrete logic circuit s having logic gates for implementing logic functions upon data signals an application specific integrated circuit s ASIC having appropriate combinatorial logic gates a programmable gate array s PGA a field programmable gate array s FPGA etc.

The foregoing description has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obvious modifications or variations are possible in light of the above teachings. The embodiments discussed however were chosen and described to illustrate the principles of the invention and its practical application to thereby enable one of ordinary skill in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. All such modifications and variation are within the scope of the invention as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly and legally entitled.

