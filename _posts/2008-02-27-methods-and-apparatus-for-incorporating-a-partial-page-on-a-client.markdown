---

title: Methods and apparatus for incorporating a partial page on a client
abstract: In one aspect, the invention relates to a method for incorporating a partial page into a transmitted page displayed on a client. The method includes displaying the transmitted page on a client, receiving by the client a regenerated portion of the transmitted page from a server and incorporating by the client the regenerated portion into the transmitted page displayed on the client. In one embodiment, the method includes receiving by the client a modification list from the server instructing the client on the incorporation of the regenerated page portion into the transmitted page. In another embodiment, the method includes receiving by the client additional code instructing the client on how to interpret commands contained in the modification list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161472&OS=08161472&RS=08161472
owner: Citrix Systems, Inc.
number: 08161472
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20080227
---
The present invention relates generally to apparatus and methods for updating a page sent to a client for display. More specifically the invention relates to an apparatus and method for regenerating and retransmitting changed portions of the page sent to a client.

Computer communication networks typically include one or more nodes called servers and one or more nodes termed clients. A server provides a service to a client upon receiving a request from the client. illustrates an example of a service that a network may provide. The client communicates with the server using a communication channel . The client via its web browser transmits arrow a request to the server for a web page . The server executes arrow all of the page generation code to generate a complete web page and transmits arrow the web page for display on arrow the client . The generated page represents a snapshot of the state of the server side data at the point in which the page generation code was executed arrow .

For example consider that the page generation code generates the page so as to include a list of share prices for certain stocks. The server retrieves arrow the data i.e. share price that was stored in the server storage buffer or received arrow by the server at the point of time in which the program was executed arrow or sometime before then. The server transmits arrow and the client displays arrow the entire generated page . The page remains displayed on the client until the client requests arrow a refresh of the page i.e. another transmission of the page with a snapshot of the state of the server side data at the time of the refresh request . Upon such a request arrow the server re executes arrow the page generation code and transmits the new generated page to arrow the client .

Some systems may have a periodic update where the client requests arrow a refresh of the page every specified period of time. Upon re executing arrow all of the page generation code the server generates another complete page . Again the page represents a snapshot of the state of the server side data at the point in which the server re executes arrow all of the page generation code . The data e.g. share price in the generated page may be the same as the period before thus making the execution arrow of the page generation code and the transmission arrow of the page unnecessary. Even when the data has changed the majority of the page will be static elements which are unchanged

Neither the manual nor periodic update keeps the user timely informed of data as the data changes. The updates are almost unrelated to the changes in the data for example a page can be transmitted although no data has changed. This update unnecessarily uses network communication channel resources client resources and server resources.

The invention relates to a method and apparatus for regenerating portions of the page that have changed and transmitting only those portions to the client for display. Executing only the necessary parts of the page generation code and transmitting only changes to the client improves the efficiency of using the resources of the network communication channel the client node and the server node. Performing these operations only when required when the data has changed improves the efficiency of use even further. The invention also takes advantage of any portions of the page that are already on the client by reusing them and thus eliminates the need to regenerate or transmit those reusable portions.

In one aspect the invention relates to a method for incorporating a partial page into a transmitted page displayed on a client. The method includes displaying the transmitted page on a client receiving by the client a regenerated portion of the transmitted page from a server and incorporating by the client the regenerated portion into the transmitted page displayed on the client. In one embodiment the method includes receiving by the client a modification list from the server instructing the client on the incorporation of the regenerated page portion into the transmitted page. In another embodiment the method includes receiving by the client additional code instructing the client on how to interpret commands contained in the modification list.

In another embodiment the step of incorporation includes copying a first portion of the transmitted page displayed on the client and inserting the copied first portion into a second portion of the transmitted page displayed on the client. In another embodiment the method includes changing an identification tag of the copied first portion inserted in the second portion from a first value to a non identical second value. In another embodiment the method includes moving a first portion of the transmitted page to a second portion. In another embodiment the step of moving further includes saving the first portion in a storage buffer. In another embodiment the step of moving further includes moving the first portion of the transmitted page to a second portion within the regenerated portion. In another embodiment the method includes changing an identification tag of the first moved portion from a first value to a non identical second value. In another embodiment the step of incorporation includes replacing a portion of the transmitted page with the regenerated portion.

In another aspect the invention relates to a client for incorporating a partial page into a transmitted page. The client includes a transceiver that receives the transmitted page and any partial portions thereof and a display alterer in communication with the transceiver. The display alterer receives a regenerated portion of the transmitted page from a server and incorporates the regenerated page portion into the transmitted page displayed on the client. In one embodiment the display alterer receives a modification list from the server instructing the client on the incorporation of the regenerated portion into the transmitted page. In another embodiment the display alterer receives additional code instructing the client on how to interpret commands contained in the modification list. In another embodiment the client includes a storage buffer in communication with the display alterer the storage buffer storing a first portion of the transmitted page displayed on the client for use in incorporating the regenerated portion.

In another aspect the invention relates to a system for incorporating a partial page into a transmitted page. The system includes an external page code source a client that includes a client transceiver that receives the page and a display alterer in communication with the client transceiver. The display alterer receives a regenerated portion of the transmitted page from a server and incorporates the regenerated page portion into the transmitted page displayed on the client. The system further includes a server that includes a server transceiver in communication with the client the server transceiver transmitting the page to the client for display and a partial page regenerator in communication with the server transceiver and the external page code source. The partial page regenerator receives from the external page code source page generation code that generates the page and executes an associated fragment of the code to regenerate a portion of the transmitted page.

In one embodiment the display alterer of the client receives a modification list from the server instructing the client on the incorporation of the regenerated portion into the transmitted page. In another embodiment the display alterer of the client receives additional code instructing the client on how to interpret commands contained in the modification list. In another embodiment the client includes a storage buffer in communication with the display alterer the storage buffer storing a first portion of the transmitted page displayed on the client for use in incorporating the regenerated portion.

In broad overview illustrates an exemplary embodiment of a partial page regeneration system that includes a first computing system client node in communication with a second computing system server node over a network . For example the network can be a local area network LAN such as a company Intranet or a wide area network WAN such as the Internet or the World Wide Web. A user of the client node can be connected to the network through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 broadband connections ISDN Frame Relay ATM and wireless connections. The client node includes a client transceiver to establish communication with the network . The server node includes a server transceiver to establish communication with the network . The connections can be established using a variety of communication protocols e.g. HTTP TCP IP IPX SPX NetBIOS Ethernet RS232 and direct asynchronous connections .

The client node can be any computing device e.g. a personal computer set top box phone handheld device kiosk etc used to provide a user interface e.g. web browser to an application or web page or to otherwise present data stored or accessed via the server node . The client node includes a display a storage buffer the client transceiver and a display alterer . The display alterer is in communication with the client transceiver for transmitting requests to the server node for an update of a web page . The display alterer also receives the web page or portions of the web page sent from the server node through the client transceiver . The display alterer is in communication with the display for displaying the web page or for incorporating received updated portions of the web page into the currently displayed web page . The display alterer is in communication with the storage buffer for temporarily storing web page data needed for the incorporation of the received updated portions of the web page . The storage buffer can include persistent and or volatile storage.

The server nodes and can be any computing device capable of providing the requested services of the client node particularly generating and transmitting portions of the transmitted web page . It is to be understood that more or fewer servers than those shown in can be connected to the network . In one embodiment the server nodes and are two separate computing devices. In another embodiment the server nodes and are a single computing device. Either implementation is equivalent for practicing the principles of the invention and thus the reference to a server node hereafter represents either configuration or another equivalent configuration.

The server node includes the server transceiver a partial page regenerator page generation code a storage buffer and a data change monitor . The server node can receive the page generation code from any source. In one embodiment the page generation code can be on another physical device that is in communication with the physical device e.g. server node on which the partial page regenerator resides. In another embodiment the source can be a programmer who creates the page generation code and stores the code on the server node to accommodate requests from the client node . The page generation code can be written in any language and in any format that the server node uses to generate a web page . Examples of format for the page generation code include a servlet a JAVA Server Page JSP an Active Server Page ASP a template language and or a Common Gateway Interface CGI script.

During operation of the page regeneration system the server node generates and transmits to the client node only those portions of a currently displayed web page that have changed since the web page or portions of the web page were last transmitted to the client node . The client node incorporates those page portions into the currently displayed page .

As shown in the web page includes a plurality of page portions and generally referred to as . The page generation code includes a plurality of code fragments generally referred to as . illustrates an example of the correspondences between page portions of the web page and the code fragments of the page generation code that generate the corresponding page portions . Examples of format for the web page and thus of the page portions include HTML XML VRML WML display postscript and nroff. Each code fragment generates one or more page portions . For example as illustrated in code fragment generates page portions and

Referring back to the partial page regenerator is in communication with the server transceiver for receiving requests from the client node to refresh the web page . The partial page regenerator transmits the web page or portions of the web page to the server transceiver in response to such requests for transmission to the client node . The partial page regenerator is in communication with the page generation code for executing code fragments of the page generation code to create corresponding page portions of the web page . The partial page regenerator also determines the data in the storage buffer that the code fragments use to generate the corresponding page portions . The partial page regenerator is in communication with the data change monitor to receive notice of any change in the data in the storage buffer upon which the code fragments depend.

The partial page regenerator identifies code fragments in the page generation code . To identify code fragments the partial page regenerator identifies processes e.g. methods in an object oriented language subroutines functions that meet one or more criteria. For example in one embodiment the criterion is that the code fragment e.g. process is idempotent or provides indempotentcy. That is the code fragment produces identical results every time that code fragment is called with the same arguments and the same dependent data . In other words when the code fragment is executed there are no side effects that change the results of calls to other code fragments e.g. no updating of global counters or that change dependent data .

The idempotent property allows the partial page regenerator to substitute a previously cached output generated by the code fragment for another page portion generated by the same code fragment rather than calling that code fragment again. For example as depicted in the embodiment in code fragment generates page portion . Instead of executing code fragment two more times page portions and can be generated simply be copying the portion because the property of the fragment is such that the fragment will produces the same output each time it is called with the same arguments.

The partial page regenerator determines that a process e.g. method in an object oriented language subroutine function in the page generation code meets this criterion by verifying for example that the process does not contain any global variables that the process changes. If the process meets the criterion the partial page regenerator identifies the process as a code fragment in a map of correspondences that the partial page regenerator generates.

For example another embodiment uses the criterion that a process e.g. method in an object oriented language subroutine function generates output e.g. HTML code that defines one or more page portions of the web page . The partial page regenerator determines that a process meets this criterion by verifying for example that the process includes a certain return type e.g. returns String . In other embodiments the partial page regenerator verifies the process follows a certain predefined naming convention e.g. called fragment x and or a certain predefined annotation to the process e.g. define foo is a fragment . In certain formats JSP for example embedded tags may exist that match pieces of the code to portions of the page that the pieces generate. In these formats the tags can be used as identifying code fragments . In other embodiments the partial page regenerator verifies the process includes other certain additional attributes such as being included in a list of process names provided to the partial page regenerator at runtime i.e. when the page generation code is executed .

In one embodiment the partial page regenerator examines the page generation code using a standard JAVA technique introspection . An advantage is that the partial page regenerator does not need to decompile or have source access to the page generation code . This allows the partial page regenerator to work with any page generation code regardless of restrictions e.g. physical or license restrictions to source access of the page generation code .

After identifying the code fragments the partial page regenerator needs the ability to execute the code fragments individually from and independently of other parts of the page generation code . Because the page generation code is written to be executed in its entirety the partial page regenerator must create additional code relating to the page generation code to selectively control execution of the code fragments. To do this the partial page regenerator augments the page generation code to enable individual and independent execution of each of the code fragments .

In one embodiment the additional code takes the same name as the code fragment that the additional code is augmenting. By taking the same name the additional code is called and executed instead of the code fragment of the partial page generation code . The additional code controls whether the code fragment of the page generation code with the same name is subsequently called and executed. This control allows the selective execution of the code fragments of the page generation code .

In one embodiment to create the additional code the partial page regenerator examines the page generation code as a .class file by using introspection. The partial page regenerator then generates an additional JAVA file containing the additional code defined as a subclass of the original page generation code . When compiled the additional JAVA file becomes a subclass of the original page generation code . In another embodiment the partial page regenerator generates a .class file directly. In another embodiment the partial page regenerator performs the code wrapping when the page generation code is executed and generates a class object that is stored in memory.

In the embodiment illustrated in the code fragments and have been wrapped with similar additional code . The additional code determines whether the code fragment has already been executed with the same argument. If the code fragment has been executed which indicates that the code fragment generates multiple page portions additional code issues a command to copy the previously generated page portion into this duplicate page portion. If the code fragment has not been executed then the additional code calls the code fragment e.g. for execution.

In the additional code the term x used after the start end and copy to instructions represents an identification tag that is used by the partial page regenerator to identify each generated page portion . The term mod list represents a modification list that is sent to the client node with the generated page portions . The modification list contains commands that instruct the client node on how to incorporate the page portions into the currently displayed page .

In the illustrated embodiment of the code fragment main is not wrapped. After the initial transmittal of the page the header and static information do not change and this code fragment is not executed again. Consequently additional code is not needed for the main code fragment . All of the page portions of the page that can change are located in the body of the page as represented by the do table code fragment and the do Share code fragment

In another embodiment if the page generation code does not include a body page portion the main code fragment includes additional code not shown similar to the other wrapped code fragments . The additional code not shown provides an identification tag for the body part of the main code fragment . The initial execution provides all of the necessary header information and static data to generate the page . A subsequent execution of the main code fragment is made if the data that the main code fragment depends on changes. The output of this re execution is scanned and all but the content of the body part is discarded. The main code fragment can then be treated like any other code fragment.

In another embodiment there is a single script e.g. page generation code and the code fragments are not individual scripts but represent subroutines of that script e.g. . In this embodiment the CGI interpreter is modified with the additional code not wrapped so that calls to invoke the subroutines of the script e.g. code fragments are intercepted.

In addition to executing the code fragments individually from and independently of other parts of the page generation code the partial page generator may also have to intercept access to the data upon which the code fragments depend. This is typically accessed via data access objects. illustrates an exemplary embodiment where JAVA is used for implementation. In this embodiment data is typically accessed via one or more Java beans . The JAVA beans themselves are logically separate from the page generation code and are only responsible for managing access to the data . The beans are not considered code fragments as the do not directly generate output that produces the page .

To intercept and control access to data the partial page regenerator wraps the JAVA beans that retrieve the data with additional code not shown . Each JAVA bean is a class file so the partial page regenerator generates a wrapper class e.g. proxy for the JAVA bean . The partial page regenerator identifies these processes e.g. methods in an object oriented language subroutines that retrieve data for example by searching for processes that match a naming convention. For example for JAVA beans the naming convention is 

Similarly as described above an advantage of generating a wrapper class e.g. proxy for the JAVA bean is that the JAVA bean code remains unmodified even during runtime. In one embodiment the partial page regenerator generates additional code for JAVA beans by generating two proxies . The generation of two proxies is necessary because the proxy called by the page generation code has the original name of the original process of data access bean so that the proxy is invoked arrow instead of the original process to allow interception of that original process. However if the proxy calls the original process which has the same name the JAVA classloader will incorrectly resolve this by calling arrow the proxy .

The partial page regenerator generates a first proxy that calls a second proxy where the second proxy has a different arbitrary name. The second proxy is invoked and then calls the original process . By arranging that the second proxy and JAVA bean exist in a different name space from the first proxy and page generation code using the two proxies and two namespaces allows for duplicative naming convention. The second namespace can be achieved using a second Java classloader. Though discussed as a technique for JAVA beans that retrieve data this two proxy technique is applicable to JAVA data access objects that are not JAVA beans. For example this technique can be used to intercept access between a piece of code A and a piece of code B providing that B does not reference A by class name and that all unnamed references from B to A are also intercepted by the proxy.

Following the flow of execution arrow first the main code fragment is executed. The main code fragment initially creates an empty page e.g. no content in the body section of the HTML page and uses an identification tag of 0 to identify the portion of the page that contains modifiable page portions . The main code fragment also generates an assign command in the modification list that assigns the content of identification tag 1 to the portion with the identification tag 0 e.g. refer to TABLE 1 below for description of assign command .

The main code fragment calls the do table code fragment . Since the do table code fragment is wrapped with additional code the additional code intercepts the call and begins execution. The additional code creates the identification tag 1 to identify the beginning of the portion of the page that the additional code code fragment produces. The additional code generates the HTML span tag for the identification tag to establish the start of the page portion that the additional code generates. The additional code generates an end span tag to identify the end of the page portion identified as 1 once the execution of addition code is complete. Using the map of correspondences the additional code determines that the do table code fragment has not been executed yet and calls the do table code fragment of the page generation code for execution.

During execution of the instruction set not shown of the do table code fragment of the page generation code the do table code fragment generates a tag in the HTML output and HTML code to generate a header row with table data cells Name and Price . The do table code fragment receives input data e.g. ticker symbols for shares of stock from the storage buffer .

In response to the input data the do table code fragment calls the do Share code fragment of the page generation code for each ticker symbol in the input data . For the first piece of data ABCC the do table code fragment calls the do Share code fragment . Because the do Share code fragment is wrapped with additional code the additional code intercepts the call and begins execution. The additional code creates the identification tag 2 to identify the beginning of the portion of the page that the additional code fragment produces the first time the do Share code fragment is called with the piece of input data ABCC .

The additional code generates the HTML span tag to establish the start of the page portion that the additional code generates. The additional code determines that the do Share code fragment has not been executed yet with the argument ABCC and calls the do Share code fragment of the page generation code for execution. During execution of the instruction set not shown of the do Share code fragment of the page generation code the do Share code fragment generates a row in the table with table data cells ABC Corp. and 99.9 . Because the execution of the do Share code fragment is complete with respect to that page portion dealing with that piece of input data the additional code generates an end span tag in the HTML code to establish the end of the portion created by the additional code fragment. Execution returns back to the do table code fragment

For the next piece of data XYZC the do table code fragment calls the do Share code fragment again. Because the do Share code fragment is wrapped with additional code the additional code intercepts the call and begins execution. The additional code creates the identification tag 3 to identify the beginning of the portion of the page that the additional code code fragment produces the first time do Share code fragment is called with the piece of input data XYZC . The additional code generates the HTML span tag to establish the start of the page portion that the additional code generates. The additional code determines that the do Share code fragment has not been executed yet with the argument XYZC and calls the do Share code fragment for execution. During execution of the instruction set not shown of the do Share code fragment of the page generation code generates a row in the table with table data cells XYZ Corp. and 1.2 . Because the execution of the do Share code fragment is complete with respect to that page portion dealing with that piece of input data the additional code generates an end span tag to establish the end of the portion created by the additional code code fragment. Execution returns back to the do table code fragment

For the next piece of data ABCC the do table code fragment calls the do Share code fragment . Because the do Share code fragment is wrapped with additional code the additional code intercepts the call and begins execution. The additional code creates the identification tag 4 to identify the beginning of the portion of the page that the additional code code fragment produces the second time do Share code fragment is called with the piece of input data ABCC . The additional code generates the HTML span tag to establish the start of the page portion that the additional code generates. This time the additional code determines that the do Share code fragment has been executed with the argument ABCC and does not call the do Share code fragment for execution. The do Share code fragment if executed again would generate a row in the table with table data cells ABC Corp. and 99.9 identical to the portion in the identification tag 2 .

Because the do Share code fragment is not executed the additional code generates an end span tag to establish the ending of the portion created by the additional code code fragment. To generate the portion of the page that is required the additional code generates a copy command in the modification list instructing the display alterer of the client node to copy the portion contained in identification tag 2 to the portion contained in identification tag 4 e.g. refer to Table 1 for description of copy command . Execution returns back to the do table code fragment

With all the pieces of input data processed the execution of the do table code fragment is completed. The additional code generates an end span tag to establish the ending of the portion generated by the additional code . Execution returns back to the main code fragment and from there to the runtime system which transmits the page portions e.g. the HTML output file and the instructions for inserting the page portions e.g. modification list to the client node via the server transceiver .

From the illustrative example of and it is easy to see that when the page is subsequently updated for example because the price of a share of XYZ Corp. increased the execution and output can be further reduced. In one embodiment for example for a subsequent update only the row of the table that has changed is transmitted to the client node . In this embodiment the partial page regenerator executes the do share code fragment with its associated additional code using XYZC as the argument. The additional code creates the identification tag 5 to identify the beginning of the portion of the page that the additional code fragment produces the next time do Share code fragment is called with XYZC . The additional code generates an HTML span tag to establish the start of the page portion that the additional code generates. The additional code calls the do Share code fragment for execution. The do Share code fragment generates a row in the table with table data cells XYZ Corp. and 2.5 the new price. Since the execution of the do Share code fragment is complete the additional code generates an end tag for span id 5 to establish the ending of the portion created by the additional code fragment.

The partial page regenerator determines using the map of correspondences that the row with XYZC has identification tag 3 . The partial page regenerator determines that the rows of the table with ABC Corp. do not need to be updated because the price has not changed. The partial page regenerator transmits the generated HTML output of the updated row and a modification list to the display alterer of the client node for incorporation into the currently displayed web page. The partial page regenerator includes the command Assign 5 3 in the transmitted modification list e.g. refer to Table 1 for description of assign command . This command instructs the display alterer to find the HTML output with the identification tag 3 and replace it with the newly transmitted HTML output portion with the identification tag 5 .

In the exemplary embodiment of the input data originates from the client node . In this embodiment the input data is transmitted from the client node after the client user has inputted the data into one or more user input fields of the transmitted page and clicked on the submit button update button and or pressed the enter key. In another embodiment the display alterer of the client node monitors the user input fields of the transmitted page . When the display alterer has detected data in a user input field e.g. the user entered data into a field and pressed the tab key or the user entered data and moved the cursor to another part of the page and clicked a mouse key the display alterer transmits that data to the partial page regenerator with a page update request.

In yet another embodiment the partial page regenerator provides additional software e.g. a method referred to as feedback to the client node that is part of the page generated by the page generation code . When the additional software is called e.g. by user action the additional software arranges that its arguments are transmitted to the server node . The partial page regenerator also provides additional software e.g. a method also called feedback in the page generation code . The feedback method on the server node uses the arguments received by the client node to update the data in the storage buffer .

For example part of the page generated might be This displays an input box and includes a piece of custom code feedback value that is called whenever the user enters a value and presses tab or moves the mouse. This will call the method feedback on the client node in response to this action passing the value entered. The value is transmitted to the server node . The method called feedback in the page generation code on the server node is called with this value as an argument. This might be for example 

In another embodiment the calling of feedback on the server node causes the partial page regenerator to immediately refresh the page as the page is most likely to have changed.

The partial page regenerator determines the identification tags e.g. HTML span tags of the portions of the page and whether data for any of those page portions has changed because the partial page regenerator generates a map of correspondences as the partial page regenerator creates the page portions which stores such information. Within the map of correspondences is a page description model that models the layout relationship of the portions of the page.

Each node of the node tree has an ID that is unique with respect to each of the other nodes of the node tree and identical with respect to the identification tag e.g. span tag inserted into the HTML output sent to the client node . In another embodiment if the node ID is different from the inserted identification tag the map of correspondences contains the relationship between the model node representing the portion of the page and the actual identification tag e.g. span tag of the HTML code sent to the client node to generate the display of the page portion. To create the page description model the map of correspondences includes correspondences between the code fragment of the page generation code and the portions of the page each of the code fragments create. The map of correspondences also includes correspondences between the code fragments of the page generation code and the data on which each of the code fragments depend.

The value field can be used to create one or more nodes . The map of a correspondences maps arrow the value field to those nodes in the node tree that correspond to that specific value field .

The key field represents arrow the execution of a code fragment . The key field includes the data necessary to re execute a code fragment to generate the value to which the key corresponds arrow . A single key field can have multiple correspondences arrow because as the code fragment of the key is re executed subsequent to a change in the data upon which the code fragment depends a new value is created. At all times however there is only one current value for that particular key .

The current value generated by a key is stored in the table of current values . In the table of current values the correspondence arrow of the key field to the value field is always one to one if the key is represented. In other words some keys may not be represented in the table of current values but if the key is in the table of current values there is at most one value for that key . The table of current values tracks the key field with a specific argument so that there is only one current value field created e.g. one criterion of a code fragment is that it always produces the same output i.e. value field with the same arguments and data .

The map of correspondences maps arrow value fields to event fields . The event field contains data about events that affect the value fields to which they are mapped arrow . In a generic sense a mapped event is simply a notion that a value depends on a piece of data and is used as one means for translating between a notification that something has changed and identifying which values are now invalid.

For example reference to events that indicate a change of the data on which the value field depends can be stored in the event field . With this correspondence arrow when that data changes or an event is generated representing a change in the data the partial page regenerator determines that those nodes which are mapped arrow to the value field mapped arrow to the event representing the changed data are no longer valid and must be updated. The generation and monitoring of these types of data change events are well known in the art and any generating and monitoring technique is acceptable.

As shown in the partial page regenerator generates a modification list along with the actual output that is used to generate a portion of the page on the display of the client node . The server node transmits the portions of the page that have been modified along with the modification list for those particular portions to the client node . The client node uses the modification list to display the transmitted portions in the appropriate area of the page . The display alterer performs the task of incorporating the transmitted page portion using the modification list.

To incorporate the transmitted page portion s into the displayed page the display alterer must be able to process the commands that are on the modification list. The partial page regenerator determines the capability of the display alterer . In one embodiment the display alterer of the client node is part of the client software. In this embodiment the client node can inform the server node which commands the display alterer can understand during the initial request.

In another embodiment the display alterer of the client node is a piece of script added to the page dynamically by the server transceiver when the page is first sent to the client node . An example of the linking of a script client to a page is described in Appendix 1.

In this embodiment the client node informs the server node what type of browser the client node is running as part of the initial request and the server node can then lookup the capabilities in a table of known browsers stored on the server node . For example the client browser may identify itself as being Internet Explorer 5.0 . In yet another embodiment the server transceiver sends the client browser different versions of the display alterer and or client transceiver depending on the type of the client browser.

The modification list uses commands from a predetermined set of commands. For one embodiment Table 1 lists an example of a set of four types of commands that can appear in the modification list. The first column of Table 1 lists the name of the command. The second column of Table 1 lists the parameters that can be included with each command. The third column of Table 1 lists a general description of each command. The term node refers to the nodes of the page description model node tree in the map of correspondences . The command parameter uses the identification tag i.e. ID to represent the node . For example if the node was a table data cell of the price of the stock and the price changed to 120 the command might be Assign 120 . The display alterer would insert the value of 120 in the table data cell with the identification tag 8 .

When an event is detected that represents a change in data the partial page regenerator adds the value that corresponds arrow to the event on an invalid value list not shown . In one embodiment the invalid value list is part of the map of correspondences . The invalid value list tracks all values currently displayed on the page on the client node that have changed and are no longer valid. Once there is an entry on the invalid value list the partial page regenerator waits for a request to refresh the page and in response to that request generates and transmits updates for the changed portions of the page .

The request to refresh the page can be generated in many different ways. For example the user on the client node may request a refresh of the page . In another embodiment the display alterer may request a refresh of the page periodically. In another embodiment the partial page regenerator generates the request for a refresh once a change in data is detected. For example as stated above when the feedback method is called on the server node the partial page regenerator automatically generates a request for a refresh. In another embodiment the communication protocol between the client node and the server node support or simulate a server push model i.e. server node transmitting data to the client node without the client node initiating a request .

To start the exemplary process the partial page regenerator examines the invalid value list and removes all values on the invalid value list step from the table of current values as they represent invalid values. The partial page regenerator generates step a recycleRoot node. This recycleRoot node is a temporary place used to store nodes that might be reused later. The partial page regenerator creates step two initially empty lists of commands a working list and the modification list. The partial page regenerator generates the working list and moves groups of items from the working list to the modification list. The commands used in this example are the same as those commands shown in Table 1.

The partial page regenerator scans step the invalid value list to find the highest node that corresponds to one of the values on the invalid value list. The highest node as the node closest to the root of the node tree . If there are no such nodes then the exemplary process jumps arrow to step . The partial page regenerator removes step the highest node from the page description model node tree for the corresponding invalid value. The children nodes of the highest node are moved step to the recycleRoot as they may not themselves be invalid and may be used later. The partial page regenerator determines step the key used to recalculate the corresponding value of the highest node using the map of correspondences . For example using the partial page regenerator follows the node which corresponds arrow to a value which corresponds arrow to a key .

Once the key is determined step the partial page regenerator determines whether there is a current value i.e. a value in the current value table for the corresponding key . If there is a current value for this key then recalculation step has already taken place for this key on a previous iteration of the loop arrow . If recalculation step has already taken place the partial page regenerator adds step the node to the page description model node tree for the corresponding current value and adds step a CopyValue command to the working list. If recalculation step has already taken place the exemplary process jumps arrow to step .

If recalculation step has not already taken place the partial page regenerator re executes step the code fragment associated with the determined key step to generate a new value. The generated output is saved to an output file e.g. the HTML output code in with an identification tag. The node is added step to the page description model node tree for the newly generated value. Then the partial page regenerator adds step an Assign command using the identification tag to the working list.

During re execution step the code fragment associated with the determined key step may call other code fragments e.g. the do table code fragment calls the do Share code fragment . For each call that has parameters matching a value in the current value table the partial page regenerator via the additional code intercepts the call. The interception is similar to the example of the execution of do Share ABCC for the second time in and . Upon interception the partial page regenerator generates an empty page portion with an identification tag e.g. span ID 4 290and in and generates a CopyValue command which is added to the working list.

The partial page regenerator examines the invalid value list to determine step whether there are more nodes reachable from the root. If there are more nodes the process loops arrow back to step . If there are not any more nodes the process continues with step .

The partial page regenerator examines the nodes under the recycle root to determine step whether any nodes can be reused. As these nodes each represent portions of a page available on the client node it is highly beneficial to reuse these. The portions can be reused if they match CopyValue commands on the working list. If a node under the recycleRoot can be reused the partial page regenerator converts step the matching CopyValue command to a MoveNode command with the source node parameter set to the matching node. The parents and children of the reused node are marked step as used as they may not also be recycled. The partial page regenerator sets step a flag to indicate that at least one command in the working list has changed.

The partial page regenerator continues by sorting step the commands in the working list placing the Assign commands first followed by the MoveNode commands. The partial page regenerator removes step the Assign commands and the MoveNode commands from the working list and appends them to the modification list ready for transmission to the client node . Remaining CopyValue commands are left on the working list.

The partial page regenerator determines step whether any commands have been changed by checking to see if a flag was set step . This determination is made because if at least one command has been changed then it is possible that a previously unreachable node is now reachable. If the flag was set step the exemplary process loops arrow back to step .

When no more nodes can be recycled the partial page regenerator converts step all remaining CopyValue commands to CopyNode commands. These are less efficient than a MoveNode command but still better than separate Assign commands. The source for a CopyNode command is any node that has the correct value. When converting a CopyValue command the set of nodes related to the value is examined and one node is selected. The only requirement is that this node is one that will be available on the client at the time that the CopyNode command is executed. The requirement can be satisfied by selecting the node with the lowest identification tag as the source node when converting the CopyValue commands in both step and step .

During this conversion the partial page regenerator renames the copied sub tree so that the resulting sub tree contains nodes with unique identifiers. Any means may be used for renaming e.g. pre order depth first traversal . The partial page regenerator appends step the working list which now contains only CopyNode commands to the modification list.

In one example the modification list includes a number of sections. All but the final two sections contain one or more Assign commands followed by one or more MoveNode commands. The penultimate section contains one or more Assign commands followed by zero or more MoveNode commands and the final section contains zero or more CopyNode commands e.g. AAM AAAMMM AAA CCC where A Assign command M MoveNode command C CopyNode command and the spaces divide each section .

Then the partial page regenerator removes step all nodes left on the recycle list from the page description model node tree for their corresponding values . If the value has no remaining corresponding nodes in the page description model node tree then the value is discarded and removed from the current values table . The partial page regenerator also removes any event records and keys associated with the discarded values . This reflects the commands that will take place on the client node .

Once the output and the modification list have been created the partial page regenerator transmits the two items through the server transceiver over the network communication channel through the client transceiver to the display alterer . The display alterer incorporates the output using the modification list .

The display alterer reexamines step the current section of the modification list for MoveNode commands. For each MoveNode command the display alterer retrieves step the appropriate source node temporarily saved step in the storage buffer . The display alterer inserts step the value of the node and any descendents into the portion of the page specified by the destination node of the MoveNode command.

The display alterer moves step to the next section in the modification list . If there are no more sections the process continues at step . If the new section does not contain only CopyNode commands the process continues to step .

The display alterer examines step the current section of the modification list for CopyNode commands. For each CopyNode command the display alterer copies step the appropriate source node and any descendents. The display alterer inserts step the output of the copied node and any descendents into the portion of the page specified by the destination node of the CopyNode command. During this copy process the display alterer renames step all of the embedded node identification tags of the copied nodes. In one embodiment the display alterer performs all of the incorporation on the HTML code e.g. a copy of the HTML code of the currently displayed page in the storage buffer and when incorporation of all of the updates is complete the display alterer displays step the updated page. In another embodiment the display alterer displays step each update as that update is incorporated into the displayed page .

The display alterer uses the modification list to incorporate the changes following the exemplary process of . The display alterer examines step the modification list and finds an Assign command. The display alterer also determines step that there are MoveNode commands associated with the descendents i.e. child nodes of the Assign command destination node i.e. node 1 . As shown if the modification list includes implicit actions of saving step the reusable nodes in the storage buffer . Because there is an Assign command for the table the display alterer removes the descendents of that node to start creating a working version 600 of the page description model node tree .

Referring to the display alterer inserts step the output as defined in the Assign command. In this example the output of the Assign command though not shown in the modification list is shown in the working version 605 of the page description model node tree . Per the Assign command the new node 1 includes four descendent nodes with the identification tags 5 6 7 and 8 . The descendent nodes with the identification tags 5 6 and 8 are empty. The descendent node with the identification tag 7 has the value Gamma .

The display alterer continues by examining step the modification list for any MoveNode commands. As shown in there are three move commands. For each MoveNode command the display alterer retrieves step the nodes identified as the source node i.e. and inserts step the values i.e. Alpha Beta Delta into the destination nodes i.e. . illustrates the page description model node tree of the updated page now displayed step on the display of the client node .

Although a table of stock prices has been used throughout this description this invention works equally well with any other kind of content. For example is a screenshot of an example of an email page being displayed to a user at the client node . A page generation code not shown might display a list of messages in an inbox for a particular user. For each message the sender subject and date are shown together with an indication not shown as to whether the message had been read e.g. displayed in bold . This list also contains links so that if a message were selected then it would be displayed in full . With an embodiment of the partial page regenerator the displayed list of messages is updated in a number of ways

The partial page regenerator to create such a list of messages would probably mimic the stock price example in structure. The partial page regenerator determines the number of messages and then executes a loop outputting a page portion e.g. html for each message.

Such an email application might be augmented by a more complex interface for example listing available folders containing email in a tree structure . The partial page regenerator creates this structure by executing one fragment for each folder and either displays a closed folder or displays an open folder and then recursively calls the same fragment to display the contents of the folders. If the generated output contains onClick events for each folder that inform the server node when a folder is selected ie opened or closed then the page is automatically updated to show the new state of a folder after a user selected it.

The invention may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. The foregoing embodiments are therefore to be considered in all respects illustrative rather than limiting on the invention described herein. Scope of the invention is thus indicated by the appended claims rather than by the foregoing description and all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein.

A worked example of adding a player to an HTML page that can then retrieve and display updates to the page. This demonstration will work with Internet Explorer 5.0

Here is an original page which has been augmented with a client player Transceiver and Display Alterer . This is shown in grey and labeled u1. The page has also been modified to get updates immediately that it is loaded this is a simplification . This is shown in grey and labeled u2

The following code is the contents of player.js that is added to the original page. This is a much simplified client player Transceiver and Display Alterer which can perform only simple ASSIGN operations. The operation of this is as follows.

When updates are requested the location of a page containing updates or server generating a page containing updates is supplied as a uniform resource locator URL . This is passed to the getUpdates function. This function creates a hidden subpage frame that is used as a communications channel to the server.

When the server receives the URL request it responds by supplying a set of updates encoded as a HTML page example given later . When loaded this page of updates calls the doUpdate method which in turn applies the update to the original page.

The following is an example page of updates. This page would normally be created dynamically by the Server Node .

