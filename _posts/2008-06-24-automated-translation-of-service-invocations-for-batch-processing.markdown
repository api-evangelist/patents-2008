---

title: Automated translation of service invocations for batch processing
abstract: The utilization of data services (such as web services) may involve the invocation of services, which may reduce performance and overburden the server. In some scenarios, the invocation may be specified in a language that does not support batch invocation, but it may not be feasible to re-code the invocations in a language that supports batching. Instead, the service invocations may be automatically translated into a batch logic specified in a batch-capable language and sent to the service as a batch. For example, a local proxy may receive a language-integrated query having two or more service invocations, compile the query into an expression tree including the two or more invocations, and send the expression tree to the service host to achieve the batch processing of the service invocations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08364750&OS=08364750&RS=08364750
owner: Microsoft Corporation
number: 08364750
owner_city: Redmond
owner_country: US
publication_date: 20080624
---
Contemporary computer servers now provide a wide variety of data services in order to fulfill requests from other computer systems on behalf of various clients. In one scenario a server may be configured to provide data items representing information of interest such as stock prices or weather forecasts. In another scenario a server may perform various calculations and data manipulation at the request of other computer systems for example a high performance massively parallel supercomputer may evaluate mathematical models on behalf of client computer systems such as multivariate linear algebra problems and molecular biology simulations. In a third scenario a server may manage access to a physical component such as a robot or a factory machine and may accept requests for manipulating the physical component provided by users of other computer systems.

These scenarios involve the communication of data items such as computer executable instructions between a server and at least one client computer system. The server is often configured to communicate with such clients by offering one or more services where each service offers one or more service functions. Clients may then utilize the services by invoking the one or more service functions which may involve providing parameters for use in the service functions. The server may respond to the invocation by e.g. validating the service function parameters performing the operations involved in fulfilling the invoked service function and returning one or more result data items produced by the performance of the service function. For example a client may request a share price from a stock market database and may provide a stock symbol identifying a publicly traded company. The server may respond by verifying that the provided stock symbol is valid and that the requested share price is available by retrieving the share price e.g. from a stock market database and by notifying the client of the share price.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The network communication and service invocation scenario outlined above may present some delays while processing multiple usages of the services. A client utilizing the services may often issue a first invocation wait for the first invocation to complete then issue a second invocation wait for the second invocation to complete then issue a third invocation etc. Each invocation involves the serialization of parameters network transport for the request to the server the deserialization of parameters the establishment of a connection on the server side the invocation of the service the serialization of the results the closing of the connection on the server and network transport back to the client and deserialization of the results. Where the client heavily utilizes the services particularly in a serial manner the ensuing costs of using the service may take a heavy toll of time and resources for both the server and the client.

Several of these costs may arise because the programming construct of the query may be oriented around a single invocation model involving one invocation of the service through the server and the return of the results. For example a database query is often structured as a single request written in a single language e.g. a language integrated query and some such languages may not support the packaging of multiple queries of this programming language. Thus where the service invocation is specified according to this programming construct the client may process each invocation as an individual invocation with all of the associated costs of each invocation.

However some servers are capable of accepting and processing a service invocation that is specified in any of several programming languages or even a service invocation having different portions specified in different languages. Some of the alternative programming languages may support multiple invocations either executed in serial or in parallel and some may also support other programming features such as conditional logic and object use. Thus where a client processes at least two service invocations specified in a first language that does not support multiple invocations the client may instead translate the service invocations into a second language that supports multiple invocations. The translated set of invocations may be sent together to the server and processed together by the server and the results of the set of invocations may be returned together to the client. In this manner the associated costs of the service invocation serialization and deserialization of the parameters and result set network transport to and from the server connection opening and closing etc. may be performed once for the set of service invocations instead of once for each service invocation in the set of invocations resulting in reduced time and resource usage and improved performance of the invocation processing.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

This disclosure pertains to the utilization of data services provided by a server the services comprising one or more service functions that may be invoked to achieve a desired result. The server may be configured to receive requests from clients e.g. software running on the client s machine that operates on data provided by the server and to perform the invoked service functions on behalf of the clients. The server may also notify the client of the completion of the service invocations and may send to the client a result data set generated by the invoked service functions.

The example of illustrates the significant number of service invocations involved in providing various services to various clients. However omitted from the illustration of are many of the elements involved in the invocation of the service functions which may be numerous time consuming and resource intensive. The elements of the service invocation may affect the performance of the service functions the computational demands on the service host and the end user performance observed by the clients of the service.

In this exemplary interaction the service host may be configured to receive the network packet and to process the network packet by performing the converse elements in inverse order. For example the service host may deserialize the service function parameters according to the serialization protocol e.g. by converting big Endian formatted multi byte integers into a native multi byte integer storage format. The service host may also validate the parameters such as by identifying the invoked service function checking the bounds of the parameters to be passed into the service function e.g. validating a stock symbol as a recognized company symbol and verifying that the client has permission to perform the requested service invocation e.g. verifying that this client is authorized to purchase and sell stock through the stock trading service. If these elements are successfully performed and the service invocation is validated the service host may then perform the invoked service function. If the invocation produces a response and or one or more data items e.g. a string comprising a report of a weather forecast the service host and client may perform a similar set of elements to return the response and or produced data items to the client .

It may be appreciated that the elements of the exemplary interaction of may involve a significant number of resources and a significant amount of time to complete. As one example the compression of large parameters the serialization of many data items and the digital signature and signature validation of the network packet may involve nontrivial computing resources such as processing power system memory data storage and network bandwidth. Moreover the elements of the exemplary interaction cannot be performed instantaneously and the time involved in performing these elements in both directions along with the network transport time produces a significant delay in the processing of the service invocation in addition to the actual time used by the server in performing the service. Moreover the client may invoke many service functions and many such clients may simultaneously operate on this basis e.g. as illustrated in . As a result the performance of the service invocation and particularly of many service invocations in series may be undesirably slow leading to a protracted delay for the clients. The complicated details of the service invocations may also tie up many allocated resources of the server for an extended period of time and the server may have high operating constraints e.g. number of processors and storage space that increase the operating costs of providing the services with acceptable performance criteria.

Some techniques may be utilized for improving the utilization of resources involved in the provision of data services by a server in contrast with the examples illustrated in . In many scenarios including the scenario illustrated in the clients seek to invoke several service functions. As one example the second client is requesting many types of information from many service functions that provide such information. The information requests could be provided together as a batch and the server may be configured to process the batch of service invocations e.g. asynchronously and or in parallel and to provide the results to the second client as a batch. As another example the third client may be invoking some service functions as a predicate to invoking other service functions. For example the invocation of the stock purchase service function may be contingent on the current stock price reported by another service function. Rather than filing two requests with the service host the third client may be able to request the purchase of the stock as contingent upon the stock price. The third client may therefore provide a service usage logic that describes how the third client desires the service functions to be invoked and the service host may be configured to perform the service usage logic as a single request before returning the data results generated by the service functions invoked by the service usage logic.

However some programming constructs such as service invocation features in a particular language may not permit or facilitate the specification of multiple invocations in a batch. For example a programming language with a database interface may simply provide an Execute Query instruction that executes a single query against the database and multiple queries are processed by calling the Execute Query instruction many times. Therefore an instruction set written in this language may not be capable of performing a batch of service invocations in a single interaction with the service.

A service may however be capable of processing service invocations specified in several languages and may even be capable of processing a service invocation with a first portion specified in a first language and a second portion specified in a second language. Moreover some of these languages may include programming constructs for batch invocation. While a developer may choose to target such a batch capable language and may redesign the application accordingly redesign may not be feasible in many scenarios e.g. where the source code is unavailable or where the redesign might be prohibitively extensive. 

One solution to this problem involves permitting the developer to write the service invocations in any language but to translate the invocations on the back end to use such a batch capable language. As one example an application may include source code featuring service invocations written in a non batch capable language. In conventional scenarios e.g. as shown in these invocations might have been sent directly to the server in such a form and therefore processed individually in a serial manner. However an alternative execution of the application may involve an automated translation of the service invocations into another language that supports batch invocation and a delivery of the batch of service invocations to the server. This might be achieved during compilation e.g. a static invocation specified in the source code might be wholly or partially compiled by a compiler into a translated form of a batch capable language and delivered to the server for processing. Another technique for achieving this improvement involves a runtime intermediary e.g. a local proxy or API that receives the set of service invocations and translates them into the batch capable language before sending the batch to the service. By translating the invocations from a non batch formulation to a batch formulation in a batch compatible language these techniques may promote the processing of the invocations in a batch manner that reduces the per invocation costs in particular the network transport costs of non batch formulations without a manual translation of the invocations by the developers in the batch capable language.

Additional improvements may also be achieved through the translation. As a first example the batch capable language may have serialization and deserialization capabilities that may be harnessed to handle the delivery of parameters sent to the service as part of the invocation e.g. a data set on which the service operates and or the return of a result set generated by the service invocations and delivered from the service to the client. As a second example the translated set of invocations may embody a programming logic that may embody more programming constructs than a series of invocations. For example the logic might include program flow constructs that alter the order of service invocations such as conditional execution and iteration. The logic might also specify different sequences for executing the invocations rather than a simple series or arbitrary execution of invocations for example the logic might specify that a first set of service invocations may be executed in parallel while a second set of service invocations are to be executed in a sequence and a third set of service invocations may be executed in any arbitrary order. These and other features may be achieved through the translation of the service invocations into a logic in a batch compatible language.

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary method of and the exemplary system of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments relates to the types of service invocations to which these techniques may be applied. As a first example the service invocations may be contained in many types of instruction sets such as source code partially or wholly compiled binaries imperative scripts executed in an interpreter and declarative data models that involve the invocation of the service e.g. an HTML page specifying that part of a page is derived by executing various queries on a content database. As a second example these techniques may be applied to many types of invocations involving many types of services such as a web service invoked by the invocation of remote methods in an application or a database invoked by a series of queries. In an exemplary scenario a source code may specify one or more language integrated queries that are to be applied against one or more databases. For example the expression tree may compile each service invocation into a lambda expression to be applied to the service. The expression tree representing the batch logic may then be sent to the service host for processing of the service invocations in a batched manner. Those of ordinary skill in the art may devise many types of services and service invocations to which the techniques discussed herein may be applied.

One such scenario is illustrated contrastingly in illustrating an exemplary scenario without batching and illustrating an exemplary scenario with batching. In the exemplary scenario of a first logic comprises a language integrated query having at least two service invocations e.g. two queries to be executed against a database . In a scenario not involving the techniques illustrated herein a compiler may be utilized to compile the first logic into a set of SQL statements that are to be executed against the service host e.g. a front end for a database . Because of the lack of batching the first service invocation is processed by a first interaction and the second service invocation is processed by a second interaction . By contrast in the exemplary scenario of the compiler may translate the language integrated query into an expression tree which may represent a batching logic specifying the processing of both the first service invocation and the second service invocation. The expression tree may then be sent to the service host for execution which may involve applying both service invocations against the database and returning the result. Because the translation into the expression tree results in batching of the service invocations only a single interaction is involved to send the service invocations to the service host and to receive back a result set.

A second aspect that may vary among embodiments of these techniques relates to the manner of configuring the client to perform the invocations on the service host. As a first example the client application may synchronously handle the batch of service invocations by delivering the batch logic to the service host awaiting a response to the batch invocation by the service host and continuing execution of the application. As a second example the client application may asynchronously handle the batch of service invocations by delivering the batch logic to the service host continuing execution of the application while the batch is being processed by the service host and then receiving and handling the result set whenever the service invocations are complete. As a third example the application may utilize a proxy to mediate communication with the service host. For example a remote invocation API may be devised that accepts a batch of invocations e.g. one or more language integrated queries comprising two or more queries against one or more databases and returns the results. Although it may not be visible to the client application this remote invocation API might opaquely handle the querying through batching e.g. by accepting the language integrated query translating it to an expression tree sending the expression tree to the service host receiving back a result set and providing the result set to the client application. Moreover the local proxy may be invokable in many ways. As one example the local proxy may provide a querying interface configured to produce the batch logic and send it to the service host. As another example the local proxy may asynchronously handle the interfacing with the service host by accepting an asynchronous callback from the client application along with the service invocations and upon receiving the result set invoking the asynchronous callback to deliver the result set. By implementing the translating and sending in a local proxy the computing environment may quietly impart a batching capability to the service invocations of various applications despite the non batching nature of the service invocations requested by the applications resulting in a performance improvement without a re coding of the service invocations in a batching language. Those of ordinary skill in the art may devise many configurations of a local proxy that implement the techniques discussed herein.

A third aspect that may vary among embodiments of these techniques relates to the exchange of data between the client and the service host such as the parameters sent by the client to be used in the service invocation and a result or result set returned from the service host to the client in response to the invocations of the service. As a first example one or more service invocations may involve a local object to be used in the service invocation and while generating the batch logic the local object may be represented in the batch logic e.g. by translating the object into an object format compatible with the batch capable language. Alternatively or additionally the translating may serialize the local object for transmission to the service host. As a second example the invocation of the services may result in data to be returned to the client application such as an invocation result success failure etc. or a result set. A service invocation result that is received in response to the batch logic may be returned to the client application e.g. a local proxy may deserialize the objects of the result set and return them to the client application to complete the synchronously or asynchronously processed batch of service invocations. In one such scenario respective local objects may correspond to records in the service invocation result such that one object may be deserialized for each record in the returned result set. Moreover a querying interface may be generated and provided to the local objects to facilitate the application in querying the data contained in the deserialized objects. In another scenario the data of the returned result set may be data bound to various properties of an existing object and when the result set is received by the client the received data may be copied into respective bound properties of the objects. These and other features may be combined with the translating of the batch logic and the sending to the service host to facilitate the integration of the service invocations with the other aspects of the application. Those of ordinary skill in the art may devise many ways of handling the exchange of data between the client application and the service host while implementing the techniques discussed herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

