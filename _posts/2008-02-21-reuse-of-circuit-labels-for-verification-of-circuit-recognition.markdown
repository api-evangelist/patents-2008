---

title: Reuse of circuit labels for verification of circuit recognition
abstract: A method for identifying instances of a smaller circuit in a larger circuit is provided. Both the smaller circuit and the larger circuit have a plurality of vertices. A vertex is one of a device or a net. The device, such a transistor, includes a Gate, a Drain, and a Source. The net is a wired connection between devices. The method includes recursively relabeling of each of the plurality of vertices until labels of all neighboring vertices of a selected vertex are zero. The neighboring vertices of a vertex are vertices that are directly connected to the vertex. Each successive iteration of the relabeling uses labels of each of the plurality of vertices after a previous iteration of the relabeling. Then, a recursive circuit tracing operation is performed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07861193&OS=07861193&RS=07861193
owner: Oracle America, Inc.
number: 07861193
owner_city: Redwood City
owner_country: US
publication_date: 20080221
---
This Application is related to co pending U.S. patent application Ser. No. 12 035 409 filed on Feb. 21 2008 entitled Unidirectional Relabeling for SubCircuit Recognition which is incorporated herein by reference for all purposes.

The present invention generally relates to electronic circuit design. More particularly the present invention is directed to efficiently and accurately finding predetermined patterns in a main circuit design.

The present invention generally relates to electronic circuit design. More particularly the present invention is directed to efficiently and accurately finding predetermined patterns in a main circuit design.

Recognizing or finding subcircuit instances in a larger circuit is widely used in the simulation verification and testing of integrated circuits using computer aided design programs. Currently the process of finding is performed using ad hoc techniques that rely on the circuit technology and implementation details. Such techniques however do not generalize to different subcircuit structures and do not transfer to other technologies. A publication entitled SubGemini Identifying SubCircuits using a Fast subgraph Isomorphism Algorithm by Ohlrich et. al. hereinafter SubGemini describes a technology independent algorithm for solving this problem based on a solution to the subgraph isomorphism problem. This publication is incorporated herein by reference. SubGemini describes a use of a recursive relabeling approach to identify circuit patterns in a larger circuit. However the SubGemini method of finding patterns in a larger circuit has flaws that under certain circumstances prevent the labels from having enough information to ensure an accurate identification of the instances of the subcircuits in larger circuits.

Thus there is a need for method and system that enable a more accurate and efficient identification of patterns i.e. subcircuits in a larger circuit.

An accurate and efficient method and system of detecting all instances of a subcircuit in a larger circuit are disclosed. Embodiments of the present invention disclose unidirectional relabeling of vertices of the subcircuit and the larger circuit to enable much deeper recursion of the relabeling method so that the labels include enough information related to the circuit topology around them.

In one embodiment a method for identifying instances of a smaller circuit in a larger circuit is disclosed. Both the smaller circuit and the larger circuit have a plurality of vertices. A vertex is one of a device or a net. The device such a transistor includes a Gate a Drain and a Source. The net is a wired connection between devices. The method includes recursively relabeling of each of the plurality of vertices until labels of all neighboring vertices of a selected vertex are zero. The neighboring vertices of a vertex are vertices that are directly connected to the vertex. Each successive iteration of the relabeling uses labels of each of the plurality of vertices after a previous iteration of the relabeling. Then a recursive circuit tracing operation is performed starting from the selected vertex until each of the plurality of vertices in the smaller circuit is matched with one of the plurality of vertices in the larger circuit. The circuit tracing operation includes matching a label of each of the plurality of vertices neighboring the selected vertex in the smaller circuit with a label of each of the plurality of vertices in the larger circuit neighboring a vertex corresponding to the selected vertex wherein labels at a same depth of relabeling iteration is matched.

In another embodiment a system for identifying instances of a smaller circuit in a larger circuit is disclosed. The smaller circuit and the larger circuit have a plurality of vertices. Each of the plurality of vertices is one of a device or a net. The device has a Gate a Drain and a Source. A processor to execute programming instructions is included in the system. The system also includes a memory to provide programming instructions execution support to the processor and a netlist data store for storing a data representation of the larger circuit and the smaller circuit. A unidirectional relabeling module is included to retrieve the data representation of the larger circuit and the smaller circuit and to perform unidirectional relabeling operations on the data representation of the larger circuit and the smaller circuit. The unidirectional relabeling operations included calculating new labels for each of the plurality of vertices in the data representation of the larger circuit and the smaller circuit wherein circuit components connected to the Gate are omitted in calculation of the new labels for each device in the plurality of vertices.

In yet another embodiment a computer readable medium for storing programming instructions for identifying instances of a smaller circuit in a larger circuit is disclosed. The computer readable medium includes programming instructions for recursively relabeling of each of the plurality of vertices until labels of all neighboring vertices of a selected vertex are zero. The neighboring vertices of a vertex are vertices that are directly connected to the vertex. Each successive iteration of the relabeling uses labels of each of the plurality of vertices after a previous iteration of the relabeling. The computer readable medium also includes programming instructions for recursively performing circuit tracing operation starting from the selected vertex until each of the plurality of vertices in the smaller circuit is matched with one of the plurality of vertices in the larger circuit. The circuit tracing operation includes matching a label of each of the plurality of vertices neighboring the selected vertex in the smaller circuit with a label of each of the plurality of vertices in the larger circuit neighboring a vertex corresponding to the selected vertex wherein labels at a same depth of relabeling iteration being matched.

The advantages of the embodiments of the present invention are numerous. Most notably the systems and methods described herein provide a more accurate identification of the instances of a subcircuit in a larger circuit because the circuit tracing operations using the vertex types and or vertex labels eliminates any false identification of the instances of a subcircuit in a larger circuit. The improvement in accuracy is achieved by providing a method of unidirectional relabeling of the vertices of circuits.

Other aspects and advantages of the present invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the present invention.

The figures are provided in order to provide a thorough understanding of the present invention. The figures should not be construed as limiting the breath of the invention in any manner.

A method of accurately identifying instances of a pattern i.e. a smaller circuit or a subcircuit in a larger circuit i.e. a main netlist is disclosed. In one embodiment the circuit components of the pattern and the main netlist are unidirectionally relabeled recursively until no more relabeling is possible under given rules of relabeling. The highest label in the pattern is then used to identify the instances of the pattern in the main netlist. While the present invention has been particularly shown and described with reference to the foregoing preferred embodiments those skilled in the art will understand that many variations may be made therein without departing from the spirit and scope of the invention as defined in the following claims. The scope of the invention should therefore not be limited to the description of the invention rather the scope of the invention should be defined by the claims including the full scope of equivalents thereof.

The pattern as used herein is a circuit whose various properties and behavior are already known. For example a NAND gate could be a pattern. The pattern has one or more devices such as transistors connected together through nets for example wires connecting the transistors in a logic gate . The nets may include resistors capacitors etc. However for the purpose of the identification of the instances of the pattern in a larger circuit i.e. main netlist the nets are considered simple wire connections i.e. circuit components such as resistors capacitors etc. are omitted and replaced by wire connections . One of the uses for finding the instances of a particular pattern in a main netlist is to identify a related collection of interconnected primitive devices in a circuit as a single high level component. For example converting a transistor netlist into a logic gate netlist involves finding the subcircuits representing gates and replacing them with the corresponding logic gates. Similarly replacing larger known subcircuits such as flip flops in a main netlist by black boxes would reduce simulation and analyzing time because the properties and characteristics of the flip flop for instance are already known and do not need to be analyzed for every instance of this subcircuit in the main netlist.

In one embodiment the process of identifying the instances of a pattern in the main netlist is performed in two phases. In the first phase each net and device in the pattern and the main netlist is given an initial unique label. In this embodiment the initial labels are prime numbers to minimize the possibility of number collision during recursive relabeling. Then the nets and devices are relabeled recursively using a predefined formula discussed in detail later in this document for relabeling. The netlist is treated as a graph where both nets and devices are treated as the vertices and the connection among the nets and devices are called edges . This graph happens to be bipartite with the nets and devices as the two sets i.e. all immediate neighbors of a net are devices and all immediate neighbors of a device are nets.

In general this process of relabeling transmits topology information laterally across the graph. The topology information is encoded in the vertex labels. That is the information about a given vertex emanates outward by one step for each relabeling round. Conversely with each relabeling round or iteration the label of a given vertex encompasses topology information of a wider and wider area surrounding it. This transmission of information thus becomes an excellent way to encode a great deal of information about the pattern into a single vertex label. With labels that are the products of many relabeling iterations it becomes very likely that the same labels appearing in the pattern and main netlist correspond to the same topologies in the surrounding area represented by that label. With this overview in mind the following figures will illustrate example structure and functionality of sampling based runtime optimizer for efficient debugging of applications.

By way of example illustrates the pattern showing exemplary initial labels for various components in the pattern . In one embodiment only prime numbers are used for initial labeling to avoid collision of label numbers during recursive relabeling. In another embodiment the numbers may be chosen arbitrarily. However choosing a distinct number for each of the component such as net device connection type Vdd GND etc. would provide better results because during relabeling the label will include more distinct and granular information about the topology of the circuit. In one embodiment initial labels are applied uniformly throughout the pattern and the main netlist. Same labels are used for particular components both in the pattern and the main netlist . For example if an N Transistor is given an initial label of all N Transistors in the pattern and the main netlist must be given the same initial label. Similarly if a GND port is given an initial label of the same number must be used throughout in the pattern as well as in the main netlist.

In one embodiment the same label number is provided to both Drain to net and Source to net connection types for example see label in . In other embodiment different connection type labels may be assigned to Drain to net and Source to net connection types. In one embodiment the Gate to net connection type for example see label in is assigned a label number that is different from the Drain to net and Source to net connection type labels. In one embodiment a net is a set of wires that connects two or more devices such as transistors . The net also connects other nets or devices to the input or output ports. For example illustrates few exemplary nets such as N N N N N and N and devices T T T and T. In one embodiment the Gate to net connection type label is kept different to indicate whether a net is connected to the Source Drain terminals of a transistor or to the Gate terminal. In another embodiment three separate connection type labels can be assigned to the Gate the Drain and the Source. During the relabeling in one embodiment only nets and devices are relabeled. As mentioned before nets and devices are also called vertices. Note that one key requirement to making the embodiments described herein to work is to perform exactly the same initial labeling and relabeling procedures in both the pattern and the main netlist.

Still referring to a fundamental limitation of this technique is the effect of nets that are ports on the pattern. These nets will almost certainly have fewer connections in the pattern than their corresponding nets will in a valid match in the main netlist. This is due to the fact that an instance of the pattern in the main netlist must communicate with the rest of the main netlist in order to be useful. This means that even the initial labels of these nets i.e. the nets connected to the ports usually won t match between the pattern and the main netlist. Worse still this mismatch of labels propagates during relabeling along with the rest of the information that the labels hold. Thus with each round of relabeling successively larger areas around each port net bear invalid labels i.e. NULL labels . In one embodiment this problem can be solved by considering that each port net has a kill flag that propagates along with the relabeling. This flag can be represented simply by the use of a null label. Meaning input and output ports are given initial label zero because the topologies connected to the input and or output are unknown i.e. nets that are ports are given initial label zero . Then use the following relabeling rule If any neighbor of a vertex has a null label this vertex cannot be relabeled. Instead this vertex s label becomes null as well. 

Formula 1 calculates a new label for a net by multiplying the value of the label of a neighboring vertex after a previous relabeling iteration by the connection type label i.e. the value of the label of the connection type that connects the net to the neighboring vertex in question and adding to the multiplication result to the current label of the net. This process is repeated for all neighboring vertices of the selected net.

In one embodiment a separate list of labels of each vertex after each round or iteration of the relabeling is maintained. Hence one list is maintained for all initial labels. Another containing labels of each vertex after first round of relabeling of all vertices yet another containing labels of each vertex after second round of relabeling and so on. Therefore in Formula 1 the neighbor s label after previous iteration of relabeling means that if a third round of relabeling is in progress the labels of neighbors after second round of relabeling are used in the calculations. By extension in round one of relabeling initial labels of the vertices are used.

Still referring to in operation if the vertex is determined to be of type device i.e. not net the control moves to operation in which first a determination is made whether any of the neighboring vertices connected to the Drain or the Source of the device is NULL. If yes then the selected device is given a NULL label too. Otherwise a new label for the selected device in one embodiment is calculated using the following formula 

In Formula 2 the meaning of term after previous round of relabeling is same as described in the description of the Formula 1 .

Formula 2 calculates a new label for a selected device by calculating a first multiplication result by multiplying the value of the label of the Source connected vertex after a previous relabeling iteration by the Source connection type label i.e. the value of the label of the connection type that connects the Source of the device to the neighboring vertex in question calculating a second multiplication result multiplying the value of the label of the Drain connected vertex after a previous relabeling iteration by the connection type label i.e. the value of the label of the connection type that connects the Drain of the device to the neighboring vertex in question adding the first multiplication resultant to the second multiplication resultant and to the current label of the selected device. This process is repeated for all neighboring vertices of the selected device.

The control is then moved to operation in which a determination is made whether more vertices are remaining to be relabeled in this round of relabeling. If no vertex is left to be relabeled in this round of relabeling the process ends. However if more vertices are remaining to be relabeled in this round of relabeling the control moves to operation in which the next vertex is selected and then the control moves to operation again. When the process ends one round of relabeling is finished. The new labels are stored in a separate list for use in the next round of relabeling. These lists are stored in a non volatile data store. In one embodiment each list includes a number representing a depth of relabeling an identification of each vertex in the circuit and the label of the vertex after that particular depth of relabeling. An appropriate indexing of the tabular data may be employed to facilitate easy data management and access. The lists may be stored in a relational database or a similar data store or in a file in the file system. In different embodiments the process described in can also be used both in unidirectional relabeling and in bidirectional relabeling.

As explained earlier the kill signal propagates from the ports to the vertices in the pattern or in main netlist . In one embodiment the relabeling process ends when no more devices in the pattern or in the main netlist can be relabeled. In other embodiments the relabeling can be stopped earlier if a determination is made that the remaining non zero labels contain enough topology information to facilitate the pattern identification in the main netlist.

It should be noted that the formula for calculating a new label for a device i.e. Formula 2 does not include the net connected to the Gate of the device. In other embodiments Formula 2 can be modified to include Gate connected nets and exclude either the Drain connected net or the Source connected net or both. In other words the asymmetry in the graph is being advantageously utilized. This determination can be made based on the topology of the pattern. If there are more ports i.e. input output in one embodiment connected to the Gate the Gate connected net is not included in the formula. One reason behind not selecting one of the terminals is to delay the propagation of the kill signal. This solves a big issue that is present in SubGemini. SubGemini method is useless in many cases such as in a pattern in which all or most Gates are connected to the ports for example a NAND gate . By SubGemini method of recalculating the labels in a NAND gate for example no round of relabeling is possible because every device is touching a kill signal i.e. a port with the label 0 . Hence in this case according to SubGemini only initial labels can be used for the identification of the pattern in the main netlist. However Formula 2 in various embodiments solves this issue by delaying the propagation of the kill signal. Therefore several iterations of relabeling is possible even in the cases such as a NAND gate pattern. Furthermore to achieve an optimal depth of iterations Formula 2 can be readily adjusted to include the Gate connected nets and to exclude either the Drain connected net or the Source connected net depending on a particular type of pattern.

As mentioned earlier the main netlist is also subjected to the same process of relabeling as illustrated in . The same initial labels as used in the pattern for different types of vertices and connection types are also used for the main netlist. Further exactly the same Formula 1 and Formula 2 as used for the pattern during the execution of operations as illustrated in are also used for the main netlist. Because the main netlist includes a larger circuit the ports are generally far away from various vertices in the main netlist comparatively more relabeling iterations are possible in the main netlist due to comparatively delayed kill signal propagation to the inner devices in the main netlist . However because the pattern identification is performed by comparing the labels at a same depth of relabeling the main netlist relabeling iterations are performed only until the depth of relabeling equivalent to the final depth of relabeling in the pattern is reached.

Moving now to which exemplarily illustrate a shrinking number of vertices and increasing label numbers after each iteration of relabeling. As mentioned in the description of the shrinking occurs due to propagation of the kill signal inward. As apparent the number of remaining vertices shrinks with each round of relabeling and finally in one embodiment no additional non zero labels can be recorded in the pattern. Alternatively the process of performing the relabeling iterations may be ended when a desired depth or relabeling is reached and a determination is made that the labels at that depth contain enough topology information to enable the identification of the instances of the pattern in the main netlist. Term depth as used herein refers to number of rounds or iterations of relabeling. In one embodiment the initial labels are considered at depth zero .

By way of example illustrates one embodiment of a Phase 2 process for further verifying the identification of the instances of a pattern in the main netlist the process of relabeling as illustrated in being Phase 1 . In Phase 2 a seed vertex is identified. In one embodiment the seed vertex is a vertex that is represented by the label used for the comparison of labels in Phase 1 as illustrated in . by way of example provides a clearer view of a seed vertex or node at the circuit level.

Referring to if there are multiple vertices connected to the seed vertex in the checking path a nested loop is used to cover all p and m pairs in one embodiment. In one embodiment a net to device pair comparison is made. Note that the seed or a vertex in checking path in the pattern may be connected to different numbers of other vertices compared to the seed or similar vertex in the main netlist. Therefore as illustrated in the number N as used in term pN in may be different from the number M as used in term mM in . Typically N will be less than or equal to M if node vp is a connected to a I O port. Otherwise M should be equal to N. Further if unique pairs are found these pairs are iterated first before moving further in the checking path. If any ambiguous pair is found try p1 m1 then if fails try p1 m2 then p1 m3 etc. within the set of ambiguous pairings. In one embodiment the pattern neighbor list is reordered and checking is performed again. If case of a failure this reordering is attempted again and again until no more unique reordering is possible.

Term working in parallel as used herein means that exactly same steps are taking in parallel on both the pattern and the main netlist. For example if the process is implemented in software two threads or two processes executing in simultaneously can be used. However working in parallel does not imply that any two similar steps are being performed exactly at the same time. These steps could be performed at a delay so long as one operation step being performed on the pattern can be repeated in the main netlist.

If in Phase 2 a mismatch if found during the vertices retracing the instance of the pattern in which the mismatch was found could have been falsely identified during Phase 1 identification. If Phase 2 retracing is successful the identification process is successfully performed and the pattern matching of Phase 1 is confirmed. In one embodiment Phase 2 may be omitted if the process performing entity determines that the Phase 1 results are accurate within an acceptable margin or errors.

In one embodiment each vertex in the pattern and the main netlist is given a unique identity. This unique identify of a vertex along with the vertex label is stored together after each relabeling iteration.

In the label checking operation after seed vertices are identified in the pattern and in the main netlist the directly connected neighboring vertices are counted. For example in the pattern includes a seed vertex P which has three neighboring vertices P P and P. If the main netlist has less number of neighboring vertices to a corresponding seed vertex in the main netlist the matching operation fails and the matching operation is then attempted on another seed vertex in the main netlist. However since the pattern inside the main netlist may be connected to other circuit components the existence of more neighboring vertices is not an indication of mismatch.

Then each neighboring vertex in the pattern is attempted to be matched with a corresponding neighboring vertex in the main netlist. For example P is attempted to be matched or paired with any of M M M and M. In one embodiment the term matching means comparing the labels of the vertices at a same depth level. In one embodiment if pattern vertex P has a max labeling depth of 3 then we will also look to the labels of M M M and M at depth 3. In other embodiments the label at a depth below the pattern vertex s max labeling depth can also be used as long as the labels from the same depth of the main netlist vertices are used for this vertex pairing operation. This will not impact the functionality but the performance will generally be best if the max depth pattern labels are used. As described earlier the label data of each vertex after each relabeling iteration along with the depth information and unique identification of each vertex is stored in a database see during the Phase 1 operation. This label data is reused in the circuit tracing operation. If the label of any one of M M M and M matches with the label of P P is marked as matched and this marking flag is stored in a database or a data store. This process is repeated for remaining neighboring vertices i.e. P and P. Then this same process is repeated for P P P and other remaining vertices in the pattern.

However if for instance the label of P matches with more than one corresponding vertex in the main netlist for example P matches with M and M both there is an ambiguity as to which one of M and M is a good match. To ascertain a good match further matching is attempted in the neighboring vertices of P with the children nodes of M and M separately. A match is not confirmed until all children of a vertex are matched. For example the children of P are attempted to be matched with the children of M recursively to make sure there is not false match. If any mismatch is found at any level the match is discarded. When all children of P are matches the subcircuit identification of Phase 1 process is confirmed. In one embodiment a parallel processing is employed to enhance the performance of matching of the labels of vertices at various levels. It should be noted that the process of verification of the circuit identification as described throughout this document can be applied both in depth first or breadth first pairing techniques or any combination of the two or any other manner in which the pattern and the main netlist topologies are traced in parallel.

As described earlier the label of a vertex contains the topology information of the circuit around the vertex. Note that the initial labels i.e. labels are depth 0 don t contain surrounding topology information. These initials labels have information of the nets or devices by themselves. Therefore comparing the same depth labels of the vertices provides improved and efficient way of verifying the subcircuit identification. This circuit tracing using the vertices labels can be performed alone or in combination of the circuit tracing process using the vertex types as described in . This circuit tracing process using vertex or vertices labels improves the identification process by eliminating any false identification of the subcircuits in Phase 1 . One aspect of the improvement is apparent from the fact that the circuit tracing using the vertex types in one embodiment does not differentiate between the Drain connected and Source connected nets. Hence there is a chance of misidentification when the pattern matches in all respect except that at least one of the devices has the Drain and Source connection reversed. The circuit tracing process using the vertex labels eliminate this possibility because if the Drain and Source are interchanged the node graph will probably also change and would lead to label mismatches. Also it may be noted that there can be true symmetries within a pattern either due to the source drain interchangeability or due to other structures. In such cases there are multiple different right ways to match up vertices with a true match in the main netlist. The phase 2 process as described herein in one embodiment will accept the first configuration it happens to come across. The mapping may end up different from what a human observer might have expected but it will be topologically equivalent.

With the above embodiments in mind it should be understood that the invention may employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

Any of the operations described herein that form part of the invention are useful machine operations. The invention also relates to a device or an apparatus for performing these operations. The apparatus may be specially constructed for the required purposes such as the carrier network discussed above or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The programming modules page modules and subsystems described in this document can be implemented using a programming language such as Flash Ruby JAVA C C C Visual Basic JAVA Script PHP XML HTML etc. or a combination of programming languages. Commonly available application programming interface API such as HTTP API XML API and parsers etc. are used in the implementation of the programming modules. As would be known to those skilled in the art that the components and functionality described above and elsewhere in this document may be implemented on any desktop operating system which provides a support for a display screen such as different versions of Microsoft Windows Apple Mac Unix X Windows Linux etc. using any programming language suitable for desktop software development.

The programming modules and ancillary software components including configuration file or files along with setup files required for performing the process of relabeling of the vertices and related functionality as described in this document are stored on a computer readable medium. Any computer medium such as a flash drive a CD ROM disk an optical disk a floppy disk a hard drive a shared drive and an storage suitable for providing downloads from connected computers could be used for storing the programming modules and ancillary software components. It would be known to a person skilled in the art that any storage medium could be used for storing these software components so long as the storage medium can be read by a computer system.

The invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a network.

The invention can also be embodied as computer readable code on a computer readable storage medium. The computer readable storage medium is any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable storage medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs DVDs Flash magnetic tapes and other optical and non optical data storage devices.

While this invention has been described in terms of several preferable embodiments it will be appreciated that those skilled in the art upon reading the specifications and studying the drawings will realize various alternation additions permutations and equivalents thereof. It is therefore intended that the present invention includes all such alterations additions permutations and equivalents as fall within the true spirit and scope of the invention.

