---

title: Multi-platform compatible portable virtual machine player
abstract: Systems and methods for detecting, selecting and running environments on a host device is provided. In general, in one aspect, a computer implemented method is provided. The computer implemented method includes detecting a device including a plurality of platform specific virtual machine monitors, identifying a virtual machine monitor that is compatible with a specified platform; and enabling a launch of the identified virtual machine monitor on the specified platform. In another aspect, a computer implemented method includes detecting a first device including one or more environments, launching an application on a second device, and using the application to collect a list of stacks, collect a list of environments, and determine environments capable of running on a stack. The method further includes receiving a selection of an environment and a stack, and running the selected environment on the selected stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589918&OS=08589918&RS=08589918
owner: Moka5, Inc.
number: 08589918
owner_city: Redwood City
owner_country: US
publication_date: 20080320
---
This application claims benefit under 35 U.S.C. 119 e of U.S. Patent Application No. 60 896 079 filed Mar. 21 2007 which is incorporated herein by reference.

A virtual machine VM is a software construct that appears to be hardware on which a guest operating system OS and applications can be installed. In an emulator implementation the virtual machine is an emulator simulating all of the hardware used by the guest operating system and applications. In para virtualization the virtual machine allows the guest operating system and applications to run on the host hardware but requires that the guest operating system be modified to use a special API application programming interface to run on the virtual machine monitor. In machine level or full virtualization the virtual machine allows a guest operating system that is implemented for the underlying host processor to be run without modification.

In a para virtualization or a machine level virtualization implementation a virtual machine monitor VMM is used to bind the virtual machine to the underlying host hardware. In some architectures the virtual machine monitor runs directly on the host hardware in a hypervisor configuration. In others it runs as an application on the host operating system. In some architectures a lightweight hypervisor is run between the host operating system and the host hardware that provides a calling interface for both the host operating system and the virtual machine monitors. In some architectures a hypervisor uses the services of a host operating system for device and other support.

Users would like to move software and data between devices. One way to do this is to place the software and data inside a VM and put the VM and VMM software on a portable storage media e.g. a Universal Serial Bus USB drive or other portable storage media which can be removably coupled to the device. Conventional approaches however are directed to a single VMM which can only run on one type of operating system e.g. Windows XP .

Additionally operating system or application level virtualization which generally virtualize at the operating system API boundary can be faster and less memory and CPU intensive than full virtual machine virtualization. However operating system or application level virtualization are not as portable as they require a compatible operating system at the host being visited.

In general in one aspect a computer implemented method is provided. The computer implemented method includes detecting device including a number of platform specific virtual machine monitors identifying a virtual machine monitor that is compatible with a specified platform and enabling a launch of the identified virtual machine monitor on the specified platform.

Implementations of the method computer program product and system can optionally include one or more of the following features. The step of enabling a launch can include presenting a representation of the identified virtual machine monitor to a user and receiving user input for launching the virtual machine monitor.

In general in another aspect a second computer implemented method is provided. The computer implemented method includes detecting a first device the first device including one or more environments launching an application on a second device using the application to collect a list of one or more stacks the one or more stacks on the list being located on either the first device or on the second device and being capable of running on the second device using the application to collect a list of all environments located on either the first device or on the second device using the application to determine which environments are capable of running on a stack from the list of one or more stacks receiving a selection of an environment capable of running on a stack from the list of one or more stacks receiving a selection of a stack from the list of one or more stacks and running the selected environment on the selected stack.

Implementations of the method computer program product and system can optionally include one or more of the following features. The step of receiving a selection of a stack can include the application automatically selecting a stack and then collecting a list of all environments capable of running on the selected stack. The first device is a portable device and the second device is a host device. Additionally the stacks can include VMM stacks and OS API stacks. Additionally when a VMM stack is selected a VM can mount the selected environment.

In general in another aspect a third computer implemented method is provided. The computer implemented method includes running one or more environments located on a device each environment being operable to run on two or more stacks located on the device the two or more stacks including at least one bootable stack and at least one non bootable stack.

Implementations of the method computer program product and system can optionally include one or more of the following features. The device is a peripheral device.

Particular embodiments of the subject matter described in this specification can be implemented to realize on or more of the following advantages. A hardware level virtual machine can be introduced to run a compatible operating system OS for maximum compatibility. For example if the host contains an operating system compatible with the OS API level virtualization layer then the system may run just the layer on the OS and the virtualized software on top of the layer. If the host runs an incompatible operating system the system may run a virtual machine monitor which runs a VM with a compatible host operating system which then runs virtualization layer and ultimately the virtualized software. Additionally by running the software in a VM the host is assured that the virtualized software will not interfere with host s operation.

The disclosed implementations allow software applications and or data stored on a single peripheral device e.g. a portable storage media to be used on multiple incompatible platforms e.g. devices with different native operating systems OSs . In some implementations this can be accomplished by bundling multiple VMMs onto a peripheral device coupling the peripheral device to a host device and automatically launching a compatible VMM monitor on the host device. In other implementations a VMM representation e.g. icon can be presented to the user to select and launch a compatible VMM monitor on the host device. As used herein the term compatible means compatible with the native host OS.

Peripheral device can be any device capable of communicating with another device. In some implementations peripheral device e.g. multi platform compatible VM player can be coupled to host device e.g. computer mobile phone game console set top box etc. . To facilitate coupling with host device peripheral device can include a connector or wireless transceiver e.g. Firewire Ethernet USB interface or USB wireless interface that allows the peripheral device to interface with host device . For example peripheral device can include a peripheral interface connector . The peripheral interface connector can be operable for coupling to a host device and capable of supporting data transfers to and from host device .

Examples of peripheral devices can include but are not limited to portable storage devices game controllers headsets webcams optical media drives musical instruments keyboards mice microphones television tuners digital cameras video cameras stereo receivers audio receivers cellular phones and any other device utilizing cellular technology scanners headphones printers personal health monitors and any other health related monitoring apparatus and PIN pads.

In some implementations the storage medium in peripheral device can contain one or more VMs. A VM can include an operating environment application software e.g. peripheral device specific software configuration settings user data code libraries or device drivers capable of providing the user with the ability to use the device for a particular use case. A different VM can exist and be run on each host device based on the host device architecture e.g. a cell phone version of the VM for a cell phone architecture or personal computer version of the VM for a personal computer architecture .

Host device can be any device capable of communicating with another device such as peripheral device . Examples of a host device can include but are not limited to personal computers personal digital assistants cellular telephones media player recorder television set top box game console and tablets. Host device can include a peripheral interface connector or wireless transceiver e.g. Firewire Ethernet USB interface or USB wireless interface capable of supporting data transfers to and from peripheral device . Host device can also include system software e.g. Windows XP or modern PC BIOS capable of accessing data storage exposed over the peripheral interface .

In some implementations host device can include software that can automatically launch e.g. by default a designated or selected e.g. by the system or the user computer program e.g. Windows XP autorun function from peripheral device storage . Additionally in some implementations host device can include a network connection e.g. DSL cable dialup LAN VPN cellular or WiFi to enable features of the platform software e.g. acquiring updates acquiring remote user data or exposing device functionalities to other devices accessible using the network connection .

Host device can also include a processor e.g. an x86 processor in a Dell computer and one of more user input devices e.g. a keyboard mouse or touchpad . The processor can be coupled to the peripheral interface and the processor can be operable to run a native environment. Host device can include a storage for storing instructions which when executed by the processor cause the processor to perform certain operations e.g. launching a virtual machine monitor . The storage in host device can also include an operating system . In some implementations the platform software to run a virtual machine e.g. a virtual machine monitor can be pre installed on host device . In some implementations the platform software can include components e.g. code capable of checking e.g. scanning host device e.g. for host device characteristics and capabilities and selecting available software e.g. a VM environment on peripheral device that is compatible with host device .

Referring to the storage medium on peripheral device includes one or more VMMs e.g. VMMs and one or more configuration files e.g. configuration files and and one or more VMs VMs and . In some implementations storage medium contains a file system containing one or more of the VMMs and along with the corresponding program files and settings for one or more of the VMMs or . The file system can also contain one or more of the VMs or . The VMs and can contain the programs settings and data of the user. In some implementations storage medium can contain more than one file system as will be discussed in greater detail below with respect to the multiple partitions in .

The configuration files can be interpreted by the OS of the host device so that when the user attaches the peripheral device containing storage medium to host device a VMM that is compatible with the host device e.g. VMM or is automatically launched and or highlighted in a user interface or other display of the device allowing the user to select and or launch a compatible VMM. For example a host OS can look for specific files e.g. specific filenames or extensions in order to use the peripheral device or to control the presentation of the VMMs or . In some implementations different types of operating systems can look for different files.

In some implementations when the VMMs e.g. QEMU for Windows and QEMU for Mac OS X are installed onto a peripheral device one or more configuration files e.g. one for each platform are created for instructing the host OS to identify a compatible VMM on the storage media and to present an icon or other user interface element to the user that corresponds to a compatible VMM. The icon or other user interface element can be prominently or conspicuously presented to the user. For example a large icon can be presented in a window or other display that identifies a compatible VMM while icons for incompatible VMMs can be hidden from the user. In some implementations on Windows an autorun.inf file can be used to automatically run a Windows compatible VMM on the host device or to add a launch instruction to a list of potential actions that are related to peripheral device and that can be performed by the host OS. The format for a Windows autorun.inf file can be found in publicly available documents provided by Microsoft Corporation Redmond Wash. . A sample autorun.inf file can include the following instructions 

In some implementations on Mac OS X one or more files e.g. a hidden .DS Store file can be used to control the presentation of a folder or other element on peripheral device in the Finder. For example a large icon for the Mac OS compatible VMM can be placed in the folder and optionally highlighted by a background that identifies the Mac OS compatible VMM. The one or more files can be created by changing the background and icon positions in a folder in the Finder such that it is apparent to the user which icon the author wishes the user to click on. A copy of the hidden files can then be saved in that directory or in another storage location. VMMs that are compatible with other platforms can be similarly implemented as described above.

Alternatively in some implementations e.g. on a Windows host device the system can automatically launch and present to the user a user interface which can include a window displaying a list of compatible VMMs for Windows . Alternatively the user can be presented with a user interface or a window containing a list of options for operating the host device e.g. the option of launching a Windows compatible VMM . In some implementations input is received from the user specifying a compatible VMM. For example the list of options for operating the host device can include one or more icons corresponding to VMMs that are compatible with the host OS. The user can click on an icon or other user interface element in the list of options corresponding to a compatible VMM to initiate a launch of the compatible VMM. The compatible VMM is then launched in response to the received user input.

On a Mac OS X host device when a peripheral device is attached to a host device an icon representing the peripheral device can appear e.g. on the user s desktop in a folder representing the storage on the peripheral device . User input can then be received e.g. the user can click on the icon related to the peripheral device attached to the host device . Clicking on the icon can cause one or more other icons representing VMMs on the peripheral device that are compatible with the Mac OS X host device to appear. The user can then launch the compatible VMM e.g. by clicking on an icon representing a compatible VMM .

The method begins when a peripheral device including one or more environments is attached to a host device. When the peripheral device is attached to the host device the host device will detect the presence of the peripheral device and the host device can automatically launch an application such as deciders or . For example the host device can launch an application e.g. deciders and if the application is suitable to run on the host device e.g. compatible with the host device OS . In some implementations the system can present an icon to the user e.g. an icon representing a peripheral device which contains system . The user can interact with the icon e.g. click on or roll over the icon which can cause the system on the host device to run an application e.g. a decider suitable to run on the host device . Deciders and are software that can determine which stack to use e.g. an OS API stack or a VMM stack when the decider or is automatically launched or when an indication is made e.g. by the user to start an environment on the host device.

The OS API stack can include a virtualization layer and environment . An OS API stack compatible with the host OS can run on host OS . The host operating system can be any operating system e.g. Microsoft Windows XP Vista Windows CE Linux or Mac OS X capable of supporting a virtualization layer. The virtualization layer can be any OS API level virtualization layer e.g. Mojopac Ceedo Thinstall Altris SVS SWSoft Virtuozzo and Microsoft Softricity that is compatible with host operating system . The environment can be any application system software or software environment supported by the virtualization layer . The environment can include several applications. The environment can run on top of virtualization layer . The environment can use functionalities exposed by the virtualization layer e.g. those simulating an isolated or distinct OS instance . If the applications in the environment are already written to be portable e.g. Firefox or any portable environment found at www.portableapps.com then the virtualization layer may not be needed and the applications can run directly on top of a host operating system or compatible operating system . After a peripheral device is attached to a host device in some implementations the environment can run on the host device and from the peripheral device without installing anything into the host device registry or file system.

The VMM stack can include a virtual machine and a virtual machine monitor . A VMM stack compatible with the host OS can run on host OS . The host OS can be any host operating system Microsoft Windows XP Vista Windows CE Linux or Mac OS X that supports VMM virtualization. The virtual machine can include a compatible operating system e.g. any operating system that runs inside a VMM such as Microsoft Windows XP Vista Windows CE Linux Mac OS X a virtualization layer and an environment . The virtualization layer can be the same software as virtualization layer or it can be different software that is compatible with the host OS . In some implementations parts of the virtualization layer and are stored in the same files on system . The VMM is any virtual machine monitor software VMware Player Parallels Client and KVM capable of running compatible operating system . As noted above in some implementations virtualization layer is not needed if the applications in environment are portable and can run directly on compatible operating system .

The system can contain multiple deciders e.g. deciders and . A decider can be coded to run on a specific host operating systems. For example decider can be coded to run on host OS and decider can be coded to run on host OS . System can include one or more VMM host stacks and one or more OS API stacks . In some implementations system is stored on a peripheral device e.g. mobile storage device . In some implementations system is stored on the host device. In some implementations one or more VMMs e.g. VMM can be stored on the peripheral device or on the host device or on both. In some implementations one or more virtualization layers can be stored on the peripheral device or on the host device or on both. In some implementations one or more deciders can be stored on the peripheral device or on the host device e.g. pre installed on the host device or on both. In some implementations one or more virtual machines without an environment can be stored on the peripheral device or on the host device or on both.

In some implementations the decider can examine the OS on the host device to determine whether the OS on the host device is compatible with a particular virtualization layer e.g. virtualization layer . In some implementations the decider can examine the OS on the host device to determine whether the OS on the host device will allow a particular virtualization layer e.g. virtualization layer to run on the host device. If the decider determines that no available virtualization layers will be allowed to run on the host device the decider can indicate an error to the initiator e.g. the user .

In some implementations the decider can examine the OS on the host device to determine whether the OS on the host device will allow a particular VMM e.g. virtual machine monitor to run on the host device. In some implementations the decider can examine the OS on the host device to determine whether a compatible VMM e.g. virtual machine monitor already exists on the host device. If the decider determines that no available VMMs are compatible with the OS on the host device the decider can indicate an error e.g. to the user . In other implementations if the decider determines that no available VMMs are compatible with the OS on the host device the decider can search e.g. the Internet for a VMM compatible with the OS on the host device. If the decider locates a compatible VMM the decider can download the compatible VMM and run it on the host device.

In some implementations the decider is hard coded to run a particular type of stack on the host device. For example the decider can be hard coded to recognize that the environment is Windows only but the decider is a Mac OS X application e.g. the decider can be wired to run a Mac OS X compatible VMM stack . In these implementations the decider can determine which available environments can run on the particular type of stack e.g. the Mac OS X compatible VMM stack and automatically choose a particular environment to run on the particular stack. For example the decider can automatically choose the only available environment or the decider can automatically choose an environment previously chosen one or more times by the user.

In some implementations a decider or can first examine an environment to see whether a compatible stack exists on the host device or the peripheral device. In some implementations a decider e.g. decider or can present an environment to the user as a selectable environment. In some implementations a decider can indicate a selection of available environments to the user. The user can then choose a particular available environment to run on the particular stack. Once the user chooses an environment the chosen environment is run on the particular stack. In some implementations an environment can automatically run on the host device after the peripheral device is attached to the host device e.g. if the environment is the only environment on the peripheral device .

In some implementations the decider collects a list of one or more available stacks e.g. on the peripheral device the host device or both capable of running on the host device. Additionally the decider can collect a list of one or more available environments e.g. on the peripheral device the host device or both capable of running on the host device. In some implementations based on the list of one or more available stacks and the list of one or more available environments the decider can determine which environments can run given the available stacks. In some implementations a single environment can run on several different stacks depending on how the environment needs to be run. For example with a Windows portable environment one may have the option of using both OS level and VMM level virtualization to run the Windows portable environment. The user can then choose VMM level virtualization to run the Windows portable environment e.g. for more compatibility or security . Additionally the user can choose OS level virtualization e.g. to run the Windows portable environment for faster startup and better integration .

After the decider determines which environments can run given the available stacks an environment can be chosen. In these implementations the decider can automatically choose a particular environment to run on an available stack. In some implementations a decider can indicate e.g. using colors or shading to the user a selection of available environments and the user can choose an available environment. In some implementations once an environment is chosen a stack can be chosen by the decider or by the user. In other implementations the environment and the stack can be chosen concurrently e.g. when only one stack is available . In some implementations a stack can be chosen prior to the selection of an environment e.g. when the decider is hard coded to run a particular type of stack on the host device .

In some implementations for a given VMM stack the decider can query the host and see if a compatible VMM or virtualization layer of the appropriate version is pre installed and whether the user is allowed to run it. If so the decider can mark the VMM stack as available. If the VMM or virtualization layer is incompatible and precludes the installation of a compatible VMM or virtualization layer then the decider can mark the VMM stack as unavailable. If the user doesn t have sufficient privileges to initiate or install the VMM or virtualization layer then the decider can mark the VMM stack as unavailable. Some virtualization layers e.g. Thinstall and QEMU do not require administrator privileges to install and or run. In that case these checks can be avoided.

In one example the VMware Workstation 6 VMM requires administrator privileges to install and run on a computer. If the user does not have administrator privileges and the VMware Workstation VMM is not pre installed then the user will be unable to run a VMM stack based on the VMware workstation VMM. The decider can make this determination by examining the host device OS for an existing version of a VMware workstation VMM that is compatible with the VM in a particular VMM stack. If a compatible VMware workstation is already installed and the software policy of the host operating system allows the user to run it then the decider can mark the VMM stack as available. If not the decider can query the host device OS to see whether the current user has sufficient privileges to install a VMware workstation stack. If the user does have sufficient privileges then the decider can mark the VMM stack as available. In some implementations after the decider has marked each stack as available or unavailable the user can choose any available OS API stack or a VMM stack to run on the host device. In other implementations the decider can choose an available stack to run on the host device.

If a decider chooses a VMM stack then the virtual machine can be configured to mount environment . In some implementations mounting is accomplished by adding an additional virtual disk containing environment to virtual machine . In this case the virtualization layer should also support reading writing the virtual disk containing environment . In other implementations a network file system shared folders system e.g. VMware Workstation Shared Folders Virtual PC Shared Folders virtual CD media or other system may be used to mount environment by adding the files needed for environment into virtual machine . In this case virtualization layer or host operating system can read write the individual files of environment using standard OS file system calls. In some implementations after the virtual machine is configured to mount environment the decider can launch virtual machine . In some implementations after the virtual machine is configured to mount environment the virtual machine can be configured to automatically start virtualization layer and environment . In some implementations if virtual machine is already running additional environments can be mounted and or launched in the running virtual machine e.g. by sending a network request to a service running in the VMM stack that can examine mounted storage for additional environments and can launch the additional environments .

If a decider chooses an OS API stack then if a virtualization layer is not already running the decider can start a virtualization layer . The decider can then instruct the virtualization layer to run environment . In some implementations the decider can instruct the virtualization layer to resume running an environment e.g. if the environment was suspended .

The functions of the decider need not all reside in a single module or unit. For example there could be a plug in system that allows the decider to be extended to additional types of stacks after compile time. Additionally in some implementations the decider can invoke the VMM or the virtualization layer and the VMM or the virtualization layer can implement the checks that determine whether a stack can run on the host device. Once an environment is selected and a stack is selected the selected environment can be run on the selected stack.

In some implementations an environment can run a bootable stack e.g. a stack that is directly on the hardware of the host device . This can be implemented by booting the host device from a peripheral device containing a bootable stack and at least one environment. For example the user may trust the hardware of the host device and not trust the currently installed OS and software on the host device. Since the user trusts the hardware on the host device the user can allow the hardware to run the software e.g. a stack and an environment originating from the peripheral device. In some implementations the same environment can be accessed from either a stack running on the host operating system or from a second stack on the peripheral device when the second stack is capable of running on the host device. In some implementations the same environment can run on any compatible stack e.g. bootable or non bootable on the peripheral device. illustrates an example peripheral device e.g. a portable storage device including a first partition and a second partition . The first partition includes an environment and a second stack . The second partition includes a bootable stack .

In some implementations the software on peripheral device can run VMs as environments e.g. booted into a Linux stack or run on a Windows OS . The storage on peripheral device can be partitioned into a first partition e.g. a FAT32 partition and a second partition e.g. an ext3 partition . An environment e.g. a VM environment and a second stack e.g. a Windows based VMM stack such as QEmu or VMware Player can be placed on the first partition e.g. a FAT32 partition can be used for storing an environment because the FAT32 partition is easily accessible from either a Linux or Windows OS . A bootable stack e.g. a bootable Linux stack can be placed on the second partition . For example a boot loader can be installed on the peripheral device . The boot loader can be configured to boot the bootable stack e.g. the Linux stack on the second partition e.g. the ext3 partition . The bootable stack can be configured to mount the first partition e.g. a FAT32 partition . Once mounted on the first partition the bootable stack can then search for and start VMs found on the first partition .

In some implementations as noted above a Windows autorun feature can be configured e.g. by creating an AUTORUN.INF file to start an environment using a Windows based VMM stack. Depending on the host configuration the autorun file can facilitate user interaction with the VM environment. For example the autorun file can automatically launch a VM environment. In another example the autorun file can present a list of options including one or more VM environments. The list of options can also include one or more actions the user can implement using the peripheral device e.g. the option of launching a VM environment .

In one implementation after the user attaches a peripheral device to a host device e.g. by inserting the USB stick into the host device the user can start the host device or restart the host device if the host device is already running. The host device can present an option to the user for selecting a boot device e.g. by presenting an icon of the peripheral device to the user or by presenting a text menu at boot . The user can select the peripheral device e.g. the USB stick as the boot device. After the user selects the peripheral device as the boot device the BIOS can start a boot loader installed on the peripheral device and one or more environments e.g. a VM environment can be booted from the peripheral device. The boot loader can be configured to boot a bootable stack on the peripheral device. The bootable stack can be configured to mount a partition containing one or more environments and look for an environment to start. Once the bootable stack discovers an environment the bootable stack can start the environment on the host device.

In one implementation the BIOS can automatically boot off of the peripheral device. In another implementation the user can enter the BIOS configuration interface and change the boot order. In another implementation the user can select a device e.g. the host device or the peripheral device to boot from by activating a key at boot time. In yet another implementation the user can insert a CD or other bootable device capable of activating the boot loader on the peripheral device.

In some implementations if a Linux compatibility layer for Windows exists a Linux environment can run on the compatibility layer on Windows in one case and run in a bootable Linux stack in the another case. In some implementations there can be a single partition on the peripheral device. For example only one partition is needed if the bootable OS supports running from a first partition. In some implementations multiple stacks can exist on a first partition.

Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them.

The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard a pointing device e.g. a mouse or a trackball or a musical instrument including musical instrument data interface MIDI capabilities e.g. a musical keyboard by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specifics these should not be construed as limitations on the scope of the invention or of what may be claimed but rather as descriptions of features specific to particular embodiments of the invention. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results. Additionally the invention can be embodied in a purpose built device.

