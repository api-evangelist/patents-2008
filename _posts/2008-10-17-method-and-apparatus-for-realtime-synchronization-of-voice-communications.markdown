---

title: Method and apparatus for real-time synchronization of voice communications
abstract: A method and system for synchronizing in real-time the voice media of a conversation conducted over a network between a first communication device and a second communication. The method includes at each of the first and second communication devices progressively storing in first and second storage elements and transmitting the voice media created using the first and second communication devices to the other communication device respectively. Both the first and second communication devices store in the first and second storage elements the progressively received media from the other device respectively. A mechanism to continually review, ascertain and request the media stored in the first storage element, but not the second storage element, and vice-versa is provided to ensure that the two storage elements contain the same voice media. As a result, the first and second storage elements each maintain real-time synchronized copies of the voice media of the conversation respectively.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08699383&OS=08699383&RS=08699383
owner: Voxer IP LLC
number: 08699383
owner_city: San Francisco
owner_country: US
publication_date: 20081017
---
This application claims the benefit of priority to U.S. Provisional Patent Application No. 60 999 619 filed on Oct. 19 2007 entitled Telecommunication and Multimedia Management System and Method and U.S. Provisional Patent Application 61 093 278 filed Aug. 29 2008 entitled Method and Apparatus for Near Real Time Synchronization Of Voice Communications. This application is also a continuation in part of U.S. patent application Ser. No. 12 028 400 filed Feb. 8 2008 entitled Telecommunication and Multimedia Management Method and Apparatus and is a continuation in part of U.S. application Ser. No. 12 192 890 filed Aug. 15 2008 entitled Telecommunication and Multimedia Management Method and Apparatus. Each of the above mentioned applications is incorporated herein by reference for all purposes.

This invention pertains to telecommunications and more particularly to a method and apparatus for the near real time synchronization of voice communications.

The current state of voice communications suffers from inertia. In spite of automated switching high bandwidth networks and technologies such as satellites fiber optics Voice over IP VoIP wireless and cellular networks there has been little change in how people use telephones. One is still required to pick up the phone dial another party wait for a connection to be made and then engage in a full duplex synchronous conversation with the dialed party. If the recipient does not answer no connection is made and the conversation does not take place.

At best a one way asynchronous voice message may be left if the recipient has voice mail. The process of delivering the voice mail however is burdensome and time consuming. The caller is required to wait for the phone on the other end to stop ringing transition into the voice mail system listen to a voice message greeting and then leave the message. Current voice mail systems are also inconvenient for the recipient. The recipient has to dial a code to access their voice mail navigate through a series of prompts listen to any earlier received voice messages in the queue and then finally listen to the message of the sender.

Another drawback with typical voice mail systems is the inability to organize or permanently archive voice messages. With some voice mail systems a user may save a message but it is automatically deleted after a predetermined period of time and lost forever.

Yet another problem with current voice mail systems is that a connection must be made between the caller and the voice mail system before a message can be left. If no connection is made there is no way for the caller to leave a message.

Current telephone systems are based on relatively simplistic usage patterns real time live calls or disjointed voice mail messages which are typically deleted as they are heard. These forms of voice communications do not capture the real power that can be achieved with voice communication or take advantage of the advances of network speed and bandwidth that is now available. Also if the phone network is down or is inaccessible e.g. a cell phone user is in an area of no coverage or the phone lines are down due to bad weather no communication can take place.

In general telephone based communications have not kept pace with the advances in text based communications. Instant messaging emailing faxing chat groups and the ability to archive text messages are all commonplace with text based communications. Other than voice mail there are few existing tools available to manage and or archive voice messages. In comparison the tools currently available to manage telephone communications are primitive compared to text communications.

The corporate environment provides just one example of the weakness in current voice communication tools. There is currently no integrated way to manage voice communications across an organization as a corporate asset. Employees generally do not record or persistently store their phone conversations. Most business related voice communication assets are gone as quickly as the words are spoken with no way to manage or store the content of those conversations in any manageable form.

As an illustrative example consider a sales executive at a company. During the course of a busy day the executive may make a number of calls and close several sales with customers over the phone. Without the ability to organize store and later retrieve these conversations there is no way for the executive to resolve potential issues that may arise such as recalling the terms of one deal versus another or challenging a customer who disputes the terms of a previously agreed upon sale. If this executive had the ability to easily retrieve and review conversations these types of issues could be easily and favorably resolved.

Current tactical radio systems such as those used by the military fire police paramedics rescue teams and first responders also suffer from a number of deficiencies. Most tactical radio communication must occur through a live radio connection between the sender of a message and a recipient. If there is no radio connection between the two parties there can be no communication. Urgent messages cannot be sent if either the sender or the receiver does not have access to their radio or a radio circuit connection is not established. Tactical communications are therefore plagued with several basic problems. There is no way i to guarantee the delivery of messages ii for a recipient to go back and listen to a message that was not heard in real time iii to control the granularity of the participants in a conversation iv for the system to cope when there is a lack of signal integrity for a live conversation. If a message is not heard live it is missed. There are no tools for either the sender or a recipient to manage prioritize archive and later retrieve i.e. time shift the messages of a conversation that were previously sent.

Yet another drawback with tactical radio communication systems is that only one message can be sent at a time per channel. Consider an example of a large building fire where multiple teams of fire fighters police and paramedics are simultaneously rescuing victims trapped in the building fighting the fire providing medical aid to victims and controlling bystanders. If each of the teams is using the same channel communications may become crowded and chaotic. Transmissions get stepped on when more than one person is transmitting at the same time. Also there is no way to differentiate between high and low priority messages. A team inside the burning building fighting the fire or rescuing trapped victims should have a higher priority over other teams such as those controlling bystanders. If high priority messages are stepped on by lower priority messages it could not only hamper important communications but could endanger the lives of the fire fighters and victims in the building.

One possible solution to the lack of ability to prioritize messages is to use multiple channels where each team is assigned a different channel. This solution however creates its own set of problems. How does the fire chief determine which channel to listen too at any point in time How do multiple teams communicate with one another if they are all on different channels If one team calls for urgent help how are other teams to know if they are listening to other channels While multiple channels can alleviate some issues it can also cause confusion creating more problems than if a single channel is used.

The lack of management tools that effectively prioritize messages that allow multiple conversations to take place at the same time that enable the time shifting of messages to guarantee delivery or that support archiving and storing conversations for later retrieval and review all contribute to the problems associated with tactical radios. In first responder situations such as with the military police and fire effective communication tools can literally mean the difference between life and death or the success or failure of a mission. The above burning building example is useful in illustrating just some of the issues with current tactical radio communications. Similar problems exist with the military police first responders and others who use tactical communications.

With packet based networks commonly used protocols include Transmission Control Protocol TCP and User Datagram Protocol UDP . UDP offers the advantage of fast delivery of data but at the expense of completeness. Packets may be dropped in transit and not available when attempting to render the data as soon as possible at the destination. In spite of the shortcomings UDP is the standard for Voice over Internet Protocol VoIP transmissions due to its speed attributes. On the other hand TCP does guarantee the delivery of perfect i.e. an exact copy of the transmitted data data but at the expense of latency. All packets are delivered regardless of how long it takes. This delay makes TCP impractical for use with live phone calls. Currently there are no known protocols that offer the performance advantages of both TCP and UDP where good enough media can be transmitted for rendering as soon as possible with the eventual delivery of a perfect copy of the media. Also there is no protocol that determines how much information should be sent over the network based on the presence of recipients on the network and their intentions to render the data either live or in a time shifted mode. In addition other factors commonly considered such as network latency network degradation packet loss packet damage and general bandwidth conditions are used in determining how much data to transmit. Prior art systems however do not consider the presence and intentions of recipients. As a result the default assumption is that the data is rendered by the recipient in real time. When a recipient is not going to render data immediately these prior art systems unnecessarily use bandwidth when it is not needed degrading the overall performance of the network.

For the reasons recited above telephone voicemail and tactical voice communications systems are inadequate. An improved voice and media communication and management system and method and improvements in delivering voice and other media over packet based networks including the near real time synchronization of the storage of voice and other media at both the sending and receiving communication devices and along each hop on the network between the two communication devices is therefore needed.

The present invention is directed to a method and system for synchronizing in real time the voice media of a conversation conducted over a network between a first communication device and a second communication. The method includes at each of the first and second communication devices progressively storing in first and second storage elements and transmitting the voice media created using the first and second communication devices to the other communication device respectively. Both the first and second communication devices store in the first and second storage elements the progressively received media from the other device respectively. A mechanism to continually review ascertain and request the media stored in the first storage element but not the second storage element and vice versa is provided to ensure that the two storage elements contain the same voice media. As a result the first and second storage elements each maintain real time synchronized copies of the voice media of the conversation respectively.

The invention will now be described in detail with reference to various embodiments thereof as illustrated in the accompanying drawings. In the following description specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without using some of the implementation details set forth herein. It should also be understood that well known operations have not been described in detail in order to not unnecessarily obscure the invention.

The communication media management method and system supports new modes of engaging in voice conversations and or managing multiple simultaneous conversations using a variety of media types such as voice video text location sensor information and other data. Users can engage in conversations by sending voice messages to designated recipients. Depending on preferences and priorities the recipient s might participate in the conversation in real time or they might simply be notified that the message is ready for retrieval. In the latter case the recipient participates in the conversation in a time shifted mode by reviewing and replying to the recorded message at their convenience.

Users are empowered to conduct communications in either i a near synchronous or live conversation providing a user experience similar to a standard full duplex phone call or ii in a series of back and forth time delayed transmissions i.e. time shifted mode . Further users engaged in a conversation can seamlessly transition from the live mode to the time shifted mode and back again. This attribute also makes it possible for users to engage in multiple conversations at the same time by prioritizing and shifting between the two modes for each conversation. Two individuals using the system can therefore send recorded voice messages back and forth to each other and review the messages when convenient or the messages can be sent at a rate where they essentially merge into a live synchronous voice conversation. This new form of communication for the purposes of the present application is referred to as Voxing 

When you Vox someone the conversation consists of a series of discrete recorded messages which are recorded in a number of locations which may include the encoding device of the sender e.g. a phone or computer servers on multiple transmission hops across the network and the receiver s rendering device. Unlike a standard phone call or voice mail the system provides the following features and advantages i the conversation can transition between live and time shifted or vice versa ii the discrete messages of the conversation are semantically threaded together and archived iii since the messages are recorded and are available for later retrieval attention can be temporarily diverted from the conversation and then the conversation can be later reviewed when convenient iv the conversation can be paused for seconds minutes hours or even days and can be picked up again where left off v one can rejoin a conversation in progress and rapidly review missed messages and catch up to the current message i.e. the live message vi no dedicated circuit is needed for the conversation to take place as required with conventional phone calls and vii lastly to initiate a conversation one can simply begin transmitting to an individual or a group. If the person or persons on the other end notice that they are receiving a message they have the option of reviewing and conducting a conversation in real time or reviewing at a later time of their choice.

The communication media management system also supports new modes of optimizing the transmission of data over a network. The system actively manages the delivery of payloads to a recipient engaged in a conversation in real time when network conditions are less than ideal. For example when network conditions are poor the system intentionally reduces the quality of the data for transmission to the point where it is good enough to be rendered upon receipt by the recipient allowing the real time participation of the conversation. The system also guarantees the eventual delivery of an exact copy of the messages over time. The system and method therefore provides the advantages of both speed and accuracy. The utilization of network bandwidth is optimized by making tradeoffs between timeliness and media quality using the presence and intentions of whether or not recipient s intend to review to the message immediately in real time as well as measures of network latency network degradation packet loss or damage and or current bandwidth conditions.

It should be noted that the messages of conversations may contain voice only or voice video and other data such as sensor information. When the messages are reviewed they are listened to or visually reviewed or a combination thereof depending on the type of media contained in the messages. Although as of the filing of the present application most conversations are voice only it is intended that the communication system and method described herein broadly includes conversations including multiple media types such as voice and video for example.

An improved voice and other media communication and management system and method is disclosed which provides one or more of the following features and functions 

In various embodiments some or all of the numerous features and functions listed above may be implemented. It should be understood however that different embodiments of the invention need not incorporate all of the above listed features and functions.

Prior to explaining the details of the invention it is useful to define some of the terms and acronyms used throughout the written description. This glossary of terms is organized into groups of System Components Media Media Management People and Conversation Management.

Client A Client is the user application in the communication system which includes a user interface persistent data storage and Voxing functionality. Users interact with the Client application and the Client application manages all communications messages and signals and payload Media transfers that are transmitted or received over a network. The Client supports encoding of media e.g. the capturing of voice video or other data content and the rendering of media and supports security encryption and authentication as well as the optimization of the transmission of data across the network. A Client may be used by one or multiple Users i.e. multi tenant .

Device A physical device that runs the Client application. A User may be actively logged into a single Device or multiple Devices at any given point of time. In various embodiments a Device may be a general purpose computer a portable computing device a programmable phone a programmable radio or any other programmable communication device.

Servers A computer node on the communication network. Servers are responsible for routing Messages sent back and forth between Users over the network and the persistent storage and archiving of Media payloads. Servers provide routing transcoding security encryption and authentication and the optimization of the transmission of data across the network.

Message An individual unit of communication from one User to another. Each Message consists of some sort of Media such as voice or video. Each Message is assigned certain attributes including i the User sending the message ii the Conversation it belongs to iii an optional or user created Importance Tag iv a time stamp and v the Media payload.

Conversation A thread of Messages identified persistently stored grouped and prioritized between two or more Users on their Devices. Users generally participate in a Conversation using their Devices by either Reviewing Messages in real time or in a time shifted mode or creating and sending Messages of a Conversation as desired. When new Messages are created they either define a new Conversation or they are added to an existing Conversation.

Head of a Conversation The most recent Message of a conversation that has been encoded by the most recent speaker. It is where a User is positioned in a Conversation when reviewing live or where one jumps to if the Jump To Live feature is used.

Multiple Conversation Management System or MCMS An application that runs as part of a Client application which enables a User to engage in multiple Conversations using a variety of Media types. With the MCMS application a User selects one Conversation among the multiple Conversations as current where only the Messages of current conversation are rendered. For the selected current Conversation the User may transition from a series of back and forth Messages in time shifted mode to near synchronous live mode similar to a standard telephone conversation and back again. The Messages of the non selected Conversations are in a paused state. Messages associated with the non selected Conversion will accumulate if others are still participating in those Conversations. The User may selectively transition the current Conversation among the multiple Conversations and Review the accumulated Messages of the selected current Conversation.

Multiple Conversation Management System Consecutive or MCMS C Similar to MCMS with the added feature of rendering and enabling Users to manage and participate in multiple Conversations consecutively through a hierarchical system of Priorities and time shifting which are automatically managed by the system. The MCMS C application allows the Messages of consecutive Conversations to be rendered in a prioritized order as opposed to MCMS where only the Messages of the currently selected Conversation are rendered. MCMS C is particularly applicable in situations where it is important that the Messages of the consecutive Conversations are rendered in the prioritized order and or the receipt of all Messages even those belonging to lower priority Conversations is more important than receiving the Messages in real time. Examples of situations where MCMS C may be suitable include but are not limited to hospitals taxi fleet management or tactical communications.

Multiple Conversation Management System Simultaneous or MCMS S Similar to MCMS with the added feature of enabling With MCMS S multiple Conversations are selected for simultaneous rendering as opposed to MCMS where the Messages of only the selected current Conversation are rendered. The MCMS S application is particularly applicable in situations where a User is listening to multiple Conversations at the same time such as a trader listening to multiple brokers on different exchanges and periodically sending trading requests to one or multiple of them simultaneously. MCMS S may also be suitable for tactical communications as well.

Priority The mechanism through which the system determines which Message to render next when a User is participating in MCMS C. Priority is automatically managed by the system. A User can set default Priorities or a predetermined set of system Priorities may be used. In the event of a conflict where more than one Message is ready to be rendered at the same time the system resolves the conflict at least partly based on Priority to determine what Message to render immediately and what Message to time shift.

Tags a set of attributes a User or the system may assign to a Conversation or a message such as a topic a company name a directive action items a indicator conversation summary or any other label by which one might want to search or organize the data.

Importance Tags A special Message attribute that enables a sender to specify when a Message is to be rendered regardless of other Priority settings. An urgent Importance tag will override other Priorities for example. This feature is critical for tactical systems though any system can be configured to use or disable this feature.

Packet Any unit of binary data capable of being routed through a computer network. Each packet consists of header meta data and payload media data . Includes standard packet protocols such as but not limited to Internet Protocol IP EvDO UMTS or any other packet based network either radio fiber optic or wired.

Header or Packet Header The portion of a packet that describes the packet the meta data concerning the payload its encoding type and destination.

Vox packet A proprietary packet that enables the system and method to further refine and optimize the delivery of Messages Media and other signaling information.

Time Shift Delay TSD The amount of time between the arrival of a Vox Packet and the rendering of the Packet on a Device. The TSD must exceed the Minimum Time Shift Delay. The TSD is typically determined by the User s behavior in choosing to review the Messages of a Conversation some time after receipt.

Minimum Time Shift Delay MTSD The time shift delay enforced by the Client to allow for jitter processing using jitter buffer techniques. This causes the system to delay rendering until an adequate number of the packets have arrived to create a usable media stream. The system will typically adaptively adjust the MTSD over time to compensate for variable conditions in the network.

Rendering Delivering a Media stream to a User in a form suitable for User consumption e.g. voice text graphic display video or a combination thereof .

Mixing The Rendering of one or more Media streams. For example the Media stream from two Participants of a Conversation may be Mixed when Rendered creating a User experience similar to a conversation where multiple people are speaking at the same time.

Encoding The process of translating Media either created by a User such as voice or video or otherwise originating on a Device such as GPS or other sensor data and converting the media into digital data to be processed by a Client.

Adaptive Jitter Buffer Jitter buffers or de jitter buffers are used to counter jitter i.e. either the arrival of out of sequence packets or the delayed arrival of packets introduced by packet switched networks so that the continuous rendering of audio or video signals transmitted over a network can be performed without disruption. The data is stored in a buffer before Rendering to allow a reasonably sized buffer of Media to arrive. The Media may be rendered before all the Packets are received trading off quality for currency. An Adaptive Jitter Buffer is capable of dynamically changing its size to optimize the delay quality tradeoff.

Persistent Infinite Message Buffer PIMB The PIMB is a storage management system for the storage of time based Media that performs both the de jittering of live data and the storage and retrieval of archive data. The PIMB further includes the additional attributes of potentially infinite and persistence storage of Media. The PIMB maintains exact or full copies of Vox Packets of a Message and Conversations at some or all Participant Devices and or Servers.

Packet Loss Compensation or Concealment PLC During Rendering of a Media stream the PLC component compensates for missing Packets interpolating the results to present the stream to a reviewer. Missing Packets may be rendered as silence or information from adjacent Packets may be used to present an interpolated sound or image. The particular method to be used will be dependent on the media Codecs in use and other generally known parameters.

Contact A record of either a User or non user of the system. Users typically engage in Conversations with members on their list of Contacts. A non user is a user that accesses or uses the system using a legacy phone radio or other non Client enabled device.

Group The association of multiple Contacts. Contacts may be selectively added or deleted from a Group. When a Conversation takes place among a Group all the members of the Group may or may not participate.

Channel Typically used for tactical communication systems. A Channel is similar to a Group in that it associates multiple Contacts with the Channel.

Participant A person who is identified as a member of a Conversation. Could be a User or a non User participant.

Time Shifting Time shifting is the ability to play any Message at any time after it has been received as determined by the User recipient. By Time Shifting a User may Review a Message i immediately on demand by Rendering immediately after the MTSD or ii time shifted in a mode of reviewing the Message upon the discretion of the User iii from the archive for searching reconstructions etc. of old Conversations iv after a delayed period of time to accommodate the Reviewing of other higher Priority Messages or Conversations that need to reviewed first v and or repeatedly if necessary for the Message to be reheard and understood. In other words Time Shifting is the ability of a user to render a Message at any time after the system imposed MTSD.

Reviewing Listening viewing reading or otherwise observing the Media content in Messages. Reviewing may take place in either a near synchronous real time live mode or the time shifted mode.

Intention Either i a User defined attribute capturing whether the User wants to Review the Messages of a Conversation either as soon as possible or Review the Messages in a time shifted mode ii implied by a User s behavior or a combination of i and ii .

Attention A user attribute capturing whether the User is Reviewing the Messages of a given Conversation at the moment.

Catch Up To Live CTL A rendering mode that allows a User who is not at the Head of a Conversation to Review previous Messages more quickly to Catch Up To Live i.e. the Head of the Conversation . The CTL feature may use any of a number of catch up techniques such as the faster replay of Messages the removal of gaps in the Media of the Messages removal of hesitation particles etc. When the User has caught up to live the system seamlessly flows into the live Conversation. This is a very useful feature with conference calls for example in situations where a User needs to temporarily shift their attention away from the Conversation but wishes to hear the entire Conversation upon their return.

Catch Up Mode A user configured or pre configured mode that determines how the CTL process will catch up i.e. replay faster remove silence and hesitation particles or a combination thereof .

Jump To Live JTL This feature allows a user to jump from their current position to the Head of a Conversation. A user will typically use the JTL feature when they do not want to Review all of the Messages between their current position in the Conversation and the Head. When the JTL feature is implemented the user skips over any intervening Messages and starts Rendering the live Messages at the head of the Conversation.

MCMS Participant Attributes A set of attributes either defined by a User interpreted by the system from the User s behaviors assigned by an administrator or a combination thereof which define the Intention Attention Priority and rendering preferences of a receiver for a given Conversation. The attributes include but are not limited to i the Intention of when a receiver would like to render to the Messages of the Conversation. Possible Intention values include now time shifted Catch Up To Live CTL paused and never ii Catch Up Mode which is a configuration setting which determines how the CTL process should catch the receiver up to live e.g. play faster skip silence gaps or hesitations or play at normal speed iii Time Shift Delay TSD which defines how far the receiver s current position in the conversation is from the Head of the Conversation and iv the Priority of the Message with regard to the receiver s other Conversations.

Referring to a block diagram of the telecommunication and media management system according to one embodiment of the invention is shown. The system includes a plurality of Clients through running on Devices through respectively. The Devices communicate with one another over a communication services network including one or more Servers . One or more networks through is provided to couple the plurality of Devices through to the communication services network . In various embodiments the networks may be the Public Switched Telephone Network PSTN a cellular network based on CDMA or GSM for example the Internet a tactical radio network or any other communication network or a combination thereof. The communication services network is a network layer on top of or otherwise in communication with the various networks through . In various embodiments the network layer is either heterogeneous or homogeneous. Clients through communicate with one another and with Servers over the networks through and network using individual message units referred to as Vox packets which are described in detail below.

Referring to a block diagram of a Client running on a Device is illustrated. As illustrated in the Client includes Multiple Conversation Management System MCMS application a rendering and encoding module and an MCMS applications database . As illustrated in the Client further includes a Store and Stream SAS module with a Persistent Infinite Message Buffer PIMB reader a PIMB writer PIMB database a data and network quality DNQS store and Media driver and encoder hardware . The MCMS application and the Store and Stream module communicate with one another through message handling modules and respectively. The Client further includes an authentication encryption security module and a communication protocol module .

The module provides authentication encryption and security services during the transmission and receipt of Vox packets to and from the Client . The communication protocol module encapsulates Vox packets into the native packets used by the underlying network connected to the Device running the Client when transmitting data and de encapsulating Vox packets from the native packets when receiving data. With the modules and multi party end to end authentication encryption and security is provided between Clients . Messages are authenticated encrypted and secured across the networks through and network from a first sending Device to second receiving Device .

The database stores and manages the persistent meta data for a number of entities in the system including Contacts and Participants Conversations and Messages live and stored and default Priorities and information regarding the Servers . In addition the MCMS database stores the moment to moment operational data of a User s Conversations presence and status as well as that of all the Participants conversing with the User or on the User s Contact list. For example with regard to Conversations and Messages the database keeps track of status information such as what Messages of a Conversation a User has or has not Reviewed Priorities and Catch Up To Live status for each Conversation in which the Client is a Participant the presence and status of all Participants and other network and other system management data.

MCMS application supports the different Voxing modes of engaging in conversations and or managing multiple conversations using a variety of media and data types voice video text location data etc. . Users engage in Conversations by sending Messages to designated recipients using their Client enabled Devices . Depending on preferences and Priorities the recipient might Review the Message in real time or they might simply be notified that the Message is ready for Reviewing. Users can transition from a series of back and forth Messages which are Reviewed in a time shifted or voice messaging mode or in a near synchronous full duplex conversation similar to standard live phone calls and then back to voice messaging again. The MCMS application allows a User to control their interactions with their most important Conversations in real time without missing any Messages in other ongoing Conversations. For example the MCMS application notifies a User of urgent or high priority communications from a Conversation that they are not currently Reviewing. MCMS application also enables all Messages from all Conversations to be stored for later retrieval so they can be reviewed at any time.

In accordance with various embodiments there are several different operational modes of the MCMS application including MCMS Consecutive MCMS C and MCMS Simultaneous MCMS S which support the consecutive and simultaneous rendering of Messages respectively. Each of these embodiments is described in more detail below. Unless specifically specified the term MCMS is intended to generally mean the MCMS application which includes the aforementioned different modes.

The MCMS application is a multi tiered architecture that includes a number of modules and services. The modules and services include the MCMS Database Module the SAS Services Module the Messaging and Signaling Services Module the User Interface Application Programming Interface API the User Interface Module the Conversations Messages Management Services the Priorities Services the Contacts Service the Presence Status Services and the Messages Signals Services

The MCMS database module is a service module that manages all function calls necessary for the MCMS application to access the MCMS database .

The SAS Services module includes a set of function calls that enable communication and coordination between the MCMS application and the Store and Stream module and which are passed back and forth through the message handling modules and respectively. The set of function calls enable both the MCMS application and the Store and Stream module to operate as necessary to implement the various Voxing functions when invoked by Users and or as dictated by network conditions. Some of the functionality performed by the SAS Services module includes maintaining and communicating the status of Message transmissions and Message acknowledgments the instructions for rendering of Messages and the status and presence of Users.

The Messaging and Signaling Services module runs on both Clients and Servers and enables communication between the Client and the Servers of the system . This communication which includes messages data and other signals allows the Client and the system to track and administer communications network status Users and User status. Types of messages and signals sent between the Message and Signaling Services modules running on the Clients and the Servers include for example network availability of Users tracking of Messages that the Server has sent to the Client possibly including a high water mark to determine if an entire message or some portion of a message is missing e.g. a sequence number per Participant per Conversation created by the generating Client whether a user is speaking or Reviewing Messages of a given Conversation where a User is with respect to the Head of a Conversation or when a Participant is no longer Reviewing a Conversation live. These are examples a few of the many types of messages and signals sent between the Message and Signaling Services modules on the Clients and Servers and in no way should be construed as limiting the invention.

The User Interface API is a module that defines a set of function calls that define the programming interface between the User Interface module and the underlying services of the MCMS application . The User Interface API supports general purpose methods such as UI application support and all function calls necessary for a User Interface to operate the MCMS Application . In various embodiments the User Interface API enables the Client to support a wide variety of user interfaces and device types such as Adobe Flash based and or Microsoft Windows applications cellular or mobile phone devices PSTN devices driven with tones a voice user interface VUI and physical radio communication interfaces. In various embodiments the User Interface API module enables the design of both highly flexible and highly constrained user interfaces to support the functionality of the MCMS application .

The MCMS User Interface module supports the operation and functions of the audio and video user interface of the Client . The User Interface module supports a host of user interactions and can be implemented with various interaction mediums such as an array of graphical user interface screens an Audio DTMF interface or voice user interface on the Device all of which enable a User to interface with the system . A partial list of User interactions that are supported include for example functions to log in manage join and monitor Conversations control Conversation rendering manage Priorities and requests to review archived Conversations. It should be noted that this list is exemplary and in no way should be construed as limiting the invention.

The Conversation Message management services is a module which defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for the User to manage the receipt and Review of transmitted and received Media e.g. voice or video content Messages between the participants of a Conversation. The Messages are organized into Conversations. Media that is sent or received by the Device running the application is available for immediate Review while being received. The received Media is also recorded for Review in a time shifted mode Conversation management and archival purposes. In an alternative embodiment Messages or Conversations can be optionally marked for transience specifying their desired retention requirements e.g. some Messages will not be retained or stored beyond the requirements for immediate rendering . In yet another embodiment Media can be optionally marked for review in a time shifted mode only and cannot be reviewed immediately upon receipt.

The Conversation Message management services further enables for each current or ongoing Conversation of the User the sending of Media to a receiving Client at any time and the receiving Client seamlessly associates these Messages with the appropriate Conversation regardless of the actions or inaction of the receiver.

With the Conversation Message management services all Conversations are essentially asynchronous. If two Users are actively engaged in a given Conversation and the User controlled delay between transmissions is minimal the experience will be one of a synchronous full duplex conversation as with current telephone or VoIP conversations. If either User delays their participation for whatever reason the Conversation drifts towards an asynchronous voice or other Media messaging experience. In alternative embodiments Conversations can be optionally Tagged as asynchronous Messages only or synchronous Messages only. In either of these cases the Conversation cannot drift between the two modes unless the Tag is reset. After the Tag is reset the Conversation again may flow between near synchronous i.e. live or real time and asynchronous i.e. time shifted or voice messaging modes.

The Conversation Message management service processes the transmission and receipt of Messages in a progressive fashion. When transmitting Media may be created while Messages are simultaneously encoded stored and transmitted. In other words the transmission of Messages may occur simultaneously with the generation of Media by the User i.e. while speaking into their Device or generating video . On the receiving side the receipt storage and Rendering of Messages also all occur progressively. Messages do not need to be completely received before they can be Rendered. The Rendering of Messages may occur at the same time Messages are being delivered right up to the MTSD. Further the service is also capable of the simultaneous transmission of outgoing Messages and Rendering of incoming Messages. The progressive nature of the service allows a User to be engaged in a live Conversation while storing and streaming the media of the Conversation for later retrieval and review as well other functions described herein.

The time shifting of Messages by the Conversation Message management services allows a User to Catch Up To Live on a Conversation if they missed earlier Messages or were involved in another Conversation. This time shifting process eliminates the need for Users to broadcast a request to their entire Group or Channel to have Messages repeated. Older Messages may be replayed at any time at potentially higher speeds to save time. Users may easily skip forward and backward through their Messages and within individual Messages. The Reviewing process may be configured on a Message Priority basis to potentially skip lower priority Messages.

In one embodiment the Conversation Message management service also identifies Messages by a specific Participant speaker and by default mixes Messages of a Conversation that were delivered at the same time MCMS S . In an optional embodiment a User could Review the transmissions of different Participant speakers of a Conversation separately.

The Conversation Message management module further allows Conversation sharing among Participants who can be added to an active or archived Conversation. In one embodiment an added Participant to a Conversation is provided access to the Conversation and has the ability to retrieve the previous Messages of the Conversation for Review. In an alternative embodiment the added Participant is provided access to the Messages of the Conversation only from the point where the new Participant joined and not any previous Messages of the Conversation.

The Conversation Message management module is also responsible for managing the functions used to control all rendering tasks performed by the Store and Stream module . These tasks include rendering Media i.e. voice video etc. appropriately for the Device running application . These rendering tasks include but are not limited to the rendering of Mixed Messages i.e. overlapping messages as well as rendering according to user defined criteria such as playing faster catching up to live removing silence removing hesitation particles frequency shifting and the ability to apply independent gain control to individual senders in a multi party conversation.

The Priority service is a module that defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for a User to manage the Priority of the consecutive Conversations i.e. MCMS C in which the User is engaged. When a User participates in a number of consecutive live Conversations the User is required to prioritize the Conversations. Issues arise when Messages of different Conversations are ready to be rendered at the same time. An algorithm is used to determine the order in which the Messages are rendered that considers the availability of Messages to be rendered and the Priorities set by the User. The algorithm determines that the available Messages with the highest priority are rendered first while any concurrently available Messages are time shifted automatically just enough to allow for the rendering of the higher priority Message. As rendering time becomes available the system will automatically render the time shifted messages according to the User s Priorities.

The Contacts services is a module that defines a set of functions that manage the data structures and processes responsible for managing and retaining all information needed for authenticating and associating one or more Contacts with Conversations. When sending a Message as part of a Conversation that is associated with a number of Contacts all of the Contacts receive the Message.

The Presence Status services is a module that defines a set of functions that maintain the data structures and processes responsible for managing and sharing presence and status information between certain Users and or non users of the system. In various embodiments the presence and status information is maintained for all User and non users engaged in the Conversations the User of the Client is engaged in all Users and non users in the Contacts list or Users within a predefined domain e.g. the members of a corporation or other organization . These examples are merely illustrative and should not be construed as limiting. The Presence Status services module may manage and share presence and status information on any defined set of Users and or non users.

The Presence Status service enables Users to monitor the status of other User s Intentions Attention and their Time Shift delay on any given Conversation i.e. how far back they are from Reviewing the Messages of the Conversation live . In one embodiment privacy controls are provided concerning availability of Presence and Status data. The Presence Status module further controls the data that enables the system to deliver Messages that match the behavior and Intentions of Users. For example a User may indicate their Status by designating an Intention to either Review or not Review a Conversation live. In response the Presence Status services issues commands that cause the rendering of Messages either live or time shifted in accordance with the Intention of the User. In addition the Intentions of Users are shared with the other Participants of the Conversation. The service is also capable of inferring other Status values from the User s behaviors. The Presence and Status information is also used to optimize network traffic and bandwidth as described in more detail below.

The Messages Signals services is a module that defines a set of functions that manage the data structures and processes responsible for messaging and signaling Users of the system using special messages or audible tones. The special messages or tones may include for example an indication if a Message or Messages are live or time shifted whom the Message s are from Priority and other factors. The Message Signal service further has the ability to i signal the presence or absence of Users on the network as well as the ability to notify if one or more Users are no longer actively Reviewing the Messages of a Conversation ii ring or otherwise notify another User to get their attention when they are paying attention to another Conversation or not paying attention to their Device at all iii leave a Message for Users currently not on the network to immediately review the Message the next time the individual re connects to the network iv generate an audible or visible feedback that alerts the sender that a sent Message was not received by recipient s generate a confirmation when the Message has been received by the recipient s and or a confirmation indicating when the Message has been Listened to by the recipient s and v implement a Priority scheme where individuals on a Conference or tactical call may be notified that their attention is immediately needed on the call. This indication may convey multiple levels of urgency and an acknowledgement of some kind by the recipient.

The rendering and encoding module is responsible for performing all rendering tasks for the MCMS application . These tasks include rendering Media appropriately for the device running application .

The Store and Stream module supports a number of functions and performance attributes which are described below.

With the Store and Stream module Message transmission is essentially full duplex enabling any party to send a Message at any time even while another party is also sending a Message or if the other party is unavailable or otherwise engaged. The Store and Stream module is able to render messages as in a live PSTN or VoIP call or deliver them for time shifted messaging modes. It is able to optimize transmission and control Rendering according to the desires of the User.

The Store and Stream module maintains connectivity with all target recipients e.g. Servers or other Devices on the underlying network manages all message signal and media transmissions and optimizes the delivery speed and bandwidth usage across the network to meet a User s immediate performance requirements while managing network quality and capacity. The module adapts and optimizes Media delivery commensurate with the quality and capacity of the underlying network . When insufficient underlying network resources are available the quality of the transmitted Media streams can be degraded. As bandwidth becomes available the quality of the transmitted Media streams may be increased. In addition to tradeoffs of Media quality the Store and Stream functionality can make tradeoffs in the amount of Media transmitted in each packet based on Users intentions to render data in real time as described below.

By dynamically controlling the delivery rate of Media based on the conditions of the underlying network the Store and Stream module is optimized to deliver time sensitive Media that is good enough to Render upon receipt and the guarantee eventual delivery of exact or full copies of the Media for archival purposes through a background process of requesting retransmission of missing low quality or damaged packets. As long as sufficient network resources exist to meet minimum Media quality levels this retransmission does not impede the Rendering of live call Media. The Clients of the system are thus designed to bridge the performance gap between the delivery of an exact or complete copy of the Media at the expense of substantial potential latency versus the quick delivery of Media but with no guarantees of completeness. In the context of this application the term good enough means that the quality of the Media is sufficient so that when it is rendered it is intelligible. The notion of good enough is therefore subjective and should not be construed in absolute terms. For example the quality level of certain Media to be good enough may vary depending on the type of Media circumstances and other factors.

The Store and Stream module further persistently stores all Media created by or otherwise originating using a Device or received over the network from other Device and or users. There are several significant advantages of storing this Media on the Device running the Client i it enables Users to leave a Message for another party even when the sender and or the recipient has either unavailable or poor network connectivity. In the case of insufficient bandwidth the Message will be transmitted as fast as available bandwidth can be effectively used. In the case of no connectivity the Message is queued for transmission as soon as network connectivity becomes available resulting in a time shifted delivery ii the User has the ability to pause replay fast forward and Catch Up To Live with an ongoing Conversation as well as retrieve and review the archived Messages of previous Conversations and iii it enables the optimization of data payloads over the system and improves system resilience against network bandwidth and connectivity problems that may occur from time to time.

The Store and Stream module is also responsible for Mixing Messages as appropriate to create overlapping Messages generated by the normal overlap of speakers in a Conversation or background noise simulating an actual Conversation where multiple parties are speaking rendering transcriptions or translations of audio media adjusting the rendering of Media according to a number of User defined criteria including playing faster removing silence gaps between spoken words removing hesitation particles and frequency shifting and the ability to apply independent gain control to individual senders in a multi party Conversation as well as other potential Rendering options.

The Persistent Infinite Message Buffer or PIMB is a set of indexed i.e. time stamped and sequentially numbered Media payload data structures and a system for their storage and retrieval. In one embodiment the data in the PIMB is arbitrarily persistent meaning it is available virtually forever or at least until the system runs out of storage. Various retention rates and strategies may be employed to make effective use of storage resources. Many possible implementations exist for the physical storage implementation of the PIMB including but not limited to RAM Flash memory hard drives optical media or some combination thereof. The PIMB is also infinite in size meaning the amount of data that can be stored in the PIMB is not inherently limited. This lack of limit is in comparison to existing jitter buffer technology that discards data as soon as it is rendered. In one specific embodiment the PIMB may be implemented using a small and relatively fast RAM cache memory coupled with a hard drive for persistent storage. As the physical storage capacity of the PIMB is exceeded the data is maintained on the Server as described below for later retrieval on demand. User criteria or a replacement algorithm such as least recently used or first in last out is used to control the actual data stored in the PIMB and the data that is maintained on the Server or archived at any point in time. The PIMB further provides the attributes of file system storage and the random access attributes of a database. Any number of Conversations regardless of their duration or the number of Messages in each may be stored and later retrieved for Review. In addition the meta data associated with the Messages of a Conversation such as its originator and its length may be also stored in the PIMB . In alternative embodiments the indexed Media payloads and other data can be stored for a designated period of time e.g. 30 days . Once the age of the media exceeds the designated period the payloads and data are discarded. In another embodiment payloads can be discarded based on the sender and or the recipient of the Message containing the payload or the topic of the Conversation or Messages associated with the payload. In yet other embodiments payloads and data may be marked for transience meaning the Messages will not be stored in the PIMB beyond the requirements for immediate Rendering.

The data and network quality store DNQS is a data store for storing information regarding Media payloads and Vox packets that are either read from or written to the PIMB .

The PIMB writer writes data to the PIMB for two basic purposes. The PIMB writer writes data from a Media capturing device e.g. a microphone or camera on the Device running the Client Encode Receive . The PIMB writer also writes data received over the network from other Clients into the PIMB Net Receive .

For capturing Media from the Device the PIMB writer includes Encoder Receiver and a Data Storer . When a User speaks into the microphone or generates video images with the Device for example the hardware receives the raw audio and or video signals and provides them to the Encoder Receiver which encodes the signals into indexed media payloads hereafter sometimes simply referred to as payload or payloads . The Data Store stores the payloads into the PIMB . Other types of Media such as sensor data is converted into payloads in a similar manner.

For storing Media received over the network into the PIMB the Net Receive function of PIMB writer includes a Network Receiver a Data Bufferer a Data Storer a Data Quality Manager and a Network Quality Manager . The Network Receiver receives Vox packets over the network . The Data Bufferer places the received Vox packets into their proper sequence and prevents the Rendering of the incoming Vox packets for at least the Minimum Time Shift Delay MTSD delay. The Data Storer transforms the packets into indexed media payloads and stores the indexed media payloads in the PIMB . As the payloads are stored the Data Quality Manager DQM notes any missing or defective packets. If packets are missing or defective the DQM schedules a request for retransmission over the network . The sending device replies by resending the missing or defective packets. Eventually these packets are converted into indexed media payloads and stored in the PIMB . By retrieving the missing or defective packets an exact copy of a sender s Message is eventually stored in the PIMB . The retransmission of missing and or defective packets does not delay the rendering of Messages in real time provided that the packets that have been delivered are of good enough quality and quantity. Retransmission requests may be delayed by the DQM if insufficient network resources are available to support both the new live data as well as the retransmission.

The PIMB reader reads data from the PIMB for two basic purposes. The PIMB reader accesses the PIMB when data is to be rendered Render for the local Client . Data is also read from the PIMB when data is to be transmitted Transmit by the Client over the network .

For the rendering of messages on the Client the PIMB reader includes a Data Prioritizer a Data Retriever a Packet Loss Compensation Interpolator PLC Interpolator a Data Mixer and a Data Renderer . The Prioritizer prioritizes the data to be rendered by building an ordered queue of messages that could potentially be Rendered. It uses User configured Priority for the rendering of consecutive Conversations MCMS C . In addition the Data Prioritizer uses the availability of media data to render within the limits imposed by the MTSD the User s current Attention and the User s defined and implied Intentions. The Data Retriever retrieves the prioritized indexed media payloads from the PIMB . The PLC Interpolator performs packet loss compensation and interpolation on the retrieved payloads using known packet loss compensation and interpolation algorithms. The particular method to be used is dependent on the media Codecs in use and other well known parameters. The Mixer is used to appropriately mix concurrent data streams from multiple Messages of a single Conversation together. For example if two or more Participants of a Conversation are speaking at the same time the Mixer mixes the Messages creating the effect of both Participants speaking at the same time. In an alternative embodiment the User has the option of Reviewing the multiple streams from one Participant at a time. If only one Participant in the Conversation is speaking the Mixer may simply pass the single Message stream without performing any mixing. The Renderer takes the data from the Mixer module and converts it into a form suitable for the hardware driver . The hardware then drives either the speaker or video display of the Device depending on the type of Media creating voice video or some other audible and or visible notifier on the Device .

To prepare messages for transmission from the Client over a network the PIMB reader includes a Data Prioritizer a Packet Quality Manager PQM a Data Retriever Packetizer a Transmitter and an Acknowledger . The Data Prioritizer prioritizes the Messages for transmission over the network . Priority is determined using the MCMS Participant Attributes related to payloads available for transmission network connectivity and bandwidth conditions and the Intentions of Users beyond the next hop to either Render live or time shifted and in some embodiments possible optimizations of transmission bundling where multiple packets to any given next network hop are available. The prioritized packets are then optimized using the PQM which assures the timely delivery of good enough data quality for live Messages while minimizing real time bandwidth as described in more detail below. The Data Retriever retrieves the appropriate payloads from the PIMB . The Packetizer assembles the payloads into Vox Packets which are then transmitted by the Transmitter module over the network . When the recipient receives the Vox packets an acknowledgement is sent back to Acknowledger over the network for notifying the sending User that a Message has arrived at its destination.

The PQM has several optimization goals i the timely delivery of an adequate copy of time sensitive Media as soon as possible to be good enough for Rendering ii the efficient use of available bandwidth meaning using the optimal transmission frequency payload quality and packet size for the underlying network and iii the ability to dynamically adjust or make changes in the transmission frequency payload content payload quality packet size etc. as network conditions change.

On the receiving side of a network transmission is the Network Quality Manager NQM . The NQM is responsible for observing specific properties of network performance for each sender that has sent media to the Client comparing expectations of jitter loss and throughput to their actual values. This is used to compute a Network Quality Rating NQR for every sender. This NQR is used to indicate sender availability and Conversation live ness to the User of the receiving device.

The Data Quality Manager measures the quality of the data being received over the network by observing packet loss jitter and throughput. The DQM uses these measurements for three purposes i to send receipt reports back to the sender ii optionally using those receipt reports to request retransmission of certain data and iii making these measurements available to the NQM

Referring to a block diagram of the application that runs on the Server s . The application is similar to the Client application in many regards and includes an MCMS server application an MCMS database a store and stream module a PIMB a data and network quality store DNQS MCMS SAS message handling modules and which manage messages and signals back and forth between the MCMS server application and Store and Stream module an archive retriever and an archive . The application further includes an authentication encryption security module and a communication protocol module .

The MCMS server application is a multi tiered architecture including a MCMS Database Module a Store and Stream SAS Module a Messaging Signaling Module Conversations Messages management services Priority services Contacts including User and Authentication services Presence Status service and Messages Signals services . The aforementioned modules and services of the application are similar or the same as the modules and services having like reference numerals as the Client and therefore are not described in detail herein except for one notable exception. In various embodiments the MCMS server application and Store and Stream module including the MCMS database is configured to support many Users in one instance of the application. The one instance may be further configured to support multiple domains where each domain is defined as a group of Users i.e. a corporation or other group of Users belonging to a common organization . This architecture allows each application on Server to serve multiple users or domains where each user or domain is not visible to other Users. This partitioning is referred to as multi tenancy .

The server Store and Steam module performs the functions of Net Receive and Transmit. For the Net Receive function the module includes a Net Receiver Data Bufferer a Data Storer a Data Quality Manager DQM and a Network Quality Manager . For Transmit functions the module includes a Data Prioritizer Packet Optimizer Data Retriever Packetizer Transmitter and an Acknowledger . The aforementioned elements of the Store and Stream module are similar or the same elements having like reference numerals as the Client and therefore are not described in detail herein.

Since the Server does not directly interact with Users the encoding and rendering functions provided in the Store and Stream module of the Clients need not be present. The MCMS application when running on Servers does not interact directly with Users. Consequently the user interface and user interface API modules and services and are not needed.

The application on each Server potentially serves multiple tenants meaning it serves multiple Users of the system . The PIMB of the server application is therefore significantly larger and is used to store the media payloads of multiple Users as opposed to the PIMB which is used to store just the generated or received payloads of only a single User. The main purpose of the Store and Stream module is to receive Messages transmitted by the Clients and transmit Messages to other Clients . As Messages are received they are stored in the PIMB and transmitted to the next Server i.e. the net hop of the network layer along the path to the intended recipient s or to the recipient s directly depending on the system configuration. The archive retriever is responsible for archiving the media payloads stored in the PIMB in archive . As the physical space in the PIMB is exhausted media payloads in the PIMB are moved to the archive which is a mass storage device. In various embodiments the payloads stored in the PIMB may be archived in accordance with User defined criteria and or any known replacement algorithm such as first in first out FIFO or least recently used LRU . It should be noted that only a single Server is illustrated in for simplicity. It should be understood that in actual embodiments multiple servers or a server farm may be used for a network with a large number of Users.

The terms persistent and infinite used to describe the PIMB and the PIMB should not be construed literally as absolute terms. A User may wish to indefinitely store some Messages that are considered important. In other situations such as a casual chat between two friends the Messages may be deleted after a certain period of time to save space. According to various embodiments of the invention different retention policies may be used either set by the system or configured by the User. The use of the word infinite refers to the lack of any preset time boundaries enforced by the PIMB. This is contrasted with current jitter buffer systems which discard media after it has been rendered. The terms persistent and infinite should therefore be broadly construed to mean that the PIMB and PIMB have no internal limitations on the time ranges and quantities of Messages that can be stored therein.

There are a number of advantages to archiving the Messages of Conversations in a persistent storage medium. Voice messages and other Media can be organized indexed searched transcribed translated and Reviewed as needed. Voice as well as other Media therefore becomes an asset that can be managed both by Users and organizations. These Media assets have value to corporations first responders police and fire departments as well as the military.

As noted above the Vox protocol is used by the Store and Stream module to support all facets of payload transmission storage and optimization. The Vox packet is a structured message format designed for encapsulation inside a transport packet or transport packets of the underlying technology of the network . This arrangement significantly improves the flexibility of the system . By embedding the Vox packets into existing transport packets as opposed to defining a new transport layer for Voxing applications the system takes advantage of current packet based communication networks running over the existing telecommunications infrastructure. A new network infrastructure for handling the Vox packets therefore need not be created to take advantage of all the benefits of the system and method described herein.

Referring to the general format structure of a Vox packet is illustrated. The format of the Vox packet includes fields for type sub type length and payload. The different types of Vox packets include authentication signaling media payload media multiplex one message and media multiplex multiple messages . The sub type field is used to designate different types of authentication signaling or media type messages. Possible sub types for authentication Messages include those necessary for key exchanges and Authentication. Possible sub types for signaling Messages include registration routing message set up and network management. Possible sub types for Media messages include different Codec styles and different payload aggregation techniques. The length field defines the overall length or size of the payload. The payload field contains the actual payload or media of the packet .

Referring to a diagram illustrating a Vox packet encapsulated in an exemplary protocol used by the network is shown. In this example the Vox packet is embedded in underlying UDP IP and Ethernet transport packets respectively. In this manner the Vox packet can be transported across underlying UDP IP and Ethernet layers of the network . This is a standard protocol encapsulation technique used by packet networks.

Referring to a diagram illustrating a media multiplex Vox packet encapsulated in UDP IP and Ethernet is illustrated. In this example the Vox packet includes a Media type field a Media sub type field a length field a message ID field a time stamp field a sequence ID field and a Media payload field.

Referring to the format of an indexed media payload is illustrated. The indexed media payload includes a sub type field a length field a message identifier ID field a time stamp field a sequence identifier ID field and field for the Media payload.

The encapsulation of Vox packets into the transport packets of the underlying network allows the Media Messages and Conversations to each be defined by a number of attributes.

When Media is created or otherwise originated on a Device it is typically time based meaning it changes in some meaningful way over time. As a person engages in a Conversation for example their spoken words are strung together into sentences or statements which vary over time and the resulting data streams and packets will maintain the same variance over time. Similarly video as opposed to a still photo as well as GPS or other sensor data will vary over time. Regardless of the type or how it is originated the Media is segmented and placed into the payloads of a plurality of Vox packets . The packets are then continually stored transmitted received stored and rendered in streams i.e. streaming media at the transmitting and receiving Devices respectively. Since each packet is indexed time stamped and given a sequence identifier the individual packets can be segmented into Messages. By sequentially threading the individual Messages together Conversations may be constructed.

One further unique aspect of the system is that the media payloads generated by a Client are stored in multiple locations. Not only are the payloads stored in the PIMB of the generating Device but also in the PIMB of the Server s and the PIMB of the receiving Devices . This basic feature enables or makes possible much of the Voxing functionality described above and provides the system with both resilience and operability even when network conditions are poor or when a Participant of a Conversation is not connected to the network.

The system is intended to run or be layered over a variety of existing communication networks such as the Internet fixed PSTN type circuit networks and mobile or cellular phone networks or a combination thereof. The system is designed around the concept of moving many small units of information i.e. the Vox packets between different Clients and Servers in the system . While Vox packets may vary in size depending on their function and payload they all appear to be the same kind of data to the underlying network layer. In one embodiment the system has been designed and optimized for IPv4 networks such as the Internet but other types of networks may be supported as well. For the purposes of this document the term IP should be taken to mean IPv4 IPv6 or any other current or future implementation of the Internet Protocol.

Referring to a diagram of a Client running on Device and communicating with a Server over a shared IP network is shown. As illustrated the Client is coupled to the shared IP network through a first Internet service provider A and the Server is coupled to the shared IP network by a second Internet service provider B. During communication the Vox packets designed VP in the figure are encapsulated within UDP IP packets and then interleaved among other IP protocol packets as is well known in the art and transmitted across the shared IP network from the Client to Server or vice versa. As is well known each lower packet layer encapsulates the entire packet of the layer immediately above it. Packets can also be sent in a similar manner between two Servers . Messages are sent from one Client enabled Device to another over a shared IP network . At each hop the Vox packets are embedded in the underlying IP protocol and transmitted until they reach the target destination.

The diagram of is merely exemplary showing only a single Client and Server connected to the network for the sake of illustration. In actual embodiments of the system a large number of Clients and one or more Servers are typically connected to the shared IP network . It is also useful to note that the Client and Server do not have exclusive use of the IP network . In the example shown an HTTP client which is coupled to the network through Internet provider A can send packets back and forth with an HTTP server coupled to the network through a third Internet provider C. The system does not control the manner in which the VPs embedded in the IP packets traverse the network . Rather all packets that traverse and share the network do so in accordance with the standard procedures of the underlying shared IP network .

Referring to a circuit based network such as a GSM mobile phone network is illustrated. The circuit network is coupled between Client running on Device and Server . Once a circuit is established between the Client and Server the system layers Vox packets VP1 VP2 VP3 VP4 VP5 etc. onto the underlying packets used by the network and transmits them across the network creating virtual Vox circuit. The Vox Packets sequentially traverse the circuit network typically with spacing or framing data as is well known in the art for transmitting data over a circuit network. In addition packet construction parameters such as the payload size and the number of header fields included may be used to exploit the lack of per packet overhead and to increase speed and or efficiency of data transfer across the network . It should be noted again that for the sake of simplicity only a single Client and Server are shown connected to the network . It should be understood however that additional circuits between Clients and Servers as well as other components may be established concurrently through the network . The network is therefore not dedicated for the transmission of Vox Packets but rather may be shared with other types of network traffic.

Referring to a diagram illustrating communication between a first Client A enabled Device A associated with a first network A and a second Client B enabled Device B associated with a second network B is illustrated. The networks A and B further each include gateway Servers A and B respectively. The Gateway Server pair A and B facilitate communication between the two networks A and B allowing the Devices A and B to communicate with each other. In various embodiments the networks A and B could each be any type of network. For example each network A and or B could be an IP network a circuit type network or a wireless or cellular network i.e. CDMA GSM TDMA etc. . The Servers that straddle the two networks A and B are considered gateway servers because they route traffic or serve as a gate between the two networks.

With the system there are a several basic network interaction considerations to optimize system performance. These considerations include factors such as resolving the underlying address to which the Vox packets are to be sent the integrity of any sent Vox packets and the management of the Maximum Transmission Unit MTU of a single Message that may be sent across a given network or combination of networks.

The address of a target Client needs to be known so that the underlying network delivers the Vox packet to the correct location. With IPv4 networks the address is typically an IPv4 Address which is a 32 bit number that uniquely identifies a host within the network. For other networking technologies the address could be some other type of identifier. IP networks use the Domain Name System DNS to resolve human readable names into IP addresses and the Address Resolution Protocol ARP to resolve IP addresses into physical addresses. Regardless of the underlying networking technology the system uses one of the above mentioned or other known addressing schemes for delivery of Vox packets to the correct location.

As with almost any packet based communication system transmitted Vox packets might not be delivered to their addressed location if the underlying network is unable to deliver the packets in which the Vox packets are encapsulated. Most packet networks do not inform transmitters when packets are dropped. Instead they rely on the transmitters and receivers to notice and compensate for any dropped packets. The system is designed to use these receiver receipt report messages to coordinate this packet loss management. If the underlying network is able to inform the sender of lost or dropped packets the system utilizes this information in its retransmission protocol.

The management of MTU is the determination of the Maximum Transmission Unit i.e. the maximum size of a single message that may be sent across a network. For packet based networks the underlying network imposes the MTU. For circuit switched networks the MTU may be a tunable parameter for network efficiency and performance. Thus in most cases the underlying network imposes or determines the maximum size of the Vox packet that may be transmitted efficiently. For example with IP networks packets may be fragmented if the payload exceeds the MTU but at a substantial performance penalty. With IP over Ethernet networks the transmitting device has an MTU of 1518 bytes as enforced by Ethernet. The largest IP packet must leave room for the Ethernet headers. The largest UDP packet must leave room for both IP and Ethernet headers and the largest Vox protocol that may be generated on Ethernet for example is the Ethernet MTU 1518 IP header 20 UDP header 8 1490 bytes. Since the Vox protocol will have a header of its own the actual Vox media payload will be less than 1490 bytes on an Ethernet network. For Gigabit Ethernet the MTU could be much larger but would be determined using a similar formula.

In a purely packet based network there are two potential values for MTU the local link MTU and the path MTU. Determining the local link MTU yields the maximum size for Vox packets to be efficiently sent out to the local network interface. The path MTU yields the maximum size of Vox packet that may be sent intact all the way to the remote node. If a sender is connected via Ethernet the Vox packet might pass through various other systems with smaller MTUs en route to the recipient. The smallest MTU on the path to the destination needs to be resolved and known by the sender. In the IP world there is a standard procedure for discovering the smallest MTU called Path MTU Discovery . For other kinds of networks an equivalent procedure may be used. Again since the system is layered on top of other networks any of the above MTU algorithms may be used.

Referring to a series of flow diagrams are provided to illustrate the operation of the store and stream module and on Clients and Servers respectively. shows the sequence of operation for a first Client transmitting Messages to a second Client . illustrate the operation of the PIMB writer and PIMB Reader on the transmitting Client . illustrate the operation of the PIMB Writer and PIMB Reader on the receiving Client . illustrates a flow diagram of the Store and Steam module on a server .

In the User of Client running on a Device originates Media to be transmitted. The Media can be originated at the Device in a number of different ways such the User creating Media by speaking into a microphone or creating video content on their Device . Media is also originated by a Device by receiving sensor data such a GPS information or a temperature reading. Regardless of how the Media is originated the Media is encoded by the PIMB Writer box which converts the Media into indexed media payloads and stores them in the PIMB box on Client . The PIMB Reader on the Client reads the payloads out of the PIMB creates Vox packets and transmits the packets to the receiving Client box over the network . Each Server along the path between the sending Client and the receiving Client stores the transmitted payloads in the PIMB and transmits the Vox packets to the next hop box . At the receiving Client the net receive function of the PIMB Writer converts the Vox packets into indexed media payloads box and stores the payloads into the PIMB of Client box . The rendering module of the PIMB reader on Client renders the payload information read from the PIMB into a medium suitable for human consumption such as voice or video box . Each of these steps are described in more detail below with respect to .

In a sequence of the Encode Receive function performed by the PIMB Writer step of is provided in detail. In the initial step the User of the Device running the Client originates the Media to be transmitted. As noted above the Media may be derived by speaking into a microphone using a camera receiving sensor data or by some other Media generating component. In the next step the Encode Receiver encodes the Media and creates the indexed media payloads step which are then stored in the PIMB step by the Data storer

In the sequence of the Transmit function performed by the PIMB Reader step of on the sending client is provided in detail. In decision loop the transmit function of the PIMB Reader continuously checks to see if indexed media payloads that are to be transmitted have been written into the PIMB and are available for transmission. If such payloads are available in the PIMB the Data Prioritizer prioritizes the payloads that should be sent first using the MCMS Participant Attributes information as illustrated in step . Information about the highest priority payloads are passed to the Packet Optimizer module which runs the PQM step as described in more detail below with respect to . The appropriate payloads are then retrieved from the PIMB step by the Data Retriever and converted into Vox packets by the Packetizer step . The Vox packets are then transmitted step by the Transmitter over the network to the receive Client which sends back receipt reports reflecting the properties loss jitter throughput of the packets that have been received. These receipt reports provide the information necessary for the PQM to calculate the MABR for a given receiver. The aforementioned process is repeated for each transmission loop as indicated by the return arrow from the transmit step to the top of the flow chart.

In the embodiment described above the media is encoded stored in the PIMB and then transmitted over the network in a serial fashion. In an alternative embodiment the encoded media can be stored in the PIMB and transmitted over the network in parallel meaning the two functions occur substantially at the same time.

In the sequence for the Net Receive function step of of the PIMB Writer on the receiving Client is illustrated. In the initial step the network receiver receives the Vox packets over the network . The Data Storer converts the packets into indexed media payloads step which are stored in the PIMB step . As the payloads are stored the Data Quality Manager DQM is run. The DQM checks for missing or corrupted packets ensures the eventually storage of an exact copy of the transmitted data and the sends receipt reports regarding the conditions of the network to the transmitter. Each of these functions of the DQM are described in more detail below with regard to .

In the sequence for the Render function of the PIMB Reader box of on the receive Client is illustrated. In the initial step the Data Prioritizer prioritizes the indexed media payloads to be rendered as determined by the MCMS application using the MTSD information as well as User status and presence information including the User s Intentions and Attention status. The prioritized payloads are then read from the PIMB step by the Data Retriever . The PLC Interpolator performs packet loss compensation and interpolation step on the retrieved payloads using known packet loss compensation and interpolation algorithms depending on which Codecs are used. In the next step the Mixer mixes step multiple Messages of a Conversation if two or more Participants have generated Media at the same time within the same Conversation e.g. both are speaking at the same time . The Renderer renders step the data stream from the Mixer generating sound video or other Media step for the recipient User.

In the sequence for a Server to receive Vox packets from the previous hop on the network store archive and transmit the Vox packets to the next hop is illustrated. In the initial step the Server performs the Net Receive function of the PIMB writer similar to to store the indexed media payloads of the received data in the PIMB and archive or the Server . The server also performs the Transmit function of the PIMB writer similar to to forward the received packets onto the next hop on the network . In this manner a copy of the media generated by the transmit Client is received stored and transmitted at each hop along the path to the receive Client .

In the aforementioned embodiment the writing of received indexed media is stored in the PIMB of the Server and transmitted to the next hop in a serial fashion. In an alternative embodiment the received indexed media payloads can be stored in the PIMB and transmitted to the next hop substantially at the same time. The storage of Media on the PIMB of both transmitting and receiving Devices allows for the progressive transmission and rendering of Media. On the transmit side the Media originating on the transmitting device may be progressively transmitted over the network as it is being received. In various embodiments the encoded Media regardless of how it is originated may be progressively transmitted before after or at substantially the same time it is stored in the PIMB . On the receive side the incoming Media may also be progressively rendered as it is received over the network provided the User has opted to Review the Media in the near real time mode. In various embodiments the incoming Media may be progressively rendered before after or substantially at the same time as it is stored in the PIMB of the receiving Device . If the received Media is to be Reviewed in the time shifted mode then the Media is retrieved from the PIMB or possibly a PIMB on a Server if replaced on the local PIMB for later Review at a time designated by the User.

In the context of the present application the term progressive or progressively is intended to be broadly construed and generally mean the continuous processing of a data stream based on availability of the data. For example as Media is created or otherwise originated on a Device the progressive encoding storage packetization and transmitting of that media is continuous so long as the Media is available. As a person speaks that Media is progressive or continuously encoded stored packetized and transmitted for the duration of the persons speech. When the person pauses or stops speaking there is no media to progressively process. When the person resumes speaking again the progressive processing of the Media resumes. On the receive side the Media is also progressively processed as the Media is being received i.e. available . As the Media is received it is continuously stored. It will also be continually rendered as the Media is being received when in the near real time mode or from storage when in the time shifted mode. Although the above explanation was provided in the context of voice it should be understood that all types of Media can be progressively processed in a similar manner. Also the progressive processing of Media does not necessarily have to be progressively processed in time indexed order. Rather the Media is processed in the order in which it is received or by using other indexing schemes. If Media is received out of index order in one embodiment the Media is progressively processed in the order it was received and then organized into the indexed sequence in the PIMB . In an alternative embodiment the received Media can be organized into its indexed sequence and then progressively rendered.

The PQM relies on a metric called the Maximum Available Bit Rate MABR which is a continually computed approximation of actual transmission capacity or bandwidth i.e. a measure of the capability of the network at a given point in time between a sending and receiving node pair. As instantaneous network conditions change the MABR is updated. Regular measurements of network throughput packet loss and jitter are considered in computing the MABR. In an alternative embodiment the MABR may also be manually set or limited based on time of day type of network other conditions or parameters.

The PQM also considers the Intention of the recipient s to optimize transmission for time sensitivity. A transmission is considered time sensitive if either i the Intention of the recipient s is to Review the transmission live or in the near real time mode or ii the recipient would like to immediately Review a Message that for some reason is not currently stored on their Device e.g. the Message was previously stored in the archive . The Intention of the recipient can be either inferred by the behavior of the recipient or the recipient may set or otherwise designate their Intention. On the other hand a transmission is considered to be not time sensitive if the Intention of the recipient is to Review the Message in the time shifted mode. The Intention of the recipient to Review the transmission in either the live i.e. real time mode or time shifted mode at least partially defines the timeliness requirements of the transmission. In various other embodiments factors such as the urgency or priority of transmissions may also be considered in defining the timeliness requirement of the transmission.

The nodes in the network path between a sender and a receiving pair also need to be consistent regarding the status of intentions of the recipients. If one target recipient indicates timeliness meaning they wish to Review the transmission immediately or live then all the intermediate nodes on the network along the sender receiver path need to have the same timeliness requirement regardless of the requirements of other recipients. The timeliness requirement of each of the intermediate nodes is therefore dependent on the receiving nodes the transmission is being sent to. This dependency is sometimes referred to as a union of requirements for target nodes in the network transmission path.

The PQM further considers an Ideal Bit Rate or IBR for each scheduled Message payload transmission. For time sensitive transmissions the IBR is computed based on the packetization rate needed for substantially real time or live communication referred to herein as the Real Time Bit Rate or RTBR . With voice for example a packetization rate of a packet every 20 milliseconds containing 20 milliseconds of audio data is considered an acceptable IBR for conducting live conversations. The RTBR for such a system in kilobits per second would be the size of 1 second of audio payload data plus the size of all network headers that would be generated for the transmission. For video media or a combination of voice and video the RTBR will likely be substantially higher than simply voice. For other types of media such as sensor or GPS positioning data the RTBR will likely be lower than that of voice. For non time sensitive transmissions the IBR is set to a Maximum Efficiency Bit Rate MEBR to optimize the usage or efficiency of transmissions over the network. The MEBR is calculated by adjusting the packetization rate to its largest possible value for the underlying network. If multiple messages or payloads are to be sent between a sending and receiving pair then an Aggregate IBR AIBR is considered for the transmission.

The PQM operates by sending data in a series of transmission loops for each sending and receiving pair. The transmission loops for each sending and receiving pair are independent. Any transmission on the network may affect the MABR of other sending receiving pairs. Accordingly the MABR is preferably continually computed for all recipients.

Referring to flow charts illustrating the sequence of operation of the PQM for a single sending and receiving pair is illustrated. In the steps in determining the MABR between the single sending and receiving pair are illustrated. In a flow chart illustrating the steps for calculating the AIBR for each transmission loop for the single sending and receiving pair are illustrated. In a sequence for determining the amount of data to transmit between the sending and receiving pair per loop is illustrated. The processes illustrated in the three diagrams run simultaneously and interact with one another as described in more detail below.

In a flow chart for calculating the MABR for the network interface between the sending and receiving pair is shown. In the initial step the network interface between the sending and receiving pair is monitored. The sender periodically receives reports which contain information regarding the status of the network connection at the receiver in step . The reports include information regarding the current status of data throughput packet loss and jitter as observed by the receiver at the network interface. In step the MABR is calculated at the sender based on these observations contained in the reports. By monitoring or observing the data in these reports the MABR value is continually adjusted based on current network capabilities or conditions between the sending and receiving pair. As network capabilities become more favorable for data transmission the MABR will increase. If the network capabilities become less favorable for transmission the MABR will decrease potentially all the way to zero for an unusable network. The reports are similar to the packet loss reports generated by nodes in TCP networks but additionally include throughput and jitter information as well.

If there are several network interfaces between the sending and receiving pair an MABR is calculated for each interface for which a receipt report is received. If no traffic has been recently sent on the network or no receipt reports have been received the MABR may not reflect current network conditions. However since receipt reports are continually generated by receivers while data is transmitted the sender s MABR metrics will quickly converge to a more accurate value.

Referring to a flow chart illustrating the steps for calculating the AIBR for a transmission loop is illustrated. In the initial step the Messages with Media by which we mean portions of the time indexed media that belongs to this Message ready to be transmitted between the sending and receiving pair in the current loop are ascertained. A list of Messages with Media is then built . For each Message in the list the time sensitivity or timeliness requirement of each Message is considered . If a particular Message is not time sensitive then the IBR is set to the ximum Efficiency Bit Rate MEBR . On the other hand if a Message is time sensitive then the IBR is set to the Real Time Bit Rate RTBR . In the next step the previously computed IBRs for each of the Messages in the list are summed together resulting in the Aggregate Ideal Bit Rate AIBR for the transmission loop. As signified by the return arrow the above described process is repeated for each transmission loop between the sending and receiving pair.

Referring to a flow chart illustrating the sequence for determining the rate of data to transmit between the sending and receiving pair per transmission loop is illustrated. In the initial step the MABR as calculated in is compared to the AIBR as determined in for the next transmission.

If the MABR is greater than or equal to the AIBR then all the Messages identified as ready for transmission in the loop are packetized at the IBR rate and transmitted .

On the other hand if the MABR is less than the AIBR then a series of procedures are applied to so that the PQM meets its goals of the timely delivery of an adequate copy of the data the efficient use of available bandwidth and or adjustments to the payload content and quality packet size and transmission rate to meet current network conditions. In other words the number of bits used to represent the transmitted Media when the MABR is less than the AIBR is reduced until the amount of data loss i.e. throughput is reduced to an acceptable level.

In the initial step the Messages in the list are reviewed for time sensitivity . If there are no time sensitive Messages then the bit rate is set to the MABR and the Messages are transmitted .

If the list includes time sensitive Messages the bit rate allocated for the non time sensitive Messages is reduced until it meets the MABR limits. If reducing the bit rate all the way to zero is insufficient to meet the MABR then these non time sensitive Messages are removed from the list of Messages to be transmitted in the loop. If the bit rate has been reduced so that it is less than or equal to the MABR then the remaining Messages are Packetized and transmitted .

If the removal of non time sensitive Messages was not sufficient to meet MABR then a procedure for sending a reduced bit version relative to the IBR version of just the time sensitive Messages is performed for the purpose of increasing the ability of the recipient to Review the Messages upon receipt so the Conversation may continue in the near real time mode. In one embodiment generating the reduced bit version of the time sensitive Messages involves using fewer bits relative to the IBR when packetizing the Media of the time sensitive Messages to be transmitted. For example the number of bits used per payload may be progressively lowered until the available bandwidth on the network is met. This procedure may be accomplished by either adjusting the setting of Codecs using different or lower quality Codec or Codecs or any combination thereof. In another embodiment generating a reduced bit version of the time sensitive Media contained in the Messages to be transmitted may involve the use of any of a number of known compression algorithms. If the reducing the number of bits is sufficient meaning the MABR limit is met then the Messages are transmitted . Regardless of which embodiment is used an attempt is made to transmit the payload data as fast as possible by sending fewer bits during the transmission loop. By reducing the quality of the payload the transmission by sending fewer bits in a given period of time the Conversation may be maintained in the near real time mode.

If reducing the bit rate using any of the above mentioned techniques still does not meet the MABR then the packetization interval for transmitting the time sensitive Messages is increased . With this procedure the header to payload ratio is increased which lowers the overall bit rate but introduces latency i.e. a delay in the delivery of the transmission to the recipient . If this procedure results in the reduction of the AIBR to less than or equal to the MABR then the transmission occurs.

If after changing the packetization interval the MABR is still not met then the bit rate may be progressively lowered to be within the MABR limit. When the bit rate is lowered in this manner time sensitive messages are sent at a rate that is not sufficient to maintain a live conversation. Therefore the Conversation is forced out of live . If the network is down or conditions are very poor it is possible that no data transmission may occur. Again the aforementioned sequence is repeated for each transmission loop between the sending and receiving pair. As conditions on the network improve the Conversation may resume in the live or near real time mode by decreasing the packetization interval and or using more bits to represent the Media to meet network conditions.

If there are multiple network interfaces between the sending and receiving pair the sequence described in relation to is performed for each interface for which receipt reports are available. In various embodiments the sender may contain logic to distribute the transmission load among the multiple interfaces. In different examples the payloads can be sent only on one interface while in other embodiments some or all of the interfaces may be used.

The aforementioned description pertains to any sending and receiving pair in the system . In most situations the sending and receiving pair will include a Client enabled Device and Server two Servers a Server and Client enabled Device or even possibly two Clients respectively. If a sending node is transmitting to two or more receiving nodes at the same time the above mentioned sequence as described in relation to occurs concurrently for each receiving sending pair.

The DQM determines if data received at the Client is either corrupted or if there are missing packets. In addition the DQM of a receiving Client generates of the receipt reports which are sent back to the transmitting node on the network. The DQM also runs a background process to ensure that an exact or complete copy of transmitted data is eventually received and stored. These functions are described below in respectively.

Referring to a flow diagram illustrating the operation of the DQM for checking for missing and or corrupted data is illustrated. In the initial step the DQM checks for corrupted packets using well known techniques such as CRC or similar integrity checking mechanisms. If a packet is corrupted that packet is treated as missing . The DQM next ascertains if any packets are missing . If an out of sequence packet is not received after a predetermined period of time it is assumed to be missing. The DQM notes any missing or corrupted packets in the DNQS . On the other hand if no corrupted or missing packets are detected the DQM determines if the quality of the received data was intentionally degraded i.e. a reduced bit rate representation of the Media by the sender for the purpose of saving bandwidth. The degraded quality is noted in the DNQS . Regardless if the quality of the received data is degraded or not receipt information e.g. a packet sequence number time stamp and the network address of the next node in the network the packet is to be sent of the data is stored in the DNQS . The aforementioned process is continually repeated as signified by the return arrow to the start of the flow diagram.

As a result of the process detailed in information regarding the receipt of non degraded i.e. full bit rate representations of Media packets the deficiency of degraded i.e. reduced bit rate representations of Media quality packets and missing or corrupted packets are all stored in the DNQS . As Media is received the DNQS maintains up to date information regarding the status of the Media.

Referring to a flow diagram illustrating the operation of the receipt report generator function of the DQM is illustrated. In the initial step the DNQS is periodically scanned to determine if there is any Media for which a receipt report needs to be generated . If the answer is no then the above scanning process is repeated. On the other hand if Media is identified then the process determines if the Media is time sensitive meaning either the User intends to Review the Media live or the user would like to immediately Review Media that is not stored on their Device .

If not time sensitive then the recipient informs the sender to set the retransmission priority as defined below to low . If time sensitive then the amount of packet loss is considered . If the amount of packet loss is outside a usable quality range the retransmission priority is set to high . As noted above if the amount of packet loss is too large the recipient may not be enabled to Review the Media upon receipt. If the quality is within an acceptable range meaning the quality of the transmission i.e. the reduced bit rate representation is sufficient that it can be understood when rendered then the priority for the sending of the receipt report is set to low . Regardless if the recipient is Reviewing upon receipt or not a receipt report is sent the DNQS is updated and the Network Quality Manager NQM is updated . The retransmission requests defined in step is therefore conditional based on time sensitivity. The transmission request defined in step is conditional on both time sensitivity and quality.

The retransmission priority informs the PQM of the sender to properly prioritize the transmission rate for the Media that requires retransmission. For example when the retransmission priority is set to high then the sending PQM of the sender should send any retransmissions before any new Media. If the priority is low the PQM should send the retransmitted Media after any new Media.

The aforementioned process is continuously repeated so that receipt reports are generated as Media is received. If the sender does not receive receipt reports in a timely manner the PQM of the sender will reduce the transmission rate eventually stopping the transmission if no receipt reports are received.

Referring to a flow diagram illustrating the sequence for requesting of missing or degraded Media is illustrated. In the initial step the DNQS is periodically scanned for missing or degraded Media . If there is no missing or degraded Media then the above defined scan is periodically repeated. In one embodiment high priority request means an immediate request for retransmission and a low priority request means a deferred request for retransmission typically until bandwidth in excess of what is needed for high priority retransmissions and or time sensitive Media is available. In addition the fulfilling of competing low priority requests at the sending node may be processed in accordance with any one of a number of different schemes. For example requests for retransmission of low priority Media may be fulfilled on a first come first serve basis time sensitive Media always before non time sensitive Media or vice versa.

Media is considered missing if an out of sequence packet does not arrive after a predetermined threshold period of time . If the packet arrives before the threshold then it is no longer considered missing. On the other hand if the packet does not arrive after the threshold is exceed then it is deemed missing. With missing packets a low priority request for retransmission is made and the time of the request is noted in the DNQS . This process is repeated until the missing packet is received. When the missing packet arrives and the corresponding Media is available in the PIMB the missing status of the Media is removed from the DNQS . The retransmission request defined in step is therefore conditional based on whether the Media is determined to be missing.

If the Media degraded to a reduced bit rate representation the DQM determines if the Media is part of a live or real time Conversation . If not a request for a full quality or bit rate copy of the degraded Media is made the full quality Media is designated as missing and the request time is noted in the DNQS . If the Media is part of a live Conversation then no action is immediately taken in order to preserve network bandwidth. When the Conversation transitions out of the live mode then the steps through are performed to ensure that a full quality i.e. an exact or complete copy of the degraded Media is eventually received. When the data becomes available in the PIMB of the recipient Client the degraded status of the associated Media is removed from the DQNS . The transmission request defined in step is therefore conditional on whether the Media is both degraded and not part of a live conversation.

The aforementioned process is continually repeated as signified by the return arrows from and to the top of the flow diagram at . By repeating the process outlined in exact copies of all transmitted Media is eventually stored in the PIMB of the receiving Device . In this manner the storage of exact copies of transmitted Media is guaranteed at the recipient Device .

Referring to a diagram illustrating the real time synchronization of the Media of a Conversation between a first Participant using Device A and a second Participant using Device B is illustrated. The progressive nature of the store and stream module ensures that the Media of the Conversation is progressively stored at both Device A or Device B as the Media is created. On the transmit side the operation of the PQM progressively transmits and stores in the local PIMB any Media created using the sending Device as the Media is created. On the receiving Device the DQM progressively stores in the local PIMB any received Media as it is being received and rendered. As a result both Participants of the Conversation have synchronized copies of the Media of the Conversation as the Media is being created.

For the sake of clarity shows only two Devices A and B engaged in the Conversation. It should be understood that the real time synchronization of the Media may be realized regardless of the number of Participants in the Conversation. In addition the network in the figure is shown as a generic networking cloud for the sake of simplicity. Again it should be understood that the network may include one or more Servers where the store and stream module and PIMB of each intermediate hop between the two Devices A and B stores a copy of the Media of the Conversation and optionally performs real time synchronization with Devices A and B.

Referring to a flow chart illustrating the sequence for the near real time synchronization of Media of a Conversation between Device A and Device B is illustrated. In this example it is presumed that the Users of Device A and Device B are engaged in the Conversation in the near real time mode. The Devices A and B may be engaged in the Conversation either directly or through one or more intermediate Servers not illustrated .

After the Conversation is initiated the Users of Device A and Device B will each typically create Media. On the left side of the figure the sequence for synchronizing the PIMB of Device A is illustrated. On the right side the sequence for synchronizing the PIMB of Device B is illustrated. The sequence is essentially the same on both sides of the diagram.

During the course of the Conversation the User of Device A will generate voice Media A . As this Media is created it is encoded and stored in the time indexed format in the local PIMB of Device A as described above with regard to A .

Device B notifies Device A of the status of all the locally created voice Media originating at Device B pertaining to the Conversation A . In various embodiments the notification of new Media may take a variety of different forms. For example the notice may occur i when Device B starts generating and transmitting Media associated with the Conversation for the first time ii when Device B logs in iii each time Media pertaining to the Conversation is created at Device B and transmitted to Device A iv when Device B periodically notifies Device A of the state of all the Media created using Device B pertaining to the Conversation v Device A periodically asks Device B for the state of the Media created and stored at Device B or vi Device B notifies Device A with a synchronization update message that Media is available either just prior to or concurrent with the transmission of the Media. In yet another embodiments vii the Media of the Conversation may be stored at one or more Servers hops between the Device A and Device B. The various notices described above with regard to i through vi may occur between the Servers and the Device A and or B rather than directly between the Devices A and B. Lastly the notice may involve some combination of i through vii . As the Media is transmitted as described above with respect to it is sequenced and time stamped allowing Device A to determine which Media it has already received and which media it may be missing.

In response to the notification Device A requests all the voice media associated with the Conversation not already stored in the PIMB of Device A A . This is accomplished by following the routine described above with regard to including running the DQM as described in relation to . Depending on circumstances the requested Media could be Media with a specific time stamp or within a time stamp range. For example if Device A is in receipt of a less than complete copy of previously sent Media then the request identifies only the Media needed to backfill and complete the copy of the Media at Device A. Alternatively during the course of an ongoing Conversation the request may not have a specific end point. Instead the request from Device A to Device B is open ended and Device B sends the new Media as it is being created.

Device B in response sends the requested Media along with any new Media associated with the Conversation as it is being created A using the sequence described above with respect to . In response Device A locally stores all the received Media in its PIMB. As a result Device A is able to maintain a complete copy of the Media of the Conversion as the Media is created on Device B.

When Device B creates voice Media the sequence B through B is executed. The sequence B through B is the complement of A through A and therefore is not described in detail herein. The net result of the two sequences A through A and B through B is that both Device A and Device B each maintain synchronized copies of the Media of the Conversation as the Conversation occurs in real time.

The synchronization of the Media of the Conversation at Device A and Device B occurs even when the MABR is less than the AIBR. As noted above with respect to a number of procedures are implemented to maintain the live ness of the Conversation when the MABR is less than the AIBR including transmitting only time sensitive media using fewer bits to represent the Media per unit of time increasing the packetization interval and reducing the rate the Media is transmitted to meet conditions on the network . These procedures have the advantage of extending the ability to maintain the live ness of the Conversation but at the expense of not transmitting an exact or full copy of the Media as it was originally encoded. As a result synchronization is maintained but with a less than exact copy of the originally encoded Media at the receiving Device. With the DQM at the receiving Device replacements for the missing corrupted and less than full bit rate versions of the Media are eventually transmitted and stored at the receiving Device. This backfill procedure eventually results in the complete synchronization of the Media of the Conversation on Devices A and B. Thus under certain conditions real time synchronization of a complete or exact copy of transmitted Media may not be possible. Rather the synchronization may be a work in progress where a complete copy of the Media is received only after the backfill process is completed.

Although the above explanation has been described in the context of a voice Conversation it should be understood that Media of the Conversation could involve any type of Media in addition to voice including video GPS information or other sensor data. In addition the Conversation does not necessarily have to be limited to two Users or Participants. The near real time synchronization of the Media of a Conversation occurs regardless of the number of Devices participating in the Conversation.

In the above discussion the network infrastructure has been represented as a single Server serving multiple Client enabled Devices . In an alternative embodiment the networking infrastructure is a distributed network of Servers .

Referring to an example of a distributed services network according to the present invention is illustrated. The distributed network includes a plurality of Servers . Each of the Servers may be configured to implement one or more distributed network related functions. A given Server may be configured as a home Server a gateway client Server a gateway Server a directory Server an access Server or any combination thereof. Regardless of how many functions a particular Server is configured to perform each shares the architecture as illustrated in and includes a Store and Stream module and PIMB with one possible exception. If a Server is configured solely as a directory Server then the module Store and Stream and PIMB are not required.

Each User is assigned a specific Server as their home Server. A home Server is where the Media of each of the User s Conversations is stored on the network . For each Conversation the stored Media includes the Media contribution of all the Participants including the contributions of the User.

In one embodiment home Devices rely on the well known Domain Name System DNS for locating their home Servers and for locating the home Servers of other Users. In alternative embodiments the Lightweight Directory Access Protocol LDAP is used. As should be obvious to those skilled in the art any type of networked directory lookup system may be used for locating home Servers .

Home Servers also manage and perform home Server migration. Home Servers are usually located on the Network topology in a convenient place for where a User ordinarily accesses the network . If a User accesses the network from a different part of the network topology for some period of time for whatever reason the home Server for that User may be moved to another Server that is more optimal in the network topology for that User. When this occurs the User s persistently stored Media is migrated from the previous to the new home Server over the network . This migration process may be initiated automatically after a predetermined period of time after the User has moved or it can be implemented manually.

Gateway Servers are gateways between the network and other communication networks as illustrated in for example. Gateway Servers straddle the two networks and are responsible for performing any mapping trans coding re encapsulation security or other translation functions as necessary when routing traffic between the two network domains. When the two networks have different packetization requirements for example the gateway Server re packetizes the packets from the format used by one network into the format used by the second network and vice versa.

Gateway client Servers provide intermediation between the distributed services architecture and non Client enabled communication devices . Gateway client Servers perform on the network on behalf of the devices the functionality of i the MCMS application including MCMS and optionally MCMS S and or MCMS C and ii the Store and Stream and persistent storage operations of module and PIMB . Specifically Gateway client Servers perform the PIMB Reader and Render function PIMB Writer Net Receive function PIMB Writer Encode Receive function and PIMB Reader Transmit function so that the Media of Conversations is stored in the PIMB of the Server on behalf of the non Client enabled device . Examples of non Client enabled devices may include standard landline or PSTN telephones mobile or satellite phones tactical radios or any other known legacy communication device. In addition non Client enabled communication devices may include non legacy devices specifically made to operate in cooperation with Gateway client Servers . For more details on gateway client Servers see U.S. application Ser. Nos. 12 206 537 and 12 206 548 each filed on Sep. 8 2008 and each entitled Telecommunication and Multimedia Management Method and Apparatus both of which are incorporated herein for all purposes.

The access point where a User connects to the network through an underlying network is called an access Server . The access Server for a User may change. For example a User may disconnect from the network move to a new physical location and then reconnect through a different Server . Also the access Server of a User may migrate from one access Server to another. For example if a User has wireless access to the network through a first node of an underlying network while traveling in a car the access Server may change as the User moves out of the range of the first node of the wireless network into the range of a second node of the wireless network . If the access point to network for the two nodes of the underlying wireless network is different than the access Server for that User will change. The ability of a User to access the network through an arbitrary access Server improves network efficiency by optimizing the communication between the User and other nodes on the network .

Directory Server provides routing information for the rest of the network . When a User joins the network the access Server i notifies the directory Server that the User has joined and ii identifies itself as the access Server for that User. The directory Server aggregates i and ii for all Users connected to the network along with the iii home Server of each User into a directory. The directory Server is continually updated. As Users join or leave the network or as the access Server and or the home Server for a User changes the directory is updated. In this manner the directory always provides current or up to date information for routing Messages and other network traffic between Users across the network or users located on other networks through gateway Servers .

If a User s home Server and access Server are the same then that Server persistently stores all Media transmitted or received by that User. For Media created by the User for transmission and for Media sent to the User the Server performs the functions described above with relation to including the PQM and PQM FIGS. D F operations. In this manner copies of the Media transmitted or received by the User are persistently stored at the home Server of the User. In addition any less than complete or full copies missing or corrupted copies of Media are eventually received through the backfill operation of the PQM and DQM

If an access Server is not the home Server for a User the transmitted and received Media is at least temporarily stored at the access Server using the same operation described in relation to including the PQM and PQM FIGS. D F operations. In one embodiment the Media is stored at the access Server only until the confirmation of the delivery and persistent storage of the Media to the User s home Server and Device . In an alternative embodiment the Media is persistently stored at the access Server and the home Server even after the delivery of the Media is confirmed. Different schemes for deleting the Media at the access Server after the confirmation of the delivery to the home Server and or Device may be employed depending on the application and network topology.

A home Server is also responsible for archiving the Media of the Conversation in its archive . Media may be archived for a number of reasons such as restoring the Media to a Device after it was locally deleted or the sending of the Media to a new Device after authentication by a User on that Device .

In the embodiment illustrated in a number of Client enabled Devices are connected to the network through various access home and gateway Servers . In addition non Client enabled devices are also connected to the network through a gateway client Server . As noted above each Server may implement one or more of the above listed functions. For example in situations where a Device connects to the network through its home Server then that Server performs the dual role of being an access Server and home Server for that Device. In situations where a Device accesses the network through a Server other than its home Server then the access and home Servers for that device are different. In yet other situations home Servers and or access Servers may also function as gateway Servers gateway client Servers and or directory Servers as well. When a Server acts as a hop on the network for transmitting Messages regardless of which function s the Server is configured to implement the Server stores and transmits the Media as described above with regard to including performing the PQM and PQM FIGS. D F operations except for possibly a Server configured solely as a directory Server . Each of the Servers regardless of the function or functions performed are also multi tenant meaning they can each support or serve multiple Users at the same time.

It should be noted that the specific arrangement of Servers and the function or functions as described or shown in is only exemplary and is provided for the sake of illustration. In actual embodiments the number of Servers the one or more functions performed by each and the actual configuration of the distributed network may vary in nearly an infinite number of variations.

In an alternative embodiment the network may be configured without a dedicated directory Server . In such embodiments access Servers are configured to assume some or all of the directory and routing functionality. Some or all of the access Servers in the network may be configured to maintain routing tables including default routes for locating and sending Messages to other access and home Servers and Users.

In another embodiment a Client enabled Device may act as a Server for other Devices or . For example a vehicle based Client enabled radio Device could be a client for the driver of the vehicle as well as a Server for all nearby radios. In another example a computer could act as not only a Client for a local User but also as a Server for other Client enabled computers connected on the local network.

In yet other embodiments access Servers may provide proxy access to home Servers and or directory Servers when the network connection to the home Server and or directory Server is degraded or unavailable. Access Servers also provide current optimal routing information by locating the appropriate home Servers other access Servers and Client enabled Devices and maps the most efficient path between Client enabled Devices and these Servers .

As Conversations occur between the various Client enable Devices and or non Client enabled devices individual Messages are typically transmitted from one or more Devices and or to one or mores Servers from Server s to Server s across the distributed network and then from Server s to one or more Devices and or . The Messages traverse the network in the form of Vox packets embedded in whatever type of packets are used by the underlying network or networks. In various embodiments the underlying network may rely on the Internet Protocol IP a Real Time Protocol RTP or any other type of protocol for the transmission of network traffic. In routing the individual Messages across the distributed architecture a procedure that reduces traffic and latency while maintaining simplicity is preferred.

Referring to a simple distributed network for illustrating a routing procedure used in one embodiment of the present invention is illustrated. In this embodiment the network includes access Servers labeled Access Server and Access Server Client enabled Devices through a number of home Servers and a directory Server . Devices through are connected to the network through Access Server . Device is connected to the network through Access Server . Home Servers and are the home Server for Devices and respectively. Devices and share a home Server . A sixth home Server is also provided for a sixth Devices which is purposely not illustrated because it is currently disconnected from the network in this example.

When Device initiates a Conversation with Devices through it sends a request to Access Server which notes that it already has connectivity with Devices through . Access Server also requests from the directory Server the status of Devices and and the Home servers for Devices through . The directory Server responds by notifying Access Server that Device is online through Access Server and Device is not online. The directory Server also notifies Access Server that the home Servers for participants and are Home servers and respectively.

When Device sends Messages related to the Conversation the Messages are sent to the Access Server . In turn the Messages are directly forwarded to Devices through since these Devices are connected to Access Server . In addition Access Server notes that the remaining transmission destinations specifically Home servers and and Devices have the same next hop which is Access Server . Since these destinations all share the same next hop Access Server sends only a single copy of each Message to Access Server . The Messages are then sent by access Server to Device home Servers and home Server . Each of the home Servers through retain the messages for the Devices through respectively. When Device comes online home Server forwards the Messages to Device enabling the Device to receive the Media of the Conversation. If Devices and had different next hops on the network then only a single copy of the Messages would be sent to each next hop. Messages generated by any of the other Devices through are routed across the network in a similar manner as described above.

The above described routing procedure provides a number of advantages. By routing Messages directly between Devices identified with the same access Server through that same access Server network traffic and latency is reduced. Also by forwarding only a single copy of Messages as opposed to multiple copies to multiple recipients sharing the same next hop on the network network traffic and latency is again reduced. By consolidating Message transmissions to multiple recipients along the same hop to a single transmission and duplicating or fanning out Messages only when there are multiple next hops overall network traffic and latency is significantly reduced.

In an alternative embodiment access Servers may be configured to allow Devices connected to the network through the same access Server to communicate directly with one another. With this embodiment any Messages directly sent between the two or more Devices still have to be sent to the common access Server which in turn forwards the Messages to the home Servers for the same Devices . This arrangement provides an improvement in latency for communication between Devices connected to the same access Server but at the expense of increased complexity on both the Devices and the access Server . Since all Messages still have to be sent to the access Server network traffic is essentially doubled.

One advantage of using Servers is the ability to maintain near real time synchronization of the Media transmitted across the distributed network . Referring to an example of a network which is configured on top of one or more networks not shown is illustrated. In this example two Client enabled Devices and a non Client enabled device are engaged in a voice and optionally other Media types Conversation across the network . The network includes access Servers and which provide network access for Devices and respectively. Non Client enabled device connects to the network through the Server configured as a gateway client. In addition a directory Server is provided. Each of the Servers includes a Store and Stream module and PIMB except perhaps the directory Server which may optionally include module and PIMB .

As Messages of the Conversation are transmitted between each sending and receiving pair on the network the Store and Stream module for Devices and and for each of the Servers run the sequence described above with regard to . As a result the Media of the Conversation is synchronously stored in the PIMB of each Server hop on the network between the legacy device and Devices and . The Media is also synchronously stored in the PIMB of the Devices and .

In one embodiment the Media is synchronously and persistently stored at each Server hop on the network . In an alternative embodiment the Media of the Conversation is persistently stored on the network only on the gateway client Server for the legacy device and the home Servers and for Devices and respectively but not the access Servers and . In the latter embodiment the Media is no longer stored on the access Servers and once it has been confirmed that the Media is persistently stored on home Servers and and or Devices and respectively.

As the Media migrates through the network from its source to destination the Media is synchronized between each sender receiving pair. Each node on the network including the Client enabled Devices and each intermediary Server is synchronized hop by hop . By performing the synchronization of the Media between each sending receiving hop on the network as opposed to just the sending and receiving communication Devices and the resiliency and redundancy of the Media across the network is increased.

Although synchronization across the network has been described in the context of a voice Conversation it should be understood that Media of the Conversation could involve any type of Media including voice video GPS information or other sensor data. In addition the Conversation does not necessarily have to be limited to three participants as described above. The near real time synchronization of the Media of a Conversation occurs regardless of the number participants. Nor does the Media have to be transmitted in the context of a Conversation. Media not pertaining to a Conversation can be synchronized across the network . Lastly it again should be understood that the particular network configuration illustrated in is merely illustrative for explaining the real time synchronization across the network. The particular configuration shown should not be construed as limiting in any way.

It should be noted that in the above discussion with regard to and the Media has been described as indexed in a time based format. It should be understood that time indexing the Media is exemplary and should not be construed as limiting the present invention. On the contrary any indexing format may be used such as indexing by bit or byte sequence hashing type indexing binary tree type indexing file directory based indexing or any combination thereof. The term indexing therefore should be broadly construed to cover any indexing scheme.

Referring to a block diagram illustrating the hardware of a Device used for storing and executing the Client application is shown. The hardware includes a CPU main memory and mass storage . As is well known in the art the Client application is loaded and stored in main memory and mass storage and executed by the CPU .

Referring to a block diagram illustrating the hardware of a Server or any of the servers through used for storing and executing the server application is shown. The hardware includes a CPU main memory mass storage and the archive . As is well known in the art the server application is loaded and stored in main memory and mass storage and executed by the CPU . As noted above indexed media payloads of one or more Users are stored in the archive .

Although many of the components and processes are described above in the singular for convenience it will be appreciated by one of skill in the art that multiple components and repeated processes can also be used to practice the techniques of the system and method described herein. Further while the invention has been particularly shown and described with reference to specific embodiments thereof it will be understood by those skilled in the art that changes in the form and details of the disclosed embodiments may be made without departing from the spirit or scope of the invention. For example embodiments of the invention may be employed with a variety of components and should not be restricted to the ones mentioned above. It is therefore intended that the invention be interpreted to include all variations and equivalents that fall within the true spirit and scope of the invention.

