---

title: User-mode based remote desktop protocol (RDP) encoding architecture
abstract: Techniques are disclosed for a user-mode based remote desktop protocol (RDP) encoding architecture. A user mode desktop application and user mode virtual channel application run in user-mode session space. Virtual channel data from the virtual channel application is marshaled and sent to a RDP encoder process in user-mode system space. There it is converted to RDP protocol data units (PDU) and sent to a remote client across a communications network. Graphics data from the desktop application is sent to a display driver in kernel-mode session space and then to a graphics reflector that marshals the graphics data and sends it to the RDP encoder for a similar transformation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08180905&OS=08180905&RS=08180905
owner: Microsoft Corporation
number: 08180905
owner_city: Redmond
owner_country: US
publication_date: 20081209
---
Some operating systems in the Windows family provide facilities through which a user can interact remotely with the user interface belonging to applications that are running on another computer. Such facilities are known as remote desktop or terminal services. An example of such a facility is WINDOWS TERMINAL SERVER or a remote desktop protocol RDP device. These facilities have shortcoming as a result of the fact that the code responsible for the RDP protocol encoding is implemented by a set of kernel mode drivers. These kernel mode drivers have typically been used because such a driver can easily access the data that is to be encoded into a protocol. However such drivers are hard to service and are very difficult to develop maintain or extend in functionality. To that end these limitations can be mitigated if the facilities are implemented in a user mode process.

An embodiment of the present invention comprises a user mode based remote desktop protocol RDP encoding architecture. In this embodiment data is extracted from a session space process and marshaled over to a system space user mode process for the purpose of being encoded. In this embodiment processes execute in each of user mode session space kernel mode session space and user mode system space.

Graphics data from a user mode desktop application operating in user mode session space is sent through a display driver operating in kernel mode session space. That driver sends the graphics data to a graphics reflector in kernel mode session space that marshals the data and sends it to a RDP encoder process in user mode system space.

Likewise virtual channel data from a user mode virtual channel application operating in user mode session space is sent through a virtual channel reflector in user mode session space that marshals the data and sends the marshaled virtual channel data to the RDP encoder process.

The RDP encoder process takes both of these types of data encodes it into RDP protocol data units PDU and sends those units to a client that has a corresponding RDP session with the computer on which this technique is executed.

This solution provides the mechanisms and architecture for efficiently marshaling the graphics data interface GDI and virtual channel data from the session space to a process running in user mode context in the system space. This enables a terminal services implementation where the protocol encoding is implemented in a single machine wide user mode component.

These techniques may be applied to a session running on a single operating system OS or to a session that is running on a guest OS within a virtual machine VM hosted by that OS on a host machine that has a host OS. Where it is the latter embodiment the techniques may be applied to a plurality of such guest OSes.

In an embodiment graphics data is marshaled through a low overhead shared memory mechanism and virtual channel data is marshaled through named pipes. Named pipes may be used in order to preserve the semantics for any existing terminal server virtual channel application programming interfaces APIs while the typically faster shared memory mechanism may be used where such named pipes are not necessary to preserve such semantics.

The above techniques allow graphics and data output to be controlled through a single user mode system space process the RDP encoder process that does not depend on a device driver interface or session application threads. That is the number of threads used to implement these techniques may be known limited and kept at a performance optimized number.

Systems methods and computer readable storage media that perform the above and similar processes are disclosed.

It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and or programming for effecting the herein referenced aspects of the present disclosure the circuitry and or programming can be virtually any combination of hardware software and or firmware configured to effect the herein referenced aspects depending upon the design choices of the system designer.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail. Those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting.

Embodiments of the present disclosure may execute on one or more computers. and the following discussion are intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that some or all of the components of the computer system of can be used to effectuate the computers of and A.

The term circuitry used through the disclosure can include specialized hardware components such as hardware interrupt controllers hard drives network adaptors graphics processors and audio codecs for example. In the same or other embodiments circuitry can include microprocessors configured to perform function s by firmware or by set switches. In the same or other example embodiments circuitry can include one or more logical processors e.g. one or more cores of a multi core general processing unit. The logical processor s in this example can be configured by software instructions embodying logic operable to perform function s that are loaded from memory e.g. RAM ROM firmware and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be processed by the logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware software or a combination of hardware software the selection of hardware versus software to effectuate specific functions is a design choice left to an implementer. More specifically one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process. Thus the selection of a hardware implementation versus a software implementation is one of design choice and left to the implementer.

Referring now to an exemplary general purpose computing system is depicted. The general purpose computing system can include a conventional computer or the like including a general purpose processing unit that can include one or more logical processors a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM . The computer may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. In some example embodiments computer executable instructions embodying aspects of the present disclosure may be stored in ROM hard disk not shown RAM removable magnetic disk optical disk and or a cache of general purpose processing unit . The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the general purpose processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computer a server a router a network PC a peer device or other common network node and typically can include many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer can be connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer can typically include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external can be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the present disclosure are particularly well suited for computerized systems nothing in this document is intended to limit the disclosure to such embodiments.

The foregoing detailed description has set forth various embodiments of the systems and or processes via examples and or operational diagrams. Insofar as such block diagrams and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof.

While particular aspects of the present subject matter described herein have been shown and described it will be apparent to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from the subject matter described herein and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of the subject matter described herein.

In these embodiments processes execute in each of user mode session space kernel mode session space and kernel mode system space. Kernel mode space is typically memory space reserved for running the kernel kernel extensions and some device drivers. User mode space is typically memory where all user mode applications execute. Session space is memory space reserved for a particular user session. System space is memory reserved for the system for as long as the system is operating. Kernel mode or user mode space may be combined with session or system space to produce the spaces above such as user mode system space. Other embodiments may utilize user mode system space.

An application in user mode session space such as a word processor or web browser first generates graphics data. Where the application is a word processor this graphics data may be text or an image to be displayed on the screen in a particular alignment such as centered and bolded on a page of the document being edited. This graphics data is then sent to a device driver in accordance with a device driver interface DDI for processing. The driver and DDI exist in kernel mode session space. A device driver is a component or computer program that allows a high level computer program such as a word processor to communicate with a hardware device such as a computer printer or a computer monitor. The driver typically communicates with the associated hardware through a communications subsystem of the computer to which the hardware is physically connected. The corresponding DDI is a form of an application programming interface API that is specific to the driver. The program makes a call in accordance with the DDI which is translated by the DDI and the driver into a communication understood by the corresponding hardware. The DDI and driver make a similar transform when receiving communications from the hardware for the program .

In an embodiment the DDI may comprise the Graphics Device Interface GDI an API for MICROSOFT WINDOWS that represents graphical objects and transmits them to output devices like monitors and printers. GDI performs tasks such as drawing lines and curves rendering fonts and handling palettes. In other embodiments the DDI may comprise an interface that supports DirectX DX or Desktop Window Manager DWM .

In the embodiment where the graphics data is to be sent across a communications network via a remote desktop protocol RDP the driver partially encodes the received data into at least one RDP graphics protocol data unit PDU . A RDP PDU is a unit of data that is specified in the RDP protocol. The driver then sends each RDP PDU to a system space kernel mode driver that implements the rest of the encoding. This system space kernel mode driver exists in kernel mode system space. The encoding may comprise both compression and encryption. After the system space kernel mode driver encodes a PDU it sends the PDU to a lower level kernel transport driver . This kernel transport driver exists in kernel mode system space. The kernel transport driver sends the PDU to the intended recipient of the PDU. For instance where a user on a client machine has a RDP session with the present machine the kernel transport driver sends the PDU to the client in accordance with RDP across a communications network.

Similar to the user mode desktop application a user mode virtual channel application may exist in user mode session space. A virtual channel application may be for instance a remote clipboard where a user on a remote client machine communicating with the present machine may copy text or images on another application running in the same session such as the desktop application to a remote clipboard and then paste the copied data into another document. Such virtual channel data is sent directly through a file input output I O subsystem driver that exists in kernel mode session space. Similar as to how the device driver processed its received data into at least one RDP PDU the I O subsystem may apply framing compression and encryption to the virtual channel data received to produce at least one RDP PDU and send each PDU to the system space RDP kernel mode driver . The RDP kernel mode driver sends each PDU to the system space kernel mode transport driver which sends the PDU to the intended recipient of the PDU.

This system of allows for data to travel through the stack without any explicit marshaling. This produces a simple kernel mode based RDP encoding architecture that does not require complex data handling and marshaling. This architecture is limited in that the encoding code runs in kernel mode.

In this embodiment both the user mode desktop application and the user mode virtual channel application exist in user mode session space.

The user mode desktop application such as a word processor or web browser first generates graphics data. Where the application is a word processor this graphics data may be text or an image to be displayed on the screen in a particular alignment such as centered and bolded on a page of the document being edited. This graphics data is then sent to a device driver in accordance with a device driver interface DDI for processing. The driver and DDI exist in kernel mode session space. A device driver is a component or computer program that allows a high level computer program such as a word processor to communicate with a hardware device such as a computer printer or a computer monitor. The driver typically communicates with the associated hardware through a communications subsystem of the computer to which the hardware is physically connected. The corresponding DDI is a form of an application programming interface API that is specific to the driver. The program makes a call in accordance with the DDI which is translated by the DDI and the driver into a communication understood by the corresponding hardware. The DDI and driver make a similar transform when receiving communications from the hardware for the program .

In an embodiment the DDI may comprise the Graphics Device Interface GDI an API for MICROSOFT WINDOWS that represents graphical objects and transmits them to output devices like monitors and printers. GDI performs tasks such as drawing lines and curves rendering fonts and handling palettes.

In the embodiment where the graphics data is to be sent across a communications network via a remote desktop protocol RDP the driver partially encodes the received data into at least one command that can be understood by the RDP encoder process. A The driver sends each command to a shared memory graphics reflector that exists in kernel mode session space. The shared memory graphics reflector comprises a memory that may be simultaneously accessed by multiple programs with an intent to provide communication among them. This shared memory graphics reflector marshals all received data and sends it to a graphics reflector in user mode system space. The reflectors ensure that a normally complex task of exchanging data between the user session space and the system space proceeds in an efficient manner.

Marshaling is the process of transforming the memory representation of an object to a data format suitable for storage or transmission and is typically used when data must be moved between different parts of a computer program or from one program to another. The opposite operation is known as unmarshaling. 

The two reflectors here communicate based on shared memory mapped between a kernel mode session space driver the shared memory graphics reflector and a user mode system space process the graphics reflector .

In an embodiment the graphics reflector is part of a RDP encoder process along with a RDP output scheduler and encoder and a user mode transport . The RDP encoder process exists in user mode system space.

The graphics reflector takes the received graphics data and sends it to the RDP output scheduler and encoder . As depicted in the kernel mode architecture encodes the RDP data and sends it across a network using the actual threads of the applications that produced that data. In most cases those applications were being blocked while the data was encoded. In the user mode architecture depicted by the encoding is performed by the RDP output scheduler and encoder component . The output scheduler component is responsible for consuming the virtual channel data and the graphics marshaled data and encoding that data on its own set of threads into the RDP format. This architecture allows the encoding for each RDP session present on the machine to be performed by a single component on a finite and optimal set of threads.

When the RDP output scheduler and encoder has encoded the received graphics data into at least one RDP PDU it sends each PDU to the user mode transport . The user mode transport sends the PDU to the intended recipient of the PDU. For instance where a user on a client machine has a RDP session with the present machine the user mode transport sends the PDU to the client in accordance with RDP across a communications network.

Similar to the user mode desktop application the user mode virtual channel application may exist in user mode session space. A virtual channel application may be for instance a remote clipboard where a user on a remote client machine communicating with the present machine may copy text or images on another application running in the same session such as the desktop application to a remote clipboard and then paste the copied data into another document. Such virtual channel data is sent from the user mode virtual channel application through a virtual channel reflector to the RDP output scheduler and encoder . The virtual channel reflector marshals the received virtual channel data and sends corresponding marshaled virtual channel data to the RDP output scheduler and encoder .

In an embodiment the virtual channel reflector uses named pipes and named pipe handles. A named pipe may be used for inter processes communication such as done by the virtual channel reflector . A named pipe is an API that provides a system persistent inter process communications IPC channel for a plurality of processes to communicate to each other and usually appears as a file to a process. A process generally attaches to a named pipe to perform an inter process communication with another process. In an embodiment a named pipe stores and fetches data in memory and retrieves it when requested. A named pipe handle is a handle to a named pipe.

By using named pipe handles the I O operations on channel handles are compatible with the pre existing terminal server API such as the WINDOWS TERMINAL SERVER API. This is key to providing compatibility with current virtual channel based applications. If named pipes were not used by the virtual channel reflector then current virtual channel based applications would be rendered inoperable as through the virtual channel reflector .

Similar as to how the RDP output scheduler and encoder encodes graphics data received from the graphics reflector into at least one RDP PDU the RDP output scheduler and encoder encodes virtual channel data received from the virtual channel reflector into at least one RDP PDU. The RDP output scheduler and encoder then sends each PDU to the user mode transport which sends the PDU to the intended recipient of the PDU.

Some components were necessarily omitted from the above figures for the sake of clarity and brevity. For instance the transmission control protocol TCP or transport listeners may be different between the implementation of and . The TCP listener in a kernel mode architecture of uses a kernel mode listener while the TCP listener of use a user mode based listener. A similar approach is taken to the components for handling the input injections. One skilled in the art will appreciate other ancillary differences between the implementation of and .

