---

title: One time settable tamper resistant software repository
abstract: A one-time-settable tamper resistant software repository may be used in any computing system to store system information such as security violations and policies for responding to them. A one-time-settable tamper resistant software repository may be cryptographically signed, encrypted with a per device key and accessible by only the most privileged software executed by a computing device, e.g., hypervisor or operating system kernel. A one-time-settable tamper resistant software repository may be mirrored in RAM for performance. Recordable event fields in a software repository may be one-time-settable without the ability to reset them in a field operation mode whereas they may be resettable in a different mode such as a manufacturing mode. Memory allocated to a one-time-settable tamper resistant software repository may be reset, reclaimed, reassigned, scaled and otherwise flexibly adapted to changing conditions and priorities in the lifespan of a computing device, which may be particularly useful for service-backed consumer devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656190&OS=08656190&RS=08656190
owner: Microsoft Corporation
number: 08656190
owner_city: Redmond
owner_country: US
publication_date: 20080131
---
The technical field relates generally to computing and more specifically to one time settable storage of information.

Computing systems such as those that implement security to protect business models often rely on one time programmable OTP ROM i.e. PROM to securely store information. Examples of such devices include service backed consumer devices e.g. closed computing systems like game consoles MP3 players HD DVD players cell phones PDAs and cable set top boxes. Information stored in PROM may include the serial number or update history of a computing system among other information. As with each additional component in hardware PROM adds costs to the development and production of computing systems. While secure there are significant problems with OTP fuses or other PROMs. Aside from costs there are hardware failure rates associated with manufacturing and operation of devices having PROMs. There is also the potential for irreversible error. Such errors may lead to recalls and component replacements because PROMs cannot be reset. There is also a lack of flexibility. PROMs are fixed in number upon manufacture and cannot be reclaimed or redistributed. PROMs are also susceptible to disablement i.e. physical blocking by hardware manipulation.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description Of Illustrative Embodiments. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The present invention provides for a one time settable tamper resistant software repository for use in any computing system. Tamper resistant security may be provided for example by cryptographically signing the software repository encrypting it with an individualized per device key and limiting access to the repository to only the highest privilege level code executed by a computing device e.g. hypervisor or operating system kernel. Recordable event fields in a software repository may be one time settable without the ability to reset them in a field operation mode whereas each recordable event field may be resettable in a different mode such as a manufacturing mode. The software repository may store security policies for responding to security violations or policies for other information stored in the software repository. For example one security policy may be to deny one or more services supported by a computing device. Such policies may be modified over time. The software repository may be mirrored in protected random access memory for performance. Both copies in non volatile memory and in RAM may be updated for each recordable event e.g. security violation. This may entail for example using the most secure software to update the mirrored copy in RAM and to decrypt authenticate verify update re sign re encrypt and re store the software repository stored in non volatile memory.

There are numerous advantages to one time settable software repositories. For example unlike PROMs one time settable software repositories are flexible. Software repositories using non volatile memory may be reset to cure manufacturing errors as well as for refurbishment and resale. Thus errors can be overcome without recalls and component replacement. Software repositories may be scaled in size throughout the life of computing devices. Memory available to software repositories may be reclaimed and redistributed. Security issues may be different at initial release than they are a year later after hackers have time to work on a computing device. Software repositories may be adapted to changing security issues and policies for dealing with them. No specialized hardware such as OTP fuses is required reducing manufacturing costs and hardware failure rates. Software repositories are also not susceptible to disablement by physical blocking. Software repositories may persist security and other information protect against illegitimate warranty claims and protect against unauthorized manipulation and access to services among other benefits. An additional advantage of a per device key is that a software vulnerability in the security system may not be mass exploitable on other computing devices each securing the software repository with a unique key.

Reference will now be made in detail to embodiments of the present technology for a one time settable tamper resistant software repository examples of which are illustrated in the accompanying drawings. While the technology for a one time settable tamper resistant software repository will be described in conjunction with various embodiments it will be understood that they are not intended to limit the present technology for a one time settable tamper resistant software repository to these embodiments. On the contrary the presented technology for a one time settable tamper resistant software repository is intended to cover alternatives modifications and equivalents which may be included within the spirit and the scope of the various embodiments as defined by the appended claims. Furthermore in the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the present technology for a one time settable tamper resistant software repository. However the present technology for a one time settable tamper resistant software repository may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present embodiments.

Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present detailed description discussions utilizing terms such as opening determining sequencing reading loading overriding writing creating including comparing receiving providing generating associating and arranging or the like refer to the actions and processes of a computer system or similar electronic computing device. The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices. The present technology for a one time settable tamper resistant software repository is also well suited to the use of other computer systems such as for example optical and mechanical computers. Additionally it should be understood that in embodiments of the present technology for a one time settable tamper resistant software repository one or more of the steps can be performed manually.

The present invention provides for a one time settable tamper resistant software repository for use in any computing system. Tamper resistant security may be provided for example by cryptographically signing the software repository encrypting it with an individualized per device key and limiting access to the repository to only the highest privilege level code executed by a computing device e.g. hypervisor or operating system kernel. Recordable event fields in a software repository may be one time settable without the ability to reset them in a field operation mode whereas each recordable event field may be resettable in a different mode such as a manufacturing mode. The software repository may store security policies for responding to security violations or policies for other information stored in the software repository. For example one security policy may be to deny one or more services supported by a computing device. Such policies may be modified over time. The software repository may be mirrored in protected random access memory for performance. Both copies in non volatile memory and in RAM may be updated for each recordable event e.g. security violation. This may entail for example using the most secure software to update the mirrored copy in RAM and to decrypt authenticate verify update re sign re encrypt and re store the software repository stored in non volatile memory.

A computer system can be roughly divided into three component groups the hardware component the hardware software interface system component and the application programs component also referred to as the user component or software component . In various embodiments of a computer system the hardware component may comprise central processing unit CPU memory both ROM and RAM various input output I O devices such as keyboard mouse display and or printer not shown among other components. To some degree initialization firmware such as basic input output system BIOS may be considered part of the hardware component as well as part of the hardware software interface system component. The hardware component comprises the basic physical infrastructure for the computer system.

The application programs component comprises various software programs including but not limited to compilers database systems word processors business programs video games and so forth. Application programs provide the means by which computer resources are utilized to solve problems provide solutions and process data for various users machines other computer systems and or end users .

The hardware software interface system component comprises and in some embodiments may solely consist of an operating system that itself comprises in most cases a shell and a kernel. As previously noted firmware such as BIOS may also be considered part of the hardware software interface system. An operating system OS is a special program that acts as an intermediary between application programs and computer hardware. The hardware software interface system component may also comprise a virtual machine manager VMM a Common Language Runtime CLR or its functional equivalent a Java Virtual Machine JVM or its functional equivalent or other such software components in the place of or in addition to the operating system in a computer system. In addition to performing initialization tasks depending on the system BIOS may also provide some level of interface between hardware and software that isn t performed by the operating system. A purpose of a hardware software interface system is to provide an environment in which a user can execute application programs.

The hardware software interface system is generally loaded into a computer system during initialization and thereafter manages all of the application programs in the computer system. The application programs interact with the hardware software interface system by requesting services via an application program interface API . Some application programs enable end users to interact with the hardware software interface system via a user interface such as a command language or a graphical user interface GUI .

A hardware software interface system traditionally performs a variety of services for applications. In a multitasking hardware software interface system where multiple programs may be running at the same time the hardware software interface system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The hardware software interface system also manages the sharing of internal memory among multiple applications and handles input and output to and from attached hardware devices such as hard disks printers and dial up ports. The hardware software interface system also sends messages to each application and in certain case to the end user regarding the status of operations and any errors that may have occurred. The hardware software interface system can also offload the management of batch jobs e.g. printing so that the initiating application is freed from this work and can resume other processing and or operations. On computers that can provide parallel processing a hardware software interface system also manages dividing a program so that it runs on more than one processor at a time.

A hardware software interface system shell referred to as a shell is an interactive end user interface to a hardware software interface system. A shell may also be referred to as a command interpreter or in an operating system as an operating system shell . A shell is the outer layer of a hardware software interface system that is directly accessible by application programs and or end users. In contrast to a shell a kernel is a hardware software interface system s innermost layer that interacts directly with the hardware components or their device drivers and or the BIOS.

As shown in an exemplary open computing environment in which various aspects of a one time settable tamper resistant software repository can be implemented includes a conventional computing device or the like including processing unit system memory and system bus that couples various system components including system memory to processing unit . Processing unit may comprise for example a CPU Northbridge and Southbridge chipset with their well known functionality among other components. System bus may be any one or all of several types of bus structures including a memory bus peripheral bus and a local bus using any of a variety of bus architectures. System memory includes read only memory ROM and random access memory RAM . Basic input output system BIOS containing basic routines that help to transfer information between elements within the computing device such as during initialization is stored in ROM . Among other functionality such as a power on self test or POST as it is commonly known BIOS may include a computer initialization program such as a boot loader stage to load other initialization stages or load and turn over control to operating system . While the only BIOS shown is BIOS some hardware devices such as optical drives may have their own BIOS or other necessary initialization firmware which may be executed in addition to BIOS during initialization of computing device . ROM may include embedded memory e.g. within the CPU of processing unit and or one or more discrete non volatile memory devices including flash memory.

Computing device may further include hard disk drive for reading from and writing thereto operating system application programs other programs program data or other information magnetic disk drive e.g. floppy disk drive for reading from or writing to removable storage or other magnetic disk operating system application programs other programs program data or other information and optical disk drive for reading from or writing to removable optical disk such as a CD ROM or other optical media operating system application programs other programs program data or other information. Hard disk drive magnetic disk drive and optical disk drive are connected to system bus by a hard disk drive interface magnetic disk drive interface and optical disk drive interface respectively. The exemplary environment of also includes universal serial bus USB controller USB and USB device e.g. removable USB flash memory or hard disk drive . USB device is coupled to system bus via universal serial bus and USB controller . The drives and their associated computer readable media provide non volatile storage of computer executable instructions data structures program modules and other data for computing device . Similarly USB device may also comprise removable non volatile memory such as a USB flash or hard drive among a host of other devices. Although the exemplary environment described herein employs hard disk removable magnetic disk removable optical disk and removable USB device it is well known that a computing system may employ many other types of fixed and removable volatile and non volatile computer readable media. Likewise the exemplary environment may also include many types of monitoring devices such as heat sensors and security or fire alarm systems and other sources of information.

Data and any number of program modules comprising computer executable instructions such as BIOS or other initialization program operating system application programs other program modules and data such as program data can be stored on any one or more computer readable mediums such as hard disk drive magnetic disk optical disk ROM e.g. ROM EEPROM flash memories eFuses USB device RAM or any other discrete or embedded volatile or non volatile memories not shown . A user may enter commands and information into computing device through input devices such as keyboard and a pointing device such as mouse . A wide variety of other input devices not shown may include for example a microphone joystick game pad tablet or scanner. These and other input devices are often connected to processing unit through a serial port interface that is coupled to system bus but may be connected by other wired or wireless interfaces such as a parallel port game port universal serial bus USB or Firewire. Display or other type of display device is also connected to system bus via an interface such as graphics controller . In addition to display computing devices typically include other peripheral output devices such as speakers and printers not shown .

Computing device may operate in a local and or wide area network environment using logical connections to one or more remote computers such as remote computer s . Remote computer s may be another computing device e.g. personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the hardware firmware and software elements described above relative to computing device . The logical connections depicted in include a local area network LAN and wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When used in a LAN networking environment computing device is connected to LAN through network interface . When used in a WAN networking environment computing device can include modem or other means for establishing communications over WAN such as the Internet. While modem which may be internal or external to computer is shown connected to system bus via serial port interface it may be connected in a variety of other ways. In a networked environment program modules or portions thereof may be stored in a remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between computer and remote computer s may be employed.

While it is envisioned that numerous embodiments of a one time settable tamper resistant software repository are particularly well suited for computerized systems nothing in this document is intended to limit a one time settable tamper resistant software repository to such embodiments. On the contrary as used herein the term computer system is intended to encompass any and all devices capable of storing and processing information and or capable of using the stored information to control the behavior or execution of the device itself regardless of whether such devices are electronic mechanical logical or virtual in nature.

A one time settable tamper resistant software repository such as computer device can be implemented in connection with hardware firmware or software or a combination thereof. Thus the methods apparatuses and systems for a one time settable tamper resistant software repository or certain aspects or portions thereof can take the form of program code i.e. instructions and or data embodied in tangible computer readable media such discrete or embedded memories such as hard disk drives magnetic disks optical disks USB devices ROM memories flash memories eFuses or any other machine readable storage medium wherein when the program code or data is loaded into and executed or read by a machine such as computer device the machine becomes an apparatus for implementing a one time settable tamper resistant software repository. The program s can be implemented in assembly or machine language if desired. In any case the language can be a compiled or interpreted language and combined with hardware implementations. The methods and apparatuses for implementing a one time settable tamper resistant software repository also can be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer or the like. When executed by a processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of a one time settable tamper resistant software repository. Additionally any storage techniques used in connection with a one time settable tamper resistant software repository can invariably be a combination of hardware firmware and software.

Without limitation is a block diagram of an exemplary closed computing environment in which various aspects of a one time settable tamper resistant software repository can be implemented. Closed computing devices tend to be more specialized or have at least one specialized purpose relative to general purpose computing devices. Closed systems tend to have one or more specific purpose s designed to execute perhaps in addition to general programs privileged programs specifically created for them. Examples of closed systems may include for example cable set top boxes smart phones gaming consoles such as Microsoft s Xbox 360 and cellular telephones that execute one or more privileged programs. As an example of what makes the Xbox 360 a closed computing environment at least in part is that it is designed to gain restricted access to services such as Xbox LIVE and Xbox LIVE Marketplace located at http www.xbox.com. Xbox Xbox 360 and Xbox Live are registered trademarks of Microsoft Corporation One Microsoft Way Redmond Wash. 98052 6399. Xbox LIVE is a full spectrum online gaming and entertainment service. Besides providing online multiplayer gaming through Xbox Live and Xbox LIVE Marketplace customers can download purchased and promotional content to their Xbox 360 including high definition and standard definition television shows movies gaming videos music videos short feature films video games dashboard themes slideshows gamer pictures game trailers demos movies game content such as new maps weapons levels characters challenges expansions arcade games demos and trailers. Without adequate initialization and other security measures Xbox 360 gaming consoles may be manipulated for unauthorized use or access.

Game console further comprises graphics processing unit GPU which is coupled to CPU and any additional processors by a bus. GPU is also coupled by one or more busses each to memory controller I O input output hub and video codec coder decoder . Memory controller and video codec may form part of GPU . GPU in addition to video processing functionality may comprise functionality commonly referred to as Northbridge. Northbridge functionality generally comprises a high speed memory and video hub having a memory controller and a video controller. In exemplary game console both CPU and I O hub Southbridge access main memory through Northbridge functionality in GPU . Memory controller facilitates access to various types of main memory which may be RAM Random Access Memory or other variety of memory.

GPU and video codec together form a video processing pipeline for high speed high resolution graphics processing required by many game applications. Data is carried from GPU to from video codec via a bi directional bus. This video processing pipeline outputs data to A V audio video port for transmission to a television or other video display device not shown . Game console may have its own integrated display not shown . Not shown is a digital to analog converter DAC that may be coupled between video codec and A V port .

Game console further comprises I O hub which may comprise among other functionality functionality commonly referred to as Southbridge. Southbridge functionality generally performs and controls functions that are relatively slow compared to functions performed and controlled by Northbridge. I O hub comprises I O controller system management controller audio processing unit network interface controller USB host controllers and front panel I O subassembly . USB controllers serve as hosts for peripheral controllers wireless adapter and memory unit e.g. flash memory CD DVD ROM hard drive other removable media . Network interface and or wireless adapter provide access to a network e.g. LAN WAN or Internet and may be any of a wide variety of various wired or wireless interface components including an Ethernet card modem Bluetooth module and the like.

System memory may be volatile and or non volatile memory including flash memory. In some embodiments system memory may store all or a portion of the initialization program and data e.g. various boot loader stages and operating system that is loaded during the initialization boot process. In other embodiments system memory may store application data game saves and downloads. Media drive may comprise for example a DVD CD drive hard drive or other fixed or removable media reader and or writer. Game application data may be read from and or written to media via media drive for execution playback etc. by game console . Media drive is connected to I O controller via a bus such as a Serial ATA bus or other high speed connection. Game console may include hard disk which may be used for example to store all or a portion of the initialization program and data e.g. various boot loader stages and operating system that is loaded during the initialization boot process game applications game data or other types of data.

System management controller provides a variety of service functions for game console . Audio processing unit and audio codec form a corresponding audio processing pipeline that may provide high fidelity 5D surround and stereo audio processing of sounds produced by for example a game application. Audio data is carried between audio processing unit and audio codec via a communication link. The audio processing pipeline outputs audio data to A V port for implementation by a device having audio capabilities.

Front panel I O subassembly supports the functionality of various controls such as power button and eject button as well as any LEDs light emitting diodes or other indicators exposed on the outer surface of game console . System power supply module provides power to components of game console while fan cools them.

CPU GPU memory controller and various other components within game console are interconnected via one or more buses including serial and parallel buses a memory bus a peripheral bus and a processor or local bus using any of a variety of bus architectures. As previously noted not all buses or other connections and components are shown in .

When game console is powered on or rebooted aside from initialization application data and or instructions can be loaded from system memory media drive hard disc or other memory into main memory and or caches and executed on CPU . The game application being executed may present a graphical user interface that provides a consistent user experience when navigating to different media types available on or to game console . Instructions and or data accessible via media drive system memory hard disk or other memory may be launched played or otherwise accessed from these various sources to provide additional functionality to game console .

Game console may be operated as a stand alone system by connecting the system to a television or other display. As previously noted game console may have an integrated display. In this stand alone mode game console may allow one or more users to interact with the system watch movies listen to music play games and the like. Network interface or wireless adapter may allow game console to be operated as a participant in a local or wide area network community such as Xbox LIVE.

An exemplary embodiment of a one time settable tamper resistant software repository will be now be discussed with respect to . Although the embodiment refers to exemplary game console the embodiment and a wide variety of other embodiments have applicability to exemplary computing system exemplary game console and other computing environments.

Method begins with step initialization. Initialization comprises for example an initialization program for an Xbox 360 game console. An exemplary initialization program may comprise a whole or a segmented partitioned or staged initialization program. For purposes of discussion it will be assumed that the initialization program is a multi stage initialization program with reference to game console in . Upon initialization CPU may be designed to execute its first instructions stored in ROM . The first stage of initialization stored in ROM may comprise for example a first boot loader stage referred to as 1BL. Since ROM is generally limited in size first stage 1BL is designed to among other things access a second larger boot loader stage 2BL in larger flash memory e.g. system memory . Generally a primary function of various stages of initialization such as stage 1BL on ROM and various stages 2BL 4BL 5BL 6BL and 7BL on system memory is to load an operating system and in some embodiments a hypervisor for the computing device and any patches to them before turning control of game console over to the patched operating system and in some embodiments hypervisor.

The presence and number of stages in the initialization program may vary from one embodiment to the next perhaps in accordance with design e.g. the presence of ROM and fuses in the CPU and larger flash memory external to the CPU and or security measures. The initialization program may be protected or unprotected. For example one or more security measures such as global or secret constant may be embedded in one or more stages of an initialization program common to the plurality of computing devices. As another example of security measures each stage may be protected by one or more previous stages in the initialization program. In some embodiments each stage may be independently encrypted to conceal it independently signed to validate authenticity or integrity of each stage or otherwise commonly protected against tampering. Multiple common cryptographic techniques may be employed together to protect the same information. Each key may be a symmetric single secret key as in the case of DES or an asymmetric public key as in the case of RSA. Encryption may be single or multiple e.g. triple DES . For example a public key pair may be used to encrypt a secret key used to encrypt a stage. Thus each stage of an initialization program may be independently encrypted with the key s embedded in a preceding stage or elsewhere as in a key vault.

Further security measures may include for example protecting each stage of initialization with a cryptographic hash value generated by an algorithm such as SHA 1 or a keyed hash message authentication code HMAC such as HMAC SHA 1 to verify the integrity of the information in each stage. While the message and the signature accompanying it are located in the stage to be authenticated validated the key e.g. public key to analyze the message and signature may be stored in a preceeding stage or elsewhere e.g. ROM fuses . An initialization program may be rolled up in storage protected by multiple security measures and upon initialization unrolled by successfully traversing the various security measures. Various stages in an initialization program may also utilize other security measures such as using memory e.g. RAM not shown ROM fuses in the CPU or segregating RAM e.g. main memory for sensitive information or operations. Various stages may also be encoded compressed or otherwise manipulated. In addition to all other manner of security measures an individualized per computing device key may be used to decrypt authenticate and or verify one or more stages of initialization. Some embodiments may also comprise a digital rights management system such as Trusted Computing technology promulgated by the Trusted Computing Group. Game console may for example comprise a Trust Computing Module TPM not shown in . In some embodiments a digital rights management system may also influence initialization.

The per device key may be generated for example by seeding a pseudo random number generator PRNG with a truly i.e. non deterministic random number to generate a random per device secret e.g. key for use in individualizing one or more stages of a common initialization program among other potential uses. A number bearing relation to CPU such as a CPUID may be used for example if it is truly random if it is combined with a truly random seed and if it is a well secured secret within the device e.g. known only to high privilege level software . In this way it may be assured with great probability that an individualized per device secret is generated for each computing device. In some embodiments the individualized per device secret may comprise an asymmetric public private key pair. However in this embodiment the per device key is presumed to be a random symmetric key. Again this per device secret e.g. key may accompany many other secret and public keys in various layers of security. Further multiple per device secrets may be generated for each device. For example none to all of the preceding security measures discussed with respect to the common initialization program may be substituted or supplemented with individualized per device secrets. For example each stage of the initialization program may be encrypted and or signed with an individualized per device private key retained by the manufacturer. In such embodiments the individualized per device public key may be stored in non volatile memory such as in a stage preceding the stage requiring the key to decrypt the stage authenticate its signature and or validate its contents.

The individualized per device secret may be stored in the computing device for example in non volatile memory in game console . Non volatile memory includes ROM fuses system memory e.g. flash hard disk etc. One or more of the per device secrets may be embedded in the initialization program or stored independently unsecured or secured for example by encryption or signature. For example in some embodiments a per device secret key may be stored in fuses a global or constant key may be stored in ROM and a random key may be stored in each stage for use in decrypting authenticating and verifying a subsequent stage.

A per device secret may be applied to at least a portion of the initialization program to generate a per device individualized initialization program. For example a per device key may be used to encrypt at least a portion e.g. at least one stage of the common initialization program which may include instructions and or data so that the initialization program is individualized for each computing device such as game console . Alternatively or additionally one or more per device secrets may be applied to encrypt all stages of the common initialization program. In some embodiments one per device key may be used perhaps in conjunction with other per device constant or random keys to encrypt and or sign each stage of the common initialization program. The per device secret key may be applied alone or in combination with other keys per device secrets random public keys constant keys etc. to encrypt and or sign one to more stages of common initialization program. In this way the initialization of a computing device is tied back to one or more unique device identifiers i.e. per device secrets . Of course the one or more per device secrets may be used for other purposes in addition to initialization. For example the one or more per device secrets may be used to encrypt and or sign all media files programs or other input information including games input to the computing device e.g. by downloading so that the input information may only be accessed e.g. played or executed by the computing device. In this way unauthorized sharing may be prevented.

A per device initialization program may be stored in the non volatile memory of the computing device. For example a per device initialization program including programs and data may be stored in whole or in part e.g. stages in non volatile memory such as ROM fuses system memory e.g. flash hard disk etc. The physical security offered by storage in ROM and fuses in CPU may be superior to storage in system memory and hard disk . However the size of non volatile memory in CPU may generally be insufficient to store an entire per device initialization program. In some embodiments a per device secret may be stored in fuses while a first boot loader stage e.g. 1BL of the per device initialization program may be stored in ROM which may contain one or more per device secret public random or other keys and remaining stages may be stored in system memory e.g. flash memory . The difficulty of engaging in unauthorized manipulation of ROM and fuses greater protects the most physically vulnerable portion of the per device initialization program in flash memory . An image of the flash memory from one computing device may not be written to another computing device because it will not initialize unless the image is in accordance with all security measures including those in ROM and fuses .

An advantage of having a per device initialization program stored in a computing device is that a vulnerability in one device cannot be exploited en masse on other computing devices by reusing the same modified initialization program. If a hacker finds a software vulnerability in an initialization stage on one computing device and moves to exploit it or distribute it with a mod chip or otherwise as the hack exploitation is limited to one computing device. Since a hacker doesn t know all the per device secrets of all devices he cannot prepare a modified initialization stage or program that would run on all devices. Another advantage is that it makes reverse engineering by comparison more difficult because among two computing devices there are at least two per device secrets likely among many other security measures.

Thus in embodiments having an individualized initialization a per device key may be used in one or more stages of initialization . At least one individualized per device secret may be used to unlock the individualized per device initialization program comprises for example applying with reference to embodiments discussed in the per device key stored in fuses perhaps along with other keys to decrypt authenticate and or verify the contents of at least one of the stages of the per device initialization program e.g. 1BL 2BL 4BL 5BL 6BL and 7BL. The per device secret may be applied alone or in combination with other security measures. For example a per device key stored in fuses a global or constant public key stored in the 1BL stage in ROM and per stage keys e.g. per stage keys in each of 1BL 2BL 4BL 5BL and 6BL for use in subsequent stages may be used in series or combined to decrypt authenticate and or verify the contents of various stages of the individualized per device initialization program the stages of which may comprise instructions and or data. For example stage 5BL may comprise an operating system and hypervisor that stage 4BL loads decrypts decompresses authenticates and validates while stage 6BL may comprise patches to the operating system and hypervisor that stage 7BL loads decrypts decompresses authenticates and validates. The existence of stages and their purpose may vary widely among embodiments. Each per device secret may be used repeatedly as in the case of application to multiple stages of the per device initialization program to unroll it. So long as each step of the initialization successfully decrypts authenticates and or verifies each stage the initialization will continue. Otherwise it may stop perhaps issuing a message to the user or permitting the user to restore the per device initialization program required by the computing device.

In some embodiments a one time settable tamper resistant software repository may be stored in flash memory perhaps as part of an initialization stage stored therein. One or more application programs and or system programs comprising exemplary method or other embodiments may also be stored in an initialization stage in flash memory . Of course in other embodiments the software repository and program s to maintain and use it may be stored elsewhere. For instance in some embodiments they may be stored in ROM and executed within CPU without external bus traffic. During initialization the one or more application and or system programs may start executing on computing device such as game console . During initialization or soon thereafter the program s embodying method or other embodiments may unlock the software repository and for performance purposes mirror it in RAM e.g. RAM not shown in CPU or main memory . The RAM in which the software repository is mirrored may be protected by an access privilege level which may be enforced by CPU . In some embodiments unlocking the software repository may comprise decrypting it and or validating its contents. The software repository may be singly or multiply encrypted by any variety of key including a per device key. Validating the contents of the software repository may comprise the application of a predetermined hash algorithm such as SHA 1 or keyed hash algorithm such as HMAC SHA 1 to the decrypted software repository and confirming that the value generated by the algorithm used matches the value stored with the software repository. A keyed hash requires a key as an input. The key may be any variety of key including a per device key.

In some embodiments the step following initialization is step determine mode which determines the current mode of the computing device. In some embodiments step determine mode may be restricted to a high or even the highest privileged program such as the operating system or hypervisor programs. The number of modes in various embodiments may vary widely. However in embodiments where flexibility is desired there may be a mode such as a manufacturing mode allowing the software repository to be cleared. Some computing devices may have a detectable secret sequence that will place them in a manufacturing or similar mode such as the application of the sequence followed by a reboot or the application of the sequence during initialization. Of course the parameters of such a mode may vary from one embodiment to the next. Other modes may include a field operating mode that maintains the software repository in accordance with controlling software programs. Step determine mode detects the prevailing mode. Step determines whether the prevailing mode is the manufacturing mode or not. If the computing device such as game console is in manufacturing mode then the method proceeds to step exit. Step exits method . In some embodiments this may disable all security programs and permit unlimited access to volatile and non volatile memory in game console . If game console is not in manufacturing mode e.g. it is in field operation mode then method proceeds to step read software repository.

Steps are part of a cycle to take any action specified for recordable events such as security violations recorded in the software repository. In the embodiment shown in each cycle addresses each recorded event one at a time until all have been addressed and the cycle exits to step monitor recordable events. In other embodiments steps may be combined. For example a single step may mask fields in the software repository to find recorded events with active policies in one step.

Step read software repository comprises for example accessing the copy of the software repository mirrored in main memory . In other embodiments step read software repository may comprise accessing the software repository store in non volatile memory such as flash . In some embodiments access to the software repository in main memory or flash may be restricted to a high or even the highest privileged program such as the operating system or hypervisor programs. In some embodiments as shown in the software repository may be reviewed for one time settable bits indicating one or more security violations. Recorded security violations may lead to enforcement action depending on a policy associated with each particular security violation. Since the design of the software repository may vary from one embodiment to the next various examples of the content of the software repository will be presented for purposes of discussion. It is noted that while repository is used in the singular it encompasses a plurality of repositories.

In some embodiments the repository may comprise a table of bits arranged in fields. The bits may concern a wide variety of information of interest generally referred to herein as recordable events. Recordable events may pertain to security advertising or any other type of information. Without limitation some specific examples of information that may be stored in a repository include a an attempt to play a pirated or other invalid game disc b a modified console e.g. a swapped DVD player or other component c boot initialize to invalid state d invalid system file e file corruption e.g. failed integrity check of non volatile memory f targeted advertising history g system update history. The format of the data stored in the repository may be Boolean e.g. true or false string integer etc. or a combination thereof. The repository or a group of repositories may indicate whether action if any should be taken upon the occurrence of a specified recordable event. Thus the repository may store detection as well as enforcement information. For example one bit may represent a true or false indication to the query is a malicious device connected to the computing device while another bit may represent a true or false indication of whether or not the computing device will take action if true. There may be a default action or a further field may indicate what action is to be taken. Other fields may provide dates and times pertaining to events recorded in the repository.

Of course a software repository offers flexibility to adapt to changing conditions. The size and fields of a software repository may be changed through software updates. Interpretation and treatment of recordable events may vary over time. Recordable events themselves may vary over time. Memory allocated to a software repository may be reclaimed and reassigned. As one example of adaptation consider that a particular security violation is at first limited to very few computing devices. As such the policy may be to take no action. However if the security violation becomes more common then a software update may enact a policy to take action against the security violation. Further a security violation may be unknown at the time of initial release of a computing device. Thereafter one or more security violations may become apparent. Through software updates a software repository may be modified to monitor and perhaps take action against such newly discovered security violations.

Step more new recorded events determines whether there are any additional recorded events including newly recorded events such as security violations that have not yet been addressed. If there are additional recorded events then method proceeds to step read software repository for policy and if there are no further recorded events then method proceeds to step monitor recorded events. As previously addressed fields in a software repository may be used to specify one or more policies e.g. enforcement policies in response to recorded events. Policies may vary widely from one embodiment to the next but may include for example no response deny access to one or more services supported by the computing device refuse to initialize the computing device etc. Step read software repository for policy accesses the policy associated with a recorded event. Step interprets the policy associated with a recorded event. If the policy is an inactive one such as a no response policy then method returns to step to review other recorded events in the software repository. If the policy is an active one such as deny access to one or more services supported by the computing device then method proceeds to step to take the action specified in the software repository. Taking an action may entail for example executing a process dedicated to carrying out the action such as disabling access to an application or data required to provide a service. Once the action specified is taken method returns to step to review other recorded events in the software repository. When it completes all actions associated with recorded events the cycle comprised of steps exits to step to monitor recordable events.

Step monitor events may comprise for example a security algorithm that operates during or soon after initialization perhaps periodically thereafter or continuously. The security algorithm may run for example when a user attempts to log on to an online service or otherwise access a service supported by the computing device. The security algorithm may run on or offline i.e. when the computing device is not attempting to access a service. Running offline means that results of the security algorithm must be persisted in memory for use by a service provider. A security algorithm may seek to verify that the computing device and associated user seeking to access service are legitimate. Results of the security algorithm may also lead to action being taken by the computing device itself e.g. in step to deny access to one or more services it supports or other action based on a policy. A security algorithm may query various hardware and software components to provide information. For example a security algorithm may query whether a malicious or unauthorized device is connected to the computing device. The security algorithm may compare the information provided to information of record such as the serial numbers and other information stored in key vault or other secure location identifying original hardware and software. In some embodiments a security algorithm monitoring recordable events may be a lesser privileged program that calls an API to a higher e.g. highest privileged program such as the operating system or hypervisor programs to access and update the software repository in RAM and ROM. Step proceeds to step detect recordable event.

Step detect recordable event determines whether an event detected in step is a recordable event. Step requires knowledge of the predetermined list of recordable events in the software repository. If an event detected in step does not match any of the recordable events in the software repository then step returns to step to continue to monitor the computing system for a recordable event. If an event detected in step is determined to be a recordable event in step then method proceeds to steps . In some embodiments step will be aware if a recordable event has already been recorded in the software repository on a previous occasion. In some embodiments a software repository may store each occasion that a recordable event is detected. Repetitious events may be stored for example in an integer field of a software repository.

Steps update the software repository in main memory and system memory to reflect the event detected in step confirmed to be a recordable event in step . In some embodiments steps may be carried out by one or more high privilege programs such as an operating system or hypervisor. In embodiments where event detection steps and are carried out by lower privileged processes step may utilize one or more APIs to call the higher privileged program s to carry out steps . In some embodiments the code executing steps may have no ability to clear detected events. Instead the code may only be permitted to record events as an added security measure. Code able to clear recorded events may not be available at all or may only be available in for example manufacturing mode. In this way the software repository operates as a one time settable repository.

Step update mirrored table comprises for example changing one or more fields in the software repository stored in main memory or RAM not shown in CPU to record the recordable event. Steps update the permanent software repository stored in non volatile memory such as system memory . Step loads decrypts and validates the permanent software repository similar to step initialization where the permanent software repository was accessed and loaded into mirrored in privileged RAM. Step update table updates the permanent software repository similar to step to reflect the same change made to the mirrored software repository. Step signs encrypts and stores the updated permanent software repository. The encrypted signed updated software repository may be stored by an in place overwrite of the encrypted signed original software repository. In embodiments where a per device key is used and it is symmetric the same per device key is used to decrypt the repository in step and encrypt the updated repository in step . In embodiments where a per device key is used and it is asymmetric one key is used to decrypt the repository in step and the paired key is used to encrypt the updated repository in step . The series of steps after updating the mirrored and permanent software repositories returns to steps to read the mirrored software repository and take action if the policy for the newly recorded event is an active policy.

In the foregoing embodiment and in other embodiments a software runtime interface e.g. API s is are able to call a high privilege level program to affect changes in a mirrored software repository and persist those changes in a permanent software repository. The one way or one time settable function is made possible by providing no ability to reset or clear or call a malicious program to reset or clear the mirrored or permanent software repositories. This may be done with or without modes. Security measures such as permitting access only by the most privileged code encrypting and cryptographically signing the permanent software repository using a per device key perhaps in addition to other security measures such as encrypting RAM and or setting privilege levels for RAM provide tamper resistance.

There are numerous advantages to one time settable software repositories. For example unlike PROMs one time settable software repositories are flexible. Software repositories using non volatile memory may be reset to cure manufacturing errors as well as for refurbishment and resale. Thus errors can be overcome without recalls and component replacement. Software repositories may be scaled in size throughout the life of computing devices. Memory available to software repositories may be reclaimed and redistributed. Security issues may be different at initial release than they are a year later after hackers have time to work on a computing device. Software repositories may be adapted to changing security issues and policies for dealing with them. No specialized hardware such as OTP fuses are required reducing manufacturing costs and hardware failure rates. Software repositories are also not susceptible to disablement by physical blocking. Software repositories may persist security and other information protect against illegitimate warranty claims and protect against authorized manipulation and access to services among other benefits. An additional advantage of a per device key is that defects in the security system may not be mass exploitable on other computing devices each securing the software repository with a unique key.

A one time settable tamper resistant software repository has broad applicability to any system that could benefit from protecting information or services against misuse. A one time settable tamper resistant software repository not only makes it more difficult to attack systems employing it but also prevents mass exploitation of successful attacks which eliminates much of the incentive to attack computing devices in the first place. This damage control security measure could save manufacturers and service providers from costly recalls and lost business due to application service or media piracy.

While a one time settable tamper resistant software repository has been described in connection with the example embodiments of the various figures it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiments for performing the same functions of a one time settable tamper resistant software repository without deviating there from. Therefore a one time settable tamper resistant software repository as described herein should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

