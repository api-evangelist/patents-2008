---

title: System and method for the generation of navigation graphs in real-time
abstract: A system and method for navigation graph generation in real time is provided including a dictionary operable to maintain information mapping surface features to navigational costs. Further included is a graphical module operable to transform geometrical data of a virtual world and associated navigational costs obtained from the dictionary into navigation data; a graph-generation module operable to translate the navigation data into a semi-generated navigation graph; and a physical module operable to receive the semi-generated navigation graph, and generate an updated navigation graph based on collisions test.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08111257&OS=08111257&RS=08111257
owner: Aiseek Ltd.
number: 08111257
owner_city: Ramat-Gan
owner_country: IL
publication_date: 20080122
---
This application claims benefit of U.S. provisional application No. 60 905 045 filed on Mar. 6 2007 which is incorporated by reference herein in its entirety.

The present invention generally relates to computer graphics and computer game artificial intelligence AI and more particularly to the generation of navigation graphs from raw geometry using computer graphics techniques.

The following U.S. patents and publications provide useful background information for which they are incorporated herein by reference in their entirety.

One of the requirements of artificial intelligence AI modules that are utilized in computer games and military simulations is to provide agents i.e. game entities with capabilities to accurately determine their motion in a three dimensional 3D environment or the game s virtual world.

The agents in a game use pathfinding algorithms to plan their path in the virtual world. Typically these algorithms are based on searching navigation graphs in order to find a minimal path on the graphs and then smoothing the path so the agent movement will look more natural. Navigation graphs are graphs with additional spatial information describing where an agent can move.

The navigation graph can be manually prepared by a game developer or automatically by a graph generation process. This process produces and updates the navigation data from geometrical and physical data of the virtual world which include a description of the objects their properties and how they interact in the 3D environment.

When a computer runs an electronic game the game engine automatically downloads the geometrical data and stores it in a local memory. Today this information is used primarily for visualizing the virtual world to the player and for detection collision but not for graph generation. The graphic processor renders the portions of the world that are visible from the player s current viewpoint i.e. position and orientation within the virtual world. As the player navigates the virtual world new objects may become visible while others pass from view.

In the related art there are several techniques for generating navigation graphs. One technique is the physical based expansion which generates the graph by moving the agent systematically through the virtual world space using a game engine and checking for collisions. Specifically this technique moves using a game engine an agent object in all directions each time in a small distance. Each point the agents visits is also expanded in the same fashion until the entire space is exhausted.

Another technique for graph generation is known as the visibility graph building. This technique builds a navigation graph by placing nodes at all the vertices of the graphical objects and connecting only nodes that are visible to each another i.e. an agent can move between these nodes in a straight line . A variant of this technique uses triangulation technique to form a navigation mesh made of triangles. A triangle is detected by scanning the angles around a node and finding an open sector. The vertices of polygons bounding that sector and the origin form triangles. At the beginning the node to be scanned for triangles is an origin and later all the edges.

Yet another technique for graph generation is the volume filling voxelization which tries to place an agent iteratively at all positions of the virtual world. If the agent can occupy two adjacent positions and a predefined set rules regarding their difference in height or in slope are satisfied the objects are deemed connected. The rules for deciding which agents to connect may be based on the agents type e.g. humans or animals.

One of the major drawbacks of related art techniques is the substantial execution time of these techniques. As a result the navigation graphs are generated off line i.e. when the game is created. Thus dynamic scenes cannot be rendered in real time i.e. when the game is played and thereby limiting the game experience. For example only few obstacles in the walk path can be added dynamically.

Therefore it would be advantageous to provide a real time solution for the generation of navigation graphs.

To realize some of the advantages described above there is provided an apparatus and a method for generating navigation graphs in real time. The apparatus may include a dictionary operable to maintain information mapping surface features to navigational costs a graphical module operable to transform geometrical data of a virtual world and associated navigational costs obtained from the dictionary into navigation data a graph generation module operable to translate the navigation data into a semi generated navigation graph and a physical module operable to receive the semi generated navigation graph and generate an updated navigation graph based on collisions test.

In an enhancement the apparatus may further include a pre graph module adapted for determining which parts of the virtual world have changed and a post graph module adapted for minimizing the size of the updated navigation graph.

More specifically in the above enhanced apparatus the graphical module may be coupled to a rendering subsystem.

In an enhanced implementation the transforming of the geometrical data into navigation data may include receiving geometrical data of at least one region in the virtual world and rendering using the rendering subsystem a plurality of bitmaps which form the navigation data.

More specifically the geometrical data may comprise polygons describing at least objects surfaces and obstacles in the region.

More specifically the plurality of bitmaps may include information about properties of a terrain in the region.

In an enhanced implementation the graph generation module may produce the semi generated navigation graph by translating the bitmaps into nodes edges and weights.

More specifically the translation decisions may be performed based on the mapping information in the dictionary.

In an enhanced implementation the graph generation module may mark areas in the semi generated navigation graph that can not be inferred from the bitmaps.

Even more specifically the collision tests may be performed using a game engine coupled to the physical module.

In an enhanced implementation the physical module may be further operable to update the mapping information based on results of the collision tests.

The method for generating a navigation graph in real time may include retrieving geometrical data of at least one region in a virtual world of a computer game. The method may further include retrieving mapping information for said at least one region rendering a plurality of bitmaps of navigation data using the geometrical data and the mapping information generating a semi generated graph using the bitmaps and generating the navigation graph based on collision tests performed on the semi generated graph.

Computer program products including a computer readable medium having software instructions to enable a computer to implement the above techniques are also within the scope of the disclosed teachings.

Specifically an implementation may include a computer readable storage medium storing instructions to enable a computer to execute a method for generating a navigation graph in real time the method comprising retrieving geometrical data of at least one region in a virtual world of a computer game retrieving mapping information for said at least one region rendering a plurality of bitmaps of navigation data based on the geometrical data and the mapping information generating a semi generated graph based on the bitmaps and generating a navigation graph based on collision tests performed on the semi generated graph.

The system comprises a graph generation module a graphical module a dictionary and a physical module . The graph generation module queries the other components of system in order to learn about the virtual world and to produce the navigation data. The process of producing the navigation data is initiated by the game engine. The graphical module receives geometric data and uses rendering techniques to transform them into navigation data useful for graph generation module . The graphical module interfaces with an external rendering subsystem such as a GPU. The physical module sends collision queries to a game engine and processes the returned results. The game engine holds the information on the virtual world in which the game is played and provides checks about whether an agent can walk somewhere. For the purpose of interfacing with the game engine the physical module implements an application programming interface hereinafter the world interface .

The dictionary includes per non player character NPC mapping information of surface features to navigational costs. The surface features include but are not limited to material width of passages slopes steps heights and so on. Specifically the mapping information describes the movement abilities of different NPCs in terms of costs. For example as shown in the cost for climbing steps with height differences of 0 0.5 meter 1 meter and 1.5 meter is 0 1 2 and 3 respectively. The cost can also be infinite for example a maximal step beyond which an agent cannot climb 2 meter in the table shown in . The cost between entries in the dictionary is interpolated. For example to compute the cost of a 1.2 meter step height linear interpolation may be used. As will be described in detail below the mapping information is created and updated using collision tests performed by the physical module .

In alternate implementations of the disclosed teachings the system may include post graph module adapted to minimize the size of the generated graph. Alternatively or collectively the system may include a pre graph module adapted to determine which parts of the virtual world have changed in order to reduce the time required for updating a graph.

As mentioned above the graph generation module controls the other components of the system using a set of queries. Specifically the module is initiated by the game engine which submits a Graph Generation query to the module . The query includes information of region s to be processed and one or more generation parameters for which the graph is to be generated. These parameters include but are not limited to required resolution a list of NPC types and so on.

The graph generation module submits an Instance Request to the game engine through the physical module in order to fetch the polygons describing objects surfaces and obstacles in the generation region s or in region s that should be updated. The physical module passes the retrieved polygon data to the graph generation module which in turn passes this data together with relevant navigational costs fetched from the dictionary to the graphical module .

The graphical module utilizes the rendering subsystem to render the geometry of a scene orthogonally from above and produces several bitmaps describing properties of the terrain and geometry. These properties include at least heights and slopes of surfaces walk able surfaces and surface material. In addition for each NPC the graphical module determines locations in which the NPC can stand cannot stand can pass through and cannot pass through. In accordance with an exemplary implementation of the disclosed teachings six bitmaps are rendered a a terrain map showing the slopes in x y directions and the floor material b a height map of the floor in each position c a last height map including last floor height map in each position d a roof height map including the height of the roof in each position e an extrusion map describing the maximum floor height in a certain radius relative to the floor height minimum roof height in a certain radius relative to the floor height minimum of difference between floor height and roof height in a certain radius and f a weight map including the weights in a grid for a single direction or multiple directions. In other implementations different steps order may be used to render the bitmaps. The weight map may be in the form of a table that includes the cost of moving between two adjacent nodes locations . The weights may be normalized to one.

The bitmaps are produced per level by rendering the geometry of the scene below the last level floor corresponding to the floor in the last level bitmap b discussed above . It should be noted that a level is a general 2D manifold and not merely a floor at the same height.

The graphical module together with the rendering subsystem renders the above bitmap for each level floor in five rendering stages. At the first stage the rendering subsystem finds a new level floor such as the floor shown in . At the second stage a new roof above the new level floor and below last level floor is detected. At the third stage the height and slope of the walk able surface above new floor and below new roof is detected. For example the ground marked as in . At the fourth stage the extrusion is performed to determine the maximum height and width of a NPC which can stand at each position without colliding. At the fifth stage for each direction the weight to move between two adjacent nodes locations is determined using rendered data and navigational costs received from the dictionary .

Each of the first second and third stages is processed in two passes. Firstly the scene is rendered in solid mode i.e. rendering the entire triangle and secondly rendering the scene in wire frame mode i.e. rendering the edges of triangles . This is done to ensure the visibility of triangles which are perpendicular to the rendering plain. It should be noted that the two passes are required if using a GPU. If using dedicated a dedicated software program only the second pass may be needed.

The fourth and fifth stage can be performed using an array processor such as the processor described in U.S. patent application Ser. No. 11 089 029 entitled Techniques for path finding and terrain analysis assigned to common assignee and which is hereby incorporated by reference here in its entirely. This rendering process is repeated for each new level floor for example shows the floor below the floor level .

The graph generation module translates the bitmaps to nodes edges and weights thereby producing a semi generated graph for example in the form of a grid. This is performed using mapping information stored in the dictionary to make translation decisions on areas that can be inferred from the graphical data bitmaps . In addition the graph generation module detects and marks areas e.g. borders where clear translation decisions cannot be taken. As illustrated in a ground surface of the cave is determined using graphical module and the areas near the cave s walls using the physical module . It should be noted that nodes and edges are not generated for objects which are encapsulated within another object.

The semi generated graph is sent to the physical module which completes the graph by submitting collision queries to the game engine and analyzing the responses. Specifically the physical module holds a list of place NPC combinations that need to be tested. For each such combination the module submits a collision query to the game engine . The results returned from the game engine are analyzed and inserted in the graph as well in to the dictionary . The physical module calculates the navigation time of an agent. For example when the agent performs a walk action the module walks the agent to an adjacent node from its current location and measures the time.

To accurately generate the graph the physical module should process accurate collision information. However in certain cases game engines cannot produce such accurate information by a single test because they keep internal hidden variables per agent. The physical module can handle several very common cases of hidden variables without making any modification to game engine but merely by querying the game engine .

An example for such a common case is a collisions system relying on a body s skin when processing collision queries. A skin is a region enveloping the body. The game engine detects a collision as an overlap in skins which can then be corrected without causing overlap in the core bodies. This results in situations where the skin is being squeezed and a body can be placed very close to another body but reported as not a collision . Cases where an agent is put near the body without that variable being set for the agents may result in an inaccurate graph. For example a NPC may be placed near a wall and its skin may go across the wall. This problem is resolved by the physical module and its world interface by testing twice near bodies. One test is performed without skin and the other with the skin. In the case described above the movement into the wall generates no collision with a skin but does generate a collision without the skin.

One of the tasks executed by the physical module includes creating and updating the mapping information in the dictionary . With this aim mapping information is derived from collision tests. For example if a NPC can pass through a 2 meter wide passage in a normal terrain it is determined that the NPC can pass through any passages wider than a 2 meter wide passage.

As mentioned earlier the dictionary includes mapping information that maps certain surface features to costs. These features may include but are not limited to passage height i.e. how different roof heights affect the movement cost passage width i.e. how different width affects the movement cost step height slope fall height the material of the surface and so on. In an exemplary implementation the dictionary maps a combination of a NPC an action performed by the NPC the surface material and one or more surface features to a list of value cost pairs. As an example for a NPC walking on a slippery floor versus a regular floor the costs of different slopes may be 

In accordance with another exemplary implementation of the disclosed teachings the generated graph may include non navigational costs. That is some movements harm the character agent which commits them. For example a character walks out of a third floor balcony usually reaches the ground quite quickly but not in a good shape. This is accounted in the generated graph by marking on each edge whether it is lethal. Edges marked as lethal can be ignored by a path finding process.

It should be noted that the method system the components of system can be implemented in software hardware firmware or any combination thereof.

Other aspect of the disclosed teachings is a computer program product including a machine readable media comprising instructions. The instructions are capable of enabling a computer to implement the techniques described above. It should be noted that the machine readable media could be any media from which a computer can receive instructions including but not limited to hard disks RAMs ROMs CDs magnetic tape internet downloads carrier wave with signals etc. Also instructions can be in any form including source code object code executable code and in any language including higher level assembly and machine languages. The computer system is not limited to any type of computer. It could be implemented in a stand alone machine or implemented in a distributed fashion including over the internet.

While the disclosed teachings has been particularly shown and described with reference to exemplary implementations thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the disclosed teachings as defined by the appended claims.

