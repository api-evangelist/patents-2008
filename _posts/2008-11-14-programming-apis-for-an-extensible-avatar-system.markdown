---

title: Programming APIS for an extensible avatar system
abstract: Disclosed is an application programming interface (API) that provides for an extensible avatar system. In one embodiment an API may allow video game applications to retrieve structures of data which represent an avatar. The game can then take those structures and incorporate the data into its own rendering system. In another embodiment an API may allow a video game application to render an avatar to a render target or texture wherein the video game system performs rendering and animation functions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08446414&OS=08446414&RS=08446414
owner: Microsoft Corporation
number: 08446414
owner_city: Redmond
owner_country: US
publication_date: 20081114
---
This application claims priority to U.S. Patent Application No. 61 080 626 entitled Extensible Avatar System filed on Jul. 14 2008.

This application is related by subject matter to the subject matter disclosed in the following commonly assigned applications the entirety of which are hereby incorporated by reference herein U.S. patent application Ser. No. 12 178 535 titled System for Editing an Avatar U.S. patent application Ser. No. 12 184 990 titled Avatar Items and Animations and U.S. patent application Ser. No. 12 189 067 titled Avatar Closet Game Awarded Avatar. 

Video games sometimes feature a user created avatar as a user controlled character. Typically a user may customize the avatar in a variety of ways dealing with appearance such as facial features and clothing. This allows the user a more personalized and involved video gaming experience. For instance the NINTENDO CORPORATION has a user created avatar the MII which a user may then use as his or her user controlled character in video games that support this feature such as WII SPORTS .

While avatars may be created on the system or in a particular game it is often desirable for a user s created avatar to be available for use by various video game applications. For instance players may desire that an avatar associated with the player be available for incorporation into new video game applications without having to recreate the avatar. Furthermore it may be advantageous for the video game application to use the video game system s rendering functions and incorporate the rendered avatar into the game output rather than providing its own avatar rendering functions. In either situation it would be advantageous for video game applications to be able to access application programming interfaces APIs that allow the applications to access avatar information into their own rendering functions or to incorporate system rendered avatars into the application s outputs.

In various embodiments of the present disclosure a method system and computer readable medium are provided to implement an API for programming avatars. Such an API may allow video game applications to retrieve structures of data which represent an avatar. The application can then take those structures and incorporate the data into their own character system so that they can render and animate the avatars in the application s context using the application s code.

An API may also allow applications to render an avatar to a render target with the system handling the rendering and animation. The video game application can trigger animations or rely on idle animations to play and the animations may be rendered to a two dimensional surface that the video game application may then present.

In some embodiments the avatar system may be designed so that the API may deliver avatars accessorized e.g. dressed with accessories e.g. t shirts that are released after the game itself has been released with no adverse effects on the video game application. Resources may be pre allocated in such a fashion that new accessories do not occupy additional resources that the video game application is expecting to be available for other purposes.

In an embodiment the avatar system may also be designed so that the retrieval of avatar assets may be executed by the console or online system which may then be updated independently of the game application. This may allow the console or online service to change the logic for avatar asset retrieval without requiring changes to the game application. For example while a console might initially retrieve assets only from local storage in other cases assets may for example be retrieved from the internet.

It should be noted that this Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In the case of online game playing other users such as user B and user C could interact with the first user if such online game playing was mediated by a central server. In the example shown in such avatars that were associated with the first user could be seen by the other users however these avatars have limited ability to be updated and animated.

In any event shows that in one aspect of the presently disclosed subject matter avatar X may have applied to it animation that is specific to the avatar e.g. the hat example discussed above . On the other hand avatar Y may have animation that is applied to the entire body of the avatar e.g. the dance example discussed above . In either case or in other cases the avatars may be user determined or they may be game determined . This means that users may accessorize the avatars via some interface or such avatars may be accessorized by gaming titles . In this latter scenario if the user is playing a game and unlocks an achievement in the game the reward for such achievement may be animation items that then may be applied to the user s avatars whether to the avatars in a specific game or to the avatars in general for several or all games.

There may be various triggering mechanisms for applying such item content to avatars. For example one such mechanism can include a user interface that allows users to select which items to apply to which avatars. Alternatively or in addition to game titles themselves can be a trigger for applying item content to avatars depending on the implementation and user interaction with a gaming console hosting such an avatar engine . Yet in other aspects of the present disclosure the avatar engine may reside on hosting server and any processing may be performed upstream from users.

Thus a system may be used for animating gaming console avatars in a plurality of different ways where the system may be loaded in local computer memory and where it may be executed by a physical processor. In such a system a processing module may be configured to process an accessory package containing a plurality of animation items. Another module the identification module may be configured to identify avatars and animation items from the plurality of animation items. And still another module the application module may be configured to apply the animation items to the avatars.

This system may accommodate various other aspects such as having animation items applied to the avatars at least in a first game title and a second game title . Moreover the animation items may be configured to be applied to the avatars while the first game title is playing . In other aspects animation items may be further configured to be applied to the avatars while the second game title is playing . The first game title and the second game title may be distinct from each other in that they may be loaded separately at time t and at time t .

It will be readily appreciated that other instructions may be used in conjunction with the aspects discussed above such as instructions configured to carry at least one item between or across different game titles instructions configured to present to a user the option of accessorizing any avatars during the execution of games instructions configured to trigger and manage animation in different ways such continuous event user and idle animation instructions configured to apply animation in specific ways such as item based and avatar based or using different mechanisms such as user interface and game titles . It should be noted that other instructions that embody the various aspect discussed above may be used.

At the process flow begins. This process may be triggered in response to a user beginning execution of a video game on a video game console that is connected to the online video game service. For example the user may power on the console insert a disc that contains computer readable instructions comprising the game and send an access credential that uniquely The service itself may comprise one or more servers through which online multiplayer video game play is validated and exchanged between users a game match making service that groups users together into a gaming session an e commerce marketplace a message board and a live chat room. The user s avatar may appear in many areas of such a service. For instance it may appear in a user s profile on the service or as a part of any posts the user makes to a message board.

Operation depicts receiving while executing the game an instruction from a user to update the appearance of the avatar. While the user is playing the game he or she may be inspired to change the avatar s appearance. In such an instance the user may enter a command that calls up an avatar editing screen. For example the user may press a dedicated button on his or her controller keyboard or other input device which brings up a list of commands to be performed. From there the user may select the command corresponding to editing the appearance of the avatar. While these commands are being entered the action in the underlying game may continue on or be suspended. The choice between those two options may be made either by the system the game is executing on or by computer readable instructions in the game itself. In one embodiment receiving an instruction from a user to update the appearance of the avatar includes suspending active play of the game.

Operation depicts updating the appearance of the avatar. The appearance may be any physical aspect of the avatar such as a hair color a hair length a hair style a facial hair color a facial hair length a facial hair style a facial hair position an eye color an eye style an eye position a nose style a nose position a mouth style a mouth color a mouth position an ear style an ear position a skin color a height a weight or a body build.

In an embodiment updating the appearance of the avatar includes overlaying an editor window on top of the game and receiving at least one instruction from the user on how to update the appearance of the avatar. For example the mechanics of updating the avatar may be controlled by the system that the user is playing the game on rather than the game itself and the system may render the editor window over the game window before sending the rendered frame to the user s visual display device. When presented with such a window the user may then send an instruction on how the avatar is to be updated. For instance the user may click on the avatar s eyes then select a new eye color from a list of available colors changing the avatar s eye color from green to hazel.

Operation depicts instructing the server to store the updated avatar. This may include displaying an error message to the server when an indication from the server that it stored the updated avatar is not received within a period of time. Where the server is connected to the user s game system over a communications network there may be times where the user updates the avatar but the communications network fails to send the updated avatar to the server. In such a case the user may typically appreciate notification that the changes made to the avatar were not saved. In another embodiment the changes may be saved locally on the user s game system and further attempts to send the updated avatar to the server may be made until such sending is successful.

Operation depicts instructing the game to load and display the updated avatar. Where the sole non volatile storage medium for an avatar exists on the server this may include instructing the game to receive the updated avatar from the server. In another embodiment the game may read the updated avatar directly from local memory. In the embodiment where the user is playing an online multi player video game comprising a session and a plurality of other users participating in said session and said instructing the game to load and display the updated avatar may include instructing each other user s video game to load and display the updated avatar. That way the user s avatar will have a consistent appearance for all participants in the multi player game. This may also include instructing each other user s video game to load the updated avatar after play has been suspended for all other users of the session. It may be confusing to another user when the user s avatar suddenly changes during game play and a malicious user may rapidly change the appearance of his or her avatar to annoy other users. This can be avoided where avatar changes propagate to all users only when play has been suspended such as when a match concludes or all players are paused. This said instructing each other user s video game to load the updated avatar may also include notifying each other user that the user s avatar has been updated. It may be confusing for another user if the user s avatar changes without explicit indication of such and a notification such as a pop up window stating this change may mitigate this problem.

Operation depicts the optional step of storing the updated avatar on the user s game system wherein the user is playing the video game on a game system. Where communications with the server occur slowly storing the avatar locally may improve the user experience by speeding up load times.

A user uses a computing device to execute a game . In an embodiment of the present disclosure the user connects to an online gaming server through a network .

The server comprises a processor a module to receive an instruction from a user to update the appearance of the avatar a module to update the appearance of the avatar a module to store the updated avatar a module to instruct the user s game to load and display the updated avatar a database in which to store an avatar user pairs and a module to check at least one credential .

The computing device may be a dedicated video game console or a more general computing device such as a cellular telephone or a personal computer. The computing device may be configured to execute a plurality of games. It may have an optical drive and allow for a variety of games to be executed from computer readable instructions stored on optical discs. The games may be stored on a storage device within the computer such as a hard drive or solid state drive.

Where the user wishes to update the appearance of the avatar he is using in a video game that he is currently playing he or she may issue an instruction to the server to update the appearance of said avatar which is received by the module to receive an instruction from a user to update the appearance of the avatar . That instruction is then passed to the module to update the appearance of the avatar . When the appearance of the avatar has been updated a signal is sent from that module to the module to store the updated avatar which stores said avatar in the database . The database may store pairs that identify the user and said avatar. Where a user may have a plurality of avatars at one time the database may store the user and the avatars separately along with an indication of which avatar corresponds to which user. The module to update the appearance of the avatar also sends a signal to the a module to instruct the user s game to load and display the updated avatar which sends a message to the user s computing device to instruct the game to load and display the updated avatar.

Where a security system is in place the server may also pass all communications from the user to update the appearance of the avatar through a module to check at least one credential of the user. Where the credential check passes the user s instruction is processed as above. Where the credential check fails the user s instruction is not executed. In an embodiment a message telling the user that the credential check failed may be send to the user s console for display to the user.

Where the user updates the avatar while playing on the service with other users through their respective computing devices when the server sends a message to the user s console to load and display the user s updated avatar it may send a message to the other users consoles to also load and display the user s updated avatar.

At the process flow begins. This process may be triggered in response to a user beginning execution of a video game on a video game console that is connected to the online video game service. For example the user may power on the console insert a disc that contains computer readable instructions comprising the game and send an access credential that uniquely The service itself may comprise one or more servers through which online multiplayer video game play is validated and exchanged between users a game match making service that groups users together into a gaming session an e commerce marketplace a message board and a live chat room. The user s avatar may appear in many areas of such a service. For instance it may appear in a user s profile on the service or as a part of any posts the user makes to a message board.

Operation depicts receiving a message indicative of the user obtaining access of the item for use with the avatar. For example the message may be received from the game when the user achieves an accomplishment in the game associated with the item. The accomplishment may be for instance beating a level or purchasing it in the game with in game currency. The message may be received in response to the user purchasing the item from an e commerce store that is associated with the service. For example the message may be received in response to the user receiving the item as a gift. For example a sponsor could allow users access to an item comprising shoes that look like actual shoes that the sponsor produces.

This operation may include the case wherein the item has a creator and said receiving a message indicative of the user obtaining access occurs after receiving a message from the item creator to store the item. In some cases the item may be created by a game developer outside of the service. Where that is true the item creator may send a message to the service indicating that the item is to be stored by the service for future use by users with their avatar.

In some instances the creator has at least one credential the message includes the credential and receiving the message from the item creator to store the item includes validating each credential.

Operation depicts storing an indication that the avatar may use the item. Where an embodiment contains a database in which are stored avatars and items the indication may comprise a third field such that for every avatar item pair there is a corresponding May use field that indicates either yes or no.

Operation depicts directing a first game to display the avatar with the item. Where the item comprises a hat said displaying may comprise having the avatar wear the hat on his or her head where the avatar is displayed. Where the item is a non clothing accessory such as a fly swatter or a giant foam We re 1 novelty hand said displaying may comprise having the avatar holding or otherwise manipulating the item where the avatar is displayed.

In an embodiment said directing the first game to display the avatar with the item includes receiving a message from the user to display the avatar with the item.

In an embodiment said first game is an online multi player game comprising a session and at least one other user. An online gaming service may have many sessions or instances of a particular game active at a single time. Typically a user participates in no more than a single session of the game at any time. In such an embodiment said directing the first game to display the avatar with the item includes directing the game of each other user to display the avatar with the item. This will cause each other user who is playing the session with the user to see the updated avatar. This will ensure consistency for all users in the gaming session.

In an embodiment said directing a first game to display the avatar with the item includes directing the first game to download the item from at least one server. In an architecture where all items are stored on a server and a subset of the items are stored on the user s computing device the first game may require local access to the item.

Operation depicts directing a second game to display the avatar with the item. The avatar exists across the entire service so while an item may be obtained in the first game it is available for the avatar in all other aspects of the service. Where the user obtains an item for his or her avatar directs that his or her avatar be displayed with the item then begins playing a second game that supports avatars the avatar will be displayed with the item in the second game as well.

Operation depicts the optional step of displaying the avatar with the item on a message board posting associated with the user. Where the service comprises a message board users may post to the board to communicate with each other. Attached to each post may be the user s name the time at which the post was made and a representation of the user s avatar. The representation may comprise less than the entire avatar such as a still image of the avatar from the neck up facing forward. Where the user s avatar is displayed with the user s message board posts and the user has set the avatar to be displayed with the item in an embodiment the image of the user s avatar corresponding to the message board posting includes the item.

Operation depicts the optional step of displaying the avatar with the item on a profile associated with the user. A profile comprises information about the user such as real name home page age interests and a personal quote. Where the service comprises a user profile the profile may comprise a representation of the user s avatar. The representation may comprise less than the entire avatar such as a still image of the avatar from the neck up facing forward. Where the user s avatar is displayed in the user s profile and the user has set the avatar to be displayed with the item in an embodiment the image of the user s avatar corresponding to the message board posting includes the item.

Operation depicts the optional step of displaying the avatar with the item in a live chat in which the user is participating. A live chat comprises a communications session where a plurality of users communicate with each other in near real time. It may comprise text audio video or some combination thereof. In an embodiment where the user participates in a live chat all participants in the chat see a representation of the user s avatar. The representation may comprise less than the entire avatar such as a still image of the avatar from the neck up facing forward. Where the user s avatar is displayed in the user s profile and the user has set the avatar to be displayed with the item in an embodiment the image of the user s avatar corresponding to the message board posting includes the item.

Operation depicts the optional step of directing the user s computer to store the association between the item and the avatar wherein the user accesses the service through a computer. It may be beneficial for the user s computer to store the association between the item and the avatar so as to reduce access time by storing the information locally.

Operation depicts the optional step of directing the user s computer to store the item wherein the user accesses the service through a computer. It may be beneficial for the user s computer to store the item itself so as to reduce access time by storing the information locally.

A user uses a computing device to execute a game . In an embodiment of the present disclosure the user connects to an online gaming server through a network .

The server comprises a processor a module to receive a message indicative of the user obtaining access of the item for use with the avatar a module to store an indication that the avatar may use the item a database to store user avatar item triplets a module to direct a first game to display the avatar with the item and a module to direct a second game to display the avatar with the item .

The computing device may be a dedicated video game console or a more general computing device such as a cellular telephone or a personal computer. The computing device may be configured to execute a plurality of games. It may have an optical drive and allow for a variety of games to be executed from computer readable instructions stored on optical discs. The games may be stored on a storage device within the computer such as a hard drive or solid state drive.

The user may obtain access to an item with his or her avatar. The user may obtain this from a variety of sources. It may be a gift from another user who is accessing the service through a computing device . The user may obtain the item as a reward by achieving a goal in the game associated with the avatar such as beating a level or obtaining a threshold score. The user may also purchase the item from a e commerce marketplace offered by the server .

When the user has obtained access to the item a corresponding message is sent to the module to receive a message indicative of the user obtaining access of the item for use with the avatar . In an embodiment said module includes a module to receive a message from the user to display the avatar with the item. In an embodiment said module to receive is configured to receive the message from the first game . Said module processes the message and then send a message to the module to store an indication that the avatar may use the item . That module stores said indication in the database . In an embodiment a user may have a plurality of avatars and the item is restricted to a single avatar. In an embodiment when a user obtains access to an item and may have a plurality of avatars the item may immediately be used by all of the user s avatars. In an embodiment the user has a single avatar and all items that the user obtains access to correspond to that one avatar.

The module to direct a first game to display the avatar with the item sends a message indicative of such to the first game via the user s computing device through the network . The first game receives the message and displays the user s avatar with the item.

Where the user later plays a second game the module to direct a second game to display the avatar with the item sends a message indicative of such to the second game via the user s computing device through the network . The second game receives the message and displays the user s avatar with the item.

In various embodiments video game applications may use a set of programming APIs that enable incorporation of avatars into the video game application. APIs may allow video game applications to retrieve structures of data which represent an avatar. In one embodiment the video game application can then take those structures and incorporate the data into their own three dimensional character system so that they can render and animate the avatars in the game s own three dimensional environment using the game s own code. APIs may also allow video game applications to render an avatar to a render target or texture with the host system or application performing all rendering and animation functions. The video game application may trigger animations or rely on an idle animation to play but they may be rendered to a two dimensional surface that the video game application may then present.

In an embodiment an API may allow a video game application to access a full body static shot of the avatar that may be saved with a user s profile. Typically a video game application can retrieve a user s gamer picture and use that picture as the user s representation in the game. However the picture will typically be a small e.g. 64 64 or 32 32 image. In one embodiment a video game application may access a larger display of the avatar such as a full body static image without using the rendered moving avatars.

In an embodiment the API family and the relevant system components may allow newer avatar accessories to be released after the release of the game. The new avatars may still appear in the game regardless of which API family is being used. The APIs may deliver avatars accessorized e.g. dressed with accessories e.g. t shirts that are released after the game itself has been released with little or no adverse affect on the video game application.

In further embodiments components of the API may be part of a video game platform for example in the game console and may be updated independently of the video game application to change the asset retrieval logic. The host system or platform may provide a host application that executes in conjunction with the video game application providing various services and providing access to information and resources via the API. The avatar system may be designed so that the retrieval of avatar assets may be performed by the host system or application the specific logic which may be updated independently of the title. The logic for avatar asset retrieval may thus be changed at a later time. For example while assets may initially be retrieved from local storage the system may be updated to retrieve assets from the internet Resources may thus be pre allocated in such a fashion that newer accessories do not occupy additional resources that the video game application is expecting to be available.

In an embodiment a video game application may use one or both of two API families one of which allows the video game application to receive raw data to construct render and animate the avatar themselves the other in which the system renders an animated avatar to a destination provided by the video game application.

As mentioned above one group of APIs can be used by video game applications to retrieve either raw data which can be used by the game s own code to construct render and animate avatars in their own three dimensional environment. Another group of APIs can be used to render given users avatars to desired render targets or textures.

If some of the code runs in the system rather than in the video game application the internal behavior of these APIs can be updated after release allowing for example alternate retrieval mechanisms to be used.

The following exemplary description of an avatar API may be better understood in conjunction with the exemplary functions provided in the Appendix. While the described API discloses one embodiment those skilled in the art will understand that many such implementations may embody the disclosed principles. Support for avatars in the API may include two interfaces IXAvatarRenderer may be used by developers to render an avatar into a given device. Developers may use IXAvatarAnimation to move the parts of an avatar through a predetermined series of movements. Functions for creating IXAvatarRenderer objects and retrieving IXAvatarAnimation objects may be included in the API. Developers who render avatars using their own game engine may use the XAvatarGetAssets function to retrieve the low level description of an avatar.

Video game applications may use avatars by retrieving avatar data and then rendering the avatar to a device. Video game applications may use the IXAvatarRenderer interface to perform the rendering or they may load the avatar data using XAvatarGetAssets and then render the data themselves.

Avatars may be available in both male and female versions although the same skeleton may be used for both thus making animations easier to design. Facial animation may be done by animating textures. For example eye textures may have five different directions up down left right and center and eye motion may be accomplished by switching textures to look in different directions.

Height and body weight may be controlled by linearly scaling joints in the skeleton from the middle standard. The scaling factor may be varied as desired by the system.

Video game applications may use avatars to represent players. In multiplayer games the avatar may be shown in the game lobby or other suitable application next to other information about the player. In games where it is appropriate the avatar may be used in actual game play to represent the player.

The avatar system is not only useful for representing players avatars but since avatars appear as humans the avatar system may also be used to render human non player characters in a game including spectators extras game show hosts and the like. Video game applications may request randomly generated avatars so that no two crowds will look the same. Video game applications may load the avatars of signed out profiles on the console to show a player s family s avatars proudly looking on at the end of a race or cheering the player from the sidelines.

Avatars are typically intended to provide a broadly appealing experience to gamers of various demographic groups. For example avatars may represent the player s identity as on a game lobby but may also adhere to rating systems such as the Entertainment Software Rating Board s ESRB E10 rating. Similarly the animation style used for avatars may be rational and naturalistic and avatar movement may be dynamic and smooth.

A typical technical consideration in a video game application s use of avatars is how the avatars will be rendered and animated. The avatar system may include a built in renderer that can be used in video game applications that wish to incorporate an avatar into their existing engine. The built in renderer may support the use of predefined animations. Video game applications that already have a sophisticated rendering engine may prefer to access the raw avatar data and to render and animate the avatar using their existing engine.

Integrating avatars into a video game application may be designed to be straightforward with predictable fixed resource requirements and a simple API. A video game application may typically use about 850 kB at runtime to render one avatar and some additional temporary memory when retrieving the avatar data. It should be clear to those skilled in the art that the various embodiments of an avatar system and API disclosed herein are exemplary and that other implementations are possible.

In an embodiment video game applications that use the XAvatar API may do so by linking to xavatar.lib. Video game applications may call XAvatarInitialize before they call any of the other functions in the library. This function allocates approximately two megabytes of heap memory for an asset retrieval cache plus approximately 500 kilobytes of additional heap memory if the IXAvatarRenderer will be used.

In an embodiment metadata may be a binary blob that contains information about the avatar s composition. Video game applications may use the XAvatarGetMetadata functions to retrieve or generate avatar metadata. Once retrieved metadata may be passed as an argument to other functions for actual rendering of the avatar. The metadata format may be opaque to video game applications.

Before calling the XAvatarGetMetadataByXuid function video game applications may call XAvatarGetMetadataByXuidResultSize with the appropriate count parameter to retrieve the size of the metadata result buffer that may be needed to hold the requested number of metadata blobs. The applications may then allocate a buffer to hold the metadata that will be returned by the function passing a pointer to that buffer as an argument to the metadata function.

The metadata describing a gamer s avatar may be retrieved by calling the XAvatarGetMetadataByXuid function with the gamer s XUID. This function can retrieve more than one avatar per call if multiple XUIDs are passed in an array. Note that the result buffer may be the proper size as reported by XAvatarGetMetadataByXuidResultSize for the number of XUIDs in the array the buffer size is not necessarily the product of the XUID count and the size of the XAVATAR METADATA structure.

Some video game applications may want access to random avatars for purposes such as crowds. This can be accomplished using the XAvatarGetMetadataRandom function to retrieve one or more randomly created avatars. When calling this function pointer may be passed which may be set to point to an array of XAVATAR METADATA structures.

Video game applications may also wish to display the avatars of a gamer s family members if those members are not signed in at the time. This can be done by retrieving avatars from profiles on the local console that are not currently signed in. First the video game application may determine how many profiles are available on the console but not signed in using the XAvatarGetMetadataSignedOutProfileCount function. This function may provide the count of available profiles. The video game application may then call XAvatarGetMetadataSignedOutProfile function with an index in the valid range from 0 to count 1. For each call a pointer may be passed to a XAVATAR METADATA structure to be filled in with that profile s avatar metadata.

Some video game applications may want to create specific avatars to be used when the game is executing. For example a quiz game might want to have a host character played by an avatar. Once created such an avatar s metadata may be passed directly to XAvatarGetAssets or XAvatarCreateRenderer. To get the metadata initially Avatar Creator may be used to create the avatar. When an avatar is saved to an associated Developer Kit metadata for that avatar may be written to two files devkit avatar metadata.h and devkit avatar metadata.bin. If those files already exist they may be overwritten. Avatar metadata.bin may contain a simple binary definition of the avatar metadata i.e. contains the information that tells the avatar system what that avatar looks like and is wearing . This definition may be included in the video game application s source code.

In further embodiments XAvatar library may include a renderer that can render an avatar into a given Direct3D device. This renderer may be configured and invoked through the IXAvatarRenderer class. A video game application may create an IXAvatarRenderer instance for each avatar by calling the XAvatarCreateRenderer function. This function may allocate approximately 850 kilobytes of memory for the avatar model and assets plus up to another four megabytes of memory for an optional avatar shadow map If used shadow maps can be small 512 512 or large 1024 1024 . The shadow map choice may be a parameter to XAvatarCreateRenderer . AddRef and Release may be used to manage the lifetime of the renderer. XAvatarCreateRenderer may return immediately but the renderer may load avatar assets asynchronously possibly through multiple requests to an online service. If a video game application uses the renderer before all assets have been received the renderer may draw a simple waiting graphic in place of the avatar. Video game applications can use GetStatus to determine whether the avatar has been completely loaded.

In the main game loop video game applications may first call Update to update the avatar s position according to the currently active animation.

Next if the video game application is using avatar self shadowing a shadow map may be generated for the current animation position using RenderShadow. Once the avatar s position and shadow map have been updated the Render function may be called to draw the avatar to the given Direct3D device the video game application may have set a render target and depth buffer ahead of time . As the game loop iterates repeated calls to Update may animate the model and RenderShadow and Render may cause the rendered image to reflect the avatar s changing pose.

Video game applications may set their own model and view matrices for rendering an avatar but the avatar system may supply three standard views head head and shoulders and full body. Video game applications may retrieve these standard matrices using the GetMatrices function. To track animating avatars video game applications may call this function after a call to Update and pass the results to both RenderShadow and Render.

When a video game application is using the IXAvatarRenderer class to render an avatar the avatar may play a randomized sequence of idle animations.

In an embodiment video game applications that use the IXAvatarRenderer class to render an avatar may use the IXavatarAnimation class to specify animations for the avatar to perform.

An animation may be encapsulated in an IXAvatarAnimation object. Video game applications may use the XAvatarLoadAnimation function to load one of a preset list of animations defined by the XAvatar library. Loading an animation with this function may allocate approximately 200 kilobytes of memory to hold the animation data.

Video game applications may also provide their own animations by loading an animation from a memory buffer with the XAvatarLoadAnimationFromBuffer function.

Like the renderer object animations may take time to load. Video game applications may use the GetStatus function to ensure that an animation has completed loading before attempting to use the animation. Animations may not available for playback until they have finished loading.

Video game applications may call the PlayAnimations function to queue a list of animations for playback. Animations may play in the order they appear in the list. By default a subsequent call to PlayAnimations may clear the existing queue insert the new list of animations and immediately begin playing the first animation in the new queue. It may be possible to modify this behavior by calling PlayAnimations with appropriate flags.

When playback transitions from one animation to another the two animations may be blended together so that there is no sudden jarring change in the avatar s position.

Video game applications may use GetCurrentAnimation to determine which animation is currently running.

In some embodiments video game applications may choose to render and animate avatars using their own rendering engine. In this case video game applications may load avatar geometry and graphical assets explicitly and then render them explicitly in its own way.

To determine the buffer size required to hold an avatar s assets video game applications may first call XAvatarGetAssetsResultSize and allocate two buffers of the indicated sizes. The first buffer pResultBuffer may hold avatar geometry metadata and pointers to the GPU resources vertex arrays textures etc. stored in the second buffer pGpuResourceBuffer. The buffer pointed to by pGpuResourceBuffer may start on a 4096 word boundary so that textures are properly aligned in memory.

The pResultsBuffer and pGpuResourceBuffer buffers may then be passed to XAvatarGetAssets which may fill them with the requested assets. An exemplary format is listed in the Appendix.

Asset retrieval may involve multiple queries to an online service to retrieve all of the assets. Video game applications must follow standard X asynchronous programming practices for this operation. An active XAvatarGetAssets request may be canceled by calling XCancelOverlapped.

When the XAvatar library functionality is no longer being used video game applications may call the XAvatarShutdown function to release memory and resources being taken up by the library.

A video game application may initialize the library use it for a period of time shut down the library and then later re initialize the library for additional use. One such scenario might be a video game application that uses avatars in the game lobby but not during gameplay. Such a video game application may initialize the XAvatar library when going into the game lobby use the library in the lobby and then call XAvatarShutdown when transitioning to gameplay freeing memory and resources for the game. When the game ends and players return to the lobby the video game application may call XAvatarInitialize again to start using the XAvatar library again.

Referring now to illustrated is an exemplary video game system including one or more avatar rendering engines and . Game titles and also referred to as video game applications may execute on the video game system . The first video game title may include an avatar rendering engine . The title may request and receive avatar data from the video game system via the API . The received data may be used by the game s rendering engine to render one or more avatars using the game title s own rendering code in the rendering engine . A second game title may or may not include its own avatar rendering engine. In either case the game title may opt to use the video game system s avatar rendering services using one or more rendering engines or . Game title may initiate the process using the API including one or more avatar target locations in the data . The video game system may then render the requested avatars at the target locations. Whether the system renders the avatars or the game title renders the avatars in some cases the avatars may be retrieved from an online gaming service .

Continuing with operation illustrates communicating additional animations provided with the video gaming system. Operation illustrates informing the video game application which animation is currently playing. In operation the video gaming system is queried for model and view matrices based on one of head head and shoulders or full body views. Operation illustrates querying an online gaming service to retrieve avatar data.

Operation illustrates that the avatar data is three dimensional data. Operation illustrates providing access to a plurality of random avatars and operation illustrates specifying a male or female body for one of the plurality of random avatars. In operation avatar data is retrieved from profiles on the video gaming system that are not currently signed in.

Any of the above mentioned aspects can be implemented in methods systems computer readable media or any type of manufacture. For example per a computer readable medium can store thereon computer executable instructions for instantiating an API for allowing a video game application executing in a video game system to render one or more avatars at a rendering destination selected by the video game application. Such media can comprise a first subset of instructions for exposing an interface for allowing the video game application to access data for rendering the avatar to a render target or texture selected by the video game application . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein and that the three presently disclosed subsets of instructions can vary in detail per the present disclosure.

For example the instructions can further comprise instructions for communicating additional animations provided by the video gaming system. The instructions can further comprise instructions for informing the video game application which animation is currently playing and instructions for querying the video gaming system for model and view matrices based on one of head head and shoulders or full body views.

For example the instructions can further comprise instructions for querying an online gaming service to retrieve avatar data. The instructions can further comprise instructions for providing access to a plurality of random avatars and retrieving avatar data from profiles on the video gaming system that are not currently signed in.

Continuing with operation illustrates that the video gaming system includes an avatar renderer. Operation illustrates allowing the avatar renderer to render said avatar to a destination provided by the video game application. Operation illustrates querying an online gaming service to retrieve avatar data released after the video game application is released and in operation the API comprises avatar asset retrieval logic that can be updated independently of the video game application.

The above discussed computing devices and accessories can be embodied as gaming consoles music players personal computers controllers remote control devices and other such devices having different similar or the same platforms. Referring to a block diagram shows an exemplary multimedia console that can be used in conjunction with the various accessories with lighting activation by proximity and motion capabilities.

This console which includes a game oriented console or a PC can comprise for example digital audio processing functionality. Specifically in a multimedia console is shown with a central processing unit CPU having a level 1 L1 cache a level 2 L2 cache and a flash ROM Read only Memory . The level 1 cache and level 2 cache can temporarily store data and hence reduce the number of memory access cycles thereby improving processing speed and throughput. The flash ROM can store executable code that is loaded during an initial phase of a boot process when the multimedia console is powered. Alternatively the executable code that is loaded during the initial boot phase can be stored in a flash memory device not shown . Further ROM can be located separately from the CPU . These memory devices can cache parts or the entirety of the above mentioned applications programs applets managed code and so on. Moreover these memory devices can store sensitive and non sensitive information on a memory unit by memory unit basis as was discussed above. Any of such information can be used at least in part to aid in animating avatars as was discussed above.

A graphics processing unit GPU and a video encoder video codec coder decoder can form a video processing pipeline for high speed and high resolution graphics processing. Data can be carried from the graphics processing unit to the video encoder video codec via a bus. The video processing pipeline can output data to an A V audio video port for transmission to a television or other display. A memory controller can be connected to the GPU and CPU to facilitate processor access to various types of memory such as but not limited to a RAM Random Access Memory . Thus various types of information whether sensitive or not or even parts of various types of information can be stored in the various types of memories discussed above depending on the need.

The multimedia console can include an I O controller a system management controller an audio processing unit a network interface controller a first USB host controller a second USB controller and a front panel I O subassembly that can be preferably implemented on a module . The USB controllers and can serve as hosts for peripheral controllers a wireless adapter and an external memory unit e.g. flash memory external CD DVD ROM drive removable media etc. . Such peripheral controllers can have various types of lighting displays that is triggered by proximity and motion. Moreover the network interface and or wireless adapter can provide access to a network e.g. the Internet home network etc. and can be any of a wide variety of various wired or wireless interface components including an Ethernet card a modem a Bluetooth module a cable modem and the like.

System memory can be provided to store application data that is loaded during the boot process. A media drive can be provided and can comprise a DVD CD drive hard drive or other removable media drive etc. The media drive can be internal or external to the multimedia console . Application data can be accessed via the media drive for execution playback etc. by the multimedia console . The media drive can be connected to the I O controller via a bus such as a Serial ATA bus or other high speed connection e.g. IEEE 1394 . Additional to such application data other information can be stored on the console that will aid in the communication between peripheral accessory device controllers and the console itself.

The system management controller can provide a variety of service functions to assure the availability of the multimedia console . The audio processing unit and an audio codec can form a corresponding audio processing pipeline with high fidelity three dimensional surround and stereo audio processing according to aspects of the presently disclosed subject matter above. Audio data can be carried between the audio processing unit and the audio codec via a communication link. The audio processing pipeline can output data to the A V port for reproduction by an external audio player or device having audio capabilities.

The front panel I O subassembly can support the functionality of the power button and the eject button as well as any LEDs light emitting diodes or other indicators exposed on the outer surface of the multimedia console . A system power supply module can provide power to the components of the multimedia console . A fan can cool the circuitry within the multimedia console .

The CPU GPU memory controller and various other components within the multimedia console can be interconnected via one or more buses including serial and parallel buses a memory bus a peripheral bus and a processor or local bus using any of a variety of bus architectures.

When the multimedia console is powered on or rebooted application data can be loaded from the system memory into memory and or caches and executed on the CPU . Such application data can include some of the online derived data including the avatar packages discussed above. The application can also present a graphical user interface that provides a consistent user experience when navigating to different media types available on the multimedia console . Users can accessorize avatars using such a user interface. In operation applications and or other media contained within the media drive can be launched or played from the media drive to provide additional functionalities to the multimedia console . And such media including game video game applications can be the basis for accessorizing avatars.

The multimedia console can be operated as a standalone system by simply connecting the system to a television or other display. In this standalone mode the multimedia console can allow one or more users to interact with the system watch movies listen to music and the like. However with the integration of broadband connectivity made available through the network interface or the wireless adapter the multimedia console can further be operated as a participant in a larger network community of computing devices. As such a participant it can interact with computing devices whether PCs or servers and receive information that can be eventually stored.

Next illustrates an exemplary networking environment for subject matter discussed with reference to and . The above discussed console can correspond to any one of the aforementioned computing devices or it can be distributed over such devices. It can interact with various other objects and storage devices via a communications network bus where such objects and devices can correspond to other computing devices whether hardware firmware or software . The controllers can communicate with the console in a wired manner or wirelessly over close distances or over remote distances using the shown communications network . Such communication can be aided by various computing devices connected to the communications network .

The term circuitry used through the disclosure can include specialized hardware components. In the same or other embodiments circuitry can include microprocessors configured to perform function s by firmware or switches. In the same or other example embodiments circuitry can include one or more general purpose processing units and or multi core processing units etc. that can be configured when software instructions that embody logic operable to perform function s are loaded into memory e.g. RAM and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic and the source code can be compiled into machine readable code that can be processed by the general purpose processing unit s .

Finally it should also be noted that the various techniques described herein can be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the presently disclosed subject matter or certain aspects or portions thereof can take the form of program code i.e. instructions embodied in tangible storage media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium where when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the subject matter.

In the case of program code execution on programmable computers the computing device can generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that can utilize the creation and or implementation of domain specific programming models aspects of the present invention e.g. through the use of a data processing application programming interface API or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language can be a compiled or interpreted language and combined.

Finally while the present disclosure has been described in connection with a plurality of exemplary aspects as illustrated in the various figures and discussed above it is understood that other similar aspects can be used or modifications and additions can be made to the described aspects for performing the same function of the present disclosure without deviating therefrom. For example in various aspects of the disclosure methods systems and computer readable media were described configured for providing animation accessorization of avatars. However other equivalent mechanisms to these described aspects are also contemplated by the teachings herein. Therefore the present disclosure should not be limited to any single aspect but rather construed in breadth and scope in accordance with the appended claims.

