---

title: Caching and memory optimizations for multi-layer XML customization
abstract: Embodiments of the present invention provide techniques for customizing aspects of a metadata-driven software application. In particular, embodiments of the present invention provide (1) a self-contained metadata engine for generating customized metadata documents from base metadata documents and customizations; (2) a customization syntax for defining customizations; (3) a customization creation/update component for creating and updating customizations; (4) a customization restriction mechanism for restricting the creation of new customizations by specific users or groups of users; and (5) memory and caching optimizations for optimizing the storage and lookup of customized metadata documents.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08538998&OS=08538998&RS=08538998
owner: Oracle International Corporation
number: 08538998
owner_city: Redwood Shores
owner_country: US
publication_date: 20080212
---
 1 U.S. Non Provisional application Ser. No. 12 029 600 titled MULTI LAYER XML CUSTOMIZATION filed Feb. 12 2008 

 2 U.S. Non Provisional application Ser. No. 12 029 605 titled CUSTOMIZATION SYNTAX FOR MULTI LAYER XML CUSTOMIZATION filed Feb. 12 2008 

 3 U.S. Non Provisional application Ser. No. 12 029 724 titled CUSTOMIZATION RESTRICTIONS FOR MULTI LAYER XML CUSTOMIZATION filed Feb. 12 2008 and

 4 U.S. Non Provisional application Ser. No. 12 029 615 titled CUSTOMIZATION CREATION AND UPDATE FOR MULTI LAYER XML CUSTOMIZATION filed Feb. 12 2008.

Embodiments of the present invention relate to computer software and more particularly relate to techniques for customizing aspects of a metadata driven software application.

Software applications are often customized to meet the needs of specific customers. This is particularly true in the field of enterprise software where each organization may have a unique set of business requirements and data integration needs. Customizations generally fall into one of several categories including site customizations i.e. customizations that apply to all users of a deployment group customizations i.e. customizations that apply to specific groups or categories of users and user customizations i.e. customizations that apply to a single user .

In recent years an increasing number of enterprise applications are being built using a metadata driven approach. These applications referred to herein as metadata driven applications are structured such that aspects of their content behavior and or appearance are specified via metadata rather than program code. Generally speaking the customization of metadata driven applications amounts to customizing their corresponding metadata.

According to one known approach for customizing a metadata driven application a customer may make direct modifications to the application s base metadata and thereby tailor the application to its needs. However this technique is problematic for several reasons. For example if an upgrade or patch modifying the base metadata is released the customer must expend considerable time and effort in re implementing and retesting the modifications against the new version of the metadata. This process must be repeated for each new release. Further this approach cannot be used to implement conditional customizations i.e. customizations that apply to specific users or groups of users which generally require modifications to the application code.

According to another known approach the application developer may implement predefined customizations directly in the application metadata code. However this greatly increases the complexity of the application resulting in higher development and maintenance costs. In addition since the number of predefined customizations is necessarily limited this approach cannot address the diverse customization requirements of all customers. Although the application developer may implement a mechanism for allowing customers to create their own customizations this further increases application complexity and cost.

Embodiments of the present invention address the foregoing and other such problems by providing techniques for customizing aspects of a metadata driven software application. In particular embodiments of the present invention provide 1 a self contained metadata engine for generating customized metadata documents from base metadata documents and customizations 2 a customization syntax for defining customizations 3 a customization creation update component for creating and updating customizations 4 a customization restriction mechanism for restricting the creation of new customizations by specific users or groups of users and 5 memory and caching optimizations for optimizing the storage and lookup of customized metadata documents.

According to one embodiment of the present invention a method for customizing a software application comprises receiving a base metadata document defining one or more characteristics of at least a portion of the software application and identifying one or more customizations defining modifications to the base metadata document. A customized metadata document is then generated based on the one or more customizations and the base metadata document.

In one embodiment the one or more customizations are stored separately from the base metadata document. For example the one or more customizations may be stored in a predefined location relative to the base metadata document. Thus the base metadata document may be upgraded without affecting the one or more customizations. Further embodiments of the present invention may support an arbitrary number of customizations per base metadata document.

In another embodiment the steps of receiving the base metadata document identifying the one or more customizations and generating the customized metadata document are performed by a metadata engine at runtime of the software application. The metadata engine may be a generic component configured to interoperate with any software application or system software component that makes use of metadata.

In another embodiment the step of identifying the one or more customizations comprises determining one or more customizations levels and for each customization level identifying a customization based on one or more runtime attributes of the software application. The one or more customization levels are configurable by users of the software application. Further the one or more customization levels may be sorted in a precedence order where the customized metadata document is generated by applying the one or more customizations to the base metadata document in the precedence order. In one embodiment the one or more customization levels are stored in an XML based configuration file.

In another embodiment the one or more customizations may be created by a supplier developer of the software application and packaged as part as of the software application. The one or more customizations may also be created by a user of the software application. In one embodiment a customization creation interface is provided for creating a customization at any customization level.

In another embodiment the customized metadata document generated from the one or more customizations and the base metadata document may be used to generate a user interface of the software application.

According to another embodiment of the present invention a system for customizing software applications is provided. The system comprises a repository configured to store a base metadata document and one or more customizations where the base metadata document defines one or more characteristics of at least a portion of the software application and where the one or more customizations define modifications to the base metadata document. The one or more customizations are stored separately from the base metadata document. The system further comprises a metadata engine configured to receive the base metadata document identify the one or more customizations and generate a customized metadata document based on the one or more customizations and the base metadata document.

According to yet another embodiment of the present invention a machine readable medium is disclosed the machine readable medium having stored thereon a series of instructions which when executed by a processing component cause the processing component to customize a software application. In various embodiments the series of instructions cause the processing component to receive a base metadata document defining one or more characteristics of at least a portion of the software application and identify one or more customizations defining modifications to the base metadata document. The one or more customizations are stored separately from the base metadata document. The series of instructions further cause the processing component to generate a customized metadata document based on the one or more customizations and the base metadata document.

According to one embodiment of the present invention a syntax for customizing a metadata document defining one or more characteristics of at least a portion of a software application is disclosed. The syntax comprises at least one element used to define a modification to a source element of the metadata document where the at least one element includes a required attribute that must be set to a value that uniquely indentifies the source element. The value may be a unique identifier associated with the source element. Alternatively if there is no unique identifier the value may be an XPath expression that selects the source element. In various embodiments the syntax is expressed as an XML schema.

In one embodiment the at least one element may include a modify element used to modify an attribute of the source element a move element used to reorder or re parent the source element and or a replace element used to replace or remove the source element. The syntax may further include a second element used to insert a new element into the metadata document.

According to another embodiment of the present invention a customization for a metadata document is provided. The customization includes at least one element that corresponds to a modification of a source element of the metadata document where the at least one element includes an attribute that is set to a value that uniquely identifies the source element. In various embodiments the customization is an XML document.

According to one embodiment of the present invention a method for restricting the customizability of a base metadata document comprises receiving a type level customization policy defined for an object type of an object included in the base metadata document the type level customization policy indicating whether the object type may be customized by users of a software application. The type level customization policy is then enforced at runtime of the software application. This enforcement may include determining a policy value from a session context of the software application the policy value indicating a username group or role of a current user of the software application and determining based on the policy value the type level customization policy and the set of default behavior rules whether an instance of the object included in the base metadata object may be customized by the current user. In various embodiments the type level customization policy is implemented as one or more type annotations to the object type.

In one embodiment the method above further includes receiving an instance level customization policy defined for the object included in the base metadata document the instance level customization policy indicating whether an instance of the object may be customized by users of the software application and enforcing the instance level customization policy at runtime of the software application. This enforcement may include determining based on the previously determined policy value the type level customization policy the instance level customization policy a set of precedence rules and a set of default behavior rules whether the instance of the object may be customized by the current user. In one embodiment the instance level customization policy is implemented as one or more object annotations in the base metadata document.

If there is a conflict between the type level customization policy and the instance level customization policy the set of precedence rules indicates which policy overrides the other. Further if no customization policy is defined the set of default behavior rules indicate whether the instance of the object may be customized by users of the software application.

According to another embodiment of the present invention a system for restricting the customizability of a base metadata document defining one or more characteristics of at least a portion of the software application is provided. The system comprises a declarative syntax for defining a customization policy the customization policy indicating whether an instance of an object included in the base metadata object may be customized by users of the software application and an evaluation engine configured to enforce the customization policy at runtime of the software application. In various embodiments the system may further comprise a design tool for viewing editing the customization policy and an application programming interface API for programmatically determining whether the instance of the object is customizable for a given user of the software application.

According to yet another embodiment of the present invention a machine readable medium is disclosed the machine readable medium having stored thereon a series of instructions which when executed by a processing component cause the processing component to restrict the customizability of a base metadata document defining one or more characteristics of a software application. In various embodiments the series of instructions cause the processing component to receive a type level customization policy defined for an object type of an object included in the base metadata document the type level customization policy indicating whether instances of objects having the object type may be customized by users of the software application and enforcing the type level customization policy at runtime of the software application.

According to one embodiment of the present invention a method for caching customized metadata documents for a metadata driven software application comprises receiving a request for a customized version of a base metadata document where the base metadata document defines one or more characteristics of at least a portion of the software application and where the base metadata document is to be customized for a first user among a plurality of users of the software application. The method further comprises identifying a first customization for the base metadata document where the first customization is determined to be applicable to the plurality of users identifying a second customization for the base metadata document where the second customization is determined to be applicable only to the first user generating a first customized metadata document based on the first customization and the base metadata document and generating a second customized metadata document based on the first customized metadata document and the second customization. The first customized metadata document is then stored in a shared cache applicable to application sessions of the plurality of users and the second customized metadata document is stored in a session cache applicable only to an application session of the first user. In various embodiments the second customized metadata document is returned to the requestor.

In one embodiment the method above further comprises receiving another request for another customized version of the base metadata document where the base metadata document is to be customized for a second user among the plurality of users identifying a third customization for the base metadata document where the third customization is determined to be applicable only to the second user retrieving the first customized metadata document from the shared cache and generating a third customized metadata document based on the retrieved first customized metadata document and the third customization. The third customized metadata document is then stored in another session cache applicable only to an application session of the second user. In various embodiments the third customized metadata document is returned to the requestor.

In another embodiment the first customized metadata document includes a first element and a second element and the second customized metadata document includes the first element and a modified version of the second element. Further storing the first customized metadata document in the shared cache comprises storing the first customized metadata document in a working memory as a first tree memory structure the first tree memory structure including an allocated memory segment for the first element and an allocated memory segment for the second element and storing the second customized metadata document in the session cache comprises storing the second customized metadata document in the working memory as a second tree memory structure the second tree memory structure including a pointer to the allocated memory segment for the first element in the first tree memory structure and an allocated memory segment for the modified version of the second element.

According to another embodiment of the present invention a layered cache for caching customized metadata documents for a metadata driven software application is disclosed. The layered cache comprises a shared cache configured to store data for application sessions for a plurality of users of the software application where the data includes a first set of customized metadata documents each customized metadata document in the first set being based on one or more customizations applicable to the plurality of users. The layered cache further comprises a plurality of session caches each session cache configured to store data for an application session of a single user where the data stored in said each session cache includes a second set of customized metadata documents each customized metadata document in the second set based on one or more customizations applicable only to the single user. In various embodiments the layered cache is utilized by a metadata engine for efficiently providing customized application metadata to one or more components of the software application.

According to another embodiment of the present invention a system for caching customized metadata documents for a metadata driven software application is provided. The system comprises a working memory component including a shared cache configured to store data for application sessions of a plurality of users of the software application and a session cache configured to store data only for an application session of a first user in the plurality of users. The system further includes a processing component configured to receive a request for a customized version of a base metadata document where the base metadata document defines one or more characteristics of at least a portion of the software application and where the base metadata document is to be customized for the first user identify a first customization for the base metadata document where the first customization is determined to be applicable to the plurality of users identify a second customization for the base metadata document where the second customization is determined to be applicable only to the first user generate a first customized metadata document based on the first customization and the base metadata document and generate a second customized metadata document based on the first customized metadata document and the second customization. The processing component is further configured to store the first customized metadata document in the shared cache and store the second customized metadata document in the session cache. In various embodiments the second customized metadata document is returned to the requester.

According to yet another embodiment of the present invention a machine readable medium is disclosed the machine readable medium having stored thereon a series of instructions which when executed by a processing component cause the processing component to cache customized metadata documents for a metadata driven software application. In various embodiments the series of instructions cause the processing component to receive a request for a customized version of a base metadata document where the base metadata document defines one or more characteristics of at least a portion of the software application and where the base metadata document is to be customized for a first user among a plurality of users of the software application identify a first customization for the base metadata document where the first customization is determined to be applicable to the plurality of users identify a second customization for the base metadata document where the second customization is determined to be applicable only to the first user generate a first customized metadata document based on the first customization and the base metadata document and generate a second customized metadata document based on the first customized metadata document and the second customization. The series of instructions further cause the processing component to store the first customized metadata document in a shared cache applicable to application sessions of the plurality of users and store the second customized metadata document in a session cache applicable only to an application session of the first user. In various embodiments the second customized metadata document is returned to the requestor.

A further understanding of the nature and advantages of the embodiments disclosed herein may be realized by reference to the remaining portions of the specification and the attached drawings.

In the drawings the use of like reference numbers in different drawings indicates similar components.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide an understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form.

Embodiments of the present invention provide a framework for customizing metadata driven software applications. According to one set of embodiments the framework includes a metadata engine configured to receive a base metadata document and identify one or more sets of modifications referred to herein as customizations for the document based on one or more criteria. The metadata engine is further configured to generate a customized metadata document from the base metadata document and the one or more customizations and present the customized metadata document to an application for processing. In one embodiment the customizations are stored separately from the base metadata document. This allows the base metadata document to be modified e.g. via an application patch upgrade without affecting the customizations. In another embodiment the customization capability described above is completely contained within the metadata engine. Accordingly any application or system software component driven by metadata may use the metadata engine to support customization with minimal changes.

In various embodiments the framework further includes a customization syntax a customization restriction mechanism and a plurality of memory and caching optimizations. The customization syntax is a proprietary syntax that allows for efficient representation of modifications e.g. modify move replace insert etc. to a base metadata document. In one embodiment the customization syntax is expressed as an Extensible Markup Language XML schema.

The customization restriction mechanism provides a technique for controlling whether certain elements of a base metadata documents may be customized and by whom. As described in greater detail below customization restrictions may be defined at a metadata object type level a metadata object instance level or both.

The memory and caching optimizations optimize storage and lookup of customized metadata documents by the metadata engine at application runtime. These optimizations include a layered cache for caching customized variants of metadata documents in a memory area configured to store data for application sessions of all users or groups of users i.e. a shared cache or in a memory area configured to store data for the application session of a single user i.e. a session cache . These optimizations further include a specialized hierarchical memory structure for efficiently storing representations of customized metadata documents in working memory.

As used herein a base metadata document is a document that defines one or more base i.e. non customized characteristics of at least a portion of a software application. In various embodiments these characteristics may correspond to the content behavior and or appearance of the application. For example a base metadata document X.xml may define a page layout for a user interface of an application.

A customization is a document that defines one or more modifications to a base metadata document. Thus a customization custX.xml may specify a rearrangement of the page layout defined in base metadata document X.xml. As described in greater detail below embodiments of the present invention allow an arbitrary number of customizations to be defined for and applied to a given base metadata document.

Embodiments of the present invention may be used in a variety of different domains and contexts. Certain embodiments are particularly applicable to enterprise software applications which are commonly customized to meet the business requirements of specific customers. However the customization techniques described herein may be used to provide customization functionality for any system or application framework that relies on metadata.

At step a base metadata document for the application is received where the base metadata document defines one or more characteristics of at least a portion of the application. As described previously these characteristics may correspond to the content behavior and or appearance of the application. In one set of embodiments the base metadata document is formatted in Extensible Markup Language XML . However embodiments of the present invention may be adapted to customize metadata documents formatted in any type of markup language such as HTML SGML and the like.

At step one or more customizations defining modifications to the base metadata document are identified. Like the base metadata document the one or more customizations may be formatted in XML or any other type of markup language. In an exemplary embodiment the one or more customizations are identified based on one or more criteria such as runtime attributes of the application. This identification process is discussed in greater detail with respect to below.

In one set of embodiments the one or more customizations are stored separately from the base metadata document. In other words the one or more customizations and the base metadata document are stored as separate files in the case of a file based repository or in separate database tables or rows in the case of a DB based repository . This allows the base metadata document to be modified or upgraded for example via an application patch or upgrade without affecting the customizations. The one or more customizations and the base metadata document may be stored in the same repository e.g. a centralized metadata repository or in separate repositories.

In further embodiments the one or more customizations are stored in a predetermined location relative to the location of the base metadata document. For example the one or more customizations may be stored in file folder located at a predetermined hierarchical location relative to a file folder containing the base metadata document. In this manner the location of a base metadata document may be used to easily determine the location of the customizations for the base metadata document. Alternatively the one or more customizations may be stored in the same location as the base metadata document or a well known centralized location common to all base metadata documents. One of ordinary skill in the art would recognize many variations modifications and alternatives.

At step a customized metadata document is generated based on the one or more customizations and the base metadata document. If multiple customizations are merged with the base metadata document the customizations are applied cumulatively. For example if customization A.xml includes a modification to element A and customization B.xml includes a modification to element B the customized metadata document will include the modifications to both elements A and B. In some cases a modification defined in a first customization may conflict with a modification defined in a second customization. This situation may be resolved by defining a precedence order for customizations which is discussed in greater detail with respect to below.

In an exemplary embodiment the processing of flowchart is performed at runtime of the software application. For example the processing of flowchart may be initiated in response to a request for a user interface of the application. In this case steps may be executed in real time or near real time . The customized metadata document generated at step may then be used to present a customized version of the requested user interface to the requestor.

It should be appreciated that the specific steps illustrated in provide a particular method for customizing a base metadata document of a software application according to an embodiment of the present invention. Other sequences of steps may also be performed according to alternative embodiments. For example while illustrates that all of the customizations for a base metadata document are identified step prior to generating a customized metadata document step other sequences of steps are possible. In one alternative embodiment each customization may be applied incrementally to the base metadata document as it is identified. Further the individual steps illustrated in may include multiple sub steps that may be performed in various sequences as appropriate to the individual step. Yet further additional steps may be added or removed depending on the particular applications. One of ordinary skill in the art would recognize many variations modifications and alternatives.

Once the customization levels for the base metadata document have been determined a customization is identified for each customization level based on one or more corresponding runtime attributes of the application step . For example assume the base metadata document is associated with a user customization level and a group customization level. In this case a runtime attribute corresponding to the user customization level e.g. username will be used to determine an appropriate user level customization for the base metadata document. Similarly a runtime attribute corresponding to the group customization level e.g. group will be used to determine an appropriate group level customization for the base metadata document. In this manner the customizations applied to the base metadata document may change dynamically based on the current runtime context of the application.

In one set of embodiments the one or more customization levels associated with a base metadata document may be configured by users of the software application. In addition a precedence order for applying the customizations corresponding to the customization levels may be defined. This functionality is discussed with respect to the customization configuration file of below.

According to one runtime flow metadata engine receives base metadata document from repository where the base metadata document corresponds to an application page requested by user of application . Metadata engine then identifies as per the processing of one or more customizations applicable to user. In the example of a site level customization and a user level customization are identified. These customizations are applied to base metadata document to generate a customized metadata document. The customized metadata document is passed to application where it used to generate a customized application page for user.

According to another runtime flow metadata engine receives base metadata document from repository where the base metadata document corresponds to an application page requested by user of application . Metadata engine then identifies as per the processing of one or more customizations applicable to user. In the example of only site level customization is identified in other words user does not have a user level customization . Accordingly only site level customization is applied to base metadata document to generate a customized metadata document. The customized metadata document is passed to application where it used to generate a customized application page for user.

Thus as shown metadata engine may dynamically determine the customizations to be applied to a given base metadata document based on runtime attributes e.g. current user of application . For example site customization and user customization are applied to base metadata document for user while only site customization is applied to base metadata document for user.

Further metadata engine may apply multiple customizations to a base metadata document. Although a maximum of two customizations are applied in the example of site customization and user customization any number of customizations are supported.

Yet further the steps of customizing base metadata document are completely contained within metadata engine . As a result any software application or software component driven by metadata may use metadata engine to support customization with minimal code changes. For example application need only be modified to call metadata engine to access base metadata document rather than retrieving the document directly from repository or . Metadata engine transparently applies the appropriate customizations and passes the customized version of the base metadata document to the application.

As shown configuration file includes three customization class lists and . Generally speaking a customization class is a function class corresponding to a particular customization level. For example customization class UserCC is a function class corresponding to user level customization customization class OrgCC is a function class corresponding to organization level customization etc. In one set of embodiments each customization class is configured to evaluate the current runtime context of the application and return a value indicating the appropriate customization for its corresponding customization level based on said runtime context. Thus if the current user is user the UserCC customization class will return a value indicating the user level customization for user. Similarly if the organization of the current user is Sales the OrgCC customization class will return a value indicating the organization level customization for Sales. 

In an exemplary embodiment a predefined set of customization classes may be implemented and provided by a supplier developer of the software application. This predefined set may include classes that correspond to commonly used customization levels such as user group organization site vertical market and the like. Users of the software application may also implement their own customization classes.

Customization class lists represent three types of mappings between customization classes and base metadata documents. List represents a mapping based on document path. Thus base metadata documents with the document path of ORACLE APPS are associated with the enumerated customization classes of list . List represents a mapping based on the XML namespace of the top level element in the metadata document. Thus base metadata documents having a top level element with the XML namespace http www.oracle.com OA are associated with the enumerated customization classes of list . List represents a default mapping for all other base metadata documents not mapped in or . Thus all other base metadata documents are associated with the customization classes enumerated in list .

In one set of embodiments the order of customization classes in each list defines a precedence order for applying customizations corresponding to those classes. For example assume a base metadata document X.xml falls within the matching scope of list i.e. the XML namespace of its top level element is http www.oracle.com OA . When X.xml is customized a customization SimpleSiteX.xml corresponding to SimpleSiteCC will be applied to X.xml prior to a customization SimpleUserX.xml corresponding to SimpleUserCC. 

In a further set of embodiments the precedence order may be used to resolve conflicts between customizations. For example in one embodiment a customization that is higher in the precedence order may override a conflicting customization that is lower in the precedence order. Thus customization SimpleSiteX.xml will override customization SimpleUserX.xml. In an alternative embodiment a customization that is lower in the precedence order may override a customization that is higher in the precedence order.

Although only three customization class lists are illustrated in any number of lists may be supported. In addition each list may contain an arbitrary number of distinct customization classes. As a result a given base metadata document may be associated with an arbitrary number of customization levels.

Further although configuration file is shown as using a specific XML based syntax for representing lists any other appropriate syntax may be utilized. One of ordinary skill in the art would recognize many variations modifications and alternatives.

At step the configuration file is retrieved. In one embodiment the configuration file may be cached in a working memory such as a working memory of metadata engine or application and retrieved from the cache. In other embodiments the configuration file may be retrieved from a storage repository.

At step one or more customization classes associated with the base metadata document are determined. In one embodiment this step comprises determining the appropriate customization class list e.g. list of for the base metadata document.

Once the customization classes have been determined an instance of a first customization class in the one or more customization classes is executed to determine a customization steps . As discussed above this determination is based one or more runtime attributes of the software application. If the customization returned by the first customization class exists then the customization is retrieved and cumulatively applied to the base metadata document step . Steps and are iterated until all of the customization classes for the base metadata document have been executed step . In an exemplary embodiment steps and are iterated over customization classes in the precedence order defined in the configuration file. This ensures that customizations are applied to the base metadata document according to the precedence order.

It should be appreciated that the specific steps illustrated in provide a particular method for customizing a base metadata document according to an embodiment of the present invention. Other sequences of steps may also be performed according to alternative embodiments. For example alternative embodiments of the present invention may perform the steps outlined above in a different order. Moreover the individual steps illustrated in may include multiple sub steps that may be performed in various sequences as appropriate to the individual step. Furthermore additional steps may be added or removed depending on the particular applications. One of ordinary skill in the art would recognize many variations modifications and alternatives.

As shown customization uses a specific customization syntax. According to one embodiment this syntax includes a top level CUSTOMIZATION element that is used to reference the base metadata document customized by the present customization. For example element includes a CUSTOMIZES attributes that indicates the base metadata document customized by customization is ORACLE APPS HR PAGE1.JSPX. In other embodiments element may be omitted. In various embodiments a customization may only reference and therefore customize a single base metadata document. In alternative embodiments a customization may be configured to customize multiple base metadata documents.

The customization syntax illustrated in further includes one or more elements for defining modifications to a source element of the base metadata document. According to one aspect if a modification applies to an attribute of top level element in the base metadata document the modification may be expressed as an attribute tag identifying the attribute name and the modified value. For example attribute tag illustrates a modification to the attribute TITLE. However all other modifications to a source element are expressed as an element that includes a required ELEMENT attribute. The value of the ELEMENT attribute uniquely identifies the source element being modified. In most cases the value of the ELEMENT attribute will be set to a unique identifier of the source element. If no unique identifier exists the ELEMENT attribute may be set to an XPath expression configured to select the source element.

The one or more elements for defining modifications to a source element may include a MODIFY element for inserting replacing or removing attributes of the source element. For example customization includes a MODIFY element defining a replacement for an attribute value of the source element EMPLOYEELIST. The one or elements may also include a MOVE element for reordering or re parenting the source element and a REPLACE element for replacing the source element with another element or removing the source element altogether.

In various embodiments the customization syntax may further include an INSERT element for inserting a new element into the base metadata document. In one embodiment the INSERT element includes one or more position related attributes such as AFTER or BEFORE. The position related attributes identify where the new element will be inserted in relation to an existing source element. For example the INSERT element of indicates that a new element COMMANDBUTTON will be inserted after the existing element APPLYBTN. 

Although not shown in the customization syntax used therein may be expressed as an XML schema. In one embodiment the schema may included in the same file as customization . In other embodiments the schema may be included in a separate XML Schema Definition XSD file.

In various embodiments customization may created updated via a customization creation update component included in metadata engine of . The customization creation update component may be used to create or update customizations at any level e.g. user group site etc. . Further the customization creation update component may be configured to interoperate with any pre existing user interface designed to create update metadata documents. For example the customization creation update component may be configured to interoperate with an XML editor designed to create update XML documents using standardized DOM based or JAXB based method calls. In this manner customizations may be created or updated transparently using pre existing metadata authoring tools.

In one set of embodiments a customization for a metadata document is created updated by retrieving the metadata document and receiving one or more changes to the metadata document using standardized method calls. For example the metadata document may be retrieved as a DOM document object and the changes may be in the form of standardized DOM method calls. Alternatively the metadata document may be retrieved as a Java Architecture for XML Bindings JAXB based in memory representation and the changes may be in the form of standardized JAXB method calls. The changes are then automatically transformed into one or more customization instructions that are stored as a customization such as customization . The customization is stored separately from the metadata document.

If there are multiple customization classes i.e. customization levels associated with the metadata document the customization instructions are stored in a customization corresponding to the last customization class to be applied to the document also known as the tip customization class . If this customization already exists the existing customization is updated. If this customization does not exist a new customization is created.

The feature of creating updating customizations from standard XML updates is useful both at application runtime and design time. For example it may be incorporated into a design time tool such as Oracle JDeveloper to enable the creation update of seeded customizations. Further the customization creation update component may be incorporated into one or more runtime user interfaces e.g. a page editor within a software application to enable the creation update of user customizations at application runtime.

In one set of embodiments the customization creation update component is configured to generate the best customization instruction to ensure that a patch upgrade of a base metadata document can be done. For example if a modified element in the base metadata document has a unique identifier that unique identifier is used to reference the modified element in the corresponding customization instruction. This makes the customization instruction robust against possible structural changes made to the base metadata document e.g. as part of a patch or upgrade . If the modified element does not have a unique identifier but has a locally unique identifier i.e. unique within its siblings the modified element is referenced using an XPath expression that includes the locally unique identifier. Finally if the modified element does not have a unique identifier or a locally unique identifier the modified element is referenced using an XPath expression.

In the case of an insert instruction one of three existing elements in the base metadata document may be used to identify the location of the insert an after sibling a before sibling or a parent element. Each of these three elements are checked to determined whether they have a unique identifier or a locally unique identifier. Preference is given to the element that has a unique identifier. If more that one of the three have a unique identifier the above order is used to select one.

In some cases a subtree may be removed from one location in the metadata document and added either at a different location under the same parent or to a different parent. In this situation the customization creation update component will detect such consecutive changes and will generate a move instruction. Generally speaking using a move instruction rather than a series of replace and insert instructions is preferable for preserving customizations in the face of structural changes to the metadata document. Note that this can be achieved even if the metadata document is being updated using an API that does not support a move operation natively e.g. DOM API .

In one set of embodiments the customization instructions generated as part of a create or update operation may be optimized prior to being stored as a customization. These optimizations may include 1 combining multiple MODIFY elements for a single source element into a single MODIFY element 2 combining an INSERT element and one or more MODIFY elements for portions of the inserted element s sub tree into a single INSERT element and 3 removing an INSERT element and a subsequent REPLACE element that deletes the inserted element. These optimizations provide the dual benefits of compacting the size of customization documents and improving the performance of metadata engine when applying customizations to base metadata documents at runtime.

According to one embodiment the optimizations described above may apply to changes performed across sessions i.e. changes performed and saved at different points in time . For example a new element may be inserted at one point in time and the customization may be saved. At a later point in time a modification may be made to a subtree of the element inserted earlier. This modification may be combined with the prior insertion even though the two operations were performed at different times.

According to another embodiment the optimization process takes into account situations where a customization may apply to two or more other customizations. For example consider a user level customization that may be applied on top of both a role manager level customization and a role employee level customization. In this situation the user level customization may include certain customization instructions that apply to elements included in the role manager customization but are not included in the role employee customization. Such customization instructions are automatically identified and preserved during the optimization process even though they do not apply to the role employee context .

As discussed above embodiments of the present invention also provide a mechanism for restricting the customizability of a base metadata document or portions thereof by one or more users. This mechanism is enabled through a declarative syntax for defining customization restrictions and an evaluation engine for enforcing the customization restrictions. As used herein a customization restriction is a control that affects the customizability of a given metadata object instance. A first type of customization restriction controls whether customization is allowed. A second type of restriction identifies the users that can customize if customization is allowed . And a third type of restriction controls whether specific types of customization i.e. modify move replace etc. are allowed. One or more restrictions for a given object may be grouped into a customization policy. An exemplary customization policy is illustrated in .

In an exemplary embodiment customization restrictions and thus customization policies may be defined for a metadata object type or a metadata object instance. Customization restrictions defined for a given object type will apply to all object instances having that type. Customization restrictions defined for a given object instance will apply only to that instance. In further embodiments customization restrictions may be defined at the element type or attribute type level for object types or at the element instance or attribute instance level for object instances .

At step a type level customization policy defined for an object type of an object included in a base metadata document is received where the type level customization policy indicates whether instances of objects having the object type may be customized by users of a software application. In an exemplary embodiment the customization restrictions included in the type level customization policy are implemented as one or more type annotations to the object type. For example if the object type is defined in an XSD file the customization restrictions may be implemented as type annotations within the XSD file. Alternatively the type annotations may be included in a standalone XML file or tag library.

At step a policy value is determined from a session context of the software application. The policy value is a value used to determine whether the customization restrictions included in the type level customization policy should be enforced for the current application session. Typically customization restrictions will be enforced based on the identity of the current user of the application. Accordingly the policy value will generally correspond to a user related attribute such as username group role or the like. Of course other types of policy values may also be used based on the customization requirements for the application.

At step a determination is made whether an instance of the object included in the base metadata document may be customized by the current user of the application. This determination is based at least in part on the policy value determined at step and the type level customization policy. Thus if the username of the current user is User and the type level customization policy includes a restriction disallowing customization by User the current user will be restricted from customizing the object instance. In various embodiments the restrictions applied to the object instance may also depend on customization policies defined at the object instance level rather than the object type level and on customization policies defined for parent object types of the object s object type. This is discussed in greater detail with respect to below.

In some cases there may be no customization policies applicable to an object instance of a base metadata document. In those situations the set of default behavior rules are used to determine whether the object instance may be customized. In one embodiment the default behavior rules may indicate that the object cannot be customized by any user if there are no applicable customization policies. In alternative embodiments the default behavior rules may allow customization by a specific group of users e.g. administrators or by all users under certain conditions. One of ordinary skill in the art would recognize many variations modifications and alternatives.

At step a type level customization policy defined for the object is received where the type level customization policy indicates whether instances of objects having the object type may be customized by users of the software application. At step an instance level customization policy is received where the instance level customization policy indicates whether an instance of the object may be customized by the users of the application. In an exemplary embodiment the customization restrictions in the instance level customization policy are implemented as one or more object annotations to the object. The object annotations may be stored in the base metadata document or in one or more extended metadata files associated with the base metadata document.

At step a policy value is determined from a session context of the application as in step of . A determination is then made based on the policy value the type level customization policy the instance level customization policy a set of precedence rules and a set of default behavior rules whether an instance of the object may be customized by the current user step . In this type of situation where multiple customization policies may apply to a given object instance the set of precedence rules determine which customization policies actually apply. According to an exemplary set of precedence rules restrictions in higher precedence policies are automatically inherited by lower precedence policies. Further type level policies have a higher precedence than instance level policies. Accordingly since the object instance in step has both a type level and object level customization policy defined the restrictions in the both the type level and instance level policies will apply.

In some cases the type level policy and instance level policy may contain conflicting restrictions. In these situations the set of precedence rules may also determine which restrictions override others. Generally speaking lower precedence restrictions cannot expand the scope of higher precedence restrictions. For example if a higher precedence restriction disables customization for an object type instance a lower precedence restriction cannot enable customization of the object type instance. However lower precedence restrictions can further limit the scope of higher precedence restrictions. For example if a higher precedence restriction limits customization of an object type instance to users in the group Admin a lower precedence restriction can further limit customization of the object type instance to users in the group Sales. In this example an instance of the object will be customizable only by users in both Admin and Sales. 

It should be appreciated that the specific steps illustrated in provide particular methods for restricting the customizability of a base metadata document according to embodiments of the present invention. Other sequences of steps may also be performed according to alternative embodiments. For example alternative embodiments of the present invention may perform the steps outlined above in a different order. Moreover the individual steps illustrated in may include multiple sub steps that may be performed in various sequences as appropriate to the individual step. Furthermore additional steps may be added or removed depending on the particular applications. One of ordinary skill in the art would recognize many variations modifications and alternatives.

In some embodiments the customization restrictions that apply to a given object instance will depend on how the object instance is instantiated. For example assume a set of precedence rules where restrictions in higher precedence customization policies are automatically inherited by lower precedence policies where type level policies have a higher precedence than object level policies and where super type level policies have a higher precedence than type level policies. Further assume a collection of object type definitions as illustrated in . As shown object type definitions include three object types BaseTypeA ExtendedTypeB and BaseTypeC . BaseTypeA includes ElementA . ExtendedTypeB extends from BaseTypeA and includes ElementB . BaseTypeC includes ElementC which is of type BaseTypeA and Element C which is of type ExtendedTypeB.

Given the above the customization policies that apply to an instance of ElementA will depend on how ElementA is instantiated. If ElementA is instantiated as part of an instance of BaseTypeA the customization policies of the instance document and BaseTypeA will apply. If ElementA is instantiated as part of an instance of ExtendedTypeB the customization policies of the instance document BaseTypeA and ExtendedTypeB will apply. If ElementA is instantiated as part of an instance of BaseTypeC ElementC the customization policies of the instance document BaseTypeA ExtendedTypeB and BaseTypeC will apply.

As shown customization policy is implemented as a plurality of type annotations . Annotation defines a customization restriction indicating that the attribute type QUANTITY may be customized by users in the groups of ADMIN and SALES. Annotation defines a customization restriction indicating that the attribute type ITEMREF cannot be customized. And annotation defines a customization restriction indicating that attribute type DESCRIPTION can be customized by any user. Although annotations utilize a specific syntax for defining customization restrictions any other suitable syntax may be employed. One of ordinary skill in the art would recognized many variations modifications and alternatives.

At step a request for a customized version of a base metadata document is received where the base metadata document is to be customized for a first user among a plurality of users of a software application. Upon receiving the request a first customization for the base metadata document is identified where the first customization is determined to be applicable to the plurality of users step . For example the first customization may be a site level customization. Additionally a second customization for the base metadata document is identified where the second customization is determined to be applicable to only the first user step . For example the second customization may be a user level customization. In various embodiments the first and second customizations are determined according to the steps of as described above.

At step a first customized metadata document is generated based on the first customization and the base metadata document. The first customized metadata document can be considered an intermediate version of the final customized document because only the first customization has been applied. The first customized metadata document is then stored in a shared cache configured to store data for application sessions of the plurality of users . Since the first customization applies to every user in the plurality of users it is likely that the first customized metadata document will need to be generated again in response to other user requests e.g. as a base for applying further customizations . Thus by caching the first customized metadata document in the shared cache the document can be retrieved quickly and efficiently.

At step a second customized metadata document is generated based on the first customized metadata document and the second customization. The second customized metadata document can be considered the final customized version of the base metadata document. The second customized metadata document is then stored in a session cache configured to store data only for an application session of the first user step . Thus the second customized metadata document can be retrieved quickly and efficiently from the session cache if requested again by an application session of the first user. The second customized metadata document may then be returned to the requestor.

At a later point in time another request for another customized version of the base metadata document is received where the base metadata document is to be customized for a second user among the plurality of users step . In response a third customization for the base metadata document is identified where third customization is determined to be applicable only to the second user step . For example the third customization may be a user level customization for the second user. In addition since the third customization needs to be applied on top of the base metadata document and the first customization the first customized metadata document is retrieved from the shared cache step . Note that the base metadata document and the first customization do not need to be retrieved and merged again thereby substantially improving performance. A third customized metadata document is then generated from the first customized metadata document and the third customization and the third customized metadata document is stored in another session cache configured to store data only for an application session of the second user steps . The third customized metadata document may then be returned to the requestor.

Using the techniques of metadata engine of may intelligently cache customized variants of a base metadata document and thereby optimize the generation of customized metadata documents that share common customizations. In one set of embodiments metadata engine may automatically determine whether to store a customized metadata document in the shared cache or a session cache based on the customizations applied. In other embodiments a cache hint may be included in each customization. The cache hint indicates to metadata engine whether to cache an application of the customization and which cache to use.

Although illustrate a specific case where only two customization levels a group level customization and a user level customization apply to a base metadata document the layered cache of the present invention may also be used in situations where more than two customization levels apply. For example assume a scenario where three customization levels division department user are associated with a base metadata document. Further assume that user user who is a member of division Engineering and department cooling systems requests the document. In this scenario a first customized metadata document based on the customization for division Engineering will be generated and stored in the shared cache. The first customized metadata document will be used as a starting point for customizing the base metadata document in cases where the base metadata document is requested by another user in the division Engineering but in a different department . Further a second customized metadata document based on the customizations for division Engineering and department cooling systems will be generated and stored in the shared cache. The second customized metadata document will be used as a starting point for customizing the base metadata document in cases where the base metadata document is requested by another user in division Engineering and department cooling systems. Finally a third customized metadata document based on the customizations for division Engineering department cooling systems and user user will be generated and stored in a session cache specific to user. The third customized metadata document will be used to service future requests by user for the base metadata document.

Tree structure is an exemplary data structure for a first metadata document stored in working memory. Assume that the first metadata document includes five elements A B C D E. As shown tree structure includes five nodes corresponding to elements A B C D E respectively. In addition the hierarchical relationships between nodes correspond to the hierarchical relationships between elements A B C D E. Each node includes an allocated memory area for storing data pertaining to its corresponding element.

Tree structure is an exemplary data structure for a second metadata document stored in working memory. Assume that the second metadata document includes five elements A B C D E where elements A B D E are identical to elements A B D E in the first metadata document and where C is a modified version of element C. In this case since the data for elements A B D E are already stored in working memory at nodes of tree structure that data does not need to be duplicated in tree structure . Accordingly nodes in tree structure can simply store pointers to corresponding nodes . Since element C has been changed from element C a new memory area is allocated for element C at node in tree structure .

Using memory structures such as tree structures customized metadata documents may be cached in the layered cache described above in a highly optimized manner. For example customized variants of a base metadata document often share a large number of common elements. Since instances of common elements are not duplicated in memory as described with respect to structures a large number of customized variants may be stored in a relatively small memory footprint. In one set of embodiments only a modified element e.g. node of a metadata document e.g. tree is allocated a new memory area if a variant of the metadata document e.g. tree is already stored in working memory. In other embodiments the modified element and all of its parent elements e.g. nodes may be allocated new memory areas even if the parent elements are identical to the parent elements in the existing variant.

Client computing devices may be general purpose personal computers including by way of example personal computers and or laptop computers running various versions of Microsoft Windows and or Apple Macintosh operating systems cell phones or PDAs running software such as Microsoft Windows Mobile and being Internet e mail SMS Blackberry or other communication protocol enabled and or workstation computers running any of a variety of commercially available UNIX or UNIX like operating systems including without limitation the variety of GNU Linux operating systems . Alternatively client computing devices may be any other electronic device such as a thin client computer Internet enabled gaming system and or personal messaging device capable of communicating over a network e.g. network described below . Although exemplary system environment is shown with four client computing devices any number of client computing devices may be supported.

In most embodiments system environment includes a network . Network may be any type of network familiar to those skilled in the art that can support data communications using any of a variety of commercially available protocols including without limitation TCP IP SNA IPX AppleTalk and the like. Merely by way of example network can be a local area network LAN such as an Ethernet network a Token Ring network and or the like a wide area network a virtual network including without limitation a virtual private network VPN the Internet an intranet an extranet a public switched telephone network PSTN an infra red network a wireless network e.g. a network operating under any of the IEEE 802.11 suite of protocols the Bluetooth protocol known in the art and or any other wireless protocol and or any combination of these and or other networks.

System environment also includes one or more server computers which may be general purpose computers specialized server computers including by way of example PC servers UNIX servers mid range servers mainframe computers rack mounted servers etc. server farms server clusters or any other appropriate arrangement and or combination. In various embodiments server may be adapted to run one or more services or software applications described in the foregoing disclosure. For example as shown in server may correspond to an application server configured to execute metadata driven application of . Server may also be configured to run metadata engine of . In alternative embodiments metadata engine may be executed on a server computer separate from application server .

Server may run an operating system including any of those discussed above as well as any commercially available server operating system. Server may also run any of a variety of additional server applications and or mid tier applications including HTTP servers FTP servers CGI servers Java servers database servers and the like. Exemplary database servers include without limitation those commercially available from Oracle Microsoft Sybase IBM and the like.

System environment may also include one or more databases . For instance databases may include an application database configured to store transactional data for applications hosted on server and a metadata database configured to store metadata for the applications as well as a metadata engine such as metadata engine of . Databases may reside in a variety of locations. By way of example one or more of databases may reside on a storage medium local to and or resident in server . Alternatively databases may be remote from server and in communication with server via a network based or dedicated connection. In one set of embodiments databases may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to server may be stored locally on server and or remotely as appropriate. In one set of embodiments databases may include relational databases such as Oracle 10g that are adapted to store update and retrieve data in response to SQL formatted commands.

Computer system may additionally include a computer readable storage media reader a communications subsystem e.g. a modem a network card wireless or wired an infra red communication device etc. and working memory which may include RAM and ROM devices as described above. In some embodiments computer system may also include a processing acceleration unit which can include a digital signal processor DSP a special purpose processor and or the like.

Computer readable storage media reader can further be connected to a computer readable storage medium together and optionally in combination with storage device s comprehensively representing remote local fixed and or removable storage devices plus storage media for temporarily and or more permanently containing computer readable information. Communications system may permit data to be exchanged with network and or any other computer described above with respect to system environment .

Computer system may also comprise software elements shown as being currently located within working memory including an operating system and or other code such as an application program which may be a client application Web browser mid tier application RDBMS etc. . In an exemplary embodiment working memory may include executable code and associated data structures such as caches for metadata engine of . It should be appreciated that alternative embodiments of computer system may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices data signals data transmissions or any other medium which can be used to store or transmit the desired information and which can be accessed by a computer.

While the present invention has been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. The present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. Many variations of the invention will become apparent to those skilled in the art upon review of the disclosure. The scope of the invention should therefore be determined not with reference to the above description but instead should be determined with reference to the pending claims along with their full scope or equivalents.

