---

title: Methods and apparatus for controlling migration of content
abstract: Some embodiments relate to a migration policy that controls migration of content from a transactional storage system to a fixed content storage system. In some embodiments, content may be migrated from the transactional storage system to the fixed content storage system based on at least one criteria that relates to whether at least a portion of the content is binding.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010741&OS=08010741&RS=08010741
owner: EMC Corporation
number: 08010741
owner_city: Hopkinton
owner_country: US
publication_date: 20080930
---
The present invention relates to the storage of content in a computer system including a fixed content storage system.

Some storage systems receive and process access requests that identify a data unit or other content unit also referenced to as an object using an object identifier rather than an address that specifies where the data unit is physically or logically stored in the storage system. Such storage systems are referred to as object addressable storage OAS systems. In object addressable storage a content unit may be identified e.g. by host computers requesting access to the content unit using its object identifier and the object identifier may be independent of both the physical and logical location s at which the content unit is stored although it is not required to be because in some embodiments the storage system may use the object identifier to inform where a content unit is stored in a storage system . From the perspective of the host computer or user accessing a content unit on an OAS system the object identifier does not control where the content unit is logically or physically stored. Thus in an OAS system if the physical or logical location at which the unit of content is stored changes the identifier by which host computer s access the unit of content may remain the same. In contrast in a block I O storage system if the location at which the unit of content is stored changes in a manner that impacts the logical volume and block address used to access it any host computer accessing the unit of content must be made aware of the location change and then use the new location of the unit of content for future accesses.

One example of an OAS system is a content addressable storage CAS system. In a CAS system the object identifiers that identify content units are content addresses. A content address is an identifier that is computed at least in part from at least a portion of the content which can be data and or metadata of its corresponding unit of content. For example a content address for a unit of content may be computed by hashing the unit of content and using the resulting hash value as the content address. Storage systems that identify content by a content address are referred to as content addressable storage CAS systems.

The eXtensible Access Method XAM proposal is a proposed standard that employs content addressable storage techniques that is being developed jointly by members of the storage industry and provides a specification for storing and accessing content and metadata associated with the content. In accordance with XAM an XSet is a logical object that can be defined to include one or more pieces of content and metadata associated with the content and the XSet can be accessed using a single object identifier referred to as an XUID . As used herein a logical object refers to any logical construct or logical unit of storage and is not limited to a software object in the context of object oriented systems.

As discussed above an XSet can store one or more pieces of content. For example an XSet can be created to store a photograph and the photograph itself can be provided as a first stream to the XSet. One or more files e.g. text files can be created to include metadata relating to the photograph and the metadata file s can be provided to the XSet as one or more additional streams. Once the XSet has been created a XUID is created for it so that the content e.g. the photograph and its associated metadata can thereafter be accessed using the single object identifier e.g. its XUID . A diagram of an illustrative XSet is shown in . As shown in XSet includes a number of streams for storing user provided content and metadata. The XSet may also include a number of additional fields that store other types of metadata for the XSet such as for example the creation time for the XSet the last access time of access of the XSet and or any retention period for the XSet.

In XAM each field or stream in an XSet may be designated as binding or non binding. Binding fields and streams are used in computing the XUID for the XSet while non binding fields and streams are not. That is the XUID for an XSet is computed based on the content of the binding fields and streams e.g. by hashing the content of these fields and streams but not based on the non binding fields and streams. The designation of certain fields and or stream as binding may change. Re designating as binding a field or stream that had been previously designated as non binding causes the XUID for the XSet to change. Similarly re designating a field or stream as non binding that had previously been designated as binding causes the XUID for the XSet to change.

Because the XUID for an XSet is generated using the content of the binding fields and streams the binding fields and streams of the XSet cannot be changed once the field becomes binding though these fields and streams can be re designated as non binding and then changed . A request to modify a binding field or stream will result in a new XSet with a different XUID being created.

One embodiment is directed to a method for use in a computer storage environment comprising a transactional storage system and a fixed content storage system wherein the storage environment stores a plurality of content units and provides a content addressable interface via which at least some of the plurality of content units are accessible wherein a content unit accessible via the content addressable interface is accessible via an identifier that comprises a content address generated based at least in part on at least a participating portion of the content of the content unit. The method comprises an act of A providing an interface to the storage environment that enables configuration of at least one migration policy that controls migration of sets of data between the transactional storage system and the fixed content storage system wherein the at least one migration policy evaluates at least one criteria relating to whether a set of data in a content unit is participating in the generation of the content address for the content unit. Another embodiment is directed at least one computer readable medium encoded with instructions that when executed performs the above described method.

Another embodiment is directed to a method for use in a content addressable storage system that stores a plurality of objects and provides a content addressable interface via which at least some of the plurality of objects are accessible wherein an object accessible via the content addressable interface is accessible via an identifier that comprises a content address generated based at least in part on at least a participating portion of the object the method comprising A in response to an operation that is directed to a first object stored in at least one content unit on the storage system and seeks to modify a non participating portion of the first object wherein the first object is accessible via a first content address and comprises a participating portion that participates in generating the first content address and the non participating portion that does not participate in generating the first content address performing acts of A1 maintaining on the storage system a first version of the first object comprising a first version of the non participating portion that does not reflect modification by the operation and A2 storing on the storage system a second version of the first object comprising a version of the non participating portion that reflects modification by the operation.

A further embodiment is directed to content addressable storage system comprising at least one storage device that stores a plurality of objects a content addressable interface via which at least some of the plurality of objects are accessible wherein an object accessible via the content addressable interface is accessible via an identifier that comprises a content address generated based at least in part on at least a participating portion of the object and at least one controller that in response to an operation that is directed to a first object stored in at least one content unit on the storage system and seeks to modify a non participating portion of the first object wherein the first object is accessible via a first content address and comprises a participating portion that participates in generating the first content address and the non participating portion that does not participate in generating the first content address maintains on the storage system a first version of the first object comprising a first version of the non participating portion that does not reflect modification by the operation and stores on the storage system a second version of the first object comprising a version of the non participating portion that reflects modification by the operation.

Some embodiments relate to techniques for storing mutable content e.g an XSet with some non binding stream or fields on a fixed content archive storage system. A fixed content archive refers herein to a storage system that does not allow content stored thereon to be modified unless an explicit command to delete the content is received Thus if a request to modify a content unit stored on a fixed content archive is received the archive creates a new content unit rather than overwrite the content of the previous version of the content unit with the modified content. Thus each time the content unit is modified a new version of the content unit is created on the archive storage system. If it desired to recover any content from a content unit that was modified a previous version of the content unit having the desired data may be retrieved.

The examples herein refer to fixed content archive storage systems that are capable of implementing at least some aspects of the XAM standard. However it should be appreciated that the aspects of the present invention described herein are not limited in this respect and can be used with any fixed content archive storage system.

Applicants have appreciated that when a logical object is stored on a fixed content archive storage system some or all of the content of the objects e.g. fields or streams of an XSet in XAM may be non binding thereby allowing the XSet to be modified after it is stored on the archive storage system. Each time one of these non binding fields is modified a new version of the object e.g. the XSet is created. As a result if an object e.g. an XSet is modified frequently a large number of versions of the object may be stored on the archive storage system thereby consuming a large amount of storage space. The problem is compounded when there are a large number of objects with non binding portions that are being modified frequently.

Applicants have further appreciated that in many situations content is modified frequently until it is in a final state after which it is desired that the content no longer be able to be modified. For example in may be desired to initially designate one or more streams of an XSet as non binding as the content of the streams is periodically being modified but then designate the stream as binding once the content is in a desired final state. Such situations can arise for example if a user is editing video content to create a video. The content may be edited frequently until the user has produced the final video after which the user is done making change so that the content will not thereafter be modified. As another example a user may be writing and revising drafts of a magazine article or a company s financial statements. Frequent modification of such content may occur as the user revises and updates various drafts but once the final draft is produced it may not be modified again. Applicants have appreciated that while fixed content archive storage systems are advantageous for storing content that is fixed e.g. because they often can do so cost effectively non archive transactional storage systems are better suited for storing content that changes frequently. A non archive transactional storage system is a storage system in which content may be modified by overwriting or deleting a portion of the content rather than creating a new version to store the modified content.

Thus Applicants have appreciated that for some objects that transition from a phase in which they are frequently updated to one wherein they are more fixed it maybe desirable to store the content unit on a transactional storage system when it is being updated frequently and then migrate it to a fixed storage system when the content becomes more fixed.

Thus some embodiments relate to configuring and or providing a migration policy that controls migration of content between a non archive transactional storage system e.g. in which content may be modified and a fixed content archive storage system based on at least one criteria relating to whether at least some portion of the content is binding i.e. participates in the generation of the identifier for the content .

As discussed above other embodiments relate to storing mutable content on a fixed content archive storage system such that a new version of the content is created when the content is modified. This may be done in any suitable way as the invention is not limited in this respect.

In some embodiments the mutable content may be a XAM XSet and may be stored on a content addressable storage CAS system. In a CAS system content units are logical objects used to store content on a CAS system and are identified and accessed using content addresses. A content address is an identifier that is computed at least in part from at least a portion of the content which can be data and or metadata of its corresponding unit of content. For example a content address for a unit of content may be computed by hashing the unit of content and using the resulting hash value as the content address.

When an XSet is stored on a CAS system the XSet may be represented by one or more content units on the CAS system. This may be done in any suitable way as the invention is not limited in this respect. In some embodiments the XSet may be represented on the CAS system using content units referred to herein as content descriptor files CDFs and blobs. Content can be stored in a content unit referred to as a blob which is identified on the CAS system by a content address computed at least in part from at least a portion of the content of the blob. Each blob has at least one associated CDF which stores the content address of the blob i.e. as a pointer to the blob as well as metadata associated with the blob. The CDF is independently accessible via its own content address. By accessing the CDF the content in the blob can be efficiently and easily accessed via its content address that is included in the CDF along with its associated metadata. In some embodiments a CDF may have a mutable portion. The mutable portion of the CDF is not used is computing the content address of the CDF. Thus if the mutable portion changes the content address of the CDF need not change.

The process next continues to act where a blob is created for each non binding stream of the XSet and a content address is generated for each blob. The process then continues to act where a second CDF is generated to store the non binding fields of the XSet and a content address is generated for the second CDF. The second CDF also has a non mutable portion which is used in generating the content address and a mutable portion which is not used in generating the content address. The binding fields of the XSet are stored in the non mutable portion of the CDF along with the content addresses of each of the blobs created in act . The process next continues to act where the content address of the second CDF is stored in the mutable portion of the first CDF and the process ends.

CDF has non mutable portion and mutable portion . Non mutable portion stores fields and and stores pointers to e.g. the content addresses of blobs and . Blob stores the content of stream and blob stores the content of stream . Mutable portion stores a pointer to e.g. the content address of CDF which has non mutable portion and mutable portion . Non mutable portion stores field of XSet and a pointer e.g. the content address of blob . Blob stores the content of stream .

In some embodiments the content address for the CDF that stores the binding fields of the XSet may be used in generating the XUID for the XSet. For example in the content address of CDF may serve as a basis for the XUID of the XSet . That is this content address is computed from the binding portions of the XSet i.e. the binding fields and the content addresses of the binding streams such that by using this content address as all or a portion of the XUID for the XSet the XUID is computed using the binding fields of the XSet. In addition when the CAS system receives a request to access the XSet that identifies the XSet using its XUID the CAS system may determine the content address of the CDF from the XUID and use this content address to access the content units that form the XSet.

In accordance with some embodiments if it is desired to modify any of the non binding portions of the XSet new content units may be created on the CAS system to store the modified data without deleting or modifying the content units that store the older version of the non binding data. This may be done in any suitable was as this aspect is not limited to any particular implementation technique.

As can be appreciated from the example above each time the non binding content is modified one or more new content units are generated to store the modified content and a pointer to the new content unit s is stored in the CDF for the binding fields. Thus each new content unit or set of content unit s generated when a modification occurs can be a thought of as a version of the non binding content of the XSet at a particular point in time. The CDF for the binding portions of the XSet e.g. CDF in stores a pointer to each version such that that this CDF may be used to access any version of the non binding content.

In the example above a non binding stream of an XSet is modified and a new content unit e.g. blob is created to store the modified content. However in some situations only a non binding field of the XSet may be modified while the non binding streams of the XSet are not modified. In such situations a new CDF may be generated to store the content of the non binding fields including the modified content for the fields being modified but a new blob need not be created for each non binding stream. Rather because the streams are not being modified the newly created CDF may simply include pointers to the already existing blobs that store the stream content. Thus in some embodiments a new blob is only created for a stream if that stream is being modified while pointers to the existing blobs for the streams not being modified may be stored in the new CDF rather than creating new blobs to store the same content. However the invention is not limited in this respect as in some embodiments a new blob may be created for each non binding stream each time any of the non binding content of the XSet is modified.

As should be appreciated from the example of when a new version of an XSet is stored on the storage system a new copy of all of the content of the XSet need not be created. Rather a new version of the XSet may share content units with one or more earlier versions of the XSet. For example in the first version of the XSet includes content units and whereas the second version of the XSet includes content units and .

The examples above are examples for creating versions of non binding portions of a XAM XSet using CDFs and blobs on a CAS system. However aspects relating to creating versions of non binding portions of objects are not limited to use with XAM XSets as any suitable type of logical objects may be used. In addition the invention is not limited to use with systems that uses CDFs and or blobs to store logical objects as objects may be represented on a system in any suitable way.

In accordance with another embodiment a migration policy may be employed that controls migration of content stored on a non archive transactional storage system e.g. in which content may be modified to a fixed content archive storage system based on at least one criteria relating to whether at least some portion of the content is binding i.e. participates in the generation of the identifier for the content . This may be done in any suitable way as aspects of the invention related to performing such migration are not limited to any particular implementation technique.

One illustrative implementation is shown in a computer system may include a host computer that executes an application program a transactional storage system and a fixed content archive storage system . The computer system may also include a migration policy manager that controls migration of content between transactional storage system and fixed content storage system . Application program may communicate with transactional storage system fixed content storage system and or migration policy manager via one or more application programming interfaces APIs .

Transactional storage system may be any suitable type of non archive storage system as the invention is not limited in this respect. For example transactional storage system may be one or more file servers or network attached storage NAS devices a database management system DBMS a block I O storage system or any other suitable type of transactional storage system.

Fixed content storage system may be any suitable type of fixed content storage system as the invention is not limited in this respect. For example in some embodiments fixed content storage system may be a content addressable storage system. In some embodiments the fixed content storage system may be implemented as in any of the embodiments described above e.g. to implement XAM a CDF blob architecture and or versioning but the aspects of the invention that relate to migration are not limited to use with a fixed content storage system of any of those types.

Migration policy manager may control migration of content between transactional storage system and fixed content storage system based on whether portions of the content participate in the generation of an identifier for the content i.e. are binding or do not participate in the generation of an identifier for the content i.e. are not binding . This may be done in any suitable way as the invention is not limited in this respect.

The process then continues to act where it is determined whether at least one portion of the selected unit of content is binding. For example if the unit of content is a XAM XSet it may be determined whether at least one field or stream is binding. If at act it is determined that no fields or streams are binding the process continues to act where the unit of content is stored on the transactional storage system in act . Alternatively if the unit of content is already stored on the transactional storage the unit of content may be left on the transactional storage system.

If at act it is determined that at least one field or stream is binding the process continues to act where the unit of content is stored on the fixed content storage system or if the unit of content is stored on the transactional storage system migrated from the transactional storage system to the fixed content storage. In some embodiments when a unit of content is migrated from the transactional storage system to the fixed content storage system the unit of content may be deleted from the transactional storage system though it is not required to be .

As mentioned above the migration policy manager may examine a unit of content in response to any suitable trigger as the invention is not limited in this respect. For example in some embodiments the unit of content may be examined in response to an application program sending a request to initially store the content unit to the storage environment. In some embodiments the migration policy manager may select a unit of content in response to the application program sending a request to alter designation of one or more portions of the unit of content from non binding to binding or vice versa. In some embodiments the migration policy manager may periodically scan units of content stored on the transactional storage system e.g. as a background process and select units of content to be examined in this way. Any other suitable way of triggering the process to examine a content unit may be used.

In the example of at act the migration policy manager makes a determination that will impact where to store and or whether to migrate a content unit based on whether at least one portion of the content unit is binding. However this is only one example of a criterion or criteria that the migration policy manager may use to determine where to store and or whether to migrate a content unit as any suitable criterion or criteria may be used and aspects of the invention related to determining where to store or migrate a content unit are not limited in this respect. For example in some embodiments migration policy manager may initially store a unit of content on the fixed content storage system or migrate a unit of content from the transactional storage system to the fixed content storage system only if all of the content of the unit of content is binding or if the amount of content of the content unit that is binding exceeds a certain threshold e.g. in terms of size and or percentage of the overall content of the content unit .

In some embodiments the migration policy manager may migrate a unit of content from the transactional storage system to the fixed content storage system based on an amount of time that the unit of content has been stored on the transactional storage system. For example in some embodiments if the amount of time that a unit of content that has been stored on the transactional storage system exceeds a certain threshold the migration policy manager may migrate the content unit to the fixed content storage system. In some such embodiments a unit of content may be migrated regardless of whether any of the content of the unit of content is binding or may be migrated only if some or all of the content is binding. As should be clear from the examples above any suitable criterion or criteria may be used to select either the transactional storage system or fixed content storage system as the initial storage location for a unit of content and or to determine whether to migrate a unit of content stored on the transactional storage system to the fixed content storage system.

For example a portion of a logical object i.e. a content unit that is stored on a transactional storage system may be designated as non binding and may be periodically modified by a user e.g. using an application program . When the user is done modifying the portion of the logical object the user may e.g. via the application program alter the designation of all of the non binding fields and or streams to binding.

In response to the user setting these fields and or streams to binding the migration policy manager may cause the logical object to be migrated from the transactional storage system to the fixed content storage system.

In some embodiments the criterion or criteria used by the migration policy manager may be user configurable such that a user and or system administrator may configure the system to specify under what circumstances a unit of content is stored on and or migrated to the transactional storage system and under what circumstance the unit of content is stored on and or migrated to the fixed content storage system.

For example as shown in migration policy manager may have a configuration interface by which a user and or system administrator may send configuration information to configure the migration policy implemented by the migration policy manager. The configuration interface may be used to periodically change the configuration of the migration policy.

Any suitable aspects of the migration policy may be configured. For example any of the aspects of migration policy discussed above in connection with may be configured e.g. under what circumstances a unit of content is stored on a particular storage system and or migrated to a particular storage system . In addition configuration interface may be used for example to configure which storage system serves as the transactional storage system and which storage system serves as the fixed content storage system. In some embodiments migration policy manager may be configured e.g. via the configuration interface to apply different migration policies to different content units based on one or more characteristics of the content unit. The policy applied to a particular content unit may be based on any suitable characteristic of the content unit such as for example the source of the content unit e.g. the application program or host computer that initially stored the content unit in the storage environment the size of the content unit the time of storage of the content unit or any other suitable characteristic.

In the example of migration policy manager is depicted as a box between host computer and storage systems and . However migration policy manager may be implemented on any suitable system or combination of systems in computer system . For example migration policy manager may be implemented on host computer transactional storage system fixed content storage system an appliance coupled in between host computer and storage systems and such as a NAS aggregator via which access requests from host computer are route to storage systems and and or any combination thereof. In some embodiments when migration policy manager is implemented entirely or in part in host computer the migration policy manager may implemented in the API s e.g. as a vendor interface module that the application program uses to communicate with storage systems and .

It should be appreciated that the above described embodiments for creating versions of non binding content on a fixed content storage system and the above described embodiments for configuring a migration policy and controlling migration of content between a transactional storage system and fixed content storage system may be used separately or may be used together in any suitable way.

The above described embodiments of the present invention can be implemented on any suitable computer and a system employing any suitable type of storage system. Examples of suitable computers and or storage systems are described in the patent applications listed below in Table 1 collectively the OAS applications each of which is incorporated herein by reference. It should be appreciated that the computers and storage systems described in these applications are only examples of computers and storage systems on which the embodiments of the present invention may be implemented as the aspects of the invention described herein are not limited to being implemented in any particular way.

The above described embodiments of the present invention can be implemented in any of numerous ways. For example the embodiments may be implemented using hardware software or a combination thereof. When implemented in software the software code can be executed on any suitable processor or collection of processors whether provided in a single computer or distributed among multiple computers. It should be appreciated that any component or collection of components that perform the functions described above can be generically considered as one or more controllers that control the above discussed functions. The one or more controllers can be implemented in numerous ways such as with dedicated hardware or with general purpose hardware e.g. one or more processors that is programmed using microcode or software to perform the functions recited above.

In this respect it should be appreciated that one implementation of the embodiments of the present invention comprises at least one computer readable medium e.g. a computer memory a floppy disk a compact disk a tape etc. encoded with a computer program i.e. a plurality of instructions which when executed on a processor performs the above discussed functions of the embodiments of the present invention. The computer readable medium can be transportable such that the program stored thereon can be loaded onto any computer environment resource to implement the aspects of the present invention discussed herein. In addition it should be appreciated that the reference to a computer program which when executed performs the above discussed functions is not limited to an application program running on a host computer. Rather the term computer program is used herein in a generic sense to reference any type of computer code e.g. software or microcode that can be employed to program a processor to implement the above discussed aspects of the present invention.

It should be appreciated that in accordance with several embodiments of the present invention wherein processes are implemented in a computer readable medium the computer implemented processes may during the course of their execution receive input manually e.g. from a user .

The phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of including comprising having containing involving and variations thereof is meant to encompass the items listed thereafter and additional items.

Having described several embodiments of the invention in detail various modifications and improvements will readily occur to those skilled in the art. Such modifications and improvements are intended to be within the spirit and scope of the invention. Accordingly the foregoing description is by way of example only and is not intended as limiting. The invention is limited only as defined by the following claims and the equivalents thereto.

