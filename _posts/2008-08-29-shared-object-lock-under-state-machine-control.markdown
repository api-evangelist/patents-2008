---

title: Shared object lock under state machine control
abstract: Embodiments relate to systems and methods for a shared object lock under state machine control. An operating system or virtual machine environment can host a set of multiple executing threads, and provide those threads with mutual access to one or more objects such as storage objects, memory objects, or others. The threads can independently request that the object be locked or unlocked, and the locked or unlocked state can be shared between the threads. Rather than communicate with the object(s) directly, in embodiments the threads communicate with a state machine that in turn controls the state of the object(s). When a request to change the state of the object(s) is received, the state machine can permit the object(s) to change between locked, unlocked, or other states based on the current state of the machine and the received message. Contention between threads can be reduced or eliminated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918798&OS=08918798&RS=08918798
owner: Red Hat, Inc.
number: 08918798
owner_city: Raleigh
owner_country: US
publication_date: 20080829
---
The present teachings relate to systems and methods for a shared object lock under state machine control and more particularly to platforms and techniques for operating a state machine configured to communicate with and manage objects shared between multiple executing threads.

In the context of multi threaded software execution it is necessary to coordinate the access of executing threads to the resources of a system. For example an operating system or virtual machine environment can manage multiple program threads or other executing processes some of which may wish to access resources such as disk storage or network port access at the same time. The operating system or environment may as a result incorporate a thread scheduler to control the order in which threads can access the objects.

Serializing the access to objects can entail some drawbacks however. Those include coherency or latency problems since one thread may gain access to an object only after another has modified that object but each may depend on the current state of the object or its data. In some environments such as certain versions of the Java run time environment a mechanism is provided by which a shared lock can be placed on an object such as a disk access object. In such implementations one thread or process can place a lock on an object but other threads can share access to that same object while it is locked. Similarly one thread can unlock the object on behalf of all threads sharing control of the object to restore access to other processes. However even in platforms employing a shared lock mechanism there can be difficulties in the control of the shared object including because there is no independent control mechanism to coordinate the locking and unlocking of the object apart from the threads themselves. It may be desirable to provide methods and systems for a shared object lock operating under separate logical control.

Embodiments of the present teachings relate to systems and methods for operating a shared object lock under state machine control. More particularly embodiments relate to platforms and techniques for generating a state machine coupled to one or more objects that are accessible to multiple executing threads. The threads can be applications or other programs running under an operating system or in a virtual machine environment. The multiple executing threads can share control of the one or more objects. Each thread can for instance transmit a message to the state machine requesting that the object take on a desired state. That state can be or include for example a locked state or an unlocked state. The remaining objects can for example share access to the object while it is locked. The requests for various states of the object or transitions from one state to another can all be communicated via the state machine. The state machine can receive those inputs from one or more threads and based on a set of data including the requests the state of the state machine and or the state of the object can generate a decision regarding the transition from a current state to a next state of the object. In cases the state machine can cause the object to maintain a current state. In cases the state machine can cause the object to change from a first state to a second or other state. In embodiments each state of the state machine can be associated with or correspond to a defined object class. These and other embodiments described herein address the various noted shortcomings in known object sharing technology and provide a programmer or other user with an enhanced ability to manage the execution of threads and ensure better coherency in the state of the object and or data generated by the object.

Reference will now be made in detail to exemplary embodiments of the present teachings which are illustrated in the accompanying drawings. Where possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

In embodiments as shown virtual machine environment can host or access a set of multiple threads such as executing process threads of applications or other software. The set of multiple threads can communicate with a state machine controller . The set of multiple threads can in general share access to object in a common or shared state of that resource. State machine controller can in turn communicate with an object . Object can represent a defined resource of virtual machine environment such as a disk access object an input output I O object a memory object or other object or resource available under virtual machine environment .

Object can exist in any one of a set of multiple states. Each state of object can be defined by one class in a set of state defining classes . For instance a first state of object can be a locked state. In embodiments where object is or includes for instance a disk access object a locked state of object can indicate that the set of multiple threads can access the underlying hardware disk or other storage and write or read data whereas a set of other processes running under virtual machine environment can not. A state of object can similarly include an unlocked state in which set of multiple threads as well as set of other processes can access object including the underlying storage hardware. Other objects states and executing processes are possible. For example states of object can include a cached state or an uncached state for instance related to the state of data stored in a database. In embodiments as shown any thread in set of multiple threads can transmit a request to state machine controller to request that object be placed or transitioned into a desired state on a shared basis with the remaining threads of set of multiple threads .

More particularly as illustrated in any one or more thread in set of multiple threads can transmit a state request to state machine controller . For instance a thread can request that object be placed into a locked state. State machine controller can then generate a transition decision based on state request a current state of object and or a current state of state machine controller . According to embodiments transition decision can be for instance generated by state machine controller using the following class definitions and associated logic or others.

According to embodiments a single state machine controller can be set up for each object to be controlled. In embodiments a class can be defined called AtomicStateMachine whose instances are used to manage the state of each controlled object . Every object class that is to be controlled by a state machine controller in this way in one regard can have an associated enumerated type which represents the list of possible states. This enumerated type can be used as the generic type parameter to AtomicStateMachine instance which can then be used to hold the state machine controller in a certain state using for example a read lock internally or can be used to transition to a new state using for example a write lock internally .

In step object can be instantiated on host machine for example by instantiation from a set of state defining classes hosted or configured on host machine . In step a state machine controller can be instantiated on host machine in an initial state. In embodiments object can be accessible to set of multiple threads via state machine controller . In embodiments state machine controller can be associated with or correspond to a set of state machine controller classes each class of which corresponds to a state of state machine controller . In step the state of state machine controller can be coupled to object in an initial state. For instance in embodiments object can be placed into an unlocked initial state and state machine controller can be instantiated initially from an object class for an unlocked state.

In step a message can be received from one or more thread of set of multiple threads in state machine controller requesting a desired state of object . For instance a thread can request that object be placed into a locked state. In step state machine controller can generate a decision to transition object to a new state or to maintain object in an existing state. State machine controller can generate a decision regarding a transition of object based on the request received from set of multiple threads the existing state of state machine controller and or the state or output of object . In step the state of object and or state machine controller can be updated to reflect a new state as appropriate. For example object can be placed in a locked state in which object can be assessed by other processes or software other than set of multiple threads . In step set of multiple threads can be provided shared access to object in the case where object is in a locked state as appropriate. In step as understood by persons skilled in the art processing can repeat return to a prior processing point jump to a further processing point or end.

The foregoing description is illustrative and variations in configuration and implementation may occur to persons skilled in the art. For example while embodiments have been described in which object can be in a locked state or unlocked state in embodiments object can have other states such as a sleep or power saving state an error correction state an encryption state or other states modes or conditions. Also for example while embodiments have been described in which a single state machine is configured to control one object in embodiments a single state machine can be configured to control multiple objects. For further example while embodiments have been described in which a single state machine is configured to control one object in embodiments multiple state machines can be configured to control one object. In yet further embodiments multiple state machines can be configured to control multiple objects either independently or cooperate with two or more state machines cooperating with each other. For still further example while embodiments have been described in which the set of multiple executing threads under control of the state machine are hosted on one host machine in embodiments the set of multiple executing threads can be hosted on different machines or hosts. Other resources described as singular or integrated can in embodiments be plural or distributed and resources described as multiple or distributed can in embodiments be combined. The scope of the present teachings is accordingly intended to be limited only by the following claims.

