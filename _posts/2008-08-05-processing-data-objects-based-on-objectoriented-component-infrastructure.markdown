---

title: Processing data objects based on object-oriented component infrastructure
abstract: A method, system and computer program product for implementing a high level object-oriented component infrastructure is directed to providing efficient development of programmable applications and systems. Objects of a system form an object hierarchy including child-objects and parent-objects. The system components include metadata describing properties of objects that are encapsulated into each of the components. A programmable object-oriented system locates the components placed in one or several catalogs and reads the metadata. This metadata is then used by the system for determining which module needs to be loaded for creation of an instance of an object in order to support functionality requested by another system object or by an external application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08234656&OS=08234656&RS=08234656
owner: Kaspersky Lab, ZAO
number: 08234656
owner_city: Moscow
owner_country: RU
publication_date: 20080805
---
This application is a continuation of U.S. patent application Ser. No. 11 868 292 filed on Oct. 5 2007 which is incorporated by reference herein in its entirety.

The present invention relates to object oriented programmable components and more particularly to a method and system for processing data objects based on a high level object oriented component infrastructure directed to providing efficient development of software applications and systems.

Modern techniques for developing software applications are based on an object oriented programming paradigm. In this paradigm functionality of a programmable system is implemented as an interaction between programmable objects. The programmable object according to the object oriented paradigm includes data structures and a set of procedures that retrieve data from the data structures and change contents of the data structures in accordance with particular rules. These procedures are called methods and a plurality of methods associated with an object is referred to as an object interface.

Generally objects within a programmable system belong to a particular common type and the objects of the same type have the same interface i.e. a set of methods . The types of objects are referred to as classes. Object oriented applications are typically developed using object oriented programming languages such as for example C JAVA and C . The object oriented programming languages include structures for developing object oriented executable code and can support classes and interfaces at the code level.

Typically modern programmable systems rely on a component infrastructure. The component infrastructure provides a number of functional components i.e. modules . Use of modules makes a system more efficient. For example only modules whose functionality is needed for a particular application can be loaded. Several applications can use the same modules and thereby save memory space. The system is more flexible from a development point of view since modules can be simply added or replaced to an existing system without changing an already implemented system.

In conventional implementations division of a program code into modules is not implemented directly by means of programming language whereas some of the older programming languages such as for example Turbo Pascal have means for creating separate programmable modules. In more commonly used modern languages such as C and C modular organization is implemented by a component infrastructure. The main task accomplished by the component infrastructure is to provide a mechanism for developing applications not in a form of a monolithic executable file but as a set of modules that are developed and supported separately.

An example of a general purpose component infrastructure is Microsoft Common Object Model COM . This infrastructure defines common rules of software coding that can be used for a wide spectrum of applications. However while being a general purpose infrastructure COM provides a very limited set of services performed by objects and the services available are very low level. A basic COM object can only support methods for increasing or decreasing a reference counter and for determining which interfaces are supported by the object. The high level functionality i.e. managing messages object properties and logical connections between objects has to be implemented by an application developer.

Therefore when developing applications based on general purpose object oriented infrastructures such as COM the high level service interfaces for objects have to be created for each particular application. A set of the service interfaces depends on architecture of a particular application and on the tasks it accomplishes. Typically applications directed to a particular class of tasks for example to anti virus processing require similar sets of services implemented by a component infrastructure. The object infrastructure of a higher level that can provide a means for implementing typical functional elements i.e. patterns is generally needed for improving efficiency of application development.

A typical problem that needs to be solved when developing applications is controlling resource allocation and in particular controlling life time of created objects. A reliable object infrastructure has to have a mechanism for preventing resource leaks including leaks within programmable objects. Typically these means are implemented by various garbage collection mechanisms for example in COM reference counters are used . However in programmable applications it is often necessary to limit maximum amount of resources allocated for processing an individual request. Conventional general purpose object oriented infrastructures do not provide any means for accomplishing this task.

Another typical task is an inter object transfer of information about events invoked during data processing. One of the important requirements for the information transfer between objects is an isolation of sender objects from receiver objects so that a set of the receiver objects can be changed without any changes in the code of the sender objects. An isolation of the receiver objects from the sender objects must also be ensured so that the receiver object can receive messages of a particular type without knowing which object was the sender of the message. Conventional general purpose object oriented infrastructures such as COM do not have a built in mechanism for support of inter object message transfer satisfying the isolation requirements. Built in support for isolation of senders and receivers is only provided in COM infrastructure .

Yet another task that needs to be solved when creating modular object oriented applications is cross platform portability so that the application can be easily transferred to a different operating system. It is highly desirable for an object oriented infrastructure to provide an isolation of application objects from low level application programming interfaces APIs of the operating system. Ideally an object oriented infrastructure can fully isolate components implementing the application logic from a platform dependent program interface so that platform independent components can be created.

U.S. Pat. No. 6 606 742 describes an object oriented interface that provides applications with access to functionality of the operating system. The system described herein includes a loader that dynamically loads needed fragments of executable code providing required functionality of the operating system.

U.S. Pat. No. 5 583 983 describes a system for developing object oriented applications. The system implements a program code structure in the form of archive that contains definitions of programmable objects. The structures saved in the archive can be de archived for implementation on different operating platforms. The system creates copies of platform independent object implementations.

U.S. Pat. No. 7 225 426 describes a system that implements tree object structure. Each object has a number of slots containing values of properties of the object. Property slots can be defined when the object is created or they can be dynamically added in run time.

The references discussed above address only a few of particular aspects of developing applications based on object oriented infrastructure. However efficient development of programmable applications requires a comprehensive approach to solving the typical tasks discussed earlier. Therefore there is a need in the art for a high level object oriented component infrastructure directed to solving typical common tasks with regards to development of software applications and systems.

Accordingly the present invention is directed to object oriented programmable components and more particularly to a method and system for implementing a high level object oriented component infrastructure directed to providing efficient development of programmable applications and systems that substantially obviates one or more of the disadvantages of the related art.

According to one embodiment a system method and computer program product for processing data objects are provided. In one embodiment a programmable application implements an anti virus processing of data objects. Special system components check data objects content for signatures of computer viruses. Other components are responsible for functionality directed to unpacking of archives and packed objects. And yet other system components implement various service functions.

In another embodiment system components include metadata describing properties of objects that are encapsulated into each of the components. A programmable object oriented system locates the components placed in one or several catalogs and reads the metadata. This metadata is then used by the system for determining which module needs to be loaded for creation of an instance of an object in order to support functionality requested by another system object or by an external application.

In another embodiment a programmable object oriented system has a capability for dynamically changing a set of components by loading the components in the process of regular update of anti virus databases. The same instances of platform independent components can be used by applications run on different operating systems implemented on compatible platforms.

In an exemplary embodiment a special high level description language for creating object interfaces is used. Initial files are processed by a compiler of this language for creating files that can be processes by common high level language such as for example C C C JAVA etc. These files provide formal description for implementation of the object interfaces using common languages. They also integrate the object interfaces into modules and implement system requirements with respect to registration and functioning of the modules.

Additional features and advantages of the invention will be set forth in the description that follows and in part will be apparent from the description or may be learned by practice of the invention. The advantages of the invention will be realized and attained by the structure particularly pointed out in the written description and claims hereof as well as the appended drawings.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are intended to provide a further explanation of the invention as claimed.

Reference will now be made in detail to the preferred embodiments of the present invention examples of which are illustrated in the accompanying drawings.

A programmable object includes data structures and a set of procedures that retrieve data from the data structures and change content of the data structures in accordance with a particular set of rules. These procedures are called methods and a plurality of methods associated with an object create an object interface. In the described embodiment some methods of the object interface have the semantics of receiving and setting values for certain attributes properties associated with the object. Such attributes are considered part of the object interface and are called object properties . An object property is a named attribute of an object that has specific methods of receiving and setting its value. The objects belong to one of the common types. The objects of the same type have the same interface i.e. set of methods and properties and are referred to as class.

One of ordinary skill in the art would appreciate that the examples given herein are not exhaustive and many other embodiments and examples of software components and objects that can be implemented in a manner described herein can be contemplated in the context of an object oriented infrastructure.

means for supporting loading of programmable components some of which are implemented in an operating system independent manner.

In an exemplary embodiment each object supports a programmable interface implemented as a set of methods and properties. Each object contains a set of typical properties that can be changed during system execution. Each object has a general purpose system interface that includes the following exemplary methods 

The system implementation according to the preferred embodiment is based on the following approach. A programmable system is divided into modules. Each module contains code that implements functionality of the methods of one or several classes of objects. The system includes a loader module that performs loading of modules needed for implementation of functionality requested by other modules.

Programmable objects of the proposed infrastructure form a hierarchy. Each object except for the root object has a parent object and a number of child objects. The hierarchy is used for controlling object s life span i.e. when an object is destroyed all of the child objects are automatically destroyed as well . The hierarchy is also used for implementation of mechanism of sending messages from to child objects and from to parent objects.

Each object implemented by the programmable system has an application interface defined by a class the object belongs to. In addition to the application interface all objects have a system interface that is common for all of the objects in the system. The system interface includes the following exemplary methods for 

Modules of the programmable system can be of two types system dependent and system independent. The system dependent modules are the ones that directly use the functionality of an operating system. The system independent modules use only the functionality of other modules system dependent or system independent . The system independent modules can be presented in a format that allows using the modules on any operating system run on a compatible platform as for example Microsoft Windows Linux or Mac OS X run on any processor with x86 architecture.

Object interfaces and their metadata parameters including class identifiers are preferably described using a specialized interface description language. Such interface descriptions are then processed by an interface definition compiler. The interface definition compiler produces a set of files in the target language for example C containing template code of an object implementing the given interface.

An exemplary object s structure is shown in . The object includes an application interface an internal interface and a system interface . The application interface is implemented using methods . Functionality of code and data used for implementation of the application interface is defined by a developer of a particular module. As a rule the application interface is intended for a class of objects. Each object of a programmable system includes a standard system interface that is supported by all of the objects of a particular system.

The system interface is implemented using system interface methods . Each object also supports a set of internal methods that create the internal interface . The internal methods are service methods invoked by the system. Examples of the internal methods are a response to creation or termination of an object or a response to receipt of messages sent by other objects. The responses of an object to different events are determined by a developer of a particular module and can be different for different classes of objects.

Implementation of methods of the internal interface is determined by the developer of a programmable module. However unlike the methods of the application interface not all the methods have to be implemented by the module developer since the system calls methods only if they are implemented for notifications about system events. A custom implementation of the methods of the internal interface is only needed when the developer needs to add some response about events that take place in the system e.g. creating and destroying objects receiving messages etc.

As discussed above an object interface includes methods and properties that have to be supported by all of the implementations of this interface. The implementation of the interface in this discussion means a combination of code and metadata that defines the behavior of a particular object that supports a given interface. For example an interface IO for accessing data contains methods Read and Write and has a property SIZE. Many implementations of the IO interface can exist. A FILE implementation can be used as one of the examples of a typical implementation of the IO interface. The FILE implementation provides support for operations with files over an interface of a file system. Another example is BUFFER implementation that supports operations with data stored in memory. A system can concurrently have any number of both types of objects with different implementations of the IO interface.

Despite the fact that different implementations of IO interface share the same set of methods and properties belonging to the interface each specific implementation can extend the set of properties with its own special properties. For example the implementation FILE for a particular instance of an object can require a file name and open mode parameters for opening the file while the implementation BUFFER may require a pointer to object s data and its size. Therefore each implementation has to support specific interface extensions created just for the given implementation. Such extensions are often bound to the inner functionality of specific implementation and are not sufficiently general to be added to the declaration of the base interface.

In a programmable system of the preferred embodiment the problem of the implementation specific interfaces is addressed by broadening a set of properties of the base interface. Any interface implementation can extend the set of properties i.e. add properties of the base interface indefinitely. The properties added in a particular implementation are referred to as implementation properties as opposed to interface properties that belong to the particular base interface.

The implementation and interface properties discussed in the above examples are shown in . The base IO interface contains methods Read and Write and Attributes Size. Both implementations FILE and BUFFER support methods and properties of the base IO interface . They also add to the properties of the IO interface their own implementation properties and respectively.

The implementation FILE properties are FILE NAME name of a file in a file system and OPEN MODE a set of flags determining the desired access to the file data for example whether write access is required or whether the file must be created if it does not yet exist in the file system . The implementation BUFFER properties are DATA PTR pointer to an external data buffer DATA SIZE size of the externally provided data buffer and ACCESS MODE a set of flags for controlling access to the contents of the buffer e.g. whether write access is allowed or whether the data must be copied to an internal buffer before use .

In the preferred embodiment besides the interface properties and implementation properties each object can have a set of custom properties. In contrast to interface properties the set of custom properties is not specified during object development. The custom properties can be added to an object in an arbitrary manner by other objects during system deployment. Reading and writing the values of the custom properties can be performed using the same methods as for the interface and the implementation properties. In the preferred embodiment ranges of identifiers of the properties of each type are different and a possibility of collision of properties of different types is eliminated.

In the programmable system according to the preferred embodiment creation of object instances can be performed in two phases as illustrated in . In the first phase in step a partially initialized object structure is created by invocation of a method ObjectCreate of a parent object. The arguments that are passed with the method are an identifier of the interface and optionally an identifier of the implementation. Then in step the properties needed for correct object initialization are set. Note that these can be interface properties and or implementation properties. At this stage object methods cannot be invoked as the object is not yet fully initialized.

At the second phase in step the method for final object creation ObjectCreateDone is invoked. After this method is correctly executed the object is fully constructed and is ready for use. In case of incorrect values of the initialization properties or other errors the method for final object creation can return an error code and object creation is considered as failed.

Alternatively the process of object creation can be optimized by combining both of the above phases in cases when object creation does not require setting of the initialization properties or if the values of these properties are considered to be correct by default. A single stage object creation is implemented by the method ObjectCreateQuick. The object creation process returns a descriptor i.e. object handle that is used for invocation of the methods of the system and the application interfaces. These methods can include reading and writing the properties values creation and termination of objects and sending messages.

In the implementation of the programmable system of the preferred embodiment all the created objects form a hierarchy. One of the objects serves as a root of the hierarchy. It exists throughout the life time of the system. Other objects are always created as the child objects of other objects including the root object . In such a hierarchical system implementation methods used for object creation are the methods of a standard system interface of an object. Thus each object has the methods for creation its own child objects. An object termination is implemented by a method of a system interface of an object ObjectClose.

In the proposed system implementation the system hierarchy can be used for controlling the life span of created objects. When an object is destroyed all of its child objects are automatically destroyed as well. Thus the system implements an automatic method for freeing up the unused system resources. When each object is being destroyed the system invokes its internal method OnObjectClose. The implementation of this method can free up additional system resources memory etc.

In the preferred embodiment the object hierarchy is also used for controlling an aggregated volume of the resources such as for example aggregated memory consumed during processing specific request. For example an anti virus application can monitor the amount of resources allocated for processing of a certain file. In the case of archives the anti virus processing of the file requires unpacking of archive contents and recursive processing of files stored in the archive. In the programmable system described herein the set of objects instantiated during archive processing can form an object hierarchy. In such a hierarchy the archive file serves as a root object and the archive contents as child objects on different levels. Then the system can monitor the total amount of resources allocated for processing archive object with all of its sub objects for example total amount of memory .

A structure of an exemplary standard system interface implemented for each object is shown in . The methods of the standard system interface are divided into the following categories 

This method creates an object structure. The system finds a module that contains an instance of an object implementation that satisfies certain criteria. The identifier of a requested interface has to be specified. Optionally the identifier of the module where the interface is implemented can be specified. If an arbitrary interface implementation is allowed than the IMPLEMENTATION ID value can be set as IMPLEMENTATION DEFAULT. This value means that the system will provide a default implementation of a given interface.

Object creation is completed by method ObjectCreateDone. This method completes object creation after the values of required properties have been set by a method PropertySet.

A single phase object creation method ObjectCreateQuick INTERFACE ID IMPLEMENTATION ID HANDLE invokes ObjectCreate and ObjectCreateDone methods. Object destruction can be performed by ObjectClose HANDLE method. An implementation of this method results in destruction of all of the child objects within the hierarchy.

 2 The methods for navigation through the hierarchy . A method ParentGet HANDLE returns a descriptor of a parent object. A method ChildGetFirst CHILD ENUM DATA HANDLE returns a descriptor of a first child object and initializes a structure CHILD ENUM DATA that is passed into a method ChildGetNext.

A method ChildGetNext CHILD ENUM DATA HANDLE returns a descriptor of a next child object and modifies the structure CHILD ENUM DATA so that the next invocation of the method ChildGetNext returns the next child object.

A method ProperyIsPresent PROPID BOOL. This method returns a Boolean value TRUE if the value of the property with identifier PROPID is set on a given object and returns FALSE otherwise.

A method PropertyGet PROPID VALUE. This method returns a value of a property with the identifier PROPID. The VALUE represents data object that can accept various data types i.e. data type VARIANT in COM model . The value of a property can be received by invoking a method of an internal object interface OnProperyGet.

A method PropertySet PROPID VALUE sets a value of a property with identifier PROPID. If the property with this identifier does not exist and the property is a custom property it is created. For setting a value of a property a method of an internal object interface OnProperySet is invoked.

A method PropertyDelete PROPID removes the property with the identifier PROPID from the set of custom properties of an object.

A method PropertyNext PROPID PROPID facilitates listing of the identifiers of the properties set on the object. In order to receive a first identifier a special value PROPID FIRST is passed through the method. For receiving the value of each subsequent identifier the value of the previous identifier needs to be passed through this method.

A method SetObjectHeap HEAPOBJ facilitates binding of an object with object s memory pool. If an object is bound to its own memory pool then memory allocation performed by this object and its child objects is implemented through this memory pool. Thus an aggregated memory volume allocated for processing an individual request can be controlled. Note that during processing of the request a hierarchy of objects processors is created.

A method HeapAlloc SIZE PTR facilitates memory allocation using memory pool bound to an object. If a given object does not have its own memory pool than a request is re addressed to a nearest parent object that is bound to a memory pool or if such an object does not exist the request is passed on to the root object.

A method HeapRealloc PTR SIZE PTR facilitates size changes of a previously allocated memory block. An additional memory is allocated from the same pool from which the memory was allocated for the previous block see method HeapAlloc .

A method HeapFree PTR frees up a block of memory that was allocated earlier by HeapAlloc or by HeapRealloc methods.

A method SendMsg MSG CLASS MSG ID MSG DATA STATUS. This method facilitates sending a message to a parent object. The message is passed upwards through the hierarchy of parent objects until it reaches a root node of the hierarchy or until it is stopped by one of the processing objects.

A method BroadcastMsg INTERFACE ID MSG CLASS MSG ID MSG DATA STATUS. This method facilitates sending messages to child objects. Each child object automatically sends messages to its respective child objects. The messages are sent only to the objects with interface identifier INTERFACE ID. If the INTERFACE ID has the value INTERFACE ANY the messages are sent to all of the objects.

A method RegisterMsgHandler MSG CLASS MODE RECV OBJECT facilitates object s subscription for receiving messages that go through a particular object. The object referenced by RECV OBJECT is registered to receive messages passed through the target object. When a message is passed through the target object the system checks whether there are receiver objects registered on the target object for messages with class equal to MSG CLASS. For each such receiver object the system calls its internal method OnMsgReceive passing the message with its associated message data.

A method UnregisterMsgHandler MSG CLASS RECV OBJECT terminates object s subscription for receiving messages that was set by invoking the method RegisterMsgHandler.

A structure of an internal interface of an object according to the preferred embodiment is illustrated in . The internal interface of an object includes the following methods 

A method OnObjectInit STATUS. The system invokes this method at the first phase of an object creation i.e. in the process of execution of ObjectCreate method . Implementation of this method can include procedures for initialization of the internal structures of the given objects.

A method OnObjectInitDone STATUS. The system invokes this method at the second phase of the object creation i.e. in the process of execution of ObjectCreateDone method . Implementation of this method can perform operations for final preparation of the object using property values set between invocations of ObjectCreate and ObjectCreateDone methods.

A method OnObjectClose STATUS. The system invokes this method in the process of removal of objects. An object removal can be initiated by a direct call of a method ObjectClose or it can be implemented automatically as a result of an automatic removal of a parent object. Implementation of this method performs operations connected to cleaning internal data structures connected to a given object.

A method OnMsgReceive MSG CLASS MSG ID HDL SENDER MSG DATA STATUS. This method is invoked by the system when an object receives a message. An object can receive a message if it goes through the object according to the message handling rules or if the object is registered as a recipient of messages addressed to another object. The return value of this method STATUS is used by the system to control message propagation. One special kind of return value is STATUS MSG DONE telling the system to stop further propagation of the message to other objects.

In object oriented infrastructures message handling is implemented in an indirect i.e. metaphorical manner. Sending messages is a method of inter object communications. Note that an object that sends a message is not aware of what objects receive and process this message unlike a conventional communication based on direct method calls. Sending messages using metaphorical approach is advantageous because the connection between the source objects and message processing objects is less rigid. The more flexible inter object connection simplifies development of complex systems. In different object oriented infrastructures many schemas of message handling are employed. For example in a COM architecture the interface IConnectionPoint is used. This interface can be supported by any COM object. However implementation of such an interface has to be written by a developer of each individual component because the COM infrastructure does not provide necessary ready to use primitives for message handling.

The system implementation according to the preferred embodiment offers a universal model for sending and receiving messages based on a hierarchical object structure. Each object supports a list of subscriber objects subscribing to messages of a particular class. The support of subscriber lists is facilitated by the system and a developer of application objects does not have to do it manually as in the case for example of COM architecture.

In the preferred embodiment messages are allowed to be sent in both directions up and down the hierarchy. If the message is sent up the hierarchy it is sent to a parent object and then to a parent of this parent object and so on until it gets to the root object. If the message is sent downwards in the hierarchy it is sent to all child objects and then to child objects of the child objects and so on all the way down. The objects located on different levels can process the message passing through them. It is also possible to associate an object with a target object. The associated object serves as a receiver that receives the messages that pass through the target object it is done through a subscription registration .

According to the preferred embodiment the messages are distinguished by a class of a message and an identifier of a message. Grouping messages by class provides for optimization of message handling because an object can subscribe to receiving only messages of a particular class. When an object receives a message the system invokes a method of an internal interface OnMsgReceive in this object. When processing a message an object can stop propagation of this message further returning special status value STATUS MSG DONE message processing is considered complete in this case .

A message handling schema according the preferred embodiment has a number of advantages. In particular 

 1 a mechanism for controlling reception of messages is synchronized with a mechanism for controlling a life span of the objects thus eliminating a possibility of sending a message to an already destroyed object 

Modular development of programmable applications is implemented in the proposed system by a special component model that uses a separate module file containing implementation of one or several programmable object interfaces as a component. The module includes code which ensures the functionality of the methods supported by the interface as well as metadata describing which interface implementations are supported by this module.

During system initialization the contents of one or several folders according to a particular configuration is scanned. The metadata is read from all of the components located in the folders. The metadata contains information regarding which interfaces are implemented by a particular module i.e. a list of interface identifiers and a list of implementations . Using this information the kernel of the system builds a service table. The service table determines which module needs to be loaded for instantiating an object having a particular interface identifier and an implementation identifier if it is set .

Upon request for instantiating an object implementing interface IF with a set implementation identifier B the system loads module B because it was explicitly requested as an implementation identifier .

Upon request the system loads module C because it is the only module containing implementation of objects with interface IF.

In one embodiment the proposed object oriented programmable system can be used for development of anti virus applications. One of the specific problems in developing anti virus applications is a necessity for frequent updates of the code that detects virus threads and other potentially destructive files. The frequently updated code needs to be tested on different platforms such as for example Microsoft Windows Linux Solaris FreeBSD etc. The updates of anti virus code can be very frequent and how fast the new code is delivered to a user is critical. Therefore all measures that can reduce testing time are highly desirable.

In the preferred embodiment code updates and testing can be optimized by dividing the modules containing the anti virus code into platform independent and platform dependent components. The platform independent modules contain code that is isolated from the interfaces of the operating system. These modules can be loaded without code changes onto any operating system using the same type of CPU. These modules are implemented in a platform neutral format and are loaded by a special loader as a part of an anti virus application.

Platform independent modules do not depend on an operating system and need to be tested only once for a given type of processor. Thus the time of anti virus updates is reduced and the anti virus application becomes more reliable.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a personal computer or server or the like including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes a read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between the elements within the personal computer such as during start up is stored in ROM . The personal computer may further include a hard disk drive for reading from and writing to a hard disk not shown herein a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media that can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system e.g. Microsoft Windows 2000 . The computer includes a file system associated with or included within the operating system such as the Windows NT File System NTFS one or more application programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus and they may also be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include a host adapter that interfaces to a storage device over a bus and other peripheral output devices not shown such as speakers and printers.

The personal computer may operate in a networked environment using logical connections to one or more remote computers . The remote computer or computers may be another personal computer a server a router a network PC a peer device or other common network node and it typically includes some or all of the elements described above relative to the personal computer although here only a memory storage device is illustrated. The logical connections include a local area network LAN and a wide area network WAN . Such networking environments are common in offices enterprise wide computer networks Intranets and the Internet.

In a LAN environment the personal computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment the program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are merely exemplary and other means of establishing a communications link between the computers be used. Such computers as described above can be used in conventional networks e.g. the Internet local area networks regional networks wide area networks and so forth. These networks can link various resources such as user computers servers Internet service providers telephones connected to the network and so on.

Having thus described a preferred embodiment it should be apparent to those skilled in the art that certain advantages of the described method and apparatus have been achieved. It should also be appreciated that various modifications adaptations and alternative embodiments thereof may be made within the scope and spirit of the present invention. The invention is further defined by the following claims.

