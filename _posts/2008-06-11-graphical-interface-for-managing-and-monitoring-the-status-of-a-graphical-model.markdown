---

title: Graphical interface for managing and monitoring the status of a graphical model
abstract: In an embodiment, a method for managing and monitoring a graphical top model includes executing the graphical top model. The graphical top model references multiple instances of at least one graphical model. The method also generates a graphical user interface that displays a component from a graphical model. The displayed component is referenced by at least two of the model instances. The graphical user interface displays a current calling hierarchy indicative of a specific model instance that is associated with the displayed component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08745537&OS=08745537&RS=08745537
owner: The Mathworks, Inc.
number: 08745537
owner_city: Natick
owner_country: US
publication_date: 20080611
---
The present application is related to a United States Patent Application entitled Status Indicator for Concurrent Computing Units Executing a Concurrent Computing Process application Ser. No. 11 497 878 filed on Jul. 31 2006 the contents of which are incorporated herein by reference in their entirety. The present application also claims the benefit of a United States Provisional Patent application entitled Graphical Interface for Managing and Monitoring the Status of a Graphical Model Application No. 61 028 988 filed on Feb. 15 2008 the contents of which are incorporated herein by reference in their entirety.

Graphical models are constructed from a variety of model components e.g. blocks representing functions subsystems etc. . In addition a graphical model may also include one or more references to instances of the same or different graphical models. When another model is referenced execution of the original referencing model referred to herein as the top model is dependent on the execution of the referenced model s . The referenced model s may be executed as part of the same computing process as the top model. Alternatively a referenced model may be executed by a concurrent computing process executing on concurrent computing units.

Concurrent computing processes enable complex analyses and modeling operations to be performed using multiple concurrent computing units. The concurrent computing units that are executing the concurrent computing process may communicate in distributed or tightly coupled environments. Exemplary concurrent computing processes include distributed and parallel computing processes. Distributed computing processes are part of an application or process that is segmented and executed on loosely coupled computing devices. Parallel computing processes are part of an application or process that is segmented and executed simultaneously. A parallel process may or may not execute on separate computing devices. Exemplary concurrent computing processes include applications providing technical computing environments adapted for modeling of dynamic systems.

Exemplary embodiments of the present invention enable a user to monitor and manage the execution and or debugging of a graphical top model. The term top model is a relative term and should not be construed in an absolute sense. The graphical top model may directly or indirectly reference multiple model instances of the same graphical model. Additionally the graphical top model may include model components directly or indirectly referencing the same display component. A graphical user interface may identify which of the model instances referenced by the graphical top model is associated with the information being displayed during the execution or debugging of the top model. This identification of a specific one of the multiple model instances referenced by the top model as the instance that is currently calling the displayed model or model component may allow a user to properly interpret the displayed data.

For example in one embodiment a displayed component utilized during the execution of the graphical top model may be a software scope block that generates a window in which data values associated with a model simulation may be displayed. The data values displayed by the software scope block may change based upon which of several model instances referenced by the graphical top model called and fed data to the software scope block. The display of a calling hierarchy with the displayed component data allows a user to identify which of the several model instances referenced by the graphical top model called the displayed component the scope . The graphical user interface may also enable a user to enter input parameters for the graphical top model and to change the currently displayed calling hierarchy.

Graphical programming languages and graphical modeling environments enable the construction of graphical models that may be used to model dynamic systems. Graphical programming languages provide a wide array of functionality that may be utilized during model design. For example a user may graphically model a dynamic system using a block diagram model a state diagram model a flow diagram model a data flow diagram model etc.

Graphical model designers may build a large application model using a hierarchy of one or more models that are referenced by a graphical top model. Each referenced model can be referenced multiple times in the hierarchy. Different instances of a referenced model may execute and have different states at the same or different instances in time. The state of a model may be represented with different values. The values from different model instances referenced by a graphical top model may be displayed via a common component e.g. a software scope .

For example depicts an exemplary top model s calling hierarchy. depicts an exemplary model hierarchy in which a graphical top model hereafter top model references a first instance of a model sub1 and a second instance of the same model sub2 . Both sub1 and sub2 may reference the same component when executing. Component may be a model block or other model element referenced via more than one calling hierarchy. This scenario may pose difficulties to a user who is running or debugging top model because the user viewing a display of component may be left uncertain as to which instance of the referenced models sub1 or sub2 called for the component to be displayed. Knowledge of a calling hierarchy indicating which model instance called component may be important for a user in interpreting the results of a model s execution for example in those circumstances when sub1 and sub2 possess different states.

For instance component may be a software scope displaying data values associated with a model instance that is called the software scope i.e. the model instance that requested the scope generate a window displaying data values . If sub1 and sub2 contain different data values the data displayed by component will differ depending upon which model instance is calling component . In order for a user debugging top model to make sense of the data being displayed by component the user needs to know whether sub1 or sub2 called component i.e. the user needs to know the calling hierarchy .

Similar concerns are present in the situation where a graphical user interface is being generated directly displaying a referenced model instance when the top model references multiple instances of the same model e.g. sub1 or sub2 . For example a view of a referenced model may be shown that includes signal values. If the calling hierarchy is not identified the user may be unable to tell which instance of the model called by the top model is being displayed.

Exemplary embodiments provide a graphical user interface that may be used to specify all or part of a calling hierarchy detailing the particular model instance that is calling a displayed model or model component such as component . This specification of a calling hierarchy may be useful in debugging a top model. For example the ability to specify in a graphical user interface the identity of a caller of a displayed component is useful when interpreting displayed port value labels display blocks software scope blocks referenced models etc. as the user is able to identify the model instance associated with the displayed component.

In one embodiment the calling hierarchy displayed by the graphical user interface may indicate that a model is being referenced indirectly. For example a top model may reference two instances of different models which each reference an instance of the same model. The two instances of the same model are referenced by instances of different models but include the same top model at the root of the calling hierarchy.

An additional benefit provided by the ability to specify a calling hierarchy is that the selection of a calling hierarchy enables a user to set conditional breakpoints when debugging a top model that utilizes a component shared by at least two referenced model instances. In such a circumstance the location of the conditional break point may depend upon the call stack for a particular calling model instance e.g. the location of the breakpoint the status of the breakpoint etc. may differ depending on whether sub1 or sub2 are calling component . The specification of the calling hierarchy simplifies the process of setting a breakpoint by providing additional information to a user.

A number of mechanisms may be used to identify a calling hierarchy and choose which particular call stack i.e. which referenced model instance s call stack to include when debugging or executing a top model. For example the title bar of the graphical user interface window may list the calling hierarchy. Similarly the title bar of the graphical user interface window may list the calling hierarchy and provide a tool such as a pull down menu by which the user may change the hierarchy. Likewise a right click context menu may be displayed when the user clicks on a graphical component that allows a user to identify and or select the calling instance. Tooltips may be provided in the graphical user interface when hovering a mouse or other selection tool over software scopes or signal lines. The tooltips may be accompanied by a selector mechanism. In one embodiment a special syntax may be provided for a debugger that allows the user to specify the calling hierarchy. In alternative embodiments other mechanisms may also be used in place or in addition to those described above. It should be appreciated that the above discussed mechanisms are merely illustrative and not an exhaustive listings of the available mechanisms for identifying and or changing calling hierarchy when executing a top model.

Examples of different mechanisms used to display and select calling hierarchy are depicted in . depicts an exemplary graphical user interface displaying a current calling hierarchy. The graphical user interface may be used by an embodiment to display a current calling hierarchy in which a top model A has called an instance of a graphical model B . A title bar pull down menu indicates that the displayed model B in is a first instance of model B referred to as B1 . The B1 instance of the model includes a Sine Wave generation block providing an input signal to a first instance of a model C C1 . The model instance B1 also includes a ramp signal block that is providing an input signal to a second instance of model C C2 .

Similarly depicts an exemplary graphical user interface that includes a current calling hierarchy associated with a displayed component called by the model depicted in . depicts the display of a current calling hierarchy in which a top model A has called an instance of a graphical model B1 depicted in which has in turn called a first instance of model C C1 . Model C includes an input ln1 that provides an input signal to a gain block . The gain block provides an output signal to a software scope block . Since the gain block has a multiplier value of 1 in this example the output signal will equal the input signal . The title bar for the graphical user interface provides an indicator that indicates that the first instance of model C C1 is being displayed. In one embodiment a selection tool in the form of a scrollable pull down menu or other mechanism is provided from which the user can change the calling hierarchy. In one embodiment model C also displays a current value of the input signal .

The effect of selecting different instances of models may be seen in reference to . is an exemplary graphical user interface displaying output and an indicator of a calling hierarchy for a component associated with multiple instances of a graphical model. An indicator in the title bar displaying the output from the software scope block indicates that the current calling hierarchy is A B1 C1 . A selector mechanism allows the calling hierarchy to be changed by a user. The displayed signal is a Sine Wave. A user viewing the displayed output is aware not only that he or she is viewing output from the software scope block but also is aware that the software scope block is associated with the first instance of model C C1 .

In the event the user uses the selector mechanism to change the calling hierarchy to A B1 C2 the display depicted in may be shown. is an exemplary graphical user interface displaying output and an indicator of a different calling hierarchy for the displayed component. The indicator now indicates the current calling hierarchy is A B1 C2. The hierarchy indicates that it is the output from the scope block associated with the second instance of model C that is being displayed. Accordingly as C2 accepts a ramp signal from B1 the displayed signal for C2 is a ramp signal and not a Sine Wave.

In one embodiment in addition to displaying a calling hierarchy a graphical user interface may be used to target commands to specific components in model instances that have been referenced by a top model. The display of a calling hierarchy allows a user to selectively target commands to a particular component in a model instance referenced by the top model when debugging the top model. A number of mechanisms may be used to target commands. In an embodiment certain displayed components may be altered by right clicking on the component and entering a new parameter utilizing a menu. For example by right clicking on a gain block a user may be able to change the multiplying value from 2 to 4 and observe the result. In another embodiment clicking on a portion of a calling hierarchy in a displayed indicator e.g. clicking on B1 in an A B1 C2 hierarchy may provide a dialog box or command line into which a user can enter commands to change component values.

Exemplary embodiments of the present invention may provide a graphical user interface for a concurrent computing environment. In one embodiment a graphical user interface may allow a user to monitor and manage the execution of a graphical top model being executed on multiple concurrent computing units. The graphical user interface may indicate information regarding the status of the execution of the various referenced model instances being executed in the concurrent computing environment. In an embodiment the graphical user interface may include a selector mechanism that allows a user to select specific concurrent computer units about which the user wishes to receive information during the execution of a graphical top model. The graphical user interface may allow the user to target specific concurrent computer units to receive commands. In another embodiment a graphical user interface may enable the debugging of a graphical top model being concurrently executed so as to allow the user to adjust tunable parameters being used for model execution.

The display of concurrent computing unit status during the execution of a graphical top model may address problems found when converting a traditional desktop modeling application into a concurrent computing process. Traditionally a single user interface has been used for both an individual computing unit application and a concurrent computing application environment. Thus the same interface was used regardless of the number of computing units being utilized. While the output of the model being executed could be shown via the interface the use of the traditional user interface made it difficult to differentiate and monitor the status of each concurrent computing unit in the concurrent computing environment. This inability to visualize the concurrent execution became even more significant in a graphical modeling environment where the display of a graphical model must convey information regarding the status of the execution or debugging of the graphical model on all of the concurrent computing units.

Graphical model may be a block diagram model a block diagram model that includes an imported UML model a state diagram model a flow diagram model a data flow diagram model etc. The results and or information regarding the status of the execution of graphical model by concurrent computing units and may be tracked by a monitoring facility that is in communication with concurrent computing process and or . Monitoring facility is preferably implemented in software but may also be implemented in hardware. Although pictured separately as a stand alone process in it will be appreciated that monitoring facility may also be integrated into the instance of concurrent computing process that is being hosted by concurrent computing unit and is being accessed by user . Alternatively monitoring facility may be implemented as a plug in for concurrent computing process .

The graphical model may be displayed to user via graphical user interface before during and or after execution. In the example depicted in the graphical model displayed in GUI is executed sequentially by concurrent computing units and . For example graphical model may include a subsystem A block a gain block a subsystem B block and a subsystem C block . Subsystem A block may provide its output as input to gain block . Gain block may provide its output as input to subsystem B block . Subsystem B block may provide its output as input to subsystem C block . Subsystem C block may provide its output as part of the input to subsystem A block .

Graphical model may be executed in a concurrent computing environment because of a general availability of computing resources and or because of the presence of specialized resources associated with individual concurrent computing units. Therefore in one embodiment subsystem A block and gain block may be executed by concurrent computing process on concurrent computing unit . The output from gain block may be provided as input to subsystem B block being executed by concurrent computing process on concurrent computing unit . Similarly the output from subsystem B block may be provided as input to subsystem C block being executed by concurrent computing process on concurrent computing unit . The output from the execution of the subsystem C block may then be provided to concurrent computing unit for use as input in the execution of subsystem A block .

During the execution of graphical model by concurrent computing units and a view of graphical model in graphical user interface may be updated. Monitoring facility may receive information regarding the status of the execution of graphical model by concurrent computing process and that is displayed via graphical user interface . A graphical indicator may be provided in the graphical user interface to indicate the current status of the execution of graphical model by concurrent computing units and . The displayed information may include a calling hierarchy or other identifier that identifies the portion of graphical model that is being executed on the respective concurrent computing units.

For example depicts exemplary graphical user interface during the execution of the model described in . Each of model components and may have indicators that indicate which concurrent computing unit and is responsible for the execution of that model component. Thus subsystem block A and gain block may have indicators indicating that they are to be executed by or are being executed by concurrent computing unit . Subsystem B block has an indicator indicating that it is to be executed by or is being executed by concurrent computing unit . Similarly subsystem C block has an indicator indicating that it is to be executed by or is being executed by concurrent computing unit .

Additionally for concurrent processing of sequentially executed models the graphical user interface may indicate which concurrent computing unit is currently active and executing. Thus a dashed box may be placed around the subsystem B block that includes a label indicating that the block is now active . Similarly an indicator such as a W for waiting may be added to subsystem A block gain block and subsystem C block to inform a user that those blocks are not currently being executed. It will be appreciated that instead of boxes and labels colors and or designs may also be utilized to indicate which model components are currently being executed. For example subsystem C block which is active could be displayed in the color green while the remainder of the model components could be displayed in red. It will further be appreciated that model parameter information and calculated results may also be displayed in the graphical user interface .

A concurrent computing environment may also be used to execute multiple instances of the same model using different parameters. depicts an exemplary embodiment in which a graphical user interface is used to display the status of different instances of a graphical model that are being concurrently executed using different parameter information. A graphical model A is concurrently executed by the concurrent computing units and using different parameter information. In one embodiment the parameter information may be input by a user. Thus concurrent computing process on concurrent computing unit may execute an instance of graphical model A with a first set of parameter information referred to herein as A . Concurrent computing process on concurrent computing unit may execute a different instance of the same graphical model A using a second set of parameter information referred to herein as A . Concurrent computing process on concurrent computing unit may execute another instance of graphical model A using a third set of parameter information referred to herein as A .

Graphical user interface may dynamically display information regarding the status of the concurrent execution of the versions of the graphical model A A A and A to a user viewing a display that is communicating with concurrent computing unit . For example as illustrated in an exemplary graphical user interface may indicate that model instance A is executing a gain block with a parameter of 1 and that the output of subsystem block D is currently 12 . Similarly graphical user interface may indicate that model instance A is executing a gain block with a parameter of 2 and that the output of subsystem block D is currently 20 . Likewise graphical user interface may indicate that model instance A is executing a gain block with a parameter of 4 and that the output of subsystem block D is currently 35 . Although depicts the views of the model instances A A and A as being displayed in a side by side fashion it will be appreciated that they may also be displayed one at a time pair wise etc. with a control allowing a user to toggle between the model instances. A calling hierarchy or other indicator may be provided so that a user can determine which model instance is being displayed. The views of the model instances may alternatively be consolidated into a single displayed model view which contains information about some or all of the model instances being executed by the concurrent computing process. For example a gain block representation could list three different values in three different colors while the output of a subsystem block could also be listed in three different colors with each color assigned to one of the model instances being executed.

In another example depicts an exemplary embodiment in which a graphical user interface is used to display the status of a graphical model being concurrently executed in a debug mode. The different instances of the concurrent computing process may execute different versions of the graphical model or may execute the same version of the graphical model but with breakpoints located at different portions of the model. For example a graphical model B may be concurrently executed by concurrent computing units and in a debug mode using different input parameter information or different breakpoints. Thus concurrent computing process on concurrent computing unit may execute a model instance with a breakpoint set to a first location referred to as model instance B . Concurrent computing unit may execute another instance of the same model that has a breakpoint set in a different location referred to as model instance B . Concurrent computing unit may execute the same graphical model instance but without setting any breakpoints referred to as model version B . Graphical user interface may dynamically display the status of the concurrent execution of the model instances B B and B to a user viewing display .

For example as illustrated in exemplary graphical user interface may indicate that model instance B includes a breakpoint just prior to executing subsystem block E and that execution of the model instance is currently stopped at the breakpoint. Similarly graphical user interface may indicate that model version B includes a breakpoint in subsystem block F but may indicate that the model version is currently executing at another indicated location . Likewise graphical user interface may indicate that model version B contains no breakpoints and is currently executing. In one embodiment when graphical user interface indicates a concurrent computing unit is stopped at a breakpoint graphical user interface may display additional information such as current model parameter and variable values.

In one embodiment exemplary graphical user interface enables a user to tune parameters for the model instances being executed. For example depicts a dialog box that may be displayed in response to a user clicking on the gain block of . The dialog box allows the user to set or adjust a value for the gain block . As a result the user is able to quickly adjust the execution of the model based on the user s level of satisfaction with the displayed results.

In one embodiment a user may target commands to specific concurrent computing units. The graphical user interface allows a user to visualize the execution of the graphical model by the different instances of the concurrent computing process. By selecting via the graphical user interface model components in a graphical model being executed by a particular instance of the concurrent computing process the user may change parameters start execution stop execution conditionally stop execution via breakpoints and otherwise manage and monitor the execution of the graphical model during both regular and debug modes of execution. The graphical user interface may also include a user interface control such as a pull down menu or the like that allows a user to target one or more computational units of a concurrent computing process. Alternatively the user may select the concurrent computing units by clicking on a graphical representation of the units with a mouse. Once one or more units have been targeted any command issued will be directed to the target unit s . Additionally when any of the concurrent computing units are in debug mode the user will be able to target any single concurrent computing unit or all or a subset of units stopped at breakpoints.

In one embodiment a graphical top model may reference one or more models based on or including a UML model the usage of the term UML Model should be understood to include derived formalisms such as SysML and MARTE and other formalisms such as AADL etc. . UML is a modeling and specification language used in software engineering. UML is often used for modeling object oriented programs as it includes a standardized modeling notation that may be used to create an abstract representation UML model of a system. While UML was designed to specify visualize construct and document software intensive systems UML is not restricted to modeling software and can be used for modeling systems in general. For example UML can also be used for business process modeling engineered system modeling and modeling of organizational structure etc.

In one embodiment a UML model may be imported into a graphical model which may then be executed as described herein. Techniques for importing a UML model into a graphical model are discussed in pending U.S. application Ser. No. 11 436 475 filed on May 17 2006 entitled Action Languages for Unified Modeling Language Model the contents of which are incorporated by reference herein in their entirety. One exemplary embodiment thus allows UML models to be concurrently executed by a concurrent computing process.

In one embodiment the monitoring facility may be used to generate reports or other displays of information received from the concurrent computing units regarding the status of execution of the graphical model. The information may relate to data generated from the execution of the graphical model or may relate to information on the status of the concurrent computing units. Examples of status or activity values for concurrent computing units include idle no work to do busy performing a computation busy sending data to another processor busy receiving data from another processor and stopped at a known execution point. In one embodiment additional information not initially displayed in the graphical user interface may be accessed through a link or reference included in the graphical user interface. For example statistics related to recent activity such as the percentage of time spent waiting to receive data from another processor or the number of times data was sent to another processor may be displayed Similarly statistical plots of the additional information may be generated as a result of a user selecting a reference or link in the graphical user interface. Such information can be used for tracking the progress of a computation and for assessing the performance of the computational system and the algorithms being employed.

In a similar vein reports may also be generated relating to model data associated with the execution of the graphical model in the concurrent computing environment. For example current output signal values current accumulated values current input values etc.

The table may also be extended to include additional columns with other statistics. In some embodiments the table may serve as a gateway to more detailed information such as statistical plots e.g. profiling information . Conventional mechanisms such as double clicking or making a selection from a context menu may provide access to the detailed information. A subset of the concurrent computing units may be differenced so as to compare a subset of concurrent computing units to compare the length of time the units ran the resources used how long the units took to process certain elements of a job and other types of comparisons. Additionally the collection of data indicating active concurrent computing units may be programmatically evaluated and further processed before being presented to a user. Other implementations or configurations will be apparent to one skilled in the art given the benefit of this disclosure.

As noted above in the discussion of embodiments of the present invention may be used to display a calling hierarchy during the execution of a graphical top model. depicts exemplary processing that may be performed by an embodiment to display a calling hierarchy to a user. The processing begins with the execution or debugging of a graphical top model that references multiple instances of a graphical model step . A graphical user interface is generated which displays a model component referenced by at least two of the model instances step . The GUI may display the current calling hierarchy step and may provide a selector mechanism allowing a user to change the current calling hierarchy step . The selector mechanism may be used to change the current calling hierarchy step and the display of the graphical model component may then be updated based upon the received selection step .

As noted above in the discussion of embodiments of the present invention may be used to display information regarding the concurrent execution of a graphical top model. A monitoring facility regularly may receive information from concurrent computing units carrying out the execution of the graphical model. An exemplary process by which the monitoring facility generates a graphical user interface in order to display received information to the user is depicted in the flowchart of . The sequence begins with the execution of a graphical model in a concurrent computing environment step . A GUI may be generated that includes a view of the graphical model or model component step . For example where the graphical model is a block diagram the GUI may display a block diagram of a whole model or particular subsystem block in the graphical model. Information regarding the execution of the graphical model may then be received from the concurrent computing units regarding the execution of the graphical model step and the received information may be displayed to the user step . For example a monitoring facility may update the displayed view of the graphical model in the graphical user interface step based upon new information. Thus where the graphical user interface is already displaying a block diagram the display may be updated. For example the graphical user interface may be updated by adding or altering indicators on the model such as signal values breakpoints status information etc. Alternatively a monitoring facility may generate a report about the execution of the model based on received information. For example in one embodiment a table such as the one depicted in may be generated step .

A similar process may be used when the graphical model has incorporated a UML model. An exemplary process of generating a graphical user interface that displays information to a user about the execution of a graphical model that includes a UML model is depicted in the flowchart of . The exemplary sequence begins with the importation of a UML model into a graphical model step . The UML model may be exported into a text based format such as an XML Metadata Interface XMI format. The graphical modeling environment being used to create a graphical model may read the XMI format and publish the components of the XML model using hierarchical computational blocks. The computational blocks may be then be used in a graphical model under construction. The graphical model is then executed using a concurrent computing process step . A GUI is generated that includes a view of the graphical model or a graphical model component step . Information may then be received by a monitoring facility or other entity regarding the execution of the graphical model step and the received information may then be displayed to the user step .

Memory may comprise a computer system memory or random access memory such as MRAM DRAM SRAM EDO RAM etc. Memory may comprise other types of memory as well or combinations thereof. A user may interact with computing device through a display device such as a computer monitor which may include a graphical user interface GUI . The computing device may include other I O devices such a keyboard and a pointing device for example a mouse for receiving input from a user. Optionally keyboard and pointing device may be connected to display device . The computing device may also include other suitable I O peripherals such as multi point touch interfaces cameras and microphones and may use neural interfaces. Computing device may further include a storage device such as a hard drive solid state drive FLASH memory or CD ROM for storing an operating system and other related software and for storing a concurrent computing process such as parallel computing with MATLAB software or SIMULINK software or distributed computing with MATLAB software or SIMULINK software MATLAB software and SIMULINK software are both products of The MathWorks Inc. of Natick Mass. . Concurrent computing process can be but is not limited to an application a program a module or a script. Concurrent computing process provides a concurrent computing environment to enable concurrent computing on the computing device . Concurrent computing process can also include a communication interface such as Message Passing Interface MPI CORBA or other suitable interface for setting up a communication channel with another computing device to form a collaboration. MPI is a standard for an interface for message passing that has been used between parallel machines or workstations in concurrent computing systems. One of ordinary skill in the art will appreciate that communication interface can be adapted to be included as part of concurrent computing process or it can be a stand alone application module script or program that responds to calls from concurrent computing process such as communication interface . Additionally operating system and concurrent computing process can be run from a bootable CD such as for example KNOPPIX a bootable CD for GNU Linux.

Computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. Network interface may be a FireWire interface FlexRay interface RS 232 interface and may include a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing computing device to any type of network capable of communication and performing the operations described herein. Moreover computing device may be any computer system such as a workstation desktop computer server laptop handheld computer sensor actuator or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

Computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the UNIX and Linux operating systems any version of the MacOS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein.

Client concurrent computing unit and concurrent computing labs A N are configured to perform distributed computing or parallel computing using concurrent computing process . Concurrent computing process may be a technical computing software application that provides a technical computing and or graphical modeling environment that generates block diagram models and defines mathematical algorithms for simulating models. Concurrent computing process may include all or a portion of the functionality provided by a corresponding stand alone desktop application. Concurrent computing unit and A N may execute an instance or of the concurrent computing process . For example each concurrent computing unit A to N and the client concurrent computing unit may each be executing a different copy of a graphical modeling application. The instance of the concurrent computing process executed on client concurrent computing unit may differ from the instances of concurrent computing processes and in that it also includes a graphical user interface and is an interactive instance of the concurrent computing process. The interactive instance of the concurrent computing process is able to accept input from a user and display output to the user during the execution of the concurrent computing process. Graphical user interface may display the information collected by a monitoring facility . Graphical user interface allows a user accessing client to control and monitor all of the executing instances and of the concurrent computing process.

Concurrent computing process which is executed by client concurrent computing unit may also include monitoring facility . Alternatively monitoring facility may be part of or in communication with scheduler . Monitoring facility may be in communication with client concurrent computing unit and concurrent computing units A B . . . N and may track the current activity and status of each concurrent computing unit.

In one embodiment functions are defined by client concurrent computing unit with an application programming interface API and or programming language representing a technical computing task to be executed by either a technical computing environment local to client or remotely on workstations A N. A graphical user interface may be built on top of the API layer. Tasks can be declared on client concurrent computing unit and additionally organized into jobs. A job is a logical unit of activities or tasks that are processed and or managed collectively. A task defines a technical computing command to be executed the number of arguments and any input data to the arguments. A job is a group of one or more tasks.

In another embodiment a task can be directly distributed by client concurrent computing unit to one or more computing resources such as concurrent computing units A N. A computing resource performs technical computing on a task and may return a result to client concurrent computing unit .

In an exemplary embodiment system may include server on which scheduler runs. Scheduler can be a scheduler provided with concurrent computing process a generic scheduler or a third party scheduler that is designed and provided by a company or individual that does not provide concurrent computing process . Server communicates over network to concurrent computing units A N and client concurrent computing unit . One of ordinary skill in the art will appreciate that any of concurrent computing units A N may include more than one technical computing lab. Additionally client concurrent computing unit and server may also include one or more concurrent computing labs.

Scheduler may include one or more application software components to provide for the automatic distribution of tasks from client concurrent computing unit to one or more of concurrent computing units A N. Scheduler allows client concurrent computing unit to delegate the management of task distribution to scheduler . Scheduler may also set up for client concurrent computing unit concurrent computing units A N by using the information received from client concurrent computing unit regarding the number of concurrent computing labs needed and other configuration information. Hence client concurrent computing unit does not need to know the specifics of concurrent computing units A N. Client concurrent computing unit can define a function to submit the task to scheduler and get a result of the task from scheduler . As such scheduler provides a level of indirection between client concurrent computing unit and concurrent computing units A N.

The use of a scheduler eases the distributed programming and integration burden on client concurrent computing unit . Client concurrent computing unit does not need to have prior knowledge of the availability of concurrent computing units A N. For multiple task submissions from client concurrent computing unit scheduler can manage and handle the delegations of the tasks to concurrent computing units A N. Scheduler can also hold the results of the tasks on behalf of client concurrent computing unit for retrieval after the completion of technical computing of all the tasks distributed by client concurrent computing unit . In an alternative implementation concurrent computing units A N may provide to client concurrent computing unit directly the results of the tasks assigned to concurrent computing labs A N by scheduler . Scheduler may further include an object oriented interface to provide control of delegating tasks and obtaining results in system . Scheduler may also provide an interface for managing a group of tasks collectively as a single unit called a job. Additionally scheduler may on behalf of client concurrent computing unit submit those tasks making up the job and obtain the results of each of the tasks until the job is completed. The functions and operations of scheduler may be separated into various software components applications and interfaces. Additionally the functions and operations of scheduler may reside on either client concurrent computing unit or one of concurrent computing units A N instead of server .

Client concurrent computing unit the server and the concurrent computing units A N may run the same or different operating systems with the same or different processors. For example client concurrent computing unit can be running Microsoft Windows server can be running a version of UNIX and concurrent computing units A N can be running a version of Linux. Alternatively Client concurrent computing unit server and concurrent computing units A N can be running Microsoft Windows . Various combinations of operating systems and processors that can be running on any of the computing devices client server concurrent computing units A N etc .

In one embodiment graphical user interface is provided for monitoring the status of model instances and components being executed by concurrent computing process and . Monitoring facility may be in communication with concurrent computing units A N and may be kept apprised of the status of the concurrent computing units and A N. In one implementation monitoring facility may first register with each of concurrent computing units A N prior to receiving any information. As noted previously monitoring facility may also be part of or in communication with scheduler . Monitoring facility may store the information in a global list or other type of data structure. Using the status information graphical user interface may be generated to provide a visual indication of the status of the execution of the graphical model in the concurrent computing environment.

In an exemplary embodiment graphical user interface may display a view of a graphical model being executed by the concurrent computing process. Graphical user interface may display the status of the sequential execution of the graphical model by a concurrent computing process. Graphical user interface may also display the status of the concurrent execution of the graphical model by multiple or all instances of the concurrent computing process as a composite view or multiple views. Graphical user interface may also display the status of the execution of the graphical model in a debugging mode. As noted above the graphical user interface may also be utilized to monitor the execution of a UML model included in a graphical model and may be used to target commands to the concurrent computing units to affect the execution of a stopped or executing graphical model.

Concurrent computing units A B and C may be arranged in an exemplary collaboration such as is shown in . Here concurrent computing units A B and C establish communication channel and form collaboration . Concurrent computing labs A B and C may communicate via an MPI communication channel . In other embodiments concurrent computing units A B and C can interface via socket based communications over TCP IP implementing a custom message specification. In further embodiments concurrent computing units A B and C may communicate using any available messaging communications products and or custom solutions that allow the sending and receiving of messages among concurrent computing units A B and C. Various types of interfaces may be used with concurrent computing labs A B and C.

In one embodiment collaboration is dynamic. In other words a user can modify or change the size of the collaboration by adding another computing resource. On client concurrent computing unit the user may be provided with a graphical user interface to modify or change the size of the collaboration or designate a specific resource to add or remove from the collaboration. In another embodiment client concurrent computing unit can forward the collaboration information to scheduler which will determine a concurrent computing lab to be added or removed from the collaboration.

Alternatively the concurrent computing units may be arranged in a tightly coupled environment such as is shown in . Computing device includes a first concurrent computing unit A and a second concurrent computing unit B. In this embodiment a concurrent computing unit may be a processor a multiple core processor multiple processors or other hardware or software components with computational capability such as a microcontroller virtual machine application specific integrated circuit analog hardware or field programmable gate arrays.

Although many embodiment discussed herein have been illustrated with reference to a distributed network it should be appreciated that the examples discussed herein may also be practiced in a tightly coupled environment. It should further be appreciated that many of the visualization techniques and command targeting techniques discussed in the distributed computing embodiments section may also be practiced with model reference embodiments. It should also be noted that although reference has been made herein to the practice of illustrative embodiments with a graphical user interface other interface modalities may also utilized.

The embodiments of the present invention may be provided as one or more computer readable programs embodied on or in one or more computer readable mediums. The mediums may be a floppy disk a hard disk a compact disc a digital versatile disc a flash memory card a PROM an MRAM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language. Some examples of languages that can be used include MATLAB FORTRAN C C C Python or Java. The software programs may be stored on or in one or more mediums as object code. Hardware acceleration may be used and all or a portion of the code may run on a FPGA an ASIP or an ASIC. The code may run in a virtualized environment such as in a virtual machine. Multiple virtual machines running the code may be resident on a single processor.

Since certain changes may be made without departing from the scope of the present invention it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a literal sense. Practitioners of the art will realize that the sequence of steps and architectures depicted in the figures may be altered without departing from the scope of the present invention and that the illustrations contained herein are singular examples of a multitude of possible depictions of the present invention.

The foregoing description of example embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example while a series of acts has been described with regard to the order of the acts may be modified in other implementations consistent with the principles of the invention. Further non dependent acts may be performed in parallel.

In addition implementations consistent with principles of the invention can be implemented using devices and configurations other than those illustrated in the figures and described in the specification without departing from the spirit of the invention. Devices and or components may be added and or removed from the implementations depicted in and depending on specific deployments and or applications. Further disclosed implementations may not be limited to any specific combination of hardware.

Further certain portions of the invention may be implemented as logic that performs one or more functions. This logic may include hardware such as hardwired logic an application specific integrated circuit a field programmable gate array a microprocessor software wetware or a combination of hardware and software.

No element act or instruction used in the description of the invention should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on as used herein is intended to mean based at least in part on unless explicitly stated otherwise.

