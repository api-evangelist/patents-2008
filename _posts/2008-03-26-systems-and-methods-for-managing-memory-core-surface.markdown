---

title: Systems and methods for managing memory core surface
abstract: Accessing a shared buffer can include receiving an identifier associated with a buffer from a sending process, requesting one or more attributes corresponding to the buffer based on the received identifier, mapping at least a first page of the buffer in accordance with the one or more requested attributes, and accessing an item of data stored in the buffer by the sending process. The identifier also can comprise a unique identifier. Further, the identifier can be passed to one or more other processes. Additionally, the one or more requested attributes can include at least one of a pointer to a memory location and a property describing the buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08886891&OS=08886891&RS=08886891
owner: Apple Inc.
number: 08886891
owner_city: Cupertino
owner_country: US
publication_date: 20080326
---
This application claims priority to U.S. Provisional Application Ser. No. 60 979 027 filed Oct. 10 2007 entitled Systems and Methods for Managing Memory Core Surface . The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.

As computing devices have evolved to host greater numbers of concurrent processes or applications the need to efficiently manage system resources has increased. Volatile memory such as Random Access Memory RAM is commonly used to store data associated with processes executing on a computing device. For example volatile memory can be utilized to store data that is to be referenced by an executing process such as data read from a storage medium with lower access speeds. Volatile memory also can be used to store the results generated by an executing process such as data that is to be output to a presentation device or a persistent storage device. Memory controllers continually refresh the volatile memory to ensure that stored data is not lost. Further memory controllers can be used to read information from and write information to the volatile memory.

The processes executing in a computing device are required to share the finite physical memory including the volatile memory that is available. Further although a process can request and reserve a portion of the physical memory the process must know how to address the memory it can use. In order to avoid conflicts virtual memory has been implemented to permit executing processes to address virtual memory addresses without regard to physical memory addresses. An operating system kernel can be used to manage access to the physical memory by translating virtual memory addresses into physical memory addresses. For example a page table for each process can be maintained by the kernel and used to translate virtual memory addresses into physical memory addresses.

Further data stored in the physical memory can be transferred between processes. Because the application programming interface API and buffering scheme of a first process may be incompatible with the API and or buffering scheme of a second process the data can be reproduced in the receiving location. For example data associated with the first process can be made available to the second process which is executing within the same computing device by copying the data from a physical memory address associated with the first process to a physical memory address associated with the second process. In this manner data generated by one process such as a result can be provided as input to another process that is executing on the same computing device.

A kernel operating in a computing system can be configured to manage the creation of one or more buffers in a memory device. The kernel further can be configured to control access to the one or more buffers by processes executing in the computing system. In order to share one or more buffers associated with a memory device the present inventors recognized the need to identify each buffer by a system wide global unique identifier. Further the present inventors recognized the need to also permit a process that has access to a buffer to share that buffer with one or more additional processes by passing the global unique identifier.

The present inventors also recognized the need to permit a process to request the creation of a buffer that can be shared with one or more additional processes. Further the need to generate a shared buffer in accordance with one or more specified requirements also was recognized. Additionally the present inventors also recognized the need to permit a receiving process to determine one or more attributes describing a shared buffer from the kernel based on the global unique identifier. Accordingly the techniques and apparatus described here implement algorithms for managing the creation of and access to one or more shared buffers implemented in a memory device.

In general in one aspect the subject matter can be implemented to include receiving an identifier associated with a buffer from a sending process requesting one or more attributes corresponding to the buffer based on the received identifier mapping at least a first page of the buffer in accordance with the one or more requested attributes and accessing an item of data stored in the buffer by the sending process.

The subject matter also can be implemented such that the one or more attributes include at least one of a pointer to a memory location and a property describing the buffer. Further the subject matter can be implemented such that accessing an item of data further comprises performing an operation utilizing the item of data stored in the buffer. Additionally the subject matter can be implemented such that one or more buffer properties are defined such that the buffer is interoperable with a plurality of applications.

The subject matter also can be implemented such that the identifier comprises a unique identifier. Further the subject matter can be implemented to include passing the identifier to one or more other processes. Additionally the subject matter can be implemented to include generating a user client to track the buffer.

In general in another aspect the subject matter can be implemented as a system comprising a memory managed by a kernel driver and processor electronics for executing a receiving process the processor electronics configured to perform operations comprising receiving an identifier associated with a buffer from a sending process wherein the buffer corresponds to at least a portion of the memory requesting one or more attributes corresponding to the buffer from the kernel driver based on the received identifier mapping at least a first page of the buffer in accordance with the one or more requested attributes and accessing an item of data stored in the buffer by the sending process.

The subject matter also can be implemented such that the one or more attributes include at least one of a pointer to a memory location and a property describing the buffer. Further the subject matter can be implemented such that the processor electronics configured to perform operations comprising accessing an item of data are further configured to perform an operation utilizing the item of data stored in the buffer. Additionally the subject matter can be implemented such that one or more buffer properties are defined such that the buffer is interoperable with a plurality of applications.

The subject matter also can be implemented such that the identifier comprises a unique identifier. Further the subject matter can be implemented such that the processor electronics are further configured to perform operations comprising passing the identifier to one or more other processes. Additionally the subject matter can be implemented such that the processor electronics are further configured to perform operations comprising generating a user client to track the buffer.

In general in another aspect the subject matter can be implemented as a computer program product encoded on a computer readable medium operable to cause data processing apparatus to perform operations comprising receiving an identifier associated with a buffer from a sending process requesting one or more attributes corresponding to the buffer based on the received identifier mapping at least a first page of the buffer in accordance with the one or more requested attributes and accessing an item of data stored in the buffer by the sending process.

The subject matter also can be implemented to be further operable to cause data processing apparatus to perform operations comprising performing an operation utilizing the item of data stored in the buffer. Further the subject matter can be implemented such that the one or more attributes include at least one of a pointer to a memory location and a property describing the buffer. Additionally the subject matter can be implemented such that one or more buffer properties are defined such that the buffer is interoperable with a plurality of applications.

The subject matter also can be implemented to be further operable to cause data processing apparatus to perform operations comprising passing the identifier to one or more other processes. Further the subject matter can be implemented such that the identifier comprises a unique identifier. Additionally the subject matter can be implemented to be further operable to cause data processing apparatus to perform operations comprising generating a user client to track the buffer.

In general in one aspect the subject matter can be implemented to include obtaining by a receiving process an identifier associated with a buffer from a sending process requesting one or more attributes corresponding to the buffer based on the received identifier mapping at least a first page of the buffer in accordance with the one or more requested attributes and performing an operation based on an item of data stored in the buffer by the sending process.

The techniques described in this specification can be implemented to realize none one or more of the following advantages. For example the techniques can be implemented such that a buffer implemented in a memory device can be shared by two or more processes. The techniques also can be implemented such that a sending process can identify a buffer to a receiving process by passing a global unique identifier associated with the buffer. The techniques further can be implemented to include looking up one or more attributes corresponding to a buffer by calling a procedure referencing the global unique identifier associated with the buffer. Additionally the techniques can be implemented to permit a process to identify a previously allocated buffer to a memory management kernel and to receive a global unique identifier that can be used to share the previously allocated buffer with one or more additional processes.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

The kernel uses a standard buffer API to manage all input to and output from the physical memory or core surface that occurs within the computing system . Thus a plurality of applications and hardware devices objects operating within the computing system can share one or more buffers defined with respect to the physical memory . For example a plurality of hardware components included in the computing system can be configured to use a core surface compatible API thus permitting the plurality of hardware components to access a common buffer associated with the physical memory .

The IOCoreSurfaceRoot of the kernel can be configured to manage one or more memory devices included in the computing system . Further the IOCoreSurfaceRoot can be configured to define and maintain one or more IOCoreSurfaceMemoryRegions corresponding to a memory device such as the physical memory . Each IOCoreSurfaceMemoryRegion can be assigned a unique descriptor. For example the IOCoreSurfaceRoot can define and maintain the IOCoreSurfaceMemoryRegions and which are defined with respect to the physical memory . Additionally an IOCoreSurfaceBuffer can be created that corresponds to a particular IOCoreSurfaceMemoryRegion. For example an IOCoreSurfaceBuffer can be created that corresponds to the IOCoreSurfaceMemoryRegion . In an implementation more that one IOCoreSurfaceBuffer can be associated with an IOCoreSurfaceMemoryRegion. An IOCoreSurfaceBuffer can be used to store one or more data items associated with a process. Further an IOCoreSurfaceBuffer can be configured to store one or more items of data describing itself including a buffer format a buffer width a buffer height and an initial offset.

The IOCoreSurfaceRoot also can be configured to interact with an IOCoreSurfaceUserClient which is associated with a single process executing in the computing system . An IOCoreSurfaceUserClient can be created in the kernel for each process executing in the computing system . Alternatively an IOCoreSurfaceUserClient can be created only for processes configured to interact with the core surface such as a process that requests or accesses an IOCoreSurfaceBuffer.

Further the IOCoreSurfaceUserClient can be configured to track one or more IOCoreSurfaceClientBuffers that correspond to the process with which the IOCoreSurfaceUserClient is associated. For example the IOCoreSurfaceUserClient can be configured to track the IOCoreSurfaceClientBuffer and the IOCoreSurfaceClientBuffer . An IOCoreSurfaceClientBuffer also wraps an IOCoreSurfaceBuffer to provide buffer access to the associated application. For example the IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion is wrapped by the IOCoreSurfaceClientBuffer .

As described above the computing system also can include one or more executing processes such as the process . Further the process can include one or more CoreSurfaceClientBuffers such as the CoreSurfaceClientBuffers and . A CoreSurfaceClientBuffer associated with a process corresponds to an IOCoreSurfaceClientBuffer associated with the kernel. Together the CoreSurfaceClientBuffer and the IOCoreSurfaceClientBuffer form a bridge between an executing process and the kernel.

The CoreSurfaceClientBuffer also can be associated with a corresponding CoreSurfaceBuffer that exists within the process . For example the CoreSurfaceClientBuffers and are wrapped by the CoreSurfaceBuffers and respectively. A CoreSurfaceBuffer represents the highest level buffer implementation based on the physical memory and exposes buffer functionality to the associated process. For example a CoreSurfaceBuffer provides a process with the ability to access and manipulate data stored in the physical memory . Further a CoreSurfaceBuffer such as the CoreSurfaceBuffer is associated with an IOCoreSurfaceBuffer such as the IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion .

An IOCoreSurfaceUserClient associated with the process also can be created in the kernel . The IOCoreSurfaceUserClient can be configured to track the IOCoreSurfaceClientBuffer which is associated with an IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion . Thus a first process and a second process executing in the computing system can share the physical memory with each process having access to one or more buffers implemented in the physical memory . Further the kernel can manage access to the buffers by the first process and a second process .

For example the process includes the CoreSurfaceBuffer which wraps the CoreSurfaceClientBuffer . Further the kernel includes the IOCoreSurfaceClientBuffer which is associated with the CoreSurfaceClientBuffer of the process . Additionally the IOCoreSurfaceClientBuffer is associated with the IOCoreSurfaceBuffer that corresponds to the IOCoreSurfaceMemoryRegion . Thus the single IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion is associated with both the IOCoreSurfaceClientBuffer corresponding to the process and the IOCoreSurfaceClientBuffer corresponding to the process . As a result each of the processes and can access the IOCoreSurfaceBuffer.

Further a sending process such as the process can identify to a receiving process such as the process an IOCoreSurfaceBuffer that is to be shared. For example the kernel can generate a system wide global unique identifier that is associated with an IOCoreSurfaceBuffer. The global unique identifier can be passed from the kernel to the process that requested creation of the buffer such as the sending process. Further the sending process can pass the global unique identifier to one or more receiving processes.

A receiving process can use the global unique identifier to gain access to the shared IOCoreSurfaceBuffer. For example the receiving process can pass the global unique identifier to the kernel such as through a look up procedure. In response the kernel can provide one or more items of information required to access the shared IOCoreSurfaceBuffer such as a pointer to the receiving process. The receiving process can then map the shared IOCoreSurfaceBuffer and perform one or more operations using the data stored in the shared IOCoreSurfaceBuffer. Thus a process can perform one or more operations with respect to data stored in an IOCoreSurfaceBuffer and then share the IOCoreSurfaceBuffer with one or more additional processes which also can utilize the data stored in the IOCoreSurfaceBuffer. Further the receiving process also can become a sending process by passing the global unique identifier to one or more processes. Additionally the mapped shared IOCoreSurfaceBuffer also can be unmapped.

In an exemplary implementation an IOCoreSurfaceBuffer can be used for video decoding. For example the kernel can allocate the IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion to the process . The process can decode a frame of video data into the IOCoreSurfaceBuffer such as by decompressing stored video data. Further the process can provide the IOCoreSurfaceBuffer corresponding to the IOCoreSurfaceMemoryRegion to the receiving process by passing the global unique identifier that is associated with the IOCoreSurfaceBuffer. The process also can perform one or more operations utilizing the decoded video data such as formatting the decoded video data for presentation on a display device. Thus an IOCoreSurfaceBuffer can be shared by a plurality of processes operating in a computing system by passing a global unique identifier associated with the IOCoreSurfaceBuffer.

The request to create the core surface buffer is received in the kernel . For example the request can be received by a user client in the kernel such as the IOCoreSurfaceUserClient that is associated with the process that initially generated the buffer request. Further the associated user client can forward the request to the IOCoreSurfaceRoot of the kernel which can generate the requested core surface buffer. The IOCoreSurfaceRoot can determine whether memory corresponding to the core surface buffer request has been allocated . For example an existing portion of memory previously allocated to the requesting process can be converted into a core surface buffer. By wrapping the existing memory in a global unique identifier the memory can be passed to other processes that also are executing in the computing system.

If memory has not already been allocated for the requested core surface buffer the IOCoreSurfaceRoot can determine whether the memory is required to be contiguous . In virtual memory the address space associated with a buffer may be contiguous although the corresponding physical memory space is not. Thus a particular buffer can be incompatible with one or more process types. Therefore a process can be configured to request contiguous memory if it is required for a particular application. For example if a process is requesting creation of a core surface buffer for use in video decoding the process can request a contiguous memory region of the core surface.

Further the memory region can be specified such that it includes all of the properties necessary to be interoperable with all of the devices and applications that will interact with the corresponding core surface buffer. Therefore a process can specify a named memory region such as graphics memory from which the core surface buffer is to be allocated. The named memory region can be managed such that all allocations from that memory region are guaranteed to be physically contiguous. If the memory associated with the requested core surface buffer is required to be contiguous memory can be allocated from a named memory region . Otherwise the memory associated with the requested core surface buffer can be allocated from any available memory region .

The allocated memory region is used to generate the requested core surface buffer which can be identified and referenced by an assigned system wide global unique identifier . Similarly if the memory for the core surface buffer had previously been allocated the previously allocated memory is assigned a system wide global unique identifier . The global unique identifier can be any reference that is unique within the computing system. For example any unique number can be assigned to identify the core surface buffer. In an implementation the global unique identifier can be generated based on a kernel pointer.

Further the kernel can pass information permitting the process to access the generated core surface buffer back to the requesting process . For example the IOCoreSurfaceRoot of the kernel can pass the core surface buffer to the IOCoreSurfaceUserClient in the kernel which can wrap the core surface buffer as an IOCoreSurfaceClientBuffer. The IOCoreSurfaceUserCient can then track the IOCoreSurfaceClientBuffer and pass a reference to the requesting process such as the global unique identifier.

A process receiving a global unique identifier can call a look up procedure that references the global unique identifier . For example a buffer look up procedure can be called that passes the global unique identifier to a user client in the kernel such as the IOCoreSurfaceUserClient. In response to the look up a core surface buffer pointer is received from the kernel . It also can be determined whether a memory management unit is associated with the receiving process . If a memory management unit is associated with the receiving process the core surface buffer pages can be mapped in the memory management unit . Otherwise the receiving process can identify the first physical address of the core surface buffer and one or more buffer attributes . For example the process can assume that all of the addresses in the memory region are contiguous.

Once the receiving process can access the core surface buffer the receiving process can use the buffer for any purpose. For example the receiving process can read data from and or write data to the core surface buffer. The receiving process also can pass the global unique identifier corresponding to the core surface buffer to one or more other processes including the process from which the global unique identifier was received.

In an implementation the receiving process also can invoke one or more procedures to determine information about the core surface buffer. The procedures can reference the core surface buffer by the global unique identifier. For example in the case of a core surface buffer used for video decoding the receiving process can determine one or more of the pixel format type of the buffer the buffer width the buffer height the bytes per row of the buffer the base address of the buffer the plane count the plane width the plane height the base address of the plane and the bytes per row of the plane. Other types of information can be obtained for other buffer types.

The processes described herein are not limited to use with any particular hardware software or programming language they may find applicability in any computing or processing environment and with any type of machine that is capable of managing memory in one or more of the disclosed implementations. Actions associated with the processes can be performed by one or more programmable processors executing one or more computer programs to perform the functions of the processes.

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only storage area or a random access storage area or both. Elements of a computer include a processor for executing instructions and one or more storage area devices for storing instructions and data.

Actions associated with the processes can be rearranged and or one or more such actions can be omitted to achieve the same or similar results to those described herein. Elements of different implementations described herein may be combined to form other implementations not specifically set forth above. A number of implementations have been disclosed herein. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the claims. Accordingly other implementations are within the scope of the following claims.

