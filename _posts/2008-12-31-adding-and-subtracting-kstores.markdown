---

title: Adding and subtracting KStores
abstract: The KStore is a datastore made up of a forest of interconnected, highly unconventional trees of one or more levels. One KStore can be added to an existing KStore to create an updated KStore by traversing the trees of the KStores and incrementing the count fields to reflect the added counts of analogous nodes. New KStore structure is added as needed. A KStore can be subtracted from an existing KStore to create an updated KStore by traversing trees KStores and decrementing the count fields in the updated KStore to reflect the subtracted counts of analogous nodes. KStore structure is removed as needed. Portions of a KStore can be added or subtracted from another KStore by isolating the paths to be used for updating. Instead of incrementing or decrementing counts, a dataset of individual records can be recreated from the KStore.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010569&OS=08010569&RS=08010569
owner: Unisys Corporation
number: 08010569
owner_city: Blue Bell
owner_country: US
publication_date: 20081231
---
This application claims the benefit of U.S. patent application Ser. No. 11 084 996 filed Mar. 18 2005 entitled SYSTEM AND METHOD FOR STORING AND ACCESSING DATA IN AN INTERLOCKING TREES DATASTORE by MAZZAGATTI et al. which application is a Continuation of U.S. patent application Ser. No. 10 385 421 filed Mar. 10 2003 and U.S. patent application Ser. No. 11 185 620 filed Jul. 20 2005 entitled METHOD FOR PROCESSING NEW SEQUENCES BEING RECORDED INTO AN INTERLOCKING TREES DATASTORE by MAZZAGATTI. These applications are incorporated in their entirety herein.

The present disclosure relates to data processing systems and datastores to such systems. In particular the present disclosure relates to data node types related to an interlocking trees datastore.

Data structures facilitate the organization and referencing of data. Many different types of data structures are known in the art including linked lists stacks trees arrays and others. The tree is a widely used hierarchical data structure of linked nodes. The conventional tree is an acyclic connected graph where each node has a set of zero or more child nodes and at most one parent node. A tree data structure unlike its natural namesake grows down instead of up so that by convention a child node is typically referred to as existing below its parent. A node that has a child is called the child s parent node or ancestor node or superior node . In a conventional tree a node has at most one parent. The topmost node in a tree is called the root node. A conventional tree has at most one topmost root node. Being the topmost node the root node does not have a parent. Operations performed on the tree commonly begin at the root node. All other nodes in the tree can be reached from the root node by following links between the nodes. Nodes at the bottommost level of the tree are called leaf nodes or terminal nodes. As a leaf node is at the bottommost level a leaf node does not have any children.

The KStore or K is a datastore made up of a forest of interconnected highly unconventional trees of one or more levels. Each node in the KStore can have many parent nodes. The KStore is capable of handling very large amounts of highly accessible data without indexing or creation of tables. Aspects of KStore are the subject of a number of patents including U.S. Pat. Nos. 6 961 733 7 158 975 7 213 041 7 340 471 7 348 980 7 389 301 7 409 389 7 418 455 and 7 424 480 which are hereby incorporated by reference in their entirety.

A KStore can be added to an existing KStore to create an updated KStore by traversing the asCase trees of the existing KStore and the KStore to be added and incrementing the count fields in the updated KStore to reflect the added counts of analogous nodes in the existing KStore and the KStore to be added. New KStore structure is added i.e. nodes in a path are added as needed to the updated KStore to add those portions of the KStore to be added that do not already exist in the existing KStore. A KStore can be subtracted from an existing KStore to create an updated KStore by traversing the asCase trees of the existing KStore and the KStore to be subtracted and decrementing the count fields in the updated KStore to reflect the subtracted counts of analogous nodes in the existing KStore and the KStore to be subtracted. KStore structure may be removed i.e. nodes in a path may be removed as needed from the updated KStore if as a result of count subtraction counts become zero or less than zero. Alternatively the structure may be retained to provide historical information.

A portion of a first KStore can be added to a second KStore to create a third KStore by isolating one or more paths or portions of paths by traversing the path to its end point saving the count traversing the path back to the primary root node and adding counts of analogous nodes in the KStores. A portion of a first KStore can be subtracted from a second KStore to create a third KStore by isolating one or more paths or portions of paths by traversing the path to its end point saving the count traversing the path back to the primary root node and subtracting counts of analogous nodes in the KStores. A dataset can be recreated record by record and sent to the KStore to be updated one by one.

A KStore or K is a datastore made up of a forest of interconnected trees. illustrates a multi level KStore structure created from the data in Dataset of . The highest level level 3 of the KStore represents the KStore illustrated in and represents records e.g. Tom Monday 103 trial NJ . The middle level level 2 represents the field content or variables the root nodes of KStore which make up the records of level 3 e.g. the variable Tom the variable Tuesday etc. and the lowest level level 1 represents the universe of dataset elements that are combined to make up the variables e.g. the letter T the letter o the number 1 the number 0 and so on . It will be appreciated that multi level KStores of any number of levels can exist. Additional levels can be added or removed at any time and existing levels can be updated at any time. For example an additional level level 4 not shown representing datasets of which Dataset of is one dataset can be added above level 3 . Additional records can be added to level 3 . Additional variables can be added to level 2 . Additional dataset elements e.g. the letter v can be added to level 1 . Moreover updates to one level of the KStore are propagated to other levels as required. For example the addition of a record for Violet Tuesday 100 sold NY would be reflected in all the levels of the KStore. The record would be added to level 3 the variables of level 2 would be updated to include the new variables Violet and NY and the list of elemental root nodes of the lowest level level of would be updated to include elemental root nodes for V and Y.

The interlocking trees datastore comprises a first tree that depends from a first root node a primary root node and may include a plurality of branches. Each of the branches of the first tree ends in a leaf node called an end product node. The first root node may represent a concept such as but not limited to a level begin indicator e.g. BOT or Beginning of Thought . For example referring to KStore includes a first tree depending from a first root node and including 5 branches e.g. the topmost branch is comprised of nodes ending with the leaf node .

A second root e.g. root node of the same level of the same trees based datastore is linked to each leaf node of the first tree e.g. to nodes and and is called an EOT End Of Thought node. Leaf nodes of a KStore are also called end product nodes. End product nodes include a count that reflects the number of times the sequence of nodes from BOT to EOT has occurred for the unique sequence of nodes that end with that particular end product node. For example node with a count of 1 reflects the counts associated with the path connecting nodes and . The second root e.g. root node is a root to an inverted order of the first tree or to an inverted order of some subset of the first tree but does not duplicate the first tree. Node is a node that is shared by the KStore path that ends with end product node and by the KStore path that ends with end product node . Thus the count of node is the combination of the count of node and the count of node .

Finally the trees based datastore comprises a plurality of trees of a third type in which the root node of each of these trees can be described as an end product node of an immediately adjacent lower level or as an elemental root node and may include or point to data such as a dataset element or a representation of a dataset element. The root nodes and are end product nodes of the immediately adjacent lower level of the KStore. It will be appreciated that not all of the root nodes of KStore are illustrated in to avoid unduly cluttering the Figure. The root node of each of these trees may be linked to one or more nodes in one or more branches of the unduplicated first tree. The nodes of the trees based datastore may contain pointers to other nodes in the trees based datastore instead of data per se and may also contain additional fields. One such additional field may be a count field e.g. the count field of node is 6 and the count field of node is 3 . Multiple levels of the above described tree based datastore may be generated and accessed the end products of the lower level becoming the root nodes of the next level.

Branches of the first tree are called asCase branches or asCase paths. AsCase paths are linked via asCase links denoted by solid lines in the Figures. Together all the asCase paths of a KStore form the asCase tree of that level. The asCase tree depends from a first root the primary root e.g. node in . Multiple asResult branches or asResult paths form multiple asResult trees that depend from respective multiple roots. AsResult paths are linked via asResult links denoted by hashed lines . . or in the Figures. For example in a number of asResult trees are illustrated including the asResult tree comprised of root node representing the dataset element Bill and internal node having a count field of 10 ten representing that 10 records of the dataset that resulted in the creation of the KStore of had a value of Bill in a particular field. Another asResult tree illustrated in is the asResult tree comprised of the following nodes root node representing the dataset element Monday which is linked by asResult links to node and to node . The count of root node is 9 the sum of the counts of node and node . The count indicates that 9 records of the dataset that resulted in the creation of the KStore of had a value of Monday in a particular field. One instance of an asResult tree comprises the asResult tree whose root node is node . This root node node in is linked to each end product node e.g. nodes and . This asResult tree can access the branches of the asCase tree terminating in end products in inverted order. This asResult tree can also be used to define root nodes for the next level. These root nodes may represent dataset elements for the next adjacent level composed of the set of end products of the lower adjacent level.

The interlocking trees datastore may capture information about relationships between dataset elements encountered in an input file by combining a node that represents a level begin indicator e.g. BOT with a node that represents a dataset element to form a node representing a subcomponent. A subcomponent node may be combined with a node representing a dataset element to generate another subcomponent node in an iterative sub process. Combining a subcomponent node with a node representing a level end indicator may create a level end product node. The process of combining a level begin node with a dataset element node to create a subcomponent and combining a subcomponent with a dataset element node and so on may itself be iterated to generate multiple asCase branches in a level. AsResult trees may also be linked or connected to nodes in the asCase tree such as for example by a root node of an asResult tree pointing to one or more nodes in the asCase tree.

As nodes are created asCase and asResult links may be simultaneously generated at each level and asCaseLists and asResultLists may be generated and updated. As described above an asCase link represents a link to the first of the two nodes from which a node is created. For example referring to the asCase link of node points to node BOT . It will be appreciated that asCase branches of the asCase trees may be created by generation of the asCase links as the input is processed. The asCase branches of each level thus provide a direct record of how each subcomponent and end product of the level was created. Hence the asCase branches can be used to represent one possible hierarchical relationship of nodes in the asCase tree. For example if the data received by an interlocking trees generator is data concerning salesmen who sell products identified by product numbers in states of the United States a particular input dataset may include the two records 

An asResult link represents a link to the second of the two nodes from which a node is created. For example the asResult link of node points to node Bill . The generation of the asResult links creates a series of interlocking trees where each of the asResult trees depends from a root comprising a dataset element. This has the result of recording all encountered relationships between the root nodes and the nodes of the asCase trees in the KStore. That is the asResult trees capture all the possible contexts of the nodes of the interlocking trees. If for example the input to the interlocking trees datastore generator comprises a universe of sales data including salesman name day of the week product number and state the resulting asResult links of the generated interlocking trees datastore could be used to extract information such as What salesmen sell in state X How many items were sold on Monday How many items did Salesman Bill sell on Monday and Tuesday and the like all from the same interlocking trees datastore without creating multiple copies of the datastore and without creating indexes or tables.

It will be appreciated that this information is determinable from the structure of the interlocking trees datastore itself rather than from information explicitly stored in the nodes of the structure. Paths can be traversed backwards towards the root node to determine if the subcomponent or end product belongs to a particular category or class of data. Links between nodes may be bi directional. For example a root node for the dataset element Monday e.g. root node may include a pointer to a subcomponent BOT Bill Monday e.g. node in node s asResultList while the node BOT Bill Monday node may include a pointer to the node Monday node as its asResult pointer and so on. Furthermore by following asCase links of the nodes containing a desired dataset element other subcomponents and end products containing the desired dataset element can be found along the branch of the asCase tree. It will be appreciated that the described features cause the datastore to be self organizing.

The Learn Engine may receive data from many types of input data sources and may transform the received data to particles suitable to the task to which the KStore being built will perform. For example if the data being sent to the KStore is information from a field record type database particular field names may be kept changed or discarded depending on the overall design of the KStore the user is creating. After breaking down the input into appropriate particles the Learn Engine may make appropriate calls to the K Engine and pass the data in particle form in a way that enables the K Engine to put it into the KStore structure.

API utilities such as API utility receive inquiries and transform the received inquiries into calls to the K Engine to access the KStore directly or to update associated memory. In the event that a query is not to be recorded in the structure of a KStore a LEARN SWITCH may be turned off. In the event that a query is to be recorded in the structure of the KStore as in Artificial Intelligence applications for example the LEARN SWITCH may be turned on. API utilities may get information from the KStore using predefined pointers that are set up when the KStore is built rather than by transforming the input into particles and sending the particles to the K Engine . For instance a field may point to the Record End of Thought EOT node the Field EOT node the Column EOT node and the Beginning Of Thought BOT node. This field may be associated with the K Engine and may allow the K Engine to traverse the KStore using the pointers in the field without requiring the API Utility to track this pointer information.

Within the KStore computing environment information may flow bi directionally between the KStore or KStores a data source and an application by way of a K Engine . The transmission of information between the data source and the K Engine may be by way of a learn engine and the transmission of information between the application and the K Engine may be by way of an API or API utility engine . A call including directives concerning addition or subtraction of KStores or partial KStores may be made to API utility . Data source and application may be provided with graphical user interfaces to permit a user to communicate with the system.

Objects or other types of system components such as learn engine and the API utility engine may be provided to service learn and query threads so that applications and interfaces of any kind can address build and use the KStore s . Learn engine may provide an ability to receive or get data in various forms from various sources on the same computer or on different computers connected via a network and to turn it into input particles that the K Engine can use. The API Utility engine may provide for appropriate processing of inquiries received by application software of any kind. The API utility engine and the learn engine get information from and or put information into a KStore. It will be understood by those of skill in the computer arts that software objects can be constructed that will configure the computer system to run in a manner so as to implement the attributes of the objects. It is also understood that the components described above may be created in hardware as well as software.

As described above represents the top level of a KStore generated from Dataset illustrated in . For example Dataset includes a set of six instances of the record Bill Tuesday sold PA. Hence the count for the nodes Tuesday sold PA and node a count of the number of the Bill Tuesday sold PA records are all 6. Similarly there is only one record for Bill Monday sold PA thus the counts for nodes sold NJ and are all 1. The count for node Bill is 10 because there are 10 records in Dataset that have Bill in the first field of the record. Similarly the count of node Tom is 5 because there are 5 records in Dataset that have Tom in the first field of the record.

Similarly illustrates the top level of a KStore generated from Dataset illustrated in . To add KStore to KStore KStore is traversed starting at node BOT by following the asCaseList pointers of node . The first pointer in node s asCaseList points to node Tom . The count for node is thus added to the count for the analogous node in KStore node Tom yielding the count of 6 in node Tom in KStore of . The asCaseList pointer for node points to the next node along the asCase path node Wednesday . Because there is no existing Wednesday node for Tom in KStore a new node is generated in KStore node . The rest of the path Tom Wednesday 103 sold NJ node is traversed using asCaseList links resulting in the addition of nodes and to KStore . After completion of the processing for the Tom Wednesday 103 sold NJ node path of KStore the next entry in node s asCaseList would be processed if any. As there are no other branches beginning from node Tom the next asCaseList entry for the node BOT is processed. The next pointer in the asCaseList for node BOT points to node Bill . Hence the count for node is added to the count for the analogous node in KStore node Bill resulting in count for node Bill to be set to 13. Similarly counts are updated in KStore for the nodes analogous to nodes and in KStore yielding counts of 7 for nodes and in KStore . This process is repeated for the rest of the KStore structure resulting in the creation of the KStore .

A similar process can be followed when subtracting KStores. For example to subtract KStore from KStore the branches of KStore are traversed using the asCaseList links starting from the BOT node node . Counts of nodes of KStore are subtracted from the counts of analogous nodes in the existing KStore KStore to create the updated KStore KStore of . For example the count of node Tom is subtracted from the count of node of KStore to result in the count of 4 for node of KStore . Processing the Tom Wednesday branch of KStore has no effect because there is no Tom Wednesday branch in KStore . Should counts in KStore reach zero or become negative as a result of the subtraction of a KStore a branch may be removed from the KStore. For example if a branch in KStore to be subtracted from KStore included BOT Tom count 3 Monday count 3 103 count 3 trial count 3 NJ count 3 end product node count 3 the branch represented by nodes and would be removed and the count of nodes and would be reduced by 3 to 2 and 2 respectively.

To add or subtract a portion of a KStore the appropriate asResult tree may be used to isolate the desired branches of the KStore to be added or subtracted. For example to add only the Bill branches of KStore to KStore Bill records may be isolated using the Bill asResult tree following the asResultList pointer of root node to node Bill and following the asCaseList pointers from node Bill to node through node and from node Bill to node and following the asCase links from node to node updating the counts of analogous nodes in KStore and adding structure as needed. Similarly to subtract only the Bill branches of KStore from KStore Bill records may be isolated using the Bill asResult tree following the asResultList pointers of root node to node Bill and following the asCaseList pointers of node Bill to node and so on through node and from node Bill to node and following the asCaseList pointers of node and so on to node updating the counts of analogous nodes in KStore and deleting structure as needed. It will be appreciated that the updating KStore the existing KStore and the updated KStore may represent different states of the same KStore as it changes through the updating process. For example a KStore may be updated by deleting all the records in the KStore associated with a particular year e.g. for 2008 by constraining the records to be removed e.g. by isolating the 2008 records to be removed and reducing the count of the end product nodes for the selected records by the number count of isolated 2008 records .

It will be appreciated the branch to be added or subtracted may be traversed to the end product node to determine counts if counts are not maintained at each node. Moreover the branch may be traversed back to the BOT node to determine which node is analogous in the KStore to be updated e.g. to determine when subtracting Bill Tuesday path nodes accessed via a Tuesday asResult tree that the node indicated in the Tuesday asResultList belongs to Bill and not Tom .

In accordance with other aspects of the subject matter disclosed herein instead of updating counts a dataset such as dataset or dataset may be recreated and sent record by record to the KStore to be updated. Records can be recreated by isolating the portion of the KStore to be added or subtracted if a partial KStore is to be added or subtracted as described above. One record at a time can be created by determining the counts and creating that number of records. For example if a count for a sequence of nodes is one one record is created if a count for a sequence of nodes is 3 3 records are created. Records may be created by traversing the path to the end product node to determine the count traversing backwards to the BOT node and then traversing each path back towards the end product node generating records as the path is traversed.

At in response to determining at that a portion of the updating KStore is to be used to update the KStore being updated the portion of the updating KStore to be used for updating is isolated at . Counts are determined for the nodes used for updating the KStore at . Processing then continues at as described above.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus described herein or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the subject matter disclosed herein has been described in connection with the figures it is to be understood that modifications may be made to perform the same functions in different ways. While innumerable uses for this invention may be found and significant variability in the form and manner of operation of this invention are described and will occur to those of skill in these arts the invention is not limited in scope further than as set forth in the following claims.

