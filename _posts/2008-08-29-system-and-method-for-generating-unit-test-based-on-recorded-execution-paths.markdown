---

title: System and method for generating unit test based on recorded execution paths
abstract: A method and system for testing a computer software system based on execution paths including: executing the computer program to obtain an execution path in the computer software; recording the execution path; modifying variables in the recorded execution path to create one or more perturbed paths; analyzing the one or more perturbed paths to detect potential errors; and generating unit tests for the one or more perturbed paths having the detected potential errors. The created test units may then be executed to test the computer software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732676&OS=08732676&RS=08732676
owner: Parasoft Corporation
number: 08732676
owner_city: Monrovia
owner_country: US
publication_date: 20080829
---
This Patent Application claims the benefits of U.S. Provisional Patent Application Ser. No. 60 968 838 filed on Aug. 29 2007 and entitled SYSTEM AND METHOD FOR GENERATING UNIT TEST BASED ON RECORDED EXECUTION PATHS the entire content of which is hereby expressly incorporated by reference. This Patent application is also related to U.S. patent application Ser. No. 11 557 454 filed Nov. 7 2006 and entitled System and Method for Detecting Defects In A Computer Program Using Data And Control Flow Analysis the entire content of which are hereby expressly incorporated by reference.

The present invention relates to testing of a computer software system. More specifically the present invention is directed to a method and system for generating unit test based on execution paths.

One measure of computer code coverage to cover all pieces of the code during testing process is line coverage or decision coverage. Line coverage counts lines of a code which were executed and compares against all lines of the code. Decision coverage counts decisions taken during execution of decision points like if statements. However even this enhanced measure may not sufficiently cover the entire code and scenarios. The combined lines executed and decisions taken formulate an execution path. One decision point with two possible decisions formulates two execution paths. But two independent decision points with two possible decisions each formulate potentially up to four possible execution paths for example decission1.1 decission2.1 decission1.1 decision2.2 decision1.2 decision2.1 and decision1.2 decision2.2 .

It is not uncommon that a defect reveals itself only on one execution path while the rest of the execution paths remain correct. Executing each and every path in a testing environment is virtually impossible since the execution paths depend not only on user driven actions but also on environment external conditions e.g. given status of network connection network traffic state of a database memory size and the like. Emulating all such conditions is extremely time and resource consuming.

Therefore testing is sometimes extended with static analysis of extracted execution path. Execution paths are extracted during parsing process. Then Control Flow Graphs CFGs and or Data Flow Graphs DFGs are created. A code analyzer then attempts to follow the created CFGs and DFGs and detect defects. Reducing a problem to isolated independent execution paths makes such analysis feasible. The problem with this approach is that the number of paths in a computer program is in the order of 2 where N is number of decision points which in turn is proportional to the number of lines of code. Therefore the analysis becomes impractically computational intensive. As a result this approach is impractical in large systems. There is a need to reduce the complexity of the analysis to a size which is in order of N to make the analysis practical for commercial systems in which N can be as large as 1 000 000.

Another approach to the problem described above is to limit analyzed path length to some arbitrary number of steps. This approach however may rule out paths which contain serious problems but take more steps than the imposed limit.

Another drawback of existing methods for automatically generated unit test cases is the fact that they very seldom represent a real program execution situation or environment. That is variables are not independent and cannot get any value that is on a given execution path given variables cannot get any arbitrary value. For example for the statement if b

However not every path in the computer application although possible from the code construction point of view is actually executed in the real life application operation environment. Therefore the number of paths to analyze can be effectively reduced significantly if there would be a way to determine which paths can be actually executed and which cannot. Such statement can be translated into execution probability.

In some embodiments the present invention is a method and system for testing a computer software system based on execution paths. The method and system include executing the computer program to obtain an execution path in the computer software recording the execution path modifying variables in the recorded execution path to create one or more perturbed paths analyzing the one or more perturbed paths to detect potential errors and generating unit tests for the one or more perturbed paths having the detected potential errors. The created test units may then be executed to test the computer software.

In some embodiments the recorded path information may include information about which lines in the computer code were executed and information about variable values at a given path stage. A pattern recognition analysis tool may also be used with a set of pattern recognition rules on the perturbed paths for further verification of the computer program.

In some embodiments the present invention examines only paths with high execution probability and ignores those with low execution probability. To determine which paths have high execution probability the method and system of the invention assumes that such paths are not very distinct from other paths with high execution probability. In particular having a path which was actually executed within the application the paths which can be obtained by small modifications perturbation to the executed path should have high execution probability. Having a recorded execution path an analyzer can traverse it and in each decision take different execution branch one at a time. In other words if a decision point A was modified from a recorded execution path the execution flow is then traced from that point but without taking all possible paths.

To further validate execution paths obtained by perturbing an existing execution path the method and system of the present invention then generate one or more unit test cases to examine test the paths obtained by perturbation. In other words the invention applies a linear method of analysis for determining realistic path candidates based on perturbing the executed path for possible errors. Since the recorded path both the executed path and the perturbed path contains variables and their values taken from a real program execution the variables and their values can be taken to generate unit test cases. Such generated test cases would represent a highly probable situation. The graphs along function invocations of the recorded execution path can be expanded to obtain an elementary path from the recorded execution path. In some embodiments the linear method of analysis includes starting at any point in a perturbed path and traversing in a forward or backwards direction through a corresponding execution path.

A perturbed path is generally derived from a recorded actual executed path by slight modifications of data involved in a decision point. For example if a decision point is if x

A recorded path is a path that is tracked and recorded during computer program execution. For example a user may hit a button which causes program to traverse certain paths through out the computer program code. That may result in opening an editor tool submitting a form performing some calculations or some other actions. All machine instructions performed after such event until the computer program returns to idle waiting for another event constitute an execution path. Such path can be tracked and recorded in the form of list s of files lines executed and all involved data values.

In one embodiment the present invention is a method and system for determining and recording computer program execution paths storing recording them and efficiently analyzing them for generating unit tests based on the recorded stored paths. The method and system provide an Application Programming Interface API which allows for plugging various programming language specific front ends. The system also includes a storage mechanism for determined execution paths a framework under which various concrete analysis algorithms such as verification tools for example a pattern recognition tool algorithm can be used on the stored execution paths. The system further includes pattern recognition rules that enforce defect detection a set of rules that are enforced to avoid possible execution errors and a presentation layer. The method and system also provide a mechanism to create custom rules to be enforced on detected execution paths.

In one embodiment the present invention is a software application for determining storing and analyzing control flow graphs and data flow graphs and based on those graphs generating unit tests to test the most realistic paths. The software application includes a language specific front end in a form of a source code parser an intermediate language parser or the like. The software application also includes an API for retrieving and representing important information about control flow data flow variables types functions and the like a scanner for scanning files in a project and retrieving required information to populate a repository using the API.

The repository is responsible for collecting information about execution paths in a project. The repository is also responsible for optimizing access to the information. An analyzer is the framework for various analyzing algorithms. An analysis or verification tool such as a pattern recognition tool uses rules from a variety of rule sets to recognize certain patterns in the flow graphs that violate the rules under enforcement. Other analysis verification tools can be easily plugged in utilizing repository features for additional path filtering or defects detection.

A software tool for rule creation such as Rule Wizard from Parasoft Corporation which presents rules graphically allows for rule customization and rule addition. Rules are stored in proprietary formats or open formats like XML UML or the like. A control User Interface UI drives the scanner and the analysis routines and provides configuration. A presentation UI presents analysis results to the user.

An API retrieves information about control flow data flow variables types functions and the like. A scanner utilizes the API to scan files in a project and retrieves required information to populate a repository .

The repository collects information about files in a project. This repository is also responsible for optimization and access to the optimization information and information like Control Flow Graphs CFG and or Data Flow Graphs DFG for a given function and all implementations of a given virtual function.

An analyzer is a framework for various analyzing processes. The analyzer can use rules from various rules sets to analyze or recognize certain patterns in the flow graphs which violate rules under enforcement. Other processes can be easily plugged in utilizing the Repository features for defects detection.

A sets of rules to be enforced by the analyzer are available. A rule creation tool such as Rule Wizard that presents rules graphically and allows for rules customization and addition can be used with the present invention. Created rules may be stored in a proprietary format or open format like XML UML and the like.

A control User Interface UI drives the scanning and analysis processes. The UI also provides configuration for which rules to use how large the paths need to be place limit on the maximum time spent on the analysis and the like. A presentation UI presents analysis results to the users.

Additionally presents an exemplary notion of breaking larger execution units like files with source code into smaller parts like methods and functions and . Each such entity is then converted into control flow graph . Each element of control flow graph which contains execution statements and variables has a created corresponding data flow graph .

On this executed path there are 3 decision points 1 2 3 4 5 and 8 9 . Let s assume that perturbing first decision point would lead to the path 2 6 8 . The invention analyzes this path but does not try to extend it by trying out to modify other decision nodes. Then the invention perturbs the second decision node that leads to the paths 1 3 and 1 5 10 . Perturbing the third decision node leads to the path 1 4 9 . In such case four new paths are to be analyzed and four other paths are not to be analyzed because other decision points were not modified .

With a more complex software program the number of paths skipped in comparison with those analyzed significantly grows. In such case analysis of the remaining paths can be much more thorough than if the system was analyzing all potentially possible paths. Perturbation to the original path at the given decision point can be achieved by analyzing the condition s that governs the decision node. For example the statement if a

After the path is analyzed the invention returns to the perturbed decision point and takes a second path assuming that a 5. For the purpose of unit test generation the task becomes more complicated because the actual value of a at the decision point is a result of the computation and initial conditions at the beginning of unit test case generation. In some embodiments the invention modifies starting conditions and performs the computations in such a way that desired value of a is achieved at the decision point. Another possible method is to insert one or more assignment statements prior to the decision point to set a to the desired value and then use the above mentioned first method only if newly generated path reveals any problems. This way the invention can rule out computation intensive activities for the paths that do not lead to any problem.

To generate unit test cases rather than performing only static analysis the invention manipulates the input data. For example as shown in a first decision point is governed by variable v1 and v2 a second decision point is governed by variable v2 and a third decision point is governed by v1 and v3 which depends on v2. Therefore in this example decision points are not completely independent and some of the selected paths may not be effectively executed.

Variables values can be manipulated by changing values of the system variables inside unit test case. In some embodiments the invention can directly set appropriate value to the variable in the test case. Often there is an indirect dependency between starting variables and the one governing decision point y f x1 x2 . . . xN where y is variable at the decision point and x1 to xN are variables which can be set as starting conditions in unit test case. If desired value of y is Y then following equation is solved using known methods 12 0 Eq. 1 

Having a given path the invention can slightly perturb it by changing some variable s for example by changing initial values for the test case so different decision is made in one of the decision points as shown in block . As a result based on a different decision point a different path is created. Depending on the nature of the code the new path may be completely different or slightly different from the original path. The assumption in this example is that the new path is created by a small change in one or limited number of decision nodes. One or more unit tests are then generated using variable values recorded with the recorded execution paths.

Having a given recorded path the invention creates one or more unit test case s which reproduce s that path. The recorded path information include not only information about which lines were executed but also information about which variable has what value at a given path stage. Moreover an event occurrence can be simulated with a test case which calls one or more appropriate function s event handler with the appropriate data. Such unit test case therefore causes same path piece of code to be executed.

Execution of a path usually starts from input operation when user initiates an action form a user interface or when some event occurs which initializes application action. The path then continues throughout the system until all required actions decided by the user are completed. Unit test cases can emulate user action from the UI. All objects being part of the system and referenced during the path execution are initialized with the recorded values. Then variables reading user input are set with the data entered by the user.

Alternatively if an event was originating instantiating the path unit test cases provide data associated with the event. For example if the event was related to an arrived message an appropriate message is delivered. If the event was indicating that some data is ready to be read from the stream the unit test case framework prepares one or more stream stubs which deliver required data.

It will be recognized by those skilled in the art that various modifications may be made to the illustrated and other embodiments of the invention described above without departing from the broad inventive scope thereof. It will be understood therefore that the invention is not limited to the particular embodiments or arrangements disclosed but is rather intended to cover any changes adaptations or modifications which are within the scope and spirit of the invention as defined by the appended claims.

