---

title: Systems for authentication for access to software development kit for a peripheral device
abstract: A set of code for a peripheral device is installed on a host device. The set of code is used to control access to the peripheral device from the host device. The set of code also contains one or more subsets of code that can be used by software entities on the host device for access to the peripheral device. A software entity on a host device must be successfully authenticated with the set of code installed on the host device. Once the software entity is successfully authenticated, the set of code will provide access to the one or more subsets of code specific to the software entity. The one or more subsets of code can be used by the software entity to access the peripheral device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621601&OS=08621601&RS=08621601
owner: SanDisk Technologies Inc.
number: 08621601
owner_city: Plano
owner_country: US
publication_date: 20080521
---
The following application is cross referenced and incorporated by reference herein in its entirety U.S. patent application Ser. No. 12 124 450 entitled Authentication for Access to Software Development Kit for a Peripheral Device by Mei Yan Chieh Hao Yang Bahman Qawami Farshid Sabet Sharghi Patricia Dwyer and Po Yuan filed the same day as the present application.

Preventing unauthorized access to a secure peripheral device has become a greater concern as technology has advanced. An example of a secure peripheral device may be memory devices as memory devices containing secure content must be protected from unauthorized use.

Semiconductor memory has become more popular for use in various electronic devices. For example non volatile semiconductor memory is used in cellular telephones digital cameras mobile media players personal digital assistants mobile computing devices non mobile computing devices and other devices.

Protecting content stored on non volatile semiconductor memory devices has become an important feature especially concerning protection for copyrighted material. For example a user may purchase copyrighted content such as music through an electronic device. Content owners typically intend for only the purchaser to use the content and may require that the purchased content be played only by authorized applications on an electronic device such as the application used to purchase the content.

Securely storing information to protect against unauthorized use of secure content can be performed using a variety of protection techniques such as encryption. An application on a device that tries to access encrypted content must decrypt the content using an encryption key before that content can be read. An application authorized to access the encrypted content will have the appropriate encryption key for decrypting the content. Unauthorized applications may still be able to access the encrypted content but without the appropriate encryption key the unauthorized application may not be able to read the content. However if an application obtains the encryption key the unauthorized application will be able to read the protected content. There is a need for an improved simplified and secure way of preventing an unauthorized application on an electronic device from accessing protected content on a secure peripheral device.

The technology described herein pertains to authentication of an application application launcher or other software entity on a host device to prevent unauthorized access to a secure peripheral device. The software entity is authenticated with set of code on the host device using any authentication mechanism. The set of code is associated with the peripheral device and is installed on the host device to control access to the peripheral device. The set of code also contains code that software entities on the host device can use for performing tasks associated with the peripheral device. Once the software entity is successfully authenticated the set of code will make code that the software entity can use for performing tasks associated with the peripheral device available to the software entity.

One embodiment includes a secure peripheral device and a host device in communication with the peripheral device. The host device includes one or more processors that control access to the peripheral device. The one or more processors also manage a set of code installed on the host device for the peripheral device by controlling access to the set of code where the set of code allows communication between the peripheral device and one or more software entities on the host device. The one or more processors verify a credential from a first software entity on the host device and expose a subset of code from the set of code to the first software entity if the credential is valid where the subset of code is associated with the first software entity.

One embodiment includes a cryptographic engine and one or more processors on a host device that are in communication with the cryptographic engine. The cryptographic engine verifies a credential from a first software entity on the host device. The one or more processors intercept access to a secure peripheral device. The one or more processors also receive the credential from the first software entity and expose code associated with the first software entity if the credential is valid. When the one or more processors execute the code the one or more processors allow the first software entity to access the peripheral device.

One embodiment includes one or more processor readable media having processor readable code respectively where the processor readable code causes the one or more processors to perform a method. The method includes sending one or more authentication options to a first software entity on a host device when the first software entity requests access to a peripheral device including sending one or more authentication options to the first software entity from a set of code installed on the host device for the peripheral device where the set of code includes code associated with one or more software entities on the host device. The set of code receives a credential from the first software. The credential is associated with one of the one or more authentication options. The method further includes providing access to first code associated with the first software entity if the credential is valid. The first code allows access to the peripheral device and is part of the set of code.

The disclosed technology provides secure access to a peripheral device by implementing security features on a host device. A peripheral device can be any device operated via a host device such as a memory device a printer a keyboard etc. Software for the peripheral device must be installed on the host device in order to operate the peripheral device on the host device. This software is a set of code for a software development kit SDK such as a dynamic link library DLL or a static library LIB installed on the host device for operating the peripheral device via one or more software entities or applications on the host device. Many times different applications on the host device will require different APIs for accessing the peripheral device depending on the type of application the functions of the application and the authority of the application for example. When a user sends a task request to the host device via an application and the task request involves access to the peripheral device the SDK for the peripheral device will authenticate the application and verify that the application is authorized to access the peripheral device. If the authentication is successful the SDK will expose only those APIs for that specific application. The SDK will not expose APIs the application is not authorized to access. The application can send and perform the task request using the exposed APIs specific to that application. This increases the security of the peripheral device and prevents unauthorized access to APIs for other applications.

When a SDK is created by a software developer for a peripheral device that will be operated through a host device such as the host device depicted in the SDK software may be configured for each software entity or application on the host device that will require access to the peripheral device. Many times the software entity on the host device may be owned or created by a particular customer with various needs and preferences. The SDK may be configured based on each software entity application or customer s needs and preferences such as authorization preferences or functions of the customer s application. is a flow chart for one process of configuring a set of code for a SDK based on different application and or customer needs and preferences. In step the SDK software specific to each application and or customer will be configured by the SDK software developer based on the specific requirements of the application and or customer. For example the set of code for the SDK for accessing a peripheral device through a customer application typically requires an API for interfacing the application with the peripheral device. The SDK software for access to these APIs for the application can be specifically configured based on customer preferences such as configuring the SDK to require application authentication before the peripheral device is accessed for example. The SDK is configured to determine which APIs each application will need to access. In step the SDK software for operating the peripheral device will be configured based on the required APIs of the SDK software specific to each application customer performed in step . This may include for example any SDK software modification needed for any security features required of each application customer. Once the SDK software for operating the peripheral device is configured the SDK will properly function using all of the software configured for each application and or customer in step e.g. security software required for authentication and any other software needed to operate the peripheral device on the host device including the software customized in step .

Note that in some embodiments step is performed for a particular secure peripheral device only during the first time that the particular secure peripheral device is connected to the host device. Once the SDK is installed on the host device during the first connection of a secure peripheral device the SDK for this particular peripheral device need not be installed again each time it is re connected to the host device. In other embodiments the SDK is loaded and installed every time the secure peripheral device is connected to the host device.

In one embodiment the SDK for operating the secure peripheral device is loaded and pre installed on the host device before the operating system is installed on the host device. In this case the SDK can be used by activating or selecting it through the operating system. Therefore step need not be performed as part of the process of . In another embodiment the SDK for operating the secure peripheral device is loaded and pre installed on the host device after the operating system for the host device has been installed. Again in this case step need not be performed as part of the process of .

To more specifically describe the process of securely accessing a peripheral device through a SDK for the peripheral device a secure memory device will be used as an example of a peripheral device. However note that the peripheral device can be any peripheral device and is not limited to the example of a memory device described below.

The application uses a host storage manager on the operating system for the host device to access or store content on the host device or any other peripheral devices such as a removable memory device. The host storage manager is a software component on the operating system that controls access and storage functions for the host device including access and storage within the host device and between any peripheral devices as will be explained in more detail below.

Additionally content stored on the host device can be encrypted for protection. The host device may contain a host cryptographic engine which may have a random number generator and a cryptographic processor that may support encryption methods such as symmetric encryption i.e. AES DES 3DES etc. cryptographic hash functions i.e. SHA 1 etc. asymmetric encryption PKI key pair generation etc. or any other cryptography methods.

In the host device is physically connected to the secure memory device through the physical interface . The application the host CPU the host device crypto engine the host storage manager and the host file system are software components on the host device as shown in . The peripheral device SDK is the set of code installed on the host device and is used to operate the secure peripheral device with the host device . The peripheral device SDK uses the secure peripheral device API the peripheral device SDK security layer the host file system the registration table the SDK crypto library and the secure file system to manage content access and storage for the secure memory device . The secure peripheral device API the peripheral device SDK security layer the registration table the SDK crypto library the secure file system and the device driver are software components loaded and installed on the host device from the set of code for SDK for the secure memory device as described in step of . The open channel and the secure channel are the data buses used to transfer content between the host device and the secure memory device .

The secure memory device controls access to and storage of content using software installed on the host device for the secure memory device . The software includes the libraries described in step of or they can be libraries pre installed on the host device. The SDK libraries loaded and installed on the host device can be either dynamic link libraries DLL or static libraries LIB that can be integrated into the operating system on the host device. The set of code for the SDK provide hooks into the host storage manager for secure operation of the secure memory device . For example subsets of code from the set of code for the peripheral device SDK can be inserted in the call chain for calling the host file system so that the code causes the host CPU to control how content is accessed and stored. In the peripheral device SDK security layer the secure peripheral device API the secure file system the registration table the SDK crypto library and the device driver are the subsets of code that are provided to the host device through the set of code for the secure peripheral device SDK using a device driver installed on the host device .

A user may access content stored in the secure memory device through a software entity such as an application on a host device as shown in . For protected content stored in the secure peripheral device the application first needs to be authenticated before the content can be accessed as described in more detail below.

The application uses the host storage manager on the operating system for the host device to access or store content in the secure memory device . The host storage manager controls access and storage functions for the host device including access and storage within the host device and the secure memory device .

Typically the host storage manager controls access and storage functions for the host device or any peripheral devices using a host file system on the operating system for the host device as discussed in . The host file system can be any standard file system such as FAT12 FAT16 FAT32 NTFS etc. However for the secure memory device the peripheral device SDK for the secure memory device uses a peripheral device SDK security layer to control access and storage functions on the host device by using a secure file system for the secure memory device . Access to the secure file system is controlled by authenticating the application and allowing access to only APIs specific to the application upon successful authentication. These APIs allow the proper interface for the secure file system . The secure file system is installed on the host device for the secure memory device and is the file system for the content stored in the secure memory device . The secure file system can be any standard file system such as FAT12 FAT16 FAT32 NTFS etc.

Software for the peripheral device SDK security layer is loaded and installed as part of the SDK loaded and installed in step of . The peripheral device SDK security layer causes the host CPU to authenticate the application . After the application is successfully authenticated the application will be registered in the registration table . The peripheral device SDK security layer also provides an application handler to the application . The application handler indicates which APIs the application is allowed to access. More detail regarding the authentication and registration process performed by the peripheral device SDK security layer will be described below.

When a user through an application requests access to content the peripheral device SDK security layer will provide the appropriate API such as secure peripheral device API needed to access the content from the secure peripheral device after successful authentication. Using the accessed API the application can receive the content stored in the secure peripheral device by accessing the permissions associated with the content. For protected content the header is stored with the content and contains information associated with the content such as domain information related to content encryption keys CEK for encrypting and decrypting the content and content metadata which may indicate what type of content is stored.

The secure peripheral device API Application Program Interface in the peripheral device SDK is used to interface the secure peripheral device with the application when content is accessed or stored. The secure peripheral device API is part of the SDK that is installed and may be called by the application when the application is successfully authenticated. The secure peripheral device API is the interface bridge between the peripheral device SDK security layer and the secure file system .

Once the content is located or filed using either the secure file system the content can be accessed or stored on the secure memory device in the appropriate location using the device driver on the host device. This is performed through the physical interface that physically connects the host device and the secure memory device . The content may be accessed or stored using a secure channel or an open channel . The peripheral device SDK determines whether the content should be transferred between the secure peripheral device and the host device using a secure channel or an open channel .

When a user through the application requests storage of content that should be unprotected the peripheral device SDK will use the host file system to store the content. If the user requests storage of content that should be protected in the secure peripheral device the peripheral device SDK will use the secure file system to store the content.

The secure peripheral device API Application Program Interface in the peripheral device SDK is used to interface the secure peripheral device with the application when protected content is accessed or stored. The secure peripheral device API is part of the SDK that is installed and may be called by the application when the application is successfully authenticated. The secure peripheral device API is the interface bridge between the peripheral device SDK security layer and the secure file system .

Once the content is located or filed using either the host file system or secure file system the content can be accessed or stored on the secure peripheral device in the appropriate location using the device driver on the host device. This is performed through the physical interface that physically connects the host device and the secure memory device . The content may be accessed or stored using a secure channel or an open channel . The peripheral device SDK security layer determines whether the content should be transferred between the secure peripheral device and the host device using a secure channel or an open channel .

A session key is an encryption key used to encrypt content before it is transferred between the host device and the secure memory device. If content does not need to be transferred through a secure channel there may be no session key associated with the content or the session key associated with that content may indicate that no encryption is needed.

If the content is associated with a session key indicating that the content should be transferred using a secure channel the content will be encrypted using the session key before it is transferred through the secure channel . Once the encrypted content is transferred the content will be decrypted using the same session key. The content is encrypted or decrypted on the host device using the SDK crypto library . The SDK crypto library contains a random number generator and cryptographic functions for encryption such as symmetric encryption i.e. AES DES 3DES etc. cryptographic hash functions i.e. SHA 1 etc. asymmetric encryption PKI key pair generation etc. or any other cryptography methods. The secure peripheral device has its own crypto engine for encryption on the secure memory device before or after transferring content as will be explain in more detail for . If the session key indicates that the content should be transferred using an open channel the content is transferred without encrypting the content.

For host devices that do not have the peripheral device SDK installed the host device may be able to access content stored in a public partition. If the content is protected although the device may be able to access the content the device will not be able to read the content correctly if it is encrypted. If the content is stored in a secure partition the device cannot access the content.

The application APIs are the APIs used by any application such as the application in . These APIs include APIs used for authentication and they also include APIs used to interface an application with the secure file system for access to content on the secure memory device once the application has been successfully authenticated such as the secure peripheral device API in . The application APIs may contain APIs specific to that particular application. For example an API used by one application may not be used by another application. An application that is successfully authenticated through the peripheral device SDK security layer may access protected content in the secure memory device through a secure peripheral device API . The secure peripheral device APIs are discussed in more detail below for .

The peripheral device SDK security layer as shown in is installed on the host device to provide hooks into the host storage manager and cause the host CPU to control how content on the secure memory device is accessed and stored. The code for the peripheral device SDK security layer hijacks the host file operations on the host device so that an application can be authenticated before accessing content on the secure peripheral device .

The software of the device driver as shown in can be loaded and installed on the host device after the secure memory device is connected to the host device step of or pre installed on the operating system for the host device either before or after the operating system is installed on the host device.

The secure file system is the file system containing filing data for accessing and storing content in the secure memory device as illustrated in .

The SDK crypto library is the library containing the cryptographic schemes that may be used for encrypting or decrypting content for a secure channel . The cryptographic schemes can be any known schemes such as AES DES 3DES SHA 1 PKI key pair generation etc. The SDK crypto library will encrypt or decrypt content based on permissions associated with the content such as a session key.

The registration table is the table used by the peripheral device SDK security layer to manage and maintain the application authentication status and related information. The table may contain information such as authentication algorithms application ID registration time expiration time registration status etc. More detail regarding the registration table will be discussed below.

Continuing with the example of a secure memory device depicts one embodiment of the secure peripheral device shown in . The secure peripheral or memory device contains a firmware module a CPU a peripheral device crypto engine and a system partition . The system partition contains public partitions and secure partitions . The firmware module accesses and stores content in either the public partitions or the secure partitions of the system partition using the CPU . The memory device crypto engine is used to encrypt or decrypt the accessed or stored protected content within the secure memory device .

The firmware module contains the hardware and software for controlling the access and storage of content on the secure memory device for the secure partitions and the public partitions . The firmware module programs the CPU to perform the access and storage functions such as determining from which portion of memory content should be accessed or stored and whether the content is protected. More details regarding the firmware module will be discussed below in the description for .

The public partitions are memory partitions of the secure memory device that are viewable by a user and detectable by the host device . The secure memory device may have one or more public partitions. The public partitions may contain public content that is openly accessible to a user or the host device . The public partitions may also store protected content that is encrypted using a content encryption key CEK . The CEK can be generated using the domain information stored in the content header containing information associated with the content. Public content may also be stored without encrypting the content.

The secure partitions are hidden memory partitions of the secure memory device that are not viewable by a user and are not detectable by the host device. The secure memory device may have one or more secure partitions. The secure partitions may contain protected content that is not openly accessible to the user or the host device . The protected content may be encrypted using a CEK. Content stored in the secure partitions is accessible to authenticated applications having the appropriate permissions for accessing the content. The information associated with the CEK and the permissions associated with the content are stored in the content header containing information associated with the content. In one embodiment public partitions and secure partitions of the system partition are stored in a flash memory device that includes a controller and one or more flash memory arrays.

Because the secure partitions are hidden partitions undetectable by a user or the host device the secure partitions may contain the software for operating the secure memory device on the host device including rights objects application credentials etc.

The peripheral device crypto engine is used to encrypt or decrypt the content using the CEK or the session key within the secure memory device . The memory device crypto engine contains a random number generator and a cryptographic processor that may support encryption methods such as symmetric encryption i.e. AES DES 3DES etc. cryptographic hash functions i.e. SHA 1 etc. asymmetric encryption PKI key pair generation etc. or any other cryptography methods.

If no protection is needed the flash memory manager controls access and storage of unprotected content in the secure memory device using the CPU . When a request to save unprotected content is received from the host device through the device driver the flash memory manager will save the content in the appropriate location according to the host file system . When a request to access unprotected content is received through the host device file system via the device driver the flash memory manager will access the content from the appropriate location using the host file system . The flash memory manager also provides access to the protected content access manager when the application tries to access protected content in the secure memory device .

If protection is needed the protected content access manager controls access and storage of protected content in the secure memory device using the CPU . The protected content access manager stores or retrieves the permissions associated with the protected content to or from the DRM module . The protected content access manager uses the secure file system shown in to access or store protected. For example when a request to save protected content is received from the host device through the device driver the peripheral device SDK security layer will use the SDK crypto library to encrypt the protected content using a session key associated with the content if the content should be sent through a secure channel . The encrypted content is then sent to the secure memory device through the secure channel and decrypted at the secure memory device using the session key and the appropriate cryptographic scheme from the crypto engine library . The decrypted content is then encrypted by the peripheral device crypto engine using a CEK for the content. The content encrypted using the CEK is then saved in the appropriate location according to the secure file system .

For protected content sent through an open channel a similar method for transferring the content is performed but without the session key encryption for the secure channel . When a request to access protected content is received from the host device through the device driver the protected content access manager will access the content from the appropriate location using the secure file system and provide the content to the host storage manager on the host device through an open channel . The protected content access manager will access and store content through the flash memory manager once the appropriate permissions are determined by the protected content access manager .

The protected content access manager may also use the DRM module to provide access to content based on permissions associated with the content such as copyright permissions for example. The DRM module can support any particular DRM technology such as OMA DRM MS DRM etc.

The crypto engine library contains the cryptographic schemes that may be used for encrypting the content with a CEK or a session key within the secure memory device . When content should be encrypted or decrypted in the secure memory device the protected content access manager will access the appropriate cryptographic scheme from the crypto engine library . The cryptographic schemes can be any of the known schemes such as AES DES 3DES SHA 1 PKI key pair generation etc.

When protected content is saved to the secure memory device the protected content access manager organizes the content according to the permissions associated with the content and the content is then stored by the flash memory manager . Public and secure partitions may have domains or logic groups that contain groups of protected content having the same CEK. Each domain or logic group is associated with one CEK for decrypting content from or encrypting content to that domain or group. Any application having the appropriate permissions for opening content within a domain or group may also be able to open other content stored in the same domain or group.

Public partition P in contains two logic groups Domain and Domain . All content stored in Domain will use one CEK for encrypting and decrypting content. All content stored in Domain will use another CEK for encrypting and decrypting the content. A software entity attempting to access either of these groups will require authentication before the content can be read. Because the public partition P is not hidden and is openly accessible protected content contained within a group may be seen and possibly accessed but the content may not be read unless the content is properly decrypted using the appropriate CEK. Therefore it is possible that content in a group may be corrupted by an unauthorized user but the content may not be read.

File A in public partition P is not contained within a group so it does not have a CEK associated with it. Therefore any user may access and read File A .

Secure partition P contains File E and File F. File E and File F can be any file requiring protection in a secure partition. For example File E or File F can be used by the SDK to store secure information such as content licenses or any internal management data. However secure partition P is not limited to storing only these types of files. Secure partition P can store any secure files.

Secure partition P contains File G and File H both within Domain . Domain is associated with a CEK for encrypting and decrypting the content. For example if an application attempts to access File G in Domain the application must first be authenticated. Once authenticated the application may access File G using the CEK for Domain and may also access File H within Domain .

The APIs for APP show the subgroup of APIs from the entire group of APIs that are specific to Application . The SDK was configured to allow the APIs for APP to be accessed by Application upon successful authentication see step . In one embodiment the APIs for APP is the subset of code from the set of code for the SDK that may be called by one or more different applications. In another embodiment the APIs for APP may only be called by Application software entity. The APIs for APP include secure storage APIs configuration APIs DRM APIs and customized APIs. However the APIs for APP are not limited to only those APIs.

The standard and secure storage APIs contain the APIs needed for an application or an application launcher to retrieve and store content on the secure memory device to establish a secure session or to perform any other type operations involving access and storage of content on the secure memory device . For example a standard or secure storage API may be an API that allows an application to send a path location for content requested for access to the host file system or the secure file system . The application may call a standard API from the group of standard and secure APIs when accessing public content and may call a secure API from the group of APIs for APP after Application is authenticated with the peripheral device SDK security layer such as secure peripheral device API shown in .

The authentication APIs are APIs used to authenticate an application and it is open to all applications without requiring an authentication process for access to authentication APIs . The authentication APIs are called by the application . When an authentication API is called by an application the application can send a credential to the peripheral device SDK security layer using the authentication API . The peripheral device SDK security layer will then verify if the credential sent by the application through the authentication API is valid. The credential can be any type of credential used to authenticate a software entity such as a response to a challenge response authentication algorithm a PKI certificate a PIN a key a password etc. In the case of the challenge response authentication the authentication API may be used to send a challenge to the application . The response to the challenge may then be sent from the application to the peripheral device SDK security layer using the same authentication API .

The configuration APIs are the APIs used to allow the application to configure the secure memory device or to retrieve information about the configuration of the secure memory device . This may only occur if the application has the appropriate authority to do so. For example the configuration APIs may be called by a specific application to obtain information about the used and free memory space on the secure memory device or to create a new secure partition after the application is successfully authenticated.

The DRM APIs may be called by the application to access the permissions or digital rights associated with content and provide access to that content if the rights are valid. The validation of these rights would occur in the DRM module in the firmware module in the secure memory device . In one embodiment the DRM APIs may be specific to a particular application such as shown in the subgroup of APIs for APP .

The customized APIs may be any additional APIs a user may require for operation of the secure memory device in the host device . The customized APIs may be specific to a particular application such as shown in the subgroup of APIs for APP .

In step of a user may send a task request to an application on the host device . The task request is received from the application at the peripheral device SDK security layer step .

In step the peripheral device SDK security layer will perform a registration process for the application . The registration process is the process for authenticating the application and registering the application in the internal registration table shown in if the authentication is successful. If the registration is successful the peripheral device SDK will send an indication to the application . The indication indicates that the APIs specific to the registered application are exposed. The peripheral device SDK security layer also sends an application handler to the application . The application handler is used as an added security measure. Each time the application communicates with the peripheral device using an exposed API the application must also send the application handler to the peripheral device via the API. More detail about the registration process will be described in .

If the registration process of step is successful the application will send the task request to the peripheral device SDK through one or more of the APIs exposed during the registration process step . The task request must be sent with the application handler given to the application during the registration process.

In step the peripheral device SDK will perform the task request using the exposed subgroup of APIs specific to the application . describes an example of how this step is performed for storage of protected content in a secure memory device. describes an example of how this step is performed for access of protected content stored in a secure memory device.

Once the task request is completed in step the peripheral device SDK security layer will unregister the application from the internal registration table in step . describes how this step is performed in more detail.

The ListAuthenMethod API may provide the peripheral device SDK security layer with the application ID char AppID for the application . The application ID is the unique identifier associated with the application . The peripheral device SDK security layer will return a list of authentication methods char AuthList supported by the peripheral device SDK . The application will then choose which authentication method to use from the list provided by the peripheral device SDK security layer based on the authentication method the application is programmed to use.

In step the application will perform the chosen authentication method by acquiring the appropriate credential for the chosen authentication method. For example if the chosen authentication method is PKI based the application will perform the authentication method by retrieving its PKI certificate as its credential. If the chosen authentication method is a challenge response authentication method the application will perform the authentication method by calling the challenge response API stored with the authentication APIs in the memory device SDK . The application will receive the challenge from the peripheral device SDK security layer using the challenge response API. The challenge can be a random number generated by the host device crypto engine or the memory device crypto engine . The application will then calculate the appropriate response to the challenge as its credential. More detail about how different authentication methods are performed is discussed in the description for .

In step the application will send the registration information to the peripheral device SDK security layer by calling a registration API. The API for registering the application can be defined for example as 

The RegisterApplication API may allow the application to send its application ID char AppID the chosen authentication method char AuthMethod the credential uchar credential and the length of the credential uchar credentialLen retrieved in step to the peripheral device SDK security layer using the RegisterApplication API. The credential length should be provided to support different credential lengths that different authentication methods may require.

In step the peripheral device SDK security layer will check to see if the credential is valid. If the credential is not valid the peripheral device SDK security layer will return an error to the application step .

If the credential is valid in step the peripheral device SDK security layer will generate an application handler for the application . The application handler is a unique random number that is generated using any predefined cryptographic algorithm such as HASH for example. The application handler will be generated by inputting particular values into the predefined cryptographic algorithm. These particular values can be any values associated with the application and or the registration information for the application such as the application ID the time that the application is registered the amount of time that the application can be registered or the registration status for example. All peripheral device SDK APIs contain an input parameter for an application handler. In one embodiment a default application handler can be generated and used for APIs that are open to all applications. However as previously described the authentication APIs are open to all applications and no application handler is required for accessing these APIs for authentication.

Once the application handler is generated the peripheral device SDK security layer will register the application in an internal registration table managed by the peripheral device SDK security layer step . The internal registration table contains information for authenticated applications and application launchers. For applications and application launchers that have been successfully authenticated with the peripheral device SDK security layer the peripheral device SDK security layer will record information in the internal registration table such as the application handler a time out period for the application indicating an amount of time that the authenticated application can remain registered in the internal registration table e.g. the registration time the amount of time the application can be registered the APIs the application can access or any other information. The internal registration table is used to keep track of authenticated applications and application launchers so that those authenticated applications and application launchers do not have to re authenticate each time a task request is received while the authenticated applications and application launchers are registered in the authentication table.

In step the peripheral device SDK security layer checks if the application is successfully registered in the internal registration table . If the application is not successfully registered in the internal registration table the peripheral device SDK security layer will return an error to the application step .

If the application is successfully registered in the internal registration table the peripheral device SDK security layer will return the application handler generated in step to the application step via the authentication API. The peripheral device SDK security layer will also return an indication to the application indicating that the registration was successful such as status ok step . The status ok indication lets the application know that the subgroup of APIs specific to the application and needed to perform the task will be exposed for use by the application .

In step the peripheral device SDK security layer will then expose the subgroup of APIs from the peripheral device SDK to the application such as the subgroup shown in . This subgroup of APIs will allow the application to communicate with the secure peripheral device . However access to this portion of code is only allowed if the application provides a valid application handler after authentication. This subgroup of APIs allows the application to perform the task request by creating the proper link between the application and the secure peripheral device .

In step the application will calculate a response by inputting the received challenge into a cryptographic function that the application was programmed to use. In step the application will send the calculated response to the peripheral device SDK security layer . The peripheral device SDK security layer will also calculate a response using the same challenge in the same cryptographic function step and compare that calculated response with the response received from the application step . This comparison step is how the peripheral device SDK security layer checks if the credential e.g. the response from the application is valid step of . The registration process of can continue based on this credential.

In step the peripheral device SDK security layer will verify the certificate. In step if the certificate is valid the peripheral device SDK security layer will encrypt a randomly generated number with a public key retrieved from the certificate sent by the application step . The random number could be generated and encrypted using the SDK crypto library . The encrypted random number is then sent from the peripheral device SDK security layer to the application step .

In step the application will decrypt the encrypted random number received from the peripheral device SDK security layer using a private key associated with the public key used by the peripheral device SDK security layer . Authorized applications are able to decrypt the encrypted random number because they have the correct private key. In step the application will send the decrypted random number to the peripheral device SDK security layer for verification step of . At that point the process of can be continued.

Application and Application are examples of other applications that have been successfully authenticated with the file system filter and registered in the internal registration table . Application may access and store protected content through the secure file system and the device driver using the subgroup of APIs for APP such as the secure storage APIs and the DRM APIs and may also configure the secure memory device using the configure APIs in the SDK. However Application may not have access to any custom APIs within the SDK. The APIs that Application is allowed to access are based on the SDK configuration as described in step of . Similarly Application may access and store protected content through the secure file system and the device driver using the subgroup of APIs for APP . However Application does not have access to the configuration DRM and custom APIs within the SDK as the SDK was not configured to allow Application to access these APIs in step of .

Continuing with the example of a secure memory device as the peripheral device is a flow chart describing one example of how the peripheral device SDK performs the task of storing protected content in the secure memory device step of . In step once the registration process of is complete and the task request has been sent using one or more of the exposed APIs the peripheral device SDK will direct the secure file system for the secure memory device to locate a place to store the protected content in the secure memory device . The application may call one of the APIs from the subgroup of APIs that was exposed in step of to provide the desired storage location for the secure file system .

In step the peripheral device SDK will access the permissions associated with the storage location where the protected content is to be stored such as a session key for creating a secure channel . In step the peripheral device SDK will determine whether a secure channel should be used to transfer the protected content based on the permissions accessed in step .

If the peripheral device SDK determines that a secure channel should not be used the protected content will be transferred from the host storage manager on the host device to the secure memory device through an open channel step . The application may transfer this content by calling one of the APIs from the subgroup of APIs exposed in step of . The protected content access manager will access the CEK for the storage location and direct the peripheral device crypto engine to encrypt the content using the CEK and the crypto engine library step . The protected content access manager will then store the encrypted protected content in the appropriate storage location step .

If in step the peripheral device SDK determines that a secure channel should be used the peripheral device SDK will receive the content from the application through one of the APIs in the subgroup of exposed APIs and direct the SDK crypto engine to encrypt the protected content within the host device using the session key and the appropriate cryptographic scheme step . In step the encrypted content will be transferred from the host storage manager on the host device to the secure memory device through a secure channel . The peripheral device crypto engine will then decrypt the transferred protected content in the secure memory device and the crypto engine library step .

In step the protected content access manager will access the CEK for the storage location where the protected content is to be stored and direct the peripheral device crypto engine to encrypt the content using the CEK and the crypto engine library . The protected content access manager will then store the encrypted protected content in the appropriate storage location step .

The protected content access manager accesses the permissions associated with the location of the protected content including the CEK and the session key step . The secure content access manager then accesses the protected content from the location in the secure memory device step and directs the peripheral device crypto engine to decrypt the content using the CEK and the crypto engine library step .

In step the protected content access manager then determines whether the protected content should be transferred to the host storage manager on the host device using a secure channel. If the session key accessed in step indicates that the protected content should be transferred using an open channel the protected content access manager will transfer the content to the host storage manager on the host device through the open channel step .

If in step the protected content access manager determines that the protected content should be transferred to the host storage manager on the host device using a secure channel the protected content access manager will direct the peripheral device crypto engine to encrypt the protected content within the secure memory device using the session key step . The protected content access manager will then transfer the encrypted protected content to the host storage manager on the host device through the secure channel step . Once the protected content is transferred the SDK crypt library will be used to decrypt the protected content using the same session key step .

After the protected content is successfully transferred step and step and decrypted if necessary step the application will receive the requested protected content step . The application will receive the requested protected content using one of the APIs from the subgroup of APIs exposed in step of .

If the task is not yet complete while the task request is performed step the peripheral device SDK security layer checks to see if the application has been registered for the amount of time indicated in the internal registration table for the time out period step . If the time out period has passed the peripheral device SDK security layer will clean the registration table of any information associated with the application step . The peripheral device SDK security layer will then request re authentication of the application step . An authentication process similar to can be used for re authentication of application . The peripheral device SDK security layer will determine if the re authentication was successful step . If re authentication is successful the task will continue to be performed step . If the re authentication is unsuccessful the peripheral device SDK security layer will unregister the application from the internal registration table by calling the appropriate API such as uchar UnRegisterApplication char AppID step . This API will unregister the application by removing the corresponding application ID from the internal registration table . The process of performing the task will then end step .

If in step the peripheral device SDK security layer determines that the time out period in the internal registration table has not passed the peripheral device SDK security layer will continue performing the task request in step .

The foregoing detailed description of various embodiments is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. The foregoing description is not intended to thereby limit the scope of the invention as recited in claims appended hereto.

