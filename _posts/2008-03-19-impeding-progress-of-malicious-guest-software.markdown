---

title: Impeding progress of malicious guest software
abstract: One embodiment of the present invention is a method of operating a virtualization system, the method including: (a) instantiating a virtualization system on an underlying hardware machine, the virtualization system exposing a virtual machine in which multiple execution contexts of a guest execute; (b) monitoring the execution contexts from the virtualization system; and (c) selectively impeding computational progress of a particular one of the execution contexts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08763115&OS=08763115&RS=08763115
owner: VMware, Inc.
number: 08763115
owner_city: Palo Alto
owner_country: US
publication_date: 20080319
---
This application claims benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 60 954 733 filed Aug. 8 2007.

The vulnerability of computer systems configurations software information codings and protocols to unauthorized access or use is problematic. In general these vulnerabilities can range from minor annoyances to national security risks. Automated tools facilitate probing of systems and discovering vulnerable systems and configurations. Once vulnerabilities are identified exploits often embodied as computer viruses worms trojans spyware rootkits and or other malicious forms of code can be globally disseminated and rapidly employed.

In recognition of threats posed by such vulnerabilities methods have been developed to identify malicious software in use in media or in transit. Indeed persons of skill in the art will appreciate a broad range of existing methods including signature and or behavior based detection methods employed in commercially available anti virus and or intrusion detection prevention systems.

For at least some systems it can useful to terminate isolate or otherwise mitigate operation of malicious code however identified. However many of the tools and facilities that might provide a method for terminating isolating or mitigating malicious code are themselves subject to compromise. For example if an operating system or an antivirus intrusion detection facility is itself compromised it may be unrealistic to expect the compromised system facility to reliably interdict malicious code even if an exploit is successfully identified. Indeed a common strategy of many exploits after gaining privileged access is to disable or otherwise subvert the very systems that are designed to protect against them.

Embodiments of the present invention include methods systems apparati computer program products and other tangible realizations of techniques for selectively impeding progress of malicious software using facilities of a virtualization system. In particular one embodiment of the present invention is a method of operating a virtualization system the method comprising a instantiating a virtualization system on an underlying hardware machine the virtualization system exposing a virtual machine in which multiple execution contexts of a guest execute b monitoring the execution contexts from the virtualization system and c selectively impeding computational progress of a particular one of the execution contexts.

One or more embodiments of the present invention include methods for selectively impeding progress of malicious software. In some embodiments methods are employed to interdict malicious software that is identified whether detected or merely suspected using anti malware techniques. In particular in accordance with one or more embodiments of the present invention it is possible to selectively impede from behind a virtualization barrier progress of certain execution contexts that would otherwise execute within a virtual machine. Typically such execution contexts often referenced in the art as processes threads or tasks correspond to an application or service that can be monitored for indicia of maliciousness or which can be presumed malicious until otherwise qualified. Accordingly some embodiments of the present invention can in general be employed to impede progress of malicious software without regard to how such malicious software is identified.

For the most part one or more embodiments of the present invention for impeding progress operate at or from a virtualization layer e.g. within a virtual machine monitor or hypervisor and in many embodiments do not require cooperation or support from a guest operating system running within a virtual machine. This independence can be useful when as is often the case an operating system is or may be compromised by the malicious software itself or via a complementary attack vector.

Although one or more embodiments of the present invention are described in an overall context that can often include anti virus anti spyware intrusion detection protection or other anti malware systems or techniques it is important recognize that one or more embodiments of the present invention do not presuppose any particular anti malware system or technique. Indeed one or more embodiments of the present invention may be implemented in software systems or computer program products that do not themselves provide malware detection. In such embodiments an interdiction mechanism or facility for a separate anti malware system e.g. via an application programming interface API can be provided. Alternatively embodiments of the present invention may be integrated or cooperative with malware detection that operates behind a virtualization barrier. Thus some embodiments are implemented in software that implements the virtualization system itself or in software that implements an operating system that exposes and isolates individual virtual machines. In general one or more embodiments of the present invention may be used in conjunction with conventional or hereafter developed anti malware systems.

Several illustrative embodiments of the present invention are described herein. In general the described embodiments may be employed individually or in combination in a given implementation. The embodiments will be understood both in terms of general strategies such as selective alteration of virtual machine operation modifications to code and or control flows or resource restrictions that target a particular execution context and based on specific implementations.

For example in some embodiments virtual machine operations may be selectively altered to supply a fault trap or interrupt under circumstances in which faithful emulation of a particular physical machine would not otherwise dictate. Note that the configuration of any particular physical machine virtualized may but need not precisely correspond to an underlying physical hardware configuration on which the virtualization system executes. Selective alterations may interdict transitions e.g. based on an otherwise valid system call between user and kernel modes of virtual machine emulation. In some embodiments behavior of a virtual machine may be selectively altered to supply a guest computation with a succession of events e.g. timer interrupts not dictated by faithful emulation of the machine virtualized but rather selected to cause the guest to deschedule or deprioritize computations of a particular execution context. In some embodiments page table entries are selectively modified to preclude or impede a particular execution context from reading writing or executing from an otherwise mapped memory page. In some embodiments the instruction sequences actually executed for a particular execution context are altered. Typically such alternations can be made in the virtualization system e.g. using a binary translation facility to effect the desired changes to code semantics or control flows.

For concreteness embodiments based on facilities terminology and exploits typical of certain processor architectures operating systems virtualization systems and network protocols and or services are described. For example conventional processor and operating system features mechanisms and constructs typical of microprocessors and software available from Intel Corporation and Microsoft Corporation provide a useful descriptive context for our techniques. That said embodiments of the present invention are general to a wide variety of processor and system architectures including both single and multi processor architectures based on any of a variety of instruction set architectures to numerous operating system implementations as well as to computations that need not include or be coordinated by a conventional operating system.

Similarly although embodiments of the present invention are illustrated largely in the context of virtualization systems that support execution of one or more operating system instances persons of ordinary skill in the art will recognize that the boundaries between an operating system and a virtualization system may in some cases be blurred. More specifically based on the description herein persons of ordinary skill in the art will appreciate embodiments in which an operating system includes virtualization features or in which a virtualization system provides some or all of the facilities usually associated with an operating system.

Accordingly in view of the foregoing and without limitation on the range of underlying processor hardware or system architectures operating systems or virtualization techniques that may be employed in embodiments of the present invention based on these embodiments and on the claims that follow persons of ordinary skill in the art will appreciate a broad range of suitable implementations and embodiments.

As on a conventional hardware computer platform guest operating system coordinates execution sequences of instructions on one or more processors or CPUs helps to maintain memory management and or mapping information e.g. virtual to physical page mappings and manages devices of an underlying computational machine. Together the operating system and underlying computational machine e.g. guest operating system and VM of virtual computer in the illustrated configuration manage context switches amongst various execution contexts based on priority data or instruction memory access stalls input output events explicit code directives etc. Numerous techniques and designs both hardware and software for scheduling and performing context switches in multitasking multithreaded systems are known and will be understood by persons of ordinary skill in the art. However in each case the identity of at least a current execution context is part of the observable state of the computational machine or in the illustration of of VM .

From the perspective of operating system and the individual execution contexts thereof exposed VM appears to be and indeed behaves like a conventional hardware computer platform executing instruction sequences and presenting an apparent processor and memory state. Indeed in some embodiments of virtualization system the interface presented by VM may be nearly indistinguishable from a conventional hardware computer platform. However unlike a conventional hardware computer platform virtualization system itself manages underlying hardware resources e.g. without limitation CPUs memory devices and storage and exposes virtual resources e.g. virtual processor s vMEM virtual devices and virtual storage rather than the underlying resources themselves to guest computations such as guest operating system and any applications services executing therewith. In general the characteristics and configurations of an exposed virtual machine need not match those of underlying hardware resources although in many implementations a correspondence between instruction set architectures of exposed virtual processors and underlying hardware CPUs may be desirable.

Although particular virtualization strategies designs are described herein virtualization system is representative of a wide variety of designs and implementations in which underlying hardware resources are presented to software typically to operating system software and or applications as virtualized instances of computational systems that may or may not precisely correspond to the underlying physical hardware.

Virtualization systems are well known in the art and include commercial implementations such as VMware ESX Server VMware Server and VMware Workstation available from VMware Inc. Palo Alto Calif. operating systems with virtualization support such as Microsoft Virtual Server 2005 and open source implementations such as those available from XenSource Inc. Accordingly persons of ordinary skill in the art will appreciate the described embodiments for selectively impeding progress of a targeted computation in the context of a substantial existing body of virtual machine technology.

Typically virtual resources of an exposed virtual machine are presented to a guest computation using mapping and or emulation techniques. In general some interface is provided between the guest software and the various hardware components and devices in the underlying hardware platform. This interface may include one or more software components and or layers possibly including one or more software components known in the field of virtual machine technology as virtual machine monitors VMMs hypervisors or virtualization kernels. For purposes of illustration only and without limitation VMM layer is illustrated in which the operative mappings and or emulations will typically be performed. In the description that follows certain enhancements or alterations are described that may be made to VMM and or VM operation to selectively impede computational progress of a targeted execution context.

These and other embodiments will be understood with reference to the description that follows. The following describes embodiments of the present invention for selectively impeding computational progress of a targeted context executing in connection with a virtual machine.

Each virtual CPU vCPU typically has its own active context and at any given time an execution context e.g. current context will be current and state of at least one vCPU corresponds thereto. In particular register states instruction pointer state memory address translation data structures etc. presented by VM are those appropriate to the current state of current context . Therefore instruction sequences including sequences of user code and system calls appropriate to current context are executed on VM and ordinarily result in progress of a computation associated with current context . In particular individual instructions of instruction sequence are ordinarily executed and result in updates to register state of exposed vCPU . Control flow instructions affect call return stacks and load store instructions affect buffer and vMEM states as well as memory address translation data structures including page table states translation lookaside buffer TLB states etc that reside in memory exposed as vMEM . Input output operations affect the state of exposed vDEVs and typically transfer data through buffers in memory exposed as vMEM .

As is typical in the art switches between execution contexts are managed or initiated by operating system based on desired multitasking and scheduling behavior and based on events such execution and or memory access stalls and interrupts or faults supplied by VM . Context switch handling is well understood in the art but typically includes writing back some state corresponding to a switched out context e.g. register state of a processor current instruction pointer stack pointer etc. to a backing store and loading from such a backing store e.g. memory at least some corresponding to a switched in context. Of course in some processor implementations architectural techniques including e.g. large onboard register sets with context selectable subsets and simultaneous multithreading techniques may facilitate lightweight context switches in which overheads associated with transfers to and from a backing store can be minimized. Depending on the implementation VM particularly exposed vCPU may leverage similar facilities including those supported by underlying hardware.

In any case a switch between execution contexts typically results in some observable change in architectural state of the processor whether implemented as a hardware processor or as in as vCPU . For example in a processor conforming to the Intel IA 32 microprocessor architecture states of certain registers e.g. Control Register 3 CR3 also known as the Page Table Base Register PTBR and the Local Descriptor Table Register LDTR which contains the address in memory of the Local Descriptor Table Register LDT can be expected to change in correspondence with a context switch. As a result contents of the CR3 register are often used in IA 32 architectures as a process id tracking mechanism. Of course other instruction set architectures and implementations may provide other facilities suitable facilities for tracking context switches and based on the description herein persons of ordinary skill in the art will appreciate suitable adaptations. For example some architectures expose an explicit address space identifier sometimes called an ASID which may be employed in a manner similar to that described above with respect to the CR3 register of IA 32 architectures. Similarly a guest operating system may use its own identifier for a context e.g. a process identifier PID . Accordingly in some embodiments in accordance with the present invention a virtualization system may read such an identifier directly from guest kernel memory.

Recognizing the variety of alternative mechanisms by which a processor and or operating system may maintain context identifiers embodiments of the present invention are described with generality. Accordingly in the illustration of VM exposes register s in or via which a context or process ID PID is encoded or may be referenced e.g. using CR3 PTBR LDTR ASID or PID states etc. for corresponding vCPUs. Note that despite the use here and elsewhere of the shorthand PID nothing herein shall be construed as limiting embodiments to mechanisms for context identification that rely on a guest operating system support.

In illustrated virtualization system VMM exposes resources of hardware machine as virtual machine VM . For simplicity of illustration only a single virtual machine is illustrated. In general VMM manages utilization of underlying hardware structures and states typically through a combination of direct execution selective binary translation mapping and or emulation techniques. When possible it can be desirable to directly execute code that is scheduled for execution on a virtual machine e.g. vCPU on an underlying hardware processor e.g. CPUs . However for at least some instruction set architectures binary translation or emulation of at least certain code and or instructions may be necessary. Similarly it can be desirable for memory accesses performed by code executing on the virtual machine to efficiently map to locations in underlying hardware memory e.g. MEM using memory management constructs such a page tables and translation lookaside buffers TLBs exposed to guest software as part of a virtual machine but maintained coherently with memory management facilities of underlying hardware.

Typically both the internals of any direct execution and or binary translation mechanism and the internals of any segmentation memory management virtualization mechanisms will be hidden from guest computations. Accordingly a virtualization barrier is illustrated in to mark a somewhat arbitrary boundary between exposed and therefore visible states functionality and constructs of VM and those states functionality and constructs of VMM and underlying hardware that are hidden from guest computations.

Of course a number of significant practical challenges exist for virtualization system implementations that seek to directly execute code and coherently map underlying physical memory particularly for virtualization of processors that implement the ubiquitous x86 or IA 32 instruction set architecture. In particular practical implementations must typically deal with instruction sets that include instructions sometimes called non virtualizable instructions that behave differently depending on an execution mode. Classic examples include instructions such as the IRET and PUSHF instructions implemented in x86 processors which behave differently based on a privilege level. Another set of practical challenges involves implementations of segmented architectures that include segment registers which are used to help manage and provide protection for a memory address space. In particular semantics of certain IA 32 specific segment operations lead to reversibility challenges that are described and addressed in the art. While elegant solutions to these problems can be non trivial and virtualization system embodiments in accordance with the present invention may build upon such solutions embodiments of the present invention relate more directly to selective alteration of virtual machine behavior for targeted execution contexts.

Therefore certain aspects of virtualization system implementations are summarized and certain more detailed descriptions of specific implementations are incorporated herein by reference from a U.S. Pat. No. 6 397 242 to Devine Bugnion and Rosenblum describes methods for managing a mix of directly executable code and code for which binary translation may be performed b U.S. Pat. No. 6 704 925 to Bugnion which among other things describes implementation of a dynamic binary translator mechanism and methods for maintaining coherence of a translation cache c U.S. Pat. No. 6 785 886 to Lim Le and Bugnion which among other things describes methods for shadowing segment descriptors in a VMM implementation and maintaining backmaps to address segment reversibility challenges and d U.S. Pat. No. 7 222 221 to Agesen Subrahmanyam and Adams which among other things describes methods for maintaining shadow page tables in a virtualization system and for maintaining coherence between related memory management data structures a VM a VMM and underlying hardware. U.S. Pat. Nos. 6 397 242 6 704 925 6 785 886 and 7 222 221 are therefore each incorporated herein by reference and persons of ordinary skill in the art will appreciate based on the description herein virtualization system implementations that build upon code execution translation methods and or segment memory management virtualization methods described in detail in any of the incorporated patents.

Notwithstanding the foregoing persons of ordinary skill in the art will readily understand embodiments of the present invention with reference to a more simplified view of VMM operations presented in . For example in the illustration of VMM provides selective code execution facilities using any suitable mechanism including but not limited to those described in the above incorporated patents . In general selective code execution facilities allow certain code to execute directly on underlying hardware in furtherance of the computation executing on exposed vCPU while supporting at least some method e.g. a binary translation method hardware assisted virtualization or other trap and emulate methods etc. for executing alternative or modified instruction sequences when needed or when desirable. In general hardware assisted virtualization methods include those extensions to 32 bit and 64 bit x86 architecture commonly known as IVT Intel Virtualization Technology and AMD V AMD Virtualization which provide hardware support for trap and emulate methods whereby a VMM may specify those events that will cause the hardware to exit guest execution and trap into the VMM.

Apart from embodiments of the present invention the availability of a binary translation for certain instructions or code blocks facilitates use of an efficient direct execution path for most code while ensuring that non virtualizable instructions or code blocks can be handled in a way that is faithful to the function semantics of the original code. However relative to embodiments of the present invention selective code execution facilities whether supported using binary translation hardware assisted trap and emulate methods or otherwise can be adapted to provide a method for selectively altering the behavior of VM for a targeted execution context. In particular some embodiments employ facilities of a binary translation emulation or other facility to replace original code sequences or individual instructions that would ordinarily be executed in connection with current context with code that need not and indeed purposefully may not faithfully replicate the function semantics of the original code.

Accordingly as illustrated in VMM is configured to monitor some VM construct illustrated as indication for correspondence with an execution context that has been identified as malicious. For example in embodiments in which VM virtualizes an IA 32 processor architecture VMM can be configured to monitor the exposed CR3 register construct for a process id PID match with that of a context identified as malicious. On such a match VMM may choose not to directly execute certain instructions or code or for that matter even faithfully replicate the function semantics of the original code when the identified execution context is active. Instead VMM may direct selective code execution facility to execute alternative code that 

In a similar way mapping shadowing and tracing mechanisms employed by VMM to efficiently handle segmentation and memory management expose a VM specific set of segment register states TLB states and page table hierarchies while mapping memory accesses and paging operations to underlying states and locations in memory . As with the selective code execution facilities described above mapping shadowing and tracing mechanisms are typically used to faithfully present virtual and physical address spaces consistent with the machine virtualized. However in accordance with one or more embodiments of the present invention the similar facilities may be used to alter the virtualization of exposed memory and selectively impede a particular execution context.

For example as illustrated in VMM is configured to monitor some VM construct e.g. indication such as exposed CR3 or page table Base Register PTBR for correspondence with an execution context that has been identified as malicious. Based on a PID match or other correspondence VMM directs mapping shadowing and tracing mechanisms to alter memory mappings or tracing behavior for execution context . In this way VMM may 

In each case monitoring and selective alteration of VM behavior are performed from behind virtualization barrier and may be hidden from both guest operating system and the affected execution context e.g. current context . Building on the foregoing illustration of a suitable virtualization system infrastructure a few strategies for selectively impeding progress of a targeted execution context are described.

As previously described virtualization software can observe switches between guest contexts e.g. based on some state of VM . Accordingly VMM can determine when a particular execution context has been scheduled by the guest OS and take action to impede its progress if desired. As previously described embodiments of the present invention do not presuppose any particular anti malware system or technique for identifying that a particular execution context is malicious. Indeed based on the description herein persons of ordinary skill in the art will recognize the general applicability of our techniques to a broad range of anti malware techniques systems and strategies including those hereafter developed. Therefore in the illustrations that follow embodiments are described for selectively impeding progress of an identified context apart from any particular mechanism for identifying a context as malicious.

In general embodiments of the present invention described herein may be used individually or in combination e.g. to increase their effectiveness. Some embodiments may be applicable only in certain situations such as when the malicious context is executing in guest user mode or guest kernel mode while others may be more generally applicable.

In some embodiments in accordance with the present invention a virtualization system is configured to selectively introduce faults traps interrupts or other events into a context that is identified as malicious. For example an illegal instruction fault can be generated by the virtualization system regardless of the actual validity of the instruction being executed by for the malicious context. illustrates an exemplary scenario in which a guest computation e.g. guest operating system and various contexts thereof execute on VM which is exposed from underlying hardware resources by VMM . Based on a context switch which may be triggered in any of the usual ways e.g. based on operating system scheduling control flow in the current context page fault interrupt etc. relevant states of a current context e.g. registers call stack etc. are saved and those of another context are restored. In the course of the context switch states of virtual control registers implemented by VM will be updated.

For example in a virtualization of an IA 32 type processor architecture an architecturally defined control register such as the CR0 register will contain a task switch flag and a CR3 register will identify the location of a page table base register PTBR that is associated with the new context. Therefore by monitoring the state of these exposed architecturally defined features VMM may observe the context switches and compare an identifier or attribute of the new current context against an encoding of identifiers or attributes for contexts that are identified as malicious. On a match VMM may supply a fault trap interrupt or other event irrespective of whether the machine as exposed VM would ordinarily do so in the course of a faithful emulation of the particular hardware machine virtualized. For example as suggested above VMM may generate and supply an illegal instruction fault even though the corresponding instruction is in fact perfectly legal. If the malicious context is running in guest user mode the supplied fault will typically cause guest operating system to terminate the context in which the illegal instruction was executed. Similarly other types of fault or exceptions may be generated depending on the particular processor architecture to achieve similar results.

As before embodiments of the present invention do not presuppose any particular anti malware system or technique for identifying that a particular execution context is malicious. Accordingly the exemplary embodiment of illustrates a variety of possible sources for identifiers e.g. PIDs or attributes that are used to match a current context. For example traditional anti virus software executing in conjunction with guest operating system as well as virtualization system supported e.g. VMM resident anti malware techniques and even hardware based mechanisms may be employed to generate appropriate identifiers or attributes for comparison against a corresponding identifier or attribute of the current context.

VMM may also selectively alter the way it handles system calls on behalf of an execution context which based on a match e.g. is considered to be malicious. As described above and as now illustrated relative to selective code execution facilities of a VMM provide a mechanism for selectively altering the instruction sequences actually executed on underlying hardware in ways not dictated by faithful emulation of a physical machine.

Using such facilities VMM may prevent a malicious context from successfully performing system calls. For example based on a match VMM may trigger an interdiction interference mode for binary translation in which the virtualization software intercepts at least some system calls. Ordinarily system calls transition an execution sequence of instructions of the current context from user mode to kernel mode. Unfettered access by malicious code to kernel operations may be particularly problematic.

Accordingly rather than allow a malicious context to invoke the specified guest kernel operation VMM may simply cause the system call to fail immediately. A typical system call interface defines some register or memory location to hold a return status value. Therefore rather than performing the operations normally associated with faithful emulation of the virtualized hardware processor selective code execution facilities of VMM may alter the instruction sequences actually supplied for execution on an underlying CPU to instead execute an instruction sequence that sets the return status to a documented error code value e.g. EINVAL in Linux. Alternatively the VMM can cause a different system call to be invoked e.g. by altering the system call number specified by the malicious context. For example with a Linux guest OS the system call number can be changed to invoke the  exit system call causing the malicious context to terminate as if it had exited voluntarily.

Similarly VMM may modify code or control flow of an execution context which based on match is considered to be malicious. In general VMM may overwrite patch or otherwise modify binary code that would normally be executed for the current context. For example particular instructions can be overwritten with nop opcodes thereby neutering actual code that would ordinarily be executed by the malicious context. Similarly the control flows of the malicious context can be changed by modifying the destination addresses of branches jumps or return instructions. Alternatively VMM can directly warp the program counter associated with a guest context causing it to resume in some benign or controlled code region or terminate.

In addition or as an alternative to embodiments that are based on selectively altering the code that would ordinarily be executed by the virtualization system some embodiments now illustrated with reference to selectively alter memory mappings maintained by VMM . For example based on a current context match with some identifier or attribute for a malicious context VMM may manipulate the page tables associated with that context in a way that alters or limits execution behaviors ordinarily associated with faithful emulation of the machine virtualized.

In particular VMM can modify memory address mappings maintained in page tables TLB entries etc. illustrated collectively as exposed shadow page tables and TLBs to deny the malicious context the ability to read write or execute particular pages of memory. For example guest virtual pages that are mapped using page table and or TLB entries maintained for the current context can be unmapped remapped or protected by modifying the page table entries maintained by guest operating system and exposed as part of VM by VMM . Alternatively these mappings can be similarly manipulated by modifying the shadow page tables maintained by the virtualization layer which are not exposed or visible to guest operating system and the execution contexts thereof. In either case memory address mappings e.g. mappings are affected.

Behavior of the exposed memory vMEM can be selectively altered in a variety of ways that may prove useful in impeding progress of the malicious context. For example if desirable sensitive memory targets that would normally be accessed in the course of execution of the malicious context can be shielded spoofed or redirected. As a result malicious updates accesses to sensitive in memory state may avoided or subverted. In some cases alterations may be entirely transparent and not visible to the malicious context. In some cases alterations to memory mapping information may be designed to trigger spurious faults which are returned to the malicious context.

Referring to another progress impeding technique that may be employed by VMM involves delivery of a burst of timer interrupts to the processor of VM on which the malicious context is scheduled. Most guest operating systems use timer interrupts to perform statistical process accounting charging the context that is currently scheduled for consuming a whole timer tick s worth of processor time. Therefore by purposefully supplying the appropriate processor with a series of timer interrupts in quick succession VM can trick guest operating system into believing that the malicious context has consumed a large amount of processor time when in reality it has consumed very little. As before the malicious execution context is selectively targeted based on a match .

Typically based on the burst of timer interrupts guest operating system will quickly deschedule the malicious context which will appear to have exhausted its scheduling quantum. Guest operating system will then preferentially schedule other non malicious contexts. By selectively supplying bursts of timer interrupts to contexts that have been identified as malicious VMM distorts the operating system s own scheduling mechanism in a way that selectively deprives the malicious contexts of processor cycles.

Alternatively VMM may simply deschedule execution of VM or some of its virtual CPUs when a malicious context is scheduled by guest operating system for execution on VM . In some cases VM may impede progress of the malicious context by infrequently scheduling VM computations for execution and or by allowing such computations to run only for a small fraction of real time e.g. by giving VM a very low scheduling priority by placing a vCPU or underlying hardware in a reduced level power management mode by reducing operating frequency voltage or by adjusting other scheduling parameters to reduce CPU consumption . As before the operation of the virtualization system is selectively altered based on a match and targets the malicious guest by effectively depriving it of processor cycles.

In addition to processor cycles other resources normally delivered to an execution context may be selectively distorted by VMM based on an identifier attribute match . For example VMM may choose to artificially delay I O operations issued from a malicious context. In general selective execution facilities of VMM can be employed for this selective alteration of behavior as well.

The virtualization software interposes on I O operations and can introduce additional delays to slow down the malicious context. For example the completion interrupt associated with a guest network write and normally supplied to a vCPU of the exposed VM can be deliberately delayed making it appear to the malicious context as if the virtual network were extremely slow.

Based on the foregoing persons of ordinary skill in the art will appreciate a variety of strategies by which a virtualization system can monitor and selectively alter virtual machine behavior for a particular execution context. Typically the selective alterations are performed from behind a virtualization barrier and may be hidden from both the guest operating system and the affected execution context. In general the described embodiments may be exploited in a variety of virtualization system designs including those now reviewed.

As is well known in art a virtual machine VM is a software abstraction a virtualization of an actual physical computer system. illustrate aspects of embodiments of the present invention for selectively impeding progress of malicious contexts. In describing embodiments of the present invention certain aspects of more complete virtualization system implementations have been abstracted. To facilitate an understanding of the broad applicability of embodiments of the present invention a few examples of specific virtualization system designs and variations thereon are described.

In general in most virtualization system designs some interface is provided between guest software within a VM and the various hardware components and devices in the underlying hardware platform. This interface which can generally be termed virtualization software may include one or more software components and or layers possibly including one or more of the software components known in the field of virtual machine technology as virtual machine monitors VMMs hypervisors or virtualization kernels. Because virtualization terminology has evolved over time and has not yet become fully standardized these terms when used in the art do not always provide clear distinctions between the software layers and components to which they refer. For example the term hypervisor is often used to describe both a VMM and a kernel together either as separate but cooperating components or with one or more VMMs incorporated wholly or partially into the kernel itself however the term hypervisor is sometimes used instead to mean some variant of a VMM alone which interfaces with some other software layer s or component s to support the virtualization. Moreover in some systems some virtualization code is included in at least one superior VM to facilitate the operations of other VMs. Furthermore specific software support for VMs is sometimes included in the host OS itself. Unless otherwise indicated embodiments of the present invention may be used and or implemented in or in conjunction with virtualized computer systems having any type or configuration of virtualization software.

In view of the above and without limitation an interface usually exists between a VM and the underlying platform which is responsible for actually executing VM issued instructions and transferring data to and from the memory and storage devices or underlying hardware. Subject to the foregoing certain commercially available virtualization systems employ a virtual machine monitor VMM in this role. A VMM is usually implemented as a thin piece of software that runs directly on top of a host or directly on the hardware and virtualizes at least some of the resources of the physical host machine. The interface exported to the VM is then the same as the hardware interface of a physical machine. In some cases the interface largely corresponds to the architecture resources and device complements of the underlying physical hardware however in other cases it need not.

Although the VM and thus applications executing in the VM and their users cannot usually detect the presence of the VMM the VMM and the VM may be viewed as together forming a single virtual computer. They are shown and described herein as separate components for the sake of clarity and to emphasize the virtual machine abstraction achieved. However the boundary between VM and VMM is somewhat arbitrary. For example while various virtualized hardware components such as virtual CPU s virtual memory virtual disks and virtual device s including virtual I O devices can be presented as part of previously described VMs see in some virtualization system implementations these components are at least partially implemented as constructs or emulations exposed to a VM by the VMM. One advantage of such an arrangement is that the VMM may be set up to expose generic devices which facilitate VM migration and hardware platform independence. In general such functionality may be said to exist in the VM or the VMM.

It should be noted that while VMMs can be viewed as executing on underlying system hardware many implementations based on the basic abstraction may be implemented. In particular some implementations of VMMs and associated virtual machines execute in coordination with a kernel that itself executes on underlying system hardware while other implementations are hosted by an operating system executing on the underlying system hardware and VMMs and associated virtual machines execute in coordination with the host operating system. Such configurations sometimes described as hosted and non hosted configurations are illustrated in . In the hosted configuration an existing general purpose operating system OS acts as a host operating system that is used to perform certain I O operations. In the non hosted configuration a kernel customized to support virtual computers takes the place of the conventional operating system.

Embodiments of the present invention for selectively impeding progress of malicious guest computations may build on systems of either configuration. Accordingly in view of the variations two exemplary virtualization system configurations are summarized and based on the preceding description persons of ordinary skill in the art will appreciate suitable hosted and non hosted embodiments of the present invention.

Different systems may implement virtualization to different degrees virtualization generally relates to a spectrum of definitions rather than to a bright line and often reflects a design choice in respect to a trade off between speed and efficiency on the one hand and isolation and universality on the other hand. For example full virtualization is sometimes used to denote a system in which no software components of any form are included in the guest other than those that would be found in a non virtualized computer thus the guest OS could be an off the shelf commercially available OS with no components included specifically to support use in a virtualized environment.

In contrast another term which has yet to achieve a universally accepted definition is that of para virtualization. As the name implies a para virtualized system is not fully virtualized but rather the guest is configured in some way to provide certain features that facilitate virtualization. For example the guest in some para virtualized systems is designed to avoid hard to virtualize operations and configurations such as by avoiding certain privileged instructions certain memory address ranges etc. As another example many para virtualized systems include an interface within the guest that enables explicit calls to other components of the virtualization software. For some the term para virtualization implies that the guest OS in particular its kernel is specifically designed to support such an interface. According to this view having for example an off the shelf version of Microsoft Windows XP as the guest OS would not be consistent with the notion of para virtualization. Others define the term para virtualization more broadly to include any guest OS with any code that is specifically intended to provide information directly to the other virtualization software. According to this view loading a module such as a driver designed to communicate with other virtualization components renders the system para virtualized even if the guest OS as such is an off the shelf commercially available OS not specifically designed to support a virtualized computer system.

Unless otherwise indicated or apparent virtualized computer system based realizations of the present invention are not restricted to use in systems with any particular degree of virtualization and is not to be limited to any particular notion of full or partial para virtualization. Furthermore embodiments of techniques described herein for impeding or interdicting system calls can also be applied to hypercalls between a guest and a VMM or hypervisor. In general hypercall mechanisms are part of a well defined interface for transitioning between the guest and the VMM hypervisor while system call mechanisms are part of a well defined interface for transitioning between user mode and kernel mode. Accordingly based on the description herein persons of ordinary skill in the art will appreciate analogous hypercall targeted adaptations of the aforementioned techniques for impeding or interdicting system calls.

While the invention s is are described with reference to various implementations and embodiments it will be understood that these embodiments are illustrative and that the scope of the invention s is not limited to them. In general virtual machines may be implemented consistent with hardware system now existing or hereafter defined. In addition while our description of virtualization techniques has generally assumed that the virtual machines present interfaces consistent with a hardware system persons of ordinary skill in the art will recognize that the techniques described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the present invention implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned.

Although achieving a goal of VMM transparency may be facilitated using techniques of the present invention VMM transparency is not required. Rather the virtualization system techniques for impeding progress of malicious guest software may be incorporated in so called para virtualization systems in which a guest operating system is aware that it is being virtualized and has an explicit interface to the VMM. In such systems functionality analogous to that described herein as a VMM is sometimes referred to as a hypervisor. 

Many variations modifications additions and improvements are possible. For example while strategies for impeding progress of a malicious context have been described in detail herein other techniques and strategies will also be appreciated by persons of ordinary skill in the art based on the description herein. Furthermore while techniques and mechanisms have been described using particular network configurations hardware architectures memory organizations and particular operating system constructs typically IA 32 based architectures systems and Windows or Linux based operating systems as a descriptive framework persons of ordinary skill in the art will recognize that it is straightforward to modify such implementations for use in systems that support other processor instruction set architectures other network or memory configurations and or other operating system constructs.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the invention s .

