---

title: Specifying a configuration for a digital system utilizing dial biasing weights
abstract: In a method of data processing, a database defines a Dial entity and at least one instance of the Dial entity. Each instance of the Dial entity has an input having a plurality of different possible input values and one or more outputs, and each of the plurality of different possible input values has a different associated output value set for the one or more outputs. Each instance of the Dial entity determines a value of at least one of a plurality of configuration latches in a digital system separate from the database. The database also associates with the Dial entity at least one set of biasing weights that, when applied, determines a probability of each instance of the Dial entity having particular ones of the plurality of different possible input values. In response to a call to set the plurality of configuration latches, the database is accessed to apply the at least one set of biasing weights to select one of the plurality of different possible input values for the at least one instance of the Dial entity. The plurality of configuration latches in the digital system are set based upon the output value set for the one or more outputs of the at least one instance of the Dial entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774724&OS=07774724&RS=07774724
owner: International Business Machines Corporation
number: 07774724
owner_city: Armonk
owner_country: US
publication_date: 20080414
---
The present application is a continuation of U.S. patent application Ser. No. 11 345 847 filed on Feb. 2 2006 now U.S. Pat. No. 7 434 193 entitled Method System and Program Product for Specifying a Configuration for a Digital System Utilizing Dial Biasing Weights which is also related to U.S. patent application Ser. No. 10 750 112 which is assigned to the assignee of the present invention and incorporated herein by reference in its entirety.

The present invention relates in general to designing simulating and configuring digital devices modules and systems and in particular to methods and systems for computer aided design simulation and configuration of digital devices modules and systems described by a hardware description language HDL model.

In modern data processing systems especially large server class computer systems the number of latches that must be loaded to configure the system for operation or simulation is increasing dramatically. One reason for the increase in configuration latches is that many chips are being designed to support multiple different configurations and operating modes in order to improve manufacturer profit margins and simplify system design. For example memory controllers commonly require substantial configuration information to properly interface memory cards of different types sizes and operating frequencies.

A second reason for the increase in configuration latches is the ever increasing transistor budget within processors and other integrated circuit chips. Often the additional transistors available within the next generation of chips are devoted to replicated copies of existing functional units in order to improve fault tolerance and parallelism. However because transmission latency via intra chip wiring is not decreasing proportionally to the increase in the operating frequency of functional logic it is generally viewed as undesirable to centralize configuration latches for all similar functional units. Consequently even though all instances of a replicated functional unit are frequently identically configured each instance tends to be designed with its own copy of the configuration latches. Thus configuring an operating parameter having only a few valid values e.g. the ratio between the bus clock frequency and processor clock frequency may involve setting hundreds of configuration latches in a processor chip.

Conventionally configuration latches and their permitted range of values have been specified by error prone paper documentation that is tedious to create and maintain. Compounding the difficulty in maintaining accurate configuration documentation and the effort required to set configuration latches is the fact that different constituencies within a single company e.g. a functional simulation team a laboratory debug team and one or more customer firmware teams often separately develop configuration software from the configuration documentation. As the configuration software is separately developed by each constituency each team may introduce its own errors and employ its own terminology and naming conventions. Consequently the configuration software developed by the different teams is not compatible and cannot easily be shared between the different teams.

In addition to the foregoing shortcomings in the process of developing configuration code conventional configuration software is extremely tedious to code. In particular the vocabulary used to document the various configuration bits is often quite cumbersome. For example in at least some implementations configuration code must specify for each configuration latch bit a full latch name which may include fifty or more ASCII characters. In addition valid binary bit patterns for each group of configuration latches must be individually specified. Moreover handcoding configuration software based upon the error prone documentation may introduce additional errors in the configuration process.

Improved methods systems and program products for specifying the configuration of a digital system are disclosed. According to one method a database defines a Dial entity and at least one instance of the Dial entity. Each instance of the Dial entity has an input having a plurality of different possible input values and one or more outputs and each of the plurality of different possible input values has a different associated output value set for the one or more outputs. Each instance of the Dial entity determines a value of at least one of a plurality of configuration latches in a digital system separate from the database. The database also associates with the Dial entity at least one set of biasing weights that when applied determines a probability of each instance of the Dial entity having particular ones of the plurality of the different possible input values. In response to a call to set the plurality of configuration latches the database is accessed to apply the at least one set of biasing weights to select one of the plurality of different possible input values for the at least one instance of the Dial entity. The plurality of configuration latches in the digital system are set based upon the output value set for the one or more outputs of the at least one instance of the Dial entity.

All objects features and advantages of the present invention will become apparent in the following detailed written description.

The present invention introduces a configuration specification language and associated methods systems and program products for configuring and controlling the setup of a digital system e.g. one or more integrated circuits or a simulation model thereof . In at least one embodiment configuration specifications for signals in the digital system are created in HDL code by the designer responsible for an associated design entity. Thus designers at the front end of the design process which are best able to specify the signal names and associated legal values are responsible for creating the configuration specification. The configuration specification is compiled at model build time together with the HDL describing the digital system to obtain a configuration database that can then be utilized by downstream organizational groups involved in the design simulation and hardware implementation processes.

With reference now to the figures and in particular with reference to there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized for example as a workstation server or mainframe computer.

As illustrated data processing system includes one or more processing nodes which if more than one processing node is implemented are interconnected by node interconnect . Processing nodes may each include one or more processors a local interconnect and a system memory that is accessed via a memory controller . Processors are preferably but not necessarily identical and may comprise a processor within the PowerPC line of processors available from International Business Machines IBM Corporation of Armonk N.Y. In addition to the registers instruction flow logic and execution units utilized to execute program instructions which are generally designated as processor core each of processors also includes an on chip cache hierarchy that is utilized to stage data to the associated processor core from system memories .

Each of processing nodes further includes a respective node controller coupled between local interconnect and node interconnect . Each node controller serves as a local agent for remote processing nodes by performing at least two functions. First each node controller snoops the associated local interconnect and facilitates the transmission of local communication transactions to remote processing nodes . Second each node controller snoops communication transactions on node interconnect and masters relevant communication transactions on the associated local interconnect . Communication on each local interconnect is controlled by an arbiter . Arbiters regulate access to local interconnects based on bus request signals generated by processors and compile coherency responses for snooped communication transactions on local interconnects .

Local interconnect is coupled via mezzanine bus bridge to a mezzanine bus . Mezzanine bus bridge provides both a low latency path through which processors may directly access devices among I O devices and storage devices that are mapped to bus memory and or I O address spaces and a high bandwidth path through which I O devices and storage devices may access system memory . I O devices may include for example a display device a keyboard a graphical pointer and serial and parallel ports for connection to external networks or attached devices. Storage devices may include for example optical or magnetic disks that provide non volatile storage for operating system middleware and application software. In the present embodiment such application software includes an ECAD system which can be utilized to develop verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.

Simulated digital circuit design models created utilizing ECAD system are comprised of at least one and usually many sub units referred to hereinafter as design entities. Referring now to there is illustrated a block diagram representation of an exemplary design entity which may be created utilizing ECAD system . Design entity is defined by a number of components an entity name entity ports and a representation of the function performed by design entity . Each design entity within a given model has a unique entity name not explicitly shown in that is declared in the HDL description of the design entity. Furthermore each design entity typically contains a number of signal interconnections known as ports to signals outside the design entity. These outside signals may be primary input outputs I Os of an overall design or signals connected to other design entities within an overall design.

Typically ports are categorized as belonging to one of three distinct types input ports output ports and bi directional ports. Design entity is depicted as having a number of input ports that convey signals into design entity . Input ports are connected to input signals . In addition design entity includes a number of output ports that convey signals out of design entity . Output ports are connected to a set of output signals . Bi directional ports are utilized to convey signals into and out of design entity . Bi directional ports are in turn connected to a set of bi directional signals . A design entity such as design entity need not contain ports of all three types and in the degenerate case contains no ports at all. To accomplish the connection of entity ports to external signals a mapping technique known as a port map is utilized. A port map not explicitly depicted in consists of a specified correspondence between entity port names and external signals to which the entity is connected. When building a simulation model ECAD software is utilized to connect external signals to appropriate ports of the entity according to a port map specification.

As further illustrated in design entity contains a body section that describes one or more functions performed by design entity . In the case of a digital design body section contains an interconnection of logic gates storage elements etc. in addition to instantiations of other entities. By instantiating an entity within another entity a hierarchical description of an overall design is achieved. For example a microprocessor may contain multiple instances of an identical functional unit. As such the microprocessor itself will often be modeled as a single entity. Within the microprocessor entity multiple instantiations of any duplicated functional entities will be present.

Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.

With reference now to there is illustrated a diagrammatic representation of an exemplary simulation model that may be employed by ECAD system to represent a digital design e.g. an integrated circuit chip or a computer system in a preferred embodiment of the present invention. For visual simplicity and clarity the ports and signals interconnecting the design entities within simulation model have not been explicitly shown.

Simulation model includes a number of hierarchically arranged design entities. As within any simulation model simulation model includes one and only one top level entity encompassing all other entities within simulation model . That is to say top level entity instantiates either directly or indirectly all descendant entities within the digital design. Specifically top level entity directly instantiates i.e. is the direct ancestor of two instances and of the same FiXed point execution Unit FXU entity and a single instance of a Floating Point Unit FPU entity . FXU entity instances having instantiation names FXU and FXU respectively in turn instantiate additional design entities including multiple instantiations of entity A having instantiation names A and A respectively.

Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name which must be unique among all descendants of the direct ancestor entity if any. For example top level entity has a description including an entity name i.e. the TOP preceding the colon and also includes an instantiation name i.e. the TOP following the colon . Within an entity description it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example single instances of entity B and entity C instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However this naming convention is not required by the present invention as shown by FPU entity i.e. the instantiation name is FPU while the entity name is FPU .

The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity provided that all entities instantiated whether singly or multiply have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.

Associated with each design entity instantiation is a so called instantiation identifier . The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top level entity instantiation name. For example the design instantiation identifier of instantiation of entity C within instantiation of FXU entity is TOP.FXU.B.C . This instantiation identifier serves to uniquely identify each instantiation with in a simulation model.

As discussed above a digital design whether realized utilizing physical integrated circuitry or as a software model such as simulation model typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies which employ stand alone configuration software created after a design is realized to load values into the configuration latches the present invention introduces a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design as illustrated in or in one or more external configuration files referenced by the one or more HDL files specifying the digital design as depicted in .

Referring now to there is depicted an exemplary HDL file in this case a VHDL file including embedded configuration statements in accordance with the present invention. In this example HDL file specifies entity A of simulation model and includes three sections of VHDL code namely a port list that specifies ports and signal declarations that specify the signals within body section and a design specification that specifies the logic and functionality of body section . Interspersed within these sections are conventional VHDL comments denoted by an initial double dash . In addition embedded within design specification are one or more configuration specification statements in accordance with the present invention which are collectively denoted by reference numerals and . As shown these configuration specification statements are written in a special comment form beginning with in order to permit a compiler to easily distinguish the configuration specification statements from the conventional HDL code and HDL comments. Configuration specification statements preferably employ a syntax that is insensitive to case and white space.

With reference now to there is illustrated an exemplary HDL file that includes a reference to an external configuration file containing one or more configuration specification statements in accordance with the present invention. As indicated by prime notation HDL file is identical to HDL file in all respects except that configuration specification statements are replaced with one or more and in this case only one configuration file reference statement referencing a separate configuration file containing configuration specification statements .

Configuration file reference statement like the embedded configuration specification statements illustrated in is identified as a configuration statement by the identifier . Configuration file reference statement includes the directive cfg file which instructs the compiler to locate a separate configuration file and the filename of the configuration file i.e. file00 . Configuration files such as configuration file preferably all employ a selected filename extension e.g. .cfg so that they can be easily located organized and managed within the file system employed by data processing system .

As discussed further below with reference to configuration specification statements whether embedded within an HDL file or collected in one or more configuration files are processed by a compiler together with the associated HDL files.

In accordance with a preferred embodiment of the present invention configuration specification statements such as configuration specification statements facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a Dial. A Dial s function is to map between an input value and one or more output values. In general such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently by virtue of their association with particular design entities which all have unique instantiation identifiers Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent many different types of Dials can be defined beginning with a Latch Dial or LDial .

Referring now to there is depicted a representation of an exemplary LDial . In this particular example LDial which has the name bus ratio is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.

As illustrated LDial like all Dials logically has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . That is mapping table specifies a one to one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches each output of LDial logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations each configuration latch is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .

At input LDial receives an enumerated input value i.e. a string among a set of legal values including 2 1 3 1 and 4 1 . The enumerated input value can be provided directly by software e.g. by a software simulator or service processor firmware or can be provided by the output of another Dial as discussed further below with respect to . For each enumerated input value the mapping table of LDial indicates a selected binary value i.e. 0 or 1 for each configuration latch .

With reference now to there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model of which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model of illustrates two properties of Dials namely replication and scope.

Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example in order to instantiate the six instances of LDials illustrated in the designer need only code two LDial configuration specification statements utilizing either of the two techniques illustrated in . That is the designer codes a first LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity A in order to automatically instantiate LDials and within entity A instantiations and respectively. The designer codes a second LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity FXU in order to automatically instantiate LDials and within FXU entity instantiations and respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values different instances of the same Dial can be set to generate different outputs by providing them different inputs.

The scope of a Dial is defined herein as the set of entities to which the Dial can refer in its specification. By convention the scope of a Dial comprises the design entity with which the Dial is associated i.e. the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated and any design entity contained within the associated design entity i.e. the associated design entity and its descendents . Thus a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated but can also specify configuration latches at any lower level of the design hierarchy within its scope. For example LDials and even though associated with FXU entity instantiations and respectively can specify configuration latches within entity C instantiations and respectively.

Referring now to there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of .

As shown simulation model of includes an LDial associated with top level design entity . LDial specifies the signal states of each signal sig which is determined by a respective configuration latch the signal states of each signal sig which is determined by a respective configuration latch the signal state of signal sig which is determined by configuration latch and the signal state of signal sig which is determined by configuration latch . Thus LDial configures the signal states of numerous different signals which are all instantiated at or below the hierarchy level of LDial which is the top level .

As discussed above with respect to LDial is instantiated within top level entity of simulation model by embedding within the HDL file of top level entity a configuration specification statement specifying LDial or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case an exemplary configuration specification statement for LDial is as follows 

The exemplary configuration specification statement given above begins with the keyword LDial which specifies that the type of Dial being declared is an LDial and the Dial name which in this case is bus ratio. Next the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above the signal identifier for each signal is specified hierarchically e.g. FXU.A.SIG for signal relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Several different syntaxes can be employed to specify the signal states. In the example given above signal states are specified in either binary format which specifies a binary constant preceded by the prefix 0b or in hexadecimal format which specifies a hexadecimal constant preceded by the prefix 0x . Although not shown signal states can also be specified in integer format in which case no prefix is employed. For ease of data entry the configuration specification language of ECAD system also preferably supports a concatenated syntax in which one constant value which is automatically extended with leading zeros is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax the mapping table of the configuration specification statement given above can be rewritten as 

Referring now to there is depicted a diagrammatic representation of an Integer Dial IDial in accordance with a preferred embodiment of the present invention. Like an LDial an IDial directly specifies the value loaded into each of one or more configuration latches by indicating within mapping table a correspondence between each input value received at an input and an output value for each output . However unlike LDials which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables the legal input value set of an IDial includes all possible integer values within the bit size of output . Input integer values containing fewer bits than the bit size of output s are right justified and extended with zeros to fill all available bits. Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table mapping table simply indicates the manner in which the integer input value received at input is applied to the one or more outputs .

IDials are ideally suited for applications in which one or more multi bit registers must be initialized and the number of legal values includes most values of the register s . For example if a 4 bit configuration register comprising 4 configuration latches and an 11 bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial the designer would have to explicitly enumerate up to 2input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement 

Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials in many cases it would be inefficient and inconvenient to do so. In particular for hierarchical digital designs such as that illustrated in the use of LDials and or IDials alone would force many Dials to higher levels of the design hierarchy which from an organizational standpoint may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result proper configuration of the configuration latches would require not only significant organizational coordination between design groups but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.

In view of the foregoing the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower level Dials and control of the lower level Dials by one or more higher level Dials. The configuration specification language of the present invention terms a higher level Dial that controls one or more lower level Dials as a Control Dial CDial .

Referring now to there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial like all Dials preferably has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . Unlike LDials and IDials which directly specify configuration latches a CDial does not directly specify configuration latches. Instead a CDial controls one or more other Dials i.e. CDials and or LDials and or IDials logically coupled to CDial in an n way Dial tree in which each lower level Dial forms at least a portion of a branch that ultimately terminates in leaves of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.

In the exemplary embodiment given in CDial receives at input an enumerated input value i.e. a string among a set of legal values including A . . . N . If CDial or an LDial or IDial is a top level Dial i.e. there are no Dials above it in a Dial tree CDial receives the enumerated input value directly from software e.g. simulation software or firmware . Alternatively if CDial forms part of a branch of a dial tree then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input CDial specifies a selected enumerated value or bit value for each connected Dial e.g. Dials and in mapping table . The values in mapping table associated with each output are interpreted by ECAD system in accordance with the type of lower level Dial coupled to the output . That is values specified for LDials and CDials are interpreted as enumerated values while values specified for IDials are interpreted as integer values. With these values each of Dials and ultimately specifies either directly or indirectly the values for one or more configuration latches .

With reference now to there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top level CDial that controls multiple lower level LDials. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of and contains the same configuration latches and associated signals as simulation model of .

As shown simulation model of includes a top level CDial associated with top level design entity . Simulation model further includes four LDials and . LDial which is associated with entity instantiation A controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is a replication of LDial associated with entity instantiation A similarly controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is associated with top level entity controls the signal state of signal sig which is determined by configuration latch . Finally LDial which is associated with entity instantiation FPU controls the signal state of signal sig which is determined by configuration latch . Each of these four LDials is controlled by CDial associated with top level entity .

As discussed above with respect to CDial and each of the four LDials depicted in is instantiated within the associated design entity by embedding a configuration specification statement or a configuration file reference statement pointing to a configuration file containing a configuration specification statement within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in is given below 

By implementing a hierarchical Dial tree in this manner several advantages are realized. First the amount of software code that must be entered is reduced since the automatic replication of LDials within FXU entity instantiations and allows the code specifying LDials to be entered only once. Second the organizational boundaries of the design process are respected by allowing each designer or design team to specify the configuration of signals within the design entity for which he is responsible. Third coding of upper level Dials i.e. CDial is greatly simplified reducing the likelihood of errors. Thus for example the CDial and LDial collection specified immediately above performs the same function as the large LDial specified above with reference to but with much less complexity in any one Dial.

Many Dials for example those utilized to disable a particular design entity in the event an uncorrectable error is detected have a particular input value that the Dial should have in nearly all circumstances. For such Dials the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment a Default value is specified by including default value following the specification of a Dial and prior to the concluding semicolon. For example a default value for a CDial can be given as follows 

The configuration specification language of the present invention also permits control of the time at which particular default values are applied. Control of the application of defaults is important for example in simulating or executing in hardware the boot sequence for an integrated circuit. During the initial stages of the boot sequence the clock signals to different sections of the integrated circuit may be started at different times meaning that latches in different sections of the integrated circuit must be loaded at different times in accordance with the specified Dial default values.

In accordance with the present invention control of the timing of the application of default values is supported through the association of one or more phase identifiers IDs with a default value. Phase IDs are strings that label collections of Dials to which default values should be applied substantially concurrently. Multiple phase IDs may be associated with a particular Dial to promote flexibility. For example in different system configurations the boot sequence for a constituent integrated circuit may be different. Accordingly it may be necessary or desirable to apply a default value to a particular Dial during different phases depending upon the system configuration.

In one exemplary syntax one or more phase IDs e.g. phaseid and phaseid can optionally be specified in a comma delimited list enclosed by parenthesis and following a default declaration in a Dial declaration statement as follows 

The use of default values for Dials is subject to a number of rules. First a default value may be specified for any type of Dial including LDials IDials including those with split outputs and CDials. Default values are preferably not supported for Dial groups which are discussed in the above referenced application . Second if default values are specified for multiple Dials in a multiple level Dial tree only the highest level default value affecting each branch of the Dial tree is applied including that specified for the top level Dial and the remaining default values if any are ignored. Despite this rule it is nevertheless beneficial to specify default values for lower level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated as discussed above. In the event that the combination of default values specified for lower level Dials forming the branches of a Dial tree do not correspond to a legal output value set for a higher level Dial the compiler will flag an error. Third a default value is overridden when a Dial receives an input to actively set the Dial.

By specifying default values for Dials a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition as discussed further below use of default values assists in auditing which Dials have been actively set.

In addition to defining syntax for configuration specification statements specifying Dials the configuration specification language of the present invention supports additional HDL semantic constructs called comments and attribute specification statements. A comment which may have the form 

Attribute specification statements are statements that declare an attribute name and attribute value and associate the attribute name with a particular Dial name. For example an attribute specification statement may have the form 

In accordance with the present invention the configuration specification language may also support bias specification statements. Bias specification statements enable the designer to specify a set of probabilities or biasing weights to be applied to the various Dials in a digital design. As will become apparent such biasing weights can then be utilized in simulation and or lab testing to automatically control the probability that specified Dials are set to particular ones of their legal settings thereby reducing or eliminating the need for designers to communicate Dial setting information to the simulation and laboratory testing teams outside of the testing system.

In one preferred embodiment the configuration specification language of the present invention permits a designer to specify a set of biasing weights for one or more input values of a Dial as integer values. For example for a Dial entity having three legal input values A B and C a set of biasing weights for instances of the Dial entity could be A 10 B 10 and C 20. The enumerated biasing weights are then effectively scaled based upon their cumulative value so that the input value of the Dial instances would be set to value A with a 25 probability to value B with a 25 probability and to value C with a 50 probability in response to an API call.

For enhanced flexibility it is also desirable if multiple different sets of biasing weights are supported. The different sets of biasing weights may be utilized for example to define separate sets of biasing weights for different types of simulation testing and or for simulation and laboratory testing. To simplify reference to the various sets of biasing weights each set of biasing weights may be given a designer assigned name which is unique with respect to other biasing weight set names for the same Dial. In addition it is preferable if the namespace of biasing weights for each Dial supports a special nameless set that is implicitly identified in declaration syntax and API calls by a NULL string parameter.

Those skilled in the art will appreciate that a number of different syntaxes can be employed to specify biasing weights for Dials in accordance with the present invention. Biasing weights can conveniently be enumerated using syntax similar to attribute specification statements particularly when multiple named sets of biasing weights are specified. Alternatively or additionally the syntax for biasing weights can be integrated directly into a Dial declaration statement.

The foregoing exemplary bias specification statement also illustrates multiple ways to specify biasing weights. First an explicit biasing weight can be specified for each legal Dial input value as is provided for the unitsim and nameless sets of biasing weights. Second the designer can specify biasing weights for one or more Dial input values in a set and then specify a single group biasing weight which is enumerated without an associated Dial input value that is applied to the remaining Dial input values that are not explicitly paired with a biasing weight. In other words the group biasing weight is applied to all unspecified Dial input values. For example in the labsim set of biasing weights the 2 1 Dial input value is applied with a 50 probability and the Dial input value is randomly selected from among the other unspecified Dial input values with a 50 probability.

The availability of group bias weights is particularly useful for IDials because for an IDial of any significant size it would be a laborious to specify biasing weights for all possible Dial input values. Thus biasing weights for an IDial such as the following 

Those skilled in the art will recognize that the syntax set forth herein is merely exemplary and that other variations and extensions and features may be employed in accordance with the present invention. For example as noted above the configuration specification language may alternatively or additionally permit biasing weights to be enumerated directly within a Dial declaration statement. For example a nameless set of biasing weights can be specified within the Dial declaration statement of exemplary CDial BusRatio as follows 

As with the defaults discussed above biasing weights can be specified by a designer for multiple Dials in a multiple level Dial tree. However biasing weights are preferably applied for only top level Dials and biasing weights specified for lower level Dials if any are ignored. Despite this rule it is nevertheless beneficial to specify biasing weights for lower level Dials in a Dial tree because the biasing weights may be applied in the event a smaller portion of a digital is independently tested.

Referring now to there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files which include configuration specification statements and or configuration file reference statements and optionally one or more configuration specification reference files . HDL compiler processes HDL file s and configuration specification file s if any beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file s describing a complete simulation model. As HDL compiler processes each HDL file HDL compiler creates markers in the design intermediate files produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.

Thereafter the design intermediate files in memory are processed by a configuration compiler and model build tool to complete the model build process. Model build tool processes design intermediate files into a simulation executable model that when executed models the logical functions of the digital design which may represent for example a portion of an integrated circuit an entire integrated circuit or module or a digital system including multiple integrated circuits or modules. Configuration compiler processes the configuration specification statements marked in design intermediate files and creates from those statements a configuration documentation file and a configuration database .

Configuration documentation file lists in human readable format information describing the Dials associated with the simulation model. The information includes the Dials names their mapping tables the structure of Dial trees if any instance information etc. In addition as noted above configuration documentation file includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a bottom up fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design simulation laboratory hardware evaluation and commercial hardware implementation of the digital design.

Configuration database contains a number of data structures pertaining to Dials. As described in detail below these data structures include Dial data structures describing Dial entities latch data structures and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design i.e. simulation executable model . In a preferred embodiment the configuration values can be specified in terms of either signal states or configuration latch values and the selection of which values are used is user selectable. Configuration database is accessed via Application Programming Interface API routines during simulation of the digital design utilizing simulation executable model and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment the APIs are designed so that only top level Dials i.e. LDials IDials or CDials without a CDial logically above them can be set and all Dial values can be read.

Now that basic types of Dials syntax for their specification and their application have been described a description of an exemplary implementation of configuration database and its use will be provided. To promote understanding of the manner in which particular Dial instantiations or multiple instantiations of a Dial can be accessed in configuration database a nomenclature for Dials within configuration database will be described.

The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity i.e. the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.

Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model e.g. due to replication use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly in a preferred embodiment the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an extended Dial identifier for each Dial within the simulation model.

As an aside it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example conventional VHDL entity naming constructs permit two design entities to share the same entity name entity name. However VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance the entity name is equivalent to the VHDL library name concatenated by a period . to the entity name as declared in the entity declaration. Thus pre pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.

In a preferred embodiment an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields an instantiation identifier field a design entity name and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period . as follows 

In the extended Dial identifier the design entity field contains the entity name of the design entity in which the Dial is instantiated and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers proceeding from the top level entity of the simulation model to the direct ancestor design entity of the given Dial instance with adjacent instance identifiers separated by periods . . Because no design entity can include two Dials of the same name the instantiation identifier is unique for each and every instance of a Dial within the model.

The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier each design entity is in effect given a unique namespace for the Dials associated with that design entity i.e. Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is due to the uniqueness of instantiation identifiers Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However such a naming scheme does not associate Dials with a given design entity. In practice it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.

With an understanding of a preferred nomenclature of Dials reference is now made to which is a diagrammatic representation of an exemplary format for a configuration database created by configuration compiler . In this exemplary embodiment configuration database includes at least four different types of data structures Dial definition data structures DDDS Dial instance data structures DIDS latch data structures and top level pointer array . Configuration database may optionally include additional data structures such as Dial pointer array latch pointer array instance pointer array and other data structures depicted in dashed line illustration which may alternatively be constructed in volatile memory when configuration database is loaded as described further below. Generating these additional data structures only after configuration database is loaded into volatile memory advantageously promotes a more compact configuration database .

A respective Dial definition data structure DDDS is created within configuration database for each Dial or Dial group in the digital system. Preferably only one DDDS is created in configuration database regardless of the number of instantiations of the Dial or Dial group in the digital system. As discussed below information regarding particular instantiations of a Dial described in a DDDS is specified in separate DIDSs .

As shown each DDDS includes a type field denoting the type of Dial. In one embodiment the value set for type field includes G for Dial group I for integer Dial IDial L for latch Dial LDial and C for control Dial CDial . DDDS further includes a name field which specifies the name of the Dial described by DDDS . This field preferably contains the design entity name of the Dial followed by a period . followed by the name of Dial or Dial group given in the configuration specification statement of the Dial or Dial group . The contents of name field correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.

DDDS also includes a mapping table that contains the mapping from the input of the given Dial to its output s if required. For LDials and CDials mapping table specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output mapping table is an empty data structure and is not used. In the case of an IDial with a split output mapping table specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields.

For Dials for which one or more sets of biasing weights are specified by the designer DDDS further includes a bias table that contains one or more sets of biasing weights and associated name s if any. Bias table is preferably used to set only top level Dial instances of any given model. Bias table may further include an identifier e.g. name or NULL string of a currently applied set of biasing weights.

Finally DDDS may include an instance pointer array containing one or more instance pointers pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array facilitates access to multiple instances of a particular Dial or Dial group.

As further illustrated in configuration database contains a DIDS corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS contains a definition field containing a definition pointer pointing to the DDDS of the Dial for which the DIDS describes a particular instance. Definition pointer permits the Dial name Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.

DIDS further includes a parent field that in the case of an IDial CDial or LDial contains a parent pointer pointing to the DIDS of the higher level Dial instance if any having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group parent pointer points to the DIDS of the higher level Dial group if any that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS is a top level Dial and does not belong to any Dial group parent pointer in parent field is a NULL pointer. It should be noted that a Dial can be a top level Dial but still belong to a Dial group. In that case parent pointer is not NULL but rather points to the DIDS of the Dial group containing the top level Dial.

Thus parent fields of the DIDSs in configuration database collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described below the hierarchical information provided by parent fields advantageously enables a determination of the input value of any top level Dial given the configuration values of the configuration latches ultimately controlled by that top level Dial.

Instance name field of DIDS gives the fully qualified instance name of the Dial instance described by DIDS from the top level design entity of the digital design. For Dial instances associated with the top level entity instance name field preferably contains a NULL string.

DIDS may further include a default field a phase ID field and a Dial set field . At compile time configuration compiler preferably initially inserts a default field into at least each DIDS for which the configuration specification statement for the associated Dial has a default specified. Default field stores the specified default value if no default value is specified default field is NULL or is omitted. Configuration compiler subsequently analyzes configuration database utilizing a recursive traversal and removes or set to NULL the default field of any Dial instance that has an ancestor Dial instance having a default. In this manner default values of Dial instances higher in the hierarchy override defaults specified for lower level Dial instances. For each remaining or non NULL default field configuration compiler inserts into the DIDS a phase ID field for storing one or more phase IDs if any associated with the default value. The phase ID s stored within phase ID field may be specified within a Dial definition statement within an HDL file or configuration specification file or may alternatively be supplied by direct manipulation of configuration database by a downstream user as discussed further below with respect to .

As indicated by dashed line notation a Dial set field is preferably inserted within each DIDS in configuration database when configuration database is loaded into volatile memory. Dial set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set.

Finally DIDS includes an output pointer array containing pointers pointing to data structures describing the lower level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically in the case of IDials and LDials output pointers refer to latch data structures corresponding to the configuration latches coupled to the Dial instance. For non split IDials the configuration latch entity referred to by output pointer receives the high order bit of the integer input value and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial output pointers refer to other DIDSs corresponding to the Dial instances controlled by the CDial. For Dial groups output pointers refer to the top level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS .

Configuration database further includes a respective latch data structure for each configuration latch in simulation executable model to which an output of an LDial or IDial is logically coupled. Each latch data structure includes a parent field containing a parent pointer to the DIDS of the LDial or IDial directly controlling the corresponding configuration latch. In addition latch data structure includes a latch name field specifying the hierarchical latch name relative to the entity containing the Dial instantiation identified by parent pointer . For example if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name a.b.c.d.latch latch name field will contain the string d.latch . Prepending contents of an instance name field of the DIDS identified by parent pointer to the contents of a latch name field thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .

Still referring to as noted above configuration database includes top level pointer array and optionally Dial pointer array and latch pointer array . Top level pointer array contains top level pointers that for each top level Dial and each top level Dial group points to an associated DIDS for the top level entity instance. Dial pointer array includes Dial pointers pointing to each DDDS in configuration database to permit indirect access to particular Dial instances through Dial and or entity names. Finally latch pointer array includes latch pointers pointing to each latch data structure within configuration database to permit easy access to all configuration latches.

Once a configuration database is constructed the contents of configuration database can be loaded into volatile memory such as system memory of data processing system of in order to appropriately configure a simulation model for simulation. In general data structures and can be loaded directly into system memory and may optionally be augmented with additional fields as described below. However as noted above if it is desirable for the non volatile image of configuration database to be compact it is helpful to generate additional data structures such as Dial pointer array latch pointer array and instance pointer arrays in the volatile configuration database image in system memory .

Referring now to there is depicted a high level logical flowchart of an exemplary method by which configuration database is expanded within volatile memory of a data processing system such as system memory of data processing system . Because depicts logical steps rather than operational steps it should be understood that many of the steps illustrated in may be performed concurrently or in a different order than that shown.

As illustrated the process begins at block and then proceeds to block which illustrates data processing system copying the existing data structures within configuration database from non volatile storage e.g. disk storage or flash memory into volatile system memory . Next at block a determination is made whether all top level pointers within top level pointer array of configuration database have been processed. If so the process passes to block which is discussed below. If not the process proceeds to block which illustrates selection from top level array of the next top level pointer to be processed.

A determination is then made at block of whether or not parent pointer within the DIDS identified by the selected top level pointer is a NULL pointer. If not which indicates that the DIDS describes a top level Dial belonging to a Dial group the process returns to block indicating that the top level Dial and its associated lower level Dials will be processed when the Dial group to which it belongs is processed.

In response to a determination at block that the parent pointer is a NULL pointer data processing system creates an instance pointer to the DIDS in the instance array of the DDDS to which definition pointer in definition field of DIDS points as depicted at block . Next at block data processing system creates a Dial pointer to the DDDS of the top level Dial within Dial pointer array if the Dial pointer is not redundant. In addition as shown at block data processing system creates a latch pointer within latch pointer array pointing to each latch data structure if any referenced by an output pointer of the DIDS of the top level Dial. As shown at block each branch at each lower level of the Dial tree if any headed by the top level Dial referenced by the selected top level pointer is then processed similarly by performing the functions illustrated at block until a latch data structure terminating that branch is found and processed. The process then returns to block representing the processing of each top level pointer within top level pointer array .

In response to a determination at block that all top level pointers have been processed the process illustrated in proceeds to block . Block illustrates the creation of a Dial set field in each DIDS in the configuration database. As noted above Dial set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set. In addition as depicted at block data processing system creates a latch value field latch set field and set history field in each latch data structure to respectively indicate the current set value of the associated configuration latch to indicate whether or not the configuration latch is currently set by an explicit set command and to indicate whether or not the configuration latch has ever been explicitly set. Although the creation of the four fields indicated at block is illustrated separately from the processing depicted at blocks for purposes of clarity it will be appreciated that it is more efficient to create Dial set field as each DIDS is processed and to create fields and as the latch data structures at the bottom of each Dial tree are reached. The process of loading the configuration database into volatile memory thereafter terminates at block .

With the configuration database loaded into volatile memory a simulation model can be configured and utilized to simulate a digital design through the execution of simulation software. With reference to there is illustrated a block diagram depicting the contents of system memory during a simulation run of a simulation model. As shown system memory includes a simulation model which is a logical representation of the digital design to be simulated as well as software including configuration APIs a simulator and an RTX Run Time eXecutive .

Simulator loads simulation models such as simulation model into system memory . During a simulation run simulator resets clocks and evaluates simulation model via various APIs . In addition simulator reads values in simulation model utilizing GETFAC API and writes values to simulation model utilizing PUTFAC API . Although simulator is implemented in entirely in software it will be appreciated in what follows that the simulator can alternatively be implemented at least partially in hardware.

Configuration APIs comprise software typically written in a high level language are dynamically loaded by simulator as needed include a first API that loads configuration model from non volatile storage and expands it in the manner described above with reference to to provide a memory image of configuration database . Configuration APIs further include additional APIs to access and manipulate configuration database as described in detail below.

RTX controls simulation of simulation models such as simulation model . For example RTX loads test cases to apply to simulation model . In addition RTX delivers a set of API calls to configuration APIs and the APIs provided by simulator to initialize configure and simulate operation of simulation model . During and after simulation RTX also calls configuration APIs and the APIs provided by simulator to check for the correctness of simulation model by accessing various Dials configuration latches counters and other entities within simulation model .

RTX has two modes by which it accesses Dials instantiated within simulation model interactive mode and batch mode. In interactive mode RTX calls a first set of APIs to read from or write to one or more instances of a particular Dial within configuration database . The latch value s obtained by reference to configuration database take immediate effect in simulation model . In batch mode RTX calls a different second set of APIs to read or write instantiations of multiple Dials in configuration database and then make any changes to simulation model at the same time.

In either interactive or batch mode RTX must employ some syntax in its API calls to specify which Dial or Dial group instances within simulation model are to be accessed. Although a number of different syntaxes can be employed including conventional regular expressions employing wildcarding in an illustrative embodiment the syntax utilized to specify Dial or Dial group instances in API calls is similar to the compact expression hereinbefore described. A key difference between the compact expressions discussed above and the syntax utilized to specify Dial or Dial group instances in the RTX API calls is that in the illustrative embodiment Dial and Dial group instances are specified in the RTX API calls by reference to the top level design entity of simulation model rather than relative to the design entity in which the Dial or Dial group is specified.

In the illustrative embodiment each RTX API call targeting one or more Dial or Dial group instances in simulation model specifies the Dial or Dial group instances utilizing two parameters an instance qualifier and a dialname qualifier. To refer to only a single Dial or Dial group instantiation the instance qualifier takes the form a.b.c.d which is the hierarchical instantiation identifier of the design entity in which the single Dial or Dial group instantiation occurs. To refer to multiple Dial or Dial group instances the instance qualifier takes the form a.b.c X which identifies all instantiations of entity X within the scope of entity instance a.b.c. In the degenerate form the instance qualifier may simply be X which identifies all instantiations of entity X anywhere within simulation model .

The dialname qualifier preferably takes the form Entity.dialname where Entity is the design entity in which the Dial or Dial group is instantiated and dialname is the name assigned to the Dial or Dial group in its configuration specification statement. If bracketed syntax is employed to specify the instance qualifier the Entity field can be dropped from the dialname qualifier since it will match the bracketed entity name.

Referring now to there is depicted a high level logical flowchart of an exemplary process by which configuration APIs locate particular Dial or Dial group instances in configuration database based upon an instance qualifier and dialname qualifier pair in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of an API call from RTX containing an instance qualifier and a dialname qualifier as discussed above. In response to the API call the configuration API enters configuration database at Dial pointer array as depicted at block and utilizes Dial pointers to locate a DDDS having a name field that exactly matches the specified dialname qualifier as illustrated at block .

Next at block the configuration API determines whether the instance qualifier employs bracketed syntax as described above. If so the process passes to block which is described below. However if the instance qualifier does not employ bracketed syntax the configuration API follows the instance pointers of the matching DDDS to locate the single DIDS having an instance name field that exactly matches the specified instance qualifier. As indicated at blocks if no match is found the process terminates with an error. However if a matching DIDS is located a temporary result pointer identifying the single matching DIDS is created at block . The process thereafter terminates at block .

Returning to block if bracketed syntax is employed the configuration API utilizes instance pointers of the matching DDDS to locate one or more DIDSs of Dial or Dial group instances within the scope specified by the prefix portion of the instance identifier preceding the bracketing. That is a DIDS is said to match if the instance name field of the DIDS contains the prefix portion of the instance qualifier. Again if no match is found the process passes through block and terminates with an error at block . However if one or more DIDSs match the instance qualifier temporary result pointers identifying the matching DIDSs are constructed at block . The process shown in thereafter terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial instances in interactive mode in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of a read Dial API call by RTX . As indicated at block a configuration API responds to the read Dial API call by locating within configuration database one or more DIDSs of Dial instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API determines by reference to type field of the DDDS associated with the DIDS identified by the current result pointer whether the DIDS corresponds to a Dial group. If so the process illustrated in terminates with an error condition at block indicating that RTX has utilized the wrong API call to read a Dial instance.

In response to a determination at block that the DIDS identified by the current result pointer does not correspond to a Dial group instance the process proceeds to block . Block depicts configuration API utilizing output pointers of the DIDS and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the Dial instance specified in the API call. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

Configuration API then verifies the latch values obtained from simulation model by reference to configuration database as shown at block . In order to verify the latch values configuration API utilizes mapping tables to propagate the latch values up the Dial tree from the corresponding latch data structures through intermediate DIDSs if any until an input value for the requested Dial instance is determined. If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

As indicated by the process returning to block the above described process is repeated for each temporary result pointer returned by the process of . Once all result pointers have been processed the process passes from block to blocks which illustrate the configuration API returning the result data structure to RTX and then terminating.

RTX reads Dial instances in interactive mode utilizing the method of for example to initialize checkers that monitor portions of simulation model during simulation runs. The Dial settings of interest include not only those of top level Dial instances but also those of lower level Dial instances affiliated with the portions of the simulation model monitored by the checkers.

Reading Dial instances in a batch mode of RTX is preferably handled by configuration APIs in the same manner as interactive mode with one exception. Whereas in interactive mode latch values are always read from simulation model via calls to GETFAC API at block in batch mode a latch value is preferably obtained from latch value field of a latch data structure in configuration database if latch set field indicates that the corresponding configuration latch has been set. If the configuration latch has not been set the latch value is obtained from simulation model by a call to GETFAC API . This difference ensures that Dial settings made in batch mode which may not yet have been reflected in simulation model are correctly reported.

Referring now to there is depicted a high level logical flowchart of an exemplary process by which RTX reads bias information of one or more Dial instances in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of a read Dial bias API call by RTX . As indicated at block a configuration API responds to the read Dial bias API call by locating within configuration database one or more DIDSs of Dial instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API determines by reference to type field of the DDDS associated with the DIDS identified by the current result pointer whether the DIDS corresponds to a Dial group. If so the process illustrated in terminates with an error condition at block .

In response to a determination at block that the DIDS identified by the current result pointer does not correspond to a Dial group instance the process proceeds to block . Block depicts configuration API placing in a result data structure the contents of the bias table of the DDDS associated with the DIDS identified by the current result pointer. As described above the contents of bias table may include not only a listing of all the sets of the biasing weights defined for the Dial but also an indication of a currently applied set of biasing weights if any for instances of the Dial.

As indicated by the process returning to block the above described process is repeated for each temporary result pointer returned by the process of . Once all result pointers have been processed the process passes from block to blocks which illustrate the configuration API returning the result data structure to RTX and then terminating.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which an RTX sets a Dial instance in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial API call from RTX . In response to the set Dial API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial instance s specified in the set Dial API call utilizing the technique described above with reference to as illustrated at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial instances. This determination can be made for example by examining the parent pointer of each such DIDS and that of any higher level DIDS linked by a parent pointer and the type fields of the associated DDDSs . The DIDS of a top level Dial instance will have either a NULL parent pointer or a non NULL parent pointer pointing to another DIDS that the type field of the associated DDDS indicates represents a Dial group. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial instance the process terminates at block with an error condition.

In response to a determination at block that all of the DIDSs referenced by the result pointers correspond to top level Dial instances a further determination is made at block whether or not the set Dial API call specified a set of biasing weights for example by passing as parameters of the call a flag indicating the use of biasing weights and a string including a NULL string identifying a set of biasing weights for the Dial instances. If a determination is made at block that the set Dial API call does not contain a flag indicating that biasing weights are to be applied to set the Dial instances but instead explicitly enumerates a particular Dial setting the process proceeds to block which is described below. If on the other hand the set Dial API call contains a parameter specifying a set of biasing weights to be applied to the Dial instances the process proceeds to block . Block depicts a configuration API determining whether or not the specified set of biasing weights is valid that is whether or not it is enumerated within bias table of the DDDS of the Dial instance s . If not the process depicted in terminates with an error at block . If configuration API determines that the specified set of biasing weights is valid at block configuration API selects a Dial setting for the Dial instances from the specified set of biasing weights at block as described in greater detail below with reference to . The process then proceeds to block .

Block depicts configuration API determining whether or not the specified value to which the Dial instance s are to be set is one of the values specified in the mapping table of the associated DDDS . If not the process terminates with an error at block . However in response to a determination at block that the specified value to which the Dial instance s are to be set is one of the legal values which is always the case if a set of biasing weights is used to set the Dial instances the process enters a loop including blocks in which each result pointer is processed to set a respective Dial instance.

At block configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified in the set Dial API call down the Dial tree headed by the top level Dial instance associated with the DIDS referenced by the current result pointer. In order to propagate the desired Dial setting mapping table in the DDDS associated with the DIDS referenced by the current result pointer is first referenced if necessary i.e. for CDials and LDials to determine the output values for each of output pointers in the output pointer array of the DIDS referenced by the current result pointer. These output values are propagated down the Dial tree as the input values of the next lower level Dial instances if any corresponding to the DIDSs referenced by output pointers . This propagation continues until a latch value is determined for each configuration latch terminating the Dial tree which are represented in configuration database by latch data structures . As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure .

Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer. After all result pointers are processed the process terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary method of selecting a Dial input value i.e. a Dial setting by reference to a set of biasing weights in accordance with the present invention. In one embodiment the illustrated process is performed by a separate routine called by configuration API .

The process begins at block and then proceeds to blocks and which illustrate the routine summing all biasing weights within the specified set of biasing weights and then generating a random number between 1 and the sum. Next at block the routine correlates the random number generated at block to a particular biasing weight within the set of biasing weights. For example for the exemplary unitsim set of biasing weights set forth above which comprises the three biasing weights 2 1 10 3 1 20 and 4 1 10 the sum of the biasing weights generated at block is 40. A random number within the range of 1 10 correlates to the first biasing weight a random number in the range of 11 30 correlates to the second biasing weight and a random number in the range of 31 40 correlates to the third biasing weight. It will be appreciated that by correlating the random number to the biasing weights in this manner biasing weights will be selected over time in accordance with the probabilities assigned by the designer.

The routine next determines at block whether or not the particular biasing weight to which the random number correlates is a group biasing weight associated with multiple Dial input values. If not the process passes to block which depicts the routine selecting the Dial input value associated with the biasing weight to which the random number correlates. For example for the exemplary unitsim set of biasing weights a random number of 15 would correlate to the second biasing weight which is associated with a Dial input value of 3 1. Following block the process ends at block .

Referring again to block in response to a determination that the biasing weight to which the random number correlates is a group biasing weight the process proceeds to block . Block depicts the routine generating a second random number between 1 and the number of Dial input values associated with the group bias weight where each possible value of the random number corresponds to a particular Dial input value. The routine then correlates the second random number to select a Dial input value at block . Thereafter the process ends at block .

Referring now to there is depicted a high level logical flowchart of an exemplary method by which an RTX sets top level Dial instance s utilizing their biasing weights in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set top level Dials API call from RTX . In response to the set top level Dials API call the configuration API first locates top level pointer array . The process then proceeds to block which illustrates a determination of whether or not all top level pointers within top level pointer array have been processed. If so the process terminates at block . If however at least one additional top level pointer remains to be processed the next top level pointer to be processed is selected at block . Next at block configuration API determines by reference to the type field of the DDDS identified by the definition pointer whether or not the instance identified by the top level pointer currently under consideration is a Dial group instance. If so the process returns to block which has been described. If not the process proceeds to block .

Block depicts configuration API determining whether or not the set of biasing weights specified as a parameter of the API call is valid for the top level Dial instance under consideration that is whether or not it is enumerated within bias table of the DDDS of the Dial instance s . If not the process depicted in returns to block which has been described. If however configuration API determines that the specified set of biasing weights is valid for the current top level Dial instance at block configuration API selects a Dial setting for the top level Dial instance from the specified set of biasing weights for example in accordance with the method of block . The process then proceeds to block .

Block depicts configuration API propagating the Dial setting selected at block down the Dial tree headed by the top level Dial instance associated with the DIDS referenced by the current top level pointer . In order to propagate the desired Dial setting mapping table in the DDDS associated with the DIDS referenced by the current top level pointer is first referenced if necessary i.e. for CDials and LDials to determine the output values for each of output pointers in the output pointer array of the DIDS referenced by the current result pointer. These output values are propagated down the Dial tree as the input values of the next lower level Dial instances if any corresponding to the DIDSs referenced by output pointers . This propagation continues until a latch value is determined for each configuration latch terminating the Dial tree which is represented in configuration database by latch data structures . As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure . Following block the process returns to block which has been described.

The process of thus permits an entire digital system to be efficiently configured according to designer specified bias weights. For example to facilitate both simulation testing of a digital design utilizing a simulation model and laboratory testing of a hardware realization of the digital design the designer may specify for all relevant Dials a first set of biasing weights named sim and a second set of biasing weights named lab . In order to configure an entire model for either simulation testing or laboratory testing an RTX need only specify sim or lab as a parameter of a set top level Dials API call which will cause a configuration API to set all relevant top level Dial instances according to the specified set of biasing weights. Of course any individual Dial instance s including Dial instances previously set by a set top level Dials API call may further be set in accordance with a set Dial API call.

With reference now to there is illustrated a high level logical flowchart of an exemplary method of setting Dial and Dial group instances in batch mode in accordance with the present invention. As illustrated the process begins at block and thereafter proceeds to block which illustrates RTX initializing configuration database by calling a configuration API e.g. start batch in order to initialize configuration database . The start batch API routine initializes configuration database for example by setting each Dial set field latch set field and set history field in configuration database to FALSE. By resetting all of the set fields in configuration database the Dials and configuration latches that are not set by the current batch mode call sequence can be easily detected as discussed below.

Following initialization of configuration database at block the process shown in proceeds to block . Block illustrates RTX optionally issuing one or more read Dial API calls to read one or more Dials as discussed above with respect to and optionally issuing one or more batch mode set Dial API calls to enter settings for Dial instances and their underlying configuration latches into configuration database . A configuration API responds to the set API calls in the same manner described above with respect to for setting Dial instances with two exceptions. First when any top level or lower level Dial instances are set whether as a result of a set Dial or set Dial group API call the Dial set field of the corresponding DIDS is set to TRUE. Second no latch values are written to simulation model by the set API routines as illustrated at blocks of . Instead the latch values are written into latch value fields of the latch data structure corresponding to each affected configuration latch and the latch set field is updated to TRUE. In this manner the Dial instances and configuration latches that are explicitly set by the API call can be readily identified during subsequent processing.

Following block the process passes to block which illustrates RTX calling an end batch API routine among configuration APIs to complete the present phase of default application. As indicated at block and as described in detail below with respect to the end batch API routine applies selected default values if any to specified Dial instances and propagates these default values to underlying configuration latches into configuration database . The latch values of all configuration latches set explicitly or with a default value are then potentially applied to latches within the simulation model. Finally preparation is made for a next phase if any.

If RTX has an additional phase of default application the process passes from block to block and then returns to block which represents RTX initiating a next phase of default application. If however all phases of default application have been processed the process illustrated in passes from block through block to block where the batch process terminates.

Referring now to there is depicted a high level logical flowchart of an exemplary embodiment of the end phase API routine called at block of . As shown the process begins at block when the end phase API routine is called by RTX for example with the following statement 

In this exemplary API call the phases parameter is a string specifying the phase ID s of defaults to be applied at the end of the current phase unnamed is a Boolean parameter indicating whether or not defaults values without any associated phase ID should be applied during the current phase apply is a Boolean valued parameter indicating whether or not configuration latch values should be immediately applied to simulation model and instance qualifier is one or more regular expressions that can be utilized to limit which instances of a particular Dial are processed to apply defaults.

By specifying an instance qualifier parameter for the end phase API routine a user can limit the application of defaults to only a portion of simulation model . The ability to restrict the application of defaults in this manner is particularly useful in cases in which two sections of the simulation model e.g. sections representing two different integrated circuit chips have different phasing requirements but use the same phase IDs. Thus collisions in phase IDs can be resolved by appropriate specification of the instance qualifier used in conjunction with the phase ID.

The end phase API routine then enters a processing loop including blocks in which DIDSs within configuration database are processed to apply appropriate Dial default values if any. Referring first to block the end phase API determines whether or not all top level pointers within top level pointer array have been processed. If so the process proceeds from block to block which is described below. If not all top level pointers within top level pointer array have been processed the process proceeds to block . Block represents the end phase API routine recursively scanning the DIDSs pointed to by a next top level pointer and its descendant DIDSs if any to apply the default values indicated by the parameters of the end phase API call. If the end phase API routine determines at block that it has processed all necessary DIDSs in the subtree of the top level DIDS identified by the current top level pointer then the process returns to block which has been described. If however at least one DIDS in the subtree of the top level DIDS identified by the current top level pointer remains to be processed the process passes from block to block .

Block illustrates the end phase API routine examining a next DIDS to determine whether or not its default field has a non NULL value. If the current DIDS does not contain a non NULL default field the process returns to block representing the end phase API routine continuing the recursive processing of DIDSs in the subtree of the top level DIDS pointed to by the current top level pointer . If the default field contains a non NULL value the process passes to block which depicts a determination of whether or not the Dial set field is set that is whether the Dial instance was previously explicitly set at block of . If the Dial set field is set the default value contained in default field is ignored since the simulation user has already explicitly specified a value for the associated Dial instance . And because simulation database is constructed so that any descendant of a DIDS having a specified default cannot have a default value the process passes to block which illustrates the end phase API routine skipping the processing of any DIDS in the subtree of the current DIDS . Thereafter the process returns to block which has been described.

Returning to block in response to a determination that the Dial set field of the current DIDS is not set the process proceeds to block . Block illustrates end phase API interrogating phase ID field of the current DIDS to determine whether the default value stored in default field has one or more associated phase IDs. If not the process passes to block which is described below. In response to a determination at block that phase ID field stores at least one phase ID the end phase API next determines at block whether the phases parameter of the end phase API call specifies a phase ID that matches a phase ID contained within phase ID field . If no match is found the process passes from block to block which has been described. If on the other hand a phase ID specified in the phases parameter of the endphase API call matches a phase ID contained within the phase ID field of the current DIDS the end phase API next determines at block whether or not the Dial instance name contained in instance name field of the current DIDS matches the qualifying expression passed as the instance qualifier parameter of the end phase API call. Again in response to a negative determination at block the process passes to block which has been described. If on the other hand the Dial instance name contained within instance name field is qualified by the instance qualifier parameter the process proceeds to block which is described below.

Returning to block if the current DIDS does not have one or more phase IDs specified within phase ID field a further determination is made whether or not the unnamed parameter of the end phase API call has a value of TRUE to indicate the default values without any associated phase information should be applied during the current phase. If not the process passes from block to block which has been described. If on the other hand the end phase API determines at block that defaults without associated phase information should be applied during the current phase the process proceeds to block which has been described above.

Thus when the end phase API reaches block end phase API has by the determinations illustrated at and determined that the default specified for the Dial instance corresponding to the current DIDS should be applied in the current phase of batch mode execution. Accordingly at block the end phase API routine applies the default value specified in the default field to mapping table to generate one or more Dial output signal s which are then propagated down the Dial tree of the current DIDS in the manner hereinbefore described ultimately setting the latch value fields and latch set field of each of the underlying latch data structures within configuration database to values corresponding to the Dial default value. The process then proceeds from block to block which has been described.

Returning to block in response to a determination that the Dial trees of all of the DIDS pointed to by top level pointers have been processed to apply any appropriate default values in the manner described above the process next passes to block . Block depicts end phase API examining the apply parameter of the end phase API call to determine whether or not the configuration latch values within latch data structures should be applied to simulation model . The added degree of control represented by this determination is advantageous in that different sections of simulation model which may have colliding phase IDs can be independently configured within configuration database in different phases but the resulting configuration latch values can be applied to simulation model at the same time if desired. If the apply parameter has the value FALSE meaning that the configuration latch values are not to be applied to simulation model during the current phase the process passes directly to block .

If however configuration latch values are to be applied to simulation model during the current phase as indicated by an apply parameter value of TRUE the end phase API routine proceeds to block . At block the end phase API utilizes latch pointer array to examine each latch data structure in configuration database . For each latch data structure in which latch set field has the value TRUE the end batch API routine issues a call to PUTFAC API of simulator to update simulation model with the latch value contained in latch value field . In addition as shown at block the end phase API performs a logical OR operation between the value of latch set field and set history field storing the result within set history field . In this manner each set history field maintains an indication of whether or not the corresponding configuration latch has been set during any phase of the batch mode process.

Following block the end batch API proceeds to block which depicts the end batch API routine resetting all of Dial set fields in DIDS and all latch set fields in preparation of a next phase if any. Thereafter the end phase API routine terminates at block .

In summary the end phase APT routine applies Dial default values to configuration database that match the limiting phase and instance qualifiers and then optionally applies the resulting configuration latch values to simulation model in accordance with the apply parameter. Finally the end phase API routine tracks which latch data structures have been set utilizing set history fields and resets various set fields to prepare for a next phase if any.

Heretofore default values have been described solely with respect to designer supplied phase information specified within HDL files or configuration specification files . For many simulation models designers have only limited knowledge of the boot sequence of the simulation model and corresponding hardware implementations and therefore have limited understanding of the phasing of defaults required to appropriately initialize the simulation model or corresponding hardware realization. Accordingly it is desirable to provide downstream users such as simulation users laboratory users or deployment support personnel with the ability to specify phase information governing the application of Dial default values.

As shown in in one embodiment users are permitted to supply and or modify the phase ID s stored within phase ID fields of configuration database or a corresponding hardware configuration database discussed below utilizing a program . Program includes a set of database manipulation API routines that when called with appropriate parameters permits a user to read and write phase IDs within configuration database or the corresponding hardware configuration database .

Referring again to configuration APIs preferably further include a find unset latch API that following a batch mode setting of Dial or Dial group instances in configuration database audits all of the latch data structures in configuration database by reference to latch pointer array in order to detect configuration latches that have not been configured by an explicit or default setting i.e. those having set history field set to FALSE . For each such unset configuration latch the find unset latch API preferably returns the fully qualified instance name of the configuration latch from latch name field in the corresponding latch data structure and the fully qualified instantiation identifier of the top level Dial instance that controls the unset latch. The find unset latch API thus provides an automated mechanism for a user to verify that all Dial and latch instances requiring an explicit or default setting are properly configured for a simulation run.

Configuration APIs preferably further include a check model API that when called utilizes top level pointer array to verify by reference to the appropriate mapping tables that each top level CDial and LDial instance in simulation model is set to one of its legal values. Any top level LDial or CDial set to an illegal value is returned by the check model API.

The Dial and Dial group primitives introduced by the present invention can be employed not only to configure a simulation model of a digital design as described above but also to configure hardware realizations of the digital design for laboratory testing and customer use. In accordance with an important aspect of the present invention hardware realizations of the digital design are configured and the configuration of hardware realizations can be read by reference to a hardware configuration database which like configuration databases and discussed above is derived from configuration specification statements coded by the designers. The reading and setting of configurations in hardware systems can be performed in like manner to the processes previously described with reference to A C A C and A B. In this manner continuity in configuration methodology exists from design through simulation and laboratory testing to commercial deployment of a digital design.

Referring now to there is illustrated a high level block diagram of a laboratory testing system for testing and debugging hardware realizations of one or more digital designs in accordance with an embodiment of the present invention. As illustrated the laboratory testing system includes a data processing system which is intended for commercial sale and deployment. For laboratory testing and debugging data processing system is coupled by a test interface to a workstation computer that communicates with data processing system via test interface to configure the various components of data processing system for proper operation. When commercially deployed data processing system includes the illustrated components but is not typically coupled to workstation computer by test interface .

Data processing system may be for example a multiprocessor computer system such as data processing system of . As such data processing system includes multiple integrated circuit chips representing the various processing units controllers bridges and other components of a data processing system. As is typical of commercial data processing systems data processing system may contain multiple instances of some integrated circuit chips such as integrated circuit chips and single instances of other integrated circuit chips such as integrated circuit chip

In addition to their respective functional logic integrated circuit chips each have a respective test port controller that supports external configuration of the integrated circuit chip utilizing multiple scan chains. To permit such external configuration each test port controller is coupled by a test access port TAP to a service processor within data processing system .

Service processor is a general purpose or special purpose computer system utilized to initialize and configure data processing system for example at power on in response to a reboot or during operation. Service processor includes at least one processing unit for executing software instructions a flash read only memory ROM providing non volatile storage for software and data an I O interface interfacing service processor with test port controllers and workstation computer and a volatile memory that buffers instructions and data for access by processing unit

Among the software and data stored in flash ROM is system firmware . System firmware is executed by processing unit of service processor at power on to sequence power to integrated circuit chips perform various initialization procedures and tests synchronize communication between integrated circuit chips and initiate operation of the functional clocks. System firmware controls the startup behavior

In addition to system firmware flash ROM stores hardware HW configuration APIs and a HW configuration database describing integrated circuit chips . During commercial deployment processing unit calls various HW configuration APIs to access HW configuration database in order to appropriately configure integrated circuits via I O interface and TAPs .

Workstation computer which may be implemented for example as a multiprocessor computer system like data processing system of includes many components that are functionally similar to those of service processor . Accordingly like reference numerals designate processing unit volatile memory I O interface and the system firmware HW configuration database and HW configuration APIs residing in non volatile storage e.g. disk storage . It will be appreciated by those skilled in the art that because the system firmware HW configuration database and HW configuration APIs residing in non volatile storage are specifically designed to initialize and configure data processing system in the context of laboratory testing and debugging they may have smaller larger or simply different feature sets and capabilities than the corresponding software and data within flash ROM .

During laboratory testing and debugging workstation computer assumes most of the functions of service processor . For example workstation computer initializes and configures data processing system by executing system firmware and various HW configuration APIs in order to generate various I O commands. These I O commands are then communicated to data processing system via test interface and I O interfaces and . System firmware which executes within service processor in a bypass mode in which most of its native functionality is disabled responds to these external I O commands by issuing them to integrated circuit chips via test access ports in order to initialize and configure integrated circuit chips .

In order to properly initialize a complex digital system such as data processing system the configuration of configuration latches within integrated circuit chips may require reference to the values of system level variables above the scope of the HDL design entities corresponding to integrated circuit chips . For example proper configuration of a complex digital system may require knowledge of system content variables having values representing the types numbers and characteristics of the components present in the system e.g. the types and number of processing units the size of volatile memory etc. . In addition configuration of a complex digital system may require knowledge of system temporal variables such as the phases of IPL during which particular system components and or configuration latches are to be set. The values of at least some of these system variables cannot be known a priori but must instead be determined at the time of configuration.

To facilitate the automation of the configuration of configuration latches that depend upon system level variables the present invention provides a system level configuration specification language. In one embodiment the system level configuration specification language supports system configuration statements of the form 

As shown in to specify a configuration of one or more digital systems of possibly different configurations a design team member composes at least one human readable e.g. ASCII system configuration specification file containing one or more system configuration statements which may employ the exemplary syntax discussed above. In one embodiment a configuration specification file is created for each type of integrated circuit chip . Each system configuration specification file is then compiled by a compiler executing on a data processing system e.g. data processing system of to obtain one or more compact binary system configuration files . In one embodiment a binary system configuration file is created for each type of integrated circuit chip . As illustrated in each binary system configuration file is then stored within system firmware and or together with an interpreter capable of interpreting or processing binary system configuration file s .

Referring now to there is depicted a high level logical flowchart of an exemplary process of configuring a digital system based upon system level variables in accordance with the present invention. The depicted process is performed for example through the execution of program code such as system firmware and or by a data processing system or .

As depicted the process begins at block in response to a configuration event which may be for example rebooting or powering on data processing system adding or removing a component of data processing system or detection of an error by system firmware . In response to the configuration event system firmware probes data processing system to obtain information regarding data processing system as shown at block . The information gathered in the system probe preferably includes system variables such as the number type and operating frequencies of integrated circuits the topology and frequency of the interconnect fabric utilized to couple integrated circuits the type of volatile memory etc. As depicted at block this system meta data is stored as system level variables within data processing system for example within volatile memory

Following block system firmware enters a processing loop including blocks . Block depicts system firmware determining whether each of possibly multiple phases of configuration has been performed. If all of the phases of configuration have been performed system level configuration by system firmware ends at block . Additional configuration of integrated circuit chips may of course be performed by system firmware as described in the above referenced U.S. patent application Ser. No. 10 750 112. If however at least one additional phase of system configuration remains to be performed the process proceeds to block which illustrates a determination of whether or not all integrated circuit chips discovered in the system probe have been processed in the current phase of configuration. If so the process returns to block . If however at least one integrated circuit chip remains to be processed during the current phase of configuration the process proceeds to block .

Block depicts system firmware invoking an interpreter to interpret the binary system configuration file for the next integrated circuit chip with reference to system level variables . That is interpreter processes the binary representations of the system configuration statements contained within the binary system configuration file using system level variables to evaluate the expressions upon which the system level configuration depends. For each system configuration statement interpreter sets the Dial identified by Dial name to the value contained in the first evaluated row for which all expressions if present evaluate as true. In one preferred embodiment interpreter sets the Dials for an integrated circuit chip by issuing to a HW configuration API a series of API calls specifying Dial names and corresponding Dial input values. In response to the API calls the HW configuration API accesses HW configuration database to identify the location of the configuration latch es within the integrated circuit chip that correspond to the specified Dial and to determine the settings of the configuration latches that correspond to the Dial input values. The HW configuration API then sets the configuration latches within the integrated circuit chip to the appropriate settings via I O interface and the relevant TAP .

Following block the process returns to block until the binary configuration file if any for each integrated circuit chip has been processed. Thereafter the process loops back to block until all temporal phases of configuration have been processed. The process then terminates at block .

As has been described the present invention provides an improved method system and program product for configuring a digital system based upon the values of system level variables. In accordance with a preferred embodiment a human readable system configuration file including a plurality of system configuration statements having predetermined syntax is created and compiled to obtain its binary representation. The binary representation specifies a plurality of diverse configurations that may be alternatively implemented based upon the value of system variables that cannot be known a priori. When a configuration event such as system power on occurs the binary representation is processed by an interpreter to set particular Dials in the system to particular values in accordance with the system configuration statements.

While the invention has been particularly shown as described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration entities having different rules than the particular exemplary embodiments disclosed herein. In addition although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Program code including software and or data defining the functions of the present invention can be delivered to a data processing system via a variety of signal bearing media which include without limitation non rewritable storage media e.g. CD ROM rewritable storage media e.g. a floppy diskette or hard disk drive and communication media such as digital and analog networks. It should be understood therefore that such signal bearing media when carrying or encoding computer readable instructions that direct the functions of the present invention represent alternative embodiments of the present invention.

