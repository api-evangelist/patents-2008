---

title: Reordering of data elements in a data parallel system
abstract: A query that identifies an input data source is received. The input data source is partitioned into a plurality of partitions. Each of the partitions includes a set of data elements with an associated set of indices for indicating an ordering of the data elements. A query type for a query operator in the received query is identified. It is determined whether a reordering of data elements will be performed based on the identified query type. The data elements in at least one of the partitions are reordered when it is determined based on the identified query type that reordering will be performed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08290917&OS=08290917&RS=08290917
owner: Microsoft Corporation
number: 08290917
owner_city: Redmond
owner_country: US
publication_date: 20080602
---
Software programs have been written to run sequentially since the beginning days of software development. Steadily over time computers have become much more powerful with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever increasing single processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware software developers arrange for one or more tasks of a particular software program to be executed in parallel also referred to as concurrently so that the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.

When parallelizing previously written sequential algorithms it is often desirable to keep as much of the previous sequential program behavior as possible. However typical parallel execution of existing sequential logic introduces new behavioral characteristics and presents problems that can introduce challenges into the migration from sequential to parallel algorithms.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Data parallel systems typically operate by partitioning input data into disjoint subsets partitions so that independent tasks of execution may process the separate subsets in isolation. The partitions are typically processed in parallel by multiple tasks of execution to generate a plurality of output sets. The output sets are then typically merged back into a merged output set.

In one embodiment a query that identifies an input data source is received. The input data source is partitioned into a plurality of partitions. Each of the partitions includes a set of data elements with an associated set of indices for indicating an ordering of the data elements. A query type for a query operator in the received query is identified. It is determined whether a reordering of data elements will be performed based on the identified query type. The data elements in at least one of the partitions are reordered when it is determined based on the identified query type that reordering will be performed.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

One embodiment provides an application that performs index tracking and reordering for data parallel operations but the technologies and techniques described herein also serve other purposes in addition to these. In one implementation one or more of the techniques described herein can be implemented as features within a framework program such as MICROSOFT .NET Framework or within any other type of program or service that handles data parallel operations in programs.

Data parallel systems typically operate by partitioning input data into disjoint subsets partitions so that independent tasks of execution may process the separate subsets in isolation. The partitions are processed in parallel by multiple processors to generate a plurality of output sets e.g. the query is executed in parallel using the plurality of partitions . The output sets are merged back into a merged output set or processed independently.

Some data parallel systems provide an application programming interface API that allows a programmer to express an operation on an input sequence as a chain of query operators such as filters projections aggregations as well as other operators. The declarative nature of the query allows the API implementation to take advantage of multiple processors when executing the query.

 1 ALL evaluates a predicate function on each element in the input and returns true only if the predicate returned true for every single element. If any element yields false a false is returned which can happen at the first occurrence of a false predicate return value.

 2 ANY evaluates a predicate function on the input and returns true if the predicate returns true on any one element and returns false if the predicate yields false for every element in the input.

 3 CONTAINS searches the input for a particular value returning true if the value was found at least once and false otherwise.

 4 FIRST returns the first element from the input for which a predicate returns true. Note that if the predicate matches multiple elements only the first one based on ordinal position is returned.

 5 LAST returns the last element from the input for which a predicate returns true. Note that if the predicate matches multiple elements only the last one is returned.

 6 TAKEWHILE outputs all elements in the input leading up to the first element for which a specified predicate returns false.

 7 SKIPWHILE outputs all elements in the input that occur after the first occurrence of an element for which a specified predicate returns false.

 10 INDEXED SELECT a projection operator that allows the value of the projection function to depend on positions of elements in the input sequence for example an indexed select could negate integers that are in even positions in the input sequence and preserve the elements in the odd positions .

 11 INDEXED WHERE filter that allows the filtering predicate to depend on positions of elements in the input sequence for example the filter could only keep the elements in even positions .

 12 SELECT used to perform a projection on a data collection to select either all the data members that make up the object or a subset of it.

During the partitioning of an input sequence in a data parallel system a situation may occur where the input sequence is partitioned non contiguously due to various practical concerns. For example in an on demand partitioning scheme parts of the input may be dynamically assigned to partitions in order to achieve load balancing if different elements of the input sequence involve different amounts of work. Since ordering of partitions does not directly correspond to ordering of the elements in the input information about how different elements from different partitions were originally ordered against each other becomes lost unless it is explicitly tracked in some way.

For example consider the input sequence 7 1 2 4 3 6 and a data parallel filter operation that only keeps odd integers. Assume that the data parallel implementation splits the input into two partitions 7 2 3 and 1 4 6 . After applying the filter the two output sets will be 7 3 and 1 . However unless the information is remembered that the 1 was positioned between the 7 and the 3 in the original input the filtered results will not be presented to the user in the order in which they appeared in the input.

One embodiment provides a data parallel system and method that assigns ordinal order indices to the elements of an input sequence at the time that the sequence is to be partitioned maintains and tracks the indices during parallel execution of the query and uses the indices to produce a correctly ordered output sequence. For some query operators if the operator is not provided ordered input the output generated by the operator may not be correct. One embodiment addresses this issue by assigning ordinal indices to elements in the input sequence tracking the state of the indices as various operators process the sequence and performing work e.g. reordering to correct the state of the indices if the indices are not in an appropriate state for a query operator that is about to process the sequence. One embodiment provides order preservation throughout the query execution process. For order preservation to work correctly the indices are remembered for as long as the system runs in parallel. This allows many disparate partitions to be brought back into one correctly ordered stream during the merge.

Computing device may also have additional features functionality. For example computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any suitable method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices. Any such computer storage media may be part of computing device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Computing device may also include input device s such as keyboard pointing device e.g. mouse pen voice input device touch input device etc. Computing device may also include output device s such as a display speakers printer etc.

In one embodiment computing device includes index tracking and reordering application . Index tracking and reordering application is described in further detail below with reference to .

Index tracking and reordering application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for re writing a query to contain data parallel operations that include partitioning and merging logic for partitioning an input data source into partitions with each partition including a set of data elements with an associated set of indices for indicating an ordering of the elements logic for performing tracking of the indices and reordering of the data elements logic for executing the query in parallel using the partitions thereby producing output data logic for merging the output data into a final ordered set and other logic for operating the application.

The term query as used herein is not limited to any one specific type of data parallel operation but rather is applicable to all types of data parallel operations. A query according to one embodiment includes for example any type of expression program statement or computation used in data parallel operations.

Turning now to with continued reference to methods for implementing one or more embodiments of index tracking and reordering application are described in further detail. In some implementations the methods illustrated in are at least partially implemented in the operating logic of computing device .

At at least one index state for the set of indices for each partition is identified. In one embodiment a plurality of index states for the set of indices for each partition is identified at . In one embodiment the plurality of index states for each partition includes a first state indicating whether the set of indices for the partition is normalized a second state indicating whether the set of indices for the partition is ordered and a third state indicating whether the set of indices for the partition is contiguously partitioned. These index states are described in further detail below with respect to . In another embodiment other index states may be used such as a first state indicating whether the set of indices is correct e.g. within each partition elements are correct i.e. normalized a second state indicating whether the set of indices is increasing e.g. within each partition elements are at least increasing and a third state indicating whether the set of indices is invalid. Each index state is successively weaker in this embodiment.

At it is determined whether a reordering of the data elements will be performed based on the query type identified at and the index states identified at . In one embodiment the determination at is made at least in part by comparing the at least one index state identified at to a set of admissible index states which are identified based on the query type identified at . At a reordering algorithm is identified based on the query type identified at and the index states identified at when it is determined at that reordering will be performed. At a reordering operation performs a reordering of the data elements in at least one of the partitions using the reordering algorithm identified at when it is determined at that reordering will be performed.

For example in one embodiment it may be determined at that a reordering of the data elements in a first one of the partitions will be performed when the admissible index states indicate that the data elements for the received query operator are to be ordered and the at least one index state indicates that the set of data elements in the first partition are non ordered. In one form of this embodiment a reordering of the data elements in the first partition will be performed to cause the data elements to be ordered.

At a plurality of parallel workers e.g. processors or threads performs a parallel execution of the received query using the plurality of partitions and generates and output set for each of the partitions thereby generating a plurality of output sets. At a merge operation merges the plurality of output sets into a merged output set. In one embodiment the order indices are used at to help ensure that the elements in the merged output set will be in the correct order.

In one embodiment processors A and B are configured to perform a parallel execution of a query which includes one or more query operators using the partitions A and B respectively. In one embodiment processors A and B are also configured to generate index state information A and B respectively and query type information A and B respectively.

In one embodiment index state information A and B each include three index state parameters for each ordinal index with each index state parameter having one of two possible index states. The index states according to one embodiment are Normalized or non normalized i.e. relative ordered or non ordered i.e. shuffled and contiguously partitioned or non contiguously partitioned.

For the normalized index state according to one embodiment the ordinal indices correctly specify the O based index of each element in the output. For example if the input data sequence 7 1 2 4 3 6 is partitioned into the two partitions 7 2 3 1 4 6 one example of indices in a normalized index state would be 0 2 4 1 3 5 . For the non normalized or relative index state according to one embodiment sorting data elements according to their indices would produce the correct output but the indices do not correctly specify O based indices of elements in the output. For example if the input data sequence 7 1 2 4 3 6 is partitioned into the two partitions 7 2 3 1 4 6 one example of indices in a non normalized index state would be 0 11 17 5 14 20 .

The ordered or non ordered index states indicate whether the elements in each partition A and B are ordered according to the indices . For the ordered index state according to one embodiment within each partition elements are sorted or ordered according to the indices . One example of indices in an ordered index state would be 0 2 4 1 3 5 . For the non ordered or shuffled index state according to one embodiment within each partition A and B elements are not sorted according to the indices . One example of indices in a non ordered index state would be 2 4 0 1 5 3 .

The contiguously partitioned or non contiguously partitioned index states indicate whether the elements in an input partition A or B are contiguously partitioned. For the contiguously partitioned index state according to one embodiment the indices do not specify two elements from the same partition e.g. partition A that surround an element from another partition e.g. partition B in the ordered output. One example of indices in a contiguously partitioned index state would be 0 1 2 3 4 5 . For the non contiguously partitioned index state according to one embodiment the indices may specify two elements from the same partition e.g. partition A that surround an element from another partition e.g. partition B in the ordered output. One example of indices in a non contiguously partitioned index state would be 0 2 4 1 3 5 .

In one embodiment query operators are each categorized into one of a plurality of categories or query types based on the index states of the input data that are appropriate or admissible for the query operator. For each query operator that is to be executed the processors A and B determine query type information A and B respectively for that query operator. In one embodiment the index state information A and B and the query type information A and B is used by the processors A and B respectively to eliminate or reduce the cost of index correction e.g. deciding whether an index corrective action should be performed and choosing the least costly algorithm to perform index corrections .

In one embodiment for each query operator admissible index state information A and B is provided to the processors A and B respectively for that query operator. The admissible index state information A and B for a query operator defines what index states are admissible in order for the operator to function correctly and produce correct output data. For example a WHERE query operator with an index dependent predicate should know the exact position of each element in the sequence in order to decide whether the element passes the filter or not so the indices should be normalized but do not have to be ordered. A WHERE query operator with an index independent predicate does not depend on element ordering so the indices can be in any index state. A TAKE operator can function with indices in any index state but it can be implemented more efficiently with indices in an ordered or normalized index state and even more efficiently when the indices are both ordered and normalized.

In one embodiment processors A and B are each configured to track how the execution of each query operator changes the index state of the indices and update the index state information A and B accordingly. For example a SELECT query operator will not degrade the index state. A WHERE query operator will degrade a normalized index state to a non normalized index state note that the indices will remain ordered if they were ordered at the input to WHERE but there may be missing indices . A REVERSE query operator will degrade an ordered index state to a non ordered index state. A SORT query operator may degrade the index state to non normalized non ordered and non contiguously partitioned in implementations where the sort is deferred until the merge phase. Other embodiments may eagerly sort which would yield immediately correct normalized indices.

In one embodiment when there is a mismatch between the admissible index states indicated by information A and B of a query operator that is about to be executed and the actual index state of the indices indicated by information A and B actions to correct the mismatch are performed by one or more of processors A and B. In one embodiment if the indices are non normalized non ordered and non contiguously partitioned all of the indices are fully sorted or reordered in order to correct the mismatch. However if the indices are ordered the elements within each partition A and B are already sorted so a more efficient merge is performed for this case in one embodiment. If the indices are ordered and contiguously partitioned then the indices within one or more of the partitions A and B are sorted in one embodiment instead of doing a complete sorting of all of the indices .

In one embodiment cases where the sequence order is undefined for example because it was produced by an operator with an undefined output order e.g. produced by a UNION operator are handled by the rest of the query as a special case where indices are absent and any output order is admissible. In another embodiment indices are assigned greedily to elements starting from zero and incrementing and the indices are treated as normalized and ordered by the rest of the query.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

