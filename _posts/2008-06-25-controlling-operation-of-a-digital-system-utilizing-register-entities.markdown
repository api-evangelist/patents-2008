---

title: Controlling operation of a digital system utilizing register entities
abstract: In at least one hardware definition language (HDL) file, at least one design entity containing a functional portion of a digital system is specified. The design entity logically contains first and second latches each having a respective plurality of different possible latch values. With one or more statements, a first Dial instance is associated with the first latch and a second Dial instance is associated with the second latch. A setting of the first Dial instance thus controls which of the plurality of different possible values is loaded in the first latch, and a setting of the second Dial instance controls which of the plurality of different possible values is loaded in the second latch. With a statement, a Register instance is concurrently associated with both the first and the second latches, such that a setting of the Register instance controls the latch values loaded in both the first and second latches.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07921389&OS=07921389&RS=07921389
owner: International Business Machines Corporation
number: 07921389
owner_city: Armonk
owner_country: US
publication_date: 20080625
---
The present application is a continuation of U.S. patent application Ser. No. 11 552 306 filed on Oct. 24 2006 entitled Method System and Program Product for Specifying and Using Register Entities to Configure a Simulated or Physical Digital System . Applicants hereby claim benefit of priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 11 552 306 which is incorporated by reference herein in its entirety and for all purposes. The present application is related to U.S. patent application Ser. No. 10 425 079 issued May 2 2006 as U.S. Pat. No. 7 039 894 which is assigned to the assignee of the present invention and incorporated herein by reference in its entirety.

The present invention relates in general to designing simulating and configuring digital devices modules and systems and in particular to methods and systems for computer aided design simulation and configuration of digital devices modules and systems described by a hardware description language HDL model.

In a typical digital design process verifying the logical correctness of a digital design and debugging the design if necessary are important steps of the design process performed prior to developing a circuit layout. Although it is certainly possible to test a digital design by actually building the digital design digital designs particularly those implemented by integrated circuitry are typically verified and debugged by simulating the digital design on a computer due in part to the time and expense required for integrated circuit fabrication.

In a typical automated design process a circuit designer enters into an electronic computer aided design ECAD system a high level description of the digital design to be simulated utilizing a hardware description language HDL such as VHDL thus producing a digital representation of the various circuit blocks and their interconnections. In the digital representation the overall circuit design is frequently divided into smaller parts hereinafter referred to as design entities which are individually designed often by different designers and then combined in a hierarchical manner to create an overall model. This hierarchical design technique is very useful in managing the enormous complexity of the overall design and facilitates error detection during simulation.

The ECAD system compiles the digital representation of the design into a simulation model having a format best suited for simulation. A simulator then exercises the simulation model to detect logical errors in the digital design.

A simulator is typically a software tool that operates on the simulation model by applying a list of input stimuli representing inputs of the digital system. The simulator generates a numerical representation of the response of the circuit to the input stimuli which response may then either be viewed on the display screen as a list of values or further interpreted often by a separate software program and presented on the display screen in graphical form. The simulator may be run either on a general purpose computer or on another piece of electronic apparatus specially designed for simulation. Simulators that run entirely in software on a general purpose computer are referred to as software simulators and simulators that run with the assistance of specially designed electronic apparatus are referred to as hardware simulators. 

As digital designs have become increasingly complex digital designs are commonly simulated at several levels of abstraction for example at functional logical and circuit levels. At the functional level system operation is described in terms of a sequence of transactions between registers adders memories and other functional units. Simulation at the functional level is utilized to verify the high level design of digital systems. At the logical level a digital system is described in terms of logic elements such as logic gates and flip flops. Simulation at the logical level is utilized to verify the correctness of the logic design. At the circuit level each logic gate is described in terms of its circuit components such as transistors impedances capacitances and other such devices. Simulation at the circuit level provides detailed information about voltage levels and switching speeds.

In order to verify the results of any given simulation run custom developed programs written in high level languages such as C or C referred to as a reference model are written to process input stimuli also referred to as test vectors to produce expected results of the simulation run. The test vector is then run against the simulation execution model by the simulator. The results of the simulation run are then compared to the results predicted by the reference model to detect discrepancies which are flagged as errors. Such a simulation check is known in the verification art as an end to end check.

In modern data processing systems especially large server class computer systems the number of latches that must be loaded to configure the system for operation or simulation is increasing dramatically. One reason for the increase in configuration latches is that many chips are being designed to support multiple different configurations and operating modes in order to improve manufacturer profit margins and simplify system design. For example memory controllers commonly require substantial configuration information to properly interface memory cards of different types sizes and operating frequencies.

A second reason for the increase in configuration latches is the ever increasing transistor budget within processors and other integrated circuit chips. Often the additional transistors available within the next generation of chips are devoted to replicated copies of existing functional units in order to improve fault tolerance and parallelism. However because transmission latency via intra chip wiring is not decreasing proportionally to the increase in the operating frequency of functional logic it is generally viewed as undesirable to centralize configuration latches for all similar functional units. Consequently even though all instances of a replicated functional unit are frequently identically configured each instance tends to be designed with its own copy of the configuration latches. Thus configuring an operating parameter having only a few valid values e.g. the ratio between the bus clock frequency and processor clock frequency may involve setting hundreds of configuration latches in a processor chip.

Conventionally configuration latches and their permitted range of values have been specified by error prone paper documentation that is tedious to create and maintain. Compounding the difficulty in maintaining accurate configuration documentation and the effort required to set configuration latches is the fact that different constituencies within a single company e.g. a functional simulation team a laboratory debug team and one or more customer firmware teams often separately develop configuration software from the configuration documentation. As the configuration software is separately developed by each constituency each team may introduce its own errors and employ its own terminology and naming conventions. Consequently the configuration software developed by the different teams is not compatible and cannot easily be shared between the different teams.

In addition to the foregoing shortcomings in the process of developing configuration code conventional configuration software is extremely tedious to code. In particular the vocabulary used to document the various configuration bits is often quite cumbersome. For example in at least some implementations configuration code must specify for each configuration latch bit a full latch name which may include fifty or more ASCII characters. In addition valid binary bit patterns for each group of configuration latches must be individually specified.

In view of the foregoing the present invention appreciates that it would be useful and desirable to provide an improved method of configuring a digital system described by an HDL model particularly one that permits configuration information to be specified in a logical manner with a reasonable amount of input and then shared among the various organizational constituencies involved in the design simulation and commercial implementation of the digital system.

Improved methods systems and program products for specifying the configuration of a digital system such as an integrated circuit or collection of interconnected integrated circuits are disclosed. According to one method at least one design entity containing a functional portion of a digital system is specified in at least one hardware definition language HDL file. The design entity logically contains first and second latches each having a respective plurality of different possible latch values. With one or more statements a first Dial instance is associated with the first latch and a second Dial instance is associated with the second latch. A setting of the first Dial instance thus controls which of the plurality of different possible values is loaded in the first latch and a setting of the second Dial instance controls which of the plurality of different possible values is loaded in the second latch. With a statement a Register instance is concurrently associated with both the first and the second latches such that a setting of the Register instance controls the latch values loaded in both the first and second latches.

All objects features and advantages of the present invention will become apparent in the following detailed written description.

The present invention employs a configuration specification language and associated methods systems and program products for configuring and controlling the setup of a digital system e.g. one or more integrated circuits or a simulation model thereof . In at least one embodiment configuration specifications for signals in the digital system are created in HDL code by the designer responsible for an associated design entity. Thus designers at the front end of the design process who are best able to specify the signal names and associated legal values are responsible for creating the configuration specification. The configuration specification is compiled at model build time together with the HDL describing the digital system to obtain a configuration database that can then be utilized by downstream organizational groups involved in the design simulation and hardware implementation processes.

With reference now to the figures and in particular with reference to there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized for example as a workstation server or mainframe computer.

As illustrated data processing system includes one or more processing nodes which if more than one processing node is implemented are interconnected by node interconnect . Processing nodes may each include one or more processors a local interconnect and a system memory that is accessed via a memory controller . Processors are preferably but not necessarily identical and may comprise a processor within the PowerPC line of processors available from International Business Machines IBM Corporation of Armonk N.Y. In addition to the registers instruction flow logic and execution units utilized to execute program instructions which are generally designated as processor core each of processors also includes an on chip cache hierarchy that is utilized to stage data to the associated processor core from system memories . Each of processing nodes further includes a respective node controller coupled between local interconnect and node interconnect . Each node controller serves as a local agent for remote processing nodes by performing at least two functions. First each node controller snoops the associated local interconnect and facilitates the transmission of local communication transactions to remote processing nodes . Second each node controller snoops communication transactions on node interconnect and masters relevant communication transactions on the associated local interconnect . Communication on each local interconnect is controlled by an arbiter . Arbiters regulate access to local interconnects based on bus request signals generated by processors and compile coherency responses for snooped communication transactions on local interconnects .

Local interconnect is coupled via mezzanine bus bridge to a mezzanine bus . Mezzanine bus bridge provides both a low latency path through which processors may directly access devices among I O devices and storage devices that are mapped to bus memory and or I O address spaces and a high bandwidth path through which I O devices and storage devices may access system memory . I O devices may include for example a display device a keyboard a graphical pointer and serial and parallel ports for connection to external networks or attached devices. Storage devices may include for example optical or magnetic disks that provide non volatile storage for operating system middleware and application software. In the present embodiment such application software includes an ECAD system which can be utilized to develop verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.

Simulated digital circuit design models created utilizing ECAD system are comprised of at least one and usually many sub units referred to hereinafter as design entities. Referring now to there is illustrated a block diagram representation of an exemplary design entity which may be created utilizing ECAD system . Design entity is defined by a number of components an entity name entity ports and a representation of the function performed by design entity . Each design entity within a given model has a unique entity name not explicitly shown in that is declared in the HDL description of the design entity. Furthermore each design entity typically contains a number of signal interconnections known as ports to signals outside the design entity. These outside signals may be primary input outputs I Os of an overall design or signals connected to other design entities within an overall design.

Typically ports are categorized as belonging to one of three distinct types input ports output ports and bi directional ports. Design entity is depicted as having a number of input ports that convey signals into design entity . Input ports are connected to input signals . In addition design entity includes a number of output ports that convey signals out of design entity . Output ports are connected to a set of output signals . Bi directional ports are utilized to convey signals into and out of design entity . Bi directional ports are in turn connected to a set of bi directional signals . A design entity such as design entity need not contain ports of all three types and in the degenerate case contains no ports at all. To accomplish the connection of entity ports to external signals a mapping technique known as a port map is utilized. A port map not explicitly depicted in consists of a specified correspondence between entity port names and external signals to which the entity is connected. When building a simulation model ECAD software is utilized to connect external signals to appropriate ports of the entity according to a port map specification.

As further illustrated in design entity contains a body section that describes one or more functions performed by design entity . In the case of a digital design body section contains an interconnection of logic gates storage elements etc. in addition to instantiations of other entities. By instantiating an entity within another entity a hierarchical description of an overall design is achieved. For example a microprocessor may contain multiple instances of an identical functional unit. As such the microprocessor itself will often be modeled as a single entity. Within the microprocessor entity multiple instantiations of any duplicated functional entities will be present.

Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.

With reference now to there is illustrated a diagrammatic representation of an exemplary simulation model that may be employed by ECAD system to represent a digital design e.g. an integrated circuit chip or a computer system in a preferred embodiment of the present invention. For visual simplicity and clarity the ports and signals interconnecting the design entities within simulation model have not been explicitly shown.

Simulation model includes a number of hierarchically arranged design entities. As within any simulation model simulation model includes one and only one top level entity encompassing all other entities within simulation model . That is to say top level entity instantiates either directly or indirectly all descendant entities within the digital design. Specifically top level entity directly instantiates i.e. is the direct ancestor of two instances and of the same FiXed point execution Unit FXU entity and a single instance of a Floating Point Unit FPU entity . FXU entity instances having instantiation names FXU and FXU respectively in turn instantiate additional design entities including multiple instantiations of entity A having instantiation names A and A respectively.

Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name which must be unique among all descendants of the direct ancestor entity if any. For example top level entity has a description including an entity name i.e. the TOP preceding the colon and also includes an instantiation name i.e. the TOP following the colon . Within an entity description it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example single instances of entity B and entity C instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However this naming convention is not required by the present invention as shown by FPU entity i.e. the instantiation name is FPU while the entity name is FPU .

The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity provided that all entities instantiated whether singly or multiply have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.

Associated with each design entity instantiation is a so called instantiation identifier . The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top level entity instantiation name. For example the design instantiation identifier of instantiation of entity C within instantiation of FXU entity is TOP.FXU.B.C . This instantiation identifier serves to uniquely identify each instantiation within a simulation model.

As discussed above a digital design whether realized utilizing physical integrated circuitry or as a software model such as simulation model typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies which employ stand alone configuration software created after a design is realized to load values into the configuration latches the present invention introduces a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design as illustrated in or in one or more external configuration files referenced by the one or more HDL files specifying the digital design as depicted in .

Referring now to there is depicted an exemplary HDL file in this case a VHDL file including embedded configuration statements in accordance with the present invention. In this example HDL file specifies entity A of simulation model and includes three sections of VHDL code namely a port list that specifies ports and signal declarations that specify the signals within body section and a design specification that specifies the logic and functionality of body section . Interspersed within these sections are conventional VHDL comments denoted by an initial double dash . In addition embedded within design specification are one or more configuration specification statements in accordance with the present invention which are collectively denoted by reference numerals and . As shown these configuration specification statements are written in a special comment form beginning with in order to permit a compiler to easily distinguish the configuration specification statements from the conventional HDL code and HDL comments. Configuration specification statements preferably employ a syntax that is insensitive to case and white space.

With reference now to there is illustrated an exemplary HDL file that includes a reference to an external configuration file containing one or more configuration specification statements in accordance with the present invention. As indicated by prime notation HDL file is identical to HDL file in all respects except that configuration specification statements are replaced with one or more and in this case only one configuration file reference statement referencing a separate configuration file containing configuration specification statements .

Configuration file reference statement like the embedded configuration specification statements illustrated in is identified as a configuration statement by the identifier . Configuration file reference statement includes the directive cfg file which instructs the compiler to locate a separate configuration file and the filename of the configuration file i.e. file . Configuration files such as configuration file preferably all employ a selected filename extension e.g. .cfg so that they can be easily located organized and managed within the file system employed by data processing system .

As discussed further below with reference to configuration specification statements whether embedded within an HDL file or collected in one or more configuration files are processed by a compiler together with the associated HDL files.

In accordance with a preferred embodiment of the present invention configuration specification statements such as configuration specification statements facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a Dial. A Dial s function is to map between an input value and one or more output values. In general such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently by virtue of their association with particular design entities which all have unique instantiation identifiers Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent many different types of Dials can be defined beginning with a Latch Dial or LDial .

Referring now to there is depicted a representation of an exemplary LDial . In this particular example LDial which has the name bus ratio is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.

As illustrated LDial like all Dials logically has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . That is mapping table specifies a one to one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches each output of LDial logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations each configuration latch is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .

At input LDial receives an enumerated input value i.e. a string among a set of legal values including 2 1 3 1 and 4 1 . The enumerated input value can be provided directly by software e.g. by a software simulator or service processor firmware or can be provided by the output of another Dial as discussed further below with respect to . For each enumerated input value the mapping table of LDial indicates a selected binary value i.e. 0 or 1 for each configuration latch .

With reference now to there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model of which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model of illustrates two properties of Dials namely replication and scope.

Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example in order to instantiate the six instances of LDials illustrated in the designer need only code two LDial configuration specification statements utilizing either of the two techniques illustrated in . That is the designer codes a first LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity A in order to automatically instantiate LDials and within entity A instantiations and respectively. The designer codes a second LDial configuration specification statement or configuration file reference statement pointing to an associated configuration file into the HDL file of design entity FXU in order to automatically instantiate LDials and within FXU entity instantiations and respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values different instances of the same Dial can be set to generate different outputs by providing them different inputs.

The scope of a Dial is defined herein as the set of entities to which the Dial can refer in its specification. By convention the scope of a Dial comprises the design entity with which the Dial is associated i.e. the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated and any design entity contained within the associated design entity i.e. the associated design entity and its descendents . Thus a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated but can also specify configuration latches at any lower level of the design hierarchy within its scope. For example LDials and even though associated with FXU entity instantiations and respectively can specify configuration latches within entity C instantiations and respectively.

Referring now to there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of .

As shown simulation model of includes an LDial associated with top level design entity . LDial specifies the signal states of each signal sig which is determined by a respective configuration latch the signal states of each signal sig which is determined by a respective configuration latch the signal state of signal sig which is determined by configuration latch and the signal state of signal sig which is determined by configuration latch . Thus LDial configures the signal states of numerous different signals which are all instantiated at or below the hierarchy level of LDial which is the top level .

As discussed above with respect to LDial is instantiated within top level entity of simulation model by embedding within the HDL file of top level entity a configuration specification statement specifying LDial or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case an exemplary configuration specification statement for LDial is as follows 

The exemplary configuration specification statement given above begins with the keyword LDial which specifies that the type of Dial being declared is an LDial and the Dial name which in this case is bus ratio. Next the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above the signal identifier for each signal is specified hierarchically e.g. FXU.A.SIG for signal relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Several different syntaxes can be employed to specify the signal states. In the example given above signal states are specified in either binary format which specifies a binary constant preceded by the prefix 0b or in hexadecimal format which specifies a hexadecimal constant preceded by the prefix 0x . Although not shown signal states can also be specified in integer format in which case no prefix is employed. For ease of data entry the configuration specification language of ECAD system also preferably supports a concatenated syntax in which one constant value which is automatically extended with leading zeros is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax the mapping table of the configuration specification statement given above can be rewritten as 

With reference now to there is illustrated a diagrammatic representation of a special case of an LDial having a one bit output which is defined herein as a Switch. As shown a Switch has a single input a single 1 bit output that controls the setting of a configuration latch and a mapping table that maps each enumerated input value that may be received at input to a 1 bit output value driven on output .

Because Switches frequently comprise a significant majority of the Dials employed in a digital design it is preferable if the enumerated value sets for all Switches in a simulation model of a digital design are the same e.g. ON OFF . In a typical embodiment of a Switch the positive enumerated input value e.g. ON is mapped by mapping table to an output value of 0b1 and the negative enumerated input value e.g. OFF is mapped to an output value of 0b0. In order to facilitate use of logic of the opposite polarity a Negative Switch or NSwitch declaration is also preferably supported that reverses this default correspondence between input values and output values in mapping table .

The central advantage to defining a Switch primitive is a reduction in the amount of input that designers are required to enter. In particular to specify a comparable 1 bit LDial a designer would be required to enter a configuration specification statement of the form 

Referring now to there is depicted a diagrammatic representation of an Integer Dial IDial in accordance with a preferred embodiment of the present invention. Like an LDial an IDial directly specifies the value loaded into each of one or more configuration latches by indicating within mapping table a correspondence between each input value received at an input and an output value for each output . However unlike LDials which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables the legal input value set of an IDial includes all possible integer values within the bit size of output . Input integer values containing fewer bits than the bit size of output s are right justified and extended with zeros to fill all available bits. Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table mapping table simply indicates the manner in which the integer input value received at input is applied to the one or more outputs .

IDials are ideally suited for applications in which one or more multi bit registers must be initialized and the number of legal values includes most values of the register s . For example if a 4 bit configuration register comprising 4 configuration latches and an 11 bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial the designer would have to explicitly enumerate up to 2input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement 

IDials may also be utilized to specify the same value for multiple replicated configuration registers as depicted in . In the illustrated embodiment an IDial which can be described as an IDial splitter specifies the configuration of three sets of replicated configuration registers each comprising 15 configuration latches based upon a single 15 bit integer input value. An exemplary configuration specification statement for instantiating IDial may be given as follows 

Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials in many cases it would be inefficient and inconvenient to do so. In particular for hierarchical digital designs such as that illustrated in the use of LDials and or IDials alone would force many Dials to higher levels of the design hierarchy which from an organizational standpoint may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result proper configuration of the configuration latches would require not only significant organizational coordination between design groups but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.

In view of the foregoing the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower level Dials and control of the lower level Dials by one or more higher level Dials. The configuration specification language of the present invention terms a higher level Dial that controls one more lower level Dials as a Control Dial CDial .

Referring now to there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial like all Dials preferably has a single input one or more outputs and a mapping table that maps each input value to a respective associated output value for each output . Unlike LDials and IDials which directly specify configuration latches a CDial does not directly specify configuration latches. Instead a CDial controls one or more other Dials i.e. CDials and or LDials and or IDials logically coupled to CDial in an n way Dial tree in which each lower level Dial forms at least a portion of a branch that ultimately terminates in leaves of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.

In the exemplary embodiment given in CDial receives at input an enumerated input value i.e. a string among a set of legal values including A . . . N . If CDial or an LDial or IDial is a top level Dial i.e. there are no Dials above it in a Dial tree CDial receives the enumerated input value directly from software e.g. simulation software or firmware . Alternatively if CDial forms part of a branch of a dial tree then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input CDial specifies a selected enumerated value or bit value for each connected Dial e.g. Dials and in mapping table . The values in mapping table associated with each output are interpreted by ECAD system in accordance with the type of lower level Dial coupled to the output . That is values specified for LDials and CDials are interpreted as enumerated values while values specified for IDials are interpreted as integer values. With these values each of Dials and ultimately specifies either directly or indirectly the values for one or more configuration latches .

With reference now to there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top level CDial that controls multiple lower level LDials. As indicated by prime notation simulation model of includes the same design entities arranged in the same hierarchical relation as simulation model of and contains the same configuration latches and associated signals as simulation model of .

As shown simulation model of includes a top level CDial associated with top level design entity . Simulation model further includes four LDials and . LDial which is associated with entity instantiation A controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is a replication of LDial associated with entity instantiation A similarly controls the signal states of each signal sig which is determined by a respective configuration latch and the signal state of signal sig which is determined by configuration latch . LDial which is associated with top level entity controls the signal state of signal sig which is determined by configuration latch . Finally LDial which is associated with entity instantiation FPU controls the signal state of signal sig which is determined by configuration latch . Each of these four LDials is controlled by CDial associated with top level entity .

As discussed above with respect to CDial and each of the four LDials depicted in is instantiated within the associated design entity by embedding a configuration specification statement or a configuration file reference statement pointing to a configuration file containing a configuration specification statement within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in is given below 

By implementing a hierarchical Dial tree in this manner several advantages are realized. First the amount of software code that must be entered is reduced since the automatic replication of LDials within FXU entity instantiations and allows the code specifying LDials to be entered only once. Second the organizational boundaries of the design process are respected by allowing each designer or design team to specify the configuration of signals within the design entity for which he is responsible. Third coding of upper level Dials i.e. CDial is greatly simplified reducing the likelihood of errors. Thus for example the CDial and LDial collection specified immediately above performs the same function as the large LDial specified above with reference to but with much less complexity in any one Dial.

Many Dials for example Switches utilized to disable a particular design entity in the event an uncorrectable error is detected have a particular input value that the Dial should have in nearly all circumstances. For such Dials the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment a Default value is specified by including default value following the specification of a Dial and prior to the concluding semicolon. For example a default value for a CDial can be given as follows 

The configuration specification language of the present invention also permits control of the time at which particular default values are applied. Control of the application of defaults is important for example in simulating or executing in hardware the boot sequence for an integrated circuit. During the initial stages of the boot sequence the clock signals to different sections of the integrated circuit may be started at different times meaning that latches in different sections of the integrated circuit must be loaded at different times in accordance with the specified Dial default values.

In accordance with the present invention control of the timing of the application of default values is supported through the association of one or more phase identifiers IDs with a default value. Phase IDs are strings that label collections of Dials to which default values should be applied substantially concurrently. Multiple phase IDs may be associated with a particular Dial to promote flexibility. For example indifferent system configurations the boot sequence for a constituent integrated circuit may be different. Accordingly it may be necessary or desirable to apply a default value to a particular Dial during different phases depending upon the system configuration.

In one exemplary syntax one or more phase IDs e.g. phaseid and phaseid can optionally be specified in a comma delimited list enclosed by parenthesis and following a default declaration in a Dial declaration statement as follows 

The use of default values for Dials is subject to a number of rules. First a default value may be specified for any type of Dial including LDials IDials including those with split outputs and CDials. Default values are preferably not supported for Dial groups which are discussed below with respect to . Second if default values are specified for multiple Dials in a multiple level Dial tree only the highest level default value affecting each branch of the Dial tree is applied including that specified for the top level Dial and the remaining default values if any are ignored. Despite this rule it is nevertheless beneficial to specify default values for lower level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated as discussed above. In the event that the combination of default values specified for lower level Dials forming the branches of a Dial tree do not correspond to a legal output value set for a higher level Dial the compiler will flag an error. Third a default value is overridden when a Dial receives an input to actively set the Dial.

By specifying default values for Dials a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition as discussed further below use of default values assists in auditing which Dials have been actively set.

In at least one embodiment of the present invention the configuration specification language of the present invention supports the definition and use of an additional construct referred to herein as a Register. A Register associates a logical name with an arbitrary collection of latches thus permitting the values of the latches to be set and read by reference to the logical name. In this regard Registers are similar to the Dials described above. However unlike the LDials and IDials described above Registers can include latches that are referenced by other Dials such as LDials and IDials as well as latches that are not referenced by any Dial .

Referring now to there is illustrated a diagrammatic representation of a Register in accordance with the present invention. Register has an input and one or more one bit outputs e.g. outputs . As shown outputs of Register are each logically coupled to a respective one of one bit latches . Of these latches latches are logically coupled to a Dial tree having CDial as the top level Dial. In addition latches are logically coupled to an LDial and latches are logically coupled to an IDial . Latches are not referenced by any Dial.

The illustrated arrangement of Register and Dials and advantageously permits latches to be set and read utilizing the most convenient conceptualization of latches . It is often the case that a collection of latches such as latches are conveniently conceptualized as a number of different subfields which may for example derive their values from different sources represent different data types e.g. integer or enumerated value have different ranges of legal values etc. Thus by employing multiple Dials to delineate some or all of the subfields the legal values and data types of the subfields can be efficiently documented within the code defining an HDL model.

On the other hand certain constituencies involved in the development of a digital design may find it more convenient to conceptualize and access latches as a monolithic entity which in this case is Register . For example because code that addresses latches as a plurality of different subfields and therefore accesses latches via Dials is larger than code that addresses latches as a monolithic register firmware developers and others interested in minimizing the size of the code image may prefer to access latches as Register and leave it to the human user to perform the combination of the subfields needed to obtain the sequence of bits comprising the Register value.

Although a wide variety of syntax may be employed to declare a Register exemplary syntax for a Register declaration statement utilized to declare a Register within an HDL file or configuration file may be given as follows 

As with the Dials described above a variety of rule sets can be constructed to define the permitted uses and functions of Registers. In one exemplary embodiment the following rules are enforced for Registers by the model build process described below with respect to 

In addition to defining syntax for configuration specification statements specifying Dials and Registers the configuration specification language of the present invention supports at least two additional HDL semantic constructs comments and attribute specification statements. A comment which may have the form 

Attribute specification statements are statements that declare an attribute name and attribute value and associate the attribute name with a particular entity name. For example an attribute specification statement may have the form 

Referring now to there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files which include configuration specification statements and or configuration file reference statements and optionally one or more configuration specification reference files . HDL compiler processes HDL file s and configuration specification file s if any beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file s describing a complete simulation model. As HDL compiler processes each HDL file HDL compiler creates markers in the design intermediate files produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.

Thereafter the design intermediate files in memory are processed by a configuration compiler and model build tool to complete the model build process. Model build tool processes design intermediate files into a simulation executable model that when executed models the logical functions of the digital design which may represent for example a portion of an integrated circuit an entire integrated circuit or module or a digital system including multiple integrated circuits or modules. Configuration compiler processes the configuration specification statements marked in design intermediate files and creates from those statements a configuration documentation file and a configuration database .

Configuration documentation file lists in human readable format information describing the Dials associated with the simulation model. The information includes the Dials names their mapping tables the structure of Dial trees if any instance information etc. In addition as noted above configuration documentation file includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a bottom up fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design simulation laboratory hardware evaluation and commercial hardware implementation of the digital design.

Configuration database contains a number of data structures pertaining to Dials. As described in detail below these data structures include Dial data structures describing Dial entities latch data structures and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design i.e. simulation executable model . In a preferred embodiment the configuration values can be specified in terms of either signal states or configuration latch values and the selection of which values are used is user selectable. Configuration database is accessed via Application Programming Interface API routines during simulation of the digital design utilizing simulation executable model and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment the APIs are designed so that only top level Dials i.e. LDials HDials or CDials without a CDial logically above them can be set and all Dial values can be read.

As described above the configuration specification language of the present invention advantageously permits the specification of the output values of LDials and IDials by reference to signal names e.g. sig . As noted above a key motivation for this feature is that designers tend to think in terms of configuring operative signals to particular signal states rather than configuring the associated configuration latches. In practice however a signal that a designer desires to configure to a particular state may not be directly connected to the output of an associated configuration latch. Instead a signal to be configured may be coupled to an associated configuration latch through one or more intermediate circuit elements such as buffers and inverters. Rather than burdening the designer with manually tracing back each configurable signal to an associated configuration latch and then determining an appropriate value for the configuration latch configuration compiler automatically traces back a specified signal to the first storage element i.e. configuration latch coupled to the signal and performs any necessary inversions of the designer specified signal state value to obtain the proper value to load into the configuration latch.

With reference now to there is illustrated a portion of a digital design including an LDial that controls the states of a plurality of signals within the digital design. When configuration compiler performs a traceback of signal no inversion of the designer specified signal states is required because signal is directly connected to configuration latch . Accordingly configuration compiler stores into configuration database the designer specified values from the configuration specification statement of LDial as the values to be loaded into configuration latch . Traceback of signal to configuration latch similarly does not result in the inversion of any designer specified values from the configuration specification statement of LDial because the only intervening element between signal and configuration register is a non inverting buffer .

Configuration latches such as configuration latches and are frequently instantiated by designers through inclusion in an HDL file of an HDL statement referencing a latch primitive in an HDL design library. The latch entity inserted into the simulation executable model in response to such HDL library references may include inverters such as inverters which are not explicitly visible to the designer in the HDL code. The automatic traceback performed by configuration compiler nevertheless detects these inverters thus preventing possible configuration errors.

Accordingly when performing a traceback of signal configuration compiler automatically inverts the designer specified configuration value specified for signal before storing the configuration value for configuration latch in configuration database because of the presence of an inverter between signal and configuration latch . When configuration compiler performs traceback of signal however configuration compiler does not invert the designer specified signal state values despite the presence of inverters and buffer in the signal path because the logic is collectively non inverting. It should be noted that configuration compiler can accurately process both hidden inverters like inverter and explicitly declared inverters like inverter .

Referring now to there is depicted a high level logical flowchart of the traceback process implemented by configuration compiler for each signal name specified in a configuration specification statement. As shown the process begins at block and then proceeds to block which illustrate configuration compiler initializing an inversion count to zero and then locating the signal identified by the signal name specified in a configuration specification statement.

The process then enters a loop comprising blocks which collectively represent configuration compiler tracing back the specified signal to the first latch element in the signal path. Specifically as illustrated at blocks configuration compiler determines whether the next upstream circuit element in the signal path is a latch buffer or inverter . If the circuit element is a latch the process exits the loop and passes to block which is described below. If however the circuit element is a buffer the process passes to block which illustrates configuration compiler moving to the next upstream circuit element to be processed without incrementing the inversion count. If the circuit element is an inverter the process passes to blocks and which depicts incrementing the inversion count and then moving to the next upstream circuit element to be processed. In this manner configuration compiler traces back a specified signal to a configuration latch while determining a number of inversions of signal state implemented by the circuit elements in the path. As noted above if configuration compiler detects a circuit element other than a buffer or inverter in the signal path configuration compiler preferably flags an error as shown at block . The process thereafter terminates at block .

Following detection of a configuration latch at block configuration compiler determines whether the inversion count is odd or even. As shown at blocks if the inversion count is odd configuration compiler inverts the designer specified configuration values for the signal at block prior to inserting the values into configuration database . No inversion is performed prior to inserting the configuration values into configuration database if the inversion count is even. The process thereafter terminates at block .

As has been described the present invention provides a configuration specification language that permits a designer of a digital system to specify a configuration for the digital system utilizing configuration statements embedded in the HDL design files describing the digital system. The configuration statements logically instantiate within the digital design one or more Dials which provide configuration values for the digital design in response to particular inputs. The Dials like the design entities comprising the digital design may be hierarchically arranged. The configuration specification statements are compiled together with the HDL files describing the digital design to produce a configuration database that may be accessed to configure a simulation executable model or after appropriate transformations a physical realization of the digital design. The compilation of the configuration specification statements preferably supports a traceback process in which designer specified configuration values for a signal are inverted in response to detection of an odd number of inverters coupled between the signal and an associated configuration latch.

With reference again to recall that an exemplary configuration specification statement for LDial includes a parenthetical signal enumeration of the form 

In order to reduce the amount of input required to input the signal or Dial enumeration sections of configuration specification statements and to reduce the burden of code maintenance as new signal and Dial instances are added to the digital design an ECAD system in accordance with the present invention also supports a compact expression syntax for the signal or Dial enumeration sections of configuration specification statements. This syntax is referred to herein more specifically as compact signal expression when applied to the configuration specification statements of LDials and IDials and is referred to as compact Dial expression when referring to the configuration specification statements of CDials.

In a compact expression of a signal or Dial enumeration all instances of an entity within a selected scope for which a common configuration is desired can be enumerated with a single identifier. For example in if the designer wants a common configuration for all four instantiations of signal sig the designer could enumerate all four instantiations in the configuration specification statement of LDial with the single compact signal expression A .sig where the bracketed term is the name of the entity in which the signal of interest occurs. In compact expressions the default scope of the expression is implied as the scope of the design entity in this case top level entity with which the Dial is associated. The identifier A .sig thus specifies all four instantiations of signal sig within A entity instantiations within the default scope of top level entity .

The scope of the identifier in a compact expression can further be narrowed by explicitly enumerating selected levels of the design hierarchy. For example the compact expression FXU A .sig refers only to signal sig instantiations and within FXU entity instantiation but does not encompass signal sig instantiations and within FXU entity instantiation

Of course when only a single instance of a signal or Dial is instantiated at higher levels of the design hierarchy the compact expression and the full expression will require approximately the same amount of input e.g. FPU.sig versus FPU .sig to identify signal sig . However it should be noted that if another FPU entity were later added to simulation model the compact expression of the identification would advantageously apply to any later added FPU entities within the scope oftop level entity .

Utilizing compact expression the configuration specification statement for LDial can now be rewritten more compactly as follows 

Compact Dial expressions are constructed and parsed by the compiler in the same manner as compact signal expressions. For example the configuration specification statement for CDial of can be rewritten utilizing compact Dial expression as follows 

Referring now to there is depicted a high level logical flowchart of an exemplary method by which configuration compiler parses each signal or Dial identification within a configuration specification statement in accordance with the present invention. As described above each signal or Dial identification is constructed hierarchically from one or more fields separated by periods . . The last field specifies an instance name of a signal e.g. sig or Dial e.g. Bus Ratio and the preceding fields narrow the scope from the default scope which by convention is the scope of the design entity with which the Dial is associated.

As shown the process begins at block and then proceeds to block which illustrates configuration compiler determining whether the first or current field of the signal or Dial identification contains an entity identifier enclosed in brackets e.g. A that is whether the identification is a compact expression. If so the process passes to block which is described below. If not configuration compiler determines at block whether the identification is a full expression by determining whether the first or current field of the identification is the last field of the identification. If so the signal or Dial identification is a full expression and the process passes to block . If on the other hand the current field of the identification is not the last field configuration compiler narrows a current scope to the design entity instantiation identified in the current field of the identification as depicted at block . For example if configuration compiler were processing the identification FPU.SIG within the configuration specification statement of CDial of configuration compiler would narrow the scope from the default scope of top entity to FPU entity instantiation . If the entity instantiation indicated by the current field of the identification exists as shown at block the process returns to block after updating the current field to be the next field as shown at block . If however the entity instantiation specified by the current field does not exist within the current scope configuration compiler flags an error at block and terminates processing of the signal or Dial identification.

Referring again to block when configuration compiler detects that it has reached the last field of a full expression the process shown in passes from block to block . Block illustrates configuration compiler attempting to locate within the current scope the single signal or Dial instance having a name matching that specified in the last field of the signal or Dial identification. If configuration compiler determines at block that no matching instance is found within the current scope the process passes to block and configuration compiler flags an error. However if configuration compiler locates the matching signal or Dial instance then configuration compiler makes an entry in configuration database binding the signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed as shown at block . Thereafter processing of the signal or Dial identification terminates at block .

With reference now to block and following blocks the processing of a signal or Dial identification employing compact expression will now be described. Block depicts configuration compiler attempting to locate within each of one or more instances in the current scope of the entity indicated by the bracketed field each Dial or signal instance matching that specified in the signal or Dial identification. For example when processing the compact expression FXU A .sig for simulation model of configuration compiler upon reaching the field A searches FXU for instantiations of entity A and upon finding entity instantiations and searches within each of these two entity instantiations to locate signals instantiations sig and . If configuration compiler determines at block that no matching signal or Dial instance is found within the current scope the process passes to block which depicts configuration compiler terminating processing of the signal or Dial identification after flagging an error. However if configuration compiler locates one or more matching signal or Dial instances then the process passes from block to block . Block illustrates configuration compiler making one or more entries in configuration database binding each matching signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed. Thereafter processing of the signal or Dial identification terminates at block .

Utilizing the compact expressions supported by the present invention the amount of code a designer must enter in a configuration specification statement can be advantageously reduced. The use of compact expressions not only reduces input requirements and the likelihood of input errors but also simplifies code maintenance through the automatic application of specified configuration parameters to later entered instances of signals and Dials falling within a selected scope.

As described above every Dial has a one to one mapping between each of its input values and a unique output value of the Dial. In other words each input value has a unique output value different than the output value for any other input value. For CDials and LDials the mapping table must explicitly enumerate each legal input value and its associated mapping.

The requirement that the input values must be explicitly enumerated in the mapping table limits the overall complexity of any given LDial or CDial. For example consider the case of an integrated circuit e.g. a memory controller containing 10 to 20 configuration registers each having between 5 and 20 legal values. In many cases these registers have mutual dependencies the value loaded in one register can affect the legal possibilities of one or more of the other registers. Ideally it would be convenient to specify values for all of the registers utilizing a Dial tree controlled by a single CDial. In this manner the configuration of all of the 10 to 20 registers could be controlled as a group.

Unfortunately given the assumptions set forth above the 10 to 20 registers collectively may have over 300 000 legal combinations of values. The specification of a CDial in such a case although theoretically possible is undesirable and practically infeasible. Moreover even if a looping construct could be employed to automate construction of the configuration specification statement of the CDial the configuration specification statement although informing simulation software which input values are legal would not inform users how to set a CDial of this size.

In recognition of the foregoing the configuration specification language of the present invention provides a Dial group construct. A Dial group is a collection of Dials among which the designer desires to create an association. The runtime APIs utilized to provide Dial input values observe this association by preventing the individual Dials within a Dial group from being set individually. In other words all Dials in a Dial group must be set at the same time so that individual Dials are not set independently without concern for the interactions between Dials. Because software enforces an observance of the grouping of the Dials forming a Dial group use of Dial groups also provides a mechanism by which a designer can warn the downstream user community that an unstated set of interdependencies exists between the Dials comprising the Dial group.

With reference now to there is illustrated a diagrammatic representation of a Dial group . A Dial group is defined by a group name e.g. GroupG and a Dial list listing one or more Dials or other Dial groups. Dial groups do not have any inputs or outputs. The Dials listed within Dial list which are all top level Dials may be LDials CDials and or IDials.

One motivation for implementing Dial groups hierarchically is to coordinate configuration of groups of Dials spanning organizational boundaries. For example consider a digital system in which 30 Dials logically belong in a Dial group and 10 of the Dials are contained within a first design entity that is the responsibility of a first designer and 20 of the Dials are contained within a second design entity that is the responsibility of a second designer. Without a hierarchical Dial group a single Dial group explicitly listing all 30 Dials in its Dial list would have to be specified at a higher level of the design hierarchy encompassing both of the first and second design entities. This implementation would be inconvenient in that the designer or design team responsible for the higher level design entity would have to know all of the related Dials in the lower level design entities and specifically identify each of the 30 Dials in the Dial list of the Dial group.

An alternative hierarchical approach would entail creating a first Dial group containing the 10 Dials within the first design entity a second Dial group containing the 20 Dials within the second design entity and a third higher level Dial group that refers to the first and second Dial groups. Importantly the Dial list of the higher level Dial group must only refer to the two lower level Dial groups thus shielding designers responsible for higher levels of the design hierarchy from low level details. In addition code maintenance is reduced since changing which Dials belong to the two lower level Dial groups would not affect the Dial list of the upper level Dial group.

Dial groups are subject to a number of rules. First no Dial or Dial group may be listed in the Dial list of more than one Dial group. Second a Dial group must refer to at least one Dial or other Dial group in its Dial list . Third in its Dial list a Dial group can only refer to Dials or Dial groups within its scope which by convention and like the concept of scope as applied to Dials is that of its associated design entity i.e. the design entity itself and any lower level design entity within the design entity . Fourth each Dial referred to in a Dial list of a Dial group must be a top level Dial.

Referring now to there is depicted an exemplary simulation model illustrating the use of Dial groups. Exemplary simulation model includes a top level design entity having instantiation identifier TOP TOP . Within top level design entity two design entities and are instantiated which have entity names FBC and L2 respectively. FBC entity instantiation in turn instantiates a Dial instance having Dial name C a Z entity instantiation containing a Dial instance having Dial name B and two instantiations of entity X which are respectively named X0 and X1 . Each entity X instantiation contains two entity Y instantiations each further instantiating a Dial instance having Dial name A . L2 entity instantiation contains a Dial instance having Dial name D and two entity L instantiations each containing a Dial instance having Dial name E .

As shown FBC entity instantiation has an associated Dial group instance having a group name F . As indicated by arrows Dial group instance includes each of Dials instances and within FBC entity instantiation . L entity instantiation similarly has an associated Dial group instance that includes each of Dial instances and within L entity instantiation . Both of these Dial group instances in turn belong to a higher level Dial group instance having group name H which is associated with top level design entity .

Each Dial group instance is created by including within the HDL file of the associated design entity an appropriate configuration statement. For example exemplary syntax for configuration statements creating Dial groups F G and H are respectively given as follows 

In each configuration statement a Dial group is declared by the keyword GDial which is followed by string e.g. F representing the group name. Within the parenthesis following the group name the Dial list for the Dial group is specified. As indicated in the configuration statement for Dial group H the Dial list for a hierarchical Dial group specifies other Dial groups in the same manner as Dials. It should also be noted that the compact dial expression syntax discussed above can be employed in specifying Dials or Dial groups in the Dial list as indicated in the configuration statements for Dial groups F and G .

Now that basic types of Dials syntax for their specification and the application and Dial groups have been described a description of an exemplary implementation of configuration database and its use will be provided. To promote understanding of the manner in which particular Dial instantiations or multiple instantiations of a Dial can be accessed in configuration database a nomenclature for Dials within configuration database will be described.

The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity i.e. the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.

Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model e.g. due to replication use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly in a preferred embodiment the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an extended Dial identifier for each Dial within the simulation model.

As an aside it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example conventional VHDL entity naming constructs permit two design entities to share the same entity name entity name. However VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance the entity name is equivalent to the VHDL library name concatenated by a period . to the entity name as declared in the entity declaration. Thus pre pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.

In a preferred embodiment an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields an instantiation identifier field a design entity name and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period . as follows 

In the extended Dial identifier the design entity field contains the entity name of the design entity in which the Dial is instantiated and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers proceeding from the top level entity of the simulation model to the direct ancestor design entity of the given Dial instance with adjacent instance identifiers separated by periods . . Because no design entity can include two Dials of the same name the instantiation identifier is unique for each and every instance of a Dial within the model.

The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier each design entity is in effect given a unique namespace for the Dials associated with that design entity i.e. Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is due to the uniqueness of instantiation identifiers Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However such a naming scheme does not associate Dials with a given design entity. In practice it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.

As noted above use of extended Dial identifiers permits the unique identification of a particular instantiation of a Dial and permits the re use of design entities within any arbitrary model without risk of Dial name collisions. For example referring again to Dial A entity instantiations and can be respectively uniquely identified by the following extended Dial identifiers 

With an understanding of a preferred nomenclature of Dials reference is now made to which is a diagrammatic representation of an exemplary format for a configuration database created by configuration compiler . In this exemplary embodiment configuration database includes at least four different types of data structures Dial definition data structures DDDS Dial instance data structures DIDS latch data structures and top level pointer array . Configuration database may optionally include additional data structures such as Dial pointer array latch pointer array instance pointer array and other data structures depicted in dashed line illustration which may alternatively be constructed in volatile memory when configuration database is loaded as described further below. Generating these additional data structures only after configuration database is loaded into volatile memory advantageously promotes a more compact configuration database .

A respective Dial definition data structure DDDS is created within configuration database for each Dial or Dial group in the digital system. Preferably only one DDDS is created in configuration database regardless of the number of instantiations of the Dial or Dial group in the digital system. As discussed below information regarding particular instantiations of a Dial described in a DDDS is specified in separate DIDSs .

As shown each DDDS includes a type field denoting whether DDDS describes a Dial or Dial group and if a Dial the type of Dial. In one embodiment the value set for type field includes G for Dial group I for integer Dial IDial L for latch Dial LDial and C for control Dial CDial . DDDS further includes a name field which specifies the name of the Dial or Dial group described by DDDS . This field preferably contains the design entity name of the Dial or Dial group followed by a period . followed by the name of Dial or Dial group given in the configuration specification statement of the Dial or Dial group . The contents of name field correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.

DDDS also includes a mapping table that contains the mapping from the input of the given Dial to its output s if required. For LDials and CDials mapping table specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output mapping table is an empty data structure and is not used. In the case of an IDial with a split output mapping table specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields.

Finally DDDS may include an instance pointer array containing one or more instance pointers pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array facilitates access to multiple instances of a particular Dial or Dial group.

As further illustrated in configuration database contains a DIDS corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS contains a definition field containing a definition pointer pointing to the DDDS of the Dial for which the DIDS describes a particular instance. Definition pointer permits the Dial name Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.

DIDS further includes a parent field that in the case of an IDial CDial or LDial contains a parent pointer pointing to the DIDS of the higher level Dial instance if any having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group parent pointer points to the DIDS of the higher level Dial group if any that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS is a top level Dial and does not belong to any Dial group parent pointer in parent field is a NULL pointer. It should be noted that a Dial can be a top level Dial but still belong to a Dial group. In that case parent pointer is not NULL but rather points to the DIDS of the Dial group containing the top level Dial.

Thus parent fields of the DIDSs in configuration database collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described below the hierarchical information provided by parent fields advantageously enables a determination of the input value of any top level Dial given the configuration values of the configuration latches ultimately controlled by that top level Dial.

Instance name field of DIDS gives the fully qualified instance name of the Dial instance described by DIDS from the top level design entity of the digital design. For Dial instances associated with the top level entity instance name field preferably contains a NULL string.

DIDS may further include a default field a phase ID field and a instance set field . At compile time configuration compiler preferably initially inserts a default field into at least each DIDS for which the configuration specification statement for the associated Dial has a default specified. Default field stores the specified default value if no default value is specified default field is NULL or is omitted. Configuration compiler subsequently analyzes configuration database utilizing a recursive traversal and removes or set to NULL the default field of any Dial instance that has an ancestor Dial instance having a default. In this manner default values of Dial instances higher in the hierarchy override defaults specified for lower level Dial instances. For each remaining or non NULL default field configuration compiler inserts into the DIDS a phase ID field for storing one or more phase IDs if any associated with the default value. The phase ID s stored within phase ID field may be specified within a Dial definition statement within an HDL file or configuration specification file or may alternatively be supplied by direct manipulation of configuration database by a downstream user as discussed further below with respect to .

As indicated by dashed line notation a instance set field is preferably inserted within each DIDS in configuration database when configuration database is loaded into volatile memory. instance set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set.

Finally DIDS includes an output pointer array containing pointers pointing to data structures describing the lower level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically in the case of IDials and LDials output pointers refer to latch data structures corresponding to the configuration latches coupled to the Dial instance. For non split IDials the configuration latch entity referred to by output pointer receives the high order bit of the integer input value and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial output pointers refer to other DIDSs corresponding to the Dial instances controlled by the CDial. For Dial groups output pointers refer to the top level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS .

Configuration database further includes a respective latch data structure for each configuration latch in simulation executable model to which an output of an LDial or IDial is logically coupled. Each latch data structure includes a parent field containing a parent pointer to the DIDS of the LDial or IDial directly controlling the corresponding configuration latch. In addition latch data structure includes a latch name field specifying the hierarchical latch name relative to the entity containing the Dial instantiation identified by parent pointer . For example if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name a.b.c.d.latch latch name field will contain the string d.latch . Prepending contents of an instance name field of the DIDS identified by parent pointer to the contents of a latch name field thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .

Still referring to as noted above configuration database includes top level pointer array and optionally Dial pointer array and latch pointer array . Top level pointer array contains top level pointers that for each top level Dial and each top level Dial group points to an associated DIDS for the top level entity instance. Dial pointer array includes Dial pointers pointing to each DDDS in configuration database to permit indirect access to particular Dial instances through Dial and or entity names. Finally latch pointer array includes latch pointers pointing to each latch data structure within configuration database to permit easy access to all configuration latches.

Once a configuration database is constructed the contents of configuration database can be loaded into volatile memory such as system memory of data processing system of in order to appropriately configure a simulation model for simulation. In general data structures and can be loaded directly into system memory and may optionally be augmented with additional fields as described below. However as noted above if it is desirable for the non volatile image of configuration database to be compact it is helpful to generate additional data structures such as Dial pointer array latch pointer array and instance pointer arrays in the volatile configuration database image in system memory .

Referring now to there is illustrated a more detailed view of a portion of an exemplary simulation configuration database including data structures representing Dials and Registers in accordance with the present invention. In order to avoid unnecessary complexity some features of simulation configuration database shown in are omitted from .

Turning now to a consideration of the figure illustrates a latch data structure representing a latch such as configuration latch of that is referenced by both a Dial and a Register. The Dial referencing the latch is represented within simulation configuration database by DIDS as discussed above with respect to . To represent the logical connection between the Dial and the latch latch data structure includes a Dial parent field containing a Dial parent pointer pointing to a DIDS and DIDS includes an output pointer within output pointer array that points to latch data structure to identify the latch as a child of the parent Dial.

The Register referencing the latch is represented within simulation configuration database by DIDS . As indicated by like reference numbers DIDS may advantageously be structured similarly to DIDS in a preferred embodiment. Specifically DIDS includes a definition field containing a definition pointer pointing to a DDDS not shown in that defines a Register entity and accordingly has a type field having the value of R for Register. It should be noted that the DDDS defining the Register entity has a NULL or absent mapping table because Registers do not map input or output values. DIDS may also include an instance name field and an output pointer array as discussed above with respect to . An output pointer within output pointer array of DIDS identifies latch data structure as representing a child latch of the Register. The relationship between the Register and the latch is similarly documented by a Register parent pointer within a Register parent field of latch data structure .

As shown DIDS may also include a parent field default field and phase field as discussed above with respect to . However if the rule set discussed above with respect to is implemented parent field default field and phase ID field are NULL or may be omitted because according to the above given rule set Registers are top level entities that do not have parents and do not permit the use of default values.

In the following description the naming setting and reading of Dial instances and their underlying latches are described in detail. Except where noted below Register instances and their underlying latches which may be shared with Dial instances are accessed in an identical manner by virtue of the common design of the data structures representing the Dial and Register instances in configuration database .

Referring now to there is depicted a high level logical flowchart of a method by which configuration database is expanded within volatile memory of a data processing system such as system memory of data processing system . Because depicts logical steps rather than operational steps it should be understood that many of the steps illustrated in may be performed concurrently or in a different order than that shown.

As illustrated the process begins at block and then proceeds to block which illustrates data processing system copying the existing data structures within configuration database from non volatile storage e.g. disk storage or flash memory into volatile system memory . Next at block a determination is made whether all top level pointers within top level pointer array of configuration database have been processed. If so the process passes to block which is discussed below. If not the process proceeds to block which illustrates selection from top level array of the next top level pointer to be processed.

A determination is then made at block of whether or not parent pointer within the DIDS identified by the selected top level pointer is a NULL pointer. If not which indicates that the DIDS describes a top level Dial belonging to a Dial group the process returns to block indicating that the top level Dial and its associated lower level Dials will be processed when the Dial group to which it belongs is processed.

In response to a determination at block that the parent pointer is a NULL pointer data processing system creates an instance pointer to the DIDS in the instance array of the DDDS to which definition pointer in definition field of DIDS points as depicted at block . Next at block data processing system creates a Dial pointer to the DDDS of the top level Dial within Dial pointer array if the Dial pointer is not redundant. In addition as shown at block data processing system creates a latch pointer within latch pointer array pointing to each latch data structure if any referenced by an output pointer of the DIDS of the top level Dial. As shown at block each branch at each lower level of the Dial tree if any headed by the top level Dial referenced by the selected top level pointer is then processed similarly by performing the functions illustrated at block until a latch data structure terminating that branch is found and processed. The process then returns to block representing the processing of each top level pointer within top level pointer array .

In response to a determination at block that all top level pointers have been processed the process illustrated in proceeds to block . Block illustrates the creation of a instance set field in each DIDS in the configuration database. As noted above instance set field is a Boolean valued field that in initialized to FALSE and is updated to TRUE when the associated Dial or Register instance is explicitly set. In addition as depicted at block data processing system creates a latch value field latch Register set field latch set field and set history field in each latch data structure to respectively indicate the current set value of the associated configuration latch to indicate whether or not the configuration latch is set through the associated Register instance to indicate whether or not the configuration latch is currently set by an explicit set command and to indicate whether or not the configuration latch has ever been explicitly set. Although the creation of the five fields indicated at block is illustrated separately from the processing depicted at blocks for purposes of clarity it will be appreciated that it is more efficient to create instance set field as each DIDS is processed and to create fields and as the latch data structures at the bottom of each Dial or Register tree are reached. The process of loading the configuration database into volatile memory thereafter terminates at block .

With the configuration database loaded into volatile memory a simulation model can be configured and utilized to simulate a digital design through the execution of simulation software. With reference to there is illustrated a block diagram depicting the contents of system memory during a simulation run of a simulation model. As shown system memory includes a simulation model which is a logical representation of the digital design to be simulated as well as software including configuration APIs a simulator and an RTX Run Time eXecutive .

Simulator loads simulation models such as simulation model into system memory . During a simulation run simulator resets clocks and evaluates simulation model via various APIs . In addition simulator reads values in simulation model utilizing GETFAC API and writes values to simulation model utilizing PUTFAC API . Although simulator is implemented in entirely in software it will be appreciated in what follows that the simulator can alternatively be implemented at least partially in hardware.

Configuration APIs comprise software typically written in a high level language such as C or C that support the configuration of simulation model . These APIs which are dynamically loaded by simulator as needed include a first API that loads configuration model from non volatile storage and expands it in the manner described above with reference to to provide a memory image of configuration database . Configuration APIs further include additional APIs to access and manipulate configuration database as described in detail below.

RTX controls simulation of simulation models such as simulation model . For example RTX loads test cases to apply to simulation model . In addition RTX delivers a set of API calls to configuration APIs and the APIs provided by simulator to initialize configure and simulate operation of simulation model . During and after simulation RTX also calls configuration APIs and the APIs provided by simulator to check for the correctness of simulation model by accessing various Dials Registers configuration latches counters and other entities within simulation model .

RTX has two modes by which it accesses Dials instantiated within simulation model interactive mode and batch mode. In interactive mode RTX calls a first set of APIs to read from or write to one or more instances of a particular Dial within configuration database . The latch value s obtained by reference to configuration database take immediate effect in simulation model . In batch mode RTX calls a different second set of APIs to read or write instantiations of multiple Dials in configuration database and then make any changes to simulation model at the same time.

In either interactive or batch mode RTX must employ some syntax in its API calls to specify which Dial or Dial group instances within simulation model are to be accessed. Although a number of different syntaxes can be employed including conventional regular expressions employing wildcarding in an illustrative embodiment the syntax utilized to specify Dial or Dial group instances in API calls is similar to the compact expression hereinbefore described. A key difference between the compact expressions discussed above and the syntax utilized to specify Dial or Dial group instances in the RTX API calls is that in the illustrative embodiment Dial and Dial group instances are specified in the RTX API calls by reference to the top level design entity of simulation model rather than relative to the design entity in which the Dial or Dial group is specified.

In the illustrative embodiment each RTX API call targeting one or more Dial or Dial group instances in simulation model specifies the Dial or Dial group instances utilizing two parameters an instance qualifier and a dialname qualifier. To refer to only a single Dial or Dial group instantiation the instance qualifier takes the form a.b.c.d which is the hierarchical instantiation identifier of the design entity in which the single Dial or Dial group instantiation occurs. To refer to multiple Dial or Dial group instances the instance qualifier takes the form a.b.c X which identifies all instantiations of entity X within the scope of entity instance a.b.c. In the degenerate form the instance qualifier may simply be X which identifies all instantiations of entity X anywhere within simulation model .

The dialname qualifier preferably takes the form Entity.dialname where Entity is the design entity in which the Dial or Dial group is instantiated and dialname is the name assigned to the Dial or Dial group in its configuration specification statement. If bracketed syntax is employed to specify the instance qualifier the Entity field can be dropped from the dialname qualifier since it will match the bracketed entity name.

Referring now to there is depicted a high level logical flowchart of an exemplary process by which configuration APIs locate particular Dial or Dial group instances in configuration database based upon an instance qualifier and dialname qualifier pair in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of an API call from RTX containing an instance qualifier and a dialname qualifier as discussed above. In response to the API call the configuration API enters configuration database at Dial pointer array as depicted at block and utilizes Dial pointers to locate a DDDS having a name field that exactly matches the specified dialname qualifier as illustrated at block .

Next at block the configuration API determines whether the instance qualifier employs bracketed syntax as described above. If so the process passes to block which is described below. However if the instance qualifier does not employ bracketed syntax the configuration API follows the instance pointers of the matching DDDS to locate the single DIDS having an instance name field that exactly matches the specified instance qualifier. As indicated at blocks if no match is found the process terminates with an error. However if a matching DIDS is located a temporary result pointer identifying the single matching DIDS is created at block . The process thereafter terminates at block .

Returning to block if bracketed syntax is employed the configuration API utilizes instance pointers of the matching DDDS to locate one or more DIDSs of Dial or Dial group instances within the scope specified by the prefix portion of the instance identifier preceding the bracketing. That is a DIDS is said to match if the instance name field of the DIDS contains the prefix portion of the instance qualifier. Again if no match is found the process passes through block and terminates with an error at block . However if one or more DIDSs match the instance qualifier temporary result pointers identifying the matching DIDSs are constructed at block . The process shown in thereafter terminates at block .

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial instances in interactive mode in accordance with the present invention. As shown the process begins at block in response to receipt by a configuration API of a read Dial API call by RTX . As indicated at block a configuration API responds to the read Dial API call by locating within configuration database one or more DIDSs of Dial instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API determines by reference to type field of the DDDS associated with the DIDS identified by the current result pointer whether the DIDS corresponds to a Dial group. If so the process illustrated in terminates with an error condition at block indicating that RTX has utilized the wrong API call to read a Dial instance.

In response to a determination at block that the DIDS identified by the current result pointer does not correspond to a Dial group instance the process proceeds to block . Block depicts configuration API utilizing output pointers of the DIDS and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the Dial instance specified in the API call. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

Configuration API then verifies the latch values obtained from simulation model by reference to configuration database as shown at block . In order to verify the latch values configuration API utilizes mapping tables to propagate the latch values up the Dial tree from the corresponding latch data structures through intermediate DIDSs if any until an input value for the requested Dial instance is determined. If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

As indicated by the process returning to block the above described process is repeated for each temporary result pointer returned by the process of . Once all result pointers have been processed the process passes from block to blocks which illustrate the configuration API returning the result data structure to RTX and then terminating.

RTX reads Dial instances in interactive mode utilizing the method of for example to initialize checkers that monitor portions of simulation model during simulation runs. The Dial settings of interest include not only those of top level Dial instances but also those of lower level Dial instances affiliated with the portions of the simulation model monitored by the checkers.

Referring now to there is illustrated a high level logical flowchart of an exemplary process by which RTX reads a value of one or more Dial group instances in interactive mode in accordance with the present invention. As can be seen by comparison of the process of reading a Dial group instance is similar to the process of reading a Dial instance but returns the value of one or more top level Dial instances of possibly different Dial entities rather than one or more instances of the same Dial entity.

As shown the process shown in begins at block in response to receipt by a configuration API of a read Dial group API call by RTX . As indicated at block a configuration API responds to the read Dial group API call by locating within configuration database one or more DIDSs of Dial group instances responsive to the API call utilizing the process described above with reference to .

The process then enters a loop at block in which each of the temporary result pointers generated by the process of is processed. If all of the result pointers returned by the process of have been processed the process passes to block which is described below. If not the process proceeds from block to block which illustrates the configuration API selecting a next result pointer to be processed. Next at block the configuration API identifies and creates temporary pointers to all of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The top level Dial instances are identified by locating the highest level DIDS for each output pointer for which the type field in the associated DDDS specifies a type other than Dial group. In other words the configuration API may have to search down through one or more hierarchical Dial groups to locate the relevant top level Dial instances.

The process illustrated in then enters a loop beginning at block in which each of the top level Dial instances belonging to the Dial group corresponding to the Dial group DIDS referenced by the current result pointer is individually processed to obtain the value s of the top level Dial instance s . The process next proceeds to block which depicts configuration API utilizing output pointers of the DIDS of the first or next top level Dial instance and those of any lower level DIDS in the Dial tree to build a data set containing the latch names from the latch name fields of latch data structures corresponding to all configuration latches ultimately controlled by the top level Dial instance. Next as depicted at block the configuration API makes one or more API calls to GETFAC API of simulator to obtain from simulation model the latch values of all of the configuration latches listed in the data set constructed at block .

At block configuration API then verifies the latch values obtained from simulation model by reference to configuration database utilizing the same technique described above with reference to block of . If at any point in this verification process a Dial instance s output value generated by the verification process does not correspond to one of the legal values enumerated in its mapping table an error is detected at block . Accordingly the latch values read from simulation model and an error indication are placed in a result data structure as illustrated at block . If no error is detected the Dial input value generated by the verification process and a success indication are placed in the result data structure as shown at block .

Following either block or block the process returns to block which represents a determination of whether or not all top level Dials belonging to the Dial group corresponding to the DIDS referenced by the current result pointer have been processed. If not the process returns to block which has been described. However if all top level Dials have been processed the process returns to block which illustrates a determination of whether or not all result pointers have been processed. If not the next result pointer is processed at block and following blocks which have been described. If however all result pointers have been processed the process passes to block which illustrates the configuration API returning the result data structure to RTX and then terminating.

Reading Dial and Dial group instances in a batch mode of RTX is preferably handled by configuration APIs in the same manner as interactive mode with one exception. Whereas in interactive mode latch values are always read from simulation model via calls to GETFAC API at blocks and in batch mode a latch value is preferably obtained from latch value field of a latch data structure in configuration database if latch set field indicates that the corresponding configuration latch has been set. If the configuration latch has not been set the latch value is obtained from simulation model by a call to GETFAC API . This difference ensures that Dial settings made in batch mode which may not yet have been reflected in simulation model are correctly reported.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which an RTX sets a Dial instance in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial API call from RTX . In response to the set Dial API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial instance s specified in the set Dial API call utilizing the technique described above with reference to as illustrated at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial instances. This determination can be made for example by examining the parent pointer of each such DIDS and that of any higher level DIDS linked by a parent pointer and the type fields of the associated DDDSs . The DIDS of a top level Dial instance will have either a NULL parent pointer or a non NULL parent pointer pointing to another DIDS that the type field of the associated DDDS indicates represents a Dial group. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial instance the process terminates at block with an error condition.

In response to a determination at block that all of the DIDSs referenced by the result pointers correspond to top level Dial instances a further determination is made at block whether or not the specified value to which the Dial instance s are to be set is one of the values specified in the mapping table of the associated DDDS . If not the process terminates with an error at block . However in response to a determination at block that the specified value to which the Dial instance s are to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set a respective Dial instance.

At block configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified in the set Dial API call down the Dial tree headed by the top level Dial instance associated with the DIDS referenced by the current result pointer. In order to propagate the desired Dial setting mapping table in the DDDS associated with the DIDS referenced by the current result pointer is first referenced if necessary i.e. for CDials and LDials to determine the output values for each of output pointers in the output pointer array of the DIDS referenced by the current result pointer. These output values are propagated down the Dial tree as the input values of the next lower level Dial instances if any corresponding to the DIDSs referenced by output pointers . This propagation continues until a latch value is determined for each configuration latch terminating the Dial tree which are represented in configuration database by latch data structures . As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure .

Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer. After all result pointers are processed the process terminates at block .

Referring now to there is depicted a high level logical flowchart of an illustrative process by which an RTX sets a Dial group in an interactive mode in accordance with the present invention. The process begins at block in response to receipt by a configuration API of a set Dial group API call from an RTX . In response to the set Dial group API call the configuration API first locates and generates temporary result pointers pointing to the DIDS of the Dial group instance s specified in the set Dial group API call utilizing the technique described above with reference to as depicted at block . Next the configuration API determines at block whether or not all of the temporary result pointers point to DIDSs of top level Dial group instances. This determination can be made for example by examining the parent pointer of each such DIDS to ascertain whether the parent pointer is NULL. If any of the DIDSs referenced by the result pointers does not correspond to a top level Dial group i.e. has a non NULL parent pointer the process terminates at block with an error condition.

In response to a determination at block that each of the DIDSs referenced by the result pointers corresponds to a top level Dial group the process passes to blocks . Block illustrates configuration API locating all of the top level Dial instances within each Dial group for which the corresponding DIDS is referenced by a result pointer. Then as depicted at block the configuration API determines whether or not the specified value to which each top level Dial instance is to be set is one of the values specified in the mapping table of the corresponding DDDS . If not the process terminates with an error at block .

In the illustrated embodiment the prevalidation steps illustrated at blocks and are performed prior to setting any Dial instances because it is deemed preferable to implement setting a Dial group instance as an atomic operation that either successfully sets all relevant top level Dial instances or completely fails. In this manner a complex condition in which some top level Dial instances within the Dial group instance are set and others are not can be avoided.

In response to a determination at block that the specified value to which each top level Dial instance is to be set is one of the legal values the process enters a loop including blocks in which each result pointer is processed to set the top level Dial instance s belonging to each Dial group instance.

At block the configuration API determines whether or not all result pointers have been processed. If so the process terminates at block . If however additional result pointers remain to be processed the next result pointer to be processed is selected at block . Next at block configuration API propagates the Dial setting specified for each top level Dial in the set Dial group API call down the Dial trees of the top level Dial instances belonging to the Dial group instance corresponding to the DIDS referenced by the current result pointer. The propagation of Dial settings down the Dial trees is performed in the same manner discussed above with reference to block of . As shown at block as each latch value for a configuration latch is determined the configuration API makes a call to PUTFAC API to set the configuration latch in simulation model to the determined value utilizing the latch name specified within the latch name field of the corresponding latch data structure . Thereafter the process returns to block which represents the processing of the top level Dial corresponding to the next result pointer if any.

With reference now to there is illustrated a high level logical flowchart of an exemplary method of setting Dial Dial group and Register instances in batch mode in accordance with the present invention. As illustrated the process begins at block and thereafter proceeds to block which illustrates RTX initializing configuration database by calling a configuration API e.g. start batch in order to initialize configuration database . The start batch API routine initializes configuration database for example by setting each instance set field latch Register set field latch set field and set history field in configuration database to FALSE. By resetting all of the set fields in configuration database the Dials Registers and configuration latches that are not set by the current batch mode call sequence can be easily detected as discussed below. Importantly if any of latch Register set fields or set history fields are subsequently set during the batch mode call sequence these fields will stay set i.e. these fields are persistent during all phases of default application.

Following initialization of configuration database at block the process shown in proceeds to block . Block illustrates RTX optionally issuing one or more read Dial or read Dial group API calls to read one or more Dials Registers or Dial groups as discussed above with respect to and optionally issuing one or more batch mode set Dial or set Dial group API calls to enter settings for Dial and Register instances and their underlying configuration latches into configuration database . A configuration API responds to the set API calls in the same manner described above with respect to for setting Dial and Register instances or for setting Dial group instances with two exceptions. First when any top level or lower level Dial or Register instances are set whether as a result of a set Dial or set Dial group API call the instance set field of the corresponding DIDS is set to TRUE. Second no latch values are written to simulation model by the set API routines as illustrated at blocks and of . Instead the latch values are written into latch value fields of the latch data structure corresponding to each affected configuration latch and the latch set field is updated to TRUE. In this manner the Dial and Register instances and configuration latches that are explicitly set by the API call can be readily identified during subsequent processing.

Following block the process passes to block which illustrates RTX calling an end batch API routine among configuration APIs to complete the present phase of default application. As indicated at block and as described in detail below with respect to the end batch API routine applies selected default values if any to specified Dial and Register instances and propagates these default values to underlying configuration latches into configuration database . The latch values of all configuration latches set explicitly or with a default value are then potentially applied to latches within the simulation model. Finally preparation is made for a next phase if any.

If RTX has an additional phase of default application the process passes from block to block and then returns to block which represents RTX initiating a next phase of default application. If however all phases of default application have been processed the process illustrated in passes from block through block to block where the batch process terminates.

Referring now to there is depicted a high level logical flowchart of an exemplary embodiment of the end phase API routine called at block of . As shown the process begins at block when the end phase API routine is called by RTX for example with the following statement 

In this exemplary API call the phases parameter is a string specifying the phase ID s of defaults to be applied at the end of the current phase unamed is a Boolean parameter indicating whether or not defaults values without any associated phase ID should be applied during the current phase apply is a Boolean valued parameter indicating whether or not configuration latch values should be immediately applied to simulation model and instance qualifier is one or more regular expressions that can be utilized to limit which instances of a particular Dial are processed to apply defaults.

By specifying an instance qualifier parameter for the end phase API routine a user can limit the application of defaults to only a portion of simulation model . The ability to restrict the application of defaults in this manner is particularly useful in cases in which two sections of the simulation model e.g. sections representing two different integrated circuit chips have different phasing requirements but use the same phase IDs. Thus collisions in phase IDs can be resolved by appropriate specification of the instance qualifier used in conjunction with the phase ID.

The end phase API routine then enters a processing loop including blocks in which DIDSs within configuration database are processed to apply appropriate Dial default values if any. Referring first to block the end phase API determines whether or not all top level pointers within top level pointer array have been processed. If so the process proceeds from block to block which is described below. If not all top level pointers within top level pointer array have been processed the process proceeds to block . Block represents the end phase API routine recursively scanning the DIDSs pointed to by a next top level pointer and its descendant DIDSs if any to apply the default values indicated by the parameters of the end phase API call. If the end phase API routine determines at block that it has processed all necessary DIDSs in the subtree of the top level DIDS identified by the current top level pointer then the process returns to block which has been described. If however at least one DIDS in the subtree of the top level DIDS identified by the current top level pointer remains to be processed the process passes from block to block .

Block illustrates the end phase API routine examining a next DIDS to determine whether or not its default field has a non NULL value. If the current DIDS does not contain a non NULL default field the process returns to block representing the end phase API routine continuing the recursive processing of DIDSs in the subtree of the top level DIDS pointed to by the current top level pointer . If the default field contains a non NULL value the process passes to block which depicts a determination of whether or not the instance set field is set that is whether the Dial instance was previously explicitly set at block of . If the instance set field is set the default value contained in default field is ignored since the simulation user has already explicitly specified a value for the associated Dial instance . And because simulation database is constructed so that any descendant of a DIDS having a specified default cannot have a default value the process passes to block which illustrates the end phase API routine skipping the processing of any DIDS in the subtree of the current DIDS . Thereafter the process returns to block which has been described.

Returning to block in response to a determination that the instance set field of the current DIDS is not set the process proceeds to block . Block illustrates end phase API interrogating phase ID field of the current DIDS to determine whether the default value stored in default field has one or more associated phase IDs. If not the process passes to block which is described below. In response to a determination at block that phase ID field stores at least one phase ID the end phase API next determines at block whether the phases parameter of the end phase API call specifies a phase ID that matches a phase ID contained within phase ID field . If no match is found the process passes from block to block which has been described. If on the other hand a phase ID specified in the phases parameter of the end phase API call matches a phase ID contained within the phase ID field of the current DIDS the end phase API next determines at block whether or not the Dial instance name contained in instance name field of the current DIDS matches the qualifying expression passed as the instance qualifier parameter of the end phase API call. Again in response to a negative determination at block the process passes to block which has been described. If on the other hand the Dial instance name contained within instance name field is qualified by the instance qualifier parameter the process proceeds to block which is described below.

Returning to block if the current DIDS does not have one or more phase IDs specified within phase ID field a further determination is made whether or not the unnamed parameter of the end phase API call has a value of TRUE to indicate the default values without any associated phase information should be applied during the current phase. If not the process passes from block to block which has been described. If on the other hand the end phase API determines at block that defaults without associated phase information should be applied during the current phase the process proceeds to block which has been described above.

Thus when the end phase API reaches block end phase API has by the determinations illustrated at and determined that the default specified for the Dial instance corresponding to the current DIDS should be applied in the current phase of batch mode execution. Accordingly at block the end phase API routine applies the default value specified in the default field to mapping table to generate one or more Dial output signal s which are then propagated down the Dial tree of the current DIDS in the manner hereinbefore described. Ultimately the latch value fields and latch set field of each of the underlying latch data structures within configuration database are set to values corresponding to the Dial default value if the latch Register set field of the latch data structure is not set. That is a default value is preferably applied to a latch only if the latch has not previously been set via a Register. If a latch has previously been set via a Register during any preceding phase of the configuration process the default value is not applied at least until the start batch API is called again . The process then proceeds from block to block which has been described.

Returning to block in response to a determination that the Dial trees of all of the DIDS pointed to by top level pointers have been processed to apply any appropriate default values in the manner described above the process next passes to block . Block depicts end phase API examining the apply parameter of the end phase API call to determine whether or not the configuration latch values within latch data structures should be applied to simulation model . The added degree of control represented by this determination is advantageous in that different sections of simulation model which may have colliding phase IDs can be independently configured within configuration database in different phases but the resulting configuration latch values can be applied to simulation model at the same time if desired. If the apply parameter has the value FALSE meaning that the configuration latch values are not to be applied to simulation model during the current phase the process passes directly to block .

If however configuration latch values are to be applied to simulation model during the current phase as indicated by an apply parameter value of TRUE the end phase API routine proceeds to block . At block the end phase API utilizes latch pointer array to examine each latch data structure in configuration database . For each latch data structure in which latch set field has the value TRUE the end batch API routine issues a call to PUTFAC API of simulator to update simulation model with the latch value contained in latch value field . In addition as shown at block the end phase API performs a logical OR operation between the value of latch set field and set history field storing the result within set history field . In this manner each set history field maintains an indication of whether or not the corresponding configuration latch has been set during any phase of the batch mode process.

Following block the end batch API proceeds to block which depicts the end batch API routine resetting all of instance set fields in DIDS and all latch set fields in preparation of a next phase if any. Thereafter the end phase API routine terminates at block .

In summary the end phase API routine applies Dial default values to configuration database that match the limiting phase and instance qualifiers and then optionally applies the resulting configuration latch values to simulation model in accordance with the apply parameter. Finally the end phase API routine tracks which latch data structures have been set utilizing set history fields and resets various set fields to prepare for a next phase if any.

Heretofore default values have been described solely with respect to designer supplied phase information specified within HDL files or configuration specification files . For many simulation models designers have only limited knowledge of the boot sequence of the simulation model and corresponding hardware implementations and therefore have limited understanding of the phasing of defaults required to appropriately initialize the simulation model or corresponding hardware realization. Accordingly it is desirable to provide downstream users such as simulation users laboratory users or deployment support personnel with the ability to specify phase information governing the application of Dial default values.

As shown in in one embodiment users are permitted to supply and or modify the phase ID s stored within phase ID fields of configuration database or a corresponding hardware configuration database discussed below utilizing a program . Program includes a set of database manipulation API routines that when called with appropriate parameters permits a user to read and write phase IDs within configuration database or the corresponding hardware configuration database .

Referring again to configuration APIs preferably further include a find unset latch API that following a batch mode setting of Dial or Dial group instances in configuration database audits all of the latch data structures in configuration database by reference to latch pointer array in order to detect configuration latches that have not been configured by an explicit or default setting i.e. those having set history field set to FALSE . For each such unset configuration latch the find unset latch API preferably returns the fully qualified instance name of the configuration latch from latch name field in the corresponding latch data structure and the fully qualified instantiation identifier of the top level Dial instance that controls the unset latch. The find unset latch API thus provides an automated mechanism for a user to verify that all Dial and latch instances requiring an explicit or default setting are properly configured for a simulation run.

Configuration APIs preferably further include a check model API that when called utilizes top level pointer array to verify by reference to the appropriate mapping tables that each top level CDial and LDial instance in simulation model is set to one of its legal values. Any top level LDial or CDial set to an illegal value is returned by the check model API.

The Dial and Dial group primitives introduced by the present invention can be employed not only to configure a simulation model of a digital design as described above but also to configure hardware realizations of the digital design for laboratory testing and customer use. In accordance with an important aspect of the present invention hardware realizations of the digital design are configured by reference to a hardware configuration database which like configuration databases and discussed above is derived from configuration specification statements coded by the designers. In this manner continuity in configuration methodology exists from design through simulation and laboratory testing to commercial deployment of a digital design.

Referring now to there is illustrated a high level block diagram of a laboratory testing system for testing and debugging hardware realizations of one or more digital designs in accordance with an embodiment of the present invention. As illustrated the laboratory testing system includes a data processing system which is intended for commercial sale and deployment. For laboratory testing and debugging data processing system is coupled by a test interface to a workstation computer that communicates with data processing system via test interface to configure the various components of data processing system for proper operation. When commercially deployed data processing system includes the illustrated components but is not typically coupled to workstation computer by test interface .

Data processing system may be for example a multiprocessor computer system such as data processing system of . As such data processing system includes multiple integrated circuit chips representing the various processing units controllers bridges and other components of a data processing system. As is typical of commercial data processing systems data processing system may contain multiple instances of some integrated circuit chips such as integrated circuit chips and single instances of other integrated circuit chips such as integrated circuit chip

In addition to their respective functional logic integrated circuit chips each have a respective test port controller that supports external configuration of the integrated circuit chip utilizing multiple scan chains as discussed in detail below with reference to . To permit such external configuration each test port controller is coupled by a test access port TAP to a service processor within data processing system .

Service processor is a general purpose or special purpose computer system utilized to initialize and configure data processing system for example at power on or in response to a reboot. Service processor includes at least one processing unit for executing software instructions a flash read only memory ROM providing non volatile storage for software and data an I O interface interfacing service processor with test port controllers and workstation computer and a volatile memory that buffers instructions and data for access by processing unit

Among the software and data stored in flash ROM is system firmware . System firmware is executed by processing unit of service processor at power on to sequence power to integrated circuit chips perform various initialization procedures and tests synchronize communication between integrated circuit chips and initiate operation of the functional clocks. System firmware controls the startup behavior of integrated circuit chips by communication via test access ports .

In addition to system firmware flash ROM stores hardware HW configuration APIs and a HW configuration database describing integrated circuit chips . As described below during commercial deployment processing unit calls various HW configuration APIs to access HW configuration database in order to appropriately configure integrated circuits via I O interface and TAPs .

Workstation computer which may be implemented for example as a multiprocessor computer system like data processing system of includes many components that are functionally similar to those of service processor . Accordingly like reference numerals designate processing unit volatile memory I O interface and the system firmware HW configuration database and HW configuration APIs residing in non volatile storage e.g. disk storage . It will be appreciated by those skilled in the art that because the system firmware HW configuration database and HW configuration APIs residing in non volatile storage are specifically designed to initialize and configure data processing system in the context of laboratory testing and debugging they may have smaller larger or simply different feature sets and capabilities than the corresponding software and data within flash ROM .

During laboratory testing and debugging workstation computer assumes most of the functions of service processor . For example workstation computer initializes and configures data processing system by executing system firmware and various HW configuration APIs in order to generate various I O commands. These I O commands are then communicated to data processing system via test interface and I O interfaces and . System firmware which executes within service processor in a bypass mode in which most of its native functionality is disabled responds to these external I O commands by issuing them to integrated circuit chips via test access ports in order to initialize and configure integrated circuit chips .

With reference now to there is illustrated a more detailed block diagram of an exemplary integrated circuit chip in accordance with the present invention. As noted above integrated circuit chip includes a test port controller supporting external communication with I O interface of service processor of and control of various internal functions of integrated circuit chip including the operation of functional clock and scan clock . Integrated circuit chip further includes functional logic not explicitly illustrated comprising the digital integrated circuitry that performs the work the integrated circuit is designed to do for example processing software instructions in response to the clock pulses of functional clock . Throughout the functional logic is distributed a plurality of functional latches that during normal functional operation of the functional logic i.e. when functional clock clocks the functional logic hold bits representing the dynamic state of the functional logic and data and or instructions. These functional latches include those that hold mode and configuration bits utilized to configure the functional logic in a desired configuration.

As shown groups of functional latches are interconnected to form multiple test scan chains and multiple SCOM scan communication chains . Although not illustrated for the sake of clarity some functional latches are in practice members of both a test scan chain and an SCOM chain . The test scan chains are utilized to scan bits into functional latches in response to pulses of scan clock and the SCOM chains are utilized to scan bits into functional latches in response to pulses of functional clock . Functional clock and scan clock do not both output pulses at the same time to prevent a conflict between values loaded into functional latches .

As depicted each functional latch in a test scan chain includes at least two data inputs a scan input scanin and a functional input D and two clock inputs a scan clock input sclk and a functional clock input fclk . Each functional latch further includes at least two data outputs namely a scan output scanout and a functional output D . To form a test scan chain the scan input of a first functional latch and the scan output of a last functional latch are coupled to test port controller and the scan output of each functional latch in the test scan chain other than the last is connected to the scan input of a next functional latch .

Each functional latch latches in the data bit present at its scanin and latches out its former value at scanout in response to a pulse of scan clock on sclk and latches in the data bit present at Dand latches out its former value in response to receipt of a pulse of functional clock on fclk. Thus by repeated pulsing of scan clock the functional latches forming a test scan chain transfer data bits in from and out to test port controller in a bit bucket brigade fashion thereby allowing test port controller to read or write one or more functional latches in a test scan chain .

SCOM chains are utilized to read and write functional latches when functional clock is active and scan clock is inactive. Each SCOM chain includes multiple sequentially connected SCOM cells the first and last of which are connected to test port controller to permit test port controller to scan data bits into and out of SCOM cells . As depicted in the exemplary embodiment each SCOM cell contains a functional latch forming a portion of an SCOM register as well as a shadow latch forming a portion of a shadow register . It is preferred if all shadow latches like functional latches also belong to a test scan chain .

As shown each functional latch in each SCOM cell is connected to an associated multiplexer having a scan input scomin coupled to the output of the corresponding shadow latch and a data input D coupled by a hold path to the data output D of the associated functional latch . Multiplexer selects the data bit present at one of data input D and scomin as an input of functional latch in response to select signal sel. Functional latch latches the selected data bit in response to functional clock fclk.

Shadow latch in each SCOM cell is similarly connected to an associated multiplexer having a data input D coupled to the data output D of functional latch a hold input coupled by a hold path to the output of shadow latch and scan input scomin . In the first SCOM cell the scan input is connected to test port controller and in the remaining SCOM cells the scan input is connected to the output of the shadow latch in the preceding SCOM cell . The output of the shadow register of the last SCOM cell in each SCOM chain is connected to test port controller . Multiplexer selects among the data bits present at its inputs as the input of the associated shadow latch in response to select signal sel. Shadow latch latches the selected data bit in response to functional clock folk.

The chain of shadow registers is used to read values from and write values to the associated SCOM registers. For example to set an SCOM register test port controller scans a new value into shadow latches via the scomin inputs of multiplexers by asserting appropriate values of selects sel. Once all shadow latches have been loaded test port controller controls select inputs sel to cause functional registers to load the values from shadow latches . To read a value from the SCOM registers test port controller drives sel to read the values out of the functional latches into the shadow latches and then scans the values out of the shadow latches by asserting appropriate values of selects sel.

In the exemplary embodiment SCOM chains employ shadow latches to read and write functional latches to avoid disrupting the proper functional operation of integrated circuit chip or even data processing system . By loading all shadow latches prior to updating any functional latches all functional latches within a SCOM chain can be updated at once without disrupting their values for multiple cycles of functional clock . It should be understood that the particular implementation of SCOM chains illustrated in is not required to practice the present invention and that other alternative designs may be employed including some that do not include shadow latches .

Thus by loading the appropriate values into functional latches and by appropriate control of functional clock and scan clock each test port controller can initialize and configure its integrated circuit chip in a desired manner based upon inputs from service processor and or workstation computer .

In order to configure hardware functional latches in the manner described above a HW configuration database that accounts for the differences between simulation and hardware environments must be generated. In general the structure and contents of HW configuration database reflect at least two central differences from the configuration database for simulation described above.

The first difference is in the manner in which latches are addressed in hardware. In particular instead of utilizing a fully qualified instantiation identifier for the configuration latch as in simulation each hardware functional latch within a particular integrated circuit is addressed and accessed for test scanning by an ordered pair consisting of a scan chain or ring identifier specifying a particular test scan chain and an offset indicating the latch s bit position in the test scan chain . Functional latches within SCOM rings are similarly addressed and accessed for SCOM scanning using a similar ordered pair of ring identifier offset specifying a particular SCOM chain and the offset of the corresponding shadow latch . Importantly the SCOM ring identifier and offset for a particular functional latch do not have the same values as the corresponding test scan ring identifier and offset. In fact in alternate SCOM implementations different SCOM hardware may be used and the offset can be expressed as a tuple ring ID register offset . It will therefore be appreciated that functional registers may be addressed and accessed utilizing multiple access methods each of which may have its own addressing scheme all of which will likely differ from that employed in simulation.

A second important difference between HW configuration database and the configuration database employed in simulation is the overall database structure. As described above configuration database is a monolithic database that may be utilized to represent an arbitrarily selected digital design of any size or complexity by nesting design entities hierarchically. A new configuration database is generated by configuration compiler for each different digital design that is simulated. Although this approach is satisfactory in a simulation environment the monolithic database structure employed in simulation does not correspond to the actual physical mechanisms utilized to access and set hardware latches in a hardware digital design. Moreover it is desirable in a laboratory environment to avoid developing an entirely new system firmware and HW configuration database for each different hardware permutation. For example it is desirable to minimize development time and cost by reusing some or all of a particular HW configuration database and system firmware to initialize and configure each server computer in a server product line supporting between 8 and 32 processing units and 1 to 4 different memory controllers.

Consequently as described in detail below HW configuration database is preferably structured as a federation of smaller databases that each corresponds to a particular type not instance of integrated circuit chip present within the hardware digital design. This database structure supports construction of a HW configuration database for a hardware system of any desired size and complexity from the same building block per chip type databases. Moreover this database structure reflects the fact that hardware latches are accessed by system firmware on a per chip basis.

Referring now to there is depicted a high level flow diagram of an exemplary process by which the simulation configuration database of each integrated circuit chip is transformed to obtain a chip HW database utilized to construct a HW configuration database suitable for laboratory testing and debugging and commercial deployment. The illustrated process may be implemented through the execution of software on data processing system of .

The process begins with the execution of a scan chain detection tool . Scan chain detection tool processes the simulation model of each integrated circuit chip within a target hardware system such as data processing system to produce a respective output file corresponding to each functional latch access path method for latches within the integrated circuit chip . For example in the exemplary embodiment scan chain detection tool generates a test scan definition file corresponding to test scanning and a SCOM definition file corresponding to SCOM scanning. Each of these files provides for latches within simulation model a correspondence between the latch s scan ring identifier and offset or other hardware address for the associated access method and its fully qualified latch instance name for simulation purposes.

The test scan definition file and SCOM definition file and the simulation configuration database for the integrated circuit chip are then processed by a database transformation tool to generate a chip HW database that can be utilized as a building block to obtain a HW configuration database for a hardware system of any arbitrary system size and component list.

With reference now to there is illustrated a high level logical flowchart of an exemplary process by which database transformation tool generates a chip HW database from the corresponding simulation configuration database for the integrated circuit chip by reference to test scan definition file and SCOM definition file . As illustrated the process begins at block and then proceeds to block which illustrates loading the simulation configuration database from non volatile data storage into volatile memory and augmenting its fields in the manner discussed above with respect to to obtain an expanded configuration database . Test scan definition file and SCOM definition file are also loaded into volatile memory.

Next at block a determination is made whether or not all latch data structures referenced by latch pointer array have been processed. If so the process terminates at block . However if all latch data structures have not yet been processed the process passes from block to block which illustrates the selection for processing of the latch data structure pointed to by the next latch pointer in latch pointer array . Next at block the fully qualified latch name of the latch corresponding to the latch data structure under consideration is formed by using the parent pointer to access the contents of instance name field of the Dial instance controlling the latch and appending those contents to the contents of latch name field .

Test scan definition file is then searched for this fully qualified latch name as depicted at block . If the fully qualified latch name is not found within test scan definition file an error is flagged at block because in the exemplary embodiment all configurable latches must be scannable. Otherwise database transformation tool calls the API routine add access method method id method name at block to augment latch data structure to form a new latch data structure . The method id parameter of the API calls identifies a particular access method e.g. with a string or integer and the method name parameter specifies a name utilized by the associated access method to access in hardware the latch corresponding to the new latch data structure . As illustrated in the new latch data structure is created at block by adding to latch data structure a method ID field specifying a method identifier of this access method which is 0 by convention and a method name field specifying a test scan ring identifier and offset value for the latch.

The process proceeds from block to block which represents repeating the search for the fully qualified latch instance name performed at block using the definition file for the next access method in this case SCOM definition file . If no match for the fully qualified latch instance name is found within SCOM definition file no error is logged because not all latches belong to SCOM chains and the process simply passes to block which is described below. If on the other hand a match is found the add access method API routine is again called at block to augment latch data structure with a method ID field specifying the method identifier of this access method and a method name field specifying a SCOM scan ring identifier and offset value for the latch.

Finally at block the API routine delete latch name is called to delete latch name field from latch data structure . Latch name field is no longer needed because a ring identifier and offset pair uniquely identifies any latch within the integrated circuit chip . The process then returns to block which has been described.

The method of thus alters the simulation configuration database of each integrated circuit chip to include information indicating the access methods available for each hardware functional latch and the method name i.e. identifier of the latch for each available access method. Although the illustrated process depicts the modification of a simulation configuration database to support two particular access methods the illustrated method can be employed to handle any number or types of access methods.

Once all of the simulation configuration databases for each integrated circuit in a system have been processed in the manner illustrated in the resulting chip hardware databases can then be combined to form HW configuration database illustrated in . In a preferred embodiment HW configuration database is constructed from chip HW databases by creating a chip pointer data structure that contains a respective chip database pointer referencing the chip HW database of each type of chip in data processing system . For example if data processing system includes 32 identical integrated circuit processor chips chip pointer data structure will contain in addition to other chip database pointers corresponding to other types of integrated circuit chips only one chip database pointer to a single chip HW database describing the digital design embodied by the 32 integrated circuit processor chips. This HW configuration database is then stored in non volatile storage such as non volatile storage or flash ROM as shown in .

In order to configure a hardware digital design utilizing a HW configuration database the HW configuration database is first loaded from non volatile storage into volatile memory in accordance with the exemplary process depicted in . The process shown in may be performed for example in a laboratory environment by workstation computer through the execution of system firmware by processing unit . Similarly when data processing system is deployed commercially service processor executes system firmware according to the process of to load HW configuration database from flash ROM to volatile memory

As illustrated the process of begins at block and then proceeds to block which illustrates a determination of the types of integrated circuit chips and number of each type present within a target data processing system such as data processing system . In an exemplary embodiment the determination illustrated at block is made by system firmware which consults a set of so called Vital Product Data VPD to determine which of the thousands of possible machine configuration is represented by data processing system .

The process then proceeds to blocks which collectively form a loop in which chip pointer data structure is walked to process the chip HW databases of the integrated circuit chips comprising data processing system . First at block a determination is made whether the chip HW database of each type of integrated circuit chip within data processing system has been processed. If so loading of HW configuration database into volatile memory is complete and the process terminates at block . If however the chip HW database corresponding to each type of integrated circuit chip identified by the VPD has not been processed a next chip HW database is loaded into volatile memory of workstation for processing at block .

As shown in which depicts an in memory view of HW configuration database loading of the chip HW database creates in memory data structures as described above such as a Dial pointer array latch pointer array and an instance pointer array within each DDDS see . In addition a latch value field a latch set field and set history field are created within each latch data structure and a instance set field is created within each DIDS . Each of these three fields is implemented as an array in which each entry corresponds to a particular instance of the integrated circuit chip corresponding to the current chip HW database . Finally an empty chip mapping table is created.

Next at block a respective entry is added to chip mapping table for each instance of the type of integrated circuit chip corresponding to the current chip HW database . This step is preferably performed by system firmware via a call to a HW configuration API that accesses the VPD to determine how many instances of the type of integrated circuit chip corresponding to the current chip HW database are contained in the present hardware digital design. By convention the order of the entries within chip mapping table corresponds to the order of array entries in instance set field latch value field and latch set field .

As shown in each entry within chip mapping table associates two firmware supplied values 1 a chip instance name which is a string like that identifying the design entity representing the integrated circuit chip instance in the simulation model of data processing system e.g. a.b.c.d and 2 a chip ID specifying an identifier of the test access port by which service processor communicates with that integrated circuit chip instance. Thus any latch in data processing system can now be readily addressed by the tuple chip ID scan ring offset which is associated by chip mapping table with the chip identifying portion of the fully qualified latch name employed by HW configuration APIs . Thereafter the process returns to block which has been described.

The process depicted in thus permits a single HW configuration database to be utilized to build an in memory HW configuration database for a data processing system of any arbitrary size or configuration eliminating the need to develop and store a separate monolithic configuration database for each possible system size and configuration.

With HW configuration database loaded into a volatile memory system firmware can then be executed by processing unit of service processor or processing unit of workstation computer to call HW configuration APIs to read or set a configuration of one or more integrated circuit chips of data processing system . As in simulation HW configuration APIs preferably include separate API routines to read Dials and Dial groups in interactive and batch modes. Also like simulation the API calls by system firmware specify an instance qualifier e.g. a.b.c.d or a.b.c X and a dialname qualifier e.g. Entity.dialname for each Dial or Dial group instance to be set or read.

Because multiple access methods can be utilized to set or read a Dial or Dial group API calls to set or read a Dial or Dial group instance preferably include an additional parameter access method. In a preferred embodiment the access method parameter can take the values SCAN which indicates test scanning SCOM which indicates SCOM scanning and AUTO which indicates that the HW configuration API is to select the access method. In response to an AUTO value for the access method parameter a HW configuration API selects an access method based upon the supported access method s indicated by the method ID s in the latch data structure s targeted by the API call and upon which of functional clock and scan clock is running. As described above SCOM scanning is only available when functional clock is running and test scanning is only available when scan clock is running.

Before any HW configuration API can set or read a Dial or Dial group instance the HW configuration API must first determine which Dial or Dial group instances are identified by the instance qualifier and dialname qualifier specified in the API call. Referring now to there is depicted a high level logical flowchart of an exemplary process by which a HW configuration API locates particular Dial or Dial group instances in HW configuration database in accordance with the present invention. The illustrated process is analogous to the process depicted in and described above.

As shown the process begins at block in response to receipt by a HW configuration API of an API call from firmware having as an argument an instance qualifier and a dialname qualifier of one or more Dial or Dial group instances as discussed above. In response to the API call the configuration API enters HW configuration database at chip pointer array and as depicted at block enters a loop in which chip database pointers are processed until one or more matching Dial instances are located within a particular chip HW database or until all chip database pointers have been processed. In response to a determination at block that all chip database pointers have been processed without locating any matching Dial instances the process terminates with an error at block . However if fewer than all of chip database pointers have been processed the next chip database pointer is selected from chip pointer data structure for processing as depicted at block . The selected chip database pointer is utilized to locate the associated chip HW database .

Following block the process proceeds to block and following blocks which represent a processing loop in which each Dial pointer in the Dial pointer array of the current chip HW database is processed until a particular Dial matching the API call is located or until all Dial pointers have been processed without finding any matching Dial instances. In response to a determination at block that all Dial pointers have been processed without locating any matching Dial entity the process returns from block to block in order to process the next chip database pointer in chip pointer array i.e. to process the next chip HW database . If on the other hand a determination is made at block that not all Dial pointers within Dial pointer array have been processed the process proceeds to block which illustrates the selection from Dial pointer array of the next Dial pointer for processing.

Next a determination is made at block of whether or not the DDDS referenced by the current Dial pointer has a name field that exactly matches the specified dialname qualifier. With respect to name fields two implementations are possible. First reuse of Dial names can be prohibited so that every Dial name is unique throughout not only its own integrated circuit chip but also throughout the entire system e.g. data processing system . A second less restrictive approach is to require each Dial name to be unique only within its integrated circuit chip and to permit multiple uses of a Dial name in different integrated circuits. In order to support the second approach name field takes the form chiptype.Dial name where chiptype is a unique string identifying the type of integrated circuit chip thus disambiguating identical Dial names applied to Dial entities instantiated in different integrated circuit chips .

In response to a determination at block that name field does not match the specified dialname qualifier the process returns to block for processing of the next Dial pointer if any as described above. If however a match is found the process then enters a processing loop comprising blocks in which the Dial instances represented by individual DIDS are examined for a match with the API call s instance qualifier utilizing the instance pointers in the instance pointer array of the DDDS of the matching Dial entity. In this processing loop a determination is first made at block of whether or not all instance pointers within the current DDDS have been processed. If so a further determination is made at block of whether or not at least one matching instance of the Dial entity corresponding to the current DDDS was found. This determination is made because the construction of HW configuration database ensures that at most one matching Dial not Dial instance in only one chip HW database will match the instance qualifier and dialname qualifier specified in the API call. Consequently if a matching instance is found for a particular Dial entity no further Dial entities or chip HW databases need be searched. Accordingly if a determination that at least one matching Dial instance has been found for the Dial entity corresponding to the current DDDS the process passes from block to block and terminates. If however a determination is made at block that no match was found the process passes through page connector A and terminates with an error at block .

Returning to block in response to a determination that all instance pointers of the current DDDS have not been processed the process proceeds to block which illustrates the selection of the next instance pointer and its associated DIDS for processing. A determination is then made at block whether the DIDS has been processed with respect to the Dial instance in each of the integrated circuit chips corresponding to the current chip HW database by processing each entry in chip mapping table . If so the process passes to block which is described below. If processing of all entries in chip mapping table has not been completed the process proceeds to block .

Block depicts forming the next fully qualified Dial instance name to be matched against the instance qualifier specified in the API call by prepending the chip instance name in the next entry of chip mapping table to the instance name field of the current DIDS . This fully qualified Dial instance name is then compared to the instance qualifier at block . If they do not match the process returns to block which has been described. If they do match a temporary result pointer and associated chip vector are created at block if they do not already exist. The temporary result pointer points to the current DIDS to identify the corresponding Dial instance as matching the instance qualifier specified in the access request. An entry is also placed in the associated chip vector to indicate the particular integrated circuit chip instance in which this matching Dial instance is located. In an exemplary embodiment the chip vector may simply comprise a same number of bits as there are entries in chip mapping table with a bit value of 1 indicating that the corresponding integrated circuit chip instance contains a matching Dial instance. Following block the process returns to block .

The processing loop represented by blocks is repeated for each entry in chip mapping table . After all entries have been processed the process passes from block to block which depicts a determination of whether the dialname qualifier was specified utilizing non bracketed syntax and if so whether or not a match was found for the specified dialname qualifier among the Dial instances represented by the current DIDS . If the determination is negative it is possible that additional matching Dial instances associated with another DIDS may exist. Accordingly the process returns to block to process the next instance pointer of the current DDDS . If however the determination at block is positive it is known that all matching Dial instances have been located and identified with temporary result pointers and associated chip vectors. The process therefore terminates at block .

After the Dial or Dial group instances specified by the instance qualifier and dialname qualifier have been determined by the process shown in the Dial or Dial group instance s are set or read in much the same fashion as described above with respect to reading a Dial instance in interactive mode B reading a Dial group instance in interactive mode A setting a Dial instance in interactive mode B setting a Dial group instance in interactive mode and A B setting a Dial instance or Dial group instance in batch mode . A few differences are required however to account for the use of a single chip HW database to represent possibly multiple integrated circuit chips and for the availability of multiple different access methods to access integrated circuit chips . These differences are detailed below.

When reading Dial instances or Dial group instances latch values are verified by propagating the latch values up the Dial trees in the configuration database as described with reference to block of . Conversely when setting Dial instances or Dial group instances Dial values are propagated down the Dial trees in the configuration database to the latch data structures as described above with reference to block of . In simulation only one latch value at a time is propagated down to or up from any one latch data structure . However because HW configuration database represents multiple integrated circuit chips of the same type with a single chip HW database reading or setting a Dial or Dial group instance by reference to a chip HW database representing multiple physical integrated circuit chips entails propagating multiple elements of a value set up or down the Dial tree in parallel where each element of the value set is the value for a particular chip instance identified by the temporary result pointer and chip vector constructed in .

Similarly in simulation each of instance set field latch value field latch set field and set history field within configuration database contains only a single value. In contrast the corresponding instance set fields latch value fields latch set fields and set history fields within HW configuration database are implemented as arrays in which each element corresponds to an individual Dial or latch instance for a particular integrated circuit chip . Accordingly when Dial Dial group and latch instances are set the elements within instance set fields latch value fields latch set fields and set history fields corresponding to the set instances are updated in accordance with the temporary result pointer and chip vector constructed in .

Because laboratory or commercial use of HW configuration database entails accessing physical hardware i.e. integrated circuit chips utilizing multiple possible access methods three additional differences from a simulation environment are noted in a preferred embodiment. First a set or read operation requested in an API call preferably fails i.e. is not performed if a HW configuration API determines that the access method indicated by the access method parameter contained within the API call is not available for any of the Dial instances identified by the temporary result pointer s and chip vector s obtained by the process of . As described above the access method s by which each latch can be set or read is indicated by the method ID field s of each latch data structure .

Second a set or read operation requested in an API call preferably succeeds only if a HW configuration API determines that the functional clock and scan clock within each integrated circuit chip targeted by the API call are in the appropriate states for the access method parameter contained within the API call. That is if the access method parameter has the value SCAN the functional clock must be disabled and the scan clock must be enabled. Conversely if the access method parameter has the value SCOM the functional clock must be enabled and the scan clock must be disabled. If the access method parameter has the value AUTO the functional clock and scan clock of each integrated circuit chip containing a latch targeted by the API call must be in states that permit at least one access method of each such latch to be employed.

Third the HW configuration APIs utilized to read and set hardware latches read latch and write latch preferably minimize scan accesses to integrated circuit chips by implementing shadow scan chain buffers in volatile memory by accessing such scan chain buffers when possible in lieu of scanning a scan chain in an integrated circuit chip . For example the read latch HW configuration API which corresponds to the GETFAC API employed in simulation preferably obtains latch value s from the corresponding shadow scan chain buffers in volatile memory in cases in which the latch value s in volatile memory are known to be current. In addition multiple updates to latch values via the write latch API which corresponds to the PUTFAC API utilized in simulation are preferably buffered in the shadow scan chain buffers in volatile memory . In this manner multiple writes to latches in a particular scan chain of an integrated circuit chip can be made by scanning the particular scan chain only once.

HW configuration APIs preferably further include a check chip API similar to the check model API available in simulation. When called the check chip API utilizes top level pointer array within a specified chip HW database to verify that each top level CDial and LDial instance within the chip HW database is set to one of its legal values. Specifically the check chip API propagates the underlying hardware latch values up the Dial tree of each top level CDial and LDial instance by reference to its mapping table and the mapping table s of any lower level Dial instance s in its Dial tree. Any top level LDial or CDial instance set to an illegal value is returned by the check chip API.

Referring again to in many commercial embodiments of data processing system the storage capacity of non volatile storage e.g. flash ROM within service processor is significantly less than that of the non volatile storage e.g. hard disk storage of the workstation computer utilized to store system firmware and HW configuration database . Accordingly it is usually desirable or necessary to reduce the size of the system firmware and HW configuration database developed in a laboratory hardware testing environment to obtain the system firmware and HW configuration database commercially deployed within flash ROM or other non volatile storage of data processing system .

Accordingly with reference now to there is illustrated a high level logical flow diagram of an exemplary process by which each chip HW database developed during laboratory development and testing of system firmware can be compressed through the elimination of unnecessary information in order to obtain a HW configuration database suitable for commercial deployment. The process begins by generating Dial usage information indicating which Dial instances within a particular type of integrated circuit chip have been set and or read and the values to which Dial instances have been set.

The determination of which Dial instances are set or read and the values to which Dial instances have been set can be accomplished in a number of ways well known to those skilled in the art. For example system firmware can be manually examined to generate Dial usage information . Alternatively system firmware can be executed in a number of possible machine configurations that cover all the settings to which Dial instances in the type of integrated circuit chip under consideration may be set. The Dial instances that are set and read and the values to which Dial instances are set can then be logged as Dial usage information .

In a preferred embodiment all that is recorded within Dial usage information for IDial instances is whether or not the IDial instance is set or read. No IDial instance values are recorded because it is assumed for purposes of generating Dial usage information that if an IDial instance is set all of its possible values may be utilized. There are however particular IDial instances that developers know will only be set to a single value. To permit the elimination of these IDials from HW configuration database these IDials and their associated values can optionally be specified by a developer within an override file . Override file may also contain a list of Dial instances if any that the developer desires to explicitly preserve within HW configuration database regardless of whether or not the Dial instance is read or set.

Thus for each chip HW database Dial usage information and override file are preferably obtained that collectively contain at least the following information 

As further illustrated in this information is then utilized by a software compression tool e.g. executed by workstation computer to eliminate unnecessary information from the associated chip HW database . Compression tool produces two outputs 1 a compressed chip HW database forming a portion of HW configuration database and 2 initial scan chain images utilized to develop the scan chain images to which test scan chains in the integrated circuit chip are initialized during execution of system firmware . As indicated these initial scan chain images may be non destructively combined with additional scan chain inputs to obtain final scan chain images .

Referring now to there is depicted a high level logical flowchart of a method by which compression tool compresses a chip HW database in accordance with the present invention. As described in detail below the illustrated method implements at least three size optimizations.

First information related to a Dial instance may be eliminated from a chip HW database if the Dial instance will never be set or read by system firmware . Because such Dial instances will never be set or read by system firmware the DIDS corresponding to such Dial instances will never be referenced within HW configuration database and may accordingly be removed. It is important to note that the fact that system firmware does not set or read a Dial instance does not necessarily mean that the Dial instance is not set or read during simulation or laboratory debugging. Many Dial instances e.g. mode Switches are never set by system firmware but are tested during simulation to ensure that the mode Switches work properly if needed by a later firmware revision.

A second reason that information related to a Dial instance may be unnecessary is if the Dial instance is set to only one value in all configurations. In this case the DIDS corresponding to the Dial instance can be removed from chip HW database because the effects of setting the Dial instance can instead be achieved by setting the final scan chain image scanned into an integrated circuit chip with the latch value s that would be obtained by setting the Dial instance. The code within system firmware that sets the Dial instance can likewise be eliminated to reduce the size of system firmware ultimately obtained from laboratory testing and debugging.

Third mapping tables in DDDSs may be optimized by eliminating values to which Dials are never set by system firmware

In making the foregoing optimizations special consideration is given to Dial instances that are read. In general when a Dial instance is read it is assumed in the exemplary compression methodology described below that the entire Dial tree containing the Dial instance that is read must be preserved within its chip HW database. In addition it is assumed that all entries within the mapping tables of Dials in Dial trees containing Dial instances that are read must be preserved because in commercial deployment the hardware may set the underlying latches to values other than those read by system firmware. Consequently it cannot be determined a priori which mapping table entries will be required to read a Dial instance. Although these assumptions limit compression they ensure that each Dial instance that is read can be easily accessed regardless of whether or not the Dial instance is a top level Dial instance or a lower level Dial instance.

Referring first to the process begins at block and then proceeds to block which illustrates compression tool loading a chip HW database into volatile memory and creating in memory data structures and as described above. In addition as depicted at block compression tool creates in association with each DID S some additional temporary fields in memory used only by compression tool . These temporary fields include a Dial Instance Value Structure DIVS for storing the values if any to which the associated Dial instance is set within Dial usage information . For IDial instances the DIVS is handled specially. In particular the DIVS will either be empty contain a token indicating the IDial instance is set or for top level IDial instances only contain the single value to which the IDial instance is set if applicable. The temporary fields created for each DIDS at block also include a Dial Instance Preserve Field DIPF which is set to TRUE if the associated DIDS should be preserved i.e. not deleted from the compressed chip HW database and is set to FALSE otherwise. The DIPF of each DIDS if any explicitly listed in override file as a DIDS to be preserved is initialized to TRUE and all other DIPFs are initialized to FALSE.

The process then proceeds from block to block which illustrates compression tool entering a loop in which each top level pointer in top level pointer array is processed to enter relevant information from Dial usage information in the DIPF and DIVS of each DIDS . If all top level pointers have been processed the processes passes through page connector B to which is described below. If however all top level pointers have not yet been processed the next top level pointer within top level pointer array is selected for processing at block .

The process then passes from block to blocks and . Block illustrates compression tool processing each non IDial in the Dial tree headed by the Dial instance corresponding to the DIDS referenced by the current top level pointer . Compression tool adds to the DIVS of each such DIDS the values for the corresponding Dial instance contained within the Dial usage information . In addition as shown at block compression tool processes each IDial within the Dial tree headed by the Dial instance corresponding to the DIDS referenced by the current top level pointer . For each such IDial compression tool adds a set token to the DIVS if Dial usage information indicates that the IDial has been set.

Next at block compression tool sets the DIPF of every DIDS in the Dial tree headed by the Dial instance corresponding to the DIDS referenced by the current top level pointer if Dial usage information indicates that any Dial in the Dial tree was read. In other words each DIPF in the Dial tree is set to TRUE if any Dial instance in the Dial tree is read. The process then proceeds to block which illustrates compression tool examining each top level IDial if any corresponding to the DIDS referenced by the current top level pointer to determine whether override file indicates that the IDial is set to only a single value. If so compression tool adds to the DIVS of those top level IDials the value contained within override file and removes a set token if present.

Thereafter the process returns to block which illustrates the continuation of the processing loop until all top level pointers within top level pointer array have been processed. Once all top level pointers have been processed the process passes through page connector B to .

With reference now to the process proceeds from page connector B to block which illustrates a second processing loop in which each top level pointer within top level pointer array is processed. If a determination is made at block that all top level pointers within top level pointer array have been processed in the current processing loop the process passes through page connector C and continues in . Otherwise the process proceeds to block which depicts the selection of the next top level pointer within top level pointer array for processing.

Following block the DIVS and DIPF associated with the DIDS referenced by the current top level pointer are examined for one of three conditions respectively represented by decision blocks and . If a determination is made at block that the DIPF has a value of TRUE or if type field in the associated DDDS indicates that the DIDS corresponds to a Dial group the process simply returns from block to block for processing of the next top level pointer if any.

If however a determination is made at block that the DIPF associated with the DIDS referenced by the current top level pointer has a value of FALSE and the associated DIVS is empty then compression tool can remove the DIDS from chip HW database because none of the corresponding Dial instances is set or read. Accordingly as illustrated at block compression tool deletes the DIDS from chip HW database as well as each lower level DIDS if any in the Dial tree headed by the deleted top level DIDS . In addition compression tool deletes the associated top level pointer from top level pointer array and sets the instance pointer pointing to each deleted DIDS to NULL. A determination is then made at block of whether or not the parent pointer of the deleted DIDS was set to NULL. If so the process returns to block which has been described. If on the other hand the parent pointer was not NULL then the top level Dial instance s corresponding to the deleted DIDS belonged to Dial group instance s . Because the top level Dial instance s were never set or read each such top level Dial instance may be safely removed from its respective Dial group instance. Accordingly as shown at block compression tool deletes from the DIDS corresponding to the Dial group instance s the output pointer to the deleted DIDS of the top level Dial instance. If the deletion of the output pointer from the DIDS of the Dial group instances removes the last member of the Dial group the DIDS corresponding to the Dial group instance s is also deleted from chip HW database . This process continues collapsing hierarchical levels of Dial groups if possible. Following block the process returns to block which has been described.

Returning to block compression tool determines whether the DIPF associated with the DIDS referenced by the current top level pointer has a value of FALSE and the associated DIVS contains a single value. If not the process returns to block which has been described. If so a further determination is made at block by reference to parent field of the DIDS of whether the Dial instance belongs to a Dial group. If so the process preferably returns to block without further processing signifying that the DIDS will be preserved. The DIDS is preferably preserved because operations setting a Dial group are atomic and will fail if a removed Dial instance is referenced in the set Dial group API call. In response to a determination at block that the Dial instance corresponding to the DIDS referenced by the top level pointer does not belong to a Dial group the process proceeds to block .

Block illustrates propagating the single Dial value contained in the DIVS down the Dial tree by reference to mapping tables if necessary in order to determine the latch values of the latches terminating the Dial tree. The latch values determined at block are then placed within initial scan chain images in scan chain locations determined by reference to chip mapping table as illustrated at block . Therefore as shown as block the DIDS referenced by the current top level pointer its lower level Dial tree and top level pointer itself are all removed from the chip HW database as described above with respect to block . In addition the set Dial API call utilized to set the top level Dial instances corresponding to the deleted DIDS is removed typically by a human programmer from system firmware as shown at block . Thereafter the process returns to block which has been described.

Referring now to processing begins at page connector C and proceeds to block which illustrates a processing loop in which all Dial pointers within Dial pointer array are processed to eliminate from chip HW database any unnecessary DDDSs and any unnecessary entries within mapping tables . After all Dial pointers within Dial pointer array have been processed the process passes to block which is described below. If however less than all Dial pointers have been processed the process proceeds from block to block which illustrates selection of the next Dial pointer for processing.

Following selection of a next Dial pointer compression tool determines at block whether all instance pointers within instance pointer array of the DDDS referenced by the current Dial pointer are NULL. If so the entire DDDS is unnecessary and is removed from the chip HW database as shown at block . Following block the process returns to block which has been described.

In response to a determination at block that all instance pointers within the DDDS referenced by the Dial pointer are not NULL a further determination is made at block of whether or not type field indicates that DDDS defines a IDial. If so no optimization to mapping table is possible and the process returns to block . If compression tool determines that block that the DDDS referenced by the current Dial pointer does not define an IDial the process proceeds to block . Block depicts a determination of whether or not any DIPF associated with any DIDS referenced by an instance pointer has a value of TRUE. If so this condition indicates that at least one Dial instance of the Dial defined by DDDS has been read and therefore requires a full mapping table . Accordingly the process returns to block without performing any optimization to mapping table .

If however compression tool determines at block that all DIPFs associated with DIDSs referenced by instance pointers have a value of FALSE the process proceeds from to the processing loop illustrated at blocks and . This processing loop represents compression tool processing each instance pointer within the instance pointer array of the DDDS referenced by the current Dial pointer in order to build a Dial value set containing all values to which the Dial instances corresponding to the DIDSs were set by system firmware . As indicated at block the Dial values are obtained from the DIVS associated with each DIDS . After the Dial value set has been built through processing each instance pointer the process passes from block to block . Block illustrates compression tool removing each entry in mapping table of the DDDS referenced by the current Dial pointer whose Dial input value is not found within the Dial value set. This process continues down the Dial tree eliminating mapping table entries that are not utilized to generate the Dial value set. Thus mapping tables of individual Dials are optimized by the removal of unneeded entries. Thereafter the process returns to block .

In response to a determination at block that all Dial pointers within Dial pointer array have been processed compression tool performs a last compression at block by replacing common portions of instance names within instance name fields with pointers to a dictionary providing the full instance name portions. This compression technique which is well known to those skilled in the art replaces instance names or portions thereof with pointers which are typically significantly shorter than the instance name or instance name portions they replace. These pointers can then be replaced within instance name fields as a step in the process in which HW configuration database is loaded into volatile memory of service processor . Following block compression tool terminates processing at block .

After all of the chip HW databases have been compressed by compression tool in accordance with the method depicted in the compressed chip HW databases can then be utilized to construct hardware configuration database stored within flash ROM by simply constructing a chip pointer data structure . It should be noted that the compression methodology implemented by compression tool is not exclusive. HW configuration APIs preferably include a suite of APIs that permit a developer to remove individual DIDSs remove an entry in a mapping table and perform other optimizations similar to those illustrated in .

In the embodiments of the present invention described above it has been assumed that each Dial i.e. LDial or IDial that is logically coupled to a simulation configuration latch or hardware latch can set the value contained in the simulation configuration latch or hardware latch. In practice however it is often desirable to be able to read such latches without permitting system firmware or a simulator to set or alter the latch values.

In view of the foregoing a preferred embodiment of the present invention supports an additional class of configuration entities referred to herein as read only Dials or RDials. There is preferably a read only configuration entity corresponding to each type of Dial and Dial group described above that is a read only LDial CDial IDial and Dial group. For ease of understanding each read only configuration entity is referred to herein by the Dial or Dial group type name e.g. LDial CDial IDial and Dial group preceded by an R designating the configuration entity as read only e.g. RLDial RCDial RIDial and RDial group .

RDials and RDial groups are subject to a number of rule sets. First RDials and RDial groups are read only and by definition cannot be set by a simulator or system firmware. Consequently RDials and RDial groups cannot be assigned default values.

Second the syntax defining an RDial or RDial group within a configuration specification statement is preferably the same as that described above for the corresponding non read only configuration entity except that the keyword defining the configuration entity is preceded by an R . For example an exemplary configuration specification statement for an RLDial can be given as follows 

The exemplary configuration specification statement given above begins with the keyword RLDial which specifies that the type of RDial being declared is an RLDial and the RDial name which in this case is state machine. Next the configuration specification statement enumerates the signal name s whose states are read by the RLDial. Following the enumeration of the signal identifiers the configuration specification statement includes a mapping table listing the permitted enumerated input values or settings of the RLDial and the corresponding signal i.e. output values for each enumerated input value. It should again be noted that the signal states specified for all enumerated values are unique and collectively represent the only legal patterns for the signal states.

Third RDials have a different set of rules regarding interconnection with Dials and RDials and grouping of Dials and or RDials to form RDial groups. These rules are set forth in detail below with reference to which is a graphical representation of a portion of an exemplary configuration database including Dials and RDials having specified logical connections to latches of a simulation model or hardware system.

As an initial matter RDials are subject to similar restrictions on interconnection to other RDials and latches as set forth above with respect to the corresponding Dials. That is in a preferred embodiment an RIDial or an RLDial but not an RCDial can have its output directly coupled to a latch and an RCDial but not an RIDial or RLDial can have its output connected to the input of a lower level RDial. Thus for example RCDial has an output connected to the input of RCDial which in turn has two outputs respectively connected to the inputs of RLDial and RIDial . RLDial and RIDial have outputs connected to latches and respectively.

In addition an RCDial can have its output connected to the input of any type of Dial but no Dial is permitted to have its output connected to the input of any RDial. For example RCDial has an output coupled to the input of CDial . Although not explicitly illustrated in it should be noted that an RDial may have outputs connected to the inputs of RDials and or Dials at multiple different levels of the same subtree.

To prevent conflicting settings the Dials and Dial groups defined hereinabove permit each latch Dial and Dial group to have at most one Dial or Dial group as a parent hierarchically above it in an n way Dial tree. For example each of CDial and CDial has only one Dial parent i.e. CDial each of LDial and IDial has only one Dial parent i.e. CDial and each of LDial and IDial has only one Dial parent i.e. CDial . However because RDials and RDial groups are by definition read only any Dial or RDial may have one or more RDial or RDial group parents without any possibility of conflict between Dial settings. That is an RDial may have its output connected to a latch Dial or RDial to which the output of another RDial or Dial is also connected subject to the other rules and provided that no closed loop is formed. Stated another way each latch and Dial is permitted to have at most one Dial parent but each latch Dial and RDial can have one or more RDial parents regardless of whether the latch or Dial also has a Dial parent. For example in configuration database of an output of each of RCDial and RCDial is connected to the input of RCDial . Similarly CDial and RCDial each have an output connected to the input of CDial . Also RLDial and LDial each have an output connected to latch .

The final rule regards the construction of RDial groups. As described above in detail with reference to in a preferred embodiment a Dial group may only contain top level Dial s and or other hierarchically nested Dial group s . In contrast an RDial group may contain an RDial or Dial at any level of hierarchy and or a Dial group or RDial group. This additional flexibility is permitted because RDial groups like RDials are never set by a simulator or system firmware.

The implementation of RDials and RDial groups within a configuration database in combination with the Dials and Dial groups previously described in accordance with the rules set forth above permits construction of three classes of trees. First as exemplified by Dial trees and a tree may comprise Dial s and latch es but no RDials. Second a RDial tree for example RDial tree may comprise RDial s and latch es but no Dials. Third a hybrid tree may be constructed that contains one or more RDials one or more Dials and one or more latches as illustrated by hybrid tree .

In order to support RDials and RDial groups some modifications are made to a simulation configuration database and a HW configuration database. First the value set of the type field within each DDDS is augmented to include additional values identifying RDial groups and the additional types of RDials. For example the value set may be augmented with values RL RC RI and RG to respectively identify DDDSs corresponding to RLDials RCDials RIDials and RDial groups. The addition of these new values ensures that a set Dial or set Dial group API call which preferably test the type field of the associated DDDS prior to attempting to set any instance will not attempt to set an RDial or RDial group.

In addition as illustrated in each DIDS is expanded to include a read only parent field including zero or more read only parent pointers . Each non NULL read only parent pointer defines either a connection between the input of the instance represented by the DIDS and the output of a higher level RDial or the inclusion of the instance represented by the DIDS within an RDial group. As noted above in addition to a Dial or Dial group parent if any an instance represented by a DIDS can have multiple RDial parents and or belong to multiple RDial groups.

As depicted in latch data structures within a configuration database e.g. latch data structure of a HW configuration database or latch data structure of a simulation configuration database are similarly augmented to include a read only parent field including one or more read only parent pointers . Each non NULL read only parent pointer defines a connection between the input of the latch instance represented by the latch data structure and the output of a RIDial or RLDial. As noted above in simulation latch names within latch name field are preferably specified with reference to the scope of the LDial or IDial indicated by parent pointer . If parent pointer is NULL indicating that the configuration latch corresponding to the latch data structure has no Dial parent the latch name contained within latch name field is preferably specified with reference to the scope of the RLDial or RIDial corresponding to the DIDS identified by the first read only parent pointer within read only parent field .

Finally top level pointer array although structurally unchanged is increased in length to support RDials and RDial groups. Specifically top level pointer array includes top level pointers to the DIDS of each top level RDial group each top level RDial included within an RDial group i.e. having a non NULL read only parent field and each top level RDial not included within an RDial group i.e. having a NULL read only parent field .

The foregoing modifications to the data structures in a configuration database to support RDials and RDial groups necessitates concomitant modifications to the method of loading and expanding a configuration database from non volatile storage into volatile storage that was described above with reference to . is a high level logical flowchart of an exemplary method of loading a configuration database containing RDial and or RDial groups from non volatile storage into volatile memory in accordance with a preferred embodiment of the present invention. As indicated by the use of like reference numerals the method illustrated in is substantially similar to that described above with reference to with some additions to ensure that each data structure is processed only once.

As indicated by prime notation a first modification to the method previously described is made at block . In the method of block represents a determination of whether or not the DIDS referenced by the current top level pointer corresponds to a Dial or Dial group belonging to a Dial group. Block in adds to this determination a further determination of whether or not the DIDS referenced by the current top level pointer corresponds to a Dial RDial Dial group or RDial group belonging to a RDial group. If either determination obtains an affirmative response processing of the current top level pointer terminates as indicated by the process returning to block because the DIDS referenced by the current top level pointer will be processed when the Dial group or RDial group is processed. This determination ensures that the DIDS of top level Dials and RDials are processed only once.

To ensure that lower level data structures are also processed only one time during the process of loading the configuration database into volatile memory a further determination is made at block whether the DIDS referenced by the current top level pointer corresponds to a RDial or RDial group. If not that is if the tree rooted at the DIDS corresponds to a Dial or Dial group then none of the children in the tree can be RDials or RDial groups. Accordingly the subtree below the current DIDS can be processed as before as indicated by the process passing from block to block .

However in response to a determination at block that the DIDS referenced by the current top level pointer corresponds to a RDial or RDial group the process passes to block and following blocks which represent processing the subtree of the RDial or RDial group to ensure that each data structure in the configuration database is processed only once. To track which data structures have been processed the current DIDS is first marked as processed at block . Then as indicated at block the process enters a processing loop in which each output pointer within the output pointer array of the current top level DIDS is processed. Once all output pointers have been processed the process exits the processing loop and returns to block which represents a determination of whether or not any additional top level pointers remain to be processed.

If a determination is made at block that not all output pointers have been processed the next output pointer within output pointer array is selected for processing at block . The process then proceeds to blocks and which respectively illustrate a determination of whether or not the selected output pointer points to a DIDS corresponding to a Dial or Dial group or whether the DIDS referenced by the output pointer is a RDial or RDial group that has been marked as previously processed. If a positive result is obtained at block an interface between an RDial or RDial group and a Dial or Dial group has been located. Because the subtree headed by the Dial or Dial group will be processed when another top level pointer is selected for processing processing of this subtree terminates and the process returns to block . Processing of the subtree similarly terminates in response to a determination at block that the DIDS referenced by the current output pointer which corresponds to a RDial or RDial group is marked as previously processed.

If on the other hand the determinations illustrated at blocks and yield negative results the DIDS or latch data structure referenced by the current output pointer is marked and processed at block . The processing performed at block is the same as that illustrated at block and and described above. As further indicated at block each lower level data structure in the subtree up to and including the latch es terminating the subtree is similarly marked and processed subject to the two conditions depicted at block and . That is processing of any subtree is discontinued if an interface with a Dial or Dial group is detected or if a data structure e.g. a latch data structure or DIDS corresponding to a RDial or RDial group that has been marked is detected. Following block the process returns to block which has been described.

The implementation of RDials and RDial groups also entails some adjustments in the manner in which Dials Dial groups RDials and RDial groups are read for both simulation and hardware implementations of the digital design. In particular as the trees are traversed to create the latch set of interest ultimately targeted by a read Dial or read Dial group API call for example at blocks the branches i.e. DIDS corresponding to Dials or RDials traversed to create the latch set are preferably recorded or marked. In this manner when the latch values of the latches in the latch set are propagated up the trees to obtain Dial and RDial settings for example as illustrated at block the correct branches are upwardly traversed from the latch data structures to obtain the Dial or RDial settings of interest. In other words because a Dial or RDial may have one or more RDial parents in addition to a single Dial parent if any the parent pointers of the branches traversed downwardly to obtain the latch values must be recorded or marked to ensure that the same branches are traversed upwardly to obtain the desired Dial or RDial setting.

Another adjustment is preferably made to the compression routine illustrated in . In the described embodiment block of depicts removing the entire Dial tree of a top level DIDS that Dial usage information and therefore the DIPF indicates was not set or read. With the implementation of RDials and RDial groups which as shown in permits the upward branching of trees it is preferable if this step is modified to preserve any lower level DIDSs also belonging to the subtree of a RDial instance that was read. In this modification after the top level DIDS is removed the DIPF of each lower level DIDS in the subtree of the deleted DIDS is tested to determine if it has the value TRUE which indicates that the lower level DIDS also belongs to a tree that was read. If not the lower level DIDS can also be removed and the removal process continues down the subtree. However if a lower level DIDS having a DIPF set to TRUE is located that lower level DIDS and its subtree are not removed. However its parent pointer is set to NULL to reflect the removal of the parent DIDS referenced by parent pointer .

When debugging and testing a hardware digital design in a laboratory environment or responding to a failure of a deployed hardware system analysis of failures to determine their causes is a crucial task. Conventionally to facilitate the determination of the causes of a failure a scan dump of all of the test scan chains within the hardware digital system is obtained. The scan chain images are then analyzed to determine the cause of the failure. Frequently particular scan chain bits are hand selected and input into a simulation model of the digital system in an attempt to reproduce the failure in simulation. Simulation of hardware failures enables the improved signal visibility and stepping capability of a simulator to be leveraged to assist in the determination of the causes of the failures.

This conventional failure analysis is tedious and error prone in that a user must first attempt to determine which bits in the sea of bits provided by the scan dump are important to port to the simulation system in order to recreate the error condition. The user must then scan through the scan dump by hand by reference to possibly erroneous paper documentation in order to determine the values of the bits of interest. Finally the user must program a RTX or other software program to load the latches of the simulation model with the appropriate bit values.

The present invention improves upon such prior art analysis techniques by leveraging the features of the configuration specification language and the hardware and simulation configuration databases described above. With reference now to there is depicted a high level logical flowchart of an exemplary process for utilizing a simulation model to analyze a selected state of a hardware system and in particular a failure state of a hardware system. As shown the process begins with the operation of a chip analyzer tool which preferably comprises software executing on a computer system such as data processing system of . Chip analyzer tool receives as inputs test scan chain images which collectively represent the system failure state and which each contain the latch values of all of the latches of a respective integrated circuit chip within a hardware digital design e.g. a server computer system under test . In addition chip analyzer tool receives the per chip type chip HW database for each type of integrated circuit chip within the hardware digital design. Finally chip analyzer tool is provided a selected Dial list which identifies which Dials within each chip HW database are deemed relevant to approximate the hardware failure state in simulation.

Chip analyzer tool processes the scan chain images and the selected Dial list by reference to chip HW databases to generate a respective chip configuration report and simulation setup file for each integrated circuit chip in the hardware digital design. Each chip configuration report comprises a human readable and printable listing of all of the Dial instances associated with a particular integrated circuit in the hardware digital design together with the setting if a legal value is available of each Dial instance at the point of failure. For Dial instances for which legal values are not available the underlying latch values are reported. Each simulation setup file is a machine readable file specifying the setting if a legal value is available of each Dial identified in selected Dial list that is associated with the corresponding integrated circuit chip. As explained below an RTX utilizes simulation setup files to configure a simulation model of the hardware digital system to a state approximating the failure state of the hardware digital design.

Referring now to there is illustrated a high level logical flowchart of an illustrative method by which chip analyzer tool of generates the chip configuration reports and simulation setup files utilized to analyze hardware failures in accordance with the present invention. As illustrated the process begins at block and then proceeds to block which depicts chip analyzer tool determining whether the scan chain images of each integrated circuit chip within the hardware digital design have been processed. If the scan chain images of all integrated circuit chips have been processed the process terminates at block . If however fewer than all of the scan chain images have been processed the scan chain images and chip HW database of the next integrated circuit chip to be processed are selected at block .

The process shown in then enters a processing loop at blocks in which each latch value of interest scanned from the current integrated circuit chip is processed by reference to the latch pointers in the latch pointer array of chip HW database . Specifically chip analyzer tool determines at block whether or not all latch pointers have been processed. If so the process passes from block to block which is described below. If however all latch pointers have not yet been processed the next latch pointer within latch pointer array is selected for processing at block . Next at block chip analyzer tool utilizes the test scan ring identifier and offset value pair contained in the method name field of the latch data structure referenced by the current latch pointer to locate within scan ring images the latch value of the hardware latch corresponding to the latch data structure . This latch value is then stored within the appropriate entry of latch value field which is determined by reference to the position of the chip ID of the current integrated circuit chip within chip mapping table . Thereafter the process returns to block .

In response to a determination at block that all latch pointers within the latch pointer array of the current chip HW database have been processed the process proceeds to block . Block depicts chip analyzer tool propagating the set of latch values contained in each latch value field up all branches of the DIDS trees within the chip HW database by reference to mapping tables in order to obtain the setting i.e. input value of each Dial and RDial if possible. Given the fact that the latch values within latch value fields correspond to a hardware failure state it is frequently the case that an attempt to propagate at least some latch values up a tree will result in at least one output value that is not among the legal output values specified within the mapping table for a Dial or RDial instance. In such cases the Dial or RDial instance and any RDial or Dial above it in the same tree is flagged as having an illegal value. Such illegal values frequently suggest the cause of the hardware failure.

It should be noted that the ability to derive Dial and RDial values from latch values depends upon the invertibility of the configuration specification language introduced by the present invention. That is without a one to one mapping between Dial and RDial inputs and outputs Dial and RDial settings cannot be definitely determined from latch values as shown at block .

Following block the process proceeds to block which depicts chip analyzer tool creating a chip configuration report for the current integrated circuit chip. As noted above chip configuration report is a human readable file containing a listing of all Dial and RDial instances within the current chip HW database and their corresponding settings if any determined at block . Dial and RDial instances having illegal values are flagged in chip configuration report and the latch values of the underlying latches are listed to facilitate analysis. As shown at block chip analysis tool also creates an RTX compatible simulation setup file for the current integrated circuit. Simulation setup file preferably includes the Dial settings of only the Dial instances specified within selected Dial list and if a Dial instance specified in selected Dial list has an illegal value the latch values of the underlying latches in the latch set controlled by the Dial. These Dial instance settings and latch values can then be applied automatically to a simulation model by an RTX running in a simulation environment as explained below.

It should be appreciated that because the number of latches controlled by Dials is typically only a small percentage of the overall number of latches in an integrated circuit the designer of the digital system through the use of the configuration specification language of the present invention to associate Dials with particular configuration latches has already greatly reduced the number of latch values to be considered in recreating the system failure state and has identified those latches most likely to be necessary to reproduce the hardware failure state. Selected Dial list further reduces the amount of hardware state information to be ported back into a simulation model by designating particular user selected Dial instances not RDial instances of interest.

Following block the process depicted in returns to block for the processing of the next integrated circuit chip in the hardware digital design if any. After all integrated circuit chips within the hardware digital design are processed the process terminates at block .

Referring again to following the creation of a respective simulation setup file for each integrated circuit chip within the hardware digital design in accordance with the process of the hardware failure state is approximated within a simulation model of the digital design through the execution of RTX . As an aside it should be noted that it is generally undesirable to reproduce the exact hardware failure state in simulation because the digital design by definition will not operate correctly from the failure state.

In order to approximate the hardware failure state in simulation RTX first makes standard API calls to the APIs provided by simulator in order to perform the normal initialization procedures utilized to initialize simulation model for simulation. Next RTX may optionally make individual user specified customizations to the configuration of simulation model based upon the contents of a user provided custom initialization modifications file . These custom modifications may be made for example to adjust a parameter to expose a particular failure mode or to improve the visibility of certain types of failures. Finally RTX applies the Dial instance settings and latch values contained in simulation setup files . As described in detail above with reference to RTX sets Dial instances through set Dial API calls to a configuration API which after reflecting the Dial instance settings in simulation configuration database calls PUTFAC API to set corresponding latch values in simulation model . RTX similarly utilizes API calls to set the configuration latches of simulation model and latch value fields of configuration database with the latch values contained within simulation setup files that correspond to illegal Dial values. With simulation model thus configured RTX directs execution of one or more test cases against simulation model by simulator in order to attempt reproduction of the hardware failure state in simulation.

While the invention has been particularly shown as described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration entities having different rules than the particular exemplary embodiments disclosed herein. In addition although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal bearing media which include without limitation non rewritable storage media e.g. CD ROM rewritable storage media e.g. a floppy diskette or hard disk drive and communication media such as digital and analog networks. It should be understood therefore that such signal bearing media when carrying or encoding computer readable instructions that direct the functions of the present invention represent alternative embodiments of the present invention.

