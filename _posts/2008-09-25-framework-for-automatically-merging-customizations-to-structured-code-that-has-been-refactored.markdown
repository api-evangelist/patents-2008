---

title: Framework for automatically merging customizations to structured code that has been refactored
abstract: A method of generating a tool for merging customizations made to a first version of a software artifact when migrating to a second version includes instantiating a mapping element for each top-level element in a first code set that does not have a complementary element in a second code set; requesting and receiving merge instructions for each top-level element for which merge instructions are not provided in the corresponding mapping element; determining whether the merge instructions for each top-level element for which merge instructions are provided require that customizations be merged into the second code set; determining whether the merge instructions for each top-level element set that requires customizations to be merged are valid; requesting and receiving merge instructions for each top-level element for which the merge instructions are not valid; and storing the merge instructions received for each top-level element in the corresponding mapping element.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321834&OS=08321834&RS=08321834
owner: International Business Machines Corporation
number: 08321834
owner_city: Armonk
owner_country: US
publication_date: 20080925
---
The present application is co pending with the concurrently filed application entitled COMPARING AND MERGING STRUCTURED DOCUMENTS SYNTACTICALLY AND SEMANTICALLY assigned to the assignee of the present application the contents of which are incorporated herein by reference in their entirety.

Exemplary embodiments of the present invention relate to software maintenance and more particularly to revision control software tools that include merge capabilities.

Version control refers to the management of different versions and variants of data files and software. As software is developed designed and deployed it is extremely common for multiple states or versions of the same software to be deployed in different sites as well as for the software s developers to be working simultaneously on updates. Code reuse which refers to the use of existing software to update software or implement new software is based on the idea that a partial or complete computer program written at one time can be should be or is being used in another program written at a later time. Programmers have reused sections of code templates functions and procedures from the earliest days of programming to save time and energy by reducing redundant development work. The most common type of reuse of is the reuse of software components but other artifacts produced during the software development process such as system architecture analysis models design models design patterns database schemas web services can also be reused. The general development practice of using a prior version of an extant program as a starting point for the next version is a standard form of code reuse.

A more typical example of code reuse is the topic of end user development EUD which refers to activities or techniques that allow people who are not professional developers to create or modify a software artifact. EUD may be viewed as essentially out sourcing the development effort to the end user. A common instance of EUD is programming to extend and adapt an existing application package for example an office suite . Two main reasons why EUD has become popular are because organizations can use EUD to effectively cut the time of completion on a project and because software tools are more powerful and easier to use. A drawback with the implementation of EUD however is that it can increase the complexity of software maintenance which generally involves the modification of a software product after delivery to correct faults to improve performance or other attributes or to adapt the product to a modified environment. In particular where an end user has made individual customizations to programming code it is difficult for the original developer of that code to account for these customizations in considering the processes of implementation and product acceptance for the maintenance modifications.

An exemplary embodiment of a method of generating a tool for merging customizations made to a first version of a software artifact when migrating to a second version of the software artifact includes instantiating a mapping information element in a first data store for each top level data element in a first code set for the first version that does not have a complementary data element in a second code set for the second version requesting merge instructions for each top level data element in the first code set for which merge instructions are not provided in the corresponding mapping information element for the top level data element receiving merge instructions for each top level data element in the first code set for which merge instructions are not provided determining whether the merge instructions for each top level data element in the first code set for which merge instructions are provided require that customizations made to the top level data element be merged into the second code set determining whether the merge instructions for each top level data element in the first code set that requires customizations made to the top level data element to be merged are valid requesting merge instructions for each top level data element in the first code set for which the merge instructions are not determined to be valid receiving merge instructions for each top level data element in the first code set for which the merge instructions are not determined to be valid and storing the merge instructions received for each top level data element in the first code set in the corresponding mapping information element in the first data store.

Exemplary embodiments of the present invention that are related to computer program products and data processing systems corresponding to the above summarized method are also described and claimed herein.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

The detailed description explains exemplary embodiments of the present invention together with advantages and features by way of example with reference to the drawings. The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the specification concludes with claims defining the features of the invention that are regarded as novel it is believed that the invention will be better understood from a consideration of the description of exemplary embodiments in conjunction with the drawings. It is of course to be understood that the embodiments described herein are merely exemplary of the invention which can be embodied in various forms. Therefore specific structural and functional details disclosed in relation to the exemplary embodiments described herein are not to be interpreted as limiting but merely as a representative basis for teaching one skilled in the art to variously employ the present invention in virtually any appropriate form. Further the terms and phrases used herein are not intended to be limiting but rather to provide an understandable description of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the content clearly indicates otherwise. It will be further understood that the terms comprises includes and comprising when used in this specification specify the presence of stated features integers steps operations elements components and or groups thereof

Exemplary embodiments of the present invention can be implemented to provide a mechanism that can be employed regularly during the software development cycle for monitoring changes made to the code of a current version of a software artifact during development of a new version of the software artifact and generating an automated tool providing solutions for merging customizations made by a third party to the code of the current version for each instance where a data element is present in the current version of the software artifact but does not have a complementary data element in the new version of the software artifact. By providing solutions for merging customizations for each of these instances exemplary embodiments can operate to generate a tool for automatically merging customizations made to data elements of the current version of a software artifact into a new version even where the code of the software artifact has been significantly refactored between versions. As used herein the term data element refers to an atomic unit of data that includes an identification such as a data element name a data element definition and one or more representation terms.

As referred to herein a data element that is present in a current version of a software artifact is said to not have a complementary data element in a new version of the software artifact where the data element no longer exists or is structured differently in the new version of the software artifact. More particularly a data element that is present in a current version of a software artifact is said to not have a complementary data element in a new version of the software artifact where one of the following five differences between the current version and the new version is present 1 the data element has been deleted between versions 2 the data element exists in the same structured programming language document as in the current version but is associated with a different parent element in the new version 3 the data element exists in a different structured programming language document and is associated with a different parent element in the new version 4 the data element associated with the same parent element but exists in a different structured programming language document in the new version and 5 the data element has been renamed in the new version.

In exemplary embodiments the tool generated for automatically merging customizations made to the code of a current version of a software artifact can provide a data store of merging solutions for reconciling customizations made to data elements that are present in the current version but do not have a complementary data element in the new version of the software artifact and an interface that is accessible by an automated data migration tool when performing code migration from the current version to a new version that services the merging solutions as dictated by the customizations made by the customer to the code of the current version. As used herein the term data store refers to any suitable memory device that may be used for storing data including manual files machine readable files and databases. Exemplary embodiments can implemented so that the tool generated for automatically merging customizations to the current version into the new version requires only a minimal amount of developer input thereby significantly reducing development cost even in situations where a significant amount of code refactoring has been performed between the release of the old version and the new version.

The mechanism for generating an automated tool that provides solutions for merging customizations made by a third party to the code of the current version for each instance where a data element is present in the current version of the software artifact but does not have a complementary data element in the new version of the software artifact generally outlined above will be described in greater detail herein with reference to exemplary embodiments in which the software artifacts comprise structured documents in the form of XML documents that are not defined by an XML schema and are formatted according to semantic constraints to include a number of elements that may be ordered or unordered. It should of course be understood that this scenario is exemplary only and that exemplary embodiments of the present invention can be implemented to provide a mechanism for generating an automated tool that provides solutions for merging customizations to software artifacts comprising structured documents of any type not just XML language documents. Exemplary embodiments can be applied to software artifacts comprising documents coded in a wide range of structured languages including for example HTML WML XHTML DHTML or other SGML derivatives as well as other structured languages such as user interface markup languages for example UIML XAL SVG XAML and LZX the programming languages Pascal and C and languages used to define two or three dimensional layouts structures or integrated circuits. Exemplary embodiments can also be applied to software artifacts comprising documents coded in structured languages used for storing scientific information engineering information business information games cryptography and other areas of information technology. A document written in a structured language will generally have a hierarchical structure of elements in which the structure is generally defined by tags that is sequences of characters in the document . Furthermore exemplary embodiments can be implemented to be applied to for any suitable type of software artifact such as software components system architectures application packages analysis models design models design patterns database schemas web services and the like.

The XML standard is governed by the World Wide Web Consortium and is maintained on the Internet at the web site of the World Wide Web Consortium W3C . XML describes a class of data objects called XML documents and partially describes the behavior of computer programs which process them. An XML document is a structured self descriptive document having a collection of elements and that facilitates some form of automatic semantic integration. Thus as used herein the terms XML element or XML data element refers to the code terms contained between a set of brackets as defined by the rules of XML. XML is classified as an extensible language because it allows users to define their own elements which contain either parsed or unparsed data. Parsed data is made up of characters some of which form character data and some of which form markup. Each element may have a list of associated attributes and elements. An element may refer to other elements to cause their inclusion in the document. A document begins in a root or document element. Markup encodes a description of the document s storage layout and logical structure. Logically the document is composed of declarations elements comments character references and processing instructions all of which are indicated in the document by explicit markup. XML provides a mechanism to impose constraints on the storage layout and logical structure. By adding these semantic constraints application languages can be implemented in XML.

The following example scenario involving the merging of software artifacts that include customizable XML documents for which no XML schema has been defined illustrates some of the issues that may arise during maintenance of the software artifacts that exemplary embodiments of the present invention can be implemented to address. In the example scenario a software vendor initially produces version 1 of the code for an application package that includes a set of customizable XML documents. The XML documents are provided according to specified semantic constraints but no XML schema is defined for the documents. A customer purchases version 1 of the application package and understanding the semantics of the XML documents customizes the application code by modifying elements of the XML documents. The customer may also define new elements for use in the customizable documents. The vendor then decides to enhance the application package by adding new functionality some of which will be implemented through updates to the customizable XML documents.

Prior to updating the application the vender decides to refactor the code for version 1 of the application package. Code refactoring which is usually motivated by the difficulty of adding new functionality to a program or fixing a bug in it refers to the process of changing programming code to make it amenable to change improve its readability or simplify its structure while preserving its existing functionality and is sometimes informally referred to as cleaning it up. For example code refactoring can be used to improve the understandability of code by changing its internal structure and design and removing dead code and other code bloat. An example of a trivial refactoring is changing the character sequence to used for an identifiers for example changing a variable name from a single letter i to a more meaningful interestRate character sequence.

After refactoring and adding new functionality to the code the vender s code for the updated version of the application version 2 is based on version 1. The customer then decides to upgrade to version 2 of the application. Because the user has customized the XML documents in version 1 to get the new features of version 2 without losing the customizations the changes that were made by the customer to the XML documents for version 1 will need to be merged into the XML documents of version 2. Because of the refactoring however some elements that were present in version 1 may no longer exist or may be structured differently in version 2. As a result elements of the code for version 1 of the application package that have been customized by the customer may no longer exist or be structured differently in version 2 and therefore using prior art merging techniques these customizations will need to be integrated manually. Exemplary embodiments of the present invention however can provide a tool for automatically merging customizations made to elements of the code for version 1 that no longer exist or are structured differently into version 2 even though the code of the application package has undergone refactoring between the two versions.

Exemplary embodiments of the present invention can be implemented to verify the correctness of the generated solutions for merging customizations made to the code of a current version of a software artifact into a new version by regularly performing validation on the solutions up until the release of the new version which can provide a benefit in terms of post release maintenance cost. This can be far less error prone than requiring customers to manually re implement their customizations after migrating to a new version or requiring developers to manually monitor updates to the code of the current version during development of the second version and document instructions to be followed by customers manually to merge their modifications to the current version code into the new version code after or during migration to the new version particularly for situations where the software artifact is produced by a large development team and includes a large number of files.

Referring now to an exemplary embodiment of a merge solution tool framework in accordance with the present invention is illustrated. As will be described merge solution tool framework is implemented to monitor changes made to the XML code file of a current version of a software artifact that includes a set of customizable XML documents during development of the XML code file for a new version of the software artifact and generate an automated tool providing solutions for merging customizations made by a third party to the customizable XML documents of the current version for each instance where an XML element that was present in the current version but does not have a complementary XML element in the XML documents for the new version of the software artifact. Merge solution tool framework provides a mechanism that can be employed regularly during the software development cycle to continuously integrate changes made between versions by updating the merge solutions provided by the automated tool.

In the present exemplary embodiment merge solution tool framework includes a top level element monitoring module a merging resources module a merge solution validator module a merge solution producer module a merge request producer module a merge solution consumer module and a merging interface producer module . As used herein the terms module and program module both include routines programs objects components data structures and instructions or instructions sets and so forth that perform particular tasks or implement particular abstract data types. As can be appreciated the modules can be implemented as software hardware firmware and or other suitable components that provide the described functionality which may be loaded into memory of a machine embodying exemplary embodiments of a version comparison mechanism in accordance with the present invention. Aspects of the modules may be written in a variety of programming languages such as C C Java etc. The functionality provided by the modules described with reference to exemplary embodiments described herein can be combined and or further partitioned.

Generally in the present exemplary embodiment element monitor is implemented to regularly monitor development to identify top level or parent XML elements that are present in the current version of a software artifact and do not have a complementary XML element in the new version as the new version is being developed for release at a later date. An XML document contains a tree based semantical structure that has exactly one root element. The top level XML elements identified by element monitor as will be described in greater detail below are all the XML elements of the XML documents that are present in the current version of a software artifact and do not have a complementary XML element in the new version and furthermore have no ancestor elements in the tree structures of the XML documents that do not have a complementary XML element in the new version.

Also generally merging resources is implemented to store customization mapping information for solutions for merging customizations made to each of the elements that no longer exist or are structured differently into the new version validator is implemented to receive the customization mapping information from merging resources and perform validation of the customization mapping on the new version solution producer is implemented to automatically generate merging solutions for customizations made to descendent elements of parent elements identified by element monitor for which the merge solution has been generated request producer is implemented to request and accept customization mapping information input from the developer for merging solutions for customizations made to each of the elements that do not have a complementary element in the new version for which merging solutions cannot either be generated by solution producer or validated by validator solution consumer is implemented to read and process the customization mapping information from merging resources to determine whether a merging solution for an element is provided by the mapping information and whether there is a need to generate a merging solution for the element and merging interface is implemented to provide an interface for providing the generated merge solutions in a manner that enables fully automated merging of customizations made to the current version of the software artifact during migration to the new version in a manner that requires far less developer input.

In the present exemplary embodiment element monitor is implemented with a deserializer that is configured to deserialize first version and second version to generate and store a memory model representation of each version into memory model . Each memory model representation takes the form of a hierarchical node labeled tree data structure. A tree data structure which is an acyclic and connected graph having a set of linked nodes is commonly used for representing XML documents which utilize a tree based semantical structure that has exactly one root element. Trees may be manipulated in more complex ways than ordered lists of text lines. For instance in the present exemplary embodiment the tree structured memory model representations of the documents can each include a number of ordered and or unordered nodes. Each node in a tree has zero or more child nodes which are below it in the tree by convention trees grow down not up as they do in nature . A node that has a child is called the child s parent node or ancestor node or superior . The topmost node in a tree is called the root node. Being the topmost node the root node will not have parents. As shown in deserializer operates to deserialize first version and second version into first memory model representation and second memory model representation respectively and to store these memory model representations in memory model .

The memory model representations generated by deserializer operate to automatically create a mapping relationship between the elements of the XML documents of the input versions that is sufficiently flexible to satisfy the requirements of the syntactical and semantical comparison performed by compare module as will be described in greater detail below. In the representation form maintained in memory model each XML element of a represented document corresponds to a tree node in the representation. Each such tree node has a context that contains a the attributes of the corresponding XML element b all descendent XML elements and their respective attributes of the corresponding element and c a unique identifier for the node. By this definition it can be seen that node contexts are hierarchical. The children of a node are the elements contained in the element corresponding to the node.

To account for the fact that some XML documents can be provided with a semantic for which order is not important for some or all of the elements the memory model representations employ the concept of the unique identifier to identify counterpart elements across documents. Unique identifiers provide a reliable marker for compare module to access when tracking changes made to elements of the software artifact code between versions that ensures that element contents are compared under the correct corresponding parent element. A unique identifier for a node includes the name of the corresponding element and zero or more attribute values of the corresponding element. To generate the unique identifier of each node context deserializer employs a repository of identifier determination rules that are applied to each of the XML elements according to the values of one or more attributes of the element.

In exemplary embodiments deserializer can be implemented to provide a pluggable framework for the repository of identifier determination rules for generating the unique identifiers that supports easy addition and modification of identifier determination rules. For example the unique identifiers for each node can be generated according to any suitable implementation of alternative identifier determination rules that allow for each node to be distinctly identified without relying on the name and or attributes of the corresponding element. The generation of unique identifiers performed by deserializer is dependent upon the identifier determination rules in the pluggable repository. Thus deserializer is flexible in that a user can control the details of identifier determination and thereby tailor the unique identifiers to meet the requirements of specific applications.

Under the memory model of the present exemplary embodiment sibling nodes cannot have the same unique identifier. To satisfy this requirement deserializer can be configured to generate unique identifiers that have different composite sets of attribute values for different corresponding element types. Thus the memory model representations there can be two different forms of unique identifiers. In the first type the name of the XML element represented by the node is used without any attribute values to form the unique identifier. In such a case it is expected that only one node context of this type occurs within the memory model representation of each version. In the second type of unique identifier the name of the XML element represented by the node and each value of one or more attributes of the element are used to form the unique identifier. In such a case there may be more than one node with this element name contained within the memory model representation of each version and the values of the one or more selected attributes in the unique identifiers are used to distinguish each node.

It is not required that the values of all the attributes for an XML element be included in the unique identifier for the node corresponding to the element as long as the values or the combinations of values are unique to a parent node and each descendent node under the parent separately. To this end element monitor in addition to otherwise ensuring that each memory model representation is well formed is configured to validate that each unique identifier in the memory model representation of each document is unique within the generated representation.

The unique identifiers having composite sets of attribute values provide for a flexible reliable and transparent mechanism for use by compare module in performing the comparisons to accurately determine the differences between two versions of a software artifact by taking into consideration the semantics of the document. Under the memory model an element in an XML document of first version is considered a counterpart of another element in an XML document of second version if the corresponding nodes for both elements have the same unique identifiers in the memory model representations of the versions. Counterpart elements are identical if their corresponding nodes have the same unique identifier and equivalent values for each of the corresponding attributes in the composite attribute set.

The unique identifiers must remain consistent between the versions of the software artifact provided by the vendor. Customers that make modifications to a version of the software artifact however are not required to have unique identifiers defined for elements they add or customize. When a customer changes any part of an element used to generate a unique identifier for the node corresponding to the changed element this will have the same effect in merge solution tool framework as if that element were deleted in the new version and then added as new element to the new version. This can be used as a way for the customer to provide an indication within a memory model node corresponding to an element of a represented document that they do not desire to have any updates that the vendor provides for that element mergedt.

Compare module employs a pluggable repository of comparison rules for performing the comparison between the memory model representations of the documents to determine the differences therebetween. To identify the same node in two different memory model representations the comparison rules are configured to be applied to link counterpart nodes that is nodes having the same unique identifier in the two representations being compared in the two representations of the versions of the software documents being compared and to generate information about the differences between the elements corresponding to the counterpart nodes in the two versions during the comparison. In exemplary embodiments compare module can be implemented to provide a mechanism through which additional rules can be added to the pluggable repository of comparison rules so that more information about the differences between the elements of the each documents of the versions of the software artifacts being compared can be determined. The comparison performed by compare module is dependent upon the comparison rules in the pluggable repository. Thus compare module is flexible in that a user can control the details of the comparison and thereby tailor the information generated in particular comparisons to meet the requirements of specific applications.

Referring now to a flow chart illustrating an exemplary embodiment of a process that may be performed by compare module for comparing two XML elements in two different XML documents to determine their differences by accessing the contexts of nodes corresponding to those elements in the memory model representations of the versions being compared is provided. To perform such a comparison between versions compare module can be configured to repeatedly perform exemplary process to compare each element in the first version once with each element in the second version and thereby explore all possible top level element additions deletions and other changes between the two versions.

Exemplary process begins at decision block by determining if the XML documents of the software artifact containing the elements being compared are provided with a semantic specifying that order is not important for the elements. If the XML documents are provided with a semantic specifying that order is important process proceeds to decision block and determines if the respective unique identifiers for the nodes corresponding to the elements in the memory model representations for the versions being compared are the same. If it is determined at decision block that the respective unique identifiers are not the same process proceeds to block and records that the first element being compared does not exist in the version containing the second element being compared. Process then terminates. If it is determined at decision block that the XML documents of the application package are provided with a semantic specifying that order is not important for the elements process proceeds to decision block and determines if the respective unique identifiers for the nodes corresponding to the elements in the memory model representations for the versions being compared are the same.

If it is determined either at decision block or at decision block that the respective unique identifiers for the nodes corresponding to the two elements being compared are the same the two elements being compared are counterpart elements and process proceeds to block . At block the attributes of the two counterpart elements as provided in the memory model representation contexts of the nodes corresponding to the elements are compared to identify any added attributes identify any deleted attributes and identify any attributes with changed values. Process then proceeds to block at which the sequences of the child elements of the two counterpart elements as provided in the memory model representation contexts of the nodes corresponding to the elements are compared based on the unique identifiers for the child elements to identify any differences in the child element sequences of the two counterpart elements. The information regarding the differences between the elements identified during the comparisons made at blocks is recorded in the generic memory model at block .

If it is determined at decision block that the respective unique identifiers for the nodes corresponding to the two elements being compared are not the same process proceeds to decision block at which it is determined whether the unique identifier for the node corresponding to the first element being compared is the same as any of the unique identifiers for the nodes corresponding to the sibling elements of the second element being compared. If it is determined that the unique identifier for the node corresponding to the first element is the not same as any of the unique identifiers for the nodes corresponding to the sibling elements of the second element process proceeds to block and records that the first element being compared does not exist in the version containing the second element being compared. If it is determined at block that the unique identifier for the node corresponding to the first element is the same as the unique identifiers for a nodes corresponding to a sibling element of the second element process proceeds to block and performs the comparisons described above at blocks and between the first element and the matching sibling element of the second element. The information regarding the differences between the elements identified during the comparisons made at blocks is recorded in the generic memory model at block and process terminates.

Referring again to upon completing the comparison between first version and second version by accessing context object and context object in data store compare module is configured to update the context objects in the memory model with at least the following information about the differences between the two documents identified by applying the comparison rules 1 information about elements that have been deleted between versions 2 information about elements that are associated with different parent elements in different versions of the same XML document 3 information about elements that are associated with one parent element and exist in one XML document in one version and are associated with a different parent element and exist in a different XML document in the other version 4 information about elements that are associated with one parent element and exist in one XML document in one version and are associated with the same parent element and exist in a different XML document in the other version and 5 information about elements that have been renamed in the updated version. These five information sets represent the situations for which an element that is present in current version no longer exists or is structured differently in the new version . These situations can commonly result from code refactoring.

Referring again to the exemplary embodiment of merge solution tool framework depicted in merging resources is implemented to communicate with data store of element monitor to receive the recorded context information stored in the memory model corresponding to each element that is present in current version and does not have a complementary element in new version and to instantiate and store a customization mapping information XML element for each of these modified elements as this customization mapping information is generated to use when merging customizations from the first version into the new version. For each modified element the corresponding customization mapping information XML element is formatted to contain six fields 1 the file name for first version 2 the location of the modified element in first version 3 a merging solution key 4 the file name for second version 5 the location in second version at which customizations are to be merged and 6 any additional description or comments provided by the developers such as for example descriptions of any code refactoring rules applied between the two versions the particular reasons for performing the refactoring or particular instructions for merging customizations for the element. The values for both the location of the modified element in first version and the location in second version at which customizations are to be merged are provided in XPATH format.

The process for generating the merge solutions performed during the operation of merge solution tool framework of the present exemplary embodiment will now be described with reference to the flow chart illustrated in . The process indicated generally by reference number in is performed by merge solution tool framework for each customization mapping information XML element instantiated by merging resources . Prior to performing process on any of the mapping information elements instantiated by merging resources the only fields specified for each element are the file name for first version the location of the modified element in first version and any additional description or comments provided by the developers. For each mapping information element the merging solution key can be set to either DO NOT MERGE which indicates that the customizations made to this element in first version need not be reapplied in second version or MERGE TO NEW INSTANCE which indicates that customizations made to this element in first version should be merged to a new location in second version .

At block of process solution consumer reads the current mapping information element from merging resources. At decision block solution consumer analyzes the mapping information element to determine whether a customization merge solution is provided in the element. That is solution consumer determines whether the values for the mapping information element fields for the merging solution key the file name for second version and the location in the second version at which customizations are to be merged have been specified. If no customization merge solution is provided at block request producer generates a request for the application developers to provide the merge solution for the element by specifying values for the fields analyzed at decision block . The request can be provided for example through a user interface implemented within merge solution tool framework that is accessible by the developer through a computer system on which the tool framework is running and the request can indicate the already specified values for the file name for first version the location of the modified element in first version and any additional description or comments provided by the developers. Generally if the element corresponding to the mapping information element existed in first version but was deleted during development of second version or is otherwise not customizable in the second version the developer will set the merging solution key to DO NOT MERGE. Otherwise the merging solution key will generally be set by the developer to MERGE TO NEW INSTANCE. After receiving this developer input the process proceeds to block at which the merging solution information is stored by solution consumer in the corresponding mapping information element maintained merging resources and the process terminates.

If a customization merge solution is found by solution consumer at decision block the solution consumer then at decision block determines whether customizations to the element corresponding to the mapping information element need to be merged. That is solution consumer reads the value of the merging solution key. If the key is set to DO NOT MERGE at block solution producer generates customization merging solutions in mapping information format for each descendent element of the element corresponding to the current mapping information element by specifying the merging solution key for descendent element to DO NOT MERGE. Process then proceeds to block at which the generated solutions for each of the descendant elements are stored by solution consumer in the corresponding mapping information elements in merging resources . The process then terminates.

If at decision block the merging solution key for the current mapping information element is set to MERGE TO NEW INSTANCE at decision block validator accesses the element specified by the fields of the current mapping information element for the file name for second version and the location in the second version at which customizations are to be merged and performs validation on the result of the customization merging solution in second version according to the semantic provided for the XML documents of the software artifact. If the solution is validated at decision block the process proceeds to block at which the solution is stored by solution consumer in the corresponding mapping information element in merging resources . The process then proceeds to block at which solution producer generates customization merging solutions in mapping information format for each child element of the element corresponding to the current mapping information element and as indicated in exemplary process is recursively instantiated and performed beginning at decision block for each child element of the element corresponding to the current mapping information element. If the customization merging solution for the current mapping information element is not validated at decision block the process proceeds to block at which request producer generates a request for the application developers to provide the merge solution for the element as described above and the process terminates.

Referring again to the exemplary embodiment of merge solution tool framework illustrated in once the system has generated the merge solutions for each element that exists in current version and does not have a complementary element in new version the framework generates the interfaced versions of the merging solutions in merging interface . To do so solution consumer is implemented to access merging resources and wrap the merging solutions in an API that can be accessed by a migration tool for performing the upgrade from current version to new version to merge customizations made by the customer to elements in the current version that does not have a complementary element in the new version while the upgrade is performed. The API of merging interface can include a MergingInterface.getTargetElement object and a MergingInterface.getTargetFile object for accessing merging resources to obtain the file name for second version and the location in the second version at which customizations are to be merged when an element that has been customized by the customer in current version is identified by the migration tool.

Merging resources and merging interface can be delivered alongside the software tool that is configured to perform the migration from current version to new version and thereafter used by customers to merge their customizations made to the current version when migrating to the new version. In some exemplary embodiments merging resources and merging interface can be configured to be implemented within the corresponding migration tool for migrating from current version of the software artifact to new version . Merging resources and merging interface may be implemented as an aspect of a software package for the corresponding migration tool or as a software module or component implemented for incorporation with the corresponding migration tool as for example one or more libraries of functions one or more plug in or extension modules one or more dynamic link libraries etc.

As discussed above exemplary embodiments of the present invention can be implemented to generate a tool for automatically merging customizations made to software artifacts comprising code in structured documents of any type not just XML language documents. In the present exemplary embodiment only deserializer is implemented under the assumption that it is working with documents having an XML construct while each of the other actor and handler modules described are working with context objects of the generic hierarchical memory model. Thus in alternative exemplary embodiments merge solution tool framework can be extended to handle non XML languages for example in either of the following two ways 1 replacing deserializer with a handler that understands non XML languages or 2 implementing a preprocessor to convert a non XML language to an XML format. Furthermore in exemplary embodiments the documents of the software artifact versions and the memory model representations of the versions may each observe different syntax rules and the nodes of the memory model representations can be generated utilizing a mechanism that is appropriate to the particular type of documents and elements being compared. For example the documents of the software artifact versions may have an HTML language construct while the memory model representations may have an XML language construct.

In the preceding description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the described exemplary embodiments. Nevertheless one skilled in the art will appreciate that many other embodiments may be practiced without these specific details and structural logical and electrical changes may be made.

Some portions of the exemplary embodiments described above are presented in terms of algorithms and symbolic representations of operations on data bits within a processor based system. The operations are those requiring physical manipulations of physical quantities. These quantities may take the form of electrical magnetic optical or other physical signals capable of being stored transferred combined compared and otherwise manipulated and are referred to principally for reasons of common usage as bits values elements symbols characters terms numbers or the like. Nevertheless it should be noted that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the description terms such as executing or processing or computing or calculating or determining or the like may refer to the action and processes of a processor based system or similar electronic computing device that manipulates and transforms data represented as physical quantities within the processor based system s storage into other data similarly represented or other such information storage transmission or display devices.

Exemplary embodiments of the present invention can be realized in hardware software or a combination of hardware and software. Exemplary embodiments can be implemented using one or more program modules and data storage units. Exemplary embodiments can be realized in a centralized fashion in one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that when being loaded and executed controls the computer system such that it carries out the methods described herein.

Exemplary embodiments of the present invention can also be embedded in a computer program product which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computer system is able to carry out these methods. Computer program means or computer program as used in the present invention indicates any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation and b reproduction in a different material form.

A computer system in which exemplary embodiments can be implemented may include inter alia one or more computers and at least a computer program product on a computer readable medium allowing a computer system to read data instructions messages or message packets and other computer readable information from the computer readable medium. The computer readable medium may include non volatile memory such as ROM Flash memory Disk drive memory CD ROM and other permanent storage. Additionally a computer readable medium may include for example volatile storage such as RAM buffers cache memory and network circuits. Furthermore the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and or a network interface including a wired network or a wireless network that allow a computer system to read such computer readable information.

Exemplary computer system can include a display interface that forwards graphics text and other data from the communication infrastructure or from a frame buffer not shown for display on a display unit . Computer system also includes a main memory which can be random access memory RAM and may also include a secondary memory . Secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. Removable storage drive reads from and or writes to a removable storage unit in a manner well known to those having ordinary skill in the art. Removable storage unit represents for example a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In exemplary embodiments secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into the computer system. Such means may include for example a removable storage unit and an interface . Examples of such may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between the computer system and external devices. Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be for example electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path that is channel . Channel carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link and or other communications channels.

In this document the terms computer program medium computer usable medium and computer readable medium are used to generally refer to media such as main memory and secondary memory removable storage drive a hard disk installed in hard disk drive and signals. These computer program products are means for providing software to the computer system. The computer readable medium allows the computer system to read data instructions messages or message packets and other computer readable information from the computer readable medium. The computer readable medium for example may include non volatile memory such as Floppy ROM Flash memory Disk drive memory CD ROM and other permanent storage. It can be used for example to transport information such as data and computer instructions between computer systems. Furthermore the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and or a network interface including a wired network or a wireless network that allow a computer to read such computer readable information.

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed can enable the computer system to perform the features of exemplary embodiments of the present invention as discussed herein. In particular the computer programs when executed enable processor to perform the features of computer system . Accordingly such computer programs represent controllers of the computer system.

Although exemplary embodiments of the present invention have been described in detail the present description is not intended to be exhaustive or limiting of the invention to the described embodiments. It should be understood that various changes substitutions and alterations could be made thereto without departing from spirit and scope of the inventions as defined by the appended claims. Variations described for exemplary embodiments of the present invention can be realized in any combination desirable for each particular application. Thus particular limitations and or embodiment enhancements described herein which may have particular advantages to a particular application need not be used for all applications. Also not all limitations need be implemented in methods systems and or apparatuses including one or more concepts described with relation to exemplary embodiments of the present invention.

The exemplary embodiments presented herein were chosen and described to best explain the principles of the present invention and the practical application and to enable others of ordinary skill in the art to understand the invention. It will be understood that those skilled in the art both now and in the future may make various modifications to the exemplary embodiments described herein without departing from the spirit and the scope of the present invention as set forth in the following claims. These following claims should be construed to maintain the proper protection for the present invention.

