---

title: Method and system for providing a data exchange service provider interface
abstract: A computer program product comprises a computer useable medium. The computer useable medium has a computer readable program such that when the computer readable medium is executed on a computer, the computer is caused to provide a data interface between an adapter component and one or more application interface components for a runtime application. Further, the computer is caused to establish a cursor that iterates over a plurality of data objects within a data set of the runtime application. In addition, the computer is caused to establish an accessor that provides access to a data element of the data object. The computer is also caused to provide the cursor and the accessor to the adapter component so that the adapter component accesses data through the one or more application interface components of the runtime application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08620856&OS=08620856&RS=08620856
owner: International Business Machines Corporation
number: 08620856
owner_city: Armonk
owner_country: US
publication_date: 20080118
---
This disclosure generally relates to software integration. More particularly the disclosure relates to connectivity to Enterprise systems.

A variety of middleware products are currently utilized to support business software applications. Examples of such middleware products include transaction processing systems message processing systems and Extract Transform Load ETL systems. The various middleware systems have different performance profiles and requirements. Some middleware systems deal with relatively small amounts of data but need to process requests very quickly. Other middleware systems deal with very large amounts of data and need to access this data in pieces of manageable size.

As a result a business software environment may include a large number of runtimes which are engine servers or software applications performing a function that need to access data from external resources. In many cases adapters have been developed for these products to access an external Enterprise Information System EIS such as a database transaction processing system etc. As a result a multitude of adapters have been built using various technologies to provide access to the same resources. This overlap provides tremendous expense e.g. development costs and maintenance costs for the software developer. Further end users are exposed to inconsistencies in the tools and capabilities of the connectivity solutions provided by different products.

Current approaches do not allow for standard connectivity to Enterprise systems from different runtime environments because the current standards are defined for specific environments e.g. Java Platform Enterprise Edition Java EE . Accordingly these current approaches do not permit the reuse of adapters between different runtime environments e.g. Application Server Information Management or System Management.

Attempts have been made to share adapters between products. However these attempts have failed for a multitude of reasons. One reason is that the interfaces are often incompatible with one another. Further additional infrastructure that is foreign to the software environment often needs to be utilized. In addition data and or format conversions which can be costly with respect to central processing unit CPU performance may need to be utilized.

In one aspect of the disclosure a computer program product comprises a computer useable medium. The computer useable medium has a computer readable program such that when the computer readable medium is executed on a computer the computer is caused to provide a data interface between an adapter component and one or more application interface components for a runtime application. Further the computer is caused to establish a cursor that iterates over a plurality of data objects within a data set of the runtime application. In addition the computer is caused to establish an accessor that provides access to a data element of the data object. The computer is also caused to provide the cursor and the accessor to the adapter component so that the adapter component accesses data through the one or more application interface components of the runtime application.

In yet another aspect of the disclosure a process is provided. The process provides a data interface between an adapter component and one or more application interface components for a runtime application. Further the process establishes a cursor that iterates over a plurality of data objects within a data set of the runtime application. In addition the process establishes an accessor that provides access to a data element of the data object. Finally the process provides the cursor and the accessor to the adapter component so that the adapter component accesses data through the one or more application interface components of the runtime application.

In another aspect of the disclosure a system is provided. The system includes a data interface between an adapter component and one or more application interface components for a runtime application. Further the system includes a cursor creation module that establishes a cursor that iterates over a plurality of data objects within a data set of the runtime application. In addition the system includes an accessor creation module that establishes an accessor that provides access to a data element of the data object. The system also includes a transmission module that provides the cursor and the accessor to the adapter component so that the adapter component accesses data through the one or more application interface components of the runtime application.

A DESPI may be utilized to define the boundaries between an Application Component and Connector Component. The DESPI is utilized for efficient transfer of data between an Application Component and a Connector Component. Accordingly the DESPI minimizes the need to copy or canonicalize data or to create intermediate objects solely for containing data elements.

The architecture component model may split an adapter into multiple adapter components . Accordingly the adapter components are not monolithic and do not impose non native metadata data and calling formats on the runtimes. As a result the adapter component may be utilized with multiple runtimes.

The adapter component encapsulates basic connectivity to the EIS and the exchange of the data with the EIS. The adapter component can be driven by the metadata describing interactions with the EIS. In one embodiment the adapter component includes separate subcomponents for connecting to the EIS and for exchanging data. The first subcomponent is a connectivity subcomponent and the second subcomponent is a data exchange subcomponent . In one embodiment a single adapter component may be utilized with multiple Application Interface Components .

The connectivity subcomponent includes functionality for establishing maintaining and closing connections to the target EIS. Further the connectivity subcomponent provides support for transactions and security for these connections. The connectivity subcomponent interacts with the specific libraries and functionality of the target EIS. The connectivity subcomponent is exposed to the application interface component through standard J2EE Connector Architecture 1.5 JCA common client interfaces CCI including Connection ConnectionFactory Interaction and InteractionSpec for outbound and ResourceAdapter and ActivationSpec for the inbound.

The data exchange subcomponent includes functionality for passing or receiving data from the application component through the data exchange interface. This interface is format neutral and runtime neutral. Accordingly the interface permits any kind of structured or streamed data to be moved between these components. The adapter understands the data format of the EIS and is able to convert it to invocations of Data Exchange interface.

The adapter component is developed by the adapter provider who has knowledge of the target EIS its interfaces and its behavior. The adapter provider can be the EIS vendor a dedicated connector vendor or an in house developer providing access to the required EIS.

The Application component is a bridge between the runtime environment e.g. a Middleware Application and the adapter component . The Application component enables invocation of the adapter from the clients by using the appropriate programming model. Further the Application component is responsible for mapping between the runtime s programming model and data format to the invocation of the adapter component through the JCA CCI.

The DESPI provides the ability to support multiple data formats. DESPI allows data of arbitrary complexity to be exchanged bi directionally between the runtime and the adapter component without a need to create intermediate objects such as Service Data Objects SDO or Extensible Markup Language XML .

The data exchange subcomponent is an implementation of data exchange interfaces in the Application component . Accordingly the data exchange subcomponent converts the invocations of the data exchange interfaces to runtime specific data representations. Further the application interface is the interface that matches the runtime programming model and maps runtime specific invocations to the invocation of the adapter through CCI. In addition the metadata describes the structure of the data exchange with the EIS through the DESPI. In other words the metadata includes information about the included types and the structure of the data. The metadata can also provide information to the adapter component about how the data can be exchanged with the EIS.

As the data interface between the adapter component and one or more Application Interface Components the DESPI is configured to optimize performance. First the DESPI is configured to access the data of the runtime environment directly without the need to create intermediate canonical objects. Second the DESPI is configured to permit data to be dynamically accessed in the external resource without requiring the whole data set to be held in memory. Third the DESPI supports streaming of data that can be read piecemeal or otherwise partitioned. As a result the DESPI provides support both inbound and outbound directions provides metadata such that both data binding and the adapter component have a shared understanding of the structure of the data provides support for both structured records and data streams minimizes conversion copying and canonicalization and supports arbitrarily complex data structures.

In one embodiment the DESPI utilizes one or more cursors that iterate over a plurality of data objects within the data set of the runtime and one or more accessors that provide access to the individual data elements e.g. fields within an object. An example of the plurality of data objects is a series of similar data objects. Both cursor and accessors are implemented by the application component and are used by the adapter component to get and set the data objects and fields. From the viewpoint of the application component the interface is simple and ensures that the development effort for an adapter developer is minimized.

As an example the application component implements the DataExchangeFactory interface which follows the standard factory pattern. The application component provides the adapter component with the entry points for creating cursors and accessors to the data either for reading or writing. A cursor references a complex object or a series of complex objects. An accessor references a field within the complex object or an array of such fields.

These cursors and accessors point to the native data of the runtime. If the runtime utilizes SDO DataObjects then the cursors will reference DataObjects and the Accessors will reference properties of these objects. If the runtime utilizes XML then the cursors and accessors may reference elements and attributes within a Document Object Model DOM representation. The adapter component does not need to be aware of the underlying data structure as the implementation of the cursor and the accessor hide the details from the adapter component . For example a single SAP Business Application Programming Interface BAPI connector component could be equally used with an SDO XML or any other DataExchangeFactory. Further a single implementation of the DESPI classes for a particular runtime supports the use of any connector component. A single adapter component may be utilized to access a specific resource. In addition a single DESPI implementation for a specific data format may be utilized. Therefore N data formats and M adapter components allows for the development of N M components which results in N M connectivity options.

A metadata format common between the adapter component and the application component is supported to allow the structure of the data exchanged through the DESPI interface to be defined. For example the externalized metadata definition format may be based on Service Data Objects SDO specification version 2.1 and represented by the SDO Type.

In one embodiment the metadata produced by the adapter component is in the form of annotated Extensible Markup Language XML schemas. The annotations contain application specific information which the adapter utilizes at runtime to associate objects or individual properties with the equivalent in the external resource. This application specific information or appinfo can be used to identify key fields mappings to external types or for any other purpose that the adapter dictates. The appinfo should be treated as an opaque string by all components other than the adapter . At runtime definitions convey the metadata to the adapter . These definitions are typically constructed from the imported XML schemas. Some environments may prefer to programmatically construct the metadata from their own metadata representation which would have been created from the original XML schemas. Any appinfo annotations in the schemas should be preserved by such environments and then provided along with the type definition for consumption by the adapter .

The architecture component model allows a plurality of input sources available through adapters to interact with multiple runtimes by reducing the number of distinct interfaces from M N to 1 N and or M 1. Further the data exchange set of interfaces eliminates the need for an intermediate object as seen for example in SDO when an intermediate SDO object needs to be built and converted to a native object if SDO is utilized to move data between an adapter and a middleware system that does not operate natively with SDO objects. In addition the lack of a defined format for the data to be exchanged between an adapter and its client as seen with JCA is alleviated by the data exchange set of interfaces. Accordingly middleware systems can much more easily adopt JCA by utilizing the data exchange set of interfaces. The architecture component model is intended to support as many runtime and design environments as possible. The adapters developed from the architecture component model are accessible by all runtimes. The choice of implementation language for adapters is determined by the client Application Programming Interface API that the adapter component utilizes to communicate with the external resource.

Each implementation of DESPI can readjust the cursor and accessors by whatever means is the most efficient for that specific implementation. As long as the accessor is pointing to the correct place in the bound data when the connector attempts to get and set the data the integrity of the data will be maintained.

The accessor interface provides a one way exchange of data. There is no data store behind the Accessor that permits navigation to read the data once it has been set. With DESPI there is no object that can be passed around between components. The data is maintained by and accessible to only the endpoints of the data exchange.

The DataExchangeFactory interface is the interface that provides the factory methods for the creation of cursors and accessors to deal with the data in some format that this particular implementation of DataExchangeFactory understands. The DataExchangeFactory interface is implemented by the data handling layer of the application component and provides the mapping between the runtime format of data and the connector record view of this data through the Cursor and Accessor interfaces.

With respect to the Cursor interface the cursor instances are created based on the metadata describing the structure of the data and are capable of advancing through the data when they point to objects with a cardinality greater than one. When the data is read the cursor advances to the next element of the list. When the data is written a function in the DESPI configuration the Cursor interface creates storage for the next element. The Cursor interface also maintains the parent and child relationship with other cursors and keeps the list of the Accessors that have been created to access fields of the complex object.

Further the InputCursor interface extends the Cursor interface to add functions that are specific to reading input records. A top level InputCursor will be created to process an input record. Any child cursors of this cursor will also be instances of InputCursor.

In addition the OutputCursor interface extends the Cursor interface to add functions that are specific for writing output records. A top level OutputCursor will be created to process an output record. Any child cursors of this cursor will also be instances of OutputCursor.

The Accessor interface provides a mechanism to access individual fields of objects within a data set. Accessors may either be named or anonymous. A named accessor is created when a function for creating an InputAccessor or an OutputAccessor is called with a non null name parameter. A named Accessor references a specific field of an object for its lifetime i.e. it cannot be made to reference a different field. When such an accessor is created a function may establish the context so that when the parent cursor is advanced the accessor is efficiently updated to reference the same field in the subsequent object. Named accessors are utilized whenever the determination of which fields to access can be determined at initialization time and whenever multiple records will be processed which contain the field referenced by the accessor.

An anonymous accessor is created when a function for creating an InputAccessor or an OutputAccessor is called with null for the name parameter. An anonymous Accessor is not associated with a particular field in an object but can instead be dynamically associated with any field of the object. An adapter component as shown in may wish to use this approach if an object contains a large number of fields and for performance reasons the adapter component does not wish to create accessors for all of these objects. It may be more efficient for an adapter component to create a single accessor and assign it to each field it wishes to access.

Further the InputAccessor interface extends the Accessor interface to add methods that are specific for accessing data within input records. The InputAccessor interface contains a large number of functions that provide typed access to data.

In addition the OutputAccesor interface extends the Accessor interface to add functions that are specific for setting fields within output records. The OutputAccesor interface contains a large number of methods that provide typed access to data.

An OutputStreamRecord may be utilized as the output record from the adapter. It will contain an OutputStream to which the client can write. When an execute function is called the adapter will create an OutputStream attach it to the external resource and return this stream as part of the output record. After this occurs the client may write to the stream.

An InputStreamRecord may be used as the input record the output record or both. When used as the input record the file adapter will read from the InputStream and write to its external resource. For example if the client wants to write the byte stream Hello World to the external resource the client will create an InputStream populated with this data and pass it into the adapter as part of the input record.

When used as output the adapter will connect the InputStream of the output record to a stream in its external resource allowing the client to read from it. For example if the client wished to retrieve the contents of a file from a file system the file adapter would pass a FileInputStream as part of the outputRecord to the client . The file adapter may alternatively be a resource adapter that obtains resources for sources other than a file system.

The InputStreamRecord is also useful when publishing streams as inbound events. Utilizing the InputStreamRecord in this manner is very similar to using it as the output record. The listener i.e. downstream application will simply read from the inputStream when it receives the event.

The processor is coupled either directly or indirectly to the memory through a system bus. The memory can include local memory employed during actual execution of the program code bulk storage and or cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

The input output devices can be coupled directly to the system or through intervening input output controllers. Further the input output devices can include a keyboard a keypad a mouse a microphone for capturing speech commands a pointing device and other user input devices that will be recognized by one of ordinary skill in the art. Further the input output devices can include a receiver transmitter speaker display image capture sensor biometric sensor etc. In addition the input output devices can include storage devices such as a tape drive floppy drive hard disk drive compact disk CD drive etc.

Network adapters may also be coupled to the system to enable the system to become coupled to other systems remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

It should be understood that the method and system described herein can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. If software is utilized to implement the method or system the software can include but is not limited to firmware resident software microcode etc.

Further the method and or system can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purpose of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a RAM a ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include CD read only memory CD ROM CD read write CD R W and DVD.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

 IBM WebSphere WebSphere Business Monitor WebSphere Integration Developer and WebSphere Process Server are registered trademarks of International Business Machines Corporation in the United States other countries or both.

