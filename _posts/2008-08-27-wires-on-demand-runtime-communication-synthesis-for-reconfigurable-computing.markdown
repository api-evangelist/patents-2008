---

title: Wires on demand: run-time communication synthesis for reconfigurable computing
abstract: A method, and system, for reconfiguring an FPGA which has a static region and a dynamic region is provided. The method includes the steps of: (a) providing a dynamic module library having information of predetermined modules; (b) receiving a reconfiguration request external to the FPGA; (c) computing reconfiguration of the FPGA at a predetermined location using predetermined module information from the dynamic module library and the reconfiguration request, and generating reconfigurable partial bitstreams; and (d) sending partial bitstreams from the predetermined location to the FPGA to perform the reconfiguration.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07902866&OS=07902866&RS=07902866
owner: Virginia Tech Intellectual Properties, Inc.
number: 07902866
owner_city: Blacksburg
owner_country: US
publication_date: 20080827
---
The present application claims the benefit of U.S. Provisional Application No. 60 968 091 filed Aug. 27 2007 whose disclosure is hereby incorporated by reference in its entirety into the present application.

The present application is also related to U.S. Provisional Application No. 61 084 429 filed Jul. 29 2008.

The work leading up to the present invention was supported by United States Air Force Contract No. FA8651 06 C 0126. The government has certain rights in the invention.

The present invention is directed to field programmable gate arrays FPGAs and more particularly to a method and system for configuration and reconfiguration of FPGAs during run time operations.

FPGAs are first introduced by Xilinx Inc. in 1985. FPGAs are semiconductor devices that can be programmed and reprogrammed to perform logic functions. Each FPGA contains hundreds or thousands of duplicated logic gates and programmable interconnects. A user or designer may compile a logic function using software provided by the FPGA vendors. The compiling of the logic function creates binary bitstreams that can be downloaded into the FPGA to instruct the FPGA s programmable interconnect to connect the logic gates to perform the designed logic function.

The FPGA allows the flexibility of reusing the logic gates for different logic functions by recompiling and reconfiguring the FPGA. However the configuration memory of an FPGA is volatile and must be configured every time the power is up. When the power is down or off the FPGA loses its functionality. Moreover recompiling and reconfiguration of an FPGA is time and energy consuming.

Conventionally whenever an FPGA is reconfigured or configured multiple full bitstreams from a designer s computer are compiled and downloaded to the FPGA. A disadvantage is that the full bitstreams cannot be downloaded on the fly and the operation of an FPGA may have to stop prior to receiving new full bitstreams. One solution is partial reconfiguration where parts of the FPGA are constant and continuously running while other parts are reprogrammed and reconfigured.

Contemporary computer engineering tries to develop systems that create a balance between price performance power adaptability and the time and cost effort required to use the technology. An axiom of reconfigurable computing research is that adding run time adaptability to hardware can improve the three P s price by multiplexing the use of a smaller FPGA performance and power efficiency. Even if such objectives are achieved the significant increase in design effort works against the main attraction of FPGA technology. Reconfigurable application development remains daunting largely because inter module communication requires low level physical design and is the responsibility of the designer. Given the effort required to develop non trivial run time reconfigurable RTR applications the price performance efficiency return on investment needs to be substantial. The current approach to partial reconfiguration leads to an intermodule communication structure that remains fixed and often consists of one or more buses. However the pervasive lesson in high performance architecture is the importance of efficient communication. Because FPGAs are mostly uncommitted wires custom point to point communication between dynamically instantiated modules is desired in order to maximize communication efficiency.

RTR application design would be much easier if module communication circuitry was automatically synthesized. A relatively new research area communication synthesis is an essential part of system on chip design productivity. Commercial communication synthesis tools exist for application specific integrated circuit ASIC design such as Sonics SMART. Designers need only provide a library of modules and memories which often pre exist as cores and all connections and physical constraints are automatically generated. This degree of abstraction is sorely missing for RTR application development. As with software and static hardware design reconfigurable applications should be insulated from rapidly evolving FPGA architectures.

Xilinx s efforts to promote RTR formed distinct phases that have some important lessons. Xilinx s reconfiguration friendly XC6200 architecture was the focus of the first phase. Its commercial failure resulted from among other things poor support for reconfiguration in the associated tools and a lack of architectural features such as fast arithmetic that designers were accustomed to. The second phase sensibly focused on reconfiguration tools for mainstream FPGA architectures and resulted in the JBits Integrated Development Environment. Run time parameterized designs could be implemented without using the standard Xilinx tools by having a Java program configure all logic and connections in a structural manner. However most designers were not willing to forgo the Register Transfer Level RTL design abstraction with familiar Hardware Description Language HDL and timing driven implementation tools.

Phase three has been in effect since 2002 and provides rudimentary support for partial reconfiguration in Xilinx s mainstream implementation tools by adding constraints and special bus macros to the modular design flow. In addition to the manual effort required to insert and place the bus macros a number of limitations arise due to the lack of a run time environment. A set of reconfigurable regions may be allocated in a design however they may not be stacked vertically because different configuration frames would be required for each combination of modules. Each region must be the size of the largest module that will occupy it. Inter module routing resources are also fixed at design time. The constraints of this static approach result in the same inflexibility or resource waste as static array allocation in programs. As with software the solution is dynamic allocation of reusable resources from a large pool.

It is therefore an object of the present invention to provide a module based RTR of FPGAs. Another object is to provide a flexible allocation of logic and wires from a dynamic pool and run time adaptable point to point communication. It is also an object of the present invention to leverage existing design methodologies and tools and focus on streaming applications.

According to an aspect of the invention another method for reconfiguring an FPGA which has a static region and a dynamic region is provided. The method includes the steps of a receiving an FPGA reconfiguration request at a server located externally of the FPGA b computing reconfiguration of the FPGA at the server using the request and information of predetermined modules and c sending partial bitstreams from the server to the FPGA to reconfigure the FPGA.

According to another aspect of the invention yet another method for reconfiguring an FPGA which has a static region and a dynamic region is provided. The method includes the steps of a providing a dynamic module library having information of predetermined modules b receiving a reconfiguration request external to the FPGA c computing a reconfiguration of the FPGA at a predetermined location using predetermined module information from the dynamic module library and the reconfiguration request and generating reconfigurable partial bitstreams and d sending partial bitstreams from the predetermined location to the FPGA to perform the reconfiguration.

According to yet another aspect of the invention a dynamic module system for reconfiguring an FPGA which has a static region and a dynamic region is provided. The system includes a an interface for receiving a reconfiguration request b a datapath manager for receiving the reconfiguration request and information of predetermined modules wherein the datapath manager computes placement of modules inside the dynamic region of the FPGA and their interconnections c a channel routing manager connected to the datapath manager for determining connections between the dynamic region and the static region and d a bitstream toolbox connected to the datapath manager and the channel routing manager and generating reconfigurable partial bitstream to the FPGA via the interface.

Preferred embodiments of the invention will be set forth in detail with reference to the drawings in which like reference numerals refer to like elements or steps throughout.

The present invention divides the reconfiguration of an FPGA into two main steps 1 creating a dynamic module library during compile time operations preprocessing dynamically instantiated IP and 2 computing the reconfiguration external to the FPGA during run time operations placing modules and completing connections . After the reconfiguration is computed the system sends partial bitstreams that represent the reconfiguration function to the FPGA. The FPGA contains a basic static region and a dynamic region. The dynamic region is also called a sandbox where as explained below logic modules are reconfigured placed and interconnected during run time operations.

The dynamic module library may be created during compile time. The library is composed of preprocessed IP blocks stored in the form of partial bitstreams. Before compilation blocks are encased in wrapper structures whose main function is to provide routing anchor points for block ports.

An exemplary wrapper structure is shown in . Referring to the wrapper structure includes two input ports two output ports a preprocessed module with input ports and and output ports and a post processed module and four multiplexers each having four input ports and one output port. The solid lines are direct connections. The dashed lines are dynamic pass through connections. The dotted lines are dynamic input or output connections from opposite sides.

The first multiplexer has an input directly connected to the input of the wrapper and an output directly connected to the input of the preprocessed module . Another input of the first multiplexer is dynamically connected to the input of the wrapper . The second multiplexer has an input directly connected to the input of the wrapper and an output directly connected to the input of the preprocessed module . The second multiplexer also has an input dynamically connected to the first input of the wrapper .

The third multiplexer has an input directly connected to the output of the preprocessed module and an output directly connected to the output of the wrapper . The third multiplexer also has an input dynamically connected to the input of the wrapper as a pass through connection so that a signal at the input of the wrapper can be sent to the output without passing through the preprocessed module . The multiplexer also has an input dynamically connected to the output of the preprocessed module .

The fourth multiplexer has an input directly connected to the output of the preprocessed module and an output directly connected to the output of the wrapper . The fourth multiplexer also has an input dynamically connected to the output of the preprocessed module . The multiplexer has another input dynamically connected to the input of the wrapper as a pass through connection so that a signal at the input can be sent to the output without passing through the preprocessed module .

With the multiplexers and the direct and dynamic connections shown in the wrapper has the flexibility to utilize the preprocessed module in various ways as demanded by a reconfiguration request. More specifically the multiplexers allow run time selection among same side and opposite side connections to the ports of the preprocessed module and pass through connections for signals unrelated to the preprocessed module .

A module interface template describes the wrapper structure required by a particular IP block. Information in the template includes the port names and ordering preferred block dimensions dataflow direction and routing options such as the number of pass through connections . IP block preprocessing takes as its input the module s port declarations and interface template and produces HDL and constraints for a wrapped module. The mainstream tools are then invoked to generate one or more bitstreams for the module. Defining similar interface templates for a set of modules promotes port alignment when the modules are connected.

Regarding the module placement and channel allocation during the reconfigurable computation to reduce the time and memory requirements of the run time placement process placement occurs at the module level rather than at the gate level. This reduces the size of the problem from placing many thousands of cells to placing tens of blocks. Previous work often takes a naive view of the architecture by treating module placement purely as a packing problem and ignoring inter module routing or by considering only the architecture s logic element grid ignoring features such as block random access memory BRAM .

The goal of datapath placement is to promote neighbor connections and reduce routing delays between blocks by minimizing the lengths of the connecting wires. Modules are first topologically sorted based on their connections. The precise placement of modules depends on the extra resources required such as multipliers and BRAM. Datapaths are primarily horizontal or vertical with folds as necessary. Routing channels are allocated wherever modules do not connect strictly through abutment. Within the channel delay estimation is performed based on wire lengths. shows an example of module placement and channel routing allocation in an FPGA.

Referring to a configuration of an FPGA is disclosed. In the FPGA includes a processor a static logic region and a sandbox . The sandbox includes a plurality of dynamic modules sandbox connections a dynamic routing channel and routing registers . The processor is connected to the sandbox connections to configure the connections of the modules inside the sandbox . Inside the sandbox the dynamic routing channels connect signals received at the sandbox connections to various modules . The size of the sandbox is preferably chosen by a designer. The sandbox allows a reconfiguration server to place various kinds and sizes of modules inside the sandbox . The modules inside the sandbox can be interconnected in any manner using the dynamic routing channels .

The purposes of placing or positioning the dynamic modules in the sandbox are to satisfy special column alignments for BRAM and digital signal processing DSP promote neighboring modules connections within datapaths and to avoid free space fragmentation as modules are removed or replaced. The purposes for channel routing are to route between synchronous anchor points along module port edges and to achieve route delays of less than one clock period.

Regarding channel routing allocation because contemporary FPGAs have a large amount of routing resources available general routing is basically a graph search problem. By contrast the inter module routing requirements in the present invention are limited to the channels reserved between the input output ports of adjacent modules. This approach permits routing with constructive algorithms based on templates that specify the sequence of wire segments to use.

Returning to the issue of channel allocation in an FPGA the channel routing procedure utilizes an abstract architecture that represents a subset of the wires and connections present in a configurable logic block CLB . By deriving the subset from resources common to two or more FPGA families the abstract architecture allows channel routing to be treated in an architecture independent manner. The wires consist of unidirectional segments which span three CLBs and travel north south east or west. Each CLB contains the start midpoint and end for ten segments in each direction. Connectivity in the abstract switch matrix is rich enough to support complex channels. After all signals have been routed in terms of the abstract architecture routes are mapped to the corresponding resources in the actual architecture.

In addition to the local wires used for channel routing the use of long lines for run time connections is also considered. In the Xilinx Virtex II Pro architecture long lines span the entire chip width or height as continuous segments while in the Virtex 4 and 5 families they span 25 and 19 CLBs respectively. Long lines are attractive in that they are not essential resources for routing within modules. Unfortunately they suffer from sparse connectivity among CLBs lean connectivity to other wires within a CLB and low density.

The low density of long lines may be prohibitive for modules having wide data ports. Long lines may be more useful for control signals related to run time housekeeping. Such communication might include a signal from a controller instructing a module to suspend or complete the current operation and prepare to be relocated or removed.

The following presents an example that demonstrates the feasibility of flexible module placement and communication over dynamic routes. The choice of an MPEG 1 Layer 3 MP3 audio decoder as the application was motivated by the algorithm s reliance on streaming data transfer between signal processing stages. As shown in the decoder is a system on chip with a 36 point inverse modified discrete cosine transform IMDCT core. The module is faster than the software IMDCT function by a factor of 2.54 including communication overhead and speeds up the overall decoding process by a factor of 1.13.

In the MP3 decoder includes an interface region and the FPGA region. The interface region includes the host PC interface logic two general purpose input output GPIO units a timer an external memory controller and a 2 MB static random access memory SRAM . The FPGA region includes a MicroBlaze IMDCT result first in first out FIFO unit and a sandbox which is equivalent to the sandbox in .

The host PC interface logic receives the MP3 stream and sends the PCM stream. The host PC interface logic is connected to the GPIO units . The external memory controller is connected to the 2 MB SRAM . The MicroBlaze is connected to the GPIO units the timer and the external memory controller via the on chip peripheral bus OPB . The MicroBlaze has a fixed point software decoder and FSL input output ports. An output port of the MicroBlaze is connected to input anchor point port of the sandbox . The sandbox has an output anchor point port connected to the IMDCT Result FIFO which sends signals to an input port of the MicroBlaze . The sandbox includes dynamic routes anchor point ports and a dynamic IMDCT module . The IMDCT module includes a module interface logic and an IMDCT core . The module interface logic is connected to the dynamic routes of the sandbox via the input output anchor point ports .

In operation the host PC interface logic sends an MP3 partial bitstream to the MicroBlaze via the GPIO . The MicroBlaze then sends the MP3 partial bitstream to the sandbox to configure the modules and their connections inside the sandbox .

The IMDCT module utilizes two BRAMs and one 18 18 multiplier cell. Four distinct vertical alignments of these cells can occur within the module depending on its placement. To address alignment the module is implemented and stored for all four possibilities at build time. When generating a partial bitfile for a particular vertical position the run time tools draw from the appropriate implementation. Note that due to the six CLB relocation restriction only two distinct cell alignments occur in this design.

Dynamic route timing is managed with a simple conservative approach. In each dynamic net is bookended by registers on both end points. By establishing at design time that the worst case dynamic route delay is less than one clock period no timing consideration is required at run time. The mainstream tools implement and verify timing for routes outside the bookend registers.

A data push protocol accommodates the two cycle latency introduced by the bookend registers without the loss of throughput. The hardware and software interfaces guarantee that the receiver can always accommodate the number of data items to be transferred. This guarantee eliminates the need for handshaking signals from the receiver allowing either sender to push one 32 bit sample per clock cycle.

Anchor points are the bridge between static and dynamic routes. Hard macros instanced by a build time flow include physical module pins. Dynamic nets are bookended by registers within the anchor points. This allows a synchronous boundary between static and run time timing verification. In addition mainstream tools can verify timing for static routes at build time. The run time framework manages timing between bookend registers in which dynamic routes need only attain a delay less than one clock period and conservative delay estimates for the router s wire segments. Typically there is no timing pressure for the router thus allowing ample slack. For long haul routes the router may instance additional registers. For maintaining the communication performance protocols that accommodate bookend latency are used for module interface logic. Protocols and interfaces are designed for streaming transfers with no throughput compromise.

The dynamic module library storage includes logic gate Modules A through Z. Each module is preprocessed and contains a partial bitstream physical annotation and catalog data of the module. Physical annotation is an Extensible Markup Language XML file created by the preprocessor for each module. The XML file describes the dimensions of the module location of the ports on the module s wrapper and any special resource or alignment requirements for the module.

The dynamic module server includes a reconfigurable communication interface a reconfigurable supervisor a library manager a bitstream toolbox a placer and a router .

The application platform includes the FPGA an application base full bitstream a SelectMap ICAP an application controller and a reconfigurable communication interface . The interface of the application platform sends signals to and receives signals from the interface of the server . The application controller may be located within the FPGA or external to the FPGA . further includes an Application Base Full Bitfile with physical annotation and Application Datapath Definitions connected to the dynamic module server . The Application Datapath Definitions defines the sandbox dimensions resources available such as memory and DSP blocks and input output port locations.

The main function of the dynamic module server is three fold datapath management channel routing and bitstream interfacing. With datapath management the server takes a reconfiguration request from a designer selects the dynamic modules available in the module library to carry out the request and determines placement of the selected modules in the sandbox inside the FPGA . The server then performs the channel routing i.e. determining how the selected modules are interconnected and how they are connected to the devices in the static region and the input output ports of the FPGA . The server subsequently sends bitstreams that represent the reconfiguration task to the application platform via the interfaces and in order to execute the reconfiguration of the FPGA . The operation of the server occurs during the run time of the FPGA .

In operation initially the application platform receives a request for reconfiguration of the FPGA from a designer. The device making the request could be a processor external to the FPGA or an embedded processor within the FPGA . Upon receiving the reconfiguration request the application platform sends the request to the dynamic module server via the reconfigurable communication interfaces and .

In the dynamic module server the reconfiguration supervisor receives the reconfiguration request via the interface a list of available datapaths for the application of the request from the Application Datapath Definitions and a list of available dynamic modules A Z from the module library storage . After analyzing the request and utilizing the information about the available modules and datapaths the reconfiguration supervisor selects the modules and datapaths and sends a module request to the placer . Upon receiving the module request the placer retrieves selected modules from the module library storage and physical annotation of the selected modules. The placer determines how the selected modules are placed in the sandbox in the FPGA and sends information regarding the module placement module and variant identifications to the bitstream toolbox .

The router receives the module connections and pin locations from the placer and sends modifications of programmable interconnect points PIP and lookup tables LUT to the bitstream toolbox . The bitstream toolbox gathers the data from the placer and router module information from the library storage and a full bitstream of the Application Base Bitfile and generates partial bitstreams to the FPGA via the interfaces and . The partial bitstream reconfigures the FPGA according to the reconfiguration request.

The reconfigurable communication interfaces and may be a physical interface e.g. an Ethernet connection between different computer systems or just a logical interface between the application platform and the dynamic module server software components running on the same computer system. The reconfiguration interface is available to the FPGA application platform via a network or on board link and to a command line shell on the server workstation.

The module server thus presents a generic interface for RTR requests because it gets a list of datapaths available for the application a list of available modules A Z from the library a list of datapaths currently in the system and a list of modules present in a datapath. The server also adds or removes a datapath replaces a module in a datapath generates partial bitstreams that cover all changes since last bitstream.

In operation the compile time flow creates a folder structure to store the dynamic modules executes the preprocessor and platform implementation tools and calls the postprocessor . The output of the operation is a partial bitstream which includes only the configuration bits and an XML description file both of which are stored in the dynamic module library for use during the run time operations.

The application platform further includes a MicroBlaze three datapath input interfaces three output datapath interfaces and a sandbox region . The MicroBlaze of the FPGA has an on chip peripheral bus OPB interface port connected to the external memory controller Ethernet MAC and ICAP controller . The MicroBlazer also has FSL master ports and FSL slave ports. The master ports send information to the three datapath input interfaces while the slave ports receive information from the three datapath output interfaces .

The sandbox includes three input port anchor points for three independent datapaths and three output port anchor points a dynamic low pass module and a dynamic high pass module . The dynamic low pass module includes an input port anchor point output port anchor point a module interface logic connected to a low pass FIR filter core . The dynamic high pass module includes an input port an output port a module interface logic connected to a high pass FIR filter core . The low pass module and high pass module are connected in cascade. In the sandbox solid lines are static connections and dashed lines are dynamic connections. The input ports for the three independent datapaths are dynamically connected to the module interface logic of the dynamic low pass module . The module interface logic then sends the data to the module interface logic of the dynamic high pass module . The module interface logic of the high pass module sends a dynamical output signal to the output ports of the sandbox to the datapath output interfaces .

The dynamic filter modules and may be single channel FIR filters. The modules and may incorporate BRAM and DSP48 Slices. The platform may be a Virtex 4 platform such as an Avnet Memec V4LX60 MB board containing a Xilinx XC4VLX60 FPGA. The input and output ports and are port anchor points with bookend registers.

The present invention with the partial bitstreams and reconfiguration computing external to the FPGAs allows reconfiguration on the fly. shows how the bitstreams on the fly flow when the sandbox is empty and when the low pass filter module and high pass filter module are added to the datapath in the sandbox . With the partial bitstreams generated by the dynamic module server in such in house bitstream tools enable rapid system composition.

The present invention provides numerous capabilities. For example the present invention provides the following capabilities for the Xilinx Virtex II Pro and Virtex 4 block copy mask module instantiation individual PIP control in all general interconnect tiles and select global clock tiles assign LUT functions read write for full active partial and inactive partial bitstreams and graphical and text based maps of configuration data including a surrogate for FPGA Editor graphics.

Table 1 below shows the performance of the dynamic module server. In this instance the server platform specifications include Intel Pentium M 1.6 GHz 512 MB RAM. The execution time includes reading module bitfiles and ancillary data from hard disk files and writing partial bitstream to memory in preparation for network transfer not to a disk file.

In the present invention four application platforms are targeted a standalone FPGA an FPGA with an external processor an external server network connected to multiple FPGAs and a server controlling a cluster of FPGAs. It should be noted that the application platforms are not limited to only these four platforms. Across all platforms the user application does not necessarily directly manage any reconfiguration or relocation that is taking place. The application programming interface API provided to reconfigurable applications hides the location of the configuration control and data. For example loading a partial bitstream is a basic function in all platforms although the source of the bitstream may be local for the standalone and embedded variants or from a server for the networked and cluster environments . When an application is ported from one platform to another the basic interface does not change even though new services may be requested such as module relocation.

In the standalone variant a single FPGA reconfigures itself preferably through a processor or controller on the FPGA. The processor or controller loads bitstreams through the internal configuration access port from internal or external memory and could use configuration flash to store partial bitstreams. The on board controller has relatively modest computing power which limits its operations to simple module loading and swapping. This platform suits small FPGAs with few dynamic regions such as those that might be used in for example a micro unmanned aerial vehicle UAV . An on board controller monitors external signals and requests from the modules currently instantiated on the chip.

The embedded variant is similar to the standalone platform except that the controller is external to the FPGA. This increases the space available for reconfiguration on the FPGA allowing more application modules to be managed. A coprocessor architecture is provided wherein a general purpose processor serves as both the module controller and the host processor while the FPGA accelerates specialized processing tasks. Software defined radio SDR systems could also leverage this variant s ability to use a controller to swap waveforms as defined by partial bitstreams without interrupting SDR operation.

The present invention disclosed above provides a module based RTR of FPGAs flexible allocation of logic and wires from a dynamic pool and run time adaptable point to point communication. The present invention also provides a library of modules managed by an RTR server automated tool flow and architecture independent framework. Finally the invention focuses on streaming applications and using leverage existing design methodologies and tools.

While preferred embodiments of the invention have been set forth above those skilled in the art who have reviewed the present disclosure will readily appreciate that other embodiments can be realized within the scope of the invention. For example although the term reconfiguration is used throughout the disclosure herein but it should be understood that the present invention is applicable equally to the configuration of the FPGAs at power up. Also numerical values are illustrative rather than limiting. Therefore the present invention should be construed as limited only by the appended claims.

