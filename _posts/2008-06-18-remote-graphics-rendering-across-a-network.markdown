---

title: Remote graphics rendering across a network
abstract: A method for remotely displaying 3D information on a remote machine is disclosed. An application graphics command is generated, corresponding to a first 3D API from an application on a first machine. The application graphics command are translated to a remote graphics command corresponding to a second 3D API wherein the remote graphics command is compatible with a transport mechanism and a graphics driver on a second machine. The remote graphics command is transported over a network to a second machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08264494&OS=08264494&RS=08264494
owner: Pano Logic, Inc.
number: 08264494
owner_city: Redwood City
owner_country: US
publication_date: 20080618
---
This application claims priority to U.S. Provisional Patent Application No. 60 936 134 entitled REMOTE GRAPHICS RENDERING ACROSS A NETWORK filed Jun. 18 2007 which is incorporated herein by reference for all purposes.

Systems for remotely rendering three dimensional 3D graphics rely on platform specific protocols and infrastructures such as OpenGL over X11 for Linux Unix based platforms and Remote Desktop Protocol version 6.0 RDP 6.0 for Microsoft Windows based platforms. These systems may present problems. Some software applications may only exist for a specific platform and are not available for users of different platforms. The Microsoft DirectX Graphics Application Programming Interfaces APIs are only available for Microsoft Windows based platforms. Even when the same infrastructure is available there may exist different versions for example DirectX 9 and DirectX 7. RDP 6.0 is a closed protocol and implementing a client for all possible platforms is cost prohibitive and impractical.

OpenGL over X11 implementations on Microsoft Windows based platforms are not native and suffer from poorer performance. Similarly translation to OpenGL using products like VMWare Workstation or Parallels Desktop to run Microsoft Windows applications on a platform not using Microsoft Windows either by virtualization or emulation suffers from poorer performance.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Allowing devices to work around limitations and remote any 3D graphics application to a 3D capable arbitrary device across a network is disclosed.

In various embodiments client may communicate to a renderer on the display device . In some embodiments the renderer is an accelerator or coprocessor for 

In some embodiments the renderer is a software renderer or a hardware renderer. In some embodiments the renderer is a computer processing unit CPU graphics processing unit GPU or a physics processing unit PPU . Throughout this specification rendering refers to any complex task performed to display on display device including 2D acceleration 3D acceleration 4D acceleration multi dimensional acceleration photorealistic rendering and physics acceleration.

Throughout this specification 3D refers to any complex task performed to display on display device including 2D acceleration 3D acceleration 4D acceleration multi dimensional acceleration photorealistic rendering and physics acceleration. Throughout this specification 3D graphics and 3D information refers to graphics and information associated with any complex task performed to display on display device including 2D acceleration 3D acceleration 4D acceleration multi dimensional acceleration photorealistic rendering and physics acceleration. Throughout this specification 3D application refers to any application that may access a renderer for a complex task performed to display on display device including 2D acceleration 3D acceleration 4D acceleration multi dimensional acceleration photorealistic rendering and physics acceleration. Throughout this specification 3D API refers to any API to access a renderer for a complex task performed to display on display device including 2D acceleration 3D acceleration 4D acceleration multi dimensional acceleration photorealistic rendering and physics acceleration.

Host comprises a 3D application which is coupled to both a 3D API translator and memory buffers which are both coupled to generic 3D API runtime stub . 3D application may also be directly coupled with generic 3D API runtime stub . Generic 3D API runtime stub is coupled to generic 3D API transporter which is coupled to the corresponding client s generic 3D API transporter .

Client comprises generic 3D API transporter which is coupled to both client memory buffers and generic 3D API runtime . Memory buffers and client memory buffers are logically coupled so that client memory buffers represent a copy of memory buffers . Generic 3D API runtime is coupled to both generic 3D API driver and display driver which are both coupled to client hardware .

The 3D application running on host invokes a local 3D graphics API. In some embodiments the local 3D graphics API includes Microsoft DirectX or OpenGL. These calls are translated as required with 3D API translator into cross platform 3D API calls to stub and use memory stored in buffers . When the local 3D graphics API is the cross platform 3D API the calls are directly made to stub . Throughout this specification the term cross platform 3D API is identical to the term generic 3D API . In some embodiments the generic 3D API is the OpenGL 3D API version 2.1 as specified by the OpenGL ARB. The resulting commands and data are transported using generic 3D API transporters and . In some embodiments the host and client are connected over a network. In some embodiments the generic 3D API transporters and use a transport protocol such as UDP or TCP.

At client the generic 3D API calls are transported to generic 3D API runtime which connects couples with the client memory buffers additional processing may be performed. The calls also couple with the generic 3D API driver and display driver and the client hardware is used. The client may send some commands and data back to host as a result of the received commands.

In some embodiments when the 3D application is launched on host it loads a binary that implements the runtime module for the 3D API used usually in the form of a shared library. With 3D remote graphics rendering enabled the 3D application loads the local generic 3D API runtime stub which invokes the 3D API transporters and also referred throughout this specification as the 3D API Transport Layer .

In the case where the 3D application uses a 3D API that is different from the generic 3D API supported by the Transport Layer 3D API translator is used. 3D API translator translates API calls and acts as the 3D application from the point of view of generic 3D API runtime stub and is also referred throughout this specification as the 3D API Translation Layer . The 3D API Transport Layer when 3D API transporters and are coupled through a network use network capabilities of the platform such as network sockets to connect.

In some embodiments when 3D application terminates its operations and closes down the local generic 3D API runtime stub is unloaded. Upon notification of being unloaded it asks the generic 3D API transporter to disconnect from the client . All the data buffers which have been allocated in the system are cleaned up. The client side generic 3D API transporter goes into listening mode waiting for incoming connections to service.

As 3D application makes a 3D API call the generic 3D API runtime stub encodes each API call into a unique operation code opcode and puts it at the top of the buffer to be transmitted. The API call arguments are added subsequently to the buffer. In some embodiments two buffer types may be used a Function Buffer Unit FBU for command encapsulation and a Data Buffer Unit DBU for data encapsulation.

In some embodiments where size permits for the case where an argument of a 3D API call is a pointer to an area of memory the actual data located in that area of memory is added to the FBU . In the example shown in FBU arg 3 is a pointer to an area of memory that fits in FBU .

In some embodiments where size does not permit or where otherwise specified for the case where an argument of a 3D API call is a pointer to an area of memory the other arguments are added to FBU a place holder pointer is put in FBU while the data itself is broken down into multiple pieces with opcode in DBU and transmitted later on. In the example shown in FBU and DBU arg 3 is a pointer to an area of memory that is to be transmitted later on.

The FBU or FBU and DBU are transported to generic 3D API transporter where they are reassembled with pointers to memory using client memory buffers and fed to a client side 3D fake application that makes the transported 3D API call to the generic 3D API Driver and or Display Driver .

In some embodiments 3D APIs may be statefull implying that a 3D application binds various data buffers to various stages of the 3D rendering pipeline for example textures for the texturing stage or depth buffers for the occlusion detection stage before sending primitives through the processing stages.

The 3D API call to explicitly instantiate a texture in OpenGL is glTexImage2D void glTexImage2D GLenum target GLint level GLint internalformat GLsizei width GLsizei height GLint border GLenum format GLenum type const GLvoid pixels .

This call takes a list of parameters along with a pointer to the actual texture data pixels to create a texture object. When 3D application calls glTexImage2D the generic 3D API transporter packs the opcode associated with glTexImage2D along with the list of arguments and their types. The argument which provides the pointer to the data is marked for processing by the generic 3D API transporter . In this example the data is stored in the DBU and other arguments in FBU rather than only in FBU .

Upon reception of the FBU the client side 3D fake application reconstructs the 3D API call which was encapsulated. As it detects that one of the arguments is a pointer to DBU in this example the pixels argument it allocates a client side piece of memory for example local pixels using the information provided by the other arguments width height format border etc. As DBUs are received at 3D API transporter their content is stored in a pre allocated memory area. After reception of the complete set of data including that in DBU the client side 3D fake application makes the 3D API call using all the arguments received from FBU but replacing the value of pixels argument by local pixels.

The same mechanism is used when the 3D API call has multiple arguments which point to data buffers and therefore need to be transported using one or more DBUs.

The logical path between the 3D application to hardware includes five components generic 3D API runtime stub generic 3D API transporter generic 3D API transporter generic 3D API runtime and generic 3D API Driver . Each one of these five components has a set of capabilities that can differ depending on the version of the API supported as well as inherent limitations of the implementation.

The 3D application starts by requesting the system s capabilities by making a GetCapabilities query or equivalent. In some embodiments each of the components makes sure it only reports capabilities that it can handle. The 3D API translator will determine the platform s 3D API capabilities as the common set between at least five capabilities 

When 3D application uses a different 3D API than the generic 3D API supported by the generic 3D API Transport Layer translation is performed. In some embodiments when a 3D application is written for the DirectX 3D API and executed the 3D API Translation Layer is a DirectX runtime which performs 3D API translation.

To perform such an operation the 3D API Translation Layer acts as an application that uses the generic 3D API supported by the generic 3D API Transport Layer . The 3D API Translation Layer queries the capabilities of the platform as described in and constructs its own capabilities table that it reports back to 3D application .

In some embodiments 3D APIs are similar in semantics and the translation between for example Microsoft DirectX API calls and OpenGL 3D API calls is primarily a one to one operation when the API versions are close in functionality for example DirectX 9 and OpenGL 2.x. When the API versions are not close in functionality it may or may not be possible to map a given API call onto another one from the generic 3D API. In some embodiments the Wine Open Source Project provides a set of libraries which is used as part of the 3D API Translation Layer from the Microsoft DirectX 3D API to the OpenGL 3D API for example DirectX API versions 7 8 9 and 9Ex to OpenGL version 2.1.

The translation of a 3D API call into a generic 3D API call takes into account that the 3D API Transport Layer is used in conjunction with the 3D API Translation Layer . In some embodiments 3D API Transport Layer is more efficient at sending large segments of data at a time whereby the 3D API Translation Layer would use transport friendly generic 3D API calls semantics.

A DirectX 3D application requests the use of Vertices to draw a 3D scene by using a Flexible Vertex Format buffer. The Translation layer has to translate the DirectX construct into an OpenGL one. There are three options 

Using the OpenGL Immediate mode as shown in is a safe option for translating DirectX Vertex rendering options as OpenGL Immediate mode is present in all versions of the OpenGL API. The performance of such an implementation is adequate when the 3D API Translation Layer and the 3D rendering are performed on the same machine rather than a host and client as in . This is usually the case where the amount of geometry primitives used by 3D application is small.

However given that the 3D API Transport Layer is inefficient at packaging small buffers if the Vertex Array or Vertex Buffer Object mechanisms are supported by the 3D Platform as described in the 3D API Translation Layer can use either of them for better system performance despite the extra overhead that using Vertex buffers introduces such as management or initialization. That is 3D API Translator translates the application graphics command based at least in part on the resulting data unit size required for its transport over a network. As shown in an extra benefit of using these mechanisms is that Vertex data is only sent once across the network. It can be referenced on the client side multiple times without having to send the Vertex data again.

In some embodiments the 3D API Translation Layer may compile a complex geometry and or commands into primitive geometries and or commands if the platform 3D API capabilities do not comprise APIs for the complex geometry and or commands. For example for a platform 3D API that does not support the capabilities for quadrants the 3D API Translation Layer may compile the quadrants to vertices and edges which are supported by the platform 3D API.

In the context of remote graphics rendering the source buffer is usually located on the client side since it has been previously transported across the network or rendered on the client side . In such a case a trivial but low performing implementation of these API calls would be to 

The bandwidth used by the data buffer transfers described can be reduced by using compression techniques such as lossy or lossless image compression algorithms for Texture data surfaces for example JPEG or Run Length Encoding. For other buffers lossless compression such as Lempel Ziv Zip or gzip compression may be used. The header present in each DBU contains flags which indicate whether compression is enabled or not in the present DBU and the type of compression used.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

