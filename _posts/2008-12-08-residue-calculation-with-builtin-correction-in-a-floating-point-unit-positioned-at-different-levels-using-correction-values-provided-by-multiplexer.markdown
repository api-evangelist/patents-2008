---

title: Residue calculation with built-in correction in a floating point unit positioned at different levels using correction values provided by multiplexer
abstract: A residue generator for calculation and correction of a residue value. The residue generator includes a residue-generation tree connected with an operand register at an input of the residue generator including a plurality of register-bits receiving and carrying bits of numerical data. The residue-generation tree includes a multiplexer connected with respective register-bits which carry unused bits, and selectively providing logical zeros or a correction value when provided, at the respective register-bits carrying the unused bits, a plurality of decoders, each decoder receiving the bits of numerical data from the respective registers-bits including the logical zeros or the correction value when provided and decoding the numerical data, and a plurality of residue condensers, receiving the decoded numerical data from the decoders including the logical zeros or the correction value when provided, and calculating the residue value and correcting while calculating the residue value using the correction value when provided by the multiplexer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08352530&OS=08352530&RS=08352530
owner: International Business Machines Corporation
number: 08352530
owner_city: Armonk
owner_country: US
publication_date: 20081208
---
This invention was made with Government support under Contract No. HR0011 07 9 0002 awarded by DARPA. The Government has certain rights to this invention.

The present invention relates to residue calculation and correction within a floating point unit FPU of a microprocessor and more specifically to residue calculation with built in correction eliminating a need for additional circuitry or logic delay.

A conventional FPU of a microprocessor typically includes a residue checking apparatus which performs residue checking for detecting errors in arithmetic floating point operations such as addition subtraction multiplication division square root or convert operations. The residue checking is performed within a checking flow by performing the same operations on the residue as those performed on the operands of the FPU. That is a checking flow is performed in parallel to a data flow within the FPU. In a data flow and a checking flow of a conventional residue checking apparatus for a FPU are shown. Operands A B and C are provided by an input register in the data flow . The operands A B and C are processed differently based on different functional elements e.g. an aligner and a normalizer and a result is provided by a result register .

Residues are generated at specified positions within the data flow by residue generators . When performing residue checking of the FPU several residue calculations are performed via the checking flow in parallel with the data flow performing the operations on the data. Therefore modulo decoders are connected to the residue generators and provide residue modulos to different functional elements such as a modulo multiplier modulo adder modulo subtract modulo add sub and modulo subtract within the checking flow . In the first stage of the checking flow the residue modulos of operands A and B are multiplied by the modulo multiplier . In the second stage the residue modulo from operand B is added to the product residue modulo from stage via the modulo adder . In the third stage the residue modulo of bits lost at the aligner is subtracted by the modulo subtract from the sum of the second stage . During the residue checking operation residue corrections to the actual residue value corresponding to the manipulated data in the data flow may be necessary. For example a small correction amount such as 1 may be necessary. Therefore in the fourth stage residue correction of 1 is performed by the modulo add sub . Then in the fifth stage a residue subtract of bits lost at the normalizer is performed by the modulo subtract . In the sixth stage a single check operation is performed by a compare element . The compare element compares the result provided by the modulo subtract with the residue modulo of the result provided by the result register of the data flow .

Each residue generator includes a residue generation tree as shown in . illustrates a conventional modulo residue generation tree for example. Different residue values other than residue are also utilized. As shown in register bits of an operand register carry 32 bits of an operand starting with the most significant bit MSB in the register bit indicated with 0 on the left and ending with the least significant bit LSB in the register bit indicated with 31 on the right. The residue generation tree includes a plurality of modulo decoders and a plurality of residue condensers . Each modulo decoder is connected with four adjacent register bits of the operand register for receiving in parallel four bits of numerical data. Every adjacent pair of modulo decoders is connected to a residue condenser . Further each residue condenser is connected to two residue condensers from a previous stage. According to m 2 1 a number of segment bits b 4 is required to receive a modulo base m 15. According to w p b the number of segments p 8 in combination with an operand with an operand width w of w 32. In the conventional residue generation tree the number input into the residue generator typically does not use all of the input bits because floating point data include a mantissa and an exponent and the exponent is extracted and handled separately. Therefore the register bits that contain the exponent bits at the entrance as indicated by the arrows now containing the MSBs or LSBs of the number are filled with logical zeros and are not used to generate a residue value. Also to save design and circuitry work in the floating point unit the same residue generating macro is typically used multiple times for the different residue generation points within the unit and since these residue generators do not all need the full width of the dataflow typically some bits of these residue generators are unused and are tied to zero.

The present invention provides a residue generator for a residue checking apparatus capable of performing residue calculation and correction to eliminate the need for extra hardware such as a modulo add sub separately performing residue corrections and to prevent additional logic delay.

According to one embodiment of the present invention a residue generator of a residue checking apparatus for calculation and correction of a residue value. The residue generator includes a residue generation tree connected with an operand register at an input of the residue generator including a plurality of register bits which receive and carry bits of numerical data. The residue generation tree includes a multiplexer connected with respective register bits which carry unused bits and selectively providing at least one of logical zeros or a correction value when provided at the respective register bits carrying the unused bits a plurality of decoders each decoder receiving the bits of numerical data from the respective registers bits including the least one of logical zeros or the correction value when provided and decoding the numerical data and a plurality of residue condensers positioned at different levels and receiving the decoded numerical data from the decoders including the at least one of logical zeros or the correction value when provided and calculating the residue value and correcting while calculating the residue value using the correction value when provided by the multiplexer.

According to another embodiment a distributed residue checking apparatus for a floating point unit having a plurality of functional elements performing floating point operations on a plurality of operands is provided. The distributed residue checking apparatus includes a plurality of residue generators which calculate residue values for the operands and the functional elements and including specified residue generators of the plurality of residue generators which calculate the residue values and correct the calculated residue values simultaneously and a plurality of residue checking units distributed throughout the floating point unit each residue checking unit receiving a first residue value and a second residue value from respective residue generators and comparing the first residue value to the second residue value to determine whether an error has occurred in a floating point operation performed by a respective functional element.

According to another embodiment a method of calculating and correcting a residue value via a residue generator including a residue generation tree is provided. The method includes receiving and carrying bits of numerical data in an operand register having a plurality of register bits connecting a multiplexer to respective register bits carrying unused bits selectively providing via the multiplexer at least one of logical zeros or a correction value at the respective register bits carrying the unused bits decoding via decoders the bits of numerical data including the at least one of logical zeros or the correction value when provided inputting to a plurality of residue condensers the decoded numerical data including the at least one of logical zeros and a correction value when provided and calculating the residue value and correcting it while calculating via the plurality of residue condensers when the correction value is provided by the multiplexer.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with the advantages and the features refer to the description and to the drawings.

With reference now to there is a residue checking apparatus including residue generators for a floating point unit that can be implemented within an embodiment of the present invention. The present invention is not limited to floating point calculations and may be used on binary or decimal operations for example.

As shown in a data flow and a checking flow of a residue checking apparatus for a FPU is shown. Operands A B and C are provided by an input register in the data flow . A plurality of functional elements is also provided to perform floating point operations on the plurality of operands A B and C. The plurality of functional elements include for example a multiplier an aligner a partial sum and carry register a main adder a sum register for the main adder and a normalizer . As shown in operands A and C are input into a multiplier and the operand B is input into the aligner . The result of the aligner and the product result of the multiplier are then input into the partial sum and carry register . The results of the aligner and the multiplier are then added together via the main adder and the sum is placed in the sum register . The results of the sum register are input into the normalizer which performs a normalization operation. The results of the normalizer are then input into a result register .

Residue values are generated at specified positions within the data flow by residue generators and . According to one embodiment of the present invention the residue generators function in a same manner as the conventional residue generators shown in for example. According to one embodiment in addition to calculating the residue values of the aligner the normalizer and the result register the residue generators as indicated by the dashed boxes may also receive a correction value from a control logic not shown to correct while calculating the residue values such that the residue calculation and correction may be performed simultaneously for example. That is the present invention supplies a correction value into the residue generators to correct the residue value while it is being calculated. Additional details concerning features of the residue generators will be discussed below with reference to .

Further in according to one embodiment the checking flow includes modulo decoders that are connected to the residue generators and and provide residue modulos to different residue functional elements such as a modulo multiplier modulo adder modulo subtract and modulo subtract . In this embodiment of the present invention since the residue generators both calculate and correct the residue values an additional modulo add sub functional element as shown in the prior art in is unnecessary thereby decreasing the need for additional hardware and logic delay. Further additional residue correction is not needed within the checking flow . A residue checking operation of the checking flow will now be described below.

In the first stage the residue modulos of operands A and B are multiplied by the modulo multiplier . In the second stage the residue modulo from operand B is added to the product residue modulo from stage via the modulo adder . In the third stage the residue modulo of bits lost at the aligner is subtracted by the modulo subtract from the sum of the second stage . In the fourth stage a residue subtract of bits lost at the normalizer is performed by the modulo subtract . In the fifth stage a single check operation is performed by a compare element . The compare element compares the result provided by the modulo subtract with the residue modulo of the result provided by the result register of the data flow . A detailed description of the residue generators will now be described below with reference to .

According to an embodiment the residue generation tree includes a plurality of modulo decoders a plurality of residue condensers . Each modulo decoder is connected with four adjacent register bits of the operand register for receiving in parallel four bits of numerical data according to residue as used in this example. According to an alternative embodiment a residue would e.g. use 3 bits. The modulo decoders each decode the numerical data received from the respective register bits. That is the decoders transform coded signals which are in binary format for example into decoded signals which are modulo remainders for example. Each adjacent pair of modulo decoders is connected to a residue condenser . The plurality of residue condensers are positioned at different levels and receive the decoded numerical data from the modulo decoders . Further each residue condenser is connected to two residue condensers from a previous stage and a single residue condenser is provided in the last stage of the residue generation tree . The present invention is not limited to the use of a modulo residue generation tree and may vary as necessary. Further according to an embodiment of the present invention the residue condensers may be a plurality of adders or a series of decoders and multiplexers for example.

Further as shown in according to an exemplary embodiment of the present invention the residue generation tree further includes a multiplexer . According to one embodiment the multiplexer is a 4 bit multiplexer however the present invention is not limited hereto and may vary as necessary. The multiplexer may be a 3 or 5 bit multiplexer for example. According to embodiments of the present invention the multiplexer may be provided at the register bits inputs or outputs. In the multiplexer selectively provides logical zeros or a correction value at the inputs of the respective registers bits carrying unused bits as indicated by the arrow for example . Since the multiplexer may be provided at the register bits inputs or outputs the correction value may be supplied to the unused bits at the register bits inputs or outputs. Every bit of the operand register has a defined contribution to the resulting residue value. There is a repetitiveness of validity of a bit e.g. when calculating residue each bit has a contribution of either 1 2 4 or 8 and these contribution values repeat from bit to for a 32 bit register. Thus the present invention is not limited to applying the correction value to bits through and may be applied to any unused bits within the register bits of the operand register . According to an embodiment of the present invention a correction value may be selectively provided by the multiplexer to correct while calculating the residue value via the residue generator . Control logic not shown determines when a correction is needed for an executed floating point operation e.g. if an increment or round up is needed if an adder carry should supply a correction value e.g. by 1 or specified corrections for negative numbers . Thus according to one embodiment when residue correction is necessary a correction value may be applied via the multiplexer and if a correction is unnecessary the multiplexer assigns logical zeros to the register bits carrying the unused bits.

According to one embodiment when the decoded numerical data including the logical zeros or the correction value when provided is input into the residue condensers connected with the modulo decoders outputs are generated from the respective residue condensers . The outputs are then input into a pair of residue condensers in the next stage and the outputs of the pair of residue condensers are then input into the residue condenser in the last stage of the residue generation tree . The residue condenser in the last stage receives the outputs from the residue condensers in the previous stage and calculates the residue value and corrects while calculating the residue value by adding a correction value of between zero and the maximum residue value when provided by the multiplexer .

According to one embodiment in the case of the modulo residue generation tree shown in a correction value may be applied as a hexadecimal value between zero and 15. Due to the mathematical properties of residues negative values can be achieved by applying their complement to the maximum residue value e.g. a correction of 1 can be obtained by applying a value of 14 binary 1110 a correction of 2 can be reached by applying a value of 13 binary 1101 to the correction inputs. Typical usages for such corrections show up in designs where an adder produces a carry bit or when special operations need an input bit to be forced to one. Typically correction values of 1 2 1 or 2 are used. The present invention is not limited hereto and may vary accordingly.

Further according to an embodiment of the present invention the data flow includes a plurality of residue generators and that calculate residue values within the FPU . According to one embodiment of the present invention the residue generators as indicated by the dashed boxes calculate residue values and correct the calculated residue value simultaneously. The residue values are generated by the residue generators and at specified positions within the data flow . According to one embodiment of the present invention the residue generators and have either approximately 64 bits data flow capacity or 128 bits for example. That is some of the residue generators have a wider data flow capacity to thereby accommodate the output of the aligner for example. The present invention is not limited to hereto and may vary as necessary.

In the data flow operands A B and C are input via the input register in parallel. As shown in operands A and C are multiplied via the multiplier while operand B which is to be added to the results of the multiplier at a later pipeline stage is input into and shifted via the aligner . Residue values of the operands A B C are generated by respective residue generators . The results at the aligner and the results from the multiplier are then input to the partial sum and carry register . The results of the aligner and the multiplier are added together in the main adder and the sum is placed in the sum register add . Residue values of the aligner are generated by respective residue generators

As further shown in the results of the aligner are also input into and incremented via the incrementer based on instructions provided. The results of the incrementer are then input into the incrementer register . The results of the incrementer register and the sum register add are input into the normalizer which performs a normalization operation. Residue values of the results of the incrementer register and the sum register add are calculated by respective residue generators and corrected by the respective residue generators when necessary in the same manner as described with reference to and described below in more detail.

According to an embodiment of the present invention the residue generators function in a same manner as the residue generators shown in . That is residue generators perform both residue calculation and correction. These residue generators are positioned at the outputs of the incrementer register of the incrementer and the sum register add of the main adder . Since minor corrections to the calculated residue values of the incrementer and the main adder are sometimes necessary when forcing an adder carry in or when incrementing a value via the incrementer a correction value can be supplied at the same time. Therefore the residue generators calculate and correct residue values simultaneously. That is the residue generators may modify the input received in the operand register as shown in for example and then calculate the residue value.

Further shown in the results of the normalizer are then input into a result register and residue values of the normalizer loss and the result register are then calculated at a respective residue generator . According to an embodiment of the present invention the distributed residue checking apparatus performs distributed residue checking operations of the residue values calculated by the residue generators and as described below.

According to an embodiment the distributed residue checking apparatus includes a plurality of residue checking units including a first residue checking unit a second residue checking unit a third residue checking unit and a fourth residue checking unit distributed throughout the data flow and the checking flow of the FPU . Each residue checking unit through receives a first residue value and a second residue value from respective residue generators or and compares the first residue value to the second residue value to determine whether the first and second residue values are equal. The respective residue checking unit or produces an error signal when the first and second residue values are not equal which indicates an error has occurred during performance of the floating point operation performed by the respective functional element .

The first residue checking unit compares the residue value from the operand B to the residue value resulting from the aligner . According to one embodiment the residue value resulting from one functional element and input into a residue checking unit in one pipeline stage may also be input into another residue checking unit in a subsequent pipeline stage. This eliminates the need for an additional residue generator as input reference for a later pipeline stage residue comparator. For example the residue value result of the aligner used by the first residue checking unit in one pipeline stage is also forwarded via a stage register to the second residue checking unit to be used in the next pipeline stage. Thus one clock cycle later the second residue checking unit compares the residue value of the aligner to the residue value of another functional element i.e. the incrementer to determine whether the data is correct.

According to an embodiment of the present invention in the checking flow a plurality of residue arithmetic elements are provided to perform residue arithmetic operations on the residue values calculated by the residue generators and . The residue calculating elements may include a residue multiplier a residue add and a residue subtract for example. The present invention is not limited hereto and may vary as necessary. The residue arithmetic elements are used to verify calculations performed by the multiplier and the main adder for example.

At a first stage of the checking flow the residue values of the operands A and C are first multiplied via the residue multiplier . Next in the second stage the product of the residue multiplier is forwarded and in the third stage the product of the residue multiplier and the residue value of the aligner are added via the residue add . In the fourth stage the residue value of the main adder and the result of the residue add are compared via the third residue checking unit to check the accuracy of the multiplier and the main adder .

In the fifth stage the residue value of the data bits lost in the normalizer is subtracted from the residue value of the main adder via the residue subtract . In the sixth stage the results of the residue subtract are then compared to the residue value from the result register via the fourth residue checking unit

According to an embodiment of the present invention a number of the residue checking units through are independent from the remaining residue checking units through

The residue generator according to embodiments of the present invention includes a residue generation tree that utilizes unused input bits by applying a necessary correction value to those input bits via a multiplexer. The control logic determines if a correction is needed for an executed instruction e.g. if an increment or round up is needed or whether an adder carry should correct the residue value and applies the appropriate correction value to the formerly unused input bits of the residue generation trees of residue generators . Thus the present invention provides the advantage of calculating a residue value and correcting the residue value using the same circuitry and without extra delay. Thus the block of of the conventional art checking is not needed here.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations element components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated

The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention had been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

