---

title: Command buffers for web-based graphics rendering
abstract: The described embodiments provide a system that renders graphics for a computer system. During operation, the system loads a software client and a software service in the computing system. Next, the system receives a set of rendering commands from the software client in a command buffer, wherein the rendering commands include at least one of a state change command, a resource allocation command, a direct memory access (DMA) command, buffer data, and a synchronization command. Finally, the system uses the software service to render an image corresponding to the rendering commands by reading the rendering commands from the command buffer and executing the rendering commands.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08675000&OS=08675000&RS=08675000
owner: Google, Inc.
number: 08675000
owner_city: Mountain View
owner_country: US
publication_date: 20081107
---
The subject matter of this application is related to the subject matter in a co pending non provisional application by inventors Robin Green Evangelos Kokkevis Matthew Papakipos and Gregg Tavares and filed 16 Jul. 2008 entitled Web Based Graphics Rendering System having Ser. No. 12 174 586.

The subject matter of this application is also related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008.

The subject matter of this application is also related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008.

The present embodiments relate to graphics rendering techniques. More specifically the present embodiments relate to techniques for using command buffers in web based rendering of graphics.

Computer systems often include a number of native applications that require complex three dimensional 3D scenes to be rendered such as computer games and computer aided design CAD systems. To render 3D scenes these native applications may use graphics application programming interfaces APIs that direct calculations related to graphics rendering to dedicated graphics processing units GPUs . The additional computational power provided by these GPUs can greatly improve graphics quality and throughput.

Web applications which have become more prevalent in recent years are typically written in scripting languages that are unable to utilize low level graphics APIs that provide graphics hardware acceleration. Instead graphics rendering for web applications is typically performed by CPUs instead of GPUs. The software based nature of web based graphics rendering may thus limit the graphics capabilities of web applications. However unlike native applications web applications provide a number of advantages. For example web applications are capable of executing on multiple platforms do not require installation and can be more secure than native applications.

The tradeoff between web application security and native graphics performance may be addressed using a browser plugin that renders graphics for web applications by interfacing with a local graphics hardware device e.g. a GPU . Such a plugin may correspond to a complex software system that includes various mechanisms for obtaining scene information from the web applications storing the scene information processing the scene information using transforms effects and shaders and sending commands to the graphics hardware for rendering the scene. Consequently the plugin itself may include a number of potential security vulnerabilities that may be exploited by other applications and or bugs that may lead to system failures.

Hence what is needed is a mechanism for safely executing the plugin while maintaining communication between the plugin and graphics hardware.

Some embodiments provide a system that renders graphics for a computer system. During operation the system loads a software client and a software service into the computing system. Next the system receives a set of rendering commands from the software client in a command buffer wherein the rendering commands include at least one of a state change command a resource allocation command a direct memory access DMA command buffer data and a synchronization command. Finally the system uses the software service to render an image corresponding to the rendering commands by reading the rendering commands from the command buffer and executing the rendering commands.

In some embodiments the system also writes the buffer data to a shared memory buffer using the software client and further executes the rendering commands using the software service by transferring the buffer data to a resource from the shared memory buffer.

In some embodiments the resource corresponds to at least one of a frame buffer a vertex buffer a texture buffer and an index buffer.

In some embodiments executing the rendering commands involves asynchronously creating the resource from the resource allocation command in the command buffer.

In some embodiments executing the rendering commands involves formatting the rendering commands and sending the formatted rendering commands to a graphics processing unit GPU of the computing system which renders the image.

In some embodiments the system also synchronizes interaction between the software client and the software service.

In some embodiments synchronizing interaction between the software client and the software service involves at least one of 

In some embodiments the software client corresponds to at least one of a native code module a web application and a graphics library.

In some embodiments the ring buffer includes a put pointer corresponding to a last rendering command from the rendering commands written by the software client and a get pointer corresponding to a next rendering command from the rendering commands to be read by the software service.

In some embodiments the get pointer is stored in shared memory between the software client and the software service.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present embodiments. Thus the system is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described below can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

Embodiments provide a method and system for rendering graphics in a computing system. The computing system may be for example a personal computer PC a mobile phone a personal digital assistant PDA a graphing calculator a portable media player a global positioning system GPS receiver and or another electronic computing device. More specifically embodiments provide a method and system for rendering graphics using command buffers. The command buffers allow asynchronous communication to occur between a software client and a software service. Furthermore a command buffer interface may facilitate synchronous communication between the software client and the software service.

In one or more embodiments the software client is executed as a native code module in a secure runtime environment. The secure runtime environment may enable safe execution of the software client on the computing system by validating the native code module and restricting access to system resources. Communication with graphics hardware may be provided by the software service which may be installed locally on the computing system as a trusted code module. Graphics rendering may thus occur by writing rendering commands to the command buffer using the software client and reading rendering commands from the command buffer using the software service. The software service may then format the rendering commands and send the formatted rendering commands to a GPU of the computing system for rendering on the GPU.

In one or more embodiments the command buffer is used to facilitate interaction between a web application implemented using a native code module and the GPU. In other words the native code module may write rendering commands directly into a hardware command buffer that is used by the GPU to render images for the web application. As a result the web application may directly request execution of rendering commands by the GPU using the native code module and command buffer.

Computing system may correspond to an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system not shown that coordinates the use of hardware and software resources on computing system as well as one or more applications that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. processor memory I O components wireless transmitter GPU etc. on computing system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system.

To enable interaction with the user computing system may include one or more hardware input output I O components such as a pointing device and a display screen. Each hardware I O component may additionally be associated with a software driver not shown that allows the operating system and or applications on computing system to access and use the hardware I O components.

Those skilled in the art will appreciate that the functionality of certain applications on computing system may depend on the applications ability to utilize graphics hardware acceleration on computing system . For example the graphics quality of a computer game may be based on the ability of the computer game to communicate with GPU .

Those skilled in the art will also appreciate that certain applications on computing system may be unable to utilize GPU in graphics rendering due to limitations in resource access and or performance. In particular graphics rendering for web applications may be performed using software that executes on a CPU of computing system rather than GPU . As a result graphics in web applications may be slow and or suboptimal compared to graphics in native applications that employ graphics hardware acceleration.

To enable graphics support and graphics hardware acceleration for web applications operations related to graphics processing may be offloaded to a web browser plugin in computing system . The plugin may expose the capabilities of GPU to the web applications thus allowing the web applications to utilize graphics hardware acceleration including the application of vertex and pixel shaders. Plugin based graphics hardware acceleration for web applications is described in a co pending non provisional application by inventors Robin Green Evangelos Kokkevis Matthew Papakipos and Gregg Tavares and filed 16 Jul. 2008 entitled Web Based Graphics Rendering System having Ser. No. 12 174 586 which is incorporated herein by reference.

However the plugin may correspond to a complex software system that includes a number of security vulnerabilities. Furthermore the plugin may include a scene graph renderer that includes limited ability to accept low level graphics rendering commands. To increase the security and versatility of the plugin the plugin may be implemented using a command buffer interface between two software components software client and software service . Software client and software service may execute on separate processes within computing system . Furthermore software client and software service may communicate and implement graphics rendering using a combination of asynchronous and synchronous mechanisms as explained below.

As shown in scene graph renderer is implemented using software client . In other words software client may include functionality to obtain and or store a graphics model to be rendered for an application such as a web application. The graphics model may include for example a set of shapes composed of triangles or polygons one or more light sources a camera and or one or more rendering effects e.g. shaders culling blending etc. . As described in the above referenced application the graphics model may additionally be stored in one or more data structures such as scene graphs buffers and or effects.

To render an image corresponding to the graphics model software client may transmit a set of rendering commands to software service . A command parser in software service may then format and or process the rendering commands. The formatted and or processed rendering commands may be passed from software service to rendering engine which executes the rendering commands by communicating with GPU . For example the rendering commands may correspond to low level commands that are parsed by command parser and translated into function calls into a rendering engine such as a Direct3D Direct3D is a registered trademark of Microsoft Corp. or OpenGL OpenGL is a registered trademark of Silicon Graphics Inc. renderer. The function calls may then be translated into graphics processing instructions for GPU by the renderer. Alternatively rendering engine may interface directly with GPU by issuing hardware instructions to GPU or command buffer interface may correspond to a direct interface with GPU as described in further detail below with respect to .

Those skilled in the art will appreciate that interaction between software client and software service may require synchronous inter process communication IPC mechanisms such as message passing remote procedure calls RPC and or sockets. Such IPC mechanisms may be provided by command buffer interface in the form of function calls between software client and software service . On the other hand IPC techniques alone may not pass individual rendering commands from software client to software service at a rate that is high enough to enable real time computer graphics. For example an RPC mechanism may be unable to support the number of function calls and or rendering commands e.g. one million required to render a three dimensional 3D scene for a computer game at 60 frames per second.

To enable real time rendering of 3D graphics command buffer interface may also include mechanisms by which software client and software service may operate asynchronously. More specifically asynchronous communication between software client and software service may be enabled using command buffer and shared memory buffer .

Command buffer may be created upon loading and or initialization of software client and or software service . For example command buffer may be created by software service and passed to software client through command buffer interface . Moreover both software client and software service may map command buffer into their respective address spaces for direct access to command buffer .

In one or more embodiments command buffer includes functionality to store rendering commands from software client to software service . As described above such rendering commands may correspond to low level graphics rendering commands that are generated on the order of tens of thousands of rendering commands per frame. Rendering commands stored in command buffer may include for example state change commands resource allocation commands direct memory access DMA commands buffer data and or synchronization commands. Most rendering commands may not require a return value thus allowing issuance of the rendering commands by software client and execution of the rendering commands by software service to be independent and or asynchronous.

Command buffer interface may allow software client to write sets of rendering commands to command buffer . As the rendering commands are written to command buffer the rendering commands may be read by command parser and executed by software service and or rendering engine . One or more images corresponding to the rendering commands may thus be produced by GPU through the transmission of rendering commands from software client to software service using command buffer .

As described above rendering engine may correspond to an OpenGL Direct3D and or other renderer that interfaces with GPU to render graphics. Furthermore the functionality of rendering engine may be accessed through an interface e.g. application programming interface API with other software components such as software service . Consequently software service may execute rendering commands from command buffer by reading and or interpreting the rendering commands using command parser and making corresponding function calls to rendering engine through the interface with rendering engine .

In other words software service may format the rendering commands from command buffer such that the rendering commands are understood by rendering engine and conveyed to GPU by rendering engine . The formatting may be accomplished by mapping each rendering command to a command table that stores API calls to rendering engine for each rendering command. The rendering command may then be executed by making the API calls to rendering engine using parameters and or arguments accompanying the rendering command in command buffer . Encoding schemes for rendering commands are discussed in further detail below with respect to .

Synchronization of actions between software client and software service may also be provided by command buffer interface . In particular command buffer interface may include mechanisms for synchronizing the writing of rendering commands to command buffer by software client with the reading and execution of rendering commands from command buffer by software service . In other words command buffer interface may provide concurrency control mechanisms between software client and software service to enforce the correct execution of rendering commands by software service rendering engine and or GPU .

In one or more embodiments command buffer is implemented as a ring buffer i.e. circular buffer . Furthermore command buffer may include a set of pointers e.g. offsets into command buffer that denote the effective start and end of the ring buffer. More specifically command buffer may include a put pointer that represents the last rendering command written to command buffer by software client . Command buffer may also include a get pointer that represents the next rendering command to be read from command buffer by software service . Consequently command buffer interface may provide mechanisms for controlling the put pointer by software client controlling the get pointer by software service and or reading the values of either pointer by software client and or software service .

For example the put and get pointers may both be stored in the address space of software service . Software client may write to the put pointer and read the get pointer through a message passing and or RPC mechanism provided by command buffer interface . However because the RPC mechanism may be associated with significant overhead software client may only update the put pointer after writing a batch of e.g. several rendering commands to command buffer . Similarly software client may cache the value of the get pointer and only update the cached value when the value of the put pointer nears the value of the get pointer.

Alternatively each pointer may be stored in the address space of the respective controlling entity. In other words the put pointer may be stored in the address space of software client and the get pointer may be stored in the address space of software service . Command buffer interface may then provide mechanisms for sending the value of the put pointer to software service and or the value of the get pointer to software client . Finally the get pointer may be stored in shared memory e.g. shared memory buffer that may be directly accessed by both software client and software service to reduce the need for IPC between software client and software service . However to store the get pointer in shared memory command buffer interface may also implement access control restrictions that prevent software client from writing to the memory address corresponding to the get pointer.

Those skilled in the art will appreciate that basic ring buffer synchronization may be implemented using the get and put pointers of command buffer . In other words rendering commands from the get pointer to the put pointer may correspond to rendering commands that have not been read or executed by software service and should not be modified. Similarly rendering commands from the put pointer to the get pointer may correspond to rendering commands that have been read and or executed and can be modified. Software client may continue writing rendering commands into command buffer until the value of the put pointer reaches the value of the get pointer indicating that command buffer is full. Along the same lines software service may continue reading and or executing rendering commands from command buffer until the value of the get pointer reaches the value of the put pointer indicating that command buffer is empty.

Command buffer interface may also enable synchronization of software client and rendering engine and or GPU . Because graphics rendering through renderers such as OpenGL and Direct3D renderers and or GPU may also be asynchronous notifications e.g. rendering commands regarding state changes in rendering engine and or GPU may be useful to software client . For example software client may use notifications from GPU such as OpenGL fences to perform tasks such as occlusion queries and or management of dynamic data buffers. GPU execution synchronization is described in further detail below with respect to .

In one or more embodiments resource allocation is managed using rendering commands that are specified by software client in command buffer and executed by software service . In particular software client may write a rendering command that specifies the creation and allocation of a particular type of resource e.g. vertex buffer index buffer frame buffer texture buffer etc. using an index e.g. identifier for the resource and a size of the resource. Upon reaching the rendering command software service may allocate space for the resource e.g. on GPU and store a handle for the resource in a resource table under the index specified by software client . Subsequent rendering commands from software client to software service involving the resource may thus be referenced by the resource s index in the resource table. Furthermore because resources may be asynchronously allocated and managed through rendering commands in command buffer delays associated with IPC mechanisms for resource creation may be avoided.

For example software client may write a rendering command into command buffer for the creation of a vertex buffer. Software service may then execute the rendering command by allocating the vertex buffer in GPU through one or more API calls and store the handle for the vertex buffer in the resource table under the index specified in the rendering command. Software client may also write rendering commands into command buffer for clearing reading from and or writing to the vertex buffer by software service using the vertex buffer s index.

Those skilled in the art will appreciate that graphics rendering e.g. 3D graphics rendering may involve the storage and transmission of large amounts of buffer data. For example rendering of a single frame in a 3D computer game may require the storage and transmission of several to tens of megabytes of vertex texture index and or frame buffer data between software client and software service . Such buffer data may be written to command buffer by software client along with commands for processing and or rendering the data. However the buffer data may exceed the allocated size of command buffer and or preclude rendering commands from being stored in command buffer until the buffer data is read from command buffer by software service .

To address the storage limitations of command buffer command buffer interface may include functionality to allocate a shared memory buffer for storing buffer data associated with graphics rendering. Shared memory buffer may include frame vertex texture and or index buffer data to be transmitted from software client to software service . In one or more embodiments shared memory buffer is created by software client during initialization of software client and shared with software service using an IPC mechanism e.g. RPC message passing socket call etc. . In addition software client may create multiple shared memory buffers to organize the allocation of resources and or store rendering data for multiple software clients. Alternatively shared memory buffer may be created by software service during initialization of software service and shared with software client using IPC. The shared nature of shared memory buffer may additionally allow both software client and software service to directly access e.g. read from write to etc. shared memory buffer from their respective address spaces.

To transmit data to software service using shared memory buffer software client may write the data directly to shared memory buffer . Software client may then write a rendering command to command buffer that prompts software service to transfer the data in shared memory buffer to a resource managed by software service . After software service executes the transfer command the data in shared memory buffer may be modified or freed by software client .

For example software client may write several megabytes of vertex buffer data into shared memory buffer . Software client may then write a rendering command into command buffer for transferring the vertex buffer data in shared memory buffer into a vertex buffer managed by software service e.g. stored in a resource table managed by software service . The transfer command may include the offset of the vertex buffer data in shared memory buffer and the index of the vertex buffer in the resource table. To execute the transfer command software service may use the offset of the vertex buffer data to locate the vertex buffer data and the index of the vertex buffer to copy the vertex buffer data to the vertex buffer. After the vertex buffer data is copied software client may modify or free the vertex buffer data from shared memory buffer . For example software client may write more vertex buffer data for copying into the vertex buffer into shared memory buffer or software client may write index buffer data to be copied into an index buffer into shared memory buffer .

In one or more embodiments state changes produced by software service are tracked using a token. Such state changes may involve for example transfer of data in shared memory buffer rendering engine and or GPU . The token may be stored in the address space of software service and updated by software service with a particular identifier e.g. an integer to reflect the completed execution of a rendering command. The identifier may further be provided by software client through a SetToken rendering command written to command buffer . Software client may then obtain the value of the token using a synchronous e.g. socket call with software service . In other words software client may instruct software service to track certain changes in state by executing the SetToken rendering command after executing one or more rendering commands that cause each of the changes in state.

For example software client may write a SetToken rendering command that increments the token after each important rendering command e.g. transfer commands GPU state change commands etc. in command buffer . Upon executing an important rendering command in command buffer software service increments the token to indicate that the important rendering command has been completed. Consequently the token may allow software client to obtain information about multiple state changes e.g. executed rendering commands in a single IPC query to software service rather than repeatedly requesting the value of the get pointer in more frequent IPC queries. More specifically the token may provide another synchronization mechanism between various independently executing components of computing system such as software client software service rendering engine and or GPU .

As mentioned previously software service may operate in conjunction with multiple software clients. Such software clients may include for example web applications graphics libraries and or native code modules. As a result software service may include multiple command buffer interfaces to facilitate secure operation with different types of software clients. For example command buffer interface may include bindings for general purpose languages such as C as well as higher level languages for web applications such as Javascript Javascript is a registered trademark of Sun Microsystems Inc. . Command buffer interface may also allow graphics libraries such as OpenGL and Direct3D to be re implemented as software client . For example command buffer interface may connect an OpenGL software client that communicates with software service to render using a Direct3D rendering engine and vice versa.

Furthermore the independent execution of software service and software client may facilitate safer execution of applications that request GPU resources. In particular the parsing and processing of rendering commands by software service prior to communicating with rendering engine and or GPU may prevent applications that run as software clients from directly accessing GPU portions of memory and or other resources on computing system . As a result the system of may reduce the incidence of system crashes graphics driver bugs file system corruption and or other security related issues. The security and safety of graphics rendering may additionally be increased by executing software client in a native code module as discussed below with respect to .

Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a rich Internet application RIA .

More specifically web application may include graphics rendering capabilities that are typically associated with native applications such as graphics hardware acceleration using GPU . To render graphics using GPU a native code module associated with web application may be used as software client . Like web application native code module may be obtained from one or more servers by web browser . Furthermore native code module may be executed natively within a plugin associated with web browser to provide hardware accelerated graphics rendering capabilities to web application . Alternatively some or all of web application may execute within native code module .

In one or more embodiments plugin includes a variety of mechanisms to ensure the safe execution of native code module . In particular native code module may be validated by a validator provided by plugin prior to execution. Native code module validation is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008 which is incorporated herein by reference.

Once native code module is validated native code module may be loaded into a secure runtime environment provided by plugin . Native code execution in a secure runtime environment is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008 which is incorporated herein by reference.

Furthermore because native code module may include binary code that runs directly on hardware native code module may be platform independent with respect to the operating system of computing system web browser and or other software components on computing system . As described in the above referenced applications plugin and or native code module may also include mechanisms for executing on a variety of instruction set architectures including the use of fat binaries and binary translators.

As shown in native code module communicates directly with GPU through command buffer interface . In other words native code module may write GPU commands and buffer data directly into a hardware command buffer and or shared memory located on GPU . Alternatively native code module may write GPU commands and or buffer data into memory locations that are directly accessible by GPU using function calls provided by command buffer interface e.g. a GPU interface . Consequently the system of provides a mechanism for communication between GPU and web application while ensuring the safe execution of rendering commands using native code module secure runtime environment and or validator .

As shown in plugin includes native code module executing in secure runtime environment . As described above native code module may function as a safely executing software client . As a result native code module may provide a scene graph renderer e.g. scene graph renderer of to web applications that use plugin . Native code module may then communicate with a trusted code module using command buffer interface command buffer and or shared memory . As a result trusted code module may implement the functionality of software service .

In other words native code module may correspond to untrusted code that executes safely within secure runtime environment . However because secure runtime environment may not allow communication with hardware devices such as GPU native code module may use command buffer interface to interact with trusted code module which executes outside secure runtime environment and includes the capability to communicate with GPU . Trusted code module may also use command buffer interface to process rendering commands from native code module and to send the rendering commands to rendering engine and or GPU . Because the majority of plugin may be implemented and executed using native code module plugin may operate in a manner that minimizes the risk of crashes bugs and or security vulnerabilities in computing system .

As shown in command includes a size an identifier and a set of arguments . Size and identifier may be stored on the same element of the command buffer while arguments may each be stored on an element of the command buffer. For example if elements in the command buffer correspond to 32 bit words size may occupy the upper eight bits of an element and identifier may occupy the lower 24 bits of the element. Arguments may also be padded to 32 bits for storage in the command buffer. Alternatively multiple arguments may also be stored on the same element as discussed below with respect to .

Size may represent the total size of command in the number of elements in the command buffer taken up by command . In other words size may correspond to the number of arguments in command incremented by one. As a result if size is stored in the upper eight bits of a 32 bit element command may not exceed 255 elements. Identifier may allow command to be identified and executed by the software service. For example identifier may correspond to an index in a global command table that is managed by the software service. The index may map to a set of function calls that may be made by the software service to a rendering engine or GPU to carry out the functionality of command . Alternatively command may correspond to a resource allocation DMA and or synchronization command that may be completed solely by the software service. Arguments may correspond to the parameters of command .

Command includes a size of 4 e.g. four elements an identifier corresponding to SetVertexSource and five arguments e.g. Index Format Stride Resource Index and Offset . Unlike command command includes three arguments in the same element of the command buffer. For example in a 32 bit word element arguments may each occupy eight bits while argument may occupy 16 bits. Consequently shorter arguments in a command e.g. command may be stored in the same command buffer element of the command buffer. Decoding of commands and arguments may be accomplished by obtaining the encoding scheme of each command by looking up the command s index and or identifier in the global command table.

Rendering commands between get and put e.g. SetTextureBufferData SetToken3 Draw SetFence FinishFence SetToken4 may correspond to commands that are to be executed by the software service while rendering commands not between get and put may correspond to commands that have already been executed by the software service. As a result rendering commands outside of the commands between get and put may be rewritten with new rendering commands by the software client. For example the software client may add two new rendering commands to command buffer by writing the new rendering commands to the elements containing CreateEffect and SetEffect and updating put to point to the location of the CreateEffect command.

Rendering commands in command buffer may also reference a shared memory buffer that is also accessible to the software client and software service. In particular vertex data index data and texture data may be written in bytes to shared memory buffer by the software client. The software client may then write transfer commands to command buffer that reference the data. In particular SetVertexBufferData references vertex data SetIndexBufferData references index data and SetTextureBufferData references texture data . When the software service reaches a transfer command the software service may use the reference e.g. offset and or other arguments e.g. length resource index etc. in the transfer command to locate the relevant data and copy the data to a resource managed by the software service. For example SetVertexBufferData may copy vertex data to a vertex buffer SetIndexBufferData may copy index data to an index buffer and SetTextureBufferData may copy texture data to a texture buffer.

After executing a transfer command in command buffer the software service may set a token indicating completion of the data transfer. For example after executing SetVertexBufferData the software service may execute SetToken1 which may set the token to the value 1. After executing SetIndexBufferData the software service may set the token to the value 2 using the command SetToken2. After executing SetTextureBufferData the software service may set the token to the value 3 using the command SetToken3. The software client may determine the progress of the software service by obtaining the value of the token through an IPC mechanism rather than repeatedly obtaining the value of get .

Command buffer may also include commands for synchronizing the software client and the GPU rendering the image corresponding to the rendering commands. In particular SetFence may correspond to a synchronization command that can be queried for completion of a rendering command by the GPU. For example SetFence may prompt the software service to set an OpenGL fence with the GPU. Similarly FinishFence may not return until the GPU has finished executing the condition specified in SetFence. The software client may also write SetToken4 to command buffer after SetFence as a state change notification indicating that the fence has finished executing. The software client may subsequently receive the state change notification as an updated token value e.g. 4 after the software service executes SetToken4 in command buffer .

Initially a software client and a software service are loaded operation in the computing system. The software client and software service may correspond to independently executing software components of the computing system. In addition loading of the software client and software service may involve creating and sharing a command buffer and or one or more shared memory buffers between the software client and software service. In particular each buffer e.g. command buffer shared memory buffer may be created by either the software client or software service. The buffer may then be provided to the other software component using an IPC mechanism and mapped to both components address spaces. As a result the command buffer and shared memory buffer s may be directly accessed by both the software client and the software service.

Next one or more rendering commands are received from the software client in the command buffer operation . The rendering commands may correspond to state change commands resource allocation commands DMA commands buffer data and or synchronization commands. The rendering commands may be written to the command buffer by the software client to enable asynchronous interaction between the software client and the software service. After the rendering commands are written to the command buffer by the software client a put pointer in the command buffer is updated by the software client. The new value of the put pointer may signal the software service to begin reading rendering commands from the command buffer operation in the order in which the rendering commands were written to the command buffer by the software client.

Each rendering command may then be formatted operation and executed operation by the software service and or a GPU on the computing system. For example the rendering command may be encoded with an identifier that maps to a global command table managed by the software service. The software service may use the global command table to decode the command in the command buffer and obtain a set of function calls to the GPU that implement the functionality of the rendering command. In addition the software service may make the function calls using arguments stored with the rendering command in the command buffer. On the other hand certain rendering commands such as resource allocation commands DMA commands and or state change commands may not require GPU execution and may be carried out by the software service. For example the software service may execute a transfer command by copying data in the shared memory buffer to a resource such as a vertex buffer.

The software client and or software service may continue executing if additional rendering commands are available operation . In particular the software client may continue writing commands to the command buffer operation and updating the put pointer. The software service may concurrently read each rendering command operation format the rendering command operation and execute the rendering command operation . As described above synchronization e.g. IPC mechanisms using a get pointer put pointer and or token may be used to synchronize the execution of the software client and software service. One or more images related to the rendering commands may thus be produced by the combined synchronous and asynchronous interaction of the software client and the software service.

The foregoing descriptions of embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present embodiments to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present embodiments. The scope of the embodiments is defined by the appended claims.

