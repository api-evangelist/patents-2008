---

title: Framework for rendering plug-ins in remote access services
abstract: A framework for and hosting rendering plug-ins in remote access services is disclosed. The framework provides an interface between the core components of the remote access system and the rendering plug-ins. The framework utilizes public APIs to provide the interface between the core components and the rendering plug-ins. Using the APIs, the framework can allow various existing and new rendering plug-ins to interact with the core components of the remote access system, thereby making an extensible system that can support a variety of rendering plug-ins.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07937452&OS=07937452&RS=07937452
owner: Microsoft Corporation
number: 07937452
owner_city: Redmond
owner_country: US
publication_date: 20080219
---
Remote access services can allow a user to access applications and data stored on a remote computing device over a network. Examples of remote access services can be Terminal Services TS which is a component of Microsoft Windows provided by the Microsoft Corporation headquartered at Redmond Wash. In addition a remote access service can allow users to access one or more applications through a desktop associated with the remote computing device such as a server. The desktop can be rendered on the client device by modules such as a rendering module based on rendering information sent by the remote computing device. The rendering information creates a surface on the client device and allows the rendering of the desktop within the surface.

Remote access services can allow exchange of information between the remote computing device and one or more client devices logged onto the remote computing device. Such information may include rendering information from the remote computing device for generating a surface on the client end. The surface can be understood to be a logical memory store or space onto which the graphical output can be displayed at the client devices.

Transmitting the rendering information from the remote computing device to the client device can be achieved by remoting at a primitive command level. This may involve the remote computing device sending primitive command level drawing commands to the client device. Based on the primitive command level drawing commands a graphical result can be generated at the remote client device. One or more rendering plug ins at the server can send the primitive commands and the rendering plug ins at the client devices can render surfaces in accordance with the primitive commands.

New rendering extensions that support graphics interfaces such as GDI WPF and so on are being developed. The number of such extensions is expected to grow significantly as new graphical interfaces become available. In existing TS scenarios there is no uniform and clearly defined model to support new extensions. The complexity and cost of supporting increasing number and types of extensions would therefore increase in the near future.

This summary is provided to introduce concepts relating to a framework for rendering plug ins in remote access scenarios which are further described below in the detailed description. This summary is not intended to identify essential features of the claimed subject matter nor is it intended for use in determining the scope of the claimed subject matter.

In an embodiment a framework provides an interface between core components of a remote access system that includes a server and client and the rendering plug ins on the server and the client. The framework can implement application program interfaces to provide the interface between the core components and the rendering plug ins.

Systems and methods for implementing a framework to support rendering plug ins in remote access services are described. The framework to support rendering plug ins in remote access service can be implemented in a variety of remote access services available on a host of operating systems. The following systems and methods are described with reference to a Microsoft Windows operating system Terminal Services TS system however it will be appreciated that the disclosed framework can be implemented in various other remoting based systems.

Remoting based systems such as those based on a TS system allow a computing device for example a server device or server to host applications for remote access by one or more remote client devices. Remoting of applications involves generating an output associated with the application running on the server device at the client devices. Therefore at the client device or client the generated output simulates the working environment of the server. Users associated with the client devices can utilize the applications hosted on the server device as if they were directly working on the server device.

The output can be generated at the client device based on rendering information sent by the server device. The rendering information can be remoted to the client through rendering extensions interchangeably referred to as rendering plug ins. The rendering extensions can be of a variety of types. Additionally many new extensions may further be developed. It is to be appreciated that the new extensions should be consistent with present remoting based systems allowing ease in maintenance and extensible support.

To this end an extensible framework is described for supporting different types of rendering plug ins in multiple remoting scenarios. Remoting based systems such as those based on TS can support different scenarios namely direct mode and composition mode. Examples of direct mode can be remoting desktop environment without desktop composition and applications remoting techniques such as applications based on RAIL i.e. Remote Application Integrated Locally . Example of composition mode can be remoting desktop environment with desktop composition. In order for an application at the TS server device to function properly in each of the scenarios a rendering plug in should be able to transfer surface information to the TS core components such as surface consumers on both the server device and the client device.

To this end the disclosed framework can provide a consistent way for the surface consumers such as desktop windows manager or DWM window manager and so on to consume surfaces of various types DX GDI rendered by graphics applications. A Surface can be a logical space or memory on which the rendering plug ins produce their graphical result. The rendering plug ins can remote graphical commands at primitive command level and the rendering plug ins at the client can use the graphical commands to produce a graphical result to be consumed by the client consumer.

In composition mode to achieve primitive level remoting the server can remote the DWM composition tree the redirected surface descriptions for which primitive level redirection is supported and graphical command streams used to rasterize the redirected surfaces. In direct mode no composition tree needs to be remoted.

For example in the composition mode when a surface consumer is running on a system graphics applications can produce surfaces through rendering while the surface consumer consumes them to compose the desktop. Different graphics applications can use different rendering extensions to render into surfaces that are then combined by the surface consumer such as DWM to produce the desktop. System redirection state can describe the relationship between the surface consumer the graphics applications and their redirected surfaces. For example in VISTA operating system specialized codes can be distributed in various parts of the system DWM win32k dxgkrnl to implement redirection functions. In DWM specialized codes can handle redirection for all supported surfaces.

In addition the framework can introduce logical surface abstraction that encapsulates the specialized implementations for the surfaces currently supported in the system. The DWM would then redirect system surfaces by use of redirection APIs written to these logical surfaces. The logical surface would encapsulate various types of surfaces GDI or DX and translate the generic surface redirection API s to the various specialized implementations. New surfaces can be added to the system DX without having to changes core components due to the encapsulation.

Presently no standard interface between various types of rendering plug in and the TS core components exists resulting in poor extensibility and inconsistency in implementation of rendering plug ins in a TS system. For example in the composition mode a new rendering plug in cannot be enabled without modifying system core components. Likewise limitations may exist in implementing a new rendering plug in for other scenarios being implemented in systems based on remote access.

The framework aims at abstracting and isolating the core functionality associated with the remoting based systems from the rendering extensions. It may be appreciated that the core functionalities associated with remoting based systems can be realized through a variety of core components. In one implementation the framework may be implemented through one or more Application Programming Interfaces APIs . The rendering plug in can remote primitive commands and generate surface data on the remote client and the core components of the remoting based systems can provide a render target for rendering based on the surface data produced by the rendering plug in. The APIs can provide an interface for the rendering plug ins to communicate with the core components.

Systems based on the framework for supporting different types of rendering plug ins in multiple remoting scenarios can include one or more agents or surface managers. The surface managers can include public APIs that allow the rendering plug ins to interact with the core components.

The network may be a wireless or a wired network or a combination thereof. The network can be a collection of individual networks interconnected with each other and functioning as a single large network e.g. the Internet or an intranet . Examples of such individual networks include but are not limited to Local Area Networks LANs Wide Area Networks WANs and Metropolitan Area Networks MANs .

In the present implementation the server can be accessed by the client through the network using one or more protocols for example a transmission control protocol running over an internet protocol TCP IP . In addition the remote desktop protocol RDP can be used to send commands to the client . The remote desktop protocol can open dynamic virtual channels to send commands to the client .

The server may be any of a variety of servers that use one or more rendering extensions such as server rendering plug ins to remote primitive level drawing commands to the client for generating a surface at the client . The server rendering plug in can be a module that uses GDI WPF and DirectX and so on to send primitive level drawing commands to one or more rendering plug ins at the client .

The server includes a surface manager acting as a middle tier that connects various rendering plug ins with core components such as surface consumers. Surface consumers can utilize the content of surfaces provided by the rendering plug ins to generate render targets at the client. The render target can be a logical memory allocated for a surface. For example the render target can be a window. The surface manager can bind the rendering plug ins and surface consumers such that the surface consumers can access the surface generated by the rendering plug ins and render the surfaces on the render targets. In one implementation the generated surface can be associated with an identifier.

The client can include a surface manager proxy . The surface manager proxy can be a proxy of the surface manager on the server . In one implementation the surface manager proxy can be identical to the surface manager . The surface manager proxy aids the communication between the client rendering plug in and the client surface consumer.

The surface manager and the surface manager proxy can provide logical connections between the rendering plug ins and the TS core components at the server and the client respectively. Therefore new rendering modules when created would be able to communicate with the TS core components utilizing the surface manager and surface manager proxy . The working of the surface manager and the surface manager proxy are further described in detail below in reference to .

The network interface s facilitates communication between the server and the client . Furthermore the network interface s may include one or more ports for connecting the client to the server . The network interface s can facilitate communications within a wide variety of networks such as the network and protocol types including wired networks e.g. LAN cable etc. and wireless networks e.g. WLAN cellular satellite etc. . The server receives an input from a user or the client via the ports connected through the network interface s and the TS server can send back the relevant information to create surface data on the client via the network interface s .

The memory can include any computer readable medium known in the art including for example volatile memory e.g. ram and or non volatile memory e.g. flash etc. .

As illustrated in the memory can also include program s and data . The program s can include the surface manager a server rendering module a server consumer module and other application s . The other application s include one or more programs that may supplement applications on the server . The server rendering module can be a plug in component of a graphics stack on the server.

The data can include server surface data and other data such as data associated with a general functioning of the program s .

The network interface s facilitates communication between the terminal services enabled server and the remote client . Furthermore the network interface s may include one or more ports for connecting the client to the server . The network interface s can facilitate communications within a wide variety of networks such as the network and protocol types including wired networks e.g. LAN cable etc. and wireless networks e.g. WLAN cellular satellite etc. . The server receives an input from a user or the client via the ports connected through the network interface s and the TS server device can send back the relevant information to create a surface on the client via the network interface s .

Memory can include any computer readable medium known in the art including for example volatile memory e.g. RAM and or non volatile memory e.g. flash etc. .

As illustrated in the memory can include program s and data . Program s can include the surface manager proxy a client rendering module a client consumer module and other application s . The other application s include one or more programs that may supplement applications on the client .

Data can include client surface data client rendering data and other data such as data associated with a general functioning of one or more program s .

The application module can be any application hosted by the server which when executed generates a graphical output. Typically in remoting scenarios the graphical output is remoted to the client devices such as client . The execution of the application module at the server may result in a change in the graphical output being generated at the client .

In order to generate the graphical output at the client the server rendering module can send primitive drawing commands to the client rendering module . In one implementation the server rendering module and the client rendering module can be any existing rendering plug in or a new rendering plug in. The server rendering module can utilize standard graphical interfaces and protocols to send primitive drawing commands to the client rendering module . The client rendering module can utilize the same graphical interfaces and protocols to receive the primitive drawing commands to generate surface data that can be utilized by the client core components to render a surface at a pre specified render target. In one implementation the surface data can be stored in the client rendering data .

In one implementation the primitive drawing commands can be commands targeted for each application to a specific render target and surface data that occupies the render target. The primitive drawing commands can be commands such as Graphic Device Interface GDI drawings commands Windows Presentation Foundation WPF drawing commands or such generated by the server rendering module .

In one implementation the server rendering module can open a typed Remote Desktop Protocol RDP pass through pipe and that can allow the server rendering module to emit primitive drawing commands into this pipe. For example the RDP pass through pipe can be a dynamic virtual channel which is a network connection.

The server consumer module can receive surface information from the server rendering module via the surface manager and it can send the surface information regarding the surface and the render target to the client consumer module via the surface manager proxy . The client consumer module can receive the surface information and render the surface generated by the client rendering module at the pre specified render target.

In the case of composition mode the client consumer module can be a DWM plug in i.e. a DWM process that can host remote composition tree of the server consumer module . In the case of direct mode the client consumer module can be a RAIL window manager that manages the RAIL window proxies and child windows on the TS client . In case of remote desktop the client consumer module can be a child window manager that manages the child windows at the TS client output window.

The surface manager can provide an interface between the server rendering module and the server consumer module . The surface manager can allow the server rendering module to send surface information to the surface manager and allow the server rendering module to communicate with the server consumer module . The surface manager can allow the server consumer module to receive surface information from the server rendering module .

In one implementation the server rendering module can call the surface manager for two primary functions. The first function can be to create a logical surface or window. For example the first function may be termed AllocateSurfaceHandle which generates a unique identifier for a surface to be generated at the client . In one implementation the surface manager can store the surface identifier in the server surface data . The unique identifier can be sent to the client rendering module to allocate a real surface to receive the upcoming primitive drawing commands . In addition the unique identifier generated can be used as a key to associate the surface to the surface manager .

The second function of the surface manager may be to track the surface or specify the association between the surface that would be generated by the client rendering module and the render target. Association information can be sent to the client consumer module via the surface manager proxy to allocate a render target for the surface. In addition association information can trigger the association of the server consumer module and the surface manager .

The association information can include information such as an indication of which render target a surface is intended for. The association information can include structural redirection information to correctly create surfaces at the user interface. Examples of the association information include but are not limited to a composition tree window mapping information specifying the positioning of windows the extent of overlap of a plurality of windows border transparency border color border texture button appearances shading light perspectives object rotation information and so on.

In order to provide the interfaces for the server rendering module and the server consumer module the surface manager can have two sets of API s. One set of the APIs can be for the server rendering module and the other set can be for the server consumer module . The rendering module API of the surface manager can allow the server rendering module to create a surface identifier and associate the surface identifier with a render target. The consumer module API of the surface manager can allow the server consumer module to register with the surface manager to receive notifications regarding changes to the surfaces.

On the client side of the framework the surface manager proxy provides an interface for the client rendering module and the client consumer module . The surface manager proxy is a proxy of the surface manager present at the server . In one implementation the surface manager proxy can be identical to the surface manager . The surface manager proxy can be based on a collection of APIs that can provide the interface between the TS core components of the client such as the client consumer module and components that render graphics at the client such as the client rendering module .

The surface manager proxy can allow the rendering module to transfer the surface data to the client consumer module . In addition the surface manager proxy can allow the client consumer module to request for surface data and dirty regions from the client rendering module . The dirty regions can be the invalid part of the surface or the part of the surface that has changed. Dirty region data can be discarded and new surface data for that region may have to be generated.

To this end the surface manager proxy includes APIs. One of the APIs provides an interface that can allow the client rendering module to register a surface with the surface manager proxy and to notify the surface manager proxy of any changes in the surface. Another API of the surface manager proxy can provide an interface that can allow the client consumer module to register with the surface manager proxy to receive notifications regarding any changes in the surface produced by the client rendering module . In addition this interface can allow the client consumer module to retrieve surface data and dirty regions of the surface.

In addition the surface manager proxy can include interfaces that can allow the client consumer module to access the surface data and accumulated dirty region at the client rendering module . The client rendering module manages the access to these surfaces by keeping a list of surfaces indexed by the Surface identifier on the server . Creation and deletion of the surface are controlled by primitive drawing commands from the server rendering module .

At runtime the server rendering module sends a notification e.g. Allocate hSurface to the surface manager to allocate an identifier to the surface to be rendered. Once the identifier has been allocated the server rendering module can send surface information such as a command e.g. CreateRenderTarget hSurface to the client rendering module via the surface manager in order to create a render target and a local surface. On creation of the local surface the client rendering module can send an AddSurface command to the surface manager proxy via an API to add the surface in the list of surfaces maintained by the surface manager proxy . In one implementation the surface manager proxy can store the surface identifier in the client surface data .

In addition the server rendering module can send a command e.g. Associate hSurface hWnd to the surface manager to associate a render target with the surface. The surface manager can make the association and pass the association information forward to the server consumer module . At the client the client consumer module receives association information via the surface manager proxy . The client consumer module can utilize the association information to associate a window node or proxy window with the surface that the client consumer module will receive from the client rendering module . Once the client consumer module receives the association information it can send a command e.g. SurfaceAttach hSurface to the surface manager proxy in order to register with the surface manager proxy to receive any notifications regarding the surface associated to the surface identifier e.g. Surface or render target .

The server rendering module can send rendering commands such as primitive drawing commands to the client rendering module . The client rendering module can receive the primitive drawing commands and generate surface data. The local surface associated with the surface identifier e.g. hSurface can be populated with the surface data generated by the server rendering module . Once the surface data has been generated at the client the client consumer module can receive a notification. Client consumer module can then request the surface manager proxy to forward the surface data and the dirty regions. The client consumer module can receive this surface data and along with the association information it had received from the server consumer module render the surface on to the allocated render target at the user interface.

Framework can be implemented for different types of rendering plug ins in various TS scenarios. The framework described the interface that a rendering plug in uses to make its surface data accessible to the client consumer module . The client consumer module is a different TS core component in each of the TS scenarios. The implementation of the framework in the direct mode and the composition mode is described below in detail.

In this scenario the TS server consumer module and the client consumer module can be a desktop window manager DWM compositor. The DWM compositor maintains a composition tree which keeps track of window nodes that represent the windows and their properties in the system. Each window node can have one or more resources that can be redirection surfaces. The DWM compositor can compose the desktop scene by using the redirection surfaces attached to its composition tree .

The server consumer module can remote association information such as a DWM composition tree to the TS client and the composition tree can be hosted by the client consumer module For example the composition tree can be remoted to the client using MIL protocol. In composition mode the surface manager proxy is required for the client rendering module to bind to the redirection surface that can be consumed by the DWM compositor. For the framework to function properly a few modules have to be added at the client in order to render the surfaces.

Remoting GDI surface in composition mode uses most of the frame work described in except the dirty region notification. The dirty region notification can be implemented as a special command such as DirtySprite which can be replaced with the surface manager APIs described in . Minimal changes may be required in the client rendering module to introduce the framework in the remote desktop with desktop composition environment.

Remoting of WPF applications is currently handled within Milcore which is an unmanaged composition engine part of the DWM composition module. A WPF hosting rendering plug in can be introduced in the TS client . The WPF hosting rendering plug in can create and own the surface composed from the remoted composition tree of the WPF application on the server and the surface of its leaf nodes.

Remoting of DirectX applications is not supported by composition mode at present. To add the support in the framework the DirectX client rendering module can be added to create surfaces and notify the surface manager proxy API of the changes in the surface.

In direct mode such as RAIL and Remote Desktop without desktop composition the render target can be a window. The rendering plug ins can directly produce their graphical result to a proxy window created on the client . The surface manager can be relatively simpler in direct mode as it does not need to manage any redirection surfaces and the consumer module does not require a surface compositor. Enabling various rendering plug ins in direct mode using the same framework and surface manager APIs may be implemented. For example in RAIL the server consumer module and the client consumer module can be the RAIL window manager. The RAIL window manager can manage RAIL windows which are top level windows. The surface manager proxy can create and manage child windows that can be the render target of RAIL windows. A RAIL surface manager may be added to the server to handle the association information on the server . Therefore the surface manager can be added to the TS RAIL server . The server consumer module can track render target windows in the server and remote them to the client consumer module on the RAIL client .

In addition the surface manager proxy can be added to the RAIL client to manage the render target windows. The client consumer module such as the window manger can receive rendering target window tracking information and create proxy windows and child windows on the client

In remote desktop without desktop composition the surface manager and the surface manager proxy can be added to implement the framework . The server rendering module and client rendering module may have to provide support for window tracking and synchronization between the client and the server . On the server side the surface manager can track the render target windows such that the surface manager proxy on the client can create corresponding proxy windows.

The surface manager could have three main functions. First when the server rendering module asks a surface identifier to be allocated the surface manager can return a NULL value. Second the surface manager can track the window to be rendered at the client . Third the surface manager can decide when to stop tracking the window in case the window has been terminated due to some user input.

The client rendering module can call the API of the surface manager proxy at the client and the surface manager proxy can make decisions regarding whether the client rendering module should provide a surface for consumption or render to a window directly.

At block an identifier can be associated with a surface created at the server. In one implementation the server rendering module can call the surface manager through the rendering module API of the surface manager and request the surface manager to allocate the identifier e.g. hSurface to the surface. For example the server rendering module can send a command e.g. AllocateSurfaceHandle to the surface manager . The surface manager can allocate the identifier e.g. hSurface and store this value in the server surface data .

At block a command can be sent to the client to create a surface based on the identifier associated with the surface. In one implementation the surface manager can send the command to the surface manager proxy for creating the surface in association with the surface identifier at the client . This command can be surface type specific such as device independent bitmap Dx shared surface and so on. For example the command can be CreateRenderTarget hSurface .

At block a surface is created at the client associated with the surface identifier allocated at the server . The surface created at the client can be associated with the identifier provided by the surface manager . In one implementation the surface manager proxy can create the surface and add the surface identifier to the surface list maintained at the surface manager proxy . The surface manager proxy can add the identifier e.g. hSurface to the list of surface identifiers maintained or active at the user interface. In one implementation the surface manager proxy can store the surface identifier in the client surface data . For example the client rendering module can send an AddSurface command to the surface manager proxy using one of the surface manager proxy API.

At block the surface can be associated with a render target. In one implementation the server rendering module can send an association call e.g. Associate hSurface hWnd to the surface manager . The surface manager can then associate the allocated surface identifier with a render target. The server consumer module can use the association information . In one implementation the association information associated with the association of the surface identifier with the render target can be composition tree or window mapping information.

At block the information regarding the association of the surface identifier with the render target can be sent to the client . The association information can be sent by the sever composition module to the client consumer module via a network such as the network . In one implementation the association information can be sent in the form of composition tree or window mapping information. The client consumer module can create a proxy for the render target on the server i.e. the proxy is either a window node in the remoted DWM tree or a proxy window in direct mode .

Once the client consumer module has allocated a render target the client consumer module can register with the surface manager proxy to receive notifications regarding any changes in the surface associated with the identifier. In one implementation the client consumer module can send a SurfaceAttach hSurface command to the surface manager proxy via the ITSSurfaceManagerProxyConsumer API to register with the surface manager proxy to receive notifications related to the surface identifier it provided to the surface manager proxy .

At block rendering commands can be sent to the client . For example the server rendering module can send the rendering commands such as primitive drawing commands to the client rendering module . The rendering commands can be sent using any standard protocols such as GDI WPF DirectX and so on. The primitive drawing commands can instruct the client rendering module to render the surface data as per the commands.

At block the surface data can be made available to the client consumer module . For example the client consumer module can request the surface manager proxy to provide the surface data such as GetSurfaceData hSurface via the ITSSurfaceManagerProxyConsumer API. The surface manager proxy in turn can send a command GetSurfaceData to the client rendering module via the ITSHostedRendererSurfaceManager API requesting the client rendering module to send the surface data. The client rendering module can then send the bitmap of the surface data to the client consumer module via the surface manager proxy . In one implementation the client rendering module can store the surface data in the client rendering data .

In one implementation the client consumer module can request the surface manager proxy to provide any dirty regions or to inform the client consumer module in case any changes have occurred in the surface. For example the client consumer module can send a command GetDirtyRegion hSurface to the surface manager proxy via the ITSSurfaceManagerProxyConsumer API. The surface manager proxy can send a command to the client rendering module via the ITSHostedRendererSurface to provide dirty regions and the rendering module can comply and send dirty regions to the surface manager proxy.

At block rendering at the render target in association with the association information and the surface data can take place. In one implementation the client consumer module can render the surface data on the associated render target. The association information informs the client consumer module on which render target the composition module is supposed to render the surface data.

In one implementation the client consumer module can render various surfaces in case a number of applications are active. The client consumer module can render the surfaces correctly using information regarding the position of render targets the extent of overlap of windows border transparency border color border texture shading and so on.

Computer environment includes a general purpose computing based device in the form of a computer . Computer can be for example a desktop computer a handheld computer a notebook or laptop computer a server computer a game console and so on. The components of computer can include but are not limited to one or more processors or processing units a system memory and a system bus that couples various system components including the processor to the system memory .

The system bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example such architectures can include an Industry Standard Architecture ISA bus a Micro Channel Architecture MCA bus an Enhanced ISA EISA bus a Video Electronics Standards Association VESA local bus and a Peripheral Component Interconnects PCI bus also known as a Mezzanine bus.

Computer typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer and includes both volatile and non volatile media removable and non removable media.

The system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM is illustrated. RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by the processing unit .

Computer may also include other removable non removable volatile non volatile computer storage media. By way of example illustrates a hard disk drive for reading from and writing to a non removable non volatile magnetic media not shown . furthermore illustrates a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk additionally illustrates an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . Alternately the hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by one or more interfaces not shown .

The disk drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computer . Although the example illustrates a hard disk a removable magnetic disk and a removable optical disk it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electrically erasable programmable read only memory EEPROM and the like can also be utilized to implement the exemplary computing system and environment.

Any number of program modules can be stored on the hard disk magnetic disk optical disk ROM and or RAM including by way of example an operating system one or more applications other program modules and program data . Each of such operating system one or more applications other program modules and program data or some combination thereof may implement all or part of the resident components that support the distributed file system.

A user can enter commands and information into computer via input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad satellite dish serial port scanner and or the like. These and other input devices are connected to the processing unit via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the monitor other output peripheral devices can include components such as speakers not shown and a printer which can be connected to computer via the input output interfaces .

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computing based device . By way of example the remote computing based device can be a personal computer portable computer a server a router a network computer a peer device or other common network node and the like. The remote computing based device is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .

Logical connections between computer and the remote computer are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When implemented in a LAN networking environment the computer is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the wide network . The modem which can be internal or external to computer can be connected to the system bus via the input output interfaces or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link s between the computers and can be employed.

In a networked environment such as that illustrated with computing environment program modules depicted relative to the computer or portions thereof may be stored in a remote memory storage device. By way of example remote applications reside on a memory device of remote computer . For purposes of illustration applications and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computing based device and are executed by the data processor s of the computer.

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that performs particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

Alternately portions of the framework may be implemented in hardware or a combination of hardware software and or firmware. For example one or more application specific integrated circuits ASICs or programmable logic devices PLDs could be designed or programmed to implement one or more portions of the framework.

Although embodiments for implementing a framework for rendering plug ins in remote access services have been described in language specific to structural features and or methods it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather the specific features and methods are disclosed as exemplary implementations for implementing the framework for rendering plug ins in remote access services.

