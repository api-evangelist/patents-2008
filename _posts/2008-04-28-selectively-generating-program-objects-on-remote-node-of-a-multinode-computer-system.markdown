---

title: Selectively generating program objects on remote node of a multi-node computer system
abstract: Embodiments of the invention enable application programs running across multiple compute nodes of a highly-parallel system to selectively migrate objects from one node to another. For example, when an object becomes too large, a node containing the object may migrate the object to another node, thereby freeing memory space. Whether a large object is migrated can be dependent on how frequently the object is used by the application. Because the memory used by such an object is freed for other uses by the application, overall application performance may be improved. On large parallel systems with thousands of compute nodes, even relatively small improvements in application performance an individual compute node may be magnified many times, resulting in dramatic improvements in overall application performance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08209299&OS=08209299&RS=08209299
owner: International Business Machines Corporation
number: 08209299
owner_city: Armonk
owner_country: US
publication_date: 20080428
---
Embodiments of the invention relate to improving the efficiency of multi node computing systems. More specifically embodiments of the invention may be configured to improve memory use on a multi node computing system by selectively migrating program objects among compute nodes of such a system.

Powerful computers may be designed as highly parallel systems where the processing activity of thousands of processors CPUs is coordinated to perform computing tasks. These systems are highly useful for a broad variety of applications including financial modeling hydrodynamics quantum chemistry astronomy weather modeling and prediction geological modeling prime number factoring and image processing e.g. CGI animations and rendering to name but a few examples.

For example one family of parallel computing systems has been and continues to be developed by International Business Machines IBM under the name Blue Gene . The Blue Gene L architecture provides a scalable parallel computer that may be configured with a maximum of 65 536 2 compute nodes. Each compute node includes a single application specific integrated circuit ASIC with 2 CPU s and memory. The Blue Gene L architecture has been successful and on Oct. 27 2005 IBM announced that a Blue Gene L system had reached an operational speed of 280.6 teraflops 280.6 trillion floating point operations per second making it the fastest computer in the world at that time. Further as of June 2005 Blue Gene L installations at various sites world wide were among five out of the ten top most powerful computers in the world.

The compute nodes in a parallel system typically communicate with one another over multiple communication networks. For example the compute nodes of a Blue Gene L system are interconnected using five specialized networks. The primary communication strategy for the Blue Gene L system is message passing over a torus network i.e. a set of point to point links between pairs of nodes . The torus network allows application programs developed for parallel processing systems to use high level interfaces such as Message Passing Interface MPI and Aggregate Remote Memory Copy Interface ARMCI to perform computing tasks and distribute data among a set of compute nodes. Of course other message passing interfaces have been and are being developed. Additionally the Blue Gene L includes both a collective network and a global interrupt network. Further certain nodes are also connected to a gigabit Ethernet. These nodes are typically used to perform I O operations between the Blue Gene core and an external entity such as a file server. Other massively parallel architectures also use multiple independent networks to connect compute nodes to one another.

One embodiment of the invention provides a method for creating objects in a multi node computing system. The method may generally include monitoring an application being executed on a plurality of compute nodes of the multi node system to generate a performance profile for one or more objects instantiated by the application during execution of the application. Each performance profile indicates performance characteristics for instances of a respective object type. The method may further include detecting that the application program being executed by a first compute node of the multi node system is going to instantiate a first object of a first object type and evaluating the performance profile corresponding to the first object type. Based on the evaluation a request by the application program to create an instance of the first object on the first compute node may be intercepted. Once intercepted the request may be directed to a second compute node and an instance of the first object may be created on the second compute node.

Another embodiment of the invention includes a computer readable storage medium containing a program which when executed by a processor performs operations for creating objects on a multi node system. The operations may generally include monitoring an application being executed on a plurality of compute nodes of the multi node system to generate a performance profile for one or more objects instantiated by the application during execution of the application. Each performance profile indicates performance characteristics for instances of a respective object type. The operations may further include detecting that the application program being executed by a first compute node of the multi node system is going to instantiate a first object of a first object type and evaluating the performance profile corresponding to the first object type. Based on the evaluation a request by the application program to create an instance of the first object on the first compute node may be intercepted. Once intercepted the request may be directed to a second compute node and an instance of the first object may be created on the second compute node.

Still another embodiment of the invention includes a parallel computing system. The parallel computing system may generally include at least one storage node having a processor and memory dedicated to storing objects instantiated by an application program and a plurality of compute nodes each having a processor and memory configured to execute the application program and a program configured for creating objects on a multi node system. The program may be configured for performing the steps of monitoring an application being executed on the plurality of compute nodes to generate a performance profile for one or more objects instantiated by the application during execution of the application. Each performance profile indicates performance characteristics for instances of a respective object type. The program may be further configured for detecting that the application program being executed by a first node of the plurality of compute nodes is going to instantiate a first object of a first object type and evaluating the performance profile corresponding to the first object type. Based on the evaluation a request by the application program to create an instance of the first object on the first compute node may be intercepted. Once intercepted the request may be directed to a second compute node and an instance of the first object may be created on the second compute node.

Embodiments of the invention enable application programs running across multiple compute nodes of a highly parallel system to selectively migrate objects from one node to another. For example an application running on one node may instantiate numerous objects and migrate some to another node. As is known an object provides a programmatic structure used to encapsulate a set of data and operations on that data. Sophisticated computer programs may be configured as a collection of objects that communicate with one another to perform a computational task. Each object consumes a portion of memory on the node on which it was created. Thus the more objects created by a node the less memory remains available.

In one embodiment when an object becomes too large as determined from an analysis of historical application performance or predefined size limits the node may migrate the object to another node thereby freeing memory space. Whether a large object is migrated may depend on how frequently the object is used i.e. how frequently methods of the object are invoked by the application. For example it may make sense to migrate a large but infrequently used object created by an application. Conversely if such an object were frequently used by the application it may not make sense to migrate it to another node. Because the memory used by such an object is freed for other uses by the application overall application performance may be improved. Although some additional overhead is incurred when methods of the migrated object are invoked it may be more than compensated for by an overall improvement in application performance. On large parallel systems with thousands of compute nodes even relatively small improvements in application performance an individual compute node may be magnified many times resulting in dramatic improvements in overall application performance.

Further when an object is to be instantiated a node may determine that the object is likely to consume a large amount of computing resources on that node. For example the method to instantiate the object typically referred to as a constructor may itself be time consuming or taxing to resources of that node. Accordingly in one embodiment the node may cause the object to be created on a remote node especially where the creation process may be performed asynchronously to other program operations. Doing so allows a node to intelligently trade off between consuming local memory for an object and the usefulness of having the object on a remote node.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore in various embodiments the invention provides numerous advantages over the prior art. However although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim s . Likewise reference to the invention shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim s .

One embodiment of the invention is implemented as a program product for use with a computer system. The program s of the program product defines functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive on which information is permanently stored ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Other media include communications media through which information is conveyed to a computer such as through a computer or telephone network including wireless communications networks. The latter embodiment specifically includes transmitting information to from the Internet and other networks. Such communications media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Broadly computer readable storage media and communications media may be referred to herein as computer readable media.

In general the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application component program module object or sequence of instructions. The computer program of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

As shown computer system includes a compute core having a plurality of compute nodes arranged in a regular array or matrix. Compute nodes perform the useful work performed by system . The operation of computer system including compute core may be controlled by service node . Various additional processors in front end nodes may perform auxiliary data processing functions and file servers provide an interface to data storage devices such as disk based storage A B or other I O operations. Functional network provides the primary data communication path among compute core and other system components. For example data stored in storage devices attached to file servers is loaded and stored to other system components through functional network .

Also as shown compute core includes I O nodes A C and compute nodes A I. Compute nodes provide the processing capacity of parallel system and are configured to execute applications written for parallel processing. I O nodes handle I O operations on behalf of compute nodes . For example the I O node may retrieve data from file servers requested by one of compute nodes . Each I O node may include a processor and interface hardware that handles I O operations for a set of N compute nodes the I O node and its respective set of N compute nodes are referred to as a Pset. Compute core contains M Psets A C each including a single I O node and N compute nodes for a total of M N compute nodes . The product M N can be very large. For example in one implementation M 1024 1K and N 64 for a total of 64K compute nodes.

In general application programming code and other data input required by compute core to execute user applications as well as data output produced by the compute core is communicated over functional network . The compute nodes within a Pset communicate with the corresponding I O node over a corresponding local I O tree network A C. The I O nodes in turn are connected to functional network over which they communicate with I O devices attached to file servers or with other system components. Thus the local I O tree networks may be viewed logically as extensions of functional network and like functional network are used for data I O although they are physically separated from functional network .

Service node may be configured to direct the operation of the compute nodes in compute core . In one embodiment service node is a computer system that includes a processor or processors internal memory and local storage . An attached console i.e. a keyboard mouse and display may be used by a system administrator or similar person to initialize computing jobs on compute core . Service node may also include an internal database which maintains state information for the compute nodes in core and an application which may be configured to among other things control the allocation of hardware in compute core direct the loading of data on compute nodes migrate process running on one of compute nodes to another one of compute nodes and perform diagnostic and maintenance functions. Illustratively memory also includes a control system . In embodiments of the invention Control system may be a software application configured to control the allocation of compute nodes in compute core direct the loading of application and data on compute nodes and perform diagnostic and maintenance functions among other things.

In one embodiment service node communicates control and state information with the nodes of compute core over control system network . Network is coupled to a set of hardware controllers A C. Each hardware controller communicates with the nodes of a respective Pset over a corresponding local hardware control network A C. The hardware controllers and local hardware control networks are logically an extension of control system network although physically separate. In one embodiment control system network may include a JTAG Joint Test Action Group network configured to provide a hardware monitoring facility. As is known JTAG is a standard for providing external test access to integrated circuits serially via a four or five pin external interface. The JTAG standard has been adopted as an IEEE standard. Within a Blue Gene system the JTAG network may be used to send performance counter data to service node in real time. That is while an application is running on compute core network performance and or network state data may be gathered and transmitted to service node without affecting the performance of that application.

In addition to service node front end nodes provide computer systems used to perform auxiliary functions which for efficiency or otherwise are best performed outside compute core . Functions which involve substantial I O operations are generally performed in the front end nodes . For example interactive data input application code editing or other user interface functions are generally handled by front end nodes as is application code compilation. Front end nodes are also connected to functional network and may communicate with file servers .

As stated in a massively parallel computer system compute nodes may be logically arranged in a three dimensional torus where each compute node may be identified using an x y and z coordinate.

As used herein the term torus includes any regular pattern of nodes and inter nodal data communications paths in more than one dimension such that each node has a defined set of neighbors and for any given node it is possible to determine the set of neighbors of that node. A neighbor of a given node is any node which is linked to the given node by a direct inter nodal data communications path. That is a path which does not have to traverse another node. The compute nodes may be linked in a three dimensional torus as shown in but may also be configured to have more or fewer dimensions. Also it is not necessarily the case that a given node s neighbors are the physically closest nodes to the given node although it is generally desirable to arrange the nodes in such a manner insofar as possible.

In one embodiment the compute nodes in any one of the x y or z dimensions form a torus in that dimension because the point to point communication links logically wrap around. For example this is represented in by links D E and F which wrap around from compute node to other end of compute core in each of the x y and z dimensions. Thus although node appears to be at a corner of the torus node to node links A F link node to nodes and in the x y and Z dimensions of torus .

As described functional network may service many I O nodes and each I O node is shared by a group of compute nodes i.e. a Pset . Thus it is apparent that the I O resources of parallel system are relatively sparse when compared to computing resources. Although it is a general purpose computing machine parallel system is designed for maximum efficiency in applications which are computationally intense.

As shown in memory stores an operating system image . Operating system image provides a copy of a simplified function operating system running on compute node referred to as a compute node kernel. The compute node kernel provides a minimal set of functions required to support operation of the compute node . In one embodiment a virtual machine may also reside within memory . The virtual machine running on computer node may be configured to execute applications created for the virtual machine . For example the virtual machine may be an implementation of a Java virtual machine and operating environment available from Sun Microsystems Inc.

Furthermore a copy of the virtual machine may be present and executing on thousands of compute nodes where in one embodiment each compute node executes the same application but maintains application data local to a given compute node . In another embodiment some compute nodes may execute a different application or simply remain idle. Further applications running on the compute nodes may be configured to share and transfer application data using well known message passing techniques e.g. MPI or ARMCI .

Illustratively virtual machine is shown executing application . In the case of a Java based virtual machine application may be written using a programming language and compiler configured to generate bytecode for the particular virtual machine . In turn the virtual machine may execute application by generating native instructions from the bytecode. The native instructions may then be executed by one or more processor cores A and B.

While executing the application may instantiate objects by dynamically allocating memory. For example the Java programming language provides the new operator used to create an object and allocate memory at runtime for that object. Other programming languages provide similar constructs.

As illustrated virtual machine may also include an object tracker and object history . In one embodiment the object tracker monitors and evaluates the objects to determine characteristics of the objects . For example as described in greater detail below metrics such as object size complexity creation time access frequency and the like may be tracked by object tracker . Subsequently the object tracker stores information indicative of the characteristics of objects in the object history . Thus over time object history provides a profile of object behavior on a given node.

In one embodiment the object tracker may have a size tracking thread that monitors the size of locally stored objects . Once the size of an object is determined the actual size of the object may be stored in the object history . Further the size of an object can change during execution of the application . Therefore the object history may be updated every time the size changes. In another embodiment the object history may be updated periodically. In yet another embodiment the object history may be updated once the size of the object reaches or exceeds a certain threshold. The threshold may be user defined or be provided by the virtual machine . In any case once this threshold is met it may be determined that the object is large. Accordingly the object history may be updated to contain information that simply indicates that the object is large rather than the actual size of the object .

In one embodiment object tracker may also have an access tracking thread that monitors how frequently the locally stored objects are accessed. The access tracking thread may measure the amount of accesses over a given period of time. If the number of accesses during the given period of time is below a certain threshold the thread may determine that the object is infrequently used. Subsequently the access tracking thread may update the object history with information indicating that the object is infrequently used.

The object history may also store information obtained from generating a profile during execution of application . For example when an object is created or about to be created on a compute node a profiler e.g. object tracker may determine characteristics of that object. Once the characteristics are determined they may be stored in the object history . In one embodiment a profile of a given object type may be updated every time an object of that type is created. In another embodiment to reduce computing overhead such as processing time and memory space a profile may be updated only when the object is first created. Furthermore while embodiments of the invention may allow profiling of every object instantiated by the application overhead may be reduced by not profiling objects having known characteristics i.e. immutable objects which do not change during execution.

In one embodiment a technique known as code instrumentation may be used to profile the application . When using code instrumentation a developer may insert special sequences of code in selected areas in the application . For example to determine the creation time for an object the developer may insert a small piece of start code that starts a clock or timer before the creation of a new object. The developer may then also insert a similar piece of stop code that stops the clock or timer immediately after the object is created. In such a case the creation time for the object is the value of the timer after it has been stopped.

Other profiling and code instrumentation techniques known in the art may be used to determine other characteristics of an object. For example certain objects may have complex initialization procedures that may require a substantial amount of memory and processing from the CPU S A B. The profiler may be able to measure the amount of memory and CPU usage required to create the object. If the memory and or CPU usage needed to construct the object is above a certain threshold the profiler may update the object history with information indicating that the object is expensive to construct. 

Moreover a profile of the lifespan of an object may also be obtained using profiling and code instrumentation techniques described above. For example a profile may measure the length of time in which one of the objects is used or accessed . If the length of time is below a certain threshold the profiler may update the object history with information indicating that the object is short lived. 

It may be determined that objects may have more than one of the above mentioned characteristics collectively providing a profile of each given object. For example one of the objects may be identified as having characteristics such as large and infrequently used expensive to construct and infrequently used large and short lived etc.

As stated above a copy of virtual machine may be present and executing on thousands of compute nodes . In one embodiment each virtual machine may utilize a respective object tracker and object history to manage the memory usage of the application running on that compute node. For example to conserve memory space on compute node i.e. a local node the virtual machine may migrate a large and infrequently accessed object to another node i.e. a remote node .

In one embodiment once an object has been migrated a trap mechanism may be used to manage requests to invoke methods of that object. The trap mechanism may be implemented using code instrumentation techniques known in the art. For example a developer may insert a sequence of code that migrates the object back to the local node before invoking a method of that object. However migrating objects back to the local node incurs additional overhead in the compute node . Therefore in an alternative embodiment the instrumentation may instead generate a remote procedure call to the remote node storing the migrated object. For example Remote Method Invocation RMI Application Programming Interfaces API s provided by the Java programming language may be used. Other programming languages provide similar constructs.

In such a case the migrated object remains in the remote node thereby reducing any overhead from migrating the object back to the local node. However if the migrated object is accessed frequently compute node may still suffer significant overhead from generating numerous remote procedure calls. Therefore the virtual machine may migrate large objects that are also infrequently used. Consequently in such a case the local node conserves memory space and also minimizes the performance impact of executing remote procedure calls.

Further the virtual machine may also migrate objects that are large and short lived. Migrated short lived objects have a limited number of remote procedure calls to them because they exist for a small amount of time. Therefore migrating objects that are large and short lived may also conserve memory and minimize the performance impact of executing remote procedure calls.

Another type of object that may be migrated to a remote node is an immutable i.e. static object. An immutable object is one with data that does not change after object construction. For example the Java programming language provides classes such as String BigDecimal BigInteger as immutable objects. Other programming languages provide similar constructs. Typically once an immutable object is allocated in memory the memory is not de allocated until the application finishes executing. Therefore the memory consumed by the immutable object never becomes available for creating additional objects. In other words the amount of available memory space for creating additional objects is reduced directly by an amount equal to the size of each immutable object created by an application. Creating large immutable objects simply magnifies this problem. Therefore in one embodiment large immutable objects created locally may be migrated to a remote node.

Another characteristic of an immutable object is that multiple nodes may share and access the same immutable object without concern for data corruption because data inside an immutable object does not change. In one embodiment any one of thousands of compute nodes may access an immutable object stored in a local node. As a result the local node may suffer a significant performance impact by servicing thousands of requests. Therefore in one embodiment a large or simply frequently accessed immutable object may be migrated to a remote node dedicated to performing this activity.

In another embodiment the virtual machine may also be configured to create objects in particular large and infrequently used large and short lived and immutable objects directly on a remote node. That is the virtual machine does not instantiate the object locally. In such a case the virtual machine may examine the object history related to an object scheduled to be created. Using the object history the virtual machine may determine that creating the scheduled object may consume a large amount of memory and computing resources. As a result the virtual machine may send a message requesting that the object be instantiated directly on a remote node thereby reducing any performance impact suffered by first creating the object locally and then subsequently migrating the object to the remote node.

For example a virtual machine running on a compute node may determine that an object scheduled for creation is expensive to construct based on a historical performance profile of previous instances of this object. To avoid the performance impact suffered by creating an object of this type the virtual machine may cause instances of the object to be created on a remote node. In another embodiment instances of objects having known characteristics i.e. immutable static objects may also be directly created on a remote node.

In one embodiment object migration across the system may be managed by a memory manager application. For example illustrates a group of one or more compute nodes similar to the compute node illustrated in configured as a memory manager for system . As shown in compute node is shown executing a memory manager program .

In one embodiment the memory manager program may maintain a record of objects created by applications running on the compute nodes of the system . Furthermore the memory manager program may monitor the characteristics of those objects. In one embodiment the memory manager program may periodically communicate with the virtual machines running on compute nodes using well known message passing techniques such as MPI or ARMCI to track the objects created in the system . In another embodiment each virtual machine in the system may notify the memory manager program that a new object has been created.

As shown compute node may also include an object tracker an object history and an object distributor . In this embodiment the object tracker may be configured to monitor and evaluate objects located in thousands of compute nodes instead of a single compute node as illustrated in . Accordingly the object history stores characteristics related to objects created on other compute nodes of computer system .

For example a size tracking thread of object tracker may periodically communicate with virtual machines executing in the system to inquire about the size of the objects created on the compute nodes . Alternatively the virtual machine on a given compute node may provide the access tracking thread with relevant information when an object is accessed by an application running on that compute node. The object distributor may use this information to determine using techniques discussed above which objects to migrate from one compute node to another. Upon making this determination the memory manager program may instruct a virtual machine running an application with an object ready for migration to migrate the that object to another node.

According to an embodiment the memory manager program may also have the functionality to consolidate multiple copies of certain objects into one object. For example consider an immutable object locally created on a compute node having the same characteristics i.e. size data type etc. as another immutable object created locally on another compute node . As stated earlier immutable objects may be shared between different nodes. Therefore having multiple copies of the same immutable object is redundant and can therefore be a waste of memory space.

Thus the memory manager program may consolidate copies of such immutable objects into a single copy. For example in one embodiment the memory manager program may search its record of objects to locate immutable objects having the same characteristics i.e. identical immutable objects . Once located the memory manager program may instruct a virtual machine running on a compute node having a copy of the immutable object to migrate the immutable objects to a remote node. Thereafter the memory manager program may also instruct that virtual machine to de allocate the immutable object from local memory. Moreover the memory manager program may also instruct other virtual machines running on compute nodes having a copy of the immutable object to de allocate their copies as well. Consequently all the compute nodes originally having a copy of the identical immutable object may now access that object located at the remote node i.e. via remote procedure calls .

Example operations for object creation and migration are further discussed in reference to . illustrates a method to manage memory across a plurality of compute nodes according to one embodiment of the invention. As shown the method begins at step where the virtual machine detects that an application is about to instantiate a new object e.g. using the new operator . Next the virtual machine may determine if the object meets the criteria for creation on a remote node. For example at step the virtual machine may determine that the object about to be created is large and immutable i.e. static . If so the operations proceed to step where the object is created on a remote node. Thereafter method returns to step where another object is evaluated. In one embodiment a large immutable object may first be created on a local node and subsequently migrated to a remote node.

At step if it is determined that the object is not large and immutable the operations proceed to step . At step the virtual machine determines if the object meets other criteria for creating the object on a remote node e.g. by evaluating the object history . If the object history indicates that the object is either expensive to build at step or large and short lived at step the operations proceed to step . As stated earlier at step the object is created on a remote node. However if the object history does not indicate the object is either expensive to construct or large and short lived the object is created on the compute node at step .

At step once an object is created locally the object tracker may track the size and usage of that object. For example the object tracker may be configured to monitor each time a method of that object is invoked by the application. Similarly the object tracker may monitor metrics such as object size frequency of method invocation and the like. At step it may be determined that the object has satisfied criteria for migration. If so at step the object may be migrated to a remote node. Alternatively if the object does not satisfy criteria for migration the method returns to step where the object tracker continues to track objects instantiated by the application. further illustrates an example of operations performed by the object tracker .

More specifically illustrates a method to track the size and number of accesses of a given object instantiated by a compute node of a parallel computing system according to one embodiment of the invention. As shown method begins at step where the size of a given object is tracked by the size tracking thread of the object tracker . At step if it is determined that the size of the object exceeds a size threshold the operations proceed to step . If however the size of the object is below the size threshold then the size tracking thread continues to track the size of the object at step .

Otherwise at step the object is tracked by the access tracking thread of the object tracker . If at step it is determined that the object is not frequently accessed i.e. is infrequently used the operations proceed to step . If however it is determined that the object is frequently accessed the access tracking thread continues to track the number of accesses to the object at step .

It may now be determined whether the object is both large and infrequently used which in one embodiment may be the criteria for migrating the object to a remote node for reasons discussed above . In one embodiment once a object satisfies the criteria for migration the object tracker may stop tracking the object to reduce overhead in the compute node caused by the tracking at step .

At step the object may be migrated to a remote node. In one embodiment the remote node may perform size tracking on the object using a respective object tracker stored on that compute node. If the size of the object decreases below the size threshold as illustrated at step the object may be migrated back to the local node. In another embodiment before migrating an object to a remote node the virtual machine located on the local node may communicate with the remote node to determine whether the remote node has enough memory space available for the object. If the remote node has enough memory space available the object may be migrated to that remote node. Otherwise if the remote node does not have enough memory space the local node may attempt to migrate the object to another remote node.

Alternatively however at step the local node may access the object on the remote node e.g. via remote procedure calls. At step the remote node may track the number of remote procedure calls received for a particular object using the object tracker executing on the remote node. If at step it is determined that the object is not frequently accessed i.e. infrequently used the operations return to step where the object continues to be tracked. If however it is determined that the object is frequently accessed than at step the remote node may migrate the object back to the local node. Consequently at step the object may be accessed directly by the local node. Once the object is returned to the local node the local node may recommence the tracking process on the object starting at step of .

Advantageously as described herein embodiments of the invention enable application programs running across multiple compute nodes of a highly parallel system to selectively migrate objects from one node to another. For example an application running a given compute one node may instantiate numerous objects and migrate some to another node. Doing so may free memory space on that node for other uses improving system performance particularly where large and infrequently used objects are migrated. Further in one embodiment upon detecting that an application is about to instantiate a object a compute node may determine that creating the object may consume a sufficiently large amount of computing resources to justify creating the object on a remote node. Doing so allows a node to intelligently trade off between locally consuming memory for a object on the node and the usefulness of having the object on a remote node.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

