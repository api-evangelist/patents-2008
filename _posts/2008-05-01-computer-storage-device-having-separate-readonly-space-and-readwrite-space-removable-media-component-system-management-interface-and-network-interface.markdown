---

title: Computer storage device having separate read-only space and read-write space, removable media component, system management interface, and network interface
abstract: A storage device for use with a computer is disclosed. The storage device includes a processor communicably connected to a computer through a computer interface and a system interface. The computer interface enables communications exclusively between the processor and the computer, while the system interface enables to processor to manage one or more hardware components of the computer. A network interface is also included to enable the processor to communicate over a network with select file servers to the exclusion of other file servers. A storage means is communicably connected to the processor and includes first and second designated storage sections. The processor has read-write access to both storage sections, while the computer has read-only access to the first storage section and read-write access to the second storage section. A removable media storage component is also communicably connected to the processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08769185&OS=08769185&RS=08769185
owner: 
number: 08769185
owner_city: 
owner_country: 
publication_date: 20080501
---
Priority is claimed to U.S. provisional patent application Ser. No. 60 981 866 filed Oct. 27 2007. The disclosure of the aforementioned priority document is incorporated herein by reference as if set forth in full.

The field of the present invention is networkable storage devices for computers and computer networks.

The present application is related to U.S. Pat. No. 7 069 351 issued on Jun. 27 2006 and U.S. patent application Ser. No. 10 017 923 now U.S. Pat. No. 7 444 393 issued on Oct. 28 2008 the disclosures of which are incorporated herein by reference as if set forth in full.

A typical computer whether it is an off the shelf or a customized computer for personal business specialty or other uses has many components. Some of the common components are processors memories storage devices input and output devices and network interfaces. The operating system such as Microsoft Windows Mac OS UNIX Linux and the like is responsible for controlling the components their functions and their interactions. In particular the operating system handles file requests from applications or from the operating system itself. When a file request is received the operating system attempts to supply the file from a local storage device or from a file server if the computer is connected to a network.

Because there are many different options available for storage devices and network interfaces the operating system is typically programmed with the characteristics necessary to access almost every storage device and network interface that could be connected to the computer. For instance most operating systems are programmed to accommodate different storage devices having various storage device types e.g. magnetic optical etc. interface types e.g. IDE ATA SCSI SATA PATA SAS etc. and physical parameters e.g. number of cylinders sectors heads tracks etc. . If the computer is connected to a network the operating system also has to be programmed with the various network interface types e.g. Ethernet Token Ring ATM etc. the network protocols e.g. TCP IP IPX SPX AppleTalk SNA etc. and any particular methods needed to communicate with network resources e.g. servers printers scanners storage etc. .

In addition the operating system also has to be able to manage files on storage devices or on a file server over a network. On local storage devices the operating system typically uses lookup tables or indices usually referred as file allocation tables to manage the files. On a network the operating system has to be programmed to communicate with a file server and retrieve files. It is often advantageous for the operating system to translate the file information received from a file server into a format resembling the file allocation tables to simplify the file retrieval process.

The way in which an operating system manages components and their functions add complexity to a computer. The complexity is easily seen during the setup process of a computer. Typically a computer goes through a setup process that would involve a booting from a bootable device that can initiate installation of the selected operating system b partitioning and formatting local storage devices c installing the full operating system d configuring hardware components such as the display card and network interface e installing and configuring applications and other software until the computer is prepared for everyday general use.

The complexity is also evident while the computer is in use. Applications and the operating system may require periodic patches or updates the installation of which frequently involves uninstalling the older versions of the applications or components of the operating system. Additionally files may be corrupted due to program errors user errors or computer viruses. When this happens the corrupted files need to be replaced or repaired a process that may involve reinstalling the applications that use the corrupted files or even possibly reinstalling the operating system itself.

The complexity involved in using a computer usually results in high maintenance and support costs being incurred. In a business environment the support costs can easily reach thousands of dollars per user or per computing device. Additionally the cost of maintaining computers increases because work productivity tends to decrease significantly often to zero when computer related problems arise.

Problems related to hardware malfunction except problems related to storage devices may often be resolved within a short amount of time. For instance a broken component such as a video card or a network interface card may be quickly replaced with an identical component. However computer repair may become a lengthy process if the problems are related to storage devices or the files stored on the storage devices. When a hard drive in a computer malfunctions or corrupted files cause problems the repair and recovery process might involve reinitializing the hard drive reinstalling the operating system and or reinstalling applications.

Numerous methods are presently available to reduce the complexity of computers shorten the recovery process when problems occur or to minimize the need for a recovery process altogether. Some of the common methods are cloning the storage device booting the computer over a network utilizing specialized computer management software and or applying file level security.

By cloning the storage device the installation process may be shortened. A computer is first completely set up with a full set of applications. Then the storage device is cloned or duplicated as an image file. The image file may then be used to reset the computer to its original condition or to set up identically equipped computers Many consumer oriented computers come with recovery CD s containing the factory default image that can be used to restore the storage device to its factory default condition. The drawback of this method is that a new image of the storage device has to be created whenever there is a change in the operating system applications or any other files stored on the storage device. Complications may arise using this method in instances when it is necessary to apply patches or updates to the installed software after the storage device is restored from an old image. Customization of final configuration for a user for instance might take several hours even if the image is kept up to date.

The network boot method is often used in conjunction with simple computers that download necessary files from a file server on a network. The computer usually uses a well known network service such as BOOTP TFTP or PXE to download and execute a small basic portion of an operating system which in turn can start downloading the rest of the operating system and any applications. The drawback of this method is that if the computer does not have a local storage device it has to go through the same boot process of downloading needed files whenever it is powered on or reset. If the computer has a local storage device this process can benefit by storing downloaded files locally. But then the operating system downloaded over the network is once again responsible for the complex tasks of managing hardware components and files stored on the local storage device.

The computer management software method is used to enhance the operating system by adding additional software components as agents daemons or services. One typical way of using this method is to use anti virus software that constantly scans stored files for any computer virus or other malware infection. This method may also be implemented by adding a software component that constantly monitors important files on the local storage device and attempts to self heal any damaged or corrupted files. An additional implementation adds a software component that handles file updates pushed out from a server as a part of a computer management tool. The drawback of this method is that the software components acting as agents daemons or services are highly dependent on the operating system. For instance a software component written for Microsoft Windows would not work under Linux. Thus the operating system has to provide necessary functions such as managing local storage devices or network interfaces for these software components to work properly.

Many operating systems can also apply file level or directory level security to provide certain level of protection against computer viruses malware unauthorized access user errors or application errors that can corrupt important files. The drawback of this method is that it is again operating system dependant and a super user an administrator or a process running with full access privileges can accidentally modify delete or corrupt important files in the local storage. Moreover many malicious programs such as viruses that have gained full access privileges can inflict detrimental damage.

The above methods by themselves or in combination with other methods provide some help in reducing the complexities involved with computers. However none of the methods fundamentally changes how the operating system manages the components of a computer. Thus a new approach is needed for operating computers and simplifying the manner in which files are handled or distributed over a network.

In addition one of the growing concerns in today s computing environment has to do with data security. Computing devices are often stolen lost or thrown out while the storage device in the computing devices may contain sensitive data. Anyone who has gained physical access to the computing device or the storage device can easily access the data stored in the storage device in many ways. For instance one can boot the computer with an alternate operating system and gain access to the data. One can crack the administrator or user accounts and passwords by using a password recovery tools. Or one can simply remove a storage device from a company s computing device and hand over the storage device with user account and password to a competing company in industrial espionage. If the data are not backed up to or synchronized with a file server then everything is lost to an unauthorized party.

There are many methods to deter unauthorized access to files and data stored in a storage device. The methods generally fall into two categories a operating system based access controls and b external hardware dependent access controls.

In the case of operating system based access controls the operating system might use an encrypted file system EFS to encrypt the data stored in the storage device. But such a method is operating system dependent. If the operating system is compromised i.e. the encryption key for EFS is exposed or if the user account and password are cracked or known to an unauthorized party such operating system based access controls would not be able to safeguard the data.

In the case of external hardware dependent access controls an external device such as a SmartCard or a USB key might be used to control access to the data. For instance a SmartCard can be used to during the boot process before an operating system is fully loaded. If a valid SmartCard is found then the boot process can continue loading the operating system that would grant access to data most likely in EFS. This would be more secure than operating system based access controls alone but it would be dependent on the external hardware. If the hardware is damaged without a backup then even an authorized user can not gain access to the data. If a recovery procedure were to exist then an unauthorized party could use the recovery procedure to gain access to data. Also the external hardware i.e. a copy of a SmartCard or a USB key along with the storage device might be handed over to an unauthorized party in industrial espionage. To prevent this kind of unauthorized access the operating system may also use a connectedness policy in addition to the external hardware. For instance after a SmartCard is verified during the boot process the operating system may check with a network server for connectedness before allowing access to the data. But this method is also operating system dependent. That is if a particular operating system that a user or an application prefers does not provide this kind of access control then there is no way to benefit from such access control. Therefore a new approach to safeguarding data in a storage device is needed preferably one that is independent of the operating system running on the computing device.

Furthermore a certain degree of asset management both hardware and software asset management and support management of end user computing devices are highly desirable in a corporate computing environment. Hardware and software asset management is often accomplished with a use of an asset management agent that gets installed on end users computing devices. Depending on the implementation the agent can query and report hardware components to a management station. The agent is able to detect any changes in hardware configuration or unauthorized activities such as the computing device case being opened. The agent can also query files stored in local storage devices and report to a management station what kind of software is installed on end users computing devices. Based on information reported by the agent hardware or software asset reports can be generated on the management station.

Such asset management agents are again highly operating system dependent. That is many agents would need to be developed and written for all kinds and versions of operating systems e.g. Windows XP Windows Vista Linux UNIX MacOS etc. . Unless the agent is developed with some level of sophistication i.e. not only checking the software file names but also checking certain traits of the software such as an MD5 checksum or the like the agent can be fooled to report software assets incorrectly. For instance if an end user wants to use an application that is not officially allowed or supported by the company the user may rename the application executable to a common one such as NOTEPAD.EXE so that the application does not get reported to the management station. In the same way a malicious program can disguise itself as an authorized application.

The user or a malicious program may also fool the agent to make it appear as if the user has a certain application running on the system or existing in the user s local storage device. In today s highly security oriented computing environment certain firewalls or gateway proxy devices try to detect if the end user s computing device has certain applications running or not i.e. whether an anti virus software is running or not . Such firewalls or gateway proxy devices would use an agent to detect the presence of required applications. Unless the agent can detect all flavors and versions of required applications the user can change the name of an application and bypass the agent s query. For instance the user can make a duplicate copy of NOTEPAD.EXE as NTRTSCAN.EXE run and minimize the hoax NTRTSCAN.EXE to circumvent the agent s attempt to check if Trend Micro s OfficeScan application is running or not.

Such asset management agents are also not able to assess hardware components if the computing device is turned off. The agent has to be running on the computing device for the agent to be able to collect asset information and report to the management station. This means that the computing device has to be fully functional. The operating system has to be running correctly with many dependant services daemons such as network interface drivers and network protocols . Otherwise the agent would not be able to provide any hardware or software asset information to a management station

There are numerous methods currently available for remotely controlling computing devices i.e. power on or power off . Wake On LAN for instance is one of such methods that an administrator can use to turn on a computing device remotely so that the asset management agent can provide asset information to the management station. But being able to remotely power on a computing device would not do any good if the computing device is unbootable i.e. OS is not loaded correctly or there is a faulty hardware component . In this case the agent would not be loaded and would not be able to provide asset information to the management station. Therefore a different approach generally called out of band management has been developed for managing and troubleshooting computing devices that do not operate correctly.

Out of band management is widely used in today s computing environment. It can simply provide remote view of computing device s console for troubleshooting. Many implementations of out of band management provide additional functions and information such as power control and health check of system components e.g. whether a local storage device is bad whether there is a memory error whether the computing device s internal temperature is too high for it to operate properly etc. . This kind of management is usually accomplished by using an add on management board or a management component built into the computing device s system board. Many servers used in the corporate environment have such management options that enable remote administration of servers. Since the add on management board or the built in management component can have constant power either via a dedicated power supply or from the always on system board it can provide hardware related information to the management station even if the computing device is powered off independent of the operating system or an asset management agent.

Such add on management boards or built in management components have at least one major limitation they cannot query a local storage device and generate a software asset list. This limitation is mainly due to the fundamental architecture of today s computing devices where no more than one operating system can control a local storage device. An operating system that is responsible for managing a local storage device builds a file system unique to the operating system. For instance Microsoft Windows may use NTFS and this file system cannot be recognized natively by Linux or MacOS. In addition Microsoft Windows does not natively recognize file systems created by the Linux or UNIX operating systems. Therefore if an add on management board or a built in management component were to be able to scan a local storage device the add on management board or the built in management component would have to understand the file system in use. That is the firmware running on the add on management board or the built in management component should be compatible with the operating system running on the computing device. This would be a serious limitation since there are many varieties of operating systems a computing device would use. Even if the firmware running on the add on management board or the built in management component was made fully compatible with the operating system running on the computing device sharing the file system possibly with directory and file level security as well between the operating system and the firmware would likely introduce additional complications in that the file system could easily be corrupted requiring significant attention to repair.

Thus for an administrator to have a complete hardware and software asset management capability a combination of a hardware based approach i.e. add on management board or built in management component and a software based approach i.e. asset management agent is ideal. Because a hardware based approach would add complexity to the system and because software based approach is highly operating system dependent a new simplified approach is needed.

Basically the root cause of problems existing in today s computing environment is contributed by the operating system that has inherent vulnerabilities arising from the operating system s kernel mode that controls every component of the computing device or the user s ability and necessity to have elevated access rights e.g. administrative or root rights . For instance most if not all computing devices are booted with an operating system that controls peripheral devices e.g. a hard disk drive and the operating system has an elevated access mode that the operating system itself or a user needs to configure the operating system and the peripheral devices. Malicious users or programs are constantly exploiting these elevated access modes to gain unauthorized access or to make the computing device non functional. Operating systems and applications have become more and more complicated to prevent such exploitation but fundamentally no effective cure is currently known.

One of the recent developments in an attempt to minimize the malicious exploitation and to increase the manageability is the virtualization of the user s computing environment. Virtualization is accomplished by booting a computing device with a host operating system usually with a hardened operating system to provide a virtual machine that has virtual storage devices virtual network connections etc. The virtual machine is then booted with a guest operating system for the user. For instance an Apple Mac is booted with Mac OS Virtual PC is started to create a virtual machine and then the virtual machine is booted with Windows XP so that the user can use Windows applications. Or a server is booted with Windows Server 2003 VMWare server is started to create multiple virtual machines and then the virtual machines are booted with various operating systems. Snapshots of a virtual machine can be taken to save the states of the virtual machine so that the virtual machine can be restored quickly if the virtual machine encounters a problem. If a server is configured to support multiple virtual machines for users it would fall into centralized server based computing or thin client computing as the users can access the virtual machines remotely while transferring keyboard mouse and video signals over the network.

There are numerous advantages that server based computing or thin client computing has such as limited direct user access to the server hardware and software components and ability use low spec devices as user stations. But server based computing or thin client computing has several disadvantages as well such as the server needs to be powerful enough to support all users and more restrictively all user stations need to be connected to the server at all times to enable the users to use the applications available on the server.

Moreover virtual machines running guest operating systems still have inherent vulnerabilities that can be exploited by malicious users or programs. For instance the virtual machines would still need anti virus software and a way to control file permissions just like regular computing devices. And no matter how much the host operating system is hardened protected the host operating system still has elevated access modes that can be exploited. For instance a malicious user or program that gained administrative rights on the host operating system can corrupt or configure the software components that provide virtual storage devices to virtual machines and cause all virtual machines inaccessible. Therefore it is highly desirable to reduce exposure of the files and data used by the operating system and applications to malicious users or programs.

The present invention is directed to a storage device for computers and computer systems. The storage device includes a processor communicably connected to a computer through a computer interface and a system interface. The processor is also communicably connected to a network through a network interface. The computer interface enables communications exclusively between the processor and the computer and the system interface enables to processor to manage one or more hardware components of the computer. The network interface enables the processor to communicate over a network with select file servers to the exclusion of other file servers. A storage means is communicably connected to the processor and includes first and second designated storage sections. The processor has read write access to both storage sections while the computer has read only access to the first storage section and read write access to the second storage section. A removable media storage component is also communicably connected to the processor.

The storage device may be constructed with additional options to improve functionality of the storage device and the computer to which it is associated. Any of these options may be implemented on their own or in combination. As one option the storage device may include an encryption module with the processor being adapted to utilize the encryption module for one or more encryption decryption functions. Such functions may include encrypted communications with the select file servers encrypted storage of files on the storage means and encrypted storage of files using the removable media storage component. Encryption keys used by the encryption module may be obtained from one of the select file servers.

As another option the processor may be programmed to follow a series of sequential steps when a request for a file is received from the computer. First the processor determines whether the file is cached within the first designated storage section and if the file is there provides the file to the computer on a read only basis. Next if the file is not found cached the processor requests the file from one or more of the select file servers. If the file is available from one of the select file servers the file is retrieved cached within the first designated storage area and provided to the computer on a read only basis. Lastly if the file is not otherwise found a file unavailable notice is retuned to the computer. As an additional step within this sequence the processor may be programmed to determine whether the file is available from the removable media storage component if the file is not available from one of the select file servers. As before if the file is available it is cached and provided to the computer on a read only basis.

As yet another option the processor may be programmed to monitor control and or process user files written to the second designated storage section. Also if the computer is communicably connected to a network through the network interface the processor may be programmed to monitor control and or process network traffic passing through the network interface to and from the computer.

As yet another option the storage device may be programmed to copy user files stored within the second designated storage area whether for backup or archive purposes to the removable media storage component. Alternatively or in addition the storage device may be programmed to copy user files stored within the second designated storage area to one or more of the select file servers.

As yet another option the processor may be adapted to delete a cached file from the storage means upon receiving a delete command for the cached file from one or more of the select file servers. Alternatively the cached files may include a file expiration tag with the processor being adapted to delete a cached file according to criteria determined by the file expiration tag. Such tags may include an absolute time and date stamp a relative time and date stamp or some other non time related criteria which serves as indicia for when the file should be deleted.

Accordingly an intelligent storage device for use with computing devices and computing systems are disclosed. Advantages of the improvements will appear from the drawings and the description of the preferred embodiment.

For purposes of the present description the term non user file means a file that is a component of an operating system of a computer a component of an application or a file that is designated as one to which a user should have read only access. The term user file as used herein means a file that is not defined as a non user file and is usually generated as a direct result of the user s use of the computing device. Such user files may include temporary files generated by the operating system or the applications for the benefit of the user. Under these definitions the delineation between a non user file and a user file is preferably determined by computer and network administrators for any particular computer and network. Thus one skilled in the art will recognize that different administrators may elect to place the same file in different categories i.e. the administrator of a first network may choose to treat a particular file as a non user file while the administrator of a second network may choose to treat the exact same file as a user file.

In addition the term server encompasses both a computing device configured to operate as an independent server on a network and a virtual server which effectively simulates the functionality of an independent server in software and enables multiple virtual servers to be hosted by a single networked computing device. While some virtual servers may only simulate the functionality necessary to perform the function of a server other virtual servers may simulate part or all of the hardware components of a computing device in order to replicate the desired server functionality.

Turning in detail to the drawings is representative of a typical networked computer as exhibited in the prior art. The networked computer may be a personal or business computer whether an off the shelf or a custom built computer a networked server or it may be a specialty device such as a personal digital assistant PDA a telephone or any networked programmable device or appliance. The computer is shown with common components such as the central processing unit the internal interface bus that connects and allows communication between the various components the secondary storage device such as a hard disk drive or non volatile random access memory where the operating system and applications typically store necessary files the network interface which may be wireless or wired and is used to connect the computer to a network having network resources such as a file and print sharing server and or a network applications server and an optional network management interface that can be used for out of band management . These components are common to networked computers and are therefore well known to those skilled in the art.

The operating system is responsible for managing the interaction between the components to form a functional computer. In particular the operating system handles file requests that may originate from applications or from the operating system itself. These file requests arise when the applications or the operating system require access to a file which resides on either the secondary storage device the file and print sharing server or the network applications server . To handle the file requests the operating system is programmed with the characteristics of the secondary storage device and network interface to account for a wide variety of storage devices and network protocols that may be used in conjunction with the computer. The operating system is also programmed with information that enables it to keep track of files stored on the secondary storage device and how to integrate into the computer s operation the various resources which are available from various network servers . Therefore under normal operating circumstances the operating system of the computer addresses many different complex tasks.

The management interface can be used in any computing device but is presently most widely used in networked servers. The management interface allows an administrator to remotely manage the servers and collect information on hardware components or operating status. Using the management interface an administrator can power on or power off the computer view POST power on self test a pre boot process messages sequence or can have remote console capability as an extension of keyboard video and mouse KVM . The management interface can also be programmed to report the operating status to the server for management at regular interval or whenever there s a critical event such as a secondary storage device or the memory going bad. The management interface can be an add on board or can be built onto the primary system board of the computing device and can provide many functions well known to those skilled in the art.

The computer in is connected to three different kinds of servers residing on a single network although in alternative designs the different servers could reside on different networks. The first server is a server for intelligent storage devices SISD which communicates primarily with ISD s on the network. It may be desirable but not necessary to have ISD s be the only device type on the network that communicates with the SISD . In other words the SISD will not communicate with any device other than ISD s and the ISD s will not communicate with any server other than the SISD . However if the ISD is limited to communication with only the SISD any pass thru connection the ISD provides to the computer would not be limited to SISD . In fact via the pass thru connection the computer may communicate with the second and third servers on the network.

Those skilled in the art will recognize that many alternative server and network configurations are possible. For example two or more of the servers could be hosted as virtual servers by a single computing device. Alternatively more servers could be added to introduce redundancy or additional functionality into the network environment. The network may be constructed in any desirable manner. For example the network may be formed using copper wiring optical fibers wireless communications or any type and the like.

The cache engine is communicably connected to and manages the other components of the ISD . To assist in these functions the cache engine includes a pass through connection for providing network access to the computer through the ISD and an encryption engine . Specific functions of the cache engine include managing 1 the main CPU interface and the system interface to the computer 2 the pass thru connection that the computer may use to access network servers 3 the files stored within the cache 4 the operation of the removable media storage component and 5 the network interface to the network. The cache engine also processes file requests from the applications and operating system of the computer and commands received from an SISD. The overall goal of each of the components included with the ISD and the functions provided by the ISD is to relieve the operating system of duties associated with managing many of the typical components found in a computing device such duties including basic management of the functions file storage and management protection of files and system resources from viruses and other malware and the like.

The main CPU interface and the system interface enable the cache engine to communicate with a computer when the ISD is connected to a computer. Similarly the network interface enables the cache engine to communicate with other networked devices over a communication network when the ISD is connected to such a network. The main CPU interface and the network interface are also communicably connected to each other via the pass thru connection so that the cache engine can transparently provide the computer with a network connection. The cache engine may selectively monitor control and or process network communications to and from the computer using the pass thru connection . For example the cache engine may apply access control policies or scan for malicious network communications. The cache engine may also provide firewall functionality or remove virus or spyware infected network communications all independent of the operating system running on the computer. By way of another example the cache engine may use the included encryption engine to encrypt outgoing and decrypt incoming network communications. Such encryption and decryption functions may be performed using any type of programmable cryptographic algorithm.

The cache engine may be any type of central processing unit appropriate to control the functions of the ISD as described herein. The particular type of central processing unit used is a matter of design choice. Acceptable central processing units are available from the integrated circuit divisions of vendors such as Intel Advance Micro Devices AMD International Business Machines IBM ARM MIPS among others. Those skilled in the art will recognize that many alternative designs for the cache engine are possible in order to manage the components and the desired functionality of the ISD .

For instance many central processing units currently available already include an encryption module. Such processors can be used to encrypt files and data stored in the cache or in the removable media storage component or to secure network communications whether to or from the cache engine or to or from the computing device. For those processors that do not include an encryption module an encryption module external to the processor may be used. The cache engine can protect files stored on the cache from unauthorized access by encrypting the files independent of the operating system . The encryption decryption keys may be embedded into the cache engine itself may be stored in a separate memory specifically provided for such a purpose i.e. a nonvolatile memory or an external device such as a Smartcard or may be stored within the cache for access by the cache engine . For a highly secure implementation the cache engine may be programmed to require connectedness with an SSID so that the encryption decryption keys can be managed and supplied by the SISD . In such an implementation access to the files stored in the ISD is blocked if the ISD is not connected to the network and able to communicate with the SSID . If the cache engine cannot contact an SISD on the network for a decryption key the cache engine would not decrypt files in the cache . Thus even if the operating system of the computer is compromised the files stored in the cache would remain encrypted and fully protected because the cache engine manages file encryption decryption independent of the operating system . Depending on the level of security and protection desired the cache engine may be programmed to check the connectedness constantly at preset intervals e.g. every 15 minutes every 2 hours every day etc. or only when encryption decryption functions are initiated.

The main CPU interface and the network interface may each be any type of appropriate interface that enables the cache engine to communicate with the computer and the network respectively. The particular method of interconnecting the computer and the network to the ISD is a matter of design choice. Methods utilizing commonly known formats such as IDE ATA SCSI SATA PATA USB and IEEE 1394 among others are acceptable for the main CPU interface in block mode or file mode native or emulated . Methods utilizing commonly known network interface types such as Ethernet ATM wireless network and cellular network among others and network protocols such as TCP IP and ATM among others are acceptable for the network interface . Such components are generally widely available from a variety of computer hardware vendors as standalone components or as a part of integrated central processor units. When the computer is a peripheral or a mobile device having an ISD the network interface may take a form of direct connection interface. A PDA for instance may have an internal ISD . The PDA may have a network interface such as a wireless network interface but may also have a direct connection to a personal computer that would act as an SISD .

The system interface may be a simple controller that can power on or power off the computer or an integrated circuit that can provide additional management functions by interfacing directly with the system board or various components of the computer . By utilizing the system interface the cache engine may send management requests to various components of the computer as a pre scheduled event or as requested from the SISD which would incorporate the typical functions of known management servers. For instance the cache engine may power cycle the computer every night to clear memory leaks to terminate unclosed applications before starting a nightly backup or for any other desired purpose. Alternatively or in addition the cache engine may query computer components every few minutes to see if any of the components show any signs of failure. If a problem is detected the cache engine may send an alert to a management server. The cache engine may also use the system interface to redirect or echo KVM to the management station as required. Essentially the cache engine may utilize the system interface to provide management functions typically provided by a management interface an add on management board or a built in management component as is currently practiced in the prior art. Thus the ISD eliminates the need of a separate management interface.

An ISD can also provide software asset management that an add on management board or a built in management component cannot provide. Since the cache engine not only provides computer component management functions but also manages files requests from the operating system or the applications an ISD would be able to provide both hardware and software asset management together.

Furthermore using known out of band management techniques the cache engine may also use the system interface to control peripherals of the computer independent of the operating system or the applications running on the computer . For instance the cache engine may control USB ports e.g. enable or disable so that not even a user with an administrative rights or the operating system has access to USB devices such as USB flash memories. Since such kind of peripheral control can be centrally managed from an SISD that sends necessary commands or policies to the ISD by managing hardware components and software assets in this manner the operating system can be anything and no operating system dependent management agent is required.

The particular type of storage used for the cache is also a matter of design choice. The cache may be any type of random access media that is known to those skilled in the art such as a hard disk drive DRAM SDRAM flash memory or any type of random access media. The choice will generally depend on the intended usage of the associated computing device. For instance a hard disk drive may be used for regular desktop or laptop computers DRAM may be used if the computer needs to be completely reset when power cycled possibly because the contents stored in the cache need to be erased completely for security reasons a SDRAM or flash memory may be used if the computer needs a high performance storage with low heat dissipation or a removable random access media may be used in an environment where the user may roam around to different computers but would want to keep the cached contents. Thus the programming used by the cache engine may be adapted to function with the particular type of random access media chosen. In addition the cache may be separated into two sections using any desirable scheme. One of the sections is designated for non user files which the computer is granted read only access to and the other is designated for user files which the computer is granted read write access to. For example the cache may be partitioned so that each designated section is formed by contiguous address space. Or alternatively the two sections can be formed by non contiguous address space such that when a new file is written to the cache the address space used by the newly written file is designated to one of the designated sections depending upon whether the file is a user file or a non user file.

The particular type of removable media storage component is also a matter of design choice. The removable media storage component may be any type of random access media storage such as a CD ROM CD RW various format and media types of DVD a USB jump drive or it may be any type of sequential access media storage such as a magnetic tape cartridge. The primary use of the removable media storage component is for the cache engine to obtain the requested files from a removable media when the cache engine cannot communicate with an SISD . Selected non user files generally available from an SISD may be stored on removable media so that the cache engine has access to those files at times when it cannot communicate with the SISD . In addition the removable media storage component may be used to pre populate non user files to the read only space of the cache so that some large applications do not need to be downloaded over the network connection.

The removable media storage component may also be a shared component of the computer as illustrated in where the operating system or the applications have direct use of the removable media storage component . Like the cache the removable media storage component may be separated into sections using any scheme desirable if it is to be a shared component. Alternatively the operating system and the applications may not have direct access to the removable media storage component but instead have access through the ISD thereby enabling the cache engine to selectively control monitor and or process communications between the operating system or applications and the removable media storage component . In addition the cache engine may allow or disallow use of the removable media storage component . For instance the cache engine may allow access to an audio CD or an encyclopedia DVD but may not allow access to MP3 files or unauthorized applications stored on removable media.

The ISD may have any number of devices or interfaces embedded within or alternatively may be configured so that the operating system and the applications must access such peripheral devices or interfaces through the ISD . In this way the access to peripherals can be controlled independent of the operating system as the cache engine can allow or disallow the access based on access rules or policies that may be centrally managed by an administrator. Being able to centrally control peripheral access independent of the operating system is a valuable ability in a highly secure environment. For instance a user would not be able to save sensitive files to a removable media if the ISD does not allow the access to the removable media storage component . The user would also not be able to boot with an alternate operating system either if the ISD does not allow access to any bootable media. In short the ISD can be programmed to control various components of a computer while managing files stored on the cache and interact with the computer and network as needed.

In a typical implementation of the ISD the processor used as for the cache engine does not need to be a high performance processor as its duties are limited to file management and access control. For instance the processor does not have to be powerful enough for large spreadsheet calculations graphics renderings etc. as such demand for high performance would only be expected of the CPU used in the user computing space . Nevertheless the user computing space can be virtualized without losing the concept of the ISD as long as direct access of the virtualized computing space to the cache engine is limited in accordance with the concepts set forth herein. Furthermore regardless of the user computing space being physically composed of a CPU and a memory or virtualized the user I O can be a locally attached keyboard mouse and video or remote keyboard mouse and video extended over a network.

The programming of the ISD may be in any programming language such as C Java and the like and the compiled program may be embedded into the cache engine itself or it may be stored in a separate memory specifically provided for such a purpose e.g. an updateable firmware . Alternatively the programming may be stored within the cache for access by the cache engine . Mainly the programming permits the cache engine to communicate with an associated computing device giving the computing device access to files stored in the cache on a read only basis for non user files or on a read write basis for user files. Depending on the type of the main CPU interface the programming may provide emulated block level access or file level access to the files stored in the cache . The programming may also permit the cache engine to communicate with a network through the network interface using any appropriate network protocol.

If the cache engine determines that the request is for a file read then the cache engine determines if the file read request is for a file located in the read only designated space i.e. a non user file or for a is for a file located in the read write designated space i.e. a user file. If the file request is for a non user file the cache engine determines if the non user file is available from the read only designated cache. If the requested non user file is available from the read only designated cache the cache engine returns the non user file to the operating system. If the requested non user file is not available from the read only designated cache the cache engine sends a request for the non user file to an SISD. The request may be in the form of a broadcast to any and all SISD on the network or it may be made to a specific SISD on the network. The method would depend on the particular network the ISD is connected to. From the request to the SISD the cache engine determines if the requested non user file is available from an SISD over the network. If the requested non user file is available the cache engine retrieves the non user file from the SISD and copies it to the read only designated space. Then the cache engine returns the non user file to the operating system . If the requested file is not available from an SISD the cache engine notifies the operating system by returning a Not Available notice to the operating system.

If the requested file is a user file residing in the read write designated space the cache engine determines if the file is available from the read write designated space. If the requested user file is not available the cache engine checks if retrieval of the file from a file server is permitted and possible. The file may be available from a file server from a past backup or archive procedure. If so the cache engine retrieves the user file from a file server and copies to the read write designated space. When the file is available whether directly from the cache or copied from a file server the cache engine determines if any features are enabled and processes the enabled features. Once the features are processed or if features are not enabled the file is returned to the operating system. Again the particular order of feature processing depends upon the feature set being processed. For instance if an automatic backup is enabled the cache engine first compares the user file locally stored in the read write designated space with the user file stored as a backup on a file server and provides the computer with the latest version of the user file. If the file is not available in the cache and not available on the file server the cache engine notifies the operating system by returning a Not Available notice to the operating system.

The actual logic that the cache engine follows in responding to a request from the operating system may take different forms depending on the needs of the particular implementation. Those skilled in the art will recognize that many alternative logics are possible for managing the file requests while separately keeping the read only space and the read write space and safely providing read only access to non user files in the manner described herein.

The ISD described herein is operating system independent and is not constricted by having to conform to any particular protocols or file structures. An operating system interacting with the ISD needs to be programmed only with the protocol needed to request files stored on the ISD and the operating system can dispense with file storage and maintenance tasks if the ISD is the only storage peripheral or the only source for connected storage peripherals. Advantageously communications between the operating system and the ISD may be performed using a small number of procedures. These procedures would be the only ones dependent on the operating system and system architecture and they can be standardized on any hardware platform.

Thus an intelligent computer storage device having separate read only space and read write space removable media component system management interface and network interface is disclosed. While embodiments of this invention have been shown and described it would be apparent to those skilled in the art that many more modifications are possible without departing from the inventive concepts herein. The invention therefore is not to be restricted except in the spirit of the following claims.

