---

title: System for estimating a software product release time from version information
abstract: Systems and processes for migration of data stored in a label-based software configuration management (CM) system to records of a time-based CM system in a manner that permits for identification, in the time-based system, of contents of releases. In some exemplary implementations, techniques operating according to some of the principles described herein will accept as input information relating to a listing of a label-based system and estimate, based on the software component versions in the listing and their corresponding creation times, a release time indicating a time a release was created. The release time may then be used, in some, but not necessarily all, implementations to create a data structure in the time-based system indicating contents of the version at the particular time. Some exemplary implementations may additionally determine, from the estimated release time, whether any software component versions should be explicitly included or excluded from the data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667465&OS=08667465&RS=08667465
owner: AccuRev, Inc.
number: 08667465
owner_city: Concord
owner_country: US
publication_date: 20080331
---
This invention relates to the field of configuration management software for managing development of a software project. More particularly it relates to a system and method for estimating a creation time for one or more versions of a software project based on input information regarding software component versions included in the one or more versions of the software project and creation times of the software component versions.

Developing software applications and products which includes both initial development and later modifying or adding to the initial development often requires the coordinated efforts of many developers e.g. software programmers . This coordinated effort is referred to herein as a software development effort or development effort and a body of work e.g. one or more software products including software applications being developed by the effort is referred to as a software development project software project or project. A software development effort may comprise one or more software projects. At any given time as part of a software development effort multiple developers may be working on different software components of a software development project and or different versions of these software components e.g. for different users or situations . Thus there may be multiple concurrent software development efforts ongoing at least some of which use or involve the modification of common software components including different versions of those software components and sometimes multiple versions of components.

Frequently a software development project may involve several or even dozens or more of developers and managers and from a few to even hundreds of software components. Managing one or more software development projects and the concurrent development of these different software components and versions is commonly referred to as configuration management CM . Computers or computer systems running CM software applications i.e. programs assist developers and project managers in the complex task of managing a software development project including maintaining coherency between different software components and versions. Hereafter the term CM application may be used to refer to such computers or computer systems or to a CM program for executing on a computer or computer system. 

One popular conventional way of managing projects of a software development effort is referred to herein as a label based system. Label based CM applications i.e. CM applications running in label based systems have long been in use in the field of software development from the Revision Control System RCS proposed in 1985 through modern CM applications like Rational ClearCase available from the IBM Corporation of Armonk N.Y. Perforce available from Perforce Software Inc. of Alameda Calif. Concurrent Versions System CVS an open source software project PVCS available from Serena Software Inc. of Redwood City Calif. and many others.

In a label based system information on software components and their versions is stored separately from project information. A developer working on a project in a label based system may edit individual software components of a project e.g. individual code files and may create one or more versions of the software components. Information on these software component versions i.e. the versions of the software components is stored by the label based system along with edit creation times for the versions. This information on software component versions may in some label based systems be stored in a tree branch format describing a relationship between versions of the software components and versions of a software project.

A developer may store additional information e.g. metadata in the records of the label based system describing the software components and or software component versions which are to be included in a build or release of a software project which is a version of a software project at a particular time. Herein where the term release is used it should be understood to refer to both a build and a release and therefore does not require any distribution to inside or outside parties. For example if a developer working on a Version 2.0 of a software product creates new versions of some software components while fixing bugs of and or adding functionality to the Version 1.0 of the software product the developer may store as a part of the additional information an indication that the new versions of the software components are to be included in the Version 2.0 release of the software product. Label based systems typically only store a single copy of this additional information that is if a change is made to the additional information any information predating the change is lost.

The additional information stored by the developer to describe a release may be used by the label based system when a release is created to retrieve the appropriate software component versions to be included in the release and may additionally be used to create a listing of software component versions which were included in the release. This listing may comprise the label of the label based system as a field identifying the release. Once created this listing may be perpetually stored by the label based CM application as an indicator of the contents of the particular build of the contents of the particular release of the version of the software project and may be stored in many ways for example as a table in a database. For example the listing may comprise information such as an identifier for each software component included in the release an identifier for the version of the software component an identifier for the version of the software component and a label for the release e.g. RELEASE1 or TestBuild . A user of a label based system as mentioned above may then refer to the listing later to determine the state of a version of the software project at a time of the release i.e. which software components and versions were included in the project .

Table I shows one example of such a listing of software components included in a release named RELEASE1.

Table II shows a second example of such a listing including information regarding two different releases.

New systems have been proposed which move away from the label based system model used by RCS ClearCase and others. One such new system is referred to herein as a time based system. An example of such a time based system is AccuRev 4.5 available from AccuRev Inc. of Lexington Mass. Time based systems are described in greater detail below and more information is available in the disclosures of U.S. patent application Ser. Nos. 10 894 697 and 10 894 964 both by Damon B. Poole and both of which are incorporated herein by reference in their entireties. It should be appreciated that terminology explicitly employed herein that also may appear in either of the disclosures incorporated by reference should be accorded a meaning most consistent with the particular concepts disclosed herein.

In a time based system such as AccuRev information on versions of software projects may be maintained indicating the software component versions that each version of the project comprises. Some systems may additionally store information on the parent or child versions with which the project versions share a relationship and a history of changes that have been made to the versions e.g. software component versions which have been previously included in the version of the software project but are not now and the time the change was made . This history may be based on a time changes were made and or a sequence of the transactions operations that effected the changes. The information on the versions of the software projects may be stored in these time based systems in many different ways including as streams.

A stream is a data structure containing information describing a version of a software project or other type of software entity and a set of software components i.e. one or more software components associated with the version. A stream may relate a set of software components to one another and to metadata describing the version of the software development project and or the software components. The metadata of a stream may be any suitable information about the software components and or project such as a status of the software components and or a status of the project. It should be appreciated that different versions of a software project or other type of software entity may have the same content e.g. may include a same set of software component versions or different content.

The contents of a version of a software project i.e. the software component versions of a version of a software project in a time based system may be determined in one or more ways. In some time based systems contents of a version are determined based on the version hierarchy in which the version is and inheritance properties of the hierarchy. For example a child version may be considered to have all the contents of a parent version but a parent version may not have all contents of a child version. Additionally or alternatively a version s contents may be determined by include and or exclude rules stipulating which software components and or software component versions are included in the software project version and or which are excluded from the software project version. For example an include rule may stipulate that all files of a particular directory in a software component file structure be included and an exclude rule may stipulate that none of the files of subdirectories of that particular directory be included. In some time based systems a combination of inheritance and include exclude rules may be implemented. Information on the contents of a version may be stored by the time based system as a part of the information on the versions of the software projects e.g. as the metadata of a stream .

The information on versions of software projects stored by a time based system may provide developers the ability to determine a status of the version of the software project at various points in time. For example by examining a history of changes made to the version a developer may be able to determine contents of the version at a desired time. Additionally in some systems a developer may be able to create in the time based system a record relating to the version that contains the contents of the version of the software project at a particular time such as when a release is created. Such a record may be stored as a time based version including as a snapshot which may be an unchangeable time based version i.e. no changes may be made to it in the future . The time based version may then be easily consulted later to determine the contents of the version at the time e.g. the contents of the release rather than examining a history of changes to the version and identifying a particular time and the contents at that time.

Time based systems offer many advantages over label based systems. First while in label based systems only the current state of a version e.g. the current contents of the version is maintained in a time based system a history of changes made to the version may permit developers to have more information about exactly what happened to a version at what time and how the version has evolved over time. This information may help developers in troubleshooting problems such as by aiding in identifying what changes were made to a version and when the changes were made. Additionally by storing at all times the contents of a version of a software project and maintaining a history of changes that may be reviewed later and or a snapshot identifying a state of a version at a particular time time based systems avoid the necessity of creating a separate listing at release time indicating the contents of the release. While in small software projects the step of creating this separate listing may be trivial in larger software projects of thousands of files this process can take hours and is a waste of system resources.

Applicant has appreciated that given these advantages and others developers using conventional label based systems may desire to migrate to a time based system or to permit part of their development teams to perform time based management of the software development process while integrating with other parts of the team using a label based process. Applicant has further appreciated the desirability of a migration process permitting a transfer of historical software project information from the label based system to the time based systems such that developers may still access previously created data in the new time based system.

Systems and processes operating according to some of the principles described herein provide functionality to allow for migration of data stored in records of a label based system to records of a time based system in a manner that permits identification in the time based system of contents of releases. In some implementations techniques operating according to some of the principles described herein will accept as input information relating to a listing e.g. a label table of a label based system as described above and estimate based on the software component versions in the listing and their corresponding creation times a release time indicating a time a release was created. The release time may then be used in some but not necessarily all implementations to create a data structure in the time based system indicating contents of the version at the particular time. Some exemplary implementations may additionally determine from the estimated release time whether any software component versions should be explicitly included or excluded from the data structure depending on whether the creation times were before or after the estimated time.

In one embodiment there is provided a method for migrating a software project from a label based system for use in a time based system and determining which versions of software components to include in a version of the software project in the time based system. The version of the software project comprises a plurality of said software components in some combination of versions of the software components. The method comprises examining a first set of software components and their versions included in the version of the software project and a second set of later versions of the software components included in the version of the software project to determine component creation times for each of the software component versions in the first set and the second set and determining a creation time for the version of the software project by comparing the creation times for each software component which is present in both the first set of software components and the second set of software components. The method further comprises recording in a computer readable data structure the creation time for the version of the software project and determining if any software component versions included in the version of the software project in the label based system were created after the creation time determined and if so recording in the data structure indications that the software component versions so determined are included in the version of the software project.

In another embodiment there is provided a computer implemented method for estimating a creation time for a version of a software product. The version comprises a plurality of software components and at least some of the software components are available in two or more versions with only one version of a software component included in a software product version. The method comprises determining a first set of software component versions and a second set of software component versions. The first set of software component versions comprises versions of software components which are included in the version of the software product and the second set of software components comprises later versions of the software components. The method further comprises examining the creation times of the software component versions of the first set and the second set to determine the creation time for the version of the software product by comparing the creation times for each software component which has a version in each of the first set and the second set and selecting as the estimated creation time for the version of the software product that time which is the latest of the component creation times of versions of software components in the first set of software component versions which is not later than a component creation time of a corresponding version of the software component in the second set of software component versions.

In a further embodiment there is provided at least one computer storage medium encoded with computer executable instructions which when executed carry out a method for migrating a software project from a label based system for use in a time based system and determining which versions of software components to include in a version of the software project in the time based system. The version of the software project comprises a plurality of said software components in some combination of versions of the software components. The method comprises examining a first set of software components and their versions included in the version of the software project and a second set of later versions of the software components included in the version of the software project to determine component creation times for each of the software component versions in the first set and the second set and determining a creation time for the version of the software project by comparing the creation times for each software component which is present in both the first set of software components and the second set of software components. The method further comprises recording in a computer readable data structure the creation time for the version of the software project and determining if any software component versions included in the version of the software project in the label based system were created after the creation time determined and if so recording in the data structure indications that the software component versions so determined are included in the version of the software project.

In another embodiment there is provided at least one computer storage medium encoded with computer executable instructions which when executed carry out a method for estimating a creation time for a version of a software product. The version comprises a plurality of software components and at least some of the software components are available in two or more versions with only one version of a software component included in a software product version. The method comprises determining a first set of software component versions and a second set of software component versions. The first set of software component versions comprises versions of software components which are included in the version of the software product and the second set of software components comprises later versions of the software components. The method further comprises examining the creation times of the software component versions of the first set and the second set to determine the creation time for the version of the software product by comparing the creation times for each software component which has a version in each of the first set and the second set and selecting as the estimated creation time for the version of the software product that time which is the latest of the component creation times of versions of software components in the first set of software component versions which is not later than a component creation time of a corresponding version of the software component in the second set of software component versions.

In a further embodiment there is provided an apparatus comprising at least one computer storage medium encoded with computer executable instructions which when executed carry out a method for migrating a software project from a label based system for use in a time based system and determining which versions of software components to include in a version of the software project in the time based system. The version of the software project comprises a plurality of said software components in some combination of versions of the software components. The method comprises examining a first set of software components and their versions included in the version of the software project and a second set of later versions of the software components included in the version of the software project to determine component creation times for each of the software component versions in the first set and the second set and determining a creation time for the version of the software project by comparing the creation times for each software component which is present in both the first set of software components and the second set of software components. The method further comprises recording in a computer readable data structure the creation time for the version of the software project and determining if any software component versions included in the version of the software project in the label based system were created after the creation time determined and if so recording in the data structure indications that the software component versions so determined are included in the version of the software project. The apparatus further comprises at least one processor to execute the method.

In a further embodiment there is provided an apparatus comprising at least one computer storage medium encoded with computer executable instructions which when executed carry out a method for estimating a creation time for a version of a software product. The version comprises a plurality of software components and at least some of the software components are available in two or more versions with only one version of a software component included in a software product version. The method comprises determining a first set of software component versions and a second set of software component versions. The first set of software component versions comprises versions of software components which are included in the version of the software product and the second set of software components comprises later versions of the software components. The method further comprises examining the creation times of the software component versions of the first set and the second set to determine the creation time for the version of the software product by comparing the creation times for each software component which has a version in each of the first set and the second set and selecting as the estimated creation time for the version of the software product that time which is the latest of the component creation times of versions of software components in the first set of software component versions which is not later than a component creation time of a corresponding version of the software component in the second set of software component versions. The apparatus further comprises at least one processor to execute the method.

In another embodiment there is provided an apparatus comprising at least one computer storage medium encoded with computer executable instructions which when executed carry out a method for migrating a software project from a label based system for use in a time based system and determining which versions of software components to include in a version of the software project in the time based system. Each version of the software project comprises a plurality of said software components in some combination of versions of the software components. The method comprises examining a first set of software components and their versions included in the version of the software project and a second set of later versions of the software components included in the version of the software project to determine component creation times for each of the software component versions in the first set and the second set and recording in a data structure a creation time for the version of the software project. The method further comprises determining if any software component versions included in the version of the software project in the label based system were created after the creation time and if so recording in the data structure indications that the software component versions so determined are included in the version of the software project. The apparatus further comprises at least one processor to execute the method and means for estimating the creation time for the software project by comparing the creation times for each software component which is present in both the first set of software components and the second set of software components.

Pure migration of data from a label based system to a time based system that is copying the software components and their corresponding versions from one to the other may be done in any number of ways and may be a very trivial process particularly for smaller software development efforts. Some processes for performing this migration however may not take full advantage of the benefits of a time based system including the capability to store a history of changes made to versions of a software project and the ability to store a state of a software project version as a time based version and or as a snapshot.

For some users of CM applications it may be desirable to migrate data in a manner that stores information in the time based system that can be used to identify a history of the changes made a software project and a history of various states of the software project. However label based systems do not typically store such information as discussed above and so this information cannot simply be migrated and stored along with other data from the records of the label based system. In label based systems the creation time for software component versions may be stored which indicates the timing of at least the transactions that created the software component versions but these times by themselves do not provide much information regarding transactions executed on a software project such as the time a release was created. While a listing of the contents of a release is created at the time the release is created many label based systems do not store any time information for the creation of this release. Additionally as discussed above the creation of this listing may take hours in the case of large software projects and time information that could be stored regarding the creation time of this listing may not be useful when seeking a description of the state of the software project at the time the release was created.

Applicant has appreciated however that information on a history of a software project may be derived from the various information stored in records of a label based system and then stored in records of a time based system to take fuller advantage of the benefits of the time based system. As discussed above when a release is created in a label based system a listing is created of the software component versions included in the release. Additionally when software components versions are created in the label based system the creation times for the software component versions is stored. Applicant has appreciated that a creation time for a release may be estimated by examining creation times for each of the software component versions included in the release and the estimated creation time for the release may be stored in the records of the time based system and used to create a history of the version of the software project related to the release.

The creation time for the release may be estimated from the version information for the release in any suitable manner examples of which will be discussed in greater detail below. Some techniques operating according to some of the principles described herein may retrieve the listing of the contents of the release from the records of the label based system identifying software component versions included in the release. The creation times of each of the software component versions included in the release may also be retrieved and the creation times for each of the next versions of each of the software components included in the release e.g. if version 1 of software component X is included in the release then also retrieve the creation times of version 2 of software component X if a version 2 exists . The exemplary technique may then compare for each software component for which there exists a next version the creation times for each of the software component versions included in the release to the creation times of the next versions to identify a latest time that is before any of the creation times of the next versions. This determination may be made in any suitable manner such as by comparing the creation times for the software component versions included in the release to the creation times of the next versions to identify a latest creation time of a software component version included in the release that is earlier than any creation time of a next version. The latest creation time may then be identified as the estimated creation time for the release.

In some time based systems the estimated creation time for the release may then be used to identify in the records of the time based system the contents of the release. While label based systems rely on the creation of listings as described above to identify the contents of a release time based systems may instead store an indication that a release is for example the contents of a version at a particular point in time. Accordingly when a creation time is estimated for a release the estimated creation time may be used in records of the time based system to identify the contents of a release by associating the estimated creation time with a version of a software project and identifying the release as the state of the version of the software project at the estimated creation time.

In some implementations techniques may also be adapted to determine exceptions and exclusions to this general rule for contents of a release and identify software components and or software component versions which are to be included i.e. excepted or excluded by rules other than the general time stamp. As used herein an exception is an indication that a software component version should be explicitly included in the release in the records of the time based system and an exclusion is an indication that a software component versions should be explicitly included in the release in the records of the time based system. Exceptions and exclusions may be used as an addition to a rule specifying a time as described above such that the contents of a release may be more accurately described.

Exceptions and exclusions may best be understood in terms of examples. In the following trivial example shown in Table III there are no exceptions exclusions.

In Table III showing records of the label based system for software components including a creation time and labeling each of the versions included in Release 1 was created at time 1 second 01 and each of the versions included in Release 2 were created at time 2 seconds 02 . Thus it may be determined using any suitable technique including the exemplary techniques described below that Release 1 was created at time 1 second and all versions that existed at time 1 second are to be included in Release 1 in the time based system. No exceptions exclusions would be created by this rule. In other words if a line were drawn at time 1 second and everything created previous to the line were included in Release 1 no software components or versions that should not be included would be included. Table IV shows an example of one situation that would produce exclusions.

As shown in Table IV version 1 of software component other.c was created at time 1 second but was included in Release 2 and not Release 1. This could be because for example the code was originally intended to be included in Release 1 but the features implemented by the code were deferred to Release 2 e.g. the code of other.c was buggy and was not fixed before Release 1 was made so it was deferred . In this case time 1 second may be determined to be the creation time for Release 1 but an exclusion may be noted for version 1 of other.c. The exclusion may be stored in the records of the time based system as part of the information identifying the release to support the description Release 1 includes all versions created at or before time 1 second other than version 1 of other.c. Exceptions may be similarly determined and noted identifying software component versions which should be explicitly included such as a software component version created after one of the next versions had been created . Exceptions and exclusions may be stored in any suitable manner including by any of the exemplary techniques outlined below.

The illustrative process of begins in block wherein data is migrated from a label based system to a time based system. The data that is migrated may comprise software components e.g. files and directories and any suitable information e.g. metadata on the software projects managed by the label based system. Once this data has been migrated and stored in the data stores of the time based system then in block the data may be sorted into versions. In time based systems which store information in streams this may comprise sorting the data into streams and may comprise establishing histories for the versions from the data migrated in block .

Blocks and of process may be implemented in any suitable manner. In accordance with one exemplary technique once all the software components stored by the label based system have been retrieved and stored in the data stores of the time based system Application Programming Interface API calls may be made to the label based system to retrieve information e.g. metadata on files versions and branches stored by the label based system. The retrieved information on the files versions and branches may then be used to associate the software components with versions of a software project in the time based system and thereby populate the versions of the software project with versions of software components and in some cases a history of changes to the version of the software project.

Once the versions have been established in block then in block the process begins determining contents of a release and storing information related to the release in records of the time based system. In block the process examines metadata stored in the label based system regarding a release. This metadata may be any information related to the release including the listing described above of software component versions included in the release and creation times for each of the software component versions. Some techniques may also examine the creation times of each of the next versions of the software components included in the listing as outlined above and as described in greater detail below.

This metadata may be retrieved from the label based system in any suitable manner. For example API calls implemented by the label based system may be used to retrieve the information. In cases where the label based system is Rational ClearCase3 available from the IBM Corporation API calls such as

could be used to retrieve from the records of the label based system a listing of all software components in a listing which have the label REL1.1. Similar API calls may be implemented for other label based systems or any other suitable technique may be used to retrieve the information. Once a listing of software component versions has been retrieved then the creation times for these software component versions may be retrieved from the records of the label based system either from a data store of metadata about the software components or from a data store of the software components themselves e.g. properties of a file on disk . Creation times may also be retrieved for the next versions in a similar manner.

In block the process estimates a creation time for the release using the metadata. This may be done in any suitable manner including as outlined above and as described in greater detail below. The estimated creation time is then in block stored in a data structure in the records of the time based system and may in some time based systems be used to generate a time based version or snapshot. In block the process determines whether any exceptions or exclusions exist and if so stores indications of the exceptions and or exclusions in the records of the time based system and the process ends. This process particularly blocks of the process may then be repeated for any number of releases maintained by the label based system.

Further details of the methods and apparatuses which may be implemented according to the principles described herein are offered below. First however to facilitate this further discussion an overview of exemplary configurations for software projects is now provided. In the exemplary configurations versions of a software project are maintained by a time based system as streams. It should be appreciated however that streams are merely exemplary of the type of data structures that may be implemented in accordance with the techniques described herein and that other implementations are possible.

CM applications in time based systems may maintain versions of software projects in a version hierarchy. Thus when versions are implemented as streams a stream may be part of a stream hierarchy. A stream hierarchy and by abstraction a version hierarchy is a logical hierarchy of streams defining relationships between streams. As shown in discussed in greater detail below a stream hierarchy may include at least one stream the source stream which is at the highest level of the hierarchy and is the stream from which the other streams of the hierarchy are ultimately derived. Thus the source stream is said to be the parent of all other streams and the other streams directly derived from it are at least initially its children. In general a stream having one or more children is a parent stream or parent of each of its child streams. A parent stream including the source stream may have one or more children or child streams each of which inherits one or more properties of the parent stream and its ancestors. For example each child stream includes at least a subset of the directory elements discussed below included in its parent stream. A child stream may be derived directly i.e. created from its parent stream though this is not always the case as a stream s relative position within the hierarchy may change over time. As a result a child stream may at some time have a parent from which the child was not originally derived.

Some CM applications operating according to the principles described herein may implement one or more types of streams. For example one type of stream is the one discussed above which may describe a version of a software project and a set of software components associated with the version. Other types of streams may have additional functionality. For example a project stream may be a stream in which the stream data structure i.e. the base structure of the stream as discussed above has an additional element which describes that the project stream is a source stream for a software project.

As another example a workspace may be implemented as a stream having an additional element in the data structure indicating that changes may be made to the software components associated with the workspace. Accordingly as used herein a workspace is a type of stream in which a developer can make changes to the content of a software project e.g. the software components of the software project . Workspaces in some exemplary implementations may be limited to being at the bottom of a stream hierarchy and any stream ancestry chains determined for the stream hierarchy. In some embodiments workspaces are further configured such that they cannot have child streams i.e. so that they cannot be a parent stream. Thus in some embodiments changes to a software project are made only in workspaces and then propagated to other streams according to techniques discussed in greater detail below.

As discussed briefly above shows an exemplary stream hierarchy for Project A comprised of a plurality of streams. Stream marked Project A may be considered the source stream for the stream hierarchies . Some of the child streams of stream such as child streams and are represented as workspaces for developers e.g. Workspace Developer Dev Workspace Developer Dev etc. . A developer may have a single workspace where all changes are made or the developer may have multiple workspaces depending on which software project he or she is working. The stream hierarchy in addition to the workspaces has development stream to which developers may propagate work done in their workspaces e.g. changes made to one or more software components . Changes may be propagated up a hierarchy or propagated down in a hierarchy. As used herein promote means to propagate up a hierarchy whereas update means to propagate down through a hierarchy.

The stream hierarchy also has testing stream which may hold streams for the projects that are used by test engineers such as Quality Assurance QA engineers to test the work done by the developers. In the stream hierarchy software components may be propagated up the stream i.e. promoted or may be propagated down the stream i.e. updated . For example a software component edited by Developer may be promoted from workspace of Developer to the development stream for Project A and the versions of the software component of the other child streams of the development stream i.e. workspaces of Developers may be updated.

In some exemplary implementations properties of a version e.g. the software component versions included in the version and or a status of the version may be determined in one or more ways. For example in some implementations the properties of a version may be determined based on inheritance rules and the parent versions of the version. In these implementations when a change is made to a parent version the child version will be updated with the change. As described in greater detail below in some implementations in some child versions such as time based versions and snapshots these changes may be inherited up to a particular point in time and not thereafter. Some implementations may additionally or alternatively determine the properties of a version using include and exclude rules.

As used herein an include exclude rule or I E rule is a rule specifying whether to include or exclude software components from a version. In some embodiments if the software component is a directory an I E rule may specify whether to include or exclude one or more of the child elements of the directory from the version. Any of a variety of types of I E rules may be used including but not limited to an include rule an include directory only IDO rule and an exclude rule. An exclude rule is an I E rule that when defined for a directory of a version specifies that the directory element and its child elements if any i.e. if it is a directory are excluded from the version. An include rule is an I E rule that when defined for a software component of a stream specifies that the software component is included in the version. An include rule may also specify that each of the software component s child elements if any i.e. if it is a directory are included in the version unless an exclude rule has been defined for the child element. In other words each child element of an software component for which an include rule has been specified are included in the version by default unless an exclude has been specified for the child element. An include directory only rule or IDO rule is an I E rule that can only be defined for software components which are directories and not for files or other types of software components. When defined for a directory an IDO rule specifies that the directory is included in a version however each of the directory s child elements if any are excluded from the version unless an include rule has been defined for the child element. In other words each child element of a directory for which an IDO rule has been specified are excluded from the version by default unless an include rule or IDO rule for directories only has been specified for the child element.

I E rules may be used to set the properties of a version by specifying for example the contents of a version. An include rule may be used for example to specify that a software component which is not a included in a parent version should be included in a version while an exclude rule may likewise specify that a software component included in a parent version should not be included in a version.

It should be appreciated that the structures of software projects of e.g. the stream hierarchies are merely exemplary and that techniques operating according to some or all of the principles described herein are not limited to implementing the illustrative hierarchies and structures shown in . Methods and apparatuses operating according to the techniques described herein may implement any suitable structure for software projects and versions of software projects.

A version of a software project e.g. a stream as mentioned above is a set of software components that may be related to the software project. As used herein software components include any element of a software project. Software components may be for example a program a file a directory a directory element an object a record a table another type of software component and any combination thereof. As used herein a directly element is a directory or a file. Additionally elements of software projects such as a files may be organized in a hierarchy. A file hierarchy is a logical hierarchy defining an organization of files. illustrates an example of a file hierarchy. A file hierarchy includes at least a root directory at a highest level of the hierarchy. The root directory may include at a second level in the hierarchy one or more directory elements. As used herein a directory element is an element of a directory and may be any of a variety of types of software components. For example a file such as file main.c or a sub directory such as sub directory GUI may be directory elements. As used herein a directory including the root directory and any of its sub directories is a directory element e.g. of a file hierarchy that includes one or more other directory elements e.g. files and or directories .

As used herein a child element or child of a directory is an element included within the directory at a level immediately below the level of the directory in the hierarchy whereas any element included within the directory regardless of level is referred to as a descendant element or a descendant of the directory. For example directory is a child element of root directory while directory is a descendant element of root directory . Conversely a directory is referred to herein as a parent directory or parent of any elements included in the directory at the level immediately below the directory and is referred to as an ancestor element or ancestor of any included element regardless of hierarchy level. Conceptually a file hierarchy is not limited to a maximum number of levels although in practice this number may be limited by computation and storage capabilities of the system on which the file hierarchy is implemented.

In some exemplary implementations each software component of a software project is assigned a unique identifier for the software component. The identifier preferably is unique in that it is assigned to the component on the component s creation and it stays with the component regardless of which version or versions the software component is a part or changes to the component made by a developer. The unique identifier which in some implementations may be termed an element identifier EID may be any of a variety of types of identifiers such as numerical alphabetical alpha numerical etc. If the component represented by an EID is a file or directory providing a numerical value may avoid problems commonly encountered in known systems where an alphabetic identifier is used. For example files and directories are frequently renamed such that a current name of a file or directory may not be a same name that the file or directory had in the past. Further the current name may be a name formerly used by another file or directory. The ability of a file or directory name to change over time and the absence of another unique identifier that remains constant may create confusion and cause problems when an attempt is made to determine a status of a file or directory at a past time. For example in some conventional CM applications e.g. some label based systems if an attempt is made to determine the status of a file in the past e.g. by resorting to tape backup and the file had a different name and another file had the file s current name the wrong file may be identified and an incorrect status determined. This problem may be eliminated in time systems operating according to the principles described herein by providing a unique numerical identifier for a file or a directory that remains constant throughout the life of a file or directory regardless of whether the file s or directory s name is changed.

In addition to an EID in some implementations a software component may be associated with one or more other values indicating one or more versions of the software component. For example a software component may be associated with one or more stream IDs one or more instance IDs one or more real stream IDs one or more edition IDs a transaction ID and or any other suitable identifier. These other identifiers may be used to identify virtual versions and real versions of the software component which are included in versions of the software project though alternative implementations may not track real and virtual versions of software components and thus may not store these identifiers or may store more or fewer identifiers to track version information in any other suitable manner.

A virtual version may be an instance of the software component. The virtual version may have the same content as or different content than other virtual versions of the software component including the software component from which it was created. Thus although it is common in the field of software configuration management to refer to different instances of a software component e.g. components in different versions of a software project as different versions of the component even if the content of each version is in fact the same such instances are referred to herein at virtual versions. 

Alternatively a real version is an edition of a software component having different content than the previous real version of a software component from which the edition was created. Thus if a change is made to a software component and recorded as part of a project a new real version of the software component may be created.

For example referring to the version hierarchy shown in and element hierarchy shown in if file were created in workspace and promoted to version the virtual version i.e. instance of file in each stream would be different although the real version i.e. edition of the file would be the same. If file were then edited in workspace workspace would have a different real version of file than workspace .

As used herein a version of a software component e.g. a file or a software component version means the real version of the software component not the virtual version of the software component. Thus in determining a software component version included in an issue resolution or a stream the real version of the software component is determined. As discussed above in some implementations modifications to a software component e.g. add remove change are made in workspaces only. In such embodiments each version i.e. real version of a software component may correspond to the workspace in which it was created.

A stream ID stored in association with a software component may therefore be used to represent the stream ID of the stream of a virtual version of the software component. An instance ID of the software component may be used to identify a an instance of the virtual version of the software component. A stream ID and an instance ID may then be used to specify a stream instance pair defining a virtual version of a software component. Likewise a real stream ID and an edition ID of a software component may define a real version of a software component.

Table V shows an exemplary record for real and virtual versions of a software project. It should be appreciated that this record is merely illustrative and that other implementations may store version information for software components in any suitable manner. For a given software component e.g. file of with an EID of 2 a record for the software component stored by a CM application may be 

For the purposes of the exemplary record shown in Table V and for further examples discussed below Table VI shows stream IDs for the streams shown in the exemplary version hierarchy of .

Each entry of Table V may specify a virtual version of a software component the corresponding real version of the software component and the transaction number of the transaction that created the virtual version of the software component. As shown in Table V a software component with an EID of 2 e.g. file of has five real versions created by developers a first edition of file created in stream a second edition created in stream a third edition created in stream a first edition created in stream and a third edition created in stream . As discussed above a real version is defined by a real stream ID edition ID pair. Table V also shows that file is included in four different streams of the software project streams and because each of those four streams includes a virtual version of the file or a reference to a real version of the file. The virtual version of stream for example is a reference to the real version 4 1 the first edition of the file created in stream . Likewise the virtual version 3 1 the first instance of stream is a reference to real version 4 1. As may be also seen from Table V stream initially created a new version of file in real version 5 1 later included a virtual version 5 2 referencing the real version 4 3 of the file and then later made its own edits to the file and created real version 5 3.

Table V in addition to including fields regarding real and virtual versions of a software component also includes a field for a transaction ID number for a transaction that created the real or virtual version. In some exemplary implementations a CM application may associate each action taken by a user and or automated action taken by the CM application itself with a transaction number such that actions may be tracked and a user may be able to determine a sequential ordering of steps taken by the user other users of the CM application and or the CM application. A transaction ID may be a sequential number a time at which the action was taken or any other suitable identifier. Associating actions with transaction IDs may be advantageous in a number of ways such as aiding users in determining when errors were inserted into a software project for example and aiding users in rolling back changes that created errors. It should be appreciate that methods and apparatuses operating according to embodiments of the invention are not limited to implementing CM applications tracking actions taken by users or the CM applications and that CM applications implemented in accordance with the principles described herein may store any suitable information.

The transaction history shown in Table V may also be useful in creating two other types of versions time based versions and snapshots. These two types of versions which may also be implemented as streams in some implementations may be created as children of a basis stream having a history. Where typical child versions as described above will inherit the current state of the parent version and thus inherit any new software component versions that are promoted to the parent version time based streams and snapshots are versions which only inherit the contents and properties of a parent stream until a particular point in time. A time based version or snapshot comprises a reference to a basis version as well as a reference to a particular point in time and or transaction number at which to stop inheriting the state of the basis version. In a time based version additional edits may be made to the version e.g. additional material added through include exclude rules and children versions may be added which may promote changes to the time based version but no changes made to the basis version i.e. the parent version of the time based stream after the reference time transaction will be inherited by the time based stream. A snapshot on the other hand may be considered to be an immutable version. Once created a snapshot may never be changed.

Table VII shows another exemplary data structure which may be implemented to track version ancestry for a file. Table VII shows a record of parent child relationships between real versions of a software component. As used herein a parent version of a particular version of a software component is the version from which the particular version was created. Conversely a child version of a particular version of a software component is a version created from the particular version. A new entry may be added to a record such as the one shown in Table VII each time a transaction results in the creation of a new real version of a software component.

For each entry in Table VII an EID field may hold a value representing a unique identifier e.g. a number of a software component. The combination of values of the Parent Stream and Parent Edition fields may specify a unique stream edition pair defining a real version of the software component specified by the EID field. This real version is the parent of the real version specified by the unique stream edition pair specified by the Child Stream and Child Edition fields.

In some implementations a data store of software components may store different real versions of a software component as a series of deltas or differences from a previous version. For example the first version of a file maybe stored in full while a second version of the file may be stored only as one or more references to deletions and or additions that were made to the file between versions. When a version of a file is needed for example at build time for a software project or when a developer wants to view and or edit the file then the original file may be retrieved and any necessary additions and or deletions made by versions between the original version and the version on which work is being done applied. In this manner CM application implemented in accordance with these implementations may conserve disk space by not storing full copies of files.

CM applications may additionally or alternatively store records for determining software components included in streams at particular times. Table VIII shows exemplary data and fields that may be included in such records.

In Table VIII the stream ID field may hold a value specifying an ID of the stream to which the entry in the record applies. EID field may hold the EID of the software component represented by the entry. The transaction number field as mentioned above may hold a value representing a transaction number or other value corresponding to a time at which the entry was made. The in progress field may hold a value indicating whether the software component is in progress for the stream at the time corresponding to the value of the transaction field. As described above a software component of a stream is in progress if a modification has been made to the software component i.e. it has been added modified or removed and the stream has not been promoted to a parent stream i.e. propagated up in a version hierarchy . If a software component is in progress within a stream then the version of the software component in the stream and its children may be different than the version of the software component elsewhere within the stream hierarchy. For example the software component may not even exist in other streams in the hierarchy. Alternatively the software component may have been removed from the subject stream and its children but still may be present in other stream of the stream hierarchy.

Having now described the arrangement of exemplary records which may be maintained by some exemplary implementations regarding software components and streams examples of transactions that may result in the entries in Tables V VII and VIII will now be described. References may be made to the version hierarchy of the element hierarchy of and the stream IDs shown in Table VI.

In transaction six file may have been created in workspace resulting in the creation of a new virtual version and a new real version of file . This transaction may have resulted in the first entries of Tables V and VIII i.e. those having a Transaction ID of 6 . As indicated in Table VIII because file is yet to be promoted from workspace to stream the in progress field for the entry indicates that file is in progress in workspace . The entry in Table V for this transaction indicates that the virtual version 4 1 and the real version 4 1 resulting from transaction six are the same.

Transaction six does not result in the creation of an entry in Table VII because file is a new file for which version ancestry has not yet been established.

In transaction file may be promoted from stream to stream . resulting in the creation of a new virtual version of file . Transaction seven may result in the second and third entries of Table VIII and the second entry of Table V. As indicated by the entries in Table VIII file is no longer in progress in workspace but is in progress in stream . The entry in Table V indicates that the virtual version i.e. stream instance pair 3 1 corresponds to the real version i.e. stream edition pair 4 1. Transaction seven does not result in the creation of an entry in Table VII because transaction seven did not result in the creation of a new real version of the file but merely the creation of a new virtual version.

In transaction eight file may be promoted from stream to stream resulting the creation of a new virtual version of file . Transaction eight may result in the fourth and fifth entries of Table VIII and the third entry in Table V. Transaction eight does not result in the creation of an entry in Table VII because a new real version of file has not been created.

In transaction nine file may be modified in workspace in which file was included because workspace is a descendant stream of streams and and the modification recorded to create a new virtual version and new real version of file . Transaction nine may result in the sixth entry of Table VIII the fourth entry in Table V and the first entry in Table VII. The entry in Table VII reflects that real version 5 1 was created from real version 4 1.

In transaction ten file may be modified in workspace and the modification recorded to create a new virtual version and a new real version of file . Transaction ten may result in entry seven in Table IV entry five in Table V and entry two in Table VII. The entry in Table VII indicates that new real version 4 2 was created from real version 4 1.

In transaction eleven file may be modified in workspace and the modification recorded to create a new virtual version and a new real version of file . Transaction eleven may result in the eighth entry in Table VIII the sixth entry in Table V and the third entry in Table VII.

In transaction twelve file may be sent from workspace to workspace thereby creating a new virtual version of file . In other words rather than promoting a file from workspace to stream and stream a user e.g. a developer project leader etc. may directly send e.g. copy and paste file from workspace to workspace thereby replacing whatever version of file currently resides in workspace . For example a user interface e.g. a GUI may enable a user to specify file e.g. by typing in an identifier or selecting it from a user interface display and send file to workspace .

Transaction twelve may result in entry nine in Table VIII and entry seven in Table V. The entry in Table V indicates that virtual version 5 2 of the file created in workspace corresponds to real version 4 3 of the software component in workspace . It should be appreciated that transaction twelve did not result in an entry in Table VII because it did not result in the creation of a new real version.

In transaction thirteen file may be modified in workspace and the modification recorded to create a new virtual version and a new real version of file . Transaction thirteen may result in the last entry in Tables V VII and VIII. The entry in Table VII as before indicates that the new real version 5 3 of file was created from real version 4 3 of file .

It should be appreciated that these exemplary transactions are merely illustrative of actions that may be supported by CM applications implemented in accordance with the principles described herein and that in some exemplary implementations CM applications may not support some of these actions or may support actions not described above. Further it should be appreciated that the data structures and records described above in conjunction with Tables V VIII are merely exemplary and that some implementations of methods and apparatuses operating according to the principles described herein may maintain any suitable records implemented in any suitable data structures.

As described above in conjunction with when migrating information from a label based system to a time based system the data stored in records of the label based system e.g. data of individual software components such as code files and or metadata about software projects may be converted into versions in the format of the time based system. Thus the data of the label based system may in some exemplary implementations be associated with streams as outlined above. Associating the data with versions may be done in any suitable manner as the principles described herein are not limited to performing in any specific way an import of the data of a label based system. One exemplary technique will now be described though it should be appreciated that other techniques are possible.

Process begins in block wherein the import module retrieves from a storage area e.g. a designated portion of one or more computer storage media of the label based system one or more file structures storing software components e.g. files and directories managed by the label based system. Each software component in the file structure may be a version of a software component in the case where multiple versions of a software component exist. The file structure of the label based system retrieved in block may then be stored in a storage area of the time based system.

In block the import module performs one or more API calls to the label based system to determine metadata associated with each of the software components of the label based system and assembles the information received in response to these API calls into a table of information on software components. This table may comprise information on each of the versions of the software components in each of the branches in which a software component is included in the label based system. This information may comprise for example the name of the software component the branches the software component in which is included the versions of the software component i.e. the software component versions and the creation times of each of the software component versions.

In block the table of information is sorted by the import module to place the results in chronological order for association with the time based system. The table may be sorted one or more times such as a sort by creation time followed by a sort by name a sort by branch name and a sort by version number.

In block the import module begins associating software components with versions by stepping through the entries in the table. For clarity the association process will described in connection with the illustrative structures described above though it should be appreciated that this is only exemplary and other implementations may store information in any suitable format. In block a selected entry in the table is examined and the file name indicated in the entry used to identify a software component stored in the time based system. In block the branch name in the entry to examined to determine if it is a new branch name or has been previously encountered in the table. If the branch name is new then in block a new stream or other suitable version data structure is created in the table based system. If however the branch name has been previously encountered in the table then in block the corresponding stream is identified. In block the version number in the entry is then used to identify a particular version of the software component to be associated with the stream and a new real version of the stream is created with an identifier linked to the stream identified by the branch name of the entry. Block may further comprise identifying the newly added version as the active version in the stream and changing a stream history to indicate a previously included version having the same file name as an inactive version. One or more transactions may then in block be recorded in the time based system indicating that the real version was created at the time corresponding to the creation time in the entry. In block the import module checks to see if more entries exist in the table and if so moves on to the next entry. Otherwise the import process ends.

As discussed above it should be appreciated that the technique shown in is merely exemplary of the techniques which may be implemented by an import module and that any suitable technique for importing software components may be used in accordance with the principles described herein.

The process executed by the import module results in versions e.g. streams being established in the time based system and creates a history of changes that have been made to the versions derived from the information contained within the records of the label based system. As discussed above however this information does not permit the time based system to identify particular points in the history of the versions at which releases were created. Given creation times for releases time based versions or snapshots may be created which reference the versions created by the import module and reference a particular time transaction in the history of the versions. These time based streams or snapshots may then be used to identify the contents of a release such that users may quickly and efficiently determine a state of a release at a particular point in time without having to perform various searches or examine histories.

Determining the contents of a release and creating a time based stream or snapshot may be done in any suitable manner as the principles described herein are not limited to being implemented according to any specific technique or techniques. Exemplary techniques are described below but it should be appreciated that these techniques are merely illustrative of the type that may be implemented and others are possible.

In some implementations a creation time for a release may be estimated from the creation times of software component versions included in the release and creation times of later versions of those software components which are not included in the release. This information may be retrieved for example from records of the label based system through executing suitable API calls as described above or in any other suitable manner.

The process begins in block in which the estimation module receives an indication of a release to be created in the time based system. The indication received in block may be any suitable identifier for a release such as a name for the release and may be received from any suitable source such as another process of the time based system e.g. another module assisting in migration of data from the label based system to the time based system from a user of the time based system from any component the label based system or a process interacting with the label based system or any other suitable source. The identifier received in block begins the process of creating in the time based system a release corresponding to the identifier.

In block the estimation module retrieves information related to the release from the label based system. This may be done in any suitable manner such as by executing one or more API calls supported by the label based system. As described above in the case that the label based system is Rational ClearCase available from the IBM Corporation at least one of the one or more API calls may be 

The information retrieved by the one or more API calls will comprise information stored by the label based system on the contents of the release identified by the indication REL1.1 which may be in this example the indication received in block . The information retrieved may comprise software component versions included in the release as well as creation times for those software component versions. Table IX shows one example of a listing of information that may be retrieved by the one or more API calls.

In block the estimation module examines the software component versions included in the release as indicated by the information retrieved in block and retrieves information on the next versions of the software components included in the release if any. For example if version 1 of software component X is included in the release as indicated by the information retrieved in block then information on version 2 of software component X if it exists will be retrieved in block . The information retrieved in block may be any suitable information such as creation times for each of the next version. Information may be retrieved in block in any suitable manner including by any suitable API calls or any other suitable information. Table X shows an example of the type of information that may be retrieved in block .

In block the information retrieved in block may be compared by the estimation module to the information retrieved in block to estimate a creation time for the release. This comparison may be done in any suitable manner. In some implementations the comparison may estimate a creation time by selecting a time which is the latest of the creation times of the software component versions included in the release which is not later than a creation time of a next version not included in the release. A comparison in accordance with this technique may be carried out in any suitable manner such as by the exemplary process illustrated in though it should be appreciated that other techniques may be implemented.

The exemplary process of implementing the estimation of block begins in block wherein the estimation module sorts the information retrieved in block according to ascending order of creation times for each of the software component versions. The sort of block operated on the information of Table IX yields Table XI.

In block the estimation module sorts the information retrieved in block according to descending order of creation times for each of the next versions. The sort of block operated on the information of Table X yields Table XII.

In block initial values are assigned to variables used by the estimation module. The value of the creation time in the first row of Table XI is set to the variable T and the value of the creation time in the first row of Table XII is set to the variable T. The estimated creation time for the release the variable basis time is set to be T. Then in block the estimation module begins stepping through the entries in each of the listings e.g. the rows of the sorted tables to identify an estimated creation time for the release. The values of T and T are compared in block . If T is greater than or equal to T T T then the process is stopped and the estimated creation time is output in block . If T is less than T however then in block basis time is set to the value of T and if the last rows of the tables have not been reached then T and T are set to be the creation times in the next rows of the respective tables. In block it is determined whether the end of both tables has been reached and if not the process loops back to perform a comparison in block . If the end of both tables has been reached then in block the estimated creation time basis time is output and the process ends. Outputting the estimated creation time may comprise storing the estimated creation time in a computer storage medium such as in records of the time based system sending the estimated creation time to another module or process of the time based system outputting the value to a user through a user interface and or any other suitable output step.

Using the exemplary data shown in Tables XI and XII Table XIII shows the values of the variables T T and basis time as changed by the illustrative process .

In the example of Tables XI and XII then the estimated creation time for the release REL1.1 is time 2 seconds.

It should be appreciated that the process shown in is merely exemplary of the types of processes that may be implemented to estimate a creation time for a release based on information retrieved from a label based system and that any suitable process may be implemented to estimate a creation time in block .

In block a data structure is created identifying the release. For example a time based stream or snapshot or other type of version may be created having as a parent the version from which the release was created. The parent version may be determined in any suitable manner such as by examining information stored in the records of the label based system by examining information stored in the time based system or by prompting a user for input regarding the parent version. In some implementations a setting in the time based system may specify a parent version for created time based versions and snapshots such as a setting that each time based stream and snapshot will have as a parent version a particular version e.g. the source version or other specified version . Such a setting may be particularly useful in cases where the software project of the label based system has only one branch such that in the label based system all releases were created based on the same source. The time based stream or snapshot may use as a reference time the estimated creation time from block and therefore may as described above inherit from the parent version the properties of the parent version e.g. the contents of the parent version only through the reference time indicated in the time based version or snapshot and therefore the time based version or snapshot will be an accurate representation of the state of the parent version i.e. the state of the version of the software project from which the release was created at the estimated creation time.

In block the estimation module may examine the contents of the release as determined by the information retrieved in block and compare it to the estimated creation time and the contents of the parent version of the time based stream or snapshot. This is done to determine whether any exceptions or exclusions should be stored in the time based stream or snapshot. Any suitable technique may be used to determine exceptions and or exclusions. For example to determine exclusions the estimation module may step through each row in the information retrieved in block e.g. the Table IX and determine whether the creation time in the row is later than the estimated creation time. If so then an exception may be indicated in the time based stream or snapshot indicating that the software component version in that row is to be explicitly included in the time based stream or snapshot. As another example to determine exclusions the contents of the parent version of the time based version or snapshot at the estimated creation time are examined and compared to the information retrieved in block e.g. the Table IX to determine whether any of the contents of the parent version at the estimated creation time was not included in the release as indicated by the information stored by the label based system i.e. the information retrieved in block . If it was not included in the release as indicated by the records of the label based system then it should not be included in the release in the records of the time based stream. If any software components are found to be included which should not be then an exclusion may be indicated in the time based stream or snapshot indicating that the software component or software component version should not be included.

The exemplary data shown above in Tables XI and XII shows an example of where an exception would be created. As shown in Table XI version 3 of the software component other.c should be included in the release but it was not created until time 5 seconds which is after the estimated creation time for the release i.e. time 2 seconds . In this case in block the estimation module will recognize that the creation time for the software component version is after the estimated creation time and will indicate an exception for version 3 of other.c in the time based version or snapshot.

Exceptions and exclusions determined and created in block may be stored by the time based system in any suitable manner. For example in some implementations include exclude rules I E rules are used to note the specific exceptions inclusions or exclusions to the time based version or snapshot. Once exceptions and exclusions are handled in block then the process ends.

It should be appreciated that the process is merely exemplary of the types of techniques that may be implemented in accordance with some of the principles described herein and that other techniques are possible. For example in some implementations an estimation module instead of storing the record in block as a time based stream or a snapshot the estimation module may first determine whether any exceptions exclusions exist and if so may then store the record as a time based version and if not store the record as a snapshot. As a further alternative the record may be stored as a time based stream in block and following the determination of block may convert the time based stream to a snapshot if there are no exceptions exclusions to be indicated.

As a further alternative to the process in some implementations a technique may be implemented which does not receive as in block an indication of a specific release for which information should be retrieved in block but rather retrieves all information regarding all releases and creates records in the time based system for each of the releases described by the retrieved information. Some implementations may additionally or alternatively be adapted not to retrieve information on one or more releases but rather to receive as input the information retrieved in block from which releases are created. For example in one implementation the import module described above may be adapted to retrieve the release information and then provide it to the estimation module.

It should be additionally appreciated that while an estimation module is described as carrying out each of the steps described in in some implementations an estimation module may only implement some of the steps. For example an estimation module may only implement the steps described in block of such as by only executing the exemplary process of . As such while an estimation module may in some implementations be responsible for retrieving information from a label based system and creating a release in a time based system in other implementations an estimation module may be implemented which carries out fewer functions and may for example only be responsible for estimating a creation time for the release.

Table XIV shows a historical version hierarchy that may be maintained in the records of a time based system to identify versions managed by the CM application of the time based system. The Table XIV shows the information that has been modified by the estimation module to yield the version hierarchy B.

For each entry the version ID field may hold a unique identifier for the version the name field may hold a name of the version identified the parent version may hold a unique identifier for the parent version of the version the time basis may hold a time and or transaction value identifying a time at which the version will stop inheriting properties of its parent version and the transaction field may hold a transaction number or other value e.g. time value corresponding to a time at which the entry was created e.g. corresponding to a time the version was created . As mentioned above Table XIV is shown comprising information modified by the estimation module as a result of actions taken that may form a part of block of the illustrative process of . The estimation module will have appended or caused through other actions the time based system to append the last row to the table creating an identifier for the Snapshot version. The transaction executed by the estimation module or by the time based system in response to actions by the estimation module has been assigned a transaction number and so is stored in the table as an indicator of the actions which resulted in the Snapshot version being created.

Techniques operating to some or all of the principles described herein may be implemented in any suitable manner. For example in some embodiments the techniques may be implemented as computer executable instructions encoded on one or more computer storage media such as a magnetic medium e.g. a hard disk drive a Compact Disk CD a Digital Versatile Disk DVD a persistent or non persistent solid state memory e.g. Flash memory Magnetic RAM etc. or any other suitable storage media. In some such embodiments the computer executable instructions implementing the techniques operating in accordance with the principles described herein may be implemented as one or more stand alone modules e.g. the import module and the estimation module described above . As used herein a module is a structural component of a system which performs a specific operational role however instantiated which may be a portion of or an entire software element e.g. a function or a discrete process . These modules may in some implementations be adapted to interact with other unrelated modules and or processes such as modules implementing a time based system and a CM application or in other implementations the modules may be adapted to interact with other modules which together with the modules form an overall system such as the time based system. As such it should be appreciated that while in some embodiments the techniques described herein may be implemented as a portion of a time based system in other embodiments the techniques may be implemented separately from any time based system and may be adapted to interact with a time based system. It should also be appreciated that in many implementations an estimation module may be implemented separately from an import module such that an import module may form a portion of a time based system while an estimation module may be a separate component adapted to interact with the time based system.

Computer executable instructions which implement techniques operating according to one or more of the principles described herein may be executed on any suitable computing device operating in any suitable computer system. For example techniques operating according to some or all of the principles discussed herein may operate on a single multi purpose programmable digital computer apparatus a coordinated system of two or more multi purpose computer apparatuses sharing processing power and jointly carrying out the techniques described herein a single computer apparatus or coordinated system of computer apparatuses co located or geographically distributed dedicated to executing the techniques described herein one or more application specifics integrated circuits ASICs for carrying out the techniques described herein one or more Field Programmable Gate Arrays FPGAs for carrying out the techniques described herein or any other suitable system.

Computing device may comprise a processor a network adapter and computer readable media . Computing device may be for example a desktop or laptop personal computer a workstation a server a mainframe or any other suitable computing device. Network adapter may be any suitable hardware and or software to enable the computing device to communicate with any other suitable computing device over any suitable computing network. The computing network may be any suitable wired and or wireless communication medium or media for exchanging data between two or more computers including the Internet. Computer readable media may be adapted to store data to be processed and or instructions to be executed by processor . Processor enables processing of data and execution of instructions. The data and instructions may be stored on the computer readable media and may for example enable communication between components of the computing device .

The data and instructions stored on computer readable media may comprise computer executable instructions implementing techniques which operate according to the principles described herein. In the example of computer readable media stores computer executable instructions implementing an estimation module and an import module which may operate according to the exemplary techniques described above. Computer readable media further comprises a suitable user interface through which a user may be prompted for input e.g. input of a release to be created as in block above and or input of a parent version for a release as in block above . In alternative implementations computer readable media may solely comprise computer executable instructions implementing an estimation module. The estimation module and or import module may be adapted to communicate with a label based system operating on another computing device over a communication network using the network adapter and may additionally be adapted to communicate with a time based system operating on a computing device which may be the same or a different computing device as the one operating the label based system over the communication network and through the network adapter .

In alternative implementations rather than communicating with the label based and time based systems over a communication network the computing device may operate the label based and or time based systems and one or both modules may be adapted to communicate with the systems locally. For example the computer readable media may further comprise computer executable instructions implementing a time based system and a data store of data and metadata stored by the time based system and the estimation and import modules may interact with the time based system locally and interact with the label based system through the communication network. Alternatively the estimation and or import modules may be implemented on the same computing device as the label based system and may interact with the time based system over a communication network. In such an implementation the computer readable media may comprise computer executable instructions implementing the label based system and a data store of data and metadata stored by the label based system. As a further alternative computing device may operate both the label based and time based systems and the estimation and or import modules and the computer readable media may further comprise computer executable instructions implementing the label based and time based systems and data stores of data and metadata stored by the systems. As a further alternative the computing device may not operate the time based and or label based systems but may instead be adapted to operate one or more client program which interacts with servers operating the label based and or time based systems. In such embodiments the computer readable media may further store computer executable instructions to operate the one or more clients.

It should be appreciated that the computer system shown in merely exemplary as techniques operating according to the principles described herein may operate in any suitable computer system. For example in one alternative system as described above computing devices and may be implemented as a single computing device such as in the case where the estimation module and or the import module are implemented on the same computing device as the time based system. Alternatively computing devices and may be implemented as a single computing device or computing devices and as a single device or all computing devices implemented as a single computing device according to some of the alternatives described above in connection with . In addition while the computing devices are shown as personal computers and servers in the example of it should be appreciated that any of the computing devices may be implemented in any suitable fashion as any suitable device including as a personal computer server mainframe workstation rack mounted computer personal digital assistant PDA or any other suitable computing device.

Various aspects of the principles described above may be used alone in combination or in a variety of arrangements not specifically discussed in the embodiments described in the foregoing and is therefore not limited in its application to the details and arrangement of components set forth in the foregoing description or illustrated in the drawings. For example aspects described in one embodiment may be combined in any manner with aspects described in other embodiments.

Use of ordinal terms such as first second third etc. in the claims to modify a claim element does not by itself connote any priority precedence or order of one claim element over another or the temporal order in which acts of a method are performed but are used merely as labels to distinguish one claim element having a certain name from another element having a same name but for use of the ordinal term to distinguish the claim elements.

Also the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of including comprising or having containing involving and variations thereof herein is meant to encompass the items listed thereafter and equivalents thereof as well as additional items.

Having thus described several aspects of at least one embodiment of this invention it is to be appreciated that various alterations modifications and improvements will readily occur to those skilled in the art. Such alterations modifications and improvements are intended to be part of this disclosure and are intended to be within the spirit and scope of the invention. Accordingly the foregoing description and drawings are by way of example only.

