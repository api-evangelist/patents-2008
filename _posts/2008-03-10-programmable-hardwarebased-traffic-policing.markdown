---

title: Programmable hardware-based traffic policing
abstract: A hardware-based technique for policing traffic in a network node involves programming a set of algorithm-specific policing primitives that establishes a relationship between condition primitives and action primitives and populating a searchable memory with a set of indexed action primitives. Action primitives are then selected from the searchable memory in response to condition primitives related to a received datagram. Policing actions related to the datagram are performed in response to the action primitive. Because the algorithm-specific policing primitives are programmable, a network node can be adapted to implement a wide variety of policing algorithms. Additionally, multiple different policing algorithms can be implemented in hardware without the need for a different set of combinational logic for each different policing algorithm.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07957311&OS=07957311&RS=07957311
owner: Bay Microsystems, Inc.
number: 07957311
owner_city: San Jose
owner_country: US
publication_date: 20080310
---
This application is entitled to the benefit of provisional U.S. Patent Application Ser. No. 60 893 958 filed Mar. 9 2007 the disclosure of which is incorporated by reference herein in its entirety.

The invention relates generally to implementing policing algorithms for network traffic and more particularly to implementing programmable hardware based policing algorithms.

In addition to providing relatively high bandwidth network services to corporate clients network service providers are moving to offer bundled multimedia services e.g. voice video and data to residential customers. This move to bundled multimedia services has placed demands on the networking equipment at the edge of the network. Quality of Service QoS control is critical to providing bundled multimedia services and one important QoS function involves controlling the data rate provided to each user for each different traffic type. Controlling the data rate provided to each user for each different traffic type involves admission control and or bandwidth enforcement mechanisms both of which are generally referred to as traffic policing or traffic metering.

In a typical traffic policing application a service provider defines a traffic profile to which a customer s traffic needs to conform. Network traffic that is classified into the profile is then passed marked to a lower priority dropped and or identified as exceeding a bandwidth limitation. Some commonly used policing algorithms include single rate Three Color Marker srTCM two rate Three Color Marker trTCM and Metro Ethernet Forum MEF service policer. Additional policing algorithms include Frame Relay time based ATM leaky bucket and vendor proprietary policing algorithms.

In first generation network equipment traffic policing was typically implemented in software. Although software based policing solutions are flexible they are not able to process network traffic at the speeds required for current and emerging networks. In order to support the throughput requirements of current and emerging networks policing solutions have been implemented in hardware. Hardware based policing solutions reduce a policing algorithm to a set of condition primitives and corresponding action primitives in which the action primitives are generated in response to the condition primitives. Condition primitives may include for example a series of bits that indicate the incoming traffic color whether enough credits are available to forward a packet and whether a credit bucket is full. Action primitives may include for example a series of bits that indicate whether a credit bucket should be decremented to account for a forwarded packet whether a packet should be dropped or whether a credit bucket should be refreshed.

In conventional hardware based policing solutions combinational logic which is designed to implement one specific policing algorithm is fabricated into a semiconductor device. The combinational logic has no memory and is fixed at the circuit level. Because the combinational logic can only implement one policing algorithm a different set of combinational logic is required to implement each different policing algorithm. Additionally once a semiconductor device is fabricated the combinational logic cannot be changed to implement a different policing algorithm. While implementing a policing algorithm using fixed combinational logic enables high speed policing of network traffic fixed combinational logic does not provide the flexibility to adapt to support different policing algorithms.

A hardware based technique for policing traffic in a network node involves programming a set of algorithm specific policing primitives that establishes a relationship between condition primitives and action primitives and populating a searchable memory with a set of indexed action primitives. Action primitives are then selected from the searchable memory in response to condition primitives related to a received datagram. Policing actions related to the datagram are performed in response to the action primitive. Because the algorithm specific policing primitives are programmable a network node can be adapted to implement a wide variety of policing algorithms. Additionally multiple different policing algorithms can be implemented in hardware without the need for a different set of combinational logic for each different policing algorithm. Further the flexibility of the solution allows the network node to be programmed to implement various standardized policing algorithms as well as new policing algorithms that have not yet been developed.

A hardware based method for policing traffic in a network node involves receiving a programming input that defines a relationship between condition primitives and action primitives storing a set of indexed action primitives according to the defined relationship identifying a condition primitive in response to a datagram that is received at the network node generating an index from the condition primitive using the index to select an action primitive from the stored set of indexed action primitives and performing a policing action related to the datagram in response to the selected action primitive.

A hardware based system for policing traffic in a network node includes a programming interface configured to receive a programming input that defines a relationship between condition primitives and action primitives a system for obtaining a condition primitive related to a received datagram and a policing module configured to select an action primitive in response to the condition primitive and to perform a policing action related to the datagram in response to the selected action primitive. The policing module further includes a condition module configured to generate an index from a condition primitive that is related to a received datagram and an action module configured to select an action primitive in response to the index where the action module includes memory for storing a set of indexed action primitives according to the defined relationship.

Other aspects and advantages of the present invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

The set of algorithm specific policing primitives depicted in is established to implement one particular policing algorithm. For example the set of algorithm specific policing primitives is established to implement a policing algorithm such as srTCM trTCM or the MEF service policer. Additional sets of algorithm specific policing primitives may also be used to implement other policing algorithms. As will be described in more detail below a policing engine can be programmed to simultaneously store different sets of algorithm specific poling primitives that can be used by a network node to implement multiple different hardware based policing algorithms. In an embodiment the stored sets of algorithm specific policing primitives can be used to simultaneously implement different policing algorithms.

The classifier provides classification information to the policing engine . For example the classifier provides a policy identifier to the policing engine that is used to obtain a policy instruction. The policy instruction for a datagram identifies the policing algorithm to be used and the rate or rates that are to be applied to the datagram. In an embodiment the rate or rates that are to be applied to a datagram are identified in terms of credit bucket refresh rates. Alternatively the rate or rates can be identified using other techniques. The classifier also provides information that is used to identify credit bucket state information.

The bucket memory is a memory that stores state information related to credit buckets that are used to control traffic rates. For example the bucket state information is used to generate some aspect of a condition primitive. In an embodiment the bucket state information for each credit bucket is a 26 bit register value that indicates an amount of available credits. The bucket state information is provided to the policing engine and the policing engine provides updated bucket state information to the bucket memory. In an embodiment the bucket memory maintains bucket state information for each credit bucket that has been established. The number of credit buckets that the bucket memory can accommodate is dependent on the size of the bucket memory. In the bucket memory includes bucket state information for credit buckets 0 to n. Additionally the number of credit buckets can change over time. Although credit buckets are described herein as one example of a rate tracking mechanism other techniques can be used to implement rate tracking e.g. token buckets accumulators. The terms credit bucket bucket memory and bucket state information are used herein to refer to a mechanism for tracking the volume of traffic in terms of bits bytes megabits etc.

The policing engine manages the policing of traffic within the network node . For example policing operations involve tracking the volume of traffic on a per flow basis marking datagrams and or dropping datagrams. The policing engine includes a programming interface and a policing module that stores a searchable set of indexed action primitives . The programming interface enables a programming input to be provided to the policing module and information that is used to generate the searchable set of indexed action primitives is provided to the policing module through the programming interface. The searchable set of indexed action primitives is stored in a searchable memory within the policing module and is programmed to implement a policing algorithm according to a set of algorithm specific policing primitives as described with reference to . In particular the searchable set of indexed action primitives is populated within the policing module such that a condition primitive returns a corresponding action primitive as defined by a preprogrammed set of algorithm specific policing primitives. In an embodiment the programming input establishes a set of algorithm specific policing primitives as depicted in . In an embodiment the network node includes an application programming interface API that enables the programming of algorithm specific policing primitives.

The action module receives an index from the condition module and outputs an action primitive in response. The action module includes a searchable memory that stores indexed action primitives. In an embodiment the searchable memory stores at least one set of indexed action primitives that is programmed to implement one policing algorithm. In particular the set of indexed policing primitives is indexed to implement a policing algorithm according to a defined relationship between condition primitives and action primitives as described with reference to .

A set of indexed policing primitives that includes a column of indexes and a column of action primitives is depicted in . Indexes and action primitives on the same row correspond to each other. For example the index in row corresponds to the action primitive in row . The set of indexed action primitives includes an indexed action primitive that corresponds to each possible condition primitive. The action primitives may be different for each condition primitive or there may be action primitives that are the same for some condition primitives. The searchable memory is fully programmable via the programming interface to change the current set of indexed action primitives and to add or delete sets of indexed action primitives. In an embodiment the searchable memory includes multiple sets of indexed action primitives that are specifically programmed to implement different policing algorithms. Although the searchable memory is graphically depicted in as having rows and columns the searchable memory can be configured in any way that enables the use of an index to select a corresponding action.

As mentioned above the searchable memory can be programmed to include multiple sets of indexed action primitives that are specific to different policing algorithms. depicts the action module with four different sets of indexed action primitives that are simultaneously stored in the searchable memory of the action module. The four different sets of indexed action primitives are programmed to implement four different policing algorithms identified as policing algorithms 1 4. Although an example of an action module with four different sets of indexed action primitives is depicted in the number of different sets of indexed action primitives can be different. In an embodiment the number of sets of indexed action primitives is limited only by the size of the searchable memory. In an embodiment the sets of indexed action primitives are selected in response to the traffic classification.

Referring back to in operation a condition primitive e.g. a 4 bit condition primitive is identified by the policing engine in response to a packet that is received at the network node. For example a 4 bit condition primitive is generated in response to the color of a packet and a comparison of the packet length to bucket state information of two corresponding credit buckets. The 4 bit condition primitive is provided to the condition module and an index is generated in response. The index is provided to the action module and used to select an action primitive from the set of indexed action primitives that is stored in the searchable memory . The action primitive that is selected from the set of indexed action primitives is output from the action module. For example the action primitive is output as a 7 bit vector. Policing actions related to the packet are then performed in response to the action primitive. For example the policing actions may include changing the color of the packet decrementing a credit bucket related to the packet reporting a credit bucket failure e.g. when a packet length exceeds the available credits dropping the packet and marking the packet. A similar operation is performed for the condition primitives related to the buckets e.g. condition primitive from in which a policing action may include refreshing a credit bucket or credit buckets. Because the algorithm specific policing primitives are fully programmable a network node can be adapted to implement a wide variety of policing algorithms. Additionally multiple different policing algorithms can be implemented in hardware without the need for a different set of combinational logic for each different policing algorithm. Further the flexibility of the solution allows the network node to be programmed to implement new policing algorithms that have not yet been developed.

Examples of policing algorithms that can be implemented using the above described technique are described with reference to . depict two different sets of algorithm specific policing primitives that are used to implement a single rate Three Color Marker srTCM policing algorithm. illustrates a color blind implementation and illustrates a color aware implementation. Referring to the srTCM policing algorithm is implemented using two credit buckets credit bucket and credit bucket . Credit bucket is used to manage the Excess Burst Size EBS and credit bucket is used to manage the Committed Burst Size CBS with both buckets having the same refresh rate which is equal to the Committed Information Rate CIR as specified in the srTCM policing algorithm. Referring to the first subset of condition and action primitives the condition primitives include a 2 bit In Color primitive a 1 bit Fail primitive and a 1 bit Fail primitive. The 2 bit In Color primitive uses two bits to identify the color of a datagram e.g. red green or yellow . The 1 bit Fail primitive indicates whether or not credit bucket has enough credits to accommodate the datagram and the 1 bit Fail primitive indicates whether or not credit bucket has enough credits to accommodate the datagram. In the embodiment of a 0 indicates that the credit bucket does have enough credits i.e. a pass and a 1 indicates that the credit bucket does not have enough credits i.e. a fail .

Still referring to the first subset of condition and action primitives the action primitives include a 1 bit Dec primitive a 1 bit Dec primitive a 2 bit Out Color primitive a 1 bit Report Fail primitive a 1 bit Report Fail primitive and a Drop primitive. The 1 bit Dec primitive indicates whether or not credit bucket should be decremented e.g. by the corresponding datagram size the 1 bit Dec primitive indicates whether or not credit bucket should be decremented e.g. by the corresponding datagram size the 2 bit Out Color primitive indicates the color of the datagram upon output the 1 bit Report Fail primitive indicates whether a failure at credit bucket e.g. Fail 1 should be reported e.g. 0 indicates do not report a failure and 1 indicates report a failure the 1 bit Report Fail indicates whether a failure at credit bucket e.g. Fail 1 should be reported e.g. 0 indicates do not report a failure and 1 indicates report a failure and the 1 bit Drop primitive indicates whether or not the datagram should be dropped e.g. 0 indicates do not drop the packet and 1 indicates drop the packet .

In the second subset of condition and action primitives the condition primitives include a 1 bit Full primitive and a 1 bit Full primitive. The 1 bit Full primitive indicates whether or not credit bucket is full e.g. 0 indicates not full and 1 indicates full and the 1 bit Full primitive indicates whether or not credit bucket is full e.g. 0 indicates not full and 1 indicates full . The action primitives include a 1 bit Inc primitive and a 1 bit Inc primitive. The 1 bit Inc primitive indicates whether or not credit bucket should be incremented e.g. 0 is do not increment and 1 is increment and the 1 bit Inc primitive indicates whether or not credit bucket should be incremented e.g. 0 is do not increment and 1 is increment .

In an embodiment the set of algorithm specific policing primitives of are programmed into the network node of via the API and the programming interface. When a packet is received the packet is classified the srTCM policing algorithm is identified and bucket state information for the corresponding buckets is obtained from the bucket memory. A first condition primitive is identified in response to the received packet. In particular the condition primitive is generated in response to the color of the packet an in response to a comparison of the packet length to the available credits in buckets and as indicated by the bucket state information. The 4 bit condition primitive is used to generate an index and the index is used to select the corresponding action primitive as described above with reference to . Policing actions related to the packet are then performed in response to the action primitive.

A second condition primitive is identified in response to the fullness of credit buckets and . In particular the condition primitive is a 2 bit condition primitive that is generated in response to whether or not each credit bucket is full up to a maximum number of credits. The 2 bit condition primitive is used to generate an index and the index is used to select the corresponding action primitive as described above with reference to . Policing actions related to the packet are then performed in response to the action primitive. In an embodiment condition primitive is processed and the corresponding actions are taken before condition primitive is processed.

Referring to the color aware srTCM policing algorithm is implemented using the same condition and action primitives as in . The primary difference between the policing algorithm of and the policing algorithm of is that the action primitives are incoming color dependent.

While the above described technique can be used to implement various standardized policing algorithms the technique can also be used to implement non standard or vendor proprietary policing algorithms. For example a user can define a set of algorithm specific policing primitives to implement a customized policing algorithm. depict two different sets of algorithm specific policing primitives that are used to implement a non standard policing algorithm. The policing algorithm is implemented using two credit buckets credit bucket and credit bucket and traffic is classified to either flow or to flow . Credit bucket is used only by the traffic classified to flow and credit bucket is shared by traffic classified to both flow and flow . In other words flow uses both credit buckets but uses credit bucket first before using credit bucket and flow uses only credit bucket . This is a non standard technique for applying traffic policing. However with the programming flexibility described above this policing algorithm can be implemented using the sets of algorithm specific policing primitives of . In an embodiment two traffic profiles and corresponding policing instructions are also defined with the same rates and bursts. The first traffic profile uses the set of algorithm specific policing primitives of and is assigned to flow and the second traffic profile uses the set of algorithm specific policing primitives of and is assigned to flow . Both flows use the same bucket state information for buckets and .

In an embodiment a coupling flag may be used to associate multiple credit buckets with each other so that spill over credits from credit bucket are added to credit bucket up to credit bucket s maximum credit capacity. In other words if the coupling flag is set and if credit bucket exceeds its maximum credit capacity then the excess credits from credit bucket can be added to credit bucket as long as credit bucket does not exceed its maximum credit capacity. In an embodiment this is taken only when Inc is enables and independent of Inc. 

As used herein a primitive refers to a bit or bits that indicate a policing condition or a policing action. In particular a condition primitive refers to a bit or bits that indicate a condition related to traffic policing an action primitive refers to a bit or bits that indicate an action related to traffic policing and policing primitives refer to both condition and action primitives.

Although specific embodiments of the invention have been described and illustrated the invention is not to be limited to the specific forms or arrangements of parts as described and illustrated herein. The invention is limited only by the claims.

