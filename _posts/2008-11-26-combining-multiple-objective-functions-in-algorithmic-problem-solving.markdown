---

title: Combining multiple objective functions in algorithmic problem solving
abstract: Combining multiple objective functions to perform algorithmic problem solving is described. A first algorithm performs processing on a complex problem and generates multiple solutions to the problem. One or more solutions as generated by the first algorithm are send to one or more additional algorithms for further processing of complex sub-problems bounded by the first algorithm. The solutions to the first algorithm are used as input to the additional algorithms, where those solutions include at least one boundary condition under which the additional algorithms process the sub-problems. Ultimate solutions satisfy boundary conditions of the first algorithm, and all conditions of the additional algorithms. Algorithms may be executed in combinations of parallel and/or sequential operation to generate a final solution considering multiple different sub-problems to the complex problem.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08195496&OS=08195496&RS=08195496
owner: SAP Aktiengesellschaft
number: 08195496
owner_city: Walldorf
owner_country: DE
publication_date: 20081126
---
Embodiments of the invention are generally related to solving logistical problems and more particularly to combining multiple objective functions in algorithmic problem solving.

Portions of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. The copyright notice applies to all data as described below and in the accompanying drawings hereto as well as to any software described below Copyright 2008 SAP AG. All Rights Reserved.

Problems that involve combinations of multiple variables that can be manipulated independently are typically solved with processing intensive solution methods. Such a problem may be referred to as a logistical problem where the problem does not have a solution consisting of a simple yes or no or even an answer to a numeric calculation. Rather a set of solutions can be generated that satisfies each of the variables in different combinations creating multiple potential solutions. A problem solving system may include an algorithm that generates potential solutions to a logistical problem. As a general rule the solutions to logistical problems are based on heuristics for example where certain assumptions and or generalizations are made regarding an aspect of the logistical problem.

As an example consider supply chain management SCM where the logistics of the SCM includes planning and implementing the movement and storage of goods or services. A supply chain is a network of retailers distributors transportation service providers warehouses and suppliers that take part in the production delivery and sale of goods or services. The movement of goods and services through a supply chain may include shipment or transportation of goods from one location to another. The shipment of goods involves one or more vehicles such as trucks ships trains or airplanes and involves the planning of the arrangement of the goods to be shipped in the vehicle. The shipment of goods may involve complex constraints which are evaluated by the SCM logistics.

The goal of logistics is creating effective solutions to movement and storage problems knowing that perfect solutions may be infeasible given the number of considerations or variables at play. For example in goods transportation the movement of the goods involves among other things selecting a schedule for shipment selecting a carrier and loading the goods into the carrier s vehicles. Each aspect of this problem may be a logistical problem or logistical sub problem to the original logistical problem of transporting the goods. The SCM system may generalize or ignore certain constraints or conditions to simulate another. For example an SCM system may use generalized conditions for arrangement of goods for shipping e.g. ignoring whether crates used are stackable or ignoring specific geometries of shipping vehicles available . While ignoring or not considering certain specific conditions may be tolerable in certain instances it may not be desirable in other instances. For example certain unconsidered conditions may be considered significant in certain contexts e.g. generalizing costs of shipping instead of factoring exact shipping costs may be considered to generalize or ignore an important consideration .

Generalizing certain considerations as a rule may result in a problem solving system that fails to consider a condition deemed significant to a user of the system. Not having the ability to consider certain conditions may make the problem solving system less useful.

Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein. An overview of embodiments of the invention is provided below followed by a more detailed description with reference to the drawings.

Methods apparatuses and systems enable a problem solving system that combines multiple objective functions to perform algorithmic problem solving. Each objective function may be provided by an algorithm. A first or primary algorithm may generate multiple solutions based on general criteria with respect to at least one aspect of a problem. Secondary or slave algorithms can then generate solutions based on the solutions generated by the primary algorithm and further refined by detail criteria with respect to the one aspect of the problem that is evaluated generally by the primary algorithm. The combination of the algorithms is thus accomplished by executing the secondary algorithm with the solution to the primary algorithm as an input evaluated in relation to additional conditions not considered in detail by the primary algorithm.

In one embodiment the problem is a logistical problem. It will be understood that a logistical problem may generally include the movement of goods or the flow of services or any equivalent. Examples include the transportation of goods as discussed above for example in a supply chain context as well as military logistics that includes movement of resources including supplies and people as well as the flow of services for example in the energy sector. The combining of objective functions in algorithmic problem solving is not unique to logistics however. Those of skill in the art will understand that any algorithmic problem solving that involves making a generalization about a particular condition or variable could also benefit by performing problem solving as described herein.

More particularly a master process or master algorithm manages the flow of problem solving. The master process or algorithm is a module or functional block that receives the request to perform the problem solving processing and directs the execution of the algorithms to generate the solution s . The master algorithm initiates a base algorithm referred to as the primary algorithm above which generates baseline solutions to the problem. A baseline solution is one of multiple solutions that each satisfy all conditions of the base algorithm. However the base algorithm generalizes at least one factor of the problem meaning that all solutions satisfy the condition generally but are not solutions generated by evaluating detail criteria of the factor.

The master algorithm also initiates secondary algorithms which may be referred to as slave algorithms which evaluate solutions generated by the base algorithm for evaluation in light of additional conditions including detail criteria with respect to the one factor. The solution of the base algorithm thus acts as a bound or boundary condition for the slave algorithm or algorithms and all solutions to the slave algorithm must not only satisfy the detail criteria of the one factor but be within the solution of the base algorithm. Thus multiple solutions based on a general solution can be generated or a general solution can be evaluated for feasibility in light of additional considerations or conditions. From the perspective of each algorithm separately solving its own objective problem the base algorithm can be considered to generate solutions to the general problem and the slave algorithms generate solutions to sub problems within the general problem.

As an example consider a supply chain issue with transportation of goods. For purposes of example supply chain management SCM is used herein as the surrounding application domain. Additionally the solutions may apply to applications in the Logistics Service Providers LSPs domain. A general transportation plan may be generated as a solution to how to ship goods from one location to another but the transportation plan may fail to consider exact freight costs. It will be understood that a plan refers herein to a series or set of actions to be performed to execute the process. For example a transportation plan may specify time of a shipment of goods a shipment type vehicle type route etc. Rather than considering exact freight costs the general solution may use a set of generalized values that represents averages estimates or worst case scenarios instead of actual freight costs. The evaluation of the actual freight costs may include an additional number of factors that would make execution of the general solution infeasible if the actual costs were to be evaluated by the general solution. Instead a slave algorithm that algorithmically computes solutions based on real world freight costs can be used with solutions generated by the general algorithm as inputs to be considered in light of the detail criteria of actual freight cost information. The evaluation of actual freight costs is itself a problem requiring an algorithmic solution e.g. the solution is found through iterative processing in addition to the general algorithmic solution of the general algorithm.

All solutions or alternatively selected ones of the solutions could then be presented to a decision maker to determine one or more actions to perform in light of the solutions.

Problem solver includes reporting engine which represents one or more components that present solutions to a decision maker. In one embodiment the decision maker is an automated decision maker that may be part of problem solver as illustrated by decision maker or another part of system not explicitly shown . In one embodiment the decision maker is a human user which can interface with problem solver via user interface UI . The user may receive solution options solution results e.g. if an automated decision maker made a decision and other results in UI .

Problem solver is also connected to storage system which represents persistent storage where detail conditions or other additional information may be stored to provide conditions or considerations for one or more of the algorithms. Coordinator may exchange information with storage system storing and retrieving results or additional information . In one embodiment coordinator can retrieve information from storage system . Alternatively coordinator merely indicates the information to use and the algorithms themselves obtain the information from storage system . In one embodiment coordinator stores the results of one algorithm in storage system or a local memory not shown in system from which the results can be passed to or obtained by the algorithms for processing.

As shown by the lines with arrows coordinator selectively initiates execution of each of algorithms and . The algorithms can be executed in different orders and multiple iterations of the slave algorithms could be used. Each algorithm reports its results to coordinator either by directly passing the result or storing the result and indicating the storage location to the coordinator .

Another way to view system is that a combined planning problem exists which will be optimized by one objective function f. Function f returns several solutions n for the selected object function. The results of f are then evaluated by other objective functions f . . . fm where m is the number of objective functions which may typically be different from n. Each objective function can define additional restrictions. A planning algorithm is used to solve the problem for one of these objective functions.

As one possible practical example for consider a TMS transport management system or equivalent available from an enterprise system provider such as SAP AG of Walldorf Germany. Problem solving system represents the TMS which serves to generate transportation plans to provide solutions to transportation problems or scenarios. Coordinator may represent a master algorithm that is part of the TMS and coordinates the execution of various algorithmic processors that generate transportation solutions. Coordinator as the master algorithm has global control and receives the results of the base algorithm. Coordinator then distributes the results to the slave algorithms to perform different planning evaluation. An evaluation may consist of additional constraint checks or even solving a new optimization problem that depends on the solution of the base algorithm.

Algorithm may represent a base algorithm which may be an algorithm that is executed first to generate solutions that provide the boundaries or baseline for more detailed analysis. For example algorithm may represent a VSR vehicle selection and routing optimizer. Algorithms and as slave algorithms could provide for example VSO vehicle space optimization and TSP transportation service provider selection functions. It will be understood that optimize or other forms derived from that word do not necessarily mean that an absolute ideal solution will be obtained. Rather the process of optimization in the context of problem solving is generally understood to determine a best solution within given parameters including the information available the assumptions made the generalizations that are made the time or processing cycles allotted etc.

Specifically the run of a VSR optimizer may evaluate many different transportation plans and return at least a subset of the plans as results. In one embodiment results may be returned during the run asynchronously and other results may be returned after the run is finished. In one example algorithm performs the task of the transportation service provider TSP selection which is called by coordinator for each returned solution of the VSR optimizer. From a transportation business perspective the VSR optimizer determines good transportation plans with respect to consolidation of transportation orders into tours and the TSP selection algorithm assigns a TSP to each tour based on TSP costs. Algorithm performs Vehicle Space Optimization VSO which evaluates the solutions of the VSR optimizer to generate a solution with the best VSO value for the given VSR result. In this example there are two slave algorithms and the function of one of the slave algorithms may be the dominant one in the problem solving hierarchy.

There may be any of a number of ways to utilize problem solver with the example given 1 The VSR optimizer can first be executed to generate x solutions and all x solutions are evaluated by a Freight Costing slave algorithm to generate solutions where a solution with the lowest freight cost is selected 2 The VSR optimizer can first be executed to generate x solutions and all x solutions are evaluated by the TSP selection algorithm to generate solutions where a solution with the lowest TSP cost is selected 3 The VSR optimizer can first be executed to generate x solutions and all x solutions are evaluated by the VSO optimizer to generate solutions where the solution with the best VSO value is selected 4 The VSR optimizer can first be executed to generate x solutions where all x solutions are evaluated by a user defined function model as a slave algorithm that checks for additional constraints where the solution that best meets the user defined constraints is selected 5 The VSR optimizer can first be executed to generate x solutions where each solution is selectively evaluated by one or more of several objective functions where the solution is selected that provides a lowest value according to a weighted sum of solution evaluations etc. It will be understood that other examples are possible and multiple of the above use case examples may be combined.

The description above with reference to system of describes a general system on which embodiments of the invention may be implemented. A general description of certain details regarding the combining of multiple objective functions in algorithmic problem solving follows. Such details should be understood as being generally applicable to any embodiment set forth within this description.

In one embodiment not all solutions generated by the base algorithm are considered by a slave algorithm. Rather the base algorithm could be configured or directed through control command to output as a solution the result obtained for example after a certain amount of time or after a certain number of processing cycles or processing iterations within the iterative processing. Whatever solution is currently produced at the number of processing iterations or the amount of time can be returned as the solution. Alternatively the algorithm can make comparisons to store a solution and replace the stored solution if the compared solution is better than the stored solution. Thus at the completion of a period the algorithm could return a best solution for the period the interval of time or the number of processing iterations or computation cycles. In one embodiment the master algorithm receives the solution and compares it against other solutions generated by the base algorithm to determine if the solution is a duplicate of a solution already generated. If the solution is the same as one already used a next best solution could be used. In such an implementation either the algorithm would need to store two solutions or a comparison with the master algorithm may need to be made regularly or to compare every generated solution. While referencing a base algorithm the same could be applied to a slave algorithm that is generating multiple potential solutions to a problem.

Note that slave algorithms could be performed in parallel with the base algorithm or the base algorithm could for example collect a certain number of solutions over a period of time processing cycles or processing iterations and present all solutions at the end of processing. The slave algorithms could thus be executing concurrently with the base algorithm and processing solutions generated by the base algorithm or multiple slave algorithms could be initiated after the base algorithm completes its processing.

In one embodiment the base algorithm generates multiple potential solutions and the one or more slave algorithms perform operations to determine a feasibility of the solutions of the base algorithm. As used herein feasibility refers to an indication of how the solution compares to an ideal or optimum solution or a theoretically possible solution. In one embodiment the feasibility is a normalized value. The normalized value may be for example between 0 and 2 where 1 is an ideal or theoretical solution and anything less than 1 represents underutilization and anything more than 1 represents overutilization. As an alternative and as an illustration consider feasibility return values between 0 and 200 where a value n of 0 to 99 represents space left over in a shipping container e.g. 98 utilization of a container and where a value n of 101 to 200 represents a requirement for space in excess of the container s size e.g. requires 120 of the container . In another embodiment as described in more detail below feasibility checks may be weighted prior to being presented to the decision maker. Slave algorithms could instead provide additional solutions generating multiple potential solutions based on the solution of the base algorithm. For example a base algorithm may generate a plan which could be input into a slave algorithm that outputs a revised plan based on the detail considerations of the slave algorithm. A system could also have slave algorithms that generate solutions and other slave algorithms that generate feasibility checks. Thus combinations of the two can be employed within the same problem solving system.

In one embodiment the decision maker to which the master algorithm reports is a human user decision maker and the human user is presented with the generated solutions for selection of what solution s will be used. Alternatively the decision maker may be a machine or automated system that performs operations in response to the report indicating the solutions. In one embodiment weighting of results is used. Weighting the results may be particularly important for an implementation involving an automated decision maker where the weighting allows the automated decision maker to select a particular solution without human intervention. The weights can thus allow configuring a system to put importance on certain aspects of a problem or solution and thus select a solution based on what are the most significant considerations. When an automated decision is made the problem solving system may pass information to other systems issue commands or perform other operations or cause operations to occur in response to the identified solution s .

In one embodiment the factors to consider the algorithms to execute in which order and or the weights or system configuration can be dynamically modifiable with each execution of the system. In this way user preferences can be considered for different problems with the same problem solving system. Thus user configuration of the system is possible for each problem solving session allowing the system to adapt to differing conditions without having to modify the underlying problem solving system itself.

As briefly mentioned above algorithms can be executed in combinations of parallel and sequential execution. Parallel execution refers to multiple algorithms running concurrently. Parallel or concurrent execution does not necessarily imply that algorithms are started at the same time end at the same time use the same data to process or put any other restrictions on execution other than the fact that processing hardware may be configured and executing in accordance with multiple algorithms at a given point in time. For example a slave algorithm need not wait until a base algorithm generates all potential solutions prior to performing its own processing on one generated solution. In one embodiment multiple slave algorithms are initiated to process the same generated solution of the base algorithm. The different slave algorithms execute on the same solution based on different detail criteria. Thus the different slave algorithms process a different sub problem. The different slave algorithms may use the same boundary condition of the base algorithm and provide different solutions to it e.g. generalized vehicle optimization in the base algorithm could be solved in accordance with specific geometries and loading considerations of a fleet of vehicles for one carrier by one algorithm and for a different carrier by a second slave algorithm alternatively the second slave algorithm could consider actual vehicle availability schedules .

Additionally or alternatively the different slave algorithms may use different boundary conditions. For example a base algorithm may generalize two aspects that could be considered separate problems e.g. generalized freight costs versus real freight costs and generalized vehicle selection versus actual transportation carrier selection based on carrier availability and real world vehicle geometries etc. .

While such considerations may be processed in parallel they may also or alternatively be processed sequentially. Sequential algorithm execution refers to providing the output of the base algorithm as the input of a slave algorithm for example which slave algorithm output could then be provided as input to another slave algorithm. Such sequential processing may enable considering conditions of different aspects to generate a final solution that satisfies all conditions of the base algorithm and the two slave algorithms. In this way a slave algorithm may provide a boundary condition for a second slave algorithm. The detail criteria evaluated by the second slave algorithm is not considered in detail in either the base algorithm or the first slave algorithm.

As briefly set forth above in one embodiment the logistical problem could be or include finding a solution to a complex business process having multiple actions where each action has multiple potential conditions. The use of business processes with multiple potential actions is common in business systems e.g. scheduling problems and vehicle routing problems . Solving complex business process problems can include the base algorithm generating a plan for business process based on a simplified condition model. The simplified condition model provides a boundary condition and the slave algorithm indicates additional solutions to the business process plan that are within the boundary condition. For example the slave algorithm may generate solutions based on a complex condition model factoring real world condition properties.

An example of solving such a logistical problem includes the base algorithm generating a transportation plan for shipment of goods where the base algorithm generates a transportation plan based on a simplified linear freight cost model. The slave algorithm generates detailed solutions and or a feasibility check of the transportation plan based on a complex freight cost model factoring real world rates and geometric shipping properties. The real world rates may include pricing tables non linear rates and other complex considerations.

Another example of solving such a logistical problem includes the base algorithm generating a transportation plan for shipment of goods where the base algorithm generates a transportation plan based on a simplified vehicle space model. The slave algorithm then generates detailed solutions and or feasibility checks of the transportation plan based on a complex vehicle space optimization model factoring actual geometric shipping properties of goods and transportation equipment. Such complex modeling may include considering stackability of goods to be shipped three dimensional vehicle considerations as well as weight load etc.

In yet another example of solving such a logistical problem the base algorithm generates a transportation plan for shipment of goods where the base algorithm generates a transportation plan based on a simplified transportation service model. The slave algorithm then generates detailed solutions and or feasibility checks for the transportation plan based on a complex transportation service provider model factoring shipping routes and equipment availability.

Master algorithm includes several functional elements which provide the ability for master algorithm to perform multiple operations. More or fewer functions could be present in specific implementations of master algorithm . In general master algorithm coordinates the generating of a solution or solutions to a complex problem including coordinating the action of algorithm .

Request processor enables master algorithm to receive a problem and initiate the algorithm to find solutions for the problem. The request may be received for example through a user interface portion of an enterprise system. As is understood by those skilled in the art a user can input a request to perform an optimization or generate a plan to perform a business process or generate a logistics solution.

Algorithm initiator initiates algorithm and any other algorithms that will perform the computations to solve the requested problem. While a single algorithm is shown as previously described a base algorithm and one or more slave algorithms can be called in various combinations including parallel or sequential processing to generate solutions to the problems. The algorithms may be separate algorithms and or multiple instances of one or more of the algorithms. Algorithm initiator may indicate a location in memory and or storage where information is stored that will be used by algorithm to perform the processing. In one embodiment at least a portion of the information to be used by algorithm in the processing includes a data structure having one or more conditions to evaluate. The output of algorithm may likewise be a data structure that is passed to master algorithm or stored in memory or storage .

Result identifier enables master algorithm to indicate a generated result to an algorithm that will be initiated. Thus a result of a base algorithm or a slave algorithm can be passed or indicated to another slave algorithm for further processing based on additional parameters or considerations. Detail identifier enables master algorithm to pass the additional parameters or considerations to the slave algorithm for further processing to generate detail results. In the field of transport management a detail consideration may be to select vehicle type. The vehicle type could be selected from among vehicles within a company s fleet or based on a contract with an external carrier. In one embodiment the consideration of vehicle may include consideration of grouping and consolidating goods that will go to the same location or at least along the same route to a stop off location etc.

Results processor enables master algorithm to receive results from the algorithms and process the results for presentation to a decision maker not shown in system . Results processor may include filters to extract data from data structures application programming interfaces APIs to generate results to provide to a user interface and other functional elements. The processing of results by results processor may include weighting certain results. Weighting is discussed in more detail below with respect to weighting engine . In one embodiment weighting engine is part of results processor .

Reporting engine enables master algorithm to report the processed results to the decision maker. In one embodiment reporting may take one of three forms 1 presenting results to user who makes a selection or decision based on the results presented 2 weighting results and presenting or reporting the weighted results to an automated decision maker that selects a result as the solution based on weighting over individual objectives or 3 weighting results and presenting the weighted results to a user as suggested results based on weighted sums from which the user selects the result to use as the solution. Note that reporting can occur asynchronously as results are generated or synchronously after a certain period of time after a certain number of results are determined or some other trigger or event . Reporting can include presenting lists tables and or business objects and may include indicating key factors that were considered in generating the results.

Weighting engine enables master algorithm to selectively apply weights to results. For example based on all results of all involved slave algorithms master algorithm may rank all solutions according to predefined criteria. Assume as an example that a base algorithm minimizes objective function f and that slaves . . . n minimize the functions f fn respectively. Master algorithm could return a set of solutions ranked according to a weighted sum where result sum i 1 . . . n wi fi with predefined weights w . . . wn for functions f . . . fn. Alternatively master algorithm could use a hierarchical ranking where f is the first decision criterion f is only used if two plans are equivalent regarding f f is only used if two plans are equivalent regarding f etc. In either case master algorithm may weight the results based on a type of the solution. The type may be based on the algorithm that was used to create the solution or equivalently said the primary criterion being evaluated for the result . The summing allows the results of all functions applied by all slave algorithms to a particular solution generated by the base algorithm to be concatenated together.

The base algorithm s objective function f does not necessarily have to be the dominant function in a hierarchical ranking rather any ordering among the objective functions can define the hierarchy among the functions. In one embodiment the weights can actually be applied by the slave algorithms themselves. In another embodiment all solutions received from a particular slave algorithm class or type can be assigned a particular weight e.g. if multiple instances of a particular algorithm are executing the same weight may be applied to all solutions from all instances . Different algorithms may be given different weights. For instance solutions from a particular feasibility algorithm could be weighted by 0.8 while solutions from a different feasibility algorithm could be weighted by 0.2 based on a predefined decision that the solutions of the former feasibility algorithm are more significant than those of the latter feasibility algorithm.

Algorithm includes result accessor which enables algorithm to obtain results to use as bounds assuming the algorithm is a slave algorithm and will use the results of a previous algorithm. In the case of a base algorithm the results accessor may not be applicable. Data accessor enables algorithm to obtain additional information that will be applied in the processing of the solution again assuming algorithm is a slave. The additional information includes details or parameters not considered by the previous algorithm. The additional information could include tables lists data structures etc. to indicate consideration points for algorithm .

Algorithm also includes conditions which represents the total of all conditions that will be applied in the processing of the solution. Conditions may be considered to include data accessed by data accessor and additional conditions that are part of algorithm . In one embodiment the processing is iterative processing which refers to processing that may repeat one or more operations to refine and determine a solution that is at least partially dependent on a previous iteration of processing. Thus iterative processing may involve using an initial condition and repeating certain operations a number of times or until convergence of a solution with the intermediary result of the operations being the initial condition of the next iteration. Such processing is understood by those skilled in the art and will not be further discussed. Objective function represents the algorithmic core of algorithm that is executed to generate the solutions.

Various acting entities are represented across the top of the swimlane diagram as examples of entities that perform the various operations. A Master algorithm receives a request to process a problem . The Master algorithm initiates the Base algorithm to process the problem. Observe the blocks in the background of each entity under the descriptions of the operations. The background block represents when a particular entity is active. The Master algorithm is considered to be active for any time the problem solving system can be accessed. The Base algorithm initiates from the Master algorithm and processes until all of its solutions have been generated. Generating the solutions may take an amount of time or be a number of solutions found etc. The end of the base process is not illustrated in .

The Base algorithm begins operation and identifies the conditions associated with its execution . The conditions are generally information stored within the Base algorithm itself or somewhere within the problem solving system that indicates what the Base algorithm evaluates. The Base algorithm receives as input data that indicates specifics for the problem to be solved such as locations times quantities of goods services required resources affected etc. The Base algorithm processes the request based on the conditions and generates a result referred to as Result . The Base algorithm can then indicate Result to the Master algorithm and continue processing to generate other potential solutions.

The Master algorithm initiates one or more slave algorithms in response to receiving Result. For example Slave is initiated to process Result. Slave operates in parallel with the continued processing of the Base algorithm. Another slave algorithm not shown could also execute in parallel to Slave to process Result. The Base algorithm continues processing by processing the request further using the Result as a basis for its continued processing generating Result and indicating Result to the Master algorithm . Concurrently or in parallel Slave identifies the conditions associated with execution of Slave . The conditions of Slave include the bounds of Result. Slave processes the request to evaluate Result generates Result and indicates Result to the Master algorithm . Although shown as happening at substantially the same point in time there is no requirement or guarantee that the processing of Slave will generate Result at any time close to the Base algorithm generating Result but is merely shown as it is for convenience in description. The Base algorithm could produce many results in the time it takes Slave to process Result. Alternatively Slave could generate Result prior to the Base algorithm producing Result.

Note that while the Base algorithm continues to process Slave may actually stop executing after generating a result or a result set. Result could be a single result such as a feasibility check or it could represent one result of a set or the entire result set.

At some time after receiving Result from Slave the Master algorithm could initiate a sequential operation by Slave and potentially other slaves to process Result . Slave would then follow a similar pattern as the other algorithms and identify the conditions associated with its execution including obtaining Result and additional data or detail criteria to perform additional detail processing. Slave then evaluates Result and generates Result which is indicated to the Master algorithm .

The Master algorithm could also initiate another instance of Slave to process Result generated by the Base algorithm. The additional instance of Slave could actually execute in parallel to the first instance of Slave described above with regards to . Slave could then perform processing on that result.

Curve may contain hundreds or even thousands of points. Consider that the base algorithm is configured to output a solution every iterations or every minute of execution time for example. In one embodiment a master algorithm is configured to indicate how often the base algorithm should output a result. The solution points need not necessarily be evenly spaced although it is illustrated as evenly spaced in . In terms of results consider that under the general condition the lowest point is the most desirable outcome. In that case point appears to be the best solution to the problem given it lies lower on curve than any of the other output points. While there are other points on curve that lie lower than point they are not considered seeing they were not selected. In one embodiment a best solution over the time period is selected which may enable one of the lower points to be evaluated further in other implementations.

However if only the base algorithm were used as has been done traditionally a much better solution might be passed up. For example consider that the detail condition involves detail criteria that significantly alter what is considered to be the most important consideration. Consider that in relation to the detail condition the higher the point the better the solution. In such a case the solution of point could be evaluated and found to be the worst of the evaluated potential solutions lying down at point on the graph space. Instead the solution of point is evaluated and point is generated which produces the best solution.

Lastly consider points and of curve . Assume that these points represent the same solution. In one embodiment the solution of point is not passed for evaluation by the slave algorithm s because the solution is already evaluated at point . Instead a solution directly before or after or a next best solution could be sent for additional evaluation.

Various operations or functions are described herein which may be described or defined as software code instructions configuration and or data. The content may be directly executable object or executable form source code or difference code delta or patch code . The software content of the embodiments described herein may be provided via an article of manufacture with the content stored thereon or via a method of operating a communication interface to send data via the communication interface. A machine readable storage medium may cause a machine to perform the functions or operations described and includes any mechanism that stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . A communication interface includes any mechanism that interfaces to any of a hardwired wireless optical etc. medium to communicate to another device such as a memory bus interface a processor bus interface an Internet connection a disk controller etc. The communication interface can be configured by providing configuration parameters and or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.

Various components described herein may be a means for performing the operations or functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc.

Besides what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be considered in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

