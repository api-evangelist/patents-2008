---

title: Microprocessor shifter circuits utilizing butterfly and inverse butterfly routing circuits, and control circuits therefor
abstract: Microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits, and control circuits therefor, are provided. The same shifter circuits can also perform complex bit manipulations at high speeds, including butterfly and inverse butterfly operations, parallel extract and deposit operations, group operations, mix operations, permutation operations, as well as instructions executed by existing microprocessors, including shift right, shift left, rotate, extract, deposit and multimedia mix operations. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08285766&OS=08285766&RS=08285766
owner: The Trustees of Princeton University
number: 08285766
owner_city: Princeton
owner_country: US
publication_date: 20080523
---
The present application claims the priority of U.S. Provisional Application Ser. No. 60 931 493 filed May 23 2007 the entire disclosure of which is expressly incorporated herein by reference.

The present invention was made with government support under Department of Defense Grant No. H98230 04 C 0496. Accordingly the Government has certain rights to the present invention.

The present invention relates to circuitry for computer systems and more specifically to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits and control circuits therefor.

Bit manipulation operations are important features of modern microprocessors. Unfortunately bit manipulation operations carried out by existing microprocessors are limited in terms of flexibility and ease of implementation at the hardware level. For example bit manipulation operations performed by existing microprocessors are often limited to shift and rotate operations. Since a microprocessor is typically optimized around the processing of words i.e. fixed length groups of binary bits of information it is not surprising that bit level operations are not well supported by current word oriented microprocessors. Simple bit parallel Boolean operations such as AND OR XOR and NOT are usually supported as the logical operations of the Arithmetic Logic Unit ALU the most fundamental functional unit of a microprocessor. However only very simple non bit parallel operations are supported such as shift and rotate operations in which all bits of an operand move by the same amount. These operations are usually supported by separate shifter functional units.

A few microprocessor Instruction Set Architectures ISAs have more advanced bit operations. However these operations are implemented by complex shifter functional unit circuitry which appreciably adds to the size and complexity of the microprocessor. Examples of such operations include subword extract and deposit operations e.g. pextrw and pinsrw operations in the INTEL IA 32 ISA field extract and deposit operations e.g. extr and dep operations in HEWLETT PACKARD PA RISC or INTEL IA 64 ISAs or rotate and mask operations e.g. rldimi in POWERPC ISA . These can be viewed as variants of the basic shift or rotate operation operations with certain bits masked out and set to zeros or sign bits replicated or bits from a second operand merged into the result. Additionally some instruction sets have multimedia permute operations that rearrange the subwords packed into one or more registers e.g. mix operation in HEWLETT PACKARD PA RISC 2.0 and INTEL IA 64 architectures .

There are also many emerging applications such as cryptography imaging and bioinformatics where even more advanced bit manipulation operations are needed. While circuitry to achieve these operations can be built by assembling simple logical and shift operation circuits or by implementing same in firmware such approaches often result in very large circuits or slow execution speeds. Applications using these advanced bit manipulation operations would thus be significantly sped up if the processor were able to support more powerful bit manipulation instructions. Such operations include arbitrary bit permutations bit gather operations performing multiple bit field extract operations in parallel and bit scatter operations performing multiple bit field deposit operations in parallel .

Accordingly what would be desirable but has not yet been provided are shifter circuits utilizing butterfly and inverse butterfly circuits and control circuits therefor which address the foregoing shortcomings of existing microprocessors.

The present invention relates to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits and control circuits therefor. The shifter circuits can be implemented in existing microprocessors and allow for complex bit manipulations to be performed by such microprocessors at high speeds. The shifter circuits can perform butterfly and inverse butterfly operations parallel extract and parallel deposit operations group operations mix operations bit permutation operations as well as instructions executed by existing microprocessors. The shifter circuits can replace existing shifter circuits in microprocessors so as to provide new ways for conducting existing shift rotate extract deposit and mix operations as well as more advanced bit manipulation instructions. The shifter circuits can be implemented with a reduced amount of circuitry thus conserving chip space. User applications relating to steganography binary image morphology transfer coding bioinformatics imaging and integer compression techniques among other applications can be implemented using the shifter circuits of the present invention. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation processes.

The present invention relates to microprocessor shifter circuits utilizing butterfly and inverse butterfly circuits and control circuits therefore for performing complex bit manipulations at high speeds. The shifter circuits can perform butterfly and inverse butterfly operations parallel extract and parallel deposit operations group operations mix operations permutation operations as well as instructions executed by existing microprocessors. The shifter circuits can be provided in various combinations to provide microprocessor functional units which perform a plurality of bit manipulation processes.

The shifter circuits and could be implemented in a microprocessor individually or they could be connected to each other to form a Benes network which is a general permutation network. The butterfly configuration of the circuit is referred to herein as bfly and the inverse butterfly configuration of the circuit is referred to herein as ibfly. A single execution of bfly followed by ibfly or vice versa can achieve any of the n permutations of n bits in at most 2 instruction cycles of a microprocessor.

The circuits shown in represent n bit circuits of lg n stages wherein each stage comprises n 2 2 input switches n being any desired bit width generally a power of 2 . Each of these circuits takes at most one processor cycle since they are less complicated than an ALU of the same width a processor cycle is assumed to be normalized to the latency of an ALU . Further as discussed in greater detail below each switch is composed of two 2 1 multiplexers totaling n lg n multiplexers for each circuit which results in small circuit area.

Each of the circuit stages of has n 2 switches with a pair of inputs going into each switch and a pair of outputs coming out. For each switch the inputs either pass through to the outputs or they are swapped as shown in described below. In the ith stage i starting from 1 the paired bits are n 2positions apart for the butterfly circuit shown in and 2positions apart for the inverse butterfly circuit shown in . A switch either passes through or swaps its inputs based on the value of a control bit. Thus the operation requires n 2 lg n control bits. For n 64 four 64 bit registers are required to hold the 64 data bits and the 32 6 control bits.

An embodiment of the present invention provides an architecture that has only 2 source operands per instruction and which utilizes 3 Application Registers ar.b ar.b ar.b associated with the functional unit to supply the control bits during the execution of these instructions. Application Registers are registers which are already available in some Instruction Set Architectures also abbreviated ISAs such as the INTEL IA 64 ISA. The control bits are determined either statically by a compiler or dynamically by software. Other permutation primitives like grp discussed below do not require Application Registers. An arbitrary permutation of the n bits within a register can be performed by a sequence of at most lg n grp instructions or by a sequence of at most 2 instructions using bfly and ibfly instructions. The latter bfly and ibfly achieve arbitrary n bit permutations in O 1 cycles rather than O lg n cycles.

The present invention can support a number of bit manipulation operations which could be implemented as instructions which are added to the existing instruction set of a microprocessor. These instructions are summarized in Table 1 below 

The conventional shifter instructions executed by existing microprocessors and listed in the top half of Table 1 above i.e. above the dotted line in Table 1 can also be implemented by the present invention since they are all based upon rotation operations. The additional functions implemented by the present invention are listed in the bottom half of Table 1 i.e. below the dotted line in Table 1 . An inverse butterfly circuit can achieve any rotation cyclic shift of its input and can perform the following on its input right and left shifts extract operations deposit operations and mix operations. These operations can be modeled as a rotate operation with additional logic handling zeroing or sign extension from an arbitrary position or merging bits from the second source operand for deposit . Mix operations can be modeled as a rotate of one operand by the subword size and then a merge of subwords alternating between the two operands. Since inverse butterfly circuits only perform permutations without zeroing and without replication an extra 2 1 multiplexer stage at the end of the shifter circuits of the present invention either selects the rotated bits as is or other bits which are computed as either zero or the sign bit replicated or the bits of the second source operand depending on the operation.

The generation of control bits for the shifter circuits of the present invention is now discussed with reference to . To achieve a right or left rotation by s positions for s 0 1 2 . . . n 1 using the n bit wide inverse butterfly circuit with lg n stages the input must be right or left rotated by s mod 2within each 2 bit wide inverse butterfly circuit at each stage j. This is because from stage j 1 on the inverse butterfly circuit can only move bits at granularities larger than 2positions so the finer movements must have already been performed in the prior stages .

An n bit inverse butterfly circuit can be viewed as two lg n 1 stage circuits followed by a stage that swaps or passes through paired bits that are n 2 positions apart. To right rotate the input in . . . in by s positions the two lg n 1 stage circuits must have right rotated their half inputs by s s mod n 2 and the input to stage lg n must be of the form in. . . inin. . . in in. . . inin. . . in 1 

As shown at in when the rotation amount s is less than n 2 then the bits that wrapped around in the lg n 1 stage circuits indicated by hatching in must be swapped in the final stage to yield the input right rotated by s in. . . inin. . . in in. . . inin. . . in 2 When the rotation amount is greater than or equal to n 2 then the bits that do not wrap in the F lg n 1 stage circuits solid must be swapped in the final stage to yield the input right rotated by s as illustrated at in in. . . inin. . . in ininin. . . in. 3 

For example consider the 8 bit inverse butterfly circuit with right rotation amount s 5 depicted in . As s 5 is greater than n 2 4 the bits that did not wrap in stage 2 are swapped in stage 3 to yield the final result. As the rotation amount through stage 2 s mod 2mod 4 1 is less than n 4 2 the bits that did wrap in stage 1 are swapped in stage 2 to yield the input to stage 3. As the rotation amount through stage 1 s mod 2 5 mod 2 1 is equal to than n 8 1 the bits that did not wrap in the input i.e. all the bits are swapped in stage 1 to yield the input to stage 2.

One can mathematically derive recursive equations for the control bits cb j 1 2 . . . lg n for achieving rotations on an inverse butterfly datapath. These equations yield the compact circuit shown in for the rotation control bit generator. The process for generating these equations is now discussed.

From Equations 1 3 and it is observed that the pattern for the control bits for the final stage which is referred to as Cb for a rotate of s bits is 

Due to the recursive structure of the inverse butterfly circuit Equation 5 can be generalized by substituting j for lg n 2for n and 2for n 2 

Since s mod k k 1 k s mod k 1 and hence the length of the string of zeros in Equation 8 is always 1 k 2 . Consequently the least significant bit of the pattern prior to XOR with s is always 0 1 0 0 1 0 s 9 

The bit pattern inside the inner parenthesis of the bottom Equation 9 is referred to as s j a string of 2 1 bits with the s mod 2leftmost bits set to 1 and the remaining bits set to 0. This function is only defined for j 2 and returns the empty string for j 1.

Since s j is a string of 2 1 bits we can replace the string of ones in the lower Equation 15 by s j ORed with 0 or 1 respectively. Similarly we can replace the string of zeros in Equation 15 by s j ANDed with 0 or 1 respectively. The value of sdetermines whether 0 or 1 is used 

Equation 11 shows a method for getting the j 2 control bits cbfor the switches in any stage j of the inverse butterfly circuit using a recursive function f s j and a bit sfrom the shift amount s. This can also be seen in described below. For a rotation every bit moves by the same amount namely the shift amount s. Hence the control bits to subsets of switches belonging to the smaller inverse butterfly circuits up to that stage are the same.

Referring to which show an 8 bit inverse butterfly circuit the 1 bit control bits cb from goes to four switches in stage 1 that pair bits that are 1 bit apart which represent four 2 bit inverse butterfly circuits. The 2 bit control bits cb for stage 2 go to four switches that pair bits that are 2 bits apart which together with stage 1 represent two 4 bit inverse butterfly circuits. The 4 bit control bits cb for stage 3 go to four switches that pair bits that are 4 bits apart which together with stages 1 and 2 represent the 8 bit inverse butterfly circuit. Equation 11 and show how these control bits cbfor each stage j can be generated using the recursive function f s j described in Equation 17.

Equation 11 provides that the control bits cbare generated by taking the recursive function f s j and Exclusive OR it with a bit from the shift amount s and concatenate the result with s. Equation 17 then describes how the function f s j can be recursively generated from the same function for the previous stage f s j 1 . This uses the OR function and the AND function with f s j 1 . The recursive function f s j is derived by f s j 1 OR with s concatenated with s then concatenated with f s j 1 AND with s. This can also be seen in the hardware realization in described below. It should be clear that other embodiments of control bit generation for doing rotations on an inverse butterfly circuit or on a butterfly circuit are possible.

Discussion of the use of these equations is now provided with the example of the 8 bit inverse butterfly circuit with right rotation amount s 5 sss 101 . The first stage control bit cb replicated for the four 2 bit circuits is given by Equations 11 and 17 and expressed as follows 5 1 1 18 

The other operations shifts extract deposit and mix shown in Table 1 above can be modeled as a rotation part plus a masked merge part with zeroes sign bits or second source operand bits. The rotation part can use the same rotation control bit generator described above to configure the inverse butterfly circuit datapath. The masked merge part can be achieved by using an enhanced inverse butterfly datapath with an extra multiplexer stage added as the final stage. The mask control bits are 0 when selecting the rotated bits and 1 when selecting the merge bits.

For a right shift by s the s sign or zero bits on the left are merged in. This requires a control string 1 0for the extra multiplexer stage. From the definition of s j it can be seen that s lg n 1 is the string 1 0. Thus the desired control string is given by s lg n 1 0 recall that s

For extract operations which are like right shift operations with the left end replaced by the sign bit of the extracted field or zeros the inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or zeros or the sign bit of the extracted field i.e. the bit in position pos len 1 in the source register see at . The bit can be selected using an n 1 multiplexer. The control bit pattern for this stage is n len 1 s followed by len 0 s 1 0 to propagate the sign bit of the extracted field in the output which is in position len 1 to the high order bits. Note that cb len len lg n 1 len len1 0 as len ranges from 0 to n and has lg n 1 bits len . So reversing left to right cb len yields 0 1and then negating it produces 1 0 the correct bit pattern for stage lg n 1.

For deposit operations which are like left shift operations with the right and left ends replaced by zeros or bits from the second operand the inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or zeros or bits from the second input operand. The correct pattern is a string of n pos len 1 s followed by len 0 s followed by s pos 1 s 1 0 1 to merge in bits on the right and left around the deposited field. cb pos len pos len lg n 1 pos len pos len is 1 0 as pos len ranges from 0 to n and has lg n 1 bits pos len . Reversing left to right this string yields 0 1and then negating it produces 1 0. Bitwise ORing this with the left shift control string 0 1 yields 1 0 1 the correct pattern for the masked merge part of the deposit operation is produced.

For mix operations the enhanced inverse butterfly circuit of the present invention selects in its extra multiplexer stage the rotated bits or the bits from the second input operand. The control bit pattern is simply a pattern of alternating strings of 0 s and 1 s the precise pattern depending on the subword size and whether mix left or mix right is executed. These patterns can be hard coded in the circuit for the 12 mix operations 6 operand sizes 2 directions .

The inverse butterfly circuit implemented by the present invention can perform a parallel extract pex operation. The inverse butterfly circuit is decomposed into even and odd subcircuits. As shown in the even subcircuits are shown with dotted lines and the odd subcircuits with solid lines. These can also be called right and left subcircuits. For simplicity and clarity of notation even subcircuits are referred to herein as R right and odd subcircuits as L left . The circuit of is similar to the inverse butterfly circuit shown in and includes a register input and three circuit stages . The proof in support of implementing pex on an inverse butterfly circuit is provided as follows 

Any single data bit can be moved to any result position by just moving it to the correct R or L subcircuit of the intermediate result at every stage of the inverse butterfly circuit.

This can be proved by induction on the number of stages. At stage 1 the data bit is moved to its final position mod 2 i.e. to R or L . At stage 2 it is moved to its final position mod 4 and so on. At stage lg n it is moved to its final position mod 2 n which is its final result position.

A permutation is routable on an inverse butterfly circuit if the destinations of the bits constitute a complete set of residues mod m i.e. the destinations equal 0 1 . . . m 1 mod m for each subcircuit of width m.

Based on Fact 1 bits are routed on the inverse butterfly circuit by moving them to the correct position mod 2 after the first stage mod 4 after the second stage etc. Consequently if the two bits entering stage 1 with 2 bit wide inverse butterfly circuits as shown in have destinations equal to 0 and 1 mod 2 i.e. one is going to R and one to L Fact 1 can be satisfied for both bits and they are routable through stage 1 without conflict. Subsequently the four bits entering stage 2 with the 4 bit wide butterfly circuits must have destinations equal to 0 1 2 and 3 mod 4 to satisfy Fact 1 and be routable through stage 2 without conflict. A similar constraint exists for each stage.

Any Parallel Extract instruction on n 2bits can be implemented with one pass through an inverse butterfly circuit of lg n stages without path conflicts with the un selected bits on the left zeroed out .

The pex operation compresses bits in their original order into adjacent bits in the result. Consequently two adjacent selected data bits that enter the same stage 1 subcircuit must be adjacent in the output. In other words one bit has a destination equal to 0 mod 2 and the other has a destination equal to 1 mod 2 the destinations constitute a complete set of residues mod 2 and thus are routable through stage 1. The selected data bits that enter the same stage 2 subcircuit must be adjacent in the output and thus form a set of residues mod 4 and are routable through stage 2. A similar situation exists for the subsequent stages up to the final n bit wide stage. No matter what the bit mask of the overall pex operation is the selected data bits will be adjacent in the final result. Thus the destination of the selected data bits will form a set of residues mod n and the bits will be routable through all lg n stages of the inverse butterfly circuit.

Parallel deposit can be performed using the butterfly circuit of the present invention since the parallel deposit operation is the inverse of the parallel extract operation. Also the grp operation discussed above can be mapped to two parallel inverse butterfly circuits since grp is a combination of a grp right or pex and a grp left a mirrored pex .

A decoder for the parallel extract and parallel deposit instruction takes as its input the n bit mask and produces the n 2 lg n control bits for the inverse butterfly or butterfly circuit. The decoder can be designed to consist of only two types of operations that can be performed in software or implemented as circuits a parallel prefix population counter which counts the ones from position 0 on the right to every bit position from 0 to n 2 and a set of left rotators that complement bits upon wraparound LROTC Left ROTate and Complement . The theoretical underpinnings for a parallel extract decoder are discussed below in connection with .

X is the rightmost bits of R as the output of pex is the selected data bits compressed and right justified in the result. Y is rotated left from the midpoint by the size of X X at the input to the final stage so that when it is swapped into R in the final stage it is contiguous to X on its right. Z is the rightmost bits in L at the input to the final stage so that when it is passed through in L it is contiguous with the bits in R. Thus the control bit pattern for the final stage is 1 0 where 1 denotes swap and 0 denotes pass through of the paired bits in L and R in the last stage. X is equal to the count of 1 s in the right half of the bit mask as all the selected data bits in the right half of the input have already been compressed and right justified prior to the input to the final stage. This pattern can be generated by a left rotate and complement on wraparound LROTC operation of the one string of length n 2. For every position in the rotation a 1 is wrapped around from the left and complemented to obtain a 0 on the right. The end result after a LROTC by X bits is a string with the X rightmost bits set to 0 and the rest set to 1. 

Referring to the top row of Y and Z can be viewed as having been left rotated by X from being the rightmost bits of L at the output of stage lg n 1. Consequently it is possible to iterate backwards through the stages performing a pex operation within each half subcircuit and then explicitly left rotate each local L at the input of the next stage by the number of selected data bits in the local R at the input of the next stage prior to the swapping or passing through of bits in this next stage.

Rather than rotating the data bits explicitly it is possible to compensate for the rotation by modifying the routing through the subsequent stages. This can be achieved by rotating the control bits by the same number of positions complementing upon wraparound LROTC . These rotations are propagated forward. Consequently the control bits for a stage obtained by a LROTC of the one string by the count of 1 s in the right half of the local bit mask are further modified by a LROTC operation by the count of 1 s in the right half of the next larger local bit mask and so on. The result is a single LROTC operation of the one string by count of 1 s in the right half the local bit mask through bit the least significant bit. Overall the counts are needed of the k rightmost bits for k 0 to n 2 the set of prefix population counts.

The counting of the number of 1 s is done in parallel by the Parallel Prefix Population Count operation while the rotation is done by the LROTC operation at each stage. The full decoding algorithm which could be performed in hardware or software is given below 

It is noted that three classes of parallel extract and parallel deposit instructions can be handled by the present invention. The first consists of static versions of these instructions where software or the compiler pre decodes the mask in the second source register into control bits for the datapath and moves the control bits into the Application Registers ARs or any registers that may be used to control the ibfly circuit. This uses the mov instruction in Table 1 followed by the pex or pdep instructions. The second class is dynamic mask decoding by a hardware implementation of the decoder of . This uses the pex.v or pdep.v instructions in Table 1. The third class is loop invariant pex and pdep. Here the mask is known only at runtime but remains fixed for a long input stream. The hardware decoder of can output the control bits to the application registers once and subsequently the static versions of pex and pdep are used. This uses the setib and setb instructions in Table 1 followed by static pex or pdep instructions.

The merge and mask control bits implemented by masked merge unit of include those summarized in Table 2 above. The merge bits can be 

The mask control bits are 0 when selecting the rotated bits output from the butterfly or inverse butterfly circuit and 1 when selecting the merge bits. The patterns are 

Table 3 below presents a high level comparison of the present invention to known barrel and log shifter designs 

The first two lines of Table 3 contain the components that contribute to circuit area. Both the log shifter and the inverse butterfly version of the present invention have n lg n elements while the barrel shifter has nelements. The log shifter also has the fewest control lines lg n while the present invention has the most as each switch or pair of elements requires an independent control bit. The next two lines pertain to latency. The datapath of the barrel shifter has a single gate delay while the log shifter and the present invention have lg n gate delay. However both the log shifter and the present invention utilize narrow multiplexers with lower capacitance at output nodes.

The method of logical effort was first used to compare the delay along the critical paths for the barrel shifter the log shifter and the inverse butterfly shifter. This estimated the critical path in terms of FO4 gate equivalents which is the delay of an inverter driving 4 similar inverters. The latency of only the basic shifter operations on these datapaths was compared. As the 64 bit barrel shifter is impractical due to the capacitance on the output lines a 64 bit shifter was implemented as an 8 byte barrel shifter followed by an 8 bit barrel shifter which limits the number of transmission gates tied together to 8. The delay only from the input to the decoder through the two shifter levels for the barrel shifter and through the three shifter levels for the log shifter was considered.

For the present invention the delay from the input to the control bit generator i.e. the rotation control bit generator of through the output of the inverse butterfly circuit was considered. According to the logical effort calculations the delay for the barrel shifter is 15.1 FO4 and the delay for the log shifter is 13.0 FO4 while the delay for inverse butterfly shifter is 15.5 FO4. Thus the delay along the critical path for the barrel shifter and the present invention is comparable and the present invention is 19 slower than a log shifter. Note that this is only a rough estimation of delay along the critical path without circuit optimization. Custom circuit design of the present invention will result in a much faster circuit.

Since the log shifter is the faster and more compact of the two current shifter designs it was implemented for testing purposes along with the present invention using a standard cell library. All designs were synthesized to gate level optimizing for shortest latency using Design Compiler mapping to a TSMC 90 nm standard cell library. The results are summarized in Tables 4 6 below.

Table 4 shows the result of a basic shifter that only implements shift and rotate instructions. For the log shifter parallel datapaths were implemented for left and right shifts. The present invention has 1.18 the latency of the log shifter which is similar to the logical effort calculation. The present invention is also smaller than the log shifter at approximately 70 of the area note that a single datapath log shifter would have smaller area additionally accounting for the wires will increase the area for the ibfly based shifter relative to the log shifter as mentioned . For comparison we also implemented an ALU supporting add subtract and or not xor with register or immediate operands synthesized using the same standard cell library. The present invention is faster 92 latency and smaller 52 area than this ALU.

Table 5 shows the result when both shifter architectures are enhanced to support extract deposit and mix instructions. The critical path of the log shifter is now through the extract sign bit propagation so the latency is now comparable to that of the inverse butterfly based shifter of the present invention. The present invention is still only 83 of the area of the log shifter. The results for an ALU of similar latency are also included which has a comparable circuit area in NAND gate equivalents .

Table 6 shows the results when support is added to the present invention for advanced bit manipulation operations but not to the log shifter. The first line in table 6 represents the log shifter circuit from Table 5 included as the baseline. The second line is a unit that supports the ibfly and static pex instructions. The functionality of the butterfly circuit can be emulated using inverse butterfly albeit with a multi cycle penalty. The latency increases are due to extra multiplexing for the control bits and output. The area increases due to the ARs the extra multiplexers and the pex masking. This unit has 1.18 the latency and 1.29 the area of the log shifter. The third line in Table 6 is a unit that also supports butterfly and static pdep. The latency increases slightly due to output multiplexing and the area increases due to the second butterfly datapath and second set of three ARs. This unit has 1.20 the latency and 1.87 the area of the log shifter. Alternatively a separate unit can be added to perform just bfly and pdep line 4 in Table 6 thereby enabling simultaneous superscalar execution with the ibfly pex shifter unit line 2 in Table 6 . It can be seen that the shift permute unit of the present invention line 3 in Table 6 can be split into two units at no additional increase in area. The results for an ALU of similar latency are also included wherein the ALU is smaller than the log shifter due to the relaxed latency constraint. The shift permute unit line 3 now has 2.25 the area of the ALU but smaller sizes are possible.

In each half of stage 2 we transfer from the local R to the local L the bits whose final destination is in the local L. So in R we transfer g to Rand in L we transfer d to L. Prior to stage 3 we right rotate the bits to right justify them in their original order in their new subnetworks. So d0 is tight rotated by 1 the number of bits that stayed in L to yield 0d and gf is right rotated by 1 the number of bits that stayed in R to yield fg.

In each subnetwork of stage 3 we again transfer from the local R to the local L the bits whose final destination is in the local L. So in Lwe transfer d and in Lwe transfer e. After stage 3 we have transferred each bit to its correct final destination d0e0fg0h. Note that we use a control bit of 0 to indicate a swap and a control bit of 1 to indicate a pass through operation. Rather than explicitly right rotating the data bits in the L half after each stage we can compensate by modifying the control bits. This is shown in .

Provided below is an explanation as to how the pdep operation can be mapped to the butterfly circuit 

Any single data bit can be moved to any result position by moving it to the correct half of the intermediate result at every stage of the butterfly circuit.

This can be proved by induction on the number of stages. At stage 1 the data bit is moved within n 2 positions of its final position. At stage 2 it is moved within n 4 positions of its final result and so on. At stage lg n it is moved within n 2 1 position of its final result which is its final result position. Referring back to Fact 3 is utilized to decide which bits to keep in R and which to transfer from R to L at each stage.

If the mask has k 1 s in it the k rightmost data bits are selected and moved i.e. the selected data bits are contiguous. They never cross each other in the final result.

This fact is by definition of the pdep instruction. See the example of where there are 5 1 s in the mask and the selected data bits are the 5 rightmost bits defgh these bits are spread out to the left maintaining their original order and thus never crossing each other in the result.

If a data bit in the right half R is swapped with its paired bit in the left half L then all selected data bits to the left of it will also be swapped to L if they are in R or stay in L if they are in L .

Since the selected data bits never cross each other in the final result Fact 4 once a bit swaps to L the selected bits to the left of it must also go to L. Hence if there is one 1 in the mask the one selected data bit do can go to R or L. If there are two 1 s in the mask the two selected data bits dd can go to RR or LR or LL. That is if the data bit on the right stays in R then the next data bit can go to R or L but if the data bit on the right goes to L the next data bit must also go to L. If there are three 1 s the three selected data bits ddd can go to RRR LRR LLR or LLL. For example in stage 1 of the five bits have the pattern LLRRR as e is transferred to L and d must then stay in L.

The selected data bits that have been swapped from R to L or stayed in L are all contiguous mod n 2 in L.

From Fact 5 the destinations of the k selected data bits d. . . dmust be of the form L . . . LR . . . R a string of zero or more L s followed by zero or more R s. Define X as the bits staying in R Y as the bits going to L that start in R and Z as the bits going to L that start in L. It is possible that 

The structure of the butterfly circuit requires that when bits are moved in a stage they all move by the same amount. Fact 4 states that the selected data bits are contiguous. Together these imply that when Y alone exists or X and Y exist ii and iii Y is moved as a contiguous block from R to L and Fact 6 is trivially true.

When X and Z exist iv Z is a contiguous block of bits that does not move so again Fact 6 is trivially true.

When X Y and Z exist v Y comprises the leftmost bits of R and Z the rightmost bits in L since they are contiguous across the midpoint of the stage Fact 4 . When Y is swapped to L since the butterfly circuit moves the bits by an amount equal to the size of L or R in a given stage Y becomes the leftmost bits of L. Thus Y and Z are now contiguous mod n 2 i.e. wrapped around in L as shown in . Thus Fact 6 is true in all cases.

For example in at the input to stage 1 X is bits fgh Y is bit e and Z is bit d. Y is the leftmost bit in R and Z is the rightmost bit in L. After stage 1 Y is the leftmost bit in L and is contiguous with Z mod 4 within L i.e. de is contiguous mod 4 in e00d.

The selected data bits in L can be rotated so that they are the rightmost bits of L and in their original order.

From Fact 6 the selected data bits are contiguous mod n 2 in L. At the output of stage 1 in these bits are offset to the left by the size of X the number of bits that stayed in R denoted by X . Thus if we explicitly rotate right the bits by X the selected data bits in L are now the rightmost bits of L in their original order see . In Fact 7 was utilized prior to stages 2 and 3.

At the end of this step we have two half sized butterfly circuits L and R with the selected data bits right aligned and in order in each of L and R last row of . The above can now be repeated recursively for the half sized butterfly circuits L and R until each L and R is a single bit. This is achieved after lg n stages of the butterfly circuit see the final output in .

The selected data bits emerge from stage 1 in rotated to the left by X . In Fact 7 the selected data are explicitly rotated b its back to the fight by X . Instead we can compensate for the rotation by modifying the control bits of the subsequent stages to limit the rotation within each subnetwork. For example if the n bit input to stage 1 is rotated by k positions the two n 2 bit inputs to the L and R subnetworks are rotated by k mod n 2 within each subnetwork. At the output of stage lg n the subnetworks are 1 bit wide so the rotations are absorbed.

If the data bits are rotated by x positions left or right at the input to a stage of a butterfly circuit then at the output of that stage we can obtain a rotation left or right by x positions of each half of the output bits by rotating left or right the control bits by x positions and complementing upon wrap around.

Consider again the example of . The selected data bits emerge from stage 1 left rotated by 3 bits i.e. L is e00d left rotated by 3 positions from 00de. In we explicitly rotated the data bits back to the right by 3. Instead we can compensate for this left rotation by left rotating and complementing upon wrap around by 3 positions the control bits of the subsequent stages. This is shown in . For stage 2 the control bit pattern of L after left rotate and complement by 3 becomes 01 11 10 00. The rotation by 3 is limited to a rotation by 3 mod 2 1 within each half of the output of L of stage 2. In we show the explicit rotation of the output of stage 2 before it is input to stage 3 to transform from d0 0e in to 0d e0. For stage 3 the rotation and complement by 3 of the two single control bits in L become three successive complements 0 1 0 1 and the left rotation of L is absorbed as the overall output is still d0e0. Hence shows how the control bits in stages 2 and 3 compensate for the left rotate by 3 bits at the output of stage 1 compare with .

An explanation is now provided as to why the control bits are complemented when they wrap around. The goal is to keep the data bits in the half they were originally routed to at each stage of the butterfly circuit in spite of the rotation of the input. shows a pair of bits a and b that were originally passed through. It is desired to route a to L and b to R in spite of any rotation. As the bits are rotated see the control bit is rotated with them keeping a in L and b in R as desired. When the bits wrap around see a wraps to R and b crosses the midpoint to L. If the control bit is simply rotated with the paired bits then a is now passed through to R and b is passed through to L which is contrary to the originally desired behavior. If instead the control bit is complemented when it wraps around see then a is swapped back to L and b is swapped back to R as is desired.

Similarly if a and b were originally swapped see a should be routed to R and b to L. As the bits rotate see we simply rotate the control bit with them. When the bits wrap around see input a wraps to R and b crosses to L. When they are swapped a is routed to L and b to R contrary to their original destinations. If the control bit is complemented on wraparound a is passed through to R and b is passed through to L conforming to the originally desired behavior.

Thus complementing the control bit when it wraps see causes each of the pair of bits to stay in the half it was originally routed to despite the rotation of the input pushing each bit to the other half This limits the rotation of the input to be within each half of the output and not across the entire output.

Any parallel deposit instruction on n bits can be implemented with one pass through a butterfly circuit of lg n stages without path conflicts with the bits that are not selected zeroed out externally .

Assume there are k 1 s in the right half of the bit mask. Then based on Fact 3 the k rightmost data bits block X must be kept in the right half R of the butterfly circuit and the remaining contiguous selected data bits must be swapped block Y or passed through block Z to the left half L . This can be accomplished in stage 1 of the butterfly circuit by setting the k rightmost configuration bits to 1 to pass through X and Z and the configuration bits of the remaining selected bits to 0 to swap Y .

At this point the selected data bits in the right subnetwork R are right aligned but those in the left subnetwork L are contiguous mod n 2 but not right aligned Fact 4 they are rotated left by the size of block X or the number of bits kept in R. We can compensate for the left rotation of the bits in L and determine the control bits for subsequent stages as if the bits in L were right aligned. This is accomplished by left rotating and complementing upon wraparound the control bits in the subsequent stages of L by the number of bits kept in R once these control bits are determined pretending that the data bits in L are right aligned . Modifying the control bits in this manner will limit the rotation to be within each half of the output until the rotation is absorbed after the final stage Fact 8 .

Now the process above can be repeated on the left and right subnets which are themselves butterfly networks count the number of 1 s in the local right half of the mask and then keep that many bits in the right half of the subnetwork and swap the remaining selected data bits to the left half. Account for the rotation of the left half by modifying subsequent control bits. This can be repeated for each subnetwork in each subsequent stage until the final stage is reached where the final parallel deposit result will have been achieved see .

Various functional units can be constructed in accordance with the present invention for implementing any desired combinations of parallel extract parallel deposit butterfly permutations and inverse butterfly permutations. Examples of such functional units will now be discussed with reference to .

The various functional units discussed above in connection with can implement a wide variety of advanced bit manipulation instructions. Table 7 below summarizes these instructions as well as the processor cycles required for each instruction. Note that Table 7 is similar to the bottom half of Table 1 with the addition of the grp instruction and associated cycle counts. A 64 bit word size without loss of generality is assumed 

For bfly and ibfly the data bits in GR rare permuted and placed in the destination register GR r. Application registers ar.band ar.ib i 1 2 3 are used to hold the configuration bits for the butterfly or inverse butterfly datapath respectively and these registers must first be loaded by the mov ar instruction. The mov ar instruction in Table 7 is used to move the contents of two general purpose registers to the application registers. The sub opcode x indicates which application register or pair of application registers are written.

Static versions of pex and pdep are used when desired mask patterns are known at compile time. In the static version of the pex instruction GR ris and ed with mask GR r then permuted using inverse butterfly application registers ar.ib with the result placed in GR r. For static pdep GR ris permuted using butterfly application registers ar.b then and ed with mask GR r with the result placed in GR r.

Dynamic or variable versions of pex and pdep are used when desired mask patterns are only known at runtime. In the pex.v instruction the data bits in GR rselected by the 1 bits in the mask GR rare placed in the same order in GR r. In the pdep.v instruction the right justified bits in GR rare placed in the same order in GR r in the positions selected by 1 s in mask GR r. For both instructions the mask ris translated dynamically by a decoder into control bits for an inverse butterfly or butterfly circuit.

Suppose the particular pattern of bit scatter or gather is determined at execution time but this pattern remains the same over many iterations of a loop. This is referred to as a loop invariant pex or pdep operation. The setib and setb instructions invoke a hardware decoder to dynamically translate the bitmask GR rto control bits for the datapath stages these control bits are written to the inverse butterfly or butterfly application registers respectively for later use in static pex and pdep instructions. Table 7 also shows the grp instruction which can perform arbitrary n bit permutations. It is noted that the grp instruction can be emulated by a short sequence of pex and Boolean instructions.

The last column of Table 7 shows the expected number of cycles taken for the execution of the instruction. All static instructions with pre loaded ARs take a single cycle comparable to the time taken for an add instruction. The hardware decoder takes about 2 cycles hence the setib and setb instructions take 2 cycles each. The variable pex.v and pdep.v and grp instructions each take up to 3 cycles each because they have to go through the hardware decoder first and then incur some additional datapath latency through the inverse butterfly or butterfly circuits and the output multiplexers. It is noted that the cycle counts depend on what a given processor uses to determine the cycle time. Here it is assumed without loss of generality that the latency of an ALU is used to determine the cycle time. Also it is noted that these cycle counts can change depending on the circuit optimization performed.

Table 8 summarizes applications in which the present invention can be implemented. Check marks indicate definite usage check marks in parenthesis indicate usage in alternative algorithms and question marks indicate potential usage. The use of the mov ar instruction is assumed but not shown in Table 8 whenever the bfly ibfly or static pex and pdep instructions are used. Note that these are just representative applications and do not constrain the use of the proposed instructions and shifter circuits in other applications or in different ways in these applications.

Table 8 shows that static pex and pdep are the most frequently used. The variable pdep.v is not used at all and the variable pex.v is only used twice. The loop invariant pex and pdep instructions indicated by the use of setib and setb instructions are only used for the LSB Steganography application. The grp instruction is only used in a block cipher.

The SSE instruction pmovmskb serves a similar purpose it creates an 8 or 16 bit mask from the most significant bit from each byte of a MMX or SSE register and stores the result in a general purpose register. However pex offers greater flexibility than the fixed pmovmskb allowing the mask for example to be derived from larger subwords or from subwords of different sizes packed in the same register.

Similarly binary image compression performed by MATLAB s bwpack function benefits from pex. Binary images in MATLAB are typically represented and processed as byte arrays a byte represents a pixel and has permissible values 0x00 and 0x01. However certain optimized algorithms are implemented for a bitmap representation in which a single bit represents a pixel.

To produce one 64 bit output word requires only 8 static pex instructions to extract 8 bits in parallel from 8 bytes and 7 dep instructions to pack these eight 8 bit chunks into one output word see . For decompression as with the bwunpack function only 7 extr instructions are required to pull out each byte and only 8 pdep instructions to scatter the bits of each byte to byte boundaries.

LSB steganography is an example of an application that utilizes the loop invariant versions of the pex and pdep instructions. The sample size and the number of bits replaced are not known at compile time but they are constant across a single message. depicts an example LSB steganography encoding operation in which the 4 least significant bits from each 16 bit sample of PCM encoded audio is replaced with secret message bits.

If the images are processed in bitmap form a single pex instruction extracts the entire index at once assuming a 64 bit word contains an 8 8 block of 1 bit pixels illustrated at in . As the algorithm steps through the pixels the neighborhood moves illustrated at in . This means that the bitmask for extracting the neighborhood is shifted and a dynamic pex.v instruction may be needed. Alternatively the data might be shifted rather than the mask such that the desired neighborhood always exists in a particular set of bit positions. In this case the mask is fixed and only a static pex is needed. Table 8 indicates the latter with pex indicated by a check mark and pex.v in parenthesis for the alternative algorithm.

A strand of DNA is a double helix there are really two strands with the complementary nucleotides AT and CG aligned. When performing analysis on a DNA string often the complementary string is analyzed as well. To obtain the complementary string the bases are complemented and the entire string is reversed as the complement string is read from the other end. The reversal of the DNA string amounts to a reversal of the ordering of the pairs of bits in a word. This is a straightforward bfly or ibfly permutation.

The DNA sequence is transcribed by the cell into a sequence of amino acids or a protein. Often the analysis of the genetic data is more accurate when performed on a protein basis such as is done by the BLASTX program. A set of three bases or 6 bits of data corresponds to a protein codon. Translating the nucleotides to a codon requires a table lookup operation using each set of 6 bits as an index. An efficient algorithm can use pdep to distribute eight 6 bit fields on byte boundaries and then use the result as a set of table indices for a parallel table lookup ptlu instruction to translate the bytes as shown in . A parallel table lookup instruction takes as input a word consisting of packed indices each index being used to read out an entry of a table. For example with a 32 bit register word and tables each of which have 256 entries 8 bit indices can be packed into the word to read out 4 different tables in parallel. These 4 results can be used immediately as in or they can be combined by combinatorial logic to provide one result word which can then be stored back into the processor s register file. The pdep instruction of the present invention is used in to expand bits from a bit string into the 8 bit indices used for the parallel table lookup. Also the pex instruction of the present invention could be utilized to implement retrieving the packed indices for the operand input for such a parallel table lookup instruction.

For example to match a pattern comprising many features where 1 indicates a match and 0 indicates no match arbitrary subsets of the binary 1 s can be efficiently collected and compressed with this parallel extract instruction. The resulting compressed bits can be used as indices into the parallel table lookup instruction. This enables very fast action depending on which patterns are matched.

When aligning two DNA sequences certain algorithms such as the known BLASTZ program use a spaced seed as the basis of the comparisons. This means that n out of m nucleotides are used to start a comparison rather than a string of n consecutive nucleotides. The remaining slots effectively function as wild cards often causing the comparison to yield better results. For example BLASTZ uses 12 of 19 or 14 of 22 nucleotides as the seed for comparison. The program compresses the 12 bases and uses the seed as an index into a hash table. This compression is a pex operation selecting 24 of 38 bits as illustrated in .

The present invention can also be used in random number generation and cryptology applications. Random numbers are very important in cryptographic computations for generating nonces keys random values etc. Random number generators contain a source of randomness such as a thermal noise generator and a randomness extractor that transforms the randomness so that it has a uniform distribution. The INTEL random number generator uses a von Neumann extractor. This extractor breaks the input random bits X xxx. . . into a sequence of pairs. If the bits in the pair differ the first bit is output. If the bits are the same nothing is output. This operation is equivalent to using a pex.v instruction on each word X from the randomness pool with the mask Mask 0 0 21 or equivalently Mask 1 0 22 

A number of popular ciphers such as DES have permutations as primitive operations. Inclusion of permutation instructions such as bfly ibfly or grp can greatly improve the performance of the inner loop of these functions. Also these instructions can be used as powerful primitive operations in the design of the next generation of ciphers and hash functions especially for the Cryptographic Hash Algorithm Competition SHA 3 . Since all the pex and pdep instructions static loop invariant and variable are also very likely to be useful for cryptanalysis algorithms they are indicated as in Table 8.

Kernels for the above binary compression and decompression steganography transfer coding bioinformatics translate integer compression and random number generation applications were coded and simulated using the SimpleScalar Alpha simulator enhanced to recognize our new instructions. The latencies of the instructions in the simulator are as given in Table 7. shows performance results normalized to the baseline Alpha ISA cycle counts. The processor with pex and pdep instructions exhibits speedups over the base ISA ranging from 1.13 to 10.04 with an average of 2.29 1.94 excluding the rng benchmark .

Random number generation exhibited the greatest speedup due to the fact that a variable pex.v operation is performed. A single pex.v instruction replaces a very long sequence of instructions that loops through the data and mask and conditionally shifts each bit of the input to the correct position of the output based on whether the corresponding bit of the mask is 0 or 1 . Of the benchmarks for static pex and pdep the simple bit compression and decompression functions exhibited the greatest speedup as these operations combine many basic instructions into one pex or pdep. The speedup is lower in the steganography encoding case because there are only 4 fields per word and also in the uudecode and BLASTX translate case because there are fewer fields overall. The lowest speedups were for integer compression cases as a smaller fraction of the runtime is spent on compression or decompressing bit fields.

To evaluate the cost of implementing the advanced bit manipulation functional units described above in connection with it is necessary to understand the implementation of the major components in such a functional unit. The most complex component is the hardware decoder that takes a register value representing a bitmask and turns it into the control bits of the stages of the butterfly or inverse butterfly datapath. Therefore in order to evaluate the functional unit circuit latency and area we must first define what is contained within the hardware decoder component. Provided below is an algorithm to obtain the n 2 lg n butterfly or inverse butterfly control bits from the n bit pdep or pex bitmask. A hardware decoder circuit can then be constructed which implements this algorithm In the case of static pex or pdep instructions the algorithm can be used by the compiler to generate the control bits for the inverse butterfly or butterfly datapath. In the case of dynamic or loop invariant pex and pdep instructions the hardware decoder is used.

The steps in the proof to Theorem 2 give an outline for how to decode the n bit bitmask into controls for each stage of a butterfly datapath. For each right half of a stage of a subnetwork we count the number of 1 s in that local right half of the mask say k 1 s and then set the k rightmost control bits to 1 s and the remaining bits to 0 s. This serves to keep block X in the local R half and export Y to the local L half. We then assume that we explicitly rotate Y and Z to be the rightmost bits in order in the local L half. Then we iterate through the stages and come up with an initial set of control bits. After this we eliminate the need for explicit rotations of Y and Z by modifying the control bits instead. This is accomplished by a left rotate and complement upon wrap around LROTC operation rotating the control bits by the same amount obtained when assuming explicit rotations.

This process can be considerably simplified as follows. First note that when we modify control bits to compensate for a rotation in a given stage we do so by propagating the rotation through all the subsequent stages. This means that when the control bits of a local L are modified they are rotated and complemented upon wrap around by the number of 1 s in the local R and by the number of 1 s in the local R of the preceding stage and by the number of 1 s in all the local R s of all preceding stages up to the R in the first stage. In other words the control bits of the local L are rotated by the total number of 1 s to its night in the bitmask.

Consider the example of . The control bit in stage 3 in the Lsubnetwork is initially a 0 when we assumed explicit rotations. We first rotated and complemented this bit by 3 the number of 1 s in R of the bitmask 0 1 0 1 . We then rotated and complemented this bit by another 1 position the number of 1 s in Lof the bitmask 1 0. This yielded the final control bit in . Overall we rotated this bit by 4 the total number of 1 s to the right of Lor to the right of bit position 6. This is a Parallel Prefix Population Count PP PP POPCNT of the bitstring from the rightmost bit to bit position 6.

Second it is necessary to produce a string of k 1 s from a count in binary of k to derive the initial control bits assuming explicit rotations. This can also be done with a LROTC operation as illustrated in . We start with a zero string of the correct length and then for every position in the rotation and we wrap around a 0 from the left and complement it to get a 1 on the night. The end result after a LROTC by k bits is a string of the correct length with k rightmost bits set to 1 and the rest set to 0 .

It is possible to combine these two facts the initial control bits are obtained by a LROTC of a zero string the length of the local R by the PP POPCNT of the bits in the bitmask in the local R and all bits to the right of it. We denote a string of k 0 s as 0. We specify a bitfield from bit h to bit v as h v where v is to the right of h. So 

One interesting point is that for stage 1 the population count of the odd multiples of n 2bits is needed for stage 2 the population counts of the odd multiples of n 2bits is needed for stage 3 the population counts of the odd multiples of n 2bits is needed and so on. Overall the counts are needed of the k rightmost bits for k 0 to n 2. Such counts can be provided using the prefix population counter of the present invention discussed above.

The control bits for the inverse butterfly for a pdep or a pex operation can be obtained using Algorithm 1 with the one caveat that the controls for stage i of the butterfly datapath are routed to stage lg n i 1 in the inverse butterfly datapath. This can be shown using an approach similar to that shown earlier except for working backwards from the final stage. Algorithm 1 decites the n mask bits into the nlg n 2 control bits for pdep and pex.

The execution time of Algorithm 1 in software is approximately 1200 cycles on an Intel Pentium D processor. This software routine is useful for static pex or pdep operations and perhaps for loop invariant pex or pdep if the amount of processing in the loop dwarfs the 1200 cycle execution time. However for dynamic pex.v and pdep.v a hardware decoder is required which implements Algorithm 1 in order to achieve a high performance. Fortunately Algorithm 1 just contains two basic operations population count and LROTC both of which have straightforward hardware implementations.

The first stage of the decoder is the parallel prefix population counter discussed above. This is a circuit that computes in parallel all the population counts of step 1 of Algorithm 1. The circuit is a parallel prefix network with each node performing carry save addition i.e. a set of full adders . The counters resemble carry shower counters in which the inputs are grouped into sets of three lines which are input into full adders. The sum and carry outputs of the full adders are each grouped into sets of three lines which are input to another stage of full adders and so on. The parallel prefix architecture resembles radix 3 Han Carlson a parallel prefix look ahead carry adder that has lg n 1 stages with carries propagated to the odd positions in the extra final stage. The radix 3 nature stems from the carry shower counter design as we group 3 lines to input to a full adder at each level. The similarity to Han Carlson is due to the 1 and 2 bit counts being deferred to the end similar to odd carries being deferred in the Han Carlson adder. Thus the counter has log n 2 stages. depicts a dot diagram of the parallel prefix network.

One simplification of the counter is based on the properties of rotations that they are invariant when the rotation amount differs by the period of rotation. Thus for the ith stage of the butterfly network the PP POPCNTs are only computed mod n 2. For example for the 64 bit hardware decoder for the 32 butterfly stage 6 PP POPCNTs corresponding to the odd multiples of n 64 it is necessary only compute the PP POPCNTs mod 2 only the least significant bit for the 16 butterfly stage 5 PP POPCNTs we need only compute the PP POPCNTs mod 4 the two least significant bits and so on. Only the PP POPCNT of 32 bits for stage 1 requires the full lg n bit PP POPCNT.

The outputs from the decoders shown in can be routed to the butterfly circuit and its application registers and can be used for controls for butterfly circuit to perform the pdep instruction. Additionally the outputs are routed to the inverse butterfly circuit and its application registers reversing the order of the stages to be used for the pex instruction.

The functional units shown in and were tested for timing and circuit area. These functional units support static pex and pdep only loop invariant and dynamic pex.v and pdep.v as well and grp as well . All three also support bfly and ibfly permutation instructions. The circuits in are implemented with a 3 stage pipeline. The hardware decoder occupies the first 2 pipeline stages due to its slow parallel prefix population counter. The butterfly or inverse butterfly circuit is in the third stage.

The various functional units were coded in Verilog and synthesized using Synopsys Design Compiler mapping to a TSMC 90 nm standard cell library. The designs were compiled to optimize timing. The decoder circuit was initially compiled as one stage and then Design Compiler automatically pipelined the subcircuit. Timing and area figures are as reported by Design Compiler. We also synthesized a reference ALU using the same technology library as a reference for latency and area comparisons.

Table 9 below summarizes the timing and area for the circuits. This shows that the 64 bit functional unit in supporting static pex and pdep has a shorter latency than that of a 64 bit ALU and about 90 of its area in NAND gate equivalents . However to support variable and loop invariant pex and pdep as in which requires a hardware decoder as described in detail above the advanced bit manipulation functional unit will be 16 slower than an ALU and 2.25 larger. To also support a fast implementation of the grp instruction the proposed new unit will be 23 slower than an ALU and about 3.2 larger in area.

Table 10 shows the number of different circuit types to give a sense for why the functional units supporting variable pex.v pdep.v and grp are so much larger. It shows that supporting variable operations comes at a high price. The added complexity is due to the complex decoder combinational logic and to the additional pipeline registers and multiplexer logic. This explains why in Table 10 the variable circuits have approximately 22 29 longer cycle time latencies compared to the static case due to the decoder complexity and pipeline overhead. They are also 2.5 to 3.6 times larger than the static case.

Having thus described the invention in detail it is to be understood that the foregoing description is not intended to limit the spirit or scope thereof. What is desired to be protected is set forth in the following claims.

