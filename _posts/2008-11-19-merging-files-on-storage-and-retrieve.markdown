---

title: Merging files on storage and retrieve
abstract: A client designates and transfers a file to a server in distinct chunks. The number of data chunks equals the number of communication sessions that are required to complete the transfer of the designated file to the server, that number being dependent on the number of times the communication session between the client and the server is interrupted. If the designated file includes several concatenated client files, each chunk of the designated file may include one or more such client files. Each chunk of the designated file may include some part of a client file and one or more whole client files. The byte-wise size or length of a chunk depends on the duration of the related communication session: the longer a communication session, the larger the related chunk. By transferring the designated file to the server as distinctly recognizable chunks, the need to retransmit large files to the server is avoided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08103631&OS=08103631&RS=08103631
owner: Sandisk IL Ltd
number: 08103631
owner_city: Kfar Saba
owner_country: IL
publication_date: 20081119
---
The present invention generally relates to data transfers between a client and a server and more specifically to a client capable of transferring a large file to a server in an efficient way.

In online backup systems a client may concatenate many files into a single archive file and then upload the archive file as a whole to a remote backup server. In computers an archive file might be a file that contains several compressed files and a client might be an application or computer system that accesses a remote service on another computer system known as a server by using some communication network e.g. the Internet .

A popular and simple way to transfer files such as an archive file from clients to backup servers is by using the Hypertext Transfer Protocol HTTP . HTTP is a request response communication standard that facilitates data transfers between a client and a server on the Internet. In the Internet environment a client is the end user and the server is a website.

While every server used for backing up archive files supports standard HTTP WebDAV commands such as GET PUT and LIST many servers do not support the byte range feature that is required to resume failed data transfers. Thus if a file e.g. an archive file transmitted from the client to the server is very large e.g. at least in the order of megabytes and the communication connection between the client and the server is interrupted or cut off during transmission the entire file must be retransmitted at the next available opportunity rather than transmitting only the portion of the file that has not yet been received by the server. This impedes using simple hosted web services as servers for online backup because sending a large file takes a considerable amount of time and requires computing resources. Therefore the traditional requirement to retransmit the entire file only exacerbates this problem.

Hence there is a need to address the problem of backing up files in a server in a way that would make the backing up process more efficient. For example there is a need for a client that can send a large file to a server in a way that the client would not have to retransmit the entire file because of communication failures.

It would therefore be beneficial to back up files in a server in a way that it will not be necessary to retransmit the files if the communication connection is interrupted in the middle of a file transfer. Various embodiments are designed to implement such capability examples of which are provided herein. Various embodiments are designed to implement such files management examples of which are provided herein. The following exemplary embodiments and aspects thereof are described and illustrated but are not intended to be exclusive or limiting in scope.

To address the foregoing a file which may include contain or be associated with one or more client files is transferred from a client to a server using a communication session. If the communication session is interrupted before the file transfer is completed the file is transferred to the server using additional one or more communication sessions where each communication session is used to transfer a different chunk of the file. A communication session as used herein necessitates establishing a communication channel between the client and the server and performing handshaking. In telecommunications handshaking is an automated process of negotiation that sets parameters of a communications channel that is established between two computer devices before normal communication over the channel begins. It follows the physical establishment of the channel and precedes normal information transfer. By interruption is meant herein any communication phenomenon that entails a new communication session.

Each chunk of the file that is transferred to the server during one of the communication sessions is transferred to the server as a file whose name is a unique variant of the file name of the file to be transferred to the server and whose size depends on the amount of data transferred until the communication session is interrupted. That is the longer a communication session is the more data is transferred and the larger is the associated unique file.

If the first communication session is uninterrupted the entire file is transferred from the client to the server as one chunk that chunk being the largest chunk because it is at least as large as the transferred file. However if additional communication sessions are required i.e. due to communication interruptions a first chunk of the file is transferred to the server using a first unique variant of the file name a second chunk of the file is transferred to the server using a second unique variant of the file name a third chunk of the transfer file is transferred to the server using a third unique variant of the file name and so on.

By maintaining information that pertains to the chunks that have already been transferred to the server the client is capable of continuing to transfer to the server only untransferred chunks of the file. In other words by making each chunk of the transferred file uniquely recognizable by both client and server i.e. recognizable as a unique file there is no need for the client to retransmit the entire file to the server if the communication connection there between is broken.

By designating a file for transfer is meant a process by which one or more files designated herein below as files f f . . . f are transferred from a client to a server using a randomly changing number of files also referred to herein below as chunks that are name wise related because their file names share a common part which is referred to herein as a common file name . The number of name wise related files required to transfer the one or more files f f . . . fchanges because each communication interruption causes an End of File EoF to be generated and entails the generation of a new such file. The number of the name wise related files is random because communication interruptions occur randomly. The name wise related files are collectively called designated file because their file names are variants of a common file name. Transferring a designated file therefore means transferring the name wise related files or chunks. The file or files to be transferred from the client to the server i.e. files f f . . . f may be transferred by using one or more chunks. That is if a communication session is long enough the file or files f f . . . fcan be transferred to the server as one chunk.

A method is provided for transferring data from a client to a server. The method may include a client designating a file for transfer to a server establishing a communication session between the client and the server and transferring the file to the server by using a unique variant of a file name of the file. If the communication session is interrupted before transfer of the file to the server is completed the method may further include repeating the latter two steps i.e. the steps of establishing a communication session between the client and the server and transferring the file to the server by using a unique variant of a file name of the file as many times as required for the file transfer to be completed.

The unique variant of the file name may include for example a unique suffix e.g. . . . part1 a unique prefix e.g. part1 . . . or a file extension e.g. .part1 to the file name. The unique variant of the file name may include a unique sequential identifier. The unique sequential identifier may include an alphabetical numeric or alphanumeric index whose value is incremented for each time the latter two steps i.e. the steps of establishing a communication session between the client and the server and transferring the file to the server by using a unique variant of a file name of the file are repeated where for each repetition the client uses a different i.e. unique variant of the file name to transfer the rest or another chunk of the file to the server.

Repeating the latter two steps i.e. the steps of establishing a communication session between the client and the server and transferring the file to the server by using a unique variant of a file name of the file may include using information to identify an offset from which transfer of the rest of the file should continue. The client may retrieve the information from the server each time before the two steps are repeated or the information may be maintained and updated by the client. Alternatively the client may retrieve some of the information from the server before the two steps are repeated and maintain and update the rest of the information locally i.e. on the client .

The information may include a size of each chunk of the file that is transferred to the server during one of the communication sessions and the offset may be derived from the sizes of the transferred chunks. The offset may be the sum of all the sizes of the transferred chunks or the sum of the sizes of the transferred chunks excluding the size of the chunk that was transferred to the server during a previous communication session. By previous communication session is meant a communication session preceding an interrupted communication session.

The method may further include assigning to a flag a repeating value e.g. 1 or REPEAT or a non repeating value e.g. 0 or NO REPEAT to respectively indicate to a retrieving client whether transferring the file to the server has been completed or not. The retrieving client may be the client or some other client. The flag may be assigned the repeating value before or during the first communication session and the non repeating value after transfer of the file to the server is completed.

The file transferred to the server may be one file for example it may be a 5.50 megabyte media file or it may include k files f f . . . f 1 k n of the same type or of varying types. If a current communication session is interrupted during transfer of a particular one of the k files which means that only part of the particular one of the k files has been transferred during the current communication session the untransferred part of the particular one of the k files may be transferred to the server during the consecutive communication session or alternatively the entire particular one of the k files may be retransferred to the server to make sure that the particular one of the k files has been successfully transferred to the server.

The method may further include sequentially retrieving the k transferred files from the server responsive to transferring the file name to the server e.g. as a Uniform Resource Locator link . Alternatively the client may retrieve the k files from the server as one concatenated file responsive to the client requesting the file from the server.

In another embodiment the method may include designating by the client k data objects for transfer to the server associating a common file name e.g. F to the designated k data objects establishing a communication session between the client and the server and while the communication session is uninterrupted sequentially transferring data objects to the server one data object after another by using a unique variant of the file name e.g. F.part0 . If the communication session is interrupted the method may include reestablishing the communication session and continuing to transfer untransferred data objects to the server by using during each reestablished communication session a different unique variant of the file name F. The process of reestablishing the communication session and continuing to transfer untransferred data objects is repeated until the last untransferred data object is transferred to the server. A data object may be or include one or more files f f . . . f and or data and metadata related to one or more of files f f . . . f.

The designated file or k files may be transferred from the client to the server and retrieved from the server by using for example Hypertext Transfer Protocol HTTP .

A device with a client is provided for transferring data from the device to a server. The device may have all of the physical components e.g. a memory a storage controller a processor and a communication interface necessary for it to function as the client referred to above and the various physical components may operatively interact with the processor and configured to perform the method described above. The device may have a client software application that may be stored on the memory. The client can be software firmware that runs on the device or it can replace the processor as a special purpose processor that performs the functions described herein.

In addition to the exemplary aspects and embodiments described above further aspects and embodiments will become apparent by reference to the figures and by study of the following detailed description.

The description that follows provides various details of exemplary embodiments. However this description is not intended to limit the scope of the claims but instead to explain various principles of the invention and the manner of practicing it.

In order to address the problem of interrupted communication between a client and a server and related issues a client designates and transfers a file to a server e.g. for back up in distinctly recognizable chunks the number of which depends on the number of the communication interruptions. For example if there are no interruptions the designated file is transferred as one chunk if there is one interruption the designated file is transferred in two chunks and so on. If the designated file involves transferring several concatenated client files each chunk of the designated file may include one or more such client files. Each chunk of the designated file may include some part of a client file and one or more whole client files. For example a first chunk of the designated file may include a client file f a second chunk of the designated file may include a client file fand 30 of a client file f a third chunk of the designated file may include the rest i.e. 70 of client file fand client files fand f and so on.

The number of data chunks equals the number of communication sessions that are required to complete the transfer of the designated file to the server that number being dependent on the number of times the communication session between the client and the server is interrupted. The byte wise size or length of a file s chunk depends on the duration of the related communication session. By transferring the designated file to the server as distinctly recognizable chunks the need to retransmit large files to the server is avoided. The way a designated file or a group of client files are transferred to a server in one or more chunks and the way the client server communication sessions affect the number and sizes of the file s chunks are described herein below.

Memory may hold one or more client files not shown in that need or are required to be transmitted to a remote computer system for example to server for back up. As explained above client may transfer the one or more client files to server as one file that may be transferred to server as a whole i.e. in one chunk or in chunks i.e. depending on whether there are interruptions in the communication between client and server .

If due to communication interruptions the file designated for transfer to server should be transferred in chunks memory may hold information pertaining to the file s chunks that have already been transferred from client to server . The information which may be held for example in lookup table may include a unique variant of the file name of the file designated for transfer and in addition the size of each transferred file s chunk. The information may be used by processor to continue transferring untransferred file s chunks to server . Alternatively processor may retrieve that information from server . The way the information is used by client is described herein below.

Client may also include a communication interface to facilitate transfers of files from and to memory . Client may use communication interface to transfer files to server via communication link and over a communication network that may be for example the Internet. Server may use a communication interface to receive files that are transferred from client and to transfer files to client or to another client e.g. to client . Transfer of files from client to server may be implemented for example by using the HTTP protocol.

Processor may designate in memory a relatively large file e.g. a 5.50 megabyte video clip for transfer to server . In the absence of communication interruptions processor may transfer the designated file to server using one communication session. However if there are interruptions in the communication link between client and server processor establishes with server additional communication sessions with server during which processor transfers to server chunks of the designated file one chunk per communication session by using for each transferred chunk a unique variant of the file name of the designated file as explained above.

The file designated for transfer to server may in and of itself be a distinct content unit for example it may be a Word file an MP3 file a large media file e.g. an AVI file etc. or an archive file. If the file designated for transfer to server is or it includes one distinct content unit each file s chunk may include a different portion of the distinct content. If the file designated for transfer to server is an archive file each file s chunk may include one or more archived files or one or more archived files and one or more portions of other archived file s or a portion of one or more archived files.

Processor may select in memory k files designated as f f . . . f for transfer to server or it may be instructed to do so for example by a user of client . In the absence of communication interruptions Processor may transfer files f f . . . fto server over one communication session. However if there are interruptions in the communication link between client and server Processor establishes with server additional communication sessions with server during which Processor transfers to server portions of the selected file a portion per communication session by using for each communication session a unique notation of the file name of the selected file.

Files f f . . . fmay be of the same type e.g. multimedia file . For example one or more files may be multimedia files other files may be WORD files picture files or MP3 files etc. After processor or a user of client selects the k files for transfer to server processor associates a common file name F with the k selected files. The associated common file name may be chosen arbitrarily provided that the chosen file name is not already used by the pertinent file system. For example it can be myfile i.e. F myfile transfer file i.e. F transfer file exchang file i.e. F exchang file or any other name.

As explained above client may hold information that pertain for example to the file name and file size of each of files f f . . . f or alternatively client may request that information from server . As explained above if a communication session is interrupted before client had a chance to transfer the last file e.g. f to server client can use that information to resume transferring the rest of the files from the point where the communication session was interrupted.

After files f f . . . fto be transferred to server are selected and the common file name e.g. myfile is associated with the selected files processor establishes a communication session with server and starts transferring the selected files f f . . . fto server one file after another. The order in which processor transfers the selected files to server i.e. the transfer order may be contingent on or be derived from the selected files. For example the transfer order of the selected files may be contingent on the type of the files or on the size of the files etc. Alternatively the transfer order in which processor transfers the selected files to server can be arbitrary.

If the communication session between processor and server is interrupted processor restores the interrupted communication session with server or establishes therewith a new communication session depending on whether the communication session was interrupted. Each time the communication session is restored or established processor notates the common file name myfile an exemplary file name by using a unique notation and while the current communication session is uninterrupted sequentially transfers untransferred files among the k files f f . . . f to server by using the uniquely notated common file name. Such communication sessions are restored or reestablished until processor transfers the last untransferred file e.g. f to server .

Notating the common file name can be implemented in various ways. For example if the common file name assigned to or associated with the k selected files is myfile the file name myfile can be uniquely notated by adding to it some differentiating text or index e.g. myfile1 myfile2 myfile3 and so on or some file extension e.g. myfile.part1 myfile.part2 myfile.part3 and so on . Even though each file name is unique because of its differentiating index or extension the file names all share a common file part the assigned common file name in this example myfile . The common file part is used by client as a filter 1 to retrieve from server information pertaining to transferred files in order to identify the point in memory from which to resume transfer of other files and after all the files have been transferred to server 2 to retrieve the files from server .

After a second chunk of file fis transferred to the server the communication session is assumed to be interrupted. Because file fstill has another part that should be transferred to the server a third communication session is established or the first original communication session may be thought of as being reestablished and a different variant of the file name DayTrip e.g. DayTrip P3 is used to transfer the untransferred part of file fto the server. It is assumed that transferring file frequires three communication sessions which results in the designated file fbeing transferred to the server in three chunks i.e. chunks and .

As explained above the number of chunks that are transferred to the server equals to the number of the communication sessions required for a complete transfer of the involved file and the size of each chunk depends on the duration of the associated communication session. The common file name used to transfer file fto the server can be the original file name e.g. DayTrip of filed f. Alternatively file fmay be transferred to the server by using a file name other than the file s original name. For example the file name TransFile may be used instead of the file s original name DayTrip. The file name used to transfer the designated file to the server may be chosen randomly.

In order to transfer files f f f fto the server a first communication session is established between the client and the server and the files f f f fare started to be transferred to the server on file after another by using a unique variant of the designated file myfile is e.g. myfile.Chunk1 . After a first chunk of the designated file myfile is transferred to the server the communication session is assumed to be interrupted. It is assumed that the first two files f fwere completely transferred to the server within or as part of chunk and that files f fstill need to be transferred. Therefore a second communication session is established or the first original communication session may be thought of as being reestablished and a different variant of the file name myfile e.g. myfile Chunk2 is used to transfer the rest of the files i.e. files f f to the server.

After a second chunk of the designated file myfile is transferred to the server the communication session is assumed to be interrupted. It is assumed that the file fwas completely transferred to the server within or as part of chunk and that file fstill needs to be transferred. Therefore a third communication session is established and a different variant of the file name myfile e.g. myfile Chunk3 is used to transfer file fto the server.

After a third chunk of the designated file myfile is transferred to the server the communication session is assumed to be interrupted. It is assumed that the communication interruption occurred during transfer of file f which means that chunk includes only part of file f. Therefore a fourth communication session is established and a different variant of the file name myfile e.g. myfile Chunk4 is used to transfer the rest of file fto the server. Alternatively in order to ensure error free communication of a particular file that was partly transferred to the server the entire particular file whose transfer to the server was interrupted may be sent to the server. Referring to the entire file fmay be transferred to the server as part of chunk or only the part thereof which was not transferred as part of any of the previous chunks and .

Referring to the designated file fmay include one distinct content unit in which case chunks and would be chunks of a larger file that may in and of itself be a Microsoft Word file an MP3 file an archive file or a large media file e.g. an AVI file . Referring to the designated file fmay include non archived files. For example it may include three distinct non archived content units one Microsoft Word file one MP3 file and one Microsoft Excel file.

At step processor checks whether the current communication session is interrupted. If the current communication session is not interrupted shown as N at step then at step processor checks whether transferring the designated file to server is completed. If transfer of the designated file is not completed shown as N at step transfer of the designated file continues in a regular manner as long as the current communication session is uninterrupted. If transfer of the designated file to server is completed shown as Y at step without any communication interruptions in the current communication session processor terminates the file transfer process after using only one communication session. However if the current communication session is interrupted before transfer of the designated file is completed shown as Y at step processor establishes at step a second communication session and iterates steps and until transfer of the designated file to server is completed.

At step processor uniquely notates the common file name archive file and prepares to transfer to server files f f . . . f. At this stage the communication session established between processor and server is the first communication session and processor notates the common file name archive file by adding for example the file extension part1 to the common file name. If the first communication session is not interrupted at least until all files f f . . . fare transferred to server the files transfer process requires one communication sessions. If however the communication session is interrupted before all files f f . . . fare transferred to server an additional communication session would be required during which transfer of files f f . . . fwill continue substantially from the point where the first communication session was interrupted. If for example the i e.g. first communication session was interrupted in the middle of the transfer of file f the transfer of the files will continue during the i 1 e.g. second communication session by completing the transfer of file f and then by transferring the rest of the files.

At step processor notifies server of the first notated file name e.g. archive file.part1 . Responsive to receiving the first notated file name server i prepares for storing whatever files processor intends to transfer to server and ii acknowledges to processor receipt of the first notated file name. Responsive to receiving the acknowledgement from server processor uses the first notated file name archive file.part1 to transfer to server as many files among files f f . . . fas possible. As long as the first communication session is free of interruptions shown as N at step and the last file has not yet been transferred shown as N at step processor continues to transfer to server one file after another during the first communication session. If the first communication session is long enough processor transfers to server all the files f f . . . fin the first and only communication session. However if the first communication session is interrupted shown as Y at step before all the files f f . . . fare transferred to server then at step processor establishes a second communication session.

At step processor uniquely notates the common file name archive file and prepares to transfer to server the rest of the files f f . . . f. At this stage the communication session established between processor and server is the second communication session. Therefore processor may notate the common file name archive file by adding for example the file extension part2 to the common file name archive file.

At step processor notifies server of the second notated file name e.g. archive file.part2 . Responsive to receiving the second notated file name server i prepares for storing whatever file s processor intends to send to server and ii acknowledges to processor receipt of the second notated file name. Responsive to receiving the acknowledgement from server processor uses the second notated file name archive file.part2 to transfer to server as many untransferred files among files f f . . . fas possible i.e. until the communication session is interrupted . As long as the second communication session is free of interruptions shown as N at step and the last file has not yet been transferred shown as N at step processor continues to transfer to server one untransferred file after another during the second communication session. If the second communication session is long enough processor transfers to server all the rest of the untrenasferred files among files f f . . . fin the second communication session. However if the second communication session is interrupted shown as Y at step before all the rest of the untransferred files are transferred to server then at step processor establishes a third communication session. During the third communication session processor transfers additional untransferred files to server and if transfer of the untransferred files is interrupted one or more times processor may use additional one or more communication sessions to transfer more files by repeating steps through .

If a communication session is not interrupted shown as N at step processor checks at step whether the file currently transferred to server is the last file to be transferred. If it is the last file to be transferred file processor completes its transfer and terminates the files transfer process. However if the file currently transferred to server is not the last file to be transferred processor continues to transfer that file and for as long as the current communication session is still intact also the other files.

As explained above a communication session may be interrupted before processor completes the transfer of a particular file. For example the communication session may be interrupted during the transfer of file for after processor transfers the first three files e.g. f f f to server . Processor knows which files are yet to be transferred to server i by receiving from server information pertaining to files e.g. file names and file sizes that have already been transferred to server or ii by maintaining the information in lookup table in client .

If a communication session is interrupted in the middle of the transfer of a particular file there is a risk that the portion of the file that was transferred to server may be corrupted. In order to ensure error free communication of a file to a server the suspected portion of the file may be discarded and the entire file may be retransferred to server during one of the following communication sessions.

When the first communication session is established processor may forward to server the common file name itself e.g. myfile rather than the first notated file name. This way if all the files f f . . . fare transferred to server in one communication session neither processor nor server have to deal with files that have been uniquely notated. If the common file name itself is used to transfer the first chunk of file s and the first communication session is interrupted processor may continue to transfer the rest of the files by using notated common file name s .

As explained above the steps of reestablishing a communication session and transferring more files during the reestablished communication sessions may need to be repeated. For file s transferring purpose client may use a flag to indicate to a retrieving client whether or not all the files f f . . . fhave been transferred to server . For example a flag called FLAG may be set to some repeating value e.g. 1 or Transfer before the first file of the files f f . . . fis transferred to server and to some non repeating value e.g. 0 or End of Transfer after the last file of the files f f . . . fis transferred to server . The retrieving client may be client or any other client for example remote client . Client may send a corresponding URL link to remote client and remote client may use that link to retrieve file f f . . . ffrom server .

For retrieving purpose server may create a meta file that automatically combines i.e. concatenates all the notated files. In order for a client e.g. client to retrieve the notated files from server the client has to request the meta file from server which will result in server sequentially sending all the notated files to the client in one batch.

In order for client to send ten files to server client uniquely notates the common file name myfile i.e. it prepares a unique variant of the common file name by using a first notation part1 . Client then sends the file name myfile.part1 shown at to server . Then while first communication session continues uninterruptedly client starts transferring files one file after another. In this example client has transferred to server during first communication session three files f f f shown at after which first communication session was interrupted the interruption being symbolically shown at . . Because files fthrough fhave not been transferred to server during first communication session client establishes a second communication session with server .

During second communication session client requests information that pertains to all the files that have been transferred during the previous one or more communication sessions in this case during first communication session . In order to receive that information client inquires server whether it holds files whose file name includes the common file name myfile. At this stage server holds one such file i.e. file myfile.part1 . Therefore responsive to the inquiry server returns shown at to client information pertaining to files that were transferred to server by using file name myfile.part1. Client then uses that information which includes the name and bit wise size of each of files f f f to calculate an offset value. Client then uses the offset value to determine the next point in the memory where files are stored from which client should resume transferring to server the rest of files .

In order for client to send the rest of files to server during second communication session client uniquely notates common file name myfile by using a second notation part2 . Client then sends the second notated file name myfile.part2 shown at to server . Then while second communication session continues uninterruptedly client resumes transferring the rest of the files to server one file after another. In this example client has successfully transferred to server during second communication session files fand f shown at after which second communication session was interrupted.

Because client has not transferred files fthrough fto server during first communication session and second communication session due to communication failure client establishes a third communication session with server in order to transfer to server the untransferred files.

During third communication session client requests information that pertains to all the files that have been transferred during the previous one or more communication sessions in this case during first communication session and second communication session . In order to receive that information client inquires server whether it holds files whose file names include the common file name myfile. At this stage server holds two such files file myfile.part1 and file myfile.part2. Therefore responsive to the inquiry i.e. responsive to the transfer of the common file name myfile to server server returns to client information pertaining to files that were transferred to server by using file name myfile.part1 transfer of the information pertaining to files is shown at and in addition information pertaining to files that were transferred to server by using file name myfile.part2 transfer of the information pertaining to files is shown at . Client then uses that information which may include for example the name and size of each of files f f f f f to calculate a new offset value. Client then uses the new offset value to determine the next point in the memory where files are stored from which client should resume transferring to server the rest of files .

In order for client to send the rest of files to server during third communication session client uniquely notates common file name myfile by using a third notation part3 . Client then sends the notated file name myfile.Part3 shown at to server . Then while third communication session continues uninterruptedly client resumes transferring the rest of files to server one file after another. In this example client has managed to transfer to server during third communication session files fthrough f shown at after which communication session may be terminated by client in an orderly fashion if there is nothing else that needs to be communicated from client to server or from server to client . As explained above instead of requesting from server the information that pertains to transferred files client may hold the information for example in a lookup table similar to lookup table of .

While files are stored in server a user of client can manually request the file myfile from a different client for example by using a Uniform Resource Locator URL . For example the user can use the HTTP command PUT to send for example a file http www.myserver.com myfile.xyz to server and then send a link e.g. Get this file to this URL to a second user. Then the second user can use the same URL i.e. Get this file from anywhere to retrieve every file that was send to server by using the common file name myfile i.e. by using the designated file myfile .

At step client notifies server that it intends to store a file f in server . File f is a common file name of a file designated for transfer to the server. At step client sends a LIST command with file name f as a filter value to server in order to know whether files are stored in server which are name wise related to the filter value which in this example is the common file name f.

At step client applies a grep command on the output of the LIST command to identify the files currently present in server whose file names match the file f.p pattern where f designates the common file name used to store the files in server and p designates a template extension used to denote the various files e.g. myfile.1 myfile.2 etc. . In other words by using the grep command client receives the names of all the files in server whose file name includes the common file name f and in addition the size of each of these files.

At step client uses the file sizes it receives from server to calculate the total size T of these files. Client uses at step the value of T as an offset value by which client seeks e.g. in its memory the next chain of files that are yet to be sent to server or the point in the memory of or associated with client from which client should resume transferring the rest of the file s .

At step client PUTs the rest of the files in server starting from the offset point T onwards. The PUT process is orderly terminated with the conclusion of the PUT command but if the PUT command fails in the middle the PUT process may be restarted. At step it is checked whether the last file was transferred from client to server . If the last file to be transferred to server has not been transferred shown as N at step a new communication session is commenced during which communication session steps through are repeated. After the last file is transferred to server shown as Y at step the PUT process is terminated.

At step client sends to server the common file name f for retrieving every notated file that includes the common filename. At step client executes a LIST command against server with the common file name f as a parameter. At step client applies the grep command on the list of file names it receives from server . At step an index i is initialized. At step client GETs i.e. retrieves from server the first notated file i.e. file f.part which includes one or more files that were stored in server by client during a corresponding PUT process. At step client concatenates the first notated file f.partto file f.

At step it is checked whether there are more notated files f.part i 1 that should likewise be retrieved. If there is at least one more such file i.e. file f.part shown as N at step then at step index i is incremented by one and at step client GETs the second notated file f.part which includes other files that were stored in server by client during a corresponding PUT process. Then at step client concatenates the second notated file f.partto file f which after the second concatenation contains two notated files f.partand f.part. Assuming there are n notated files i.e. files f.partthrough f.part steps and are repeated until client GETs the last notated file f.part. As explained above each notated file f.partthat client receives from server contains one or more files that client transferred to server during the corresponding communication session i.e. during the corresponding PUT process . By retrieving all the n notated files i.e. files f.part f.part . . . f.part client receives from server every file that was transferred to server by using a common file name. As explained above files may be stored in a server by one client and retrieved from the server by the same client or another client.

The articles a and an are used herein to refer to one or to more than one i.e. to at least one of the grammatical object of the article depending on the context. By way of example depending on the context an element can mean one element or more than one element. The term including is used herein to mean and is used interchangeably with the phrase including but not limited to . The terms or and and are used herein to mean and are used interchangeably with the term and or unless context clearly indicates otherwise. The term such as is used herein to mean and is used interchangeably with the phrase such as but not limited to .

Having thus described exemplary embodiments of the invention it will be apparent to those skilled in the art that modifications of the disclosed embodiments will be within the scope of the invention. Alternative embodiments may accordingly include more modules fewer modules and or functionally equivalent modules.

