---

title: Fair stateless model checking
abstract: Techniques for providing a fair stateless model checker are disclosed. In some aspects, a schedule is generated to allocate resources for threads of a multi-thread program in lieu of having an operating system allocate resources for the threads. The generated schedule is both fair and exhaustive. In an embodiment, a priority graph may be implemented to reschedule a thread when a different thread is determined not to be making progress. A model checker may then implement one of the generated schedules in the program in order to determine if a bug or a livelock occurs during the particular execution of the program. An output by the model checker may facilitate identifying bugs and/or livelocks, or authenticate a program as operating correctly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09063778&OS=09063778&RS=09063778
owner: Microsoft Technology Licensing, LLC
number: 09063778
owner_city: Redmond
owner_country: US
publication_date: 20080109
---
Analyzing and debugging complex programs using a technique called model checking is an important process to ensure that a program meets its design goals during and after development thereof. However a sophisticated program can be challenging to analyze particularly when the program includes multiple threads which are run in cyclic state spaces.

Multi thread programs are characterized by including two or more threads which when executed by an operating system require processor resource allocation by the operating system. For example a program may include two threads t u . During an execution of the program thread t may be executed during a first resource allocation and thread u may be executed during a second resources allocation and so forth such that the resource allocation may look like t u t u u t u . . . t. Unlike acyclic programs multi thread cyclic programs may include an indefinite number of resource allocation sequences thus making it impossible to test each combination of thread executions.

Prior attempts to analyze computer programs include tracking the state of a modified program to determine interactions at each state. More recently stateless model checking has introduced a type of model checking whereby the model checker explores the state space of the program without capturing the individual program states. The program is executed under the control of a special scheduler that controls all non determinism in the program. However prior art stateless model checking only applies to terminating programs which have acyclic state spaces.

Another stateless approach uses a predetermined and arbitrary bound depth to artificially terminate a non terminating program thus making it act like a terminating program. This is disadvantageous because it reduces the coverage of a safety verification thus may not explore a cycle deep enough to uncover improper or undesirable program execution. Conversely increasing the depth bound increases the inefficiency of a search by exponentially adding more resources to unroll cycles in the state space rather than explore new state spaces.

This summary is provided to introduce simplified concepts of fair stateless model checking which is further described below in the Detailed Description. This summary is not intended to identify essential features of the claimed subject matter nor is it intended for use in determining the scope of the claimed subject matter.

Exemplary techniques for providing a fair stateless model checker are disclosed. According to one or more embodiments a schedule is generated to allocate resources for threads of a multi thread program in lieu of having an operating system allocate resources for the threads. The generated schedule is configured to be both fair and exhaustive. In an embodiment a priority graph may be implemented to reschedule a thread when a different thread is determined not to be making progress. A model checker may implement one of the generated schedules in the program in order to determine if a bug or a livelock occurs during the particular execution of the program. In at least one other embodiment an output by the model checker may facilitate identifying bugs and or livelocks or authenticate a program as operating correctly.

Generally speaking stateless model checking provides a well suited technique for analyzing large programs particularly programs including global variables heap thread stacks and register contexts among other characteristics which make capturing each program state impractical. Stateless model checking is a useful technique for systematically testing complex real world software. Multi thread non terminating programs present a particular problem for prior art model checking techniques because they include cyclic state spaces such as spin loops which result in infinite executions.

In an embodiment the application code includes a program and a scheduler . The program may be a real world program that is not modified prior to model checking. The program may be computer software such as and without limitation a utility program a multimedia program a game etc. In an embodiment the program may be tested by the fair stateless model checker just prior to or after completion of a development process. For example the program may be a compiled program that has been generated from an initial software development cycle. The program includes a multi thread structure that is non terminating which creates a cyclic state model of the program.

As shown in the scheduler may generate schedules which may be used with the program . Typically when the program is executed by a computer device the operating system OS determines the scheduling of threads in the program based on a priority and the availability of resources. In such instances model checking becomes difficult if not impossible because the OS may not schedule a wide array of the possible schedules for the threads used by the program. Instead of relying on the OS to schedule the threads the scheduler acts to artificially simulate the scheduling of threads by the OS thus providing control of the thread schedules by the model checker. In an illustrative example the scheduler creates a plurality of schedules which when implemented with the program explore the majority of state spaces of the program.

In an embodiment the scheduler may create a schedule that includes an ordered list of thread execution events. Alternatively the scheduler may schedule one thread at a time and then analyze the outcome of a portion of the program run e.g. the execution of the scheduled thread before scheduling another thread. Therefore the schedule may include a feedback loop that facilitates providing the scheduler with feedback on the thread activity during a program run.

In an embodiment an analyzer may be implemented to analyze the program which is controlled by the thread schedules generated by the scheduler . Thus the analyzer acts as a model checker that executes the program with each schedule generated by the scheduler to analyze the program s response to each different schedule. The analyzer may detect bugs e.g. execution errors safety violations etc. livelocks e.g. non termination errors or the completion of an anticipated program termination APT . The analyzer may output results from the analysis to an output such as a file or a display. The output may indicate locations and or occurrences of bugs and or livelocks or it may indicate the completion of an anticipated program termination such as by issuing an approval certificate.

As an example simple program includes a first thread t and a second thread u which manipulate a global variable x. During operation of the simple program the first thread t sets x to 1 while the second thread u spins in a loop waiting for the update of x by t. A state space diagram depicts the state space of the two thread program . The state of the simple program can be captured by a program counter of the two threads. For instance the state a c is the initial state at which the two threads are about to execute the instructions at locations a and c respectively. The state space contains a cycle between a c and a d resulting from the spin loop of u. As shown this program does not terminate under the schedule that continuously runs u without giving a chance for t to execute thus making it a non terminating program.

Although the two thread program is non terminating it will terminate when executed with a fair schedule thus making the simple program a fairly terminating program. A fair schedule shares resources among the various threads for the program . Conversely an unfair schedule staves a particular thread by dedicating all resources to other threads thus not executing the particular thread. Typically operating systems allocate resources to each thread using a fair schedule thus selectively alternating between the various threads in a multi thread program so each thread has a chance to execute. Often the OS determines which thread is selected based on a priority such as an integer priority value for each thread.

Concurrent programs are tested by combining them with a suitable test harness to make them fairly terminating. A fair scheduler eventually gives a chance to every thread in the program to make progress ensuring that the program as a whole makes progress towards the end of the test. Such a test harness can be created even for systems such as cache coherence protocols that are designed to run forever. The harness limits the number of cache requests from the external environment. The notion of fair termination includes an expectation of a program such as the simple program to terminate when run on a real machine.

When a thread waits for a resource that is not available it either blocks on the resource or yields the processor. A block or a yield tells the operating system scheduler to perform a context switch to another thread such as the thread holding the resource required by the waiting thread. If the waiting thread does not yield the processor and continues to spin idly it will needlessly waste its time slice of a processor and slow down the program. This behavior is consequently considered an error. Therefore in addition to being fairly terminating correct programs also satisfy the following property if a thread is scheduled infinitely often then it yields infinitely often. The simple program satisfies this property because there is a yield statement in the spin loop of thread u. Also a thread that terminates after executing a finite number of steps satisfies the property.

The scheduler as described in may include an exhaustive scheduler and a fair scheduler . An exhaustive scheduler provides all possible schedule scenarios thus making it exhaustive in the literal sense. It follows that an exhaustive schedule for the simple program will result in an infinite number of schedules. The exhaustive scheduler is nondeterministic to guarantee full coverage of safety properties of a program.

With an exhaustive schedule the program is executed under the control of a scheduler such as scheduler that controls all the non determinism in the program thus assuming responsibilities that are typically controlled by the OS. The exhaustive scheduler systematically enumerates all execution paths of the program obtained by the nondeterministic choices.

In at least one other embodiment the fair scheduler schedules a new thread when the exhaustive scheduler tries to schedule a yielding thread. In other words when the fair scheduler is signaled such as by a feedback loop that a thread is not making progress the fair scheduler will stop scheduling the yielding or otherwise non progressive thread and divert resources to a different thread such as a thread that will enable the yielded thread to make progress. Implementation of a fair schedule may exponentially increase the speed of error checking by a model checker because resources are not wasted by scheduling threads that cannot make progress.

As shown in the scheduler includes the exhaustive scheduler and the fair scheduler . Although the exhaustive scheduler and the fair scheduler are depicted separately other implementations may include combining them into a single scheduler module. Taken together the scheduler therefore produces an exhaustive and fair schedule. Thus as long as the program is fairly terminating the scheduler will not generate an infinite number of schedules truly exhaustive because the scheduler includes fair scheduling which will avoid generating schedules that produce a non terminating program run. Instead the fair scheduler will guide the program to allocate resources to threads that are making progress and thus enable the creation of a finite number of schedules.

The analyzer as described in includes a program execution module and a number of detection modules . The program execution module represents an execution of the program within the analyzer which is operable as a model checker. Concurrently during a run of the program by the program execution the detection modules may monitor the program execution using a yield detector a bug detector and or a livelock detector .

The yield detector may detect when the program is not making progress usually because a thread is waiting for another event to occur before the thread can make progress. Progress may be halted when e.g. a thread calls a sleep function a timeout occurs or otherwise when a thread yields to other threads or an event that has not occurred. In at least one embodiment the yield detector may use term or keyword matching to identify when a yield is implanted in a thread. In addition or alternatively the yield detector may perform an analysis of a yielding thread s execution to identify it as a yielding thread.

In at least one embodiment the yield detector provides a feedback loop to the scheduler to signal the scheduler that a thread is not making progress. Further the feedback loop may provide a signal directly to the fair scheduler which in turn may generate a fair schedule for the next thread allocation. In such an embodiment the fair scheduler may dynamically update a schedule created by the scheduler .

The bug detector detects the occurrence of a bug in the program execution . For example a bug may be an execution error that prematurely terminates the program such as by creating a safety violation. In the context of the model checker a bug includes concurrency related errors.

The livelock detector detects a livelock. A livelock exists when the program is not making progress despite a fair schedule which is generated by the fair scheduler .

In at least one embodiment the livelock detector may detect a livelock by setting a bound depth for a program. In practice it is not possible for a stateless model checker to identify or generate an infinite execution. Therefore the user may set an arbitrary large bound on the execution depth which can be used to detect a livelock. This bound can be many orders of magnitude greater than the maximum number of steps the user expects the program to execute. The model checker stops if an execution exceeding the bound is reached and reports a warning to the user. This execution is then examined by the user to see if it actually indicates a livelock. If not the user simply increases the bound and runs the model checker again. Thus livelock detector is able to detect the livelock in the program.

Generally speaking the analyzer acting as a model checker for the program may facilitate the program execution using a schedule from the scheduler . The program execution may be monitored by the detection modules including the yield detector the bug detector and the livelock detector . The program execution may result in a detection of a livelock a bug or an anticipated program termination which may complete a cycle of a unique schedule. Additional schedules may be generated by the exhaustive scheduler until all possible schedules have been exhausted while only fair schedules are generated by the fair scheduler and thus provided by the scheduler for implementation with the analyzer . Finally the analyzer may generate information for the model checker in the output .

Next an analysis of a scheduled thread may be conducted to determine if the thread is making progress at a decision block at . A determination that the thread is not making progress may be established if the thread is yielding to another thread such as in a spin cycle the thread causes a timeout to occur the thread calls a sleep function or any other indication that the thread is not making progress. If the thread is making progress indicated by the absence of progress inhibiting operations the processing flow at may enable the thread for execution in the program.

However if the thread is not making progress at the decision block at then the process advances to a prioritization analysis at . The prioritization may be performed by a priority graph module . The priority graph module may include information to determine the priority of the threads. For example the priority graph module may include a priority graph such as a look up table database or other data source that contains information on the priority of threads used by the program . Each thread may be assigned a relative or absolute priority by the priority graph module which determines when the thread should be called with respect to other threads. For example a thread with a higher priority would be called before a thread with a lower priority assuming that neither of the threads was previously active. When a particular thread is not making progress the priority graph may select another thread or selection of threads which should be scheduled to run thus modifying the schedule to avoid executing a non productive thread.

An illustrative priority graph implemented with the priority graph module may be a relative prioritization that includes three threads u t g . The relative priority of the threads may be expressed as u t g w. For example when thread t has yielded the priority graph will determine that thread u should be schedule over thread g and thread w because thread u has a higher priority. Thread t is not scheduled because it has yielded and is not making progress. In other implementations the priority graph may include absolute priority values such as integer priorities. In one or more embodiments the priority graph may include multiple priorities which include different relationships between the threads. For example a priority graph may include u t g t w thus the relative priority of w with respect to g is undetermined. In some embodiments it may be advantageous to define the priority of threads by relative relationships.

In some embodiments the priority graph used by the priority graph module may be updated to include a partial order on the set of threads in each state. This partial order defines a scheduling priority over threads in each state. An enabled thread cannot be scheduled in a state if a higher priority thread as determined by the partial order is enabled in that state. By appropriately updating such a priority order the fair stateless model checker generates only fair schedules. The scheduler introduces an edge in the priority order only when a thread yields as identified by the yield detector and thereby indicates lack of progress. Thus the prioritization analysis at in conjunction with the decision block at operates as a fair scheduler . For example a non productive thread may be scheduled by the exhaustive scheduler but overridden by the prioritization analyzer at as determined by the priority graph module when the scheduled thread is determined to not be making progress at the decision block at .

The processing flow resumes from either or the prioritization analysis at at a block which depicts schedulable threads. At the threads may be executed to advance the program .

Each of the schedules N may be implemented with the non terminating program during a model checking process such as a model checking process implemented by the analyzer . Each schedule determines the order of the thread executions for each thread in the non terminating program. A complete schedule includes the thread executions for all threads during a full execution of the program. Each schedule is unique thus maximizing resources allocation during the model checking process while minimizing redundancy.

At a decision point a number of possible outcomes may occur when the non terminating program is subjected to the schedules such as schedule . The program may enter a livelock at or a bug may be detected at . A livelock is an instance when the program is executing properly but the program is unable to make progress as opposed to a thread that is unable to make progress as described in relation to the decision block in . For example a program that enters multiple concurrent spin loops may enter a livelock when each spin loop is waiting for the other spin loop to complete. A bug is an error in program code which results in a premature program termination. For example a bug may be an improper call to a function by a thread which terminates the program because of a safety violation.

If a livelock is detected at or a bug is detected at the process flow progresses to report the finding at . In at least one embodiment the model checker may store the schedule that results in a livelock and or bug thus assisting a user to error check the program such as by retracing the state space of the program during the unsuccessfully executed schedule.

Alternatively the program may execute until it achieves an anticipated program termination APT at . The APT occurs when the program does not encounter a bug or a livelock. The APT may be reported at to compile the APT information. As described herein livelocks bugs and APTs are intended to be mutually exclusive while fully encompassing any potential outcome experienced when the program that is subjected to a schedule such as schedule .

Each schedule includes a decision point such as . . . N . Accordingly each decision point may result in a livelock at . . . N a bug at . . . N or an APT at . . . N . In an instance when each of the schedules report successful executions at the process flow may issue a certificate showing the program is correct at . For example the certificate may be used to authenticate a program as having completed the model checking process.

The process may begin by selecting a program to test at . As indicated the program does not need to be modified before it is processed by the model checker. For example the program may be a piece of consumer software that has completed a first development cycle and is ready to be tested for bugs and livelocks. At schedules may be generated for the program which determine when the program s threads are executed. The schedule may be generated by the scheduler which may generate fair and exhaustive schedules. In an implementation the scheduler includes both a fair and exhaustive scheduler in a single module. Alternatively the fair scheduler may be separate from the exhaustive scheduler as shown in .

At the program may be executed with each of the schedules. For example a portion of a first unique schedule may be created by the scheduler . Cumulatively the scheduler creates an exhaustive schedule of all possible fair schedules for the program. At the result of each schedule implementation is determined as one of a livelock indication a bug indication or an anticipated program termination.

The results of all of the schedule runs for the program may be outputted at . For example when the program is prematurely terminated by a bug the program output at may provide information such as without limitation the schedule that caused the bug the point in the schedule where the bug occurred etc. In an instance when no bugs or livelocks are detected for all the schedules the output may issue a certificate which authenticates the program as successfully completing the model checking process.

The illustrative algorithm includes an input of a multithreaded program P together with its initial state init. It assumes that the program P includes a function NextState that assumes a state s and a thread t and returns the state that result from executing t in state s. The illustrative algorithm starts with the initial state and an empty execution. In each iteration of the loop lines the algorithm may extend the current execution by one step. The illustrative algorithm may terminate with a complete terminating execution when the return statement on line is executed.

Each thread t Tid partitions an execution into windows a window of thread t lasts from a state immediately after a yielding transition by thread t to the state immediately after the next yielding transition by t. The algorithm maintains for each state s several auxiliary predicates that record information about a window of thread t.

2. E t maintains the set of threads that have been continuously enabled since the last yield by thread t.

3. D t maintains the set of threads that have been disabled by some transition of thread t since the last yield by thread t.

In addition to these predicates each state s also contains a relation s.P which represents a priority ordering on threads. Specifically if t u s.P then t will be scheduled in s only when s.enabled t and s.enabled u . In each iteration the algorithm may first compute T line the set of schedulable threads that satisfy the priorities in curr.P. If T is empty then the execution may terminate. Otherwise the illustrative algorithm selects a thread t nondeterministically from T line and schedules t to obtain the next state. The model checker must explore the nondeterminism in the execution of Choose T on line . Systematic depth first or breadth first search capability may be added to the illustrative algorithm. At line the illustrative algorithm may remove all edges with sink t from P to decrease the relative priority of t.

The loop at lines updates the auxiliary predicates for each thread u Tid. The set E of continuously enabled threads is updated by taking the intersection of its current value with the set of enabled threads in next line . The set D of threads disabled by thread t may be updated by taking the union of its current value with the set of threads disabled by the latest transition line . The set of scheduled threads is updated on line .

Finally if yield t holds in the new state then the data structures are updated appropriately to mark the beginning of a new window of u line . The set H computed on line may contain only those threads that were never scheduled in the current window of thread t and were either continuously enabled or disabled by thread t at some point in the window. At line the illustrative algorithm reduces the priority of t with respect to the threads in H.

In the emulation the scheduler executes thread u continuously. Starting from the initial state a c the first window of u begins once the scheduler has scheduled u twice. At this point u has gone through the spin loop once and the state is a c again. In this state P S u D u and E u ES t u. When u is executed for one more step u is added to S u and the state becomes a d . In this state yield u is true as u will yield if executed from this state. However the P relation is still empty allowing the scheduler to choose either of the two threads.

If the scheduler chooses to schedule u again the thread completes the second iteration of the loop and the program enters the state a c . Illustrative algorithm adds the edge u t to P because the set H on line evaluates to t. Thus the illustrative algorithm gives the yielding thread u a lower priority than the pending thread t. This update to P makes the set of scheduler choices T t. Thus the scheduler is forced to schedule t which enables u to exit its loop.

Generalizing this example if the thread t was not enabled in the state a c for example if it was waiting on a lock currently held by u the scheduler may continue to schedule u till it releases the lock. Further if t was waiting on a lock held by some other thread v in the program the illustrative algorithm will guarantee that eventually v makes progress releasing the lock.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Thus computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and need not be discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. Communication connection s is one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. for performing particular tasks or implement particular abstract data types. These program modules and the like may be executed as native code or may be downloaded and executed such as in a virtual machine or other just in time compilation execution environment. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media.

The above described techniques e.g. methods devices systems etc. pertain to fair stateless model checking. Although the techniques have been described in language specific to structural features and or methodological acts it is to be understood that the appended claims are not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing such techniques.

