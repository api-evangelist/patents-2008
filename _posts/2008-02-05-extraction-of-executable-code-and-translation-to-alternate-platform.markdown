---

title: Extraction of executable code and translation to alternate platform
abstract: A technique for transferring binary instructions from a computer system to an external platform is described herein. The process extracts binary instructions from the computer system. The instructions include a function at a register location. The process disassembles the binary instructions to produce an intermediate representation of the function. An interruption is inserted at the register location linked to a routine call. The process analyzes the intermediate representation for data dependency to identify internal data references for the routine call and external data references to produce a data dependence representation. The process reconfigures the data dependence representation to produce a reconfigured representation, whose control flow logic produces a logic hierarchy representation for the function. The process then translates the logic hierarchy representation to produce a source code of the function that compiles on the external platform to produce an object code to be linked with the binary code upon execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407675&OS=08407675&RS=08407675
owner: The United States of America as represented by the Secretary of the Navy
number: 08407675
owner_city: Washington
owner_country: US
publication_date: 20080205
---
Pursuant to 35 U.S.C. 119 the benefit of priority from provisional application 60 900 306 with a filing date of Feb. 6 2007 is claimed for this non provisional application.

The invention described was made in the performance of official duties by one or more employees of the Department of the Navy and thus the invention herein may be manufactured used or licensed by or for the Government of the United States of America for governmental purposes without the payment of any royalties thereon or therefor.

The invention relates generally to providing anti tamper techniques to inhibit reverse engineering of pre established binary code on an original system. In particular this invention relates to extraction and translation of select functions in the binary code for separate processing on a secure platform while expunging those functions from the original system.

Various conventional anti tamper techniques include incorporation of physical barriers to hardware tamper detection mechanisms and or complete overhaul of existing systems. Such conventional anti tamper techniques yield disadvantages addressed by various exemplary embodiments of the present invention. In particular the conventional manners may be either insufficient and or cost ineffective for particular applications. A technique for transferring binary instructions from a computer system to an external platform e.g. secure and removable is described herein.

The process begins by extracting binary instructions from the computer system. The instructions include a function at a register location. The process continues by disassembling the binary instructions to produce an intermediate representation of the function. This representation can be provided in symbolic characters such as ASCII. An interruption e.g. interrupt call is inserted at the register location and the interruption is linked to a routine call for the function. The process analyzes the intermediate representation for data dependency to identify internal data references for said routine call and external data references for said function to produce a data dependence representation.

The process continues by reconfiguring the data dependence representation to resolve any discrepancy between the internal and external data references to thereby produce a reconfigured representation. The process further analyzes the reconfigured representation for control flow logic to produce a logic hierarchy representation for the function. The process then undertakes translation of the logic hierarchy representation to produce a source code corresponding to operation of the function the source code then being compiled on the external platform to produce an object code to be linked with the binary code upon execution.

Other various embodiments alternatively or additionally provide for replacing the function at the location on the computer system with obfuscation code. Also the analysis of the reconfigured representation may include its optimization to reduce computational load and or insertion of a register association between each internal data reference for the routine call and each external data reference for the function. Alternate embodiments include reconfiguring the data dependence by incorporating on the external platform a library that the function may call with the external data references or else by incorporating on the external platform a protocol interface that routes the routine call from the interruption with the internal data representation that includes input to the function with the external data representation that includes output.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and logical mechanical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

Binary Synthesis Translation BST represents a technique that safely enables extraction of one or more portions from a legacy executable code labeled Critical Program Information CPI to be compiled linked and executed on a separate secure platform as a method in anti tamper application counter technology ATACT to mitigate security gaps. A legacy platform represents a pre existing computer system such as commercial off the shelf COTS hardware. An executable code represents compiled machine language instructions in binary form produced from translation of higher level language source code e.g. written in Fortran Ada Pascal C etc. to perform specific operations to yield a particular result such as a target solution for a specific weapon system.

Upon such extraction of this binary code advanced optimization and or translation operations can be applied. A secure platform can be a removable field programmable gate array FPGA and be custom designed for application specific operations. Colorado Engineering Inc. of Colorado Springs Colorado supplies an exemplary such platform configured as firmware automated test system FATS board. This approach enables the extracted code to be separately executed upon the secure platform rather than the original legacy system which may be subject to compromise by reverse engineering. Vulnerability of legacy systems can increase dramatically for hardware distributed through a foreign military sale FMS .

To threaten a legacy system an attacking system may interrogate an integrated circuit in that system by issuing random input signals to the circuit and analyzing its response signals. A variety of such circuits are employed throughout the Navy for various weapons platforms such as the AN SPY 1D V phased array radar used aboard naval combat vessels. Select functions of those systems might be compromised without segregating select instructions to and or responses from the circuits. Such segregation may involve development of anti tamper AT protections. However older systems may instead be redesigned rather than retrofitted depending on which course of action may be more expedient or less expensive. Due to the customer including military preference for COTS software constructing a new system absent relevant source code remains impractical. Instead attention focuses on providing a secure mobile add on type solution that includes maximum flexibility and portability.

Decompilation represents one operation for reverse translating from executable binary code to reconstruct equivalent human readable source code. The first known code decompiler was developed in 1960 through a project directed by Maury Halstead using Neliac as a Universal Computer Oriented Language. Joel Donnelly and Herman Englander implemented the D Neliac decompiler for the Univac M 460 Countess Computer while on Maury s staff. The D Neliac decompiler was an operational decompiler that decompiled Univac M 460 binary code into Neliac source code.

System platform dependency and application programming interface API routines native to a given operating system are bound into each binary image by the compiler. API routines may be written in the language of the compiler or in lower assembler. The operation results in a binary program that contains not only the routines written by the programmer but several other routines linked in by a linker. A typical binary program written in C to display hello world and compiled on a COTS platform contains over twenty two different API subroutines in the binary program. The same instructions written in Pascal generate more than thirty seven subroutines in the executable program. Additional code may be required to construct a graphical user interface GUI .

Conceptually a decompiler functions very similarly to the way a compiler operates. The decompiler retrieves instructions from one format and translates them to another. Decompilation may be subdivided into several steps or phases to accomplish this translation. In association with this disclosure select steps are based on compiler and optimization theory using several different components of existing Open Source decomplilers such as dcc Boomerang and Andromeda. Cristina Cifuentes wrote the UNIX based dcc decompiler. Boomerang primarily developed by QuantumG and Mike van Emmerik is a UNIX Windows based GUI system and perhaps represents the most mature of the major decomplilers in current use. Andromeda is a GUI version for Windows developed by Andrey Shulga.

The module may include several components such as an FPGA a central processing unit CPU FPGA load LD dynamic ram DDR Ethernet ENET power regulator PWR and switches. The external connectors may include power and or Joint Test Action Group JTAG pins and input output I O pins . JTAG complies with the IEEE 1149.1 standard for test access ports. The ATACT module may be physically protected by a tamper detection circuit and surrounded by an external coating to inhibit reverse engineering.

The BST process for obtaining such a configuration begins with the legacy system which incorporates a set of machine executable instructions in binary form having been compiled from an earlier assembly or source code that was compiled and linked with library functions and memory addresses. A portion of the code represents CPI determined from the addresses. The binary CPI portion can be disassembled to produce a tabular sequence. From this sequence analyses may be performed to establish data dependencies and code flow i.e. conditional order sequence . These instructions may be presented in symbolic characters for intermediate representation. These symbols can be stored as data within internal data structures created by an executing program

Global Data Flow analysis can be conducted on the intermediate representation to construct a data dependency list for each exported CPI function and resolve all data register dependencies. The Data Flow may exchange information with a Symbol Table for register cross referencing. Control Logic Flow analysis provides function and subroutine calls to connect each diverted call to an interrupt for forwarding to the secure FPGA for processing. The data and control analyses can be used to generate CPI Relocatable Library functions in a dynamic CPI library. The operations including the CPI functions can be tested and evaluated using the CPI dynamic library to verify proper execution. Upon satisfactory completion of the evaluation the CPI function code can then be translated to match the specific CPU core to be implemented in the FPGA on the ATACT module . Finally the CPI library loaded in the FPGA can then be tested with the legacy system for intended operation.

Due to differences in hardware between the legacy system and the ATACT module various instructions can be optimized to streamline computational operations. These analyses and optimizations thereby yield synthesized CPI source code or CPI S to be compiled on either a library platform or the ATACT module for linking with the remaining legacy system binary code.

The CPI instructions originally installed on the legacy system may be replaced at its entry point with a redirection to an interrupt table which may call a simulation library that contains the transferred CPI S instructions that have been recompiled. Because the legacy system and ATACT module may differ in clock speeds the SPY 1D running typically much slower than more recent FPGA designs an interrupt table represents one exemplary method to synchronize data exchange between these platforms. For example a call to a CPI function with inputs may be routed to the interrupt table.

The function may be processed by the CPI S in the simulation library that returns outputs to the interrupt table for providing to the call after an appropriate wait state for the legacy system. Upon verification of the CPI S function the code may be translated as a CPI ST function for integration with an interface protocol on the ATACT module . The FPGA execution code containing the CPI ST remains encrypted this code can be decrypted with a non volatile Key that is not externally accessible. The FPGA has input line tamper detection capability to compliment physical protections of the ATACT module .

For example the FPGA may include a protected critical circuit an input monitoring model and an output obfuscation model. Data flow through an input monitoring model to be characterized as either conforming as operationally expected or attack by random signals. An attempt to tamper with the FPGA can be detected by invalid e.g. random inputs so that the input monitoring model shifts to an alert state either issuing an alarm of the attack or producing obfuscated outputs to the attacking interrogator. By contrast conforming data pass through the critical circuit and the output obfuscation model without obfuscation or warning. This is subsequently described in portions of this disclosure on learning and operational phases.

Upon establishing a connection between the host system and the repository a CPI library may be packaged and tested on the host system . The previous function entry point is directed to the Interrupt Table by an interface pointer . The Interrupt Table may then be directed via connections to the repository representing a dynamic library containing the CPI S Func and CPI S Func as and respectively. The CPI S code may be translated to match an FPGA core to product CPI ST . For example CPI S Fund can be connected to a Hewlett Packard platform an Intel X86 processor a PowerPC a SPARC workstation and or a reduced instruction set computer RISC platform.

Optimization represents a process to alter instructions for improved operational performance. The analysis includes detection of data dependencies in memory registers to enable exchange of variables from a vulnerable system to be offloaded and processed on a secure platform. Instructions can be optimized by replacing high overhead or bottleneck operations with substitute instructions. Examples of optimization techniques include loop unrolling explicit replication of the loop body multiple instances and inverse multiplication to avoid cornputationally intensive division . Careful attention can avoid creating hazards that can cause the instructions to produce output other than that intended.

Operating a radar system might include an example function of delivering a range distance as an output in response to azimuth and elevation inputs. shows hex bin dump contents from an initial legacy program with symbolic line terminating characters suppressed analogous to block on the host platform. The column of data following the text08048 . . . prefix represents the original legacy byte swapped binary image consisting of instruction and data. These data may be read directly off a read only memory ROM storage device.

After analyzing the disassembled list using BST methodology for data and control flow the input parameters can be diverted to an interface for external processing. show a disassembly list after modification to replace the CPI function. illustrates the legacy main after employing BST. In such a case an I O chip such as an 8255 may be used to store variable data that can be referenced by the CPI external interface during execution. Arrow points to three out commands write the value of each variable to the 8255 chip in intervals of eight bytes at a time. Each variable has a double precision requiring eight bytes. Arrow points to an interrupt service routine interface to pass execution to the external CPI function. illustrates the CPI procedure after BST and obfuscation resident on the legacy system. The CPI functions are replaced and remotely executed to inhibit reverse engineering.

Following the translation of the reconfigurable CPI functional instructions into source code written in Impulse C to be compiled on the FPGA and linked to the legacy system. show an exemplary listing including all necessary hooks or stubs to receive relevant library calls. illustrates the beginning portion with arrow showing input and return variables in double precision. illustrates the middle portion with arrow pointing to the azimuth and elevation inputs and arrow pointing to the range distance output. shows the final portion that defines buffer size.

Various exemplary embodiments provide an automatic system that transform a given binary image from a given host platform into a newer optimized binary image that executes faster on a variety of target platforms. The system can operate with or without original source code. In select embodiments the system may translate and synthesize any input binary image in to a mobile optimized code set that will execute on any target platform.

Binary Synthesis Translation BST can be characterized as a system composed of several phases which are grouped into modules dependent on language or machine features. The front end is a machine dependent module that parses the binary program analyzes the semantics of the instructions in the program and generates an intermediate representation of the program. A control flow graph may be generated for each subroutine. BST can operate with language and machine independent modules. The system analyzes the low level intermediate code and transforms it into a high level representation available in any high level language and analyzes the structure of the control flow graph s and transforms them into graphs that make use of high level control structures. Finally the back end is a target language dependent module that generates code for the target language.

BST benefits from compiler and Application Programming Interface API signatures resident within a binary image. In the former compiler signatures for any start up code are ignored and not decompiled. In the latter any API references are used for variable type information and propagated throughout the function analysis process. The BST system comprises the following modules each with a set of corresponding sub modules 

The syntax parser analyzer in the front end groups bytes of the source program into grammatical phrases or sentences of the source machine language. These phrases or Idioms may be stored in a hierarchical tree. The hierarchy in machine code is restricted to a maximum of two levels. The primary problem encountered while parsing machine code is distinguishing between data and instructions. For example a case table usually residing after the function that invokes may be located in the code segment with the decompiler unable to determine which the table represents. This is a common problem with COTS memory architectures that utilize the von Neumann architecture in which data and code reside in same memory . Instructions cannot be parsed sequentially by assuming that the next byte always holds an instruction. Many machine dependent heuristics are needed in order to determine the correct set of instructions.

The semantic analysis phase checks the source program for the semantic meaning of groups of instructions. The type information may be gathered and propagated across the subroutine. Based on the assumption that binary programs were produced by a compiler the semantics of the machine language may be presumed correct in order for the program to execute assuming the program originally executed properly . Thus semantic errors may be assumed not to be extant in the source program unless the syntax parser has performed an error such as data have been parsed instead of instructions.

The process of intermediate code generation enables an intermediate representation of the source code to be created for analysis and modification. The intermediate representation can be used to enable the decompiler to analyze low level structures within the module. A road map may be followed during the generation process to facilitate migration to the target language of the reconstructed source code. This phase may use three address code instruction mapping.

A control flow graph of each subroutine can be generated from the intermediate representation. This approach can be very useful for removing dead code and obfuscations and determining def use relationships across procedures. High level control structures used in the program can also be identified. This graph may assist in removal of compiler generated intermediate jumps.

Redefining this intermediate representational code can be facilitated by data flow analysis by identifying high level language expressions. Temporary registers and condition flags may be removed as these constructs are not used in high level languages. This process involves determining data dependencies and defined usages within a basic block of code.

API signature type information may be used to assist in identification of variable types. This information may then used throughout the procedural data scoping process. Once the procedure data scope has been established then a higher order inter procedural data scope may be obtained. During this process complex global data flow analysis equations are solved for each procedure. This includes any parameters that are referenced by the procedure and any return values and any global data variables are modified inside the procedures.

The final phase or back end of the process involves producing target source code by code generation after specifying the target language along with any optimizing or specific in lining options. Traversal of the control graph for each sub routine may be implemented to handle such issues as variable naming local stacks arguments and register variable identifiers. Additionally the control structures and intermediate instructions created in earlier steps may be translated at this phase to high level language statements.

The previous description concerns converting machine language to a higher level language source. Many weapons systems to be protected use machine language originally derived from assembly language source rather than a high level language such as Ada C or Fortran.

An exemplary approach with the SPY 1 D radar combat system begins by identifying the CPI machine code to be extracted. The extracted binary code is disassembled into an intermediate representation from which may be generated control flow graphs conduct semantic analysis data flow analysis single static assignment data propagation register variable identification data type propagation data type analysis primitive data types complex data types control flow analysis. This enables extraction of a function or functions void of any data dependencies and API dependencies. This function renders a sequence of code that can be executed outside its initial environment.

After CPI extraction the host executable code shown in should be patched where CPI code once resided at its function entry point . In addition the external CPI function on the module can be invoked by the host machine. The next instruction after the function entry point can be replaced with an interrupt service routine ISR call. This ISR may reside within the host Interrupt Table . The ISR may examine the contents of the stack contained by the process that invoked the ISR to identify a return address which points back to the location directly following the ISR invocation. This information enables determination of which CPI function call is invoking the ISR routine.

For the CPI to execute remotely a mechanism may be provided to enable the CPI function to execute an ISR instruction on the host remotely on an external secure module . For example the CPI function calls an operating system API routine that in turn issues the ISR request. The host target machine and the external secure platform e.g. FATS integrated board can be provided with a remote procedure call RPC interface module IDC that includes both client and server capability to permit a CPI function to issue an ISR call while executing remotely.

In the event of the CPI function issuing an ISR call back to the host machine a CPI call may be issued within the context of a remote procedure call client. The host machine functions within the context of a remote procedure call server. Upon completion of transforming and extracting the CPI code from the original executable a remote relocatable library can be packaged as a library module shown in . This library module can be initially tested with in the original host executable process environment. This operation can be performed to ensure that all dependency memory system call operations have been resolved correctly. This process is very similar to executing a program and then at run time issuing a system load library call to load a given dynamic library into a process space.

A validation and verification operation can be conducted to insure proper operation of the CPI. The CPI functions may be coded on a secure FPGA chip shown in that resides on an external FATS integrated board . The FPGA may employ a 128 bit Non Volatile encryption strategy with a key that cannot be extracted externally. At this point the type of core execution image to reside within the FPGA may be decided. Under a soft core execution environment EE the system runs at a greatly reduced speed but with greater flexibility. Under a hard core EE image the system can execute up to 800 MHz. Changing the EE of the FPGA may require translation of the CPI code to match the EE of the FPGA. The Altera that runs about 800 MHz represents an exemplary FPGA for these purposes.

This approach introduces a degree of operational latency by virtue of passing thru the ISR and RPC code. This may not present difficulties with the 1750 CPU found in the SPY 1D which currently runs at 33 MHz. The principle timing concern in this case involves not issuing a return too early back to the host process. For newer COTS systems however typical CPUs execute internally at 3.0 GHz range but remain nonetheless able to fetch instructions and memory only at local bus speeds which are typically in the 800 MHz range.

Techniques as Function Level Working Set tuning can be used to rebuild the extracted functions with BST. The functions can be profiled for execution within a target executable of the FPGA. The functions that are executed more frequently than others can be moved closer to the top of the module. This way the operating system can keep the popular code in memory and only load the remainder of the module as needed and then page the remainder out again at the conclusion of use . This approach can provide for a significant increase in speed by reducing on demand memory paging.

Operational speed of the extracted function can be further increased by implementing strategies like reciprocal multiplication as mentioned in context of optimization. Reciprocal multiplication uses multiplication instead of division in order to implement the division operation. Typically multiplication is four to six times faster than native division operations. This process involves multiplying a dividend by a fraction that represents the reciprocal of the divisor. For example dividing thirty by three can be performed by computing the reciprocal of three or one third to yield approximately 0.3333333 and then multiplying thirty by this reciprocal of three to produce the correct result of ten.

Further optimization can be achieved by deconstructing an instruction and implementing its micro code underpinnings. A typical floating point instruction found in many CPI algorithms can frequently be implemented as lower level multiply and divide operations. Symmetric parallel optimization can be applied during the construction process with which to fabricate a custom micro instruction to run much faster than the original instruction. The FPGA may include additional I O pin tamper detection safety circuitry to prevent black box attack. In order to defeat probe attempts i.e. interrogation with arbitrary input signals an Altera FPGA is equipped with a tamper detection capability. This may be performed by learning and operational phases.

In the learning phase an Input Monitoring Model is trained from real or simulated inputs and outputs to the device to be protected. These inputs and outputs can be measured obtained from the device specification or extrapolated from piecemeal knowledge of the device s characteristics. Upon creation of this database of known I O combinations both normal operational inputs and simulated tamper style inputs the database may be applied to a time sensitive Input Monitoring Model.

In the operational phase such as after FMS the component under protection is considered to be either in its normal operational environment or else is outside of this environment and being subjected to laboratory attacks. External inputs are received by the augmented anti tamper package and fed directly to the protected component the Input Monitoring Model and the Output Obfuscation Model. These inputs come from either the intended environment or from laboratory testing the component does not identify the source initially. In the former case the Input Monitoring Model will respond with a No Tamper signal. This signal is used by the Output Obfuscation Model s Gating Mechanism to pass the normal operational outputs from the critical component through to the output of the augmented package.

Upon recognizing that the input represents an attack the Input Monitoring Model outputs a Tampered Input signal which initiates processing within the Output Obfuscation Model. Based upon the temporal inputs being received and the indicator from the recognizer the generator produces obfuscated outputs that are then passed through the gating mechanism to the output.

BST solves many interrelated software vulnerability problems present in modern computer systems as well as older legacy systems. BST can aid in identifying polymorphic viral code that escapes scrutiny of today s current signature based anti virus products. BST can be used to mitigate buffer overflow vulnerabilities in legacy COTS code by extracting unsecured code to be executed within a secure framework. BST can be used to prevent Reverse Engineering efforts by protecting CPI code in a secure shielded environment particularly software vendor s protection mechanisms can be extracted and executed in a secure environment as well as military weapon systems CPI content. BST can be used to assist in software optimization and or upgrading of obsolete legacy code to modern software libraries.

The advantages over current technology include the ability to synthesize binary code to run on secure mobile encrypted platforms like the picture above. The systems provides for new features that include the ability to add on to a legacy system as opposed to building a new system. The system can execute faster than current legacy systems due to automatic variable scalarization and loop unfolding techniques.

While certain features of the embodiments of the invention have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the true spirit of the embodiments.

