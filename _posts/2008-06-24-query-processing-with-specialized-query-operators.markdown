---

title: Query processing with specialized query operators
abstract: Queries targeting various data sources are processed in a query processing pipeline that parses the query into a set of operations (e.g., an expression tree or a translated SQL query) using a set of query operators, each handling a particular type of operation. The query operators are often designed in an unspecialized manner, such that each query operator handles one query operation in an atomic, generic manner (e.g., sorting generic data items for an ORDER BY clause.) More efficient queries may be devised by including specialized queries that operate in common but special cases, such as a sorting of a particular data type (e.g., a floating-point number sort) or a sequence of two or more operations that are often performed together (e.g., a WHERE test of an attribute followed by a SELECT of the same attribute.) The use of specialized operators may result in the formulation of more efficient queries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713048&OS=08713048&RS=08713048
owner: Microsoft Corporation
number: 08713048
owner_city: Redmond
owner_country: US
publication_date: 20080624
---
Queries of data sources e.g. SQL queries applied against a relational database or in memory queries against queryable local objects are often written in a programming language such as a source code for an application. A query written in one manner e.g. a language integrated query specified according to a programming language is often processed by a query processing pipeline which interfaces the query with the data source by parsing the query translating it into a more easily managed form e.g. SQL or an expression tree serializing any objects or values used in the query and sending the translated query to the data source. The query processing pipeline may also receive a query result such as a result data set and may present it to the rest of the application.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Query processing pipelines often involve one or more query operators which are components configured to provide querying services e.g. parsing the query validating the syntax and generating a translation for a particular query term such as SELECT WHERE JOIN ORDER BY etc. The query processing pipeline may therefore parse the query by selecting a query operator for respective query terms and by invoking the selected query operators to generate appropriate elements of the translated query.

These query operators are often designed in a simple broad manner that focuses on a single operation and on a maximally broad range of data types such as a SORT operation applied to any comparable objects or values. This RISC like configuration provides a reduced set of query operators that each applies to a broad range of operations. However more particular types of queries may often arise within queries. As a first example while sorting may often be performed on any types of comparable objects or values it is often applied to sort text strings in alphanumeric order. As a second example some operations may often be performed in a particular sequence such as a test and select operation that first applies a WHERE conditional test to a particular attribute and if the condition is satisfied selects the attribute into the result data set.

If these types of more specialized operations arise with sufficient frequency it may be advantageous to devise one or more specialized query operators that are capable of processing a specialized type of operation e.g. an operation that is often applied to a particular data type or a set of operations that are often applied in a particular sequence. The specialized query operators may coexist in the query operators set alongside the unspecialized query operators and may be included in a selected sequence of query operators in order to process a query. For example a query processor may attempt to select specialized query operators for a portion of the query e.g. an operation that is performed in the query on objects or values of a known type and if no specialized query operator can be found the query processor may select unspecialized query operators to handle the query portion. The inclusion of specialized query operators may improve the efficiency of the processing and may enhance the performance of the query processor.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Queries against data sources such as relational databases and queryable local objects may be devised in many computing scenarios such as data driven applications and websites rendered from content management systems. A query is conventionally written in a language such as a general query language such as SQL a domain specific query language or a programming language such as a language integrated query and specifies the logical operations to be performed on a data source in order to retrieve a desired set and shape of data from the data source and or to alter the data source in a desired manner.

A query written in a language is often processed in order to issue the query against the data source. This processing may involve e.g. validating the syntax of the query according to the conventions of the language transforming the query into a form that is more easily processed by the data source such as an expression tree and serializing local objects to be used in the query. The query may then be delivered to the data source e.g. a relational database server for application against the data source. If the application results in a response such as an indication of query success or completion or a result data set retrieved by the query the processing may also involve receiving and handling the response e.g. by deserializing one or more objects representing the result data set. Together these processing aspects form a query processing pipeline that provides a variety of services while operating as an interface between the query and the data source.

Query processing pipelines are often designed predominantly to handle the four basic types of queries CREATE or INSERT queries which insert new records or objects into the data source READ or SELECT queries which retrieve data from the data source UPDATE queries which modify data already in the data source and DELETE queries which remove records or objects from the data source. Other types of queries may also be available such as queries that explore or modify the structure of the data source but these four types of queries often comprise the bulk of interactions with the data source.

In order to handle the four predominant types of queries CREATE INSERT READ SELECT UPDATE and DELETE query processing pipelines are often configured with a set of query operators that are configured for one of these actions such as an insert query operator a select query operator an update query operator and a delete query operator. Other query operators may be included to handle other operations of the query e.g. a join query operator may be provided for operations that involve connecting different sets of relationally linked data a sum query operator may be provided for operations that involve adding a series of values and a sort query operator may be provided for operations that involve sorting values. These query operators may provide a variety of services in the query processing pipeline such as validating the syntax and logic of the specified operation and generating SQL or a node of an expression tree representing the specified operation. The processing of the query may then involve parsing the query to identify the types of operations specified in the terms of the query selecting an appropriate query operator for respective terms of the query and invoking the query operators to perform a service such as generating SQL for these query terms.

These query operators are often configured to operate in a simple generic manner that performs one operation on a broad range of object or value types. For example a UNION query operator is often configured to merge two sets of data regardless of the types of data contained therein and with a minimum of additional activity or side effects. Similarly a SORT query operator is often configured to sort any type of comparable object or value and the sorting logic of precedence is relegated to the types of objects and values being sorted e.g. upon receiving two objects to be sorted the query operator does not attempt to identify which object precedes the other but rather asks the class of the objects to make a decision for these two class instances. A query may then be processed by generating a sequence of simple query operators each performing a minimum of processing on a broad range of data types. It may be appreciated that this approach resembles a reduced instruction set RISC architecture having a constrained set of simple instructions.

In the exemplary scenario of the data source describes a set of books available at a library and in particular a table indicating the checked out status of particular books comprising three attributes the ID of a book the date that the book was checked out and a customer ID identifying the borrower of the book. The query requests a set of dates of books checked out of the library by a particular borrower with customer ID 061974 in calendar years 2008 and beyond which is to be sorted in ascending order by date. The query is parsed to identify the logical operations to be invoked including a FROM operation that identifies the table in the data source to be queried a first WHERE operation that filters the rows of the table according to the customer ID a second WHERE operation that further filters the rows of the table according to the checkout date a SELECT operation that retrieves the checkout date attributes of the filtered rows and an ORDER BY operation that sorts the checkout date attributes in ascending order. Each operation may be handled by a particular query operator capable of handling such operations e.g. a sort query operator may be selected to handle the ORDER BY operation . Once a sequence of query operators has been selected the selected query operators may be invoked to generate translated query components e.g. SQL clauses that correspond to these operations. The processing solution may then be assembled by aggregating the translated query components that specify the details and sequence of these operations.

While this type of query operators set may promote the robustness of the query processing it may be inefficient in other respects. As a first example a type of operation may often be processed on a particular data type e.g. while a SORT query operator may generally apply to any type of comparable objects or values it is often applied to sorting strings by alphabetic priority and sorting numbers by magnitude. However an unspecialized sort query operator may not presume that the objects being sorted are of a particular or uniform type because a sort operation may be applied to a heterogeneous set of objects or values e.g. a number a string and a class instance and these different objects may indeed be comparable based on some IComparable interface implementations associated with respective data types. Therefore an unspecialized sort query operator may compare any two objects or values by identifying the types thereof identifying a comparing function that can compare objects of such types and invoking the comparing function to determine the relative ordering of the two objects or values. While this unspecialized sorting may exhibit an advantageous robustness it may be disadvantageously slow where the objects are of a uniform and known type e.g. a set of strings and the operator may unnecessarily identify the type of each string and may repeatedly seek the same comparing function to sort respective strings. Moreover some particular types of data may be sorted in an efficient manner e.g. a set of numeric values may be quickly sortable by a radix exchange and text strings may be efficiently sorted by various techniques relating to the nature and formatting of the text strings but an unspecialized sort query operator may be unable to utilize such efficiencies because of the generic nature of the data that the unspecialized query operator is configured to handle.

As a second example while the atomic nature of unspecialized operators may enhance the robustness of the query language by extending the range of queries that may be specified and handled the atomicity may not reflect common pairings of operators that are often performed in a particular sequence. For example many queries may involve a test and select sequence where a particular attribute of items in a data source is tested against one or more criteria and the attributes that fulfill the criteria are selected into the result data set e.g. select attribute A where A X . This sequence may be handled by an unspecialized WHERE query operator that tests the attribute and an unspecialized SELECT query operator that selects the attributes that fulfill the criteria. However the use of two query operators may be inefficient e.g. the attribute of a record may be retrieved by the WHERE query operator and tested and if the record passes the test the same attribute of the record may be retrieved again by the SELECT query operator for inclusion in the result data set. The use of two query operators in this operation and the redundant retrieval of the attribute may represent an inefficiency in the processing of the query.

Turning again to the processing solution derived from the query exhibits both types of inefficiency due to the selection of unspecialized query operators in the processing solution . As a first example the ORDER BY operation is not informed that the selected attributes are both uniform and of the string type and the unspecialized sort query operator may specify a generic sorting of objects that involves identifying a comparing function for any two objects and invoking the comparing function. As a second example the second WHERE operation is handled by an unspecialized where query operator and the SELECT operation is handled by an unspecialized select query operator. The where query operator specifies that the CheckoutDate attribute of the records of the data source is to be tested against a particular value which may lead to particular records being flagged for inclusion in a result data set. The select query operator then specifies that the CheckoutDate attribute of the included records is to be retrieved into the result data set. As a result each CheckoutDate attribute is operated upon twice and may be retrieved twice from the data source this represents an inefficiency that may cause a significant reduction of performance in the processing of the query against the data source .

The inefficiencies exhibited in the exemplary scenario of arise from the unspecialized nature of the query operators in the query operators set . Such unspecialized operators are often included in the query operators set to ensure that the full range of syntactically and logically valid queries may be processed. However the inefficiencies may be reduced by adding specialized query processors to the query operators set that may handle specialized operations of different types. As a first example if query processors are often selected to sort strings and numbers it may be advantageous to include in the query operators set a first specialized SORT query operator for sorting strings and or a second specialized SORT query operator for sorting numbers which may coexist in the query operators set alongside the unspecialized generic SORT query operator. As a second example if two or more operations are often performed in a particular sequence such as a WHERE operation applied to test an attribute followed by a SELECT operation that retrieves the attribute into a result data set it may be advantageous to include in the query operators set a specialized query operator that performs both operations and coexists in the set of specialized query operators alongside the unspecialized atomic WHERE and SELECT query operators. This specialized query operator may reduce the number of query operators involved in the processing of the query and may provide a more efficient processing of the query e.g. by specifying two operations on a particular attribute rather than a first operation on an attribute and a second operation that happens to pertain to the same attribute. 

Accordingly a query operators set may be devised comprising unspecialized query operators for handling atomic generic operations as well as at least one specialized query operator that handles a specialized operation e.g. an atomic operation applied to a particular object or value type or a non atomic sequence of operations applied generically to objects and values of any suitable type. A query may again be processed by selecting a sequence of query operators that together embody the structure and logic of the query but the selected query operators may include one or more specialized query operators which may be connected in the sequence with other specialized and unspecialized query operators. If the query operator selector can identify a specialized operation for a portion of the query e.g. a sorting of values or objects of a known type a specialized query operator may be selected for processing the portion otherwise one or more unspecialized query operators may be selected for processing the portion. The selected sequence of specialized and unspecialized query operators may therefore lead to a more efficient processing of the query than a sequence of unspecialized query operators.

As illustrated in a query operators set comprising both unspecialized query operators and specialized query operators may be utilized to produce a better processing solution for many types of queries than a query operators set comprising only unspecialized query operators. As in the processing solution for the query in includes a selection of the unspecialized from query operator to handle the FROM operation and the unspecialized where query operator to handle the first WHERE operation . However the second WHERE operation and the SELECT operation are combined into a specialized TEST AND SELECT operation handled by a specialized test and select query operator which specifies a more efficient processing due to the specialized sequence of operations e.g. by eliminating the redundant second accessing of the attributes illustrated in the less efficient processing solution of . Also the ordering is now handled by a specialized date sorting query operator that specifies a specialized ORDER operation particularly suited for sorting a uniform set of date values in a more efficient manner. The resulting processing solution may therefore exhibit some efficiencies that improve the application of the query against the data source and the performance of data driven applications consuming the result data set of the query .

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary method of and the exemplary method of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among implementations relates to the types of queries processed according to these techniques and the types of query processors in which such techniques may be utilized. A first example involves a language integrated query where a conventional programming language is extended to include some syntax and supporting libraries for specifying queries. A language integrated query differs from a non language integrated query where the query is specified as a separate data construct that is handled by components of the programming language e.g. as a text string that is simply generated and passed to the query processor and where the syntax is not parsed and does not directly interact with other components of the first language. By contrast a language integrated query is specified according to the syntax of the programming language and the logical constructs of the query may be evaluated and compiled by the compiler as operations. The query in illustrates one such language integrated query wherein the query syntax is specified in an object oriented programming language that directly interacts with functions and objects of the source code. In processing the query a compiler might utilize a query processing pipeline that translates the language integrated query into a translated query specified in a query language e.g. SQL and this query might then be sent to an SQL compatible query processor. Alternatively the compiler might generate a set of instructions that comprise the logic of the query such as an expression tree having nodes that represent particular operations that are connected to indicate the logical sequence of application to the data source. As a second alternative these techniques might be included in a programming library such as a runtime that serves as an interface between a data driven application having one or more queries and the data source to which the queries are to be applied. The programming library might receive queries from executing applications process the queries through a query processing pipeline and mediate the delivery of the query to the data source and the return of a result data set in response to the query. The programming library might also receive and execute queries on behalf of executing applications against queryable local objects this may be advantageous for improving the local performance of the querying and by extension the data driven application. As a third alternative these techniques may be included in a manager of the data source such as a database server capable of receiving and processing queries specified in many types of languages. The database server might therefore comprise the data store targeted by the query and a query applying component configured to apply the query processing solution to the data store. Those of ordinary skill in the art may devise many types of queries and query processors to which the techniques discussed herein may be applied.

A second aspect that may vary among embodiments of these techniques relates to the manner in which the specialized query operators are specialized as distinguished from the unspecialized query operators. A specialized query operator may be formulated as one or more operations that may handle a portion of a query that meets one or more specialization criteria. As a first example a specialized query operator might specify that the query performs at least two query tasks specified in at least two query terms. The specialized test and select query operator in exhibits one such specialization criterion and is applicable to a portion of a query that comprises a WHERE operation in a first query term that operates on a particular attribute followed by a SELECT operation in a second query term that selects the particular attribute. Other such combinations may be specified as specialization criteria such as a sequence of three or more operations that are commonly invoked together e.g. select from table where attribute value may be sufficiently common to motivate the development of a specialized conditional row selector query operator that combines a FROM operation a WHERE operation and a full row SELECT operation. This type of specialization may produce specialized efficiencies in the synergy of the operations e.g. instead of retrieving and testing an attribute to fulfill a WHERE operation and then retrieving the attribute again in a SELECT operation that produces the result data set the attribute may be retrieved tested and included in the result data set in one operation. 

As a second example of this second aspect a specialization criterion of a specialized query operator might specify at least one data type involved in the query task. The specialized date sorting query operator in is one such specialized operator that specifies the performance of the sort operation on data items of the DateTime type. This type of specialization may permit type specific enhancements of the operation for specialized types of data e.g. a sort operation specialized for sorting numeric values may utilize a radix exchange sorting technique while a sort operation specialized for sorting text strings may utilize text comparison techniques both of which may be faster than a generic sorting technique. Alternatively or additionally the specialization criterion of such a specialized query operator might specify a property of a data type e.g. the specialized query operator might be applied to any type of object supporting a particular interface. This type of specialization may permit the development of more efficient query operators to be applied to particular types of data. For example this type of specialization may permit the query processing solution to avoid an unnecessary typecasting in a translated query e.g. whereas an unspecialized select query operator might produce an SQL query such as select i as int which requires a typecasting of the retrieved attribute a specialized select query operator that is specialized for integer types might produce an SQL query such as select i for an attribute that is known to be an integer. Moreover the specialization might be applied to avoid typecasting an entire aspect of a data set e.g. a specialized query task may apply to the data set comprising objects of the specified data type. Thus a language integrated query specifying int i from select Integer.Cast . . . may be processed to eliminate the casting of the entire array if the attributes are known to be of integer types. Also this type of specialization may be layered to produce even greater efficiencies. As a first example a first specialized query operator may specify a query task involving a first data type e.g. a number and a second specialized query operator specifying the query task involving a second data type that is more specific than the first data type of the first specialized query operator e.g. a floating point number. The selection of query operators may therefore use a highly specialized query operator for a very particular type of data such as floating point numbers less specialized query operator for a more general class of data such as numbers and a generic query operator for other or unknown data types.

A third aspect that may vary among implementations of these techniques relates to the selecting of query operators from a query operator set comprising both specialized query operators and unspecialized query operators. As illustrated in the selecting may involve attempting to identify and select specialized query operators for various portions of the query and then identifying and selecting unspecialized query operators for the portions of the query for which a specialized query operator has not been selected. As another variation a query operator may attempt to detect whether a more specialized query operator is available to perform the operation in a more efficient manner for a particular query portion. For example an unspecialized sorting query operator selected to sort a set of numbers in the query may be capable of checking with the query operators set to determine whether a specialized number sorting query operator is available if so the unspecialized sorting query operator may recommend the more specialized query operator to handle the query portion. Moreover the specialized number sorting query operator may in turn check to see if an even more specialized sorting query operator is available to handle the particular types of numbers involved in the query portion e.g. a specialized floating point number sorting query operator for sorting floating point numbers and may recommend the even more specialized query operator if it is available. One manner of combining these techniques may involve parsing the query by initially selecting unspecialized query operators for each query term and recursively asking each selected query operator to check whether a more specialized query operator is available. Once each selected query operator indicates that a more highly specialized query operator cannot be found for a particular query portion the selected query operators may be invoked to generate the query processing solution. Alternatively or additionally the data types may be able to recommend query processors for a particular operation e.g. the query processing pipeline might identify the class of an object involved in a portion of a query and may ask the class of the object to recommend or provide a specialized query operator for handling the object in the query. Those of ordinary skill in the art may be able to devise many ways of selecting a set of query operators from among the set of specialized and unspecialized query operators in accordance with the techniques discussed herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

