---

title: Integer division using floating-point reciprocal
abstract: One embodiment of the present invention sets forth a technique for performing fast integer division using commonly available arithmetic operations. The technique may be implemented in a four-stage process using a single-precision floating point reciprocal in conjunction with integer addition and multiplication. Furthermore, the technique may be fully pipelined on many conventional processors for overall performance that is comparable to the best available high-performance alternatives.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938485&OS=08938485&RS=08938485
owner: NVIDIA Corporation
number: 08938485
owner_city: Santa Clara
owner_country: US
publication_date: 20080212
---
Embodiments of the present invention relate generally to computer arithmetic and more specifically to integer division using floating point reciprocal.

A typical computer system uses at least one central processing unit CPU to execute programming instructions associated with the specified function of the computer system. The programming instructions include without limitation data storage data retrieval branching looping and arithmetic operations. In order to optimize program execution performance many conventional CPUs incorporate dedicated hardware resources that can efficiently perform frequently encountered arithmetic operations such as integer addition subtraction and multiplication which have an important impact on overall performance. Many CPUs also include dedicated hardware resources configured to perform a full set of basic floating point operations used to improve the performance of a variety of common applications. Integer division however is used infrequently enough that most processor designers choose to avoid the added expense of dedicated hardware resources used to perform integer division. In such cases integer division is typically provided by a performance optimized software implementation.

Certain advanced computer systems augment the processing capability of a general purpose CPU with a specialty processor such as a graphics processing unit GPU . Each GPU may incorporate one or more processing units with higher performance GPUs having 16 or more processing units. GPUs and CPUs are generally designed using similar architectural principles including a careful allocation of hardware resources to maximize performance while minimizing cost. Furthermore the arithmetic operations typically selected for execution on dedicated GPU hardware resources tend to mirror the arithmetic operations executed on dedicated CPU hardware resources. Thus integer division which is less frequently used in GPU applications is typically implemented in software for execution on the GPU.

When performing software based integer division operations the operations may be performed by software executing integer instructions or a combination of integer and floating point instructions. For example the classical shift and subtract algorithm using integer machine instructions typically computes no more than one result bit per step where each step typically includes one to three machine instructions depending on machine architecture. One solution to improve integer division performance uses one floating point reciprocal 1 x function to implement integer division provided the bit width of the floating point mantissa is larger than the bit width of the integer being processed. However the standard single precision floating point mantissa is only 24 bits whereas the bit width of an integer value is typically 32 bits precluding the use of this approach on most common processors. Another class of solution uses specialty arithmetic operations such as a floating point fused multiply add FMA to facilitate integer division. However these arithmetic operations are typically not supported by the dedicated hardware resources found on conventional processors such as commonly available CPUs and GPUs thereby restricting the usefulness of this class of solution.

As the foregoing illustrates what is needed in the art is a technique for performing integer division operations in software that uses the hardware resources available on conventional processors more efficiently than prior art approaches.

One embodiment of the present invention sets forth a method for performing integer division. The method includes the steps of receiving an integer dividend and an integer divisor computing a floating point reciprocal based on the divisor computing a lower bound quotient generating a reduced error quotient based on the lower bound quotient and correcting the reduced error quotient to generate a final quotient.

One advantage of the disclosed method is that it enables integer division to be performed on conventional single precision floating point hardware more effectively relative to prior art techniques.

The fetch unit retrieves a sequential instruction stream for processing from the program instructions stored in memory . Certain operations within the instruction stream require additional data which may be retrieved by the fetch unit from the program data within the memory . The decode unit directs specific actions that should be performed by the logic within the processor in order to execute a decoded instruction. For example the decode unit may configure the execution unit to perform an integer multiply upon decoding an integer multiply instruction from the instruction stream.

The execution unit performs the operations associated with decoded instructions using dedicated hardware resources including without limitation at least one arithmetic logic unit ALU . Conventional processors typically incorporate independent ALUs for processing related types of data. For example execution unit within processor includes ALU for processing integer operations and ALU for processing floating point operations. When the execution unit performs an integer multiply a multiplicand and a multiplier are presented to inputs and of ALU . The resulting product is emitted from output of ALU for further processing. Similarly when the execution unit performs a floating point division a dividend and divisor are presented to inputs and of ALU . The ALU computes a quotient and emits the quotient via output .

The output of ALU and the output of ALU may be stored within the processor or stored in the program data . The data store unit performs the necessary actions to store ALU outputs and in the program data within memory for later use.

A compiler back end receives the intermediate code and generates machine code that is specific to the target processor. In some embodiments code from the subroutine library is incorporated into the compiled machine code by the compiler back end . The functions within the subroutine library may then be invoked as needed with a function call. Alternately selected functions within the subroutine library maybe included in line in the compiled machine code thereby eliminating the overhead of a function call but increasing the size of the resulting compiled machine code .

The compiled machine code may be stored in the memory of as all or part of the program instructions . As described below in the compiled machine code included in the program instructions may be used by the processor to perform integer division operations where the processor does not include hardware elements dedicated for such operations.

The method begins in step where the processor receives two integer values N and D for processing. These two integer values may be read from internal storage such as a register file or the program data stored in memory . The variable N contains the value of a dividend numerator and the variable D contains the value of a divisor denominator of a division operation. Variables N and D are both represented in an integer format.

In step the processor computes a single precision floating point reciprocal using the divisor D as input to the reciprocal calculation. The reciprocal calculation is performed using a round to nearest rounding policy. The process of computing the single precision floating point reciprocal is illustrated in the pseudo code shown below in TABLE 1. Again N is dividend and D is the divisor. A function call to fesetround FE TONEAREST instructs the floating point unit within processor to round any results to the nearest least significant bit represented in the floating point format. In alternative embodiments any technically feasible mechanism may be used to establish each specified floating point rounding policy. Each variable including fD f D and f Dlowered are declared as floating point indicated by the preceding float declaration. In the second line of pseudo code in Table1 floating point variable fD is assigned to the value of input integer D. In the third line of pseudo code in Table1 floating point variable f D is declared and assigned to the floating point reciprocal of fD. Finally f Dlowered is computed by passing f D through function Lower . The resulting lowered reciprocal is stored in f Dlowered. In alternative embodiments f Dlowered may be computed directly without calling the Lower function in a processor that includes a round up rounding policy for the floating point reciprocal operation shown in Table 1.

The Lower function shown in Table 1 receives an input floating point value in the range 2 32 through 2 32 and returns a value that is lowered by up to two least significant bits of the mantissa of the original value. That is when f is a 32 bit IEEE standard floating point number the function Lower f has a behavior bounded by Equation 1 below.

One implementation of the Lower function is illustrated in the pseudo code shown below in TABLE 2. A floating point variable fpvalue contains a floating point value for the Lower function to process. A pointer to an unsigned 32 bit integer is defined as integer pointer ip. References to the contents of a memory location pointed to by ip are indicated as ip. Arithmetic operations on ip are performed as though the contents of the referenced memory location are unsigned 32 bit integer values. In the first line of pseudo code integer pointer ip is declared and assigned to point to the location in memory where floating point variable fpvalue resides. In effect the raw bits representing fpvalue are made available for processing as an unsigned 32 bit integer. In the second line of pseudo code the raw bits representing fpvalue are treated as an integer value for the purpose of subtracting 2 from contents of the memory location storing fpvalue. In effect a value of 2 is subtracted from the raw machine code representation of the fpvalue treated as an integer. The subtract operation is performed on a concatenation of a biased exponent field situated in the most significant bits representing fpvalue and a mantissa field situated in the least significant bits representing fpvalue. Therefore a mantissa underflow will borrow from the exponent field and yield a correct arithmetic result. Because the input values are bounded by the range of 2 32 to 2 32 bounds checking on the biased exponent field should be unnecessary for standard 32 bit IEEE floating point values.

In step the processor computes a lower bound quotient. The process of computing the lower bound quotient is illustrated in the pseudo code shown below in TABLE 3. The lower bound quotient calculation is performed using a round toward zero policy. A function call to fesetround FE TOWARDZERO instructs the floating point unit within processor to round the least significant bit represented in the floating point result towards zero. In the second line of pseudo code in Table3 floating point variable fErrl is declared and assigned the value of integer variable N. In the third line of pseudo code a floating point lower bound quotient is computed using the lowered reciprocal f Dlowered computed in Table 1. Finally the an unsigned 32 bit integer lower bound quotient is assigned to unsigned 32 bit integer Q1. 

In step the processor generates a reduced error quotient by performing computations to reduce the error associated with the lower bound quotient computed in step . The process of computing the reduced error quotient is illustrated in the pseudo code shown below in TABLE 4.

The function call to fesetround FE TOWARDZERO performed previously in step continues in force throughout step . Therefore each floating point operation in step is performed using a round toward zero policy.

In the second line of pseudo code of Table 4 variable N2 is declared and assigned to the integer product of integer values stored in Q1 and D. Variable err2 is then declared and assigned to the difference between N and N2. Floating point variable fErr2 is then declared and assigned the value of unsigned 32 bit integer variable err2. Floating point variable fQ2 is then declared and assigned to the floating point product of previously computed values stored in fErr2 and f Dlowered. An unsigned 32 bit integer variable Q2 is declared and assigned the value stored in floating point variable fQ2. Finally an unsigned 32 bit integer variable result2 is assigned to the sum of Q2 and the previously value of 01. In effect the value of Q2 adjusts the initially computed lower bound quotient Q1 up a small amount to reduce the overall error bound to be less than or equal to one. The resulting value corresponds to a reduced error quotient stored in variable result2.

In step the processor generates a final quotient by correcting the reduced error quotient computed in step . The process of computing the final quotient is illustrated in the pseudo code shown below in TABLE 5.

An unsigned 32 bit variable N3 is declared and assigned the product of result2 by D. An unsigned 32 bit variable err3 is declared and assigned the difference of N minus N3. If err3 is larger than or equal to D the input denominator then variable oneCorr one correction is set to 1 otherwise oneCorr is set to 0. The final quotient is stored in variable Qfinal which is declared and assigned the sum of result2 reduced error quotient and oneCorr in line four of Table 5.

In step the final quotient Qfinal computed in step is returned. In one embodiment the final quotient is returned to a calling function. In an alternate embodiment the final quotient is computed using in line code and the process of returning the final quotient may not require an explicit return operation. The method terminates in step .

The pseudo code in Tables 1 through 5 uses a specific style whereby variables are declared and assigned on the same line. However variable declaration may be performed using any technically appropriate technique without deviating from the scope of the present invention.

The method of advantageously allows integer division to be performed effectively on conventional single precision floating point hardware. More specifically as is well known applications that use floating point arithmetic tend to rely on a mix of operations including addition subtraction multiplication and division in order to achieve good overall performance. In fact the availability of high performance floating point division tends to be an important requirement to the overall performance of many floating point applications. The bit width of each floating point variable in many conventional 32 bit CPU architectures and GPUs with internal 32 bit architectures is limited to standard single precision 32 bit values as specified in the IEEE 754 specification. A standard 32 bit single precision floating point number includes twenty four bits of mantissa twenty three bits are represented with a leading implied 1 value eight bits of exponent and a sign bit. Thus persons skilled in the art will readily recognize the compatibility of the disclosed algorithm with such conventional hardware designs.

Persons skilled in the art will also recognize that the disclosed integer division technique may be realized in many different implementations on many different processing platforms without deviating from the scope of the present invention. For example the integer division technique may be implemented on a graphics processing unit GPU configured to execute multiple threads in multiple streaming multiprocessor cores as discussed in greater detail below.

The instructions executed by a streaming multiprocessor may be an arithmetic logical and or memory operation including read and write operations to the memory . Arithmetic and logic operations are performed by ALUs and . Each ALU includes logic to perform integer operations and floating point operations including without limitation integer addition and multiplication as well as floating point division. The threads executing on a particular streaming multiprocessor may be configured to execute the method steps of in order to perform integer division with greater efficiency.

The GPU also includes a core interface that couples the GPU to external memory resources. The core interface is also coupled to the streaming multiprocessors and through a plurality of couplings shown as interfaces and respectively. The streaming multiprocessors and are coupled to the memory through a crossbar which is advantageously designed to allow any streaming multiprocessor to access any memory location within the memory . The streaming multiprocessors and access the memory through couplings and respectively and through a coupling between the crossbar and the memory not shown . The couplings and may allow wide data transfers e.g. 256 bits or more between the memory and the streaming multiprocessors of the GPU .

In sum a high performance technique for computing integer division using commonly available instructions such as a floating point reciprocal is disclosed. The technique computes one floating point reciprocal. The reciprocal value is then used to compute a lower bound quotient which is guaranteed to be less than or equal to the mathematically true quotient. The lower bound quotient is used to compute a reduced error quotient which is guaranteed to be less than or equal to the mathematically true quotient by either zero or one. The reduced error quotient is then corrected to generate a final quotient which is equal to a mathematically true quotient. The technique may be fully pipelined by using predicated execution instructions where computation decisions are required for higher performance.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the scope of the present invention is determined by the claims that follow.

