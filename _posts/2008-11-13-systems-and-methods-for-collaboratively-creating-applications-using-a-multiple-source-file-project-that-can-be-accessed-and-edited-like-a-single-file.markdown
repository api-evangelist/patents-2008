---

title: Systems and methods for collaboratively creating applications using a multiple source file project that can be accessed and edited like a single file
abstract: Certain embodiments facilitate collaboration between designers and developers in the creation of software applications. Designers and developers can work on the same multi-file-based software development project, without the designer having to address or even be aware of the multi-file structure of the project or the management of different versions of the project. Instead the designer can receive and send the project as a single file and work with it as if it were a single document. A developer or another user can address conflicts and other versioning issues that may result from collaborators making changes concurrently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08453112&OS=08453112&RS=08453112
owner: Adobe Systems Incorporated
number: 08453112
owner_city: San Jose
owner_country: US
publication_date: 20081113
---
The present disclosure relates generally to developing computer software applications and content and specifically to applications used for such development.

Creating computer content and other applications including desktop applications Web pages and rich Internet applications generally involves separate stages and often involves two or more sets of people with very different skill sets. Generally designers generate images of an application s appearance for example using a drawing program like Adobe Photoshop and separately write specifications of how they want the application to behave for example when the user moves the mouse over a given part of the screen. Developers then take the images and specifications and develop a working application generally by manually coding such an application. This two stage design development process can be inefficient and inaccurate. Discrepancies often require additional iterations of the design development process and thus additional effort by both designer and developer. The use of declarative languages platforms like Adobe s Flex platform and other technologies have helped reduce the gap in the design and development process. However inefficiencies and inaccuracies remain.

Developing software applications frequently involves creating and managing development projects having multiple source code files. In the context of an integrated development environment IDE application creators typically must keep track of these individual files and develop the application based on their understanding of how the files relate to each other. Because each file typically has its own editor window for editing developer actions such as undo and redo can be limited to the context of the individual file being edited. Developers also frequently use granular source control systems that require manual steps to manage versioning for individual files so that if two developers make changes to the same file there is a process for merging the changes.

Unlike developers designers typically create graphics interfaces and other visual and appearance attributes using software applications that present the material being developed as a single document file. For designers edits to anything in the entire project are viewed as edits to that one document file. User actions such as for example undo commands redo commands and save commands function globally with respect to the entire project rather than operating on a single portion of a project. Thus many designers are accustomed to working with a user interface that presents individual components as if such components where all part of the same document or file.

The different environments that designers and developers are accustomed to working in presents various hurdles in collaborative development. Designers are unaccustomed to working within multi source file projects and managing versioning source control workflows granular file merges and merging code. Designers therefore tend to contribute indirectly by submitting ideas and graphics to a developer who then has to implement the ideas and graphics in the project. Existing development applications thus fail to adequately facilitate collaboration between designers and developers in certain ways.

Certain embodiments facilitate collaboration between designers and developers in the creation of software applications. Designers and developers can work on the same multi file based software development project without the designer having to address or even be aware of the multi file structure of the project or the management of different versions of the project. Instead the designer can receive and send the project as a single file and work with it as if it were a single document. A developer or another user can address conflicts and other versioning issues that may result from collaborators making changes concurrently.

One embodiment is a method of working with a single file version of a multi file project. The method comprises receiving a single file. The single file packages the multiple files of the multi file project together. When the project is opened in an editing tool the method involves creating a temporary storage structure and extracting the multiple files of the multi file project from the single file into the temporary storage structure. When one or more edits are received the temporary storage structure is updated using the edit or edits. This may involve for example identifying a file or files of the multi file project extracted in the temporary storage structure to update and updating that file or files using the edit or edits to the multi file project. The method may also involve saving an edited version of the single file using the updated temporary storage structure.

Another embodiment is a method of collaborating on the development of an application. The method involves providing a version of a project for use in an editing application that allows the project to be edited. The version of the project is provided with a baseline usable to identify any changes including potentially conflicting changes made during a time period associated with provision of the version of the project. The method further involves receiving a changed version of the project identifying changes using the baseline and the changed version of the project and identifying a subset of those changes that potentially conflict with changes made to another copy of the project available to the receiver. The method may then involve presenting the potentially conflicting changes for merger with the project. Accordingly this method in some cases allows the responsibility for merging changes to be shifted to a user other than the user making the changes. The method may also facilitate merging changes from multiple users at once. For example identifying potentially conflicting changes may further comprise using changes made to another version of the project during the time period associated with the provision of the version of the project to the editing application. The user responsible for merging changes may be presented with a merge tool that presents various changes to a given file of a multi file project identifies who made the changes and or provides refactoring information to allow the user to decide an appropriate merger action.

In other embodiments a computer readable medium such as for example random access memory or a computer disk comprises code for carrying out these methods.

These embodiments are mentioned not to limit or define the invention but to provide examples of embodiments to aid understanding thereof. Embodiments are discussed in the Detailed Description and further description is provided there. Advantages offered by the various embodiments may be further understood by examining this specification.

Certain embodiments facilitate collaboration between designers and developers in the creation of software applications. Designers and developers can work on the same multi file based software development project without the designer having to address or even be aware of the multi file structure of the project or the management of different versions of the project. Instead the designer can receive and send the project as a single file and work with it as if it were a single document. The term file is used herein to refer to a conceptual data unit regardless of whether it is actually directly a file on disk that an operating system can access. The terms project and multi file project refer to a collection of files used in creating an application. The term project files thus refers to the individual files of a multi file project. The designer or other user can work with the project as a single document meaning that the user can use cross project operations that operate like single file operations while a developer or other user can work with the multiple project files as separate independent entities.

Various aspects of certain embodiments are introduced here with an example involving creating an application that provides a user interface with functionality controllable by the application user and graphics of controls and other components of the applications. Development of such an exemplary application may involve creating and editing a project containing multiple source files. As a specific example the project may have a file corresponding to a main application and a number of subcomponents represented by separate files that provide or define the graphics and or other features of the application. The main file may specify the layout of components of the application while other files provide information about the appearance of certain components such as the appearance of a particular button or image.

The creation and modification of this exemplary application may involve the efforts of multiple people using different creation applications. For example a designer may position components for the layout of the user interface of the application and create and incorporate specific images and other visual components. A developer may specify or program various functionality implemented in the application such as for example specifying that when a particular button is clicked a particular list will be populated with data from a database.

The designer and developer may use different applications to work with the project. The developer for example may use an IDE development application and the designer may use an application that simplifies the designer s interaction with the project. For example the designer may execute a design focused application and access the project by a project open command and then work with the project as a single file and a single document. For example the designer may actually receive a single file work with it and then send it back or otherwise check it back in for synchronization with any other work being done on the project by other designers and developers. While working with the project the designer may work with the single file like other files he she is accustomed to working with saving it as a file on an operating system desktop moving it around e mailing it etc.

The single file accessed by the designer may be a packaged version of the entire project that can be used by the designers design application. The design application may extract and use the project components without the designer having to manually work with or even be aware of the multiple project files. For example the design application may create a structure such as a folder that may be hidden or otherwise not exposed directly to the user. This structure or folder can mimic or represent the multi file structure of the project and can be modified as the designer interacts with the application to track ongoing changes. When the designer takes action some of those actions result in files or components of the structure or folder being updated added or deleted. When the designer selects a save command to save the project the structure or folder can be saved as a single file. The designer can later return the single file containing the modified project to the source from which it was accessed or checked out. Accordingly the designer can make changes in parallel with other designers and developers. In some cases a developer is able to easily merge changes after a designer sends back or otherwise checks back in a project. The designer may thus not need to be concerned about synchronization or conflicts and can simply work with the project as a single file and single document.

This illustrative example is given to introduce the reader to the general subject matter discussed herein. The disclosure is not limited to this example. The following sections describe various additional embodiments and examples of methods and systems.

As shown in the server stores a project that may comprise multiple files . The server provides the project for the designer and developer to edit. For example the server may send a copy of the project to the developer computer allowing the developer to use various editing and development functions of development application to edit and develop the project . The development application may also include a merge tool that allows the developer to control and manage versioning of the project. For example the merge tool may present the developer with an interface showing potentially conflicting changes made by the developer and designer among others. This allows the developer in this embodiment to manage the changes made by a designer who may be less familiar with techniques for managing such changes and unwilling or unable to do so.

The server may also provide a version of the project stored as a single file through network to the designer s computer. For example the multiple files of the project may be packaged archived or otherwise combined as a single file and sent to the designer. This may happen in some cases in response to a designer requesting access to the project or otherwise checking out a version of the project for editing. The project stored as a single file can be stored in the memory of the designer computer and used by a design application . The design application can provide various access functions such as for example check out and check in functions used by the design application to check a project in and out of the server . The design application may also include various editing functions allowing the designer to make changes to the project. For example the design application may present a canvas area and display components for an application being developed. Those displayed components may represent the user interface of the application that is being developed. In some cases a designer can edit add to or delete from the canvas area to specify or change the appearance of the user interface of the application being developed.

In an alternative embodiment a design application need not interact with a server . For example in certain embodiments a project stored as a single file may be provided by a developer . For example a developer may e mail a file containing a copy of the project to the designer for use within the development application . The designer may edit the project and eventually return the changed file to the developer who may then use development application to integrate any changes into the project .

In the exemplary embodiment shown in the design application comprises a temporary storage structure that is used to facilitate editing of the project stored as a single file . Such a storage structure may be an internal folder that includes temporary editable copies of the project files . For example when a designer accesses and opens the single file project using design application the project that is stored as a single file may be used to create this storage structure that is then available to the design application to work with. In some cases the design application can use these internal files in a similar way that a development application uses the actual files of the project . Indeed there may be various common elements to a design application and a development application such that features of these applications do not need to be recreated differently for the different applications. For example the development application may access project files using the same or similar application programming interface function API calls as are used in the design application to access files of a temporary storage structure .

The extracted files or other elements of a temporary storage structure do not need to be exposed to the designer who may simply see and work with the project stored as a single file . As one example the designer may make changes to various components throughout the project causing changes to several of the files extracted in the temporary storage structure. The temporary storage structure and or other components of the design application can track these changes so that the designer can use undo to undo prior changes based on the order the changes were made and regardless of which extracted file was impacted by the change.

When the designer saves the project stored as a single file the temporary storage structure can be used to create and save the changed version of the project stored as a single file. The designer can reopen the single file and make additional changes. At some point the designer can send the changed version of the project stored as a single file back to the server for synchronization. The server may then provide the changes from the changed version of the project to the developer who can use the merge tool to to address any potential conflict or other versioning issues. In the meantime the designer may check out or receive from the developer a new version of the project as a single file such as for example one that includes changes from other designers and developers . Alternatively the designer may continue working on their prior version of the project stored as a single file . In some embodiments the designer is required to work on a new version but in other embodiments the designer is not restricted from working on prior versions.

The techniques for developing applications and the other features described herein have uses in a variety of contexts not to be limited by the specific illustrations provided herein. The system shown in is merely illustrative and is not intended to recite any system component or feature as essential or necessary to any embodiment.

An application creation project may involve a multi file structure of multiple source files such as for example a file corresponding to the main application and a number of subcomponents represented by separate files. Certain embodiments present the project as a single file while creating a structure such as a folder that may be hidden or otherwise not exposed directly to the user. This structure or folder can mimic or represent the multi file structure of the project and can be modified as the user interacts with the application to track ongoing changes. When the user takes action some of those actions result in files or components of the structure or folder being updated. When the user hits save to save the project the structure or folder can be saved as a single file.

The method further comprises opening the single file for editing as shown in block . For example the file may be opened in an editing application that allows a designer developer or other user to view and or make changes to one or more aspects of the project. Referring again to a design application may be used to access and open the single file.

The method may comprise creating a temporary storage structure and extracting files of the multi file project into the temporary storage structure as shown in block . For example upon opening the single file for editing in block a design application may read the single file and extract pieces of the single file for individual manipulation and editing. For example a packaged file may be unzipped into a folder of hidden temporary files. The folder can thus function like a scratch working area or temporary storage area.

The method may further comprise receiving an edit to the project as shown in block . For example a design application such as the design application of may present a designer developer or other user with a canvas area and allow the user to reposition components of an application s user interface on the canvas. As the user works with and otherwise edits the application on the design application these edits can be tracked by the design application.

As shown in block after an update the method may involve updating the temporary storage structure . Such updating can in some embodiments occur periodically after a number of updates and otherwise need not occur after each update. Generally as a user makes changes the files within the folder or other temporary storage structure may change without the user knowing or even being aware that such files are being used.

In certain embodiments a design application can manipulate individual temporary files like a file available through an operating system. Individual files of a folder or other temporary storage structure may not merely be logical units and instead the single file may literally be a packaged up representation of what could be individual files on disk that an operating system can access. In these and other cases a design application may update the temporary files of a folder or other temporary storage structure using the same application programming interface API that is used to access and update operating system files.

As shown in decision triangle if there are more edits the method returns to block and processes the additional edits. However as shown in block if there are not more edits the method may further involve saving the project. Thus as shown in block upon a save the temporary storage structure is used to update the single file. If the user does not save the original single file remains unchanged. The saved file can be reopened at a later time or provided to a central system or other user for synchronization versioning and other collaborative development functions.

The method of provides an example of an embodiment that allows a designer developer or other user to work with a single file that is an amalgamation of several individual physical files that are potentially worked with individually by other collaborators in a software development project. While the single file can be essentially a package file of multiple individual files it may appear to the user to be just a single document representation. Thus certain aspects of certain embodiments provide a development application or tool that presents an abstract view to a user of a collection of files as a single document in a way that allows the user to make changes to the content of those files without necessarily dealing with or even knowing about the existence of those individual files. Certain embodiments provide a method of presenting content from multiple files as a single document and allowing the user to edit any of that content and then reflecting changes back in those multiple underlying sources without the user having to be aware that they are dealing with anything other than a single file and or working in a single document.

Regardless of whether a project is packaged as a single file certain embodiments involve techniques for presenting multiple project files for editing as if the editing were occurring on a single document. This can involve presenting document type operations like undo redo save close revert etc. and other editing operations that can change any file in a multi file project without requiring a user to identify which file is changed. Providing these types of operations in the context of the project being presented as a single document may help a user feel as if he or she were working on a single document even though the end result relates to multiple files.

For example one embodiment comprises a computer implemented method that involves opening a multi file project for editing in a development application and providing a single document view of the multi file project in the development application. The single document view presents and allows editing of features from more than one file of the multi file project in one place. For example the single document view may present such features on a graphical canvas area or within a single text editing window among other ways. This exemplary method may comprise receiving an edit to the single document view of the multi file project mapping the edit to one or more files of the multi file project and updating the files of the multi file project based on the edit to the single document view. Exemplary edits include but are not limited to a change to an object to be displayed a change to an operation to be performed a change to code a change to text an undo operation a redo operation a cut operation a paste operation an insert operation a delete operation a format operation among many others. Accordingly various cross project functions operation and other edits can be implemented through an interface that presents a multi file project as a single document and or otherwise simplifies development of a multi file project for a user.

After opening the project the method further involves receiving an edit to the project as shown in block . As described in the context of other embodiments herein such an edit may be made in a variety of ways including but not limited to through a development or design application s editing interfaces and or by a user entering text manipulating graphical representations or otherwise providing input or edits.

After receiving one or more edits the method further involves updating a storage structure based on the edits as shown in block and recording the edit or edits in an undo list as shown in block . In certain embodiments when the user performs actions that might affect different files in the project all of those actions are recorded in a single undo list or stream even though the actions may be associated with separate source code files. The use of such a single undo list or stream can ensure that the user can use an undo function in accordance with their prior experiences of an undo function that functions across an entire document rather than just with respect to a particular piece of the document. Thus changes to different files in a temporary storage structure are all recorded sequentially in an undo list so that these changes can be undone in the reverse order that the user made the edits regardless of the file or files associated with a given edit. Note that in some embodiments a single entry in an undo list may encompass changes to multiple files in a project while the entry may correspond to a single edit made by a user.

The method further involves a user selecting or not selecting an undo command as shown in block . If an undo command is not selected the method returns to block for further editing. However if an undo command is selected the method involves using the undo list to undo the last edit and update the temporary storage structure as shown in block . Accordingly an editing interface can be updated to undo the last edit and any associated change made to the temporary storage structure can also be undone.

Finally as shown in block the method can then involve removing the undone edit from the undo list. The method may alternatively comprise leaving the edit in the undo list and instead marking the edit in the undo list as undone. In this case the a subsequent command to redo the edit can trigger a redoing of the edit using the edit still stored in the undo list and removing the marking that indicates that the edit was undone.

The method can then return to block and determine whether another undo has been requested or not. In this way a user is able to undo one edit after another in the reverse order from the order in which the edits were made regardless of the file or files of the multi file project that was impacted by the edit. This can provide an editing experience with which a designer developer or other user is more familiar or comfortable.

Collaborative development may involve allowing two or more users making changes concurrently to a same project. In such cases various conflicts may result and can be addressed in a variety of ways. For example a designer may be working with the appearance of a user interface and create a new state for a button component. At the same time a developer may have decided that the button component is not necessary and delete it. Certain embodiments of the present disclosure address these and other issues by providing a mechanism for one user editing a project to simply provide a changed version of the project without having to be concerned about such changes. Such a user may be technically less sophisticated or otherwise desire to focus his or her efforts on other aspects of the project s creation. Instead another user can manage the changes. In some cases potential conflicts can be managed each time a given user checks a version of the project back in or otherwise provides their version of the project for synchronization or integration with the collaborative project.

An edited version of a multi file project can be integrated with another copy of the project in a variety of ways. For example a user may check back in the single file or send it to a particular other user for incorporation or synchronization with the multi file project. Another user such as a developer can then merge the contents from what is presented as a single file into the multi file project. A central server may be used in some embodiments. A central server is not used in some embodiments. In certain embodiments a designer or other user may avoid having to address any source control issues. Unlike in traditional source control in which anyone submitting changes is typically responsible for merging their changes with any overlapping changes made by others during the same time frame a designer can be insulated from such merging. A developer who is accepting changes from a designer s single file package can be responsible for the merge and in a position to do it properly.

An edited version of a project can be integrated with another copy of the project regardless of the forms in which the versions of the project are stored. For example some embodiments integrate a multi file version of a project with one or more other multi file versions of the project. Some embodiments integrate a single file version of a project with one or more other single file versions of the project. Still other embodiments integrate various combinations of single and multiple file versions of a project. Thus some embodiments will involve only single file versions of a project some embodiments will involve only multiple file versions of a project and some embodiments will involve versions of a project of both types.

In certain embodiments a development project also involves a traditional source control system and a developer can provide a bridge function to a source control system for designers and other users wishing to avoid source control responsibility. From a designer s standpoint he or she can simply check in their single file version of a project and have a developer or other user ensure changes are merged properly. Similarly a designer can simply synchronize their version of the project by having the developer other user or system return another single file that replaces the designer s old one with one that includes the results of any mergers that have been accepted.

Suppose the designer is working with the appearance of a user interface and their changes create a new state for a component a list box or a button. At the same time a developer may have decided that the component is not necessary and delete it. Or they re factor and they move the component into a separate file. A developer may reorganize the project into smaller files.

The method further comprises receiving a changed version of the project as shown in block . For example a modified version of a single file provided to a designer may be checked back in or otherwise sent back to the source that originally provided the single file or sent to a developer or other user other than the source that is capable of performing the merge. Changed files extracted from inside the single file can be compared using the baseline to identify the specific changes that were made. From the designer s standpoint he or she has the ability to deposit changes without concern about the actual merger of those changes into the collaborative project. The designer may be able to continually check out and check in a project for editing regardless of whether there are any conflicts because such conflicts can be addressed by another person at potentially a later time.

The method may further comprise identifying potential conflicts using the baseline and changed version of the project as shown in block . This may identify for example that a particular file of the project has been edited concurrently in different versions of the project so that the potentially conflicting situation can be flagged for a line by line granular merge. For example a baseline may comprise a version of the file as it was prior to any changes and can thus be used to directly identify any changes. A baseline may be used to identify any changes made to other version of the project during the time period when the single file was checked out and being modified. For example the baseline can be used to also identify changes made by separate developers to another version of the project. Any changes identified from the changed version of the project received at block can be compared to any changes made separately by other developers to identify potential conflicts. Changes may be identified using a diff tool that is passed files identified as having potential differences from prior versions of the files.

As another example a baseline may provide a simple timestamp or timestamps for all of the files that can be used to access a version of the project associated with one or more specific prior periods of time. Such prior versions can be used to identify changes. Alternatively timestamps could be used on their own rather than to access a specific version based on time. For example timestamps may be used to determine whether something has changed at all or not. If a file has the same timestamp as the baseline it can be assumed that the file has no changes.

Another exemplary baseline provides a checksums of the files of a multi file project that can be used to determine whether content has changed. Checksum use may be used to reduce or eliminate errors associated with inaccurate computer clocks etc. In some cases a baseline may comprise different types of information depending on the associated content. For example a baseline may provide the content of certain files e.g. a complete copy of the textual files and source code inside a project but for images the baseline may use a checksum and or timestamp.

A baseline may also be used to identify any changes made to other versions of the project during the time period when the single file was checked out and being modified. For example the baseline can be used to also identify changes made by a separate developer to another version of the project. Any changes identified from the changed version of the project received at block can be compared to any changes made separately by the other developer to identify potential conflicts.

The method further comprises presenting potentially conflicting changes for merger and receive commands merging changes as shown in block . This may involve providing information to a developer or other user regarding which files have potential conflicts. The developer may use a development application such as development application s merge tool shown in to manage the merging of any conflicts that are identified. In some embodiments potential conflicts are presented in a queue for a developer or other user to address at an appropriate or convenient time. The conflicts in such a queue need not be addressed immediately or all at once but rather may remain pending or persistent. Thus potential conflicts can remain flagged and unresolved while development continues. For example the changes may be unresolved even though new versions of the project are checked out and edited.

In one embodiment a designer or other user cannot continue to make changes to a project after sending the project e.g. the single file back for synchronization until an updated project file is received. In another embodiment a designer continues to work on the original single file after a merge rather than picking up the new copy that has the result of the merge. In some cases a developer or other user addressing potential conflicts may see spurious conflicts flags being raised because he or she already performed a merge resolving some of the potential conflicts. This is because changes that were already resolved in a first merge might be misidentified as conflicts in the second merge. In some embodiments a merge tool identifies and removes spurious potential conflicts reducing or eliminating this problem since the user may have previously merged a change.

The method of offers various advantages. For example a developer or other user can modify a collaborative project and allow another person to essentially deal with potential conflict issues. This allows persons to collaborate directly in the creation of the project who would otherwise not be able to do so because of inability or unwillingness to address potentially technical and confusing conflict resolution and other issues with which software developers and other technical users are more familiar. For example a designer can be isolated from having to think about or deal with any of the sort of responsibilities that a developer working on the source control typically takes on which includes synchronizing and merging conflicts upon synchronization and before submitting any changes. Instead a designer may be free from any of those requirements. Those requirements can be placed on a developer or other user who is receiving the changes and who may act as the designer s liaison to a source control system.

In certain embodiments a baseline is not stored in a version of a project that is provided to a designer or other user for editing. Instead the baseline is stored in some other location and retrieved at an appropriate time so that conflict analysis and merging can take place. In other embodiments a baseline is provided in the version of the project that is provided. This can provide various advantages for example when multiple versions of a project are checked out to one or more different designers. Associating a baseline with each checked out version of the project can help avoid confusion.

Generally a baseline can be used in a variety of ways to facilitate detection of changes and conflicts and to facilitate merging when a designer or other user submits changes. A baseline can provide a common starting point for comparing changes made by multiple parties during a same time period. It can further help identify circumstances in which one party made a change based on an assumption that was true in their version but where a change made by another party broke that assumption.

Certain embodiments utilize a refactoring log to facilitate the identification of conflicts and or suggest appropriate paths to resolve conflicts. The log may be stored as part of the project that is being edited to make the merger process easier in some cases. For example if a designer adds a new state to a component and a developer has refactored the component by moving it into a different folder. One or more records of refactoring can be used to more easily identify exactly what changes have been made and how such changes were made.

Certain embodiments also use unique identifiers that are included in a version of a project to identify users and track the editing history of individual files of a multi file project. For example if a single file version of a project is opened by a designer and then passed back and forth between the designer and a second designer who make edits at different times a system may be able to discern the identity of the user who made each particular edit or group of edits using unique identifiers embedded in metadata associated with the project. Among other things this type of information may be used to facilitate the merger of changes for example to identify whether changes from a given user at a specific revision number or timestamp have already been merged. The same or a different unique identifier may also be used to identify that a particular project selected for merger is actually a different version of the same project.

Numerous specific details are set forth herein to provide a thorough understanding of claimed subject matter. However it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances methods apparatuses or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter. Some portions are presented in terms of algorithms or symbolic representations of operations on data bits or binary digital signals stored within a computing system memory such as a computer memory. These algorithmic descriptions or representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. An algorithm is here and generally is considered to be a self consistent sequence of operations or similar processing leading to a desired result. In this context operations or processing involve physical manipulation of physical quantities. Typically although not necessarily such quantities may take the form of electrical or magnetic signals capable of being stored transferred combined compared or otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to such signals as bits data values elements symbols characters terms numbers numerals or the like. It should be understood however that all of these and similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise it is appreciated that throughout this specification discussions utilizing terms such as processing computing calculating determining and identifying or the like refer to actions or processes of a computing platform such as one or more computers or a similar electronic computing device or devices that manipulate or transform data represented as physical electronic or magnetic quantities within memories registers or other information storage devices transmission devices or display devices of the computing platform.

Certain embodiments provide techniques for collaboratively creating applications using a multiple source file project that can be accessed and edited like a single file. These embodiments are merely illustrative. In short the techniques and the other features described herein have uses in a variety of contexts not to be limited by the specific illustrations provided herein. It should also be noted that embodiments may comprise systems having different architecture and information flows than those shown in the Figures. The systems shown are merely illustrative and are not intended to indicate that any system component feature or information flow is essential or necessary to any embodiment or limiting the scope of the present disclosure. The foregoing description of the embodiments has been presented only for the purpose of illustration and description and is not intended to be exhaustive or to limit the disclosure to the precise forms disclosed. Numerous modifications and adaptations are apparent to those skilled in the art without departing from the spirit and scope of the disclosure.

In addition with respect to the computer implementations depicted in the Figures and described herein certain details known to those of skill in the art have been omitted. For example software tools and applications that execute on each of the devices and functions performed thereon are shown in as functional or storage components on the respective devices. As is known to one of skill in the art such applications may be resident in any suitable computer readable medium and execute on any suitable processor. For example the devices at environments each may comprise a computer readable medium such as a random access memory RAM coupled to a processor that executes computer executable program instructions stored in memory. Such processors may comprise a microprocessor an ASIC a state machine or other processor and can be any of a number of computer processors. Such processors comprise or may be in communication with a computer readable medium which stores instructions that when executed by the processor cause the processor to perform the steps described herein.

A computer readable medium may comprise but is not limited to an electronic optical magnetic or other storage or transmission device capable of providing a processor with computer readable instructions. Other examples comprise but are not limited to a floppy disk CD ROM DVD magnetic disk memory chip ROM RAM an ASIC a configured processor optical storage magnetic tape or other magnetic storage or any other medium from which a computer processor can read instructions. A computer readable medium may transmit or carry instructions to a computer including a router private or public network or other transmission device or channel both wired and wireless. The instructions may comprise code from any suitable computer programming language including for example C C C Visual Basic Java Python Perl and JavaScript.

While the network shown in may comprise the Internet in other embodiments other networks such as an intranet or no network may be used. Moreover methods may operate within a single device. Devices can be connected to a network as shown. Alternative configurations are of course possible. The devices may also comprise a number of external or internal devices such as a mouse a CD ROM DVD a keyboard a display or other input or output devices. Examples of devices are personal computers digital assistants personal digital assistants cellular phones mobile phones smart phones pagers digital tablets laptop computers Internet appliances other processor based devices and television viewing devices. In general a device may be any type of processor based platform that operates on any operating system capable of supporting one or more client applications or media content consuming programs. The server devices may be single computer systems or may be implemented as a network of computers or processors. Examples of a server device are servers mainframe computers networked computers a processor based device and similar types of systems and devices.

