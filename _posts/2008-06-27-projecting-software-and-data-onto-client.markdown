---

title: Projecting software and data onto client
abstract: A software application written for a server environment is transformed into one which runs in a rich client environment. An entity model defines data sources as they are accessed from the server and as they are accessed from the clients. An application programming interface defines stereotyped interfaces which provide the same functionality on the server and the clients. A metadata model describes the components which make up the application and defines the differences in structure between the server and clients. The metadata model also defines mappings between components used on the server and clients. Settings and context information which tailor the activation and functionality of the components is also captured in the metadata model. Automated transformation is performed by using the mappings to identify the component set to use for the clients, selecting the client version of the application programming interfaces, and selecting the appropriate settings and context information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904363&OS=08904363&RS=08904363
owner: Microsoft Corporation
number: 08904363
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
Business rules are increasingly being captured in web based applications. The complex data stores on which these applications rely are typically hosted on database server systems. The resulting combination is a server centric set of solutions.

In parallel rich client applications have become the toolset used to perform the daily tasks of the business workers. These rich client applications are becoming well integrated with each other raising expectations of seamless integration between business solutions.

Integration of rich client applications with server based business systems is not as seamless as between client applications. Users must switch between systems and between styles of user interaction in order to perform related tasks.

Solutions which allow the users to interact with the server based business systems from within the rich client environment would increase user satisfaction and productivity. Supporting that interaction from multiple client applications would provided added benefit.

This Summary is provided to introduce in a simplified form a selection of concepts that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Various aspects of the subject matter disclosed herein are related to the automated transformation of a software application which runs on a server system into one which runs on one or more rich client applications. Stereotyped APIs abstract models of data sources and metadata models of the application support the transformation.

Other aspects relate to mapping components and their properties from the server to the clients. Some components and properties exist in both environments. Others have equivalents which can be substituted. Still others are distinct and will only be used in a subset of the environments.

Still other aspects relate to modeling and transforming settings which control the behavior of components and context information which controls the timing and conditions under which user interface components will be activated or displayed.

The approach described below may be implemented as a computer process a computing system or as an article of manufacture such as a computer program product. The computer program product may be a computer storage medium readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.

A more complete appreciation of the above summary can be obtained by reference to the accompanying drawings which are briefly summarized below to the following detailed description of present embodiments and to the appended claims.

This detailed description is made with reference to the accompanying drawings which form a part hereof and which show by way of illustration specific exemplary embodiments. These embodiments are described in sufficient detail to enable those skilled in the art to practice what is taught below and it is to be understood that other embodiments may be utilized and that logical mechanical electrical and other changes may be made without departing from the spirit or scope of the subject matter. The following detailed description is therefore not to be taken in a limiting sense and its scope is defined only by the appended claims.

The present disclosure addresses the transformation of a software application written for one system environment into one capable of execution on another. Referring to a Business Application is illustrated which has been developed for an exemplary system comprising those components below it. The Runtime component provides a set of services applicable across a variety of applications. The Runtime relies in turn on the Application Program Interfaces APIs which provide access to Line Of Business LOB systems . These LOB systems are external and are typically focused on providing a specific type of service. They often comprise business logic operating on a persistent store of data maintained on a server . As an example they may provide access to a business entities data i.e. payroll production etc. stored in a relational database to external data sources i.e. RSS feeds or to specialized services such as web hosting. An exemplary architecture would host the LOB systems on one or more servers .

An exemplary approach to the above transformation of a Business Application emphasizes automatically transforming an application developed to run in a server environment to run on one or more client environments. In the present disclosure a client is a software application such as a word processor and its associated components not a hardware client as the term is sometimes used. This exemplary approach relies on having an environment in which the Runtime component provides identical functionality on both client and server. This can be achieved by abstracting the system specific APIs and creating a stereotyped API which provides a simple orthogonal set of commonly used operations that are supported by the set of LOB Systems . This stereotyped API may then utilize a set of shims or connectors to translate the abstract requests into system specific invocations. For each different LOB System Type the associated shim provides system specific code that implements the API. The shims also serve to wrap the system specific data returned by the LOB Systems to provide a uniform stereotyped interface to the data.

The present disclosure is specific to the transformation of a Business Application into one or more Client Business Applications within the context of an exemplary environment such as that described above and illustrated in . The details of that environment are beyond the scope of the present disclosure and will be discussed only as necessary for the purposes of this disclosure.

Central to the concepts of the present disclosure is a Business Application Metadata model such as that illustrated in . Specifying a combination of one or more of the components of the metadata model defines an abstract model of the Business Application . This model can then be instantiated to form a concrete executable application. The concepts of the present invention allow multiple instantiations to be formed targeted to different environments such as the Client Business Applications . Each instantiated application will then provide the same functionality in each environment.

An exemplary embodiment uses the components illustrated in to model a Business Application . Parts and Layouts represent aspects of the Graphical User Interface GUI of the application. Actions expose functionality for use. They may also have an aspect which surfaces in the GUI where a graphical control is use to trigger the functionality. Settings and Context information represent attributes or properties which control the operation of the other components tailor the operation of business rules or otherwise customize the Business Application . The Entity Model describe the various LOB Systems available to the Business Application . Of particular interest are those external systems which serve as data sources. The Entity Model describes essential characteristics of each system such as its API data interchange formats and authentication methods.

The exemplary embodiment of decomposes some or all of the components into subclasses. In some cases such as for Parts the subclasses are specific to a particular type of environment. Web Parts are specifically applicable to a server based application which is accessed via a web browser. Business Parts are applicable to Client Business Applications which are accessed directly. In other cases such as Layouts the top level class may be applicable to all environments i.e. the layout engine for all environments understands the same basic information for laying out GUI elements while the subclasses each provide a host specific implementation on which a layout can be displayed. Pages provide two dimensional layout capabilities while Taskpanes are limited to one dimensional layout. Other display surfaces such as regions are more specific to a particular rich client. These components will differ in appearance while providing the same underlying functionality. Similarly the subclasses of Actions will provide equivalent functionality even though they look different and require different user interaction. URLs serve as hyperlinks to destination web pages or other landing sites. They offer the flexibility of being able to be embedded within pages and documents. Ribbons implement a specific model of presenting buttons within a bounded area. Settings and Context have been decomposed in to three discrete sub classes Client Settings are unique to client hosted applications Server settings are unique to server hosted applications while Common Settings are applicable to both client and server hosted applications.

The exemplary component model illustrated in is only one possible embodiment. Clearly additional or different subclasses could be used as could a different top level partitioning.

The high level process of transforming a Business Application from the server into a Client Business Application is illustrated in . The Business Application Metadata see is created as the application is being built on the server. When implementation is complete the developer will Stage the Business Application by placing the metadata into the Document Library . A Manifest lists the components of the Business Application as implemented on the server. The Business Application Metadata Files then serve as the source data for the transformation process. Step Generate Client Specific Metadata files reads in the Business Application Metadata Files and generates the Client Metadata Files . Each set of client metadata is specific to a particular client environment and a separate Manifest lists the components to be transformed or generated for each client. An exemplary embodiment uses XML files to implement the Client Metadata Files . When triggered by a user or an automated event Download Client Application will select the appropriate set of Client Metadata Files and transfer them to a client computer as local Client Metadata . Install Components will then unpackage the metadata and install the components locally. Update Entity Model will update the local copy of the Entity Model see to reflect any additions or changes required for the applications being installed. Install Metadata installs the application specific metadata configuring the components instances as they are installed. Install Subscriptions establishes the data subscriptions which the application components will use to retrieve data from the sources defined in the Entity Model . Configure Settings applies the Context and Settings data to tailor the behavior of the components as required.

The transformation of a Business Application from the server into a Client Business Application involves mapping the server model of the application into the client model of the application. Three of the components play lead roles in this process. The Entity Model which describes the data sources and their APIs captures the differences between the runtime environment on the server and on the rich client and servers as the framework for the transformation. The Layouts are the top level UI components and can be viewed as containers for all of the other UI components which are to be transformed. The Settings and Context describe the bindings between the Entity Model and the UI components.

The transformation of the Entity Model starts by identifying those LOB systems with which the Business Application interacts. This can be determined by identifying the data sources for each UI component being used. For each of these the Entity Model provides access information for the server and for the rich clients. The transformation process selects the access method which is appropriate for accessing each data source from the selected rich client. Because these access methods will be remote authentication methods will also be selected which may not have been needed on the server. Some of the settings which comprise the Settings and Context capture attributes of these access methods. Because the Entity Model contains representations of the LOB systems from both server and client perspectives most of this transformation involves looking up the system and selecting the values appropriate to the client. In some cases there may be multiple options available on the client. For example there may be more than one authentication method available. In these cases the preferred method may have been previously identified enabling automatic selection or the alternatives may be presented to the user and their choice retrieved.

In an exemplary embodiment the UI components are transformed in a hierarchical process starting at the Layout and working down to the smaller components. The Layout itself describes the relative arrangement of UI components in the graphical display which is presented to the user. The layout engines on the client and server are different but each can consume a Layout . While the same functional capabilities are available on both the server and the client the visual presentation of the components may differ significantly. For example the server may utilize Pages which support two dimensional arrangements while a client may only support a Taskpane which supports only one dimensional arrangement. An exemplary embodiment supports three options for transforming layouts. In the first the existing server layout is automatically transformed into the client equivalent. As a part of this two dimensional arrangements will be mapped to one dimensional arrangements according to specified rules. A second alternative is to generate a layout from the information available in the entity model and the specification of the Business Application . Predefined rules will be applied to provide default positioning of the components. A third alternative is for the user to develop a separate layout which is specific to the client. Once this layout is defined and the mappings between parts specified by the user the transformation can subsequently be performed automatically by transferring properties and settings for the individual parts as described below. Context information for the Layout will also be transformed for use in the client specification. The context information controls when the layout is displayed. This may be the same as for the server or it may be different. Where the information is the same it will be mapped directly to the client. Where the context information differs or where the developer wants different behavior mappings between the server context information and the client context information will be specified and the server settings mapped to the equivalent client settings.

Contained within Layouts are Parts . On the server Web Parts are used to implement the user interface. The equivalent capability is handled by Business Parts on the Rich Client. The transformation of Parts is more complex due to the differences in how the user interface is handled on the server and clients. Referring to a greatly simplified exemplary embodiment of a Part is illustrated. In addition to other attributes each component comprises plural Properties each of which describes a particular aspect of the component. Each Property has plural attributes which define a particular characteristic of that Property . In the exemplary embodiment each Property has an Attribute named CommonProperty which is used to identify those Properties which are common across the host environments. The optional name parameter on the attribute can be used to specify a different name in the target version. illustrates a trivial mapping of a server part to a Client Part while shows the corresponding metadata specification for a Sample Part . The Server Part has three Properties Title Description and Visibility. The Client Part shares the use of Description and Visibility but uses Text in place of Title. Referring to these features are reflected in the model of the Sample Part . Description and Visibility have the attribute CommonProperty with no name parameter indicating that the property is used on both the server and client versions with the same name. Title has the CommonProperty attribute with a parameter of Text to indicate that Title is used on the client but with a different name. This approach supports automated mapping of components by enabling direct transfer of attributes which are identical or equivalent. Any Property with the CommonProperty attribute can be automatically mapped. Where the CommonProperty attribute is not present the Part will not be transformed for use on the client. This same approach is easily extended to other Components. Business Parts may also be specified which are not directly mapped from Web Parts . These will be included in the Client Business Application during transformation.

As the Parts are transformed associated data sources are identified. A Business Application which is running on a server can connect to these data sources in real time. In the client environment support is also needed for disconnected operation where the computer has no network connection. Since the data sources are server based the Business Application cannot access them without a network connection. An exemplary solution to this is to use local caching of the data sources with subscriptions to update the data when the network connection is available. In this model Subscriptions are exclusive to the Client versions of applications and do not exist on the Server side. As each unique data source is identified during the transformation process subscriptions are automatically generated by reference to the Entity Model .

Actions may be associated with either an entity class or with a particular instance. On the server actions are typically implemented as code workflows or URL based navigation options. Code based actions can be used on the client as long as the code has been exposed. The UI control used to activate the Action will be mapped to an equivalent control on the client. Workflows can be handled in the same manner if a compatible workflow engine is available on the client. Otherwise they will not be available on the client. URL links are not directly supported on the client because the clients do not use a web browser paradigm. The transformation process converts URL based Actions to an equivalent user experience. The hyper link is replaced with a button or other UI control. The destination Page is replaced with a Taskpane or Region .

Throughout the transformation process the Settings and Context data associated with each of the components is transferred to the Client Metadata files along with the transformed component. This information comprises criteria and conditions which specify when a component will be displayed activated or otherwise enabled. For example a particular Action may only be enabled when the user is working on a Microsoft Word document that was created from a template named Resume. A different Action may be enabled for a Microsoft Excel spreadsheet with the custom property Group set to Accounting. Some Settings and Context data is common to both server and client and the transformation consists of directly copying it to the client specification. In other cases there will be an equivalent which has been defined and that data will be substituted. It is also possible for client specific Settings and Context data to be specified by the developer. That data will be added to the client metadata as part of the transformation.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. It will be understood by those skilled in the art that many changes in construction and widely differing embodiments and applications will suggest themselves without departing from the scope of the disclosed subject matter.

