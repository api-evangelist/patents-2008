---

title: Selective execution of trace mechanisms for applications having different bit structures
abstract: A computer implemented method, a computer program product, and a data processing system trace information about current context and system state for either 32-bit or 64-bit applications. A 32-bit trace executable code and a 64-bit trace executable code are compiled for a trace script. A determination is then made as to whether an application process is a 32-bit process or a 64-bit process. Responsive to determining that the application process is the 32-bit process or the 64-bit process, an internal indicator is set to indicate the application process as either a 32-bit process or a 64-bit process. Subsequently, the internal indicator is identified as either indicating the 32-bit process or the 64-bit process. If the internal identifier indicates the application process is a 32-bit process, an instruction pointer is set to indicate the 32-bit trace executable code, and the 32-bit trace executable code is executed. If the internal identifier indicates the application process is a 64-bit process, an instruction pointer is set to indicate the 64-bit trace executable code, and the 64-bit trace executable code is executed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261243&OS=08261243&RS=08261243
owner: International Business Machines Corporation
number: 08261243
owner_city: Armonk
owner_country: US
publication_date: 20080812
---
The present invention relates generally to a computer implemented method a computer program product and a data processing system. More specifically the present invention relates to a computer implemented method a computer program product and a data processing system for selective execution of trace mechanisms for applications having different bit structures.

A probe or trace is a software mechanism that interrupts normal system action to investigate and obtain information about current context and system state. Tracing actions or probe actions refer to the actions performed by the trace. Typically they include the capturing of information by writing the current values of global and context specific information to a trace buffer. The obtained information thus captured in the trace buffer is called trace data. The system usually provides facilities to consume the trace that is read the data out of the trace buffer and make it available to the users of the system.

A trace point identifies a point during normal system activity that is capable of being traced. With dynamic tracing trace points do not have any probes attached to them unless they are being traced. Enabling a trace is the operation of attaching a probe to a trace point and disabling a trace is the operation of removing a probe from a trace point. Triggering or firing of a probe refers to the condition where an enabled trace point occurs during system activity and the tracing actions are performed.

Dynamic tracing requires tracing actions to be executed dynamically. The tracing actions are often written in a programming language and usually compiled into machine code or byte code which is then loaded into the Operating System. At the time a trace point is triggered this machine code or byte code for the trace is executed which allows for the efficient execution of trace actions. Attempting to interpret and execute trace actions at the time a trace point is triggered incurs the extra overhead involved in translating the code into machine code.

An important requirement for tracing is the ability to access the values of global variables input parameters to a function being traced return values from functions being traced and other context data at the trace point in an application that is being traced. There are two common data models available for applications on most modern operating systems the 32 bit and the 64 bit data models. Accordingly compilers on AIX and other operating systems support converting a program written in the high level language into either a 32 bit or 64 bit binary executable. Dynamic tracing must support tracing both 32 bit and 64 bit applications.

Because 32 bit applications and 64 bit applications follow different data models a problem arises when the same tracing actions code needs to be executed for both 32 bit and 64 bit applications and context or global data in the application must be accessed as part of executing the tracing actions. This problem is specific to compilers that need to generate object code that can be executed in one or more data modes. Standard compilers generating either 32 bit object code to create a 32 bit executable or generating 64 bit object code to create a 64 bit executable will not experience this problem although separate 32 bit and 64 bit executables may be created from the same program.

For example pointers and long variables longs in a 32 bit application assume different sizes than do pointers and longs in a 64 bit application. Consider the case where we put a trace point at entry into a system call such as sigaction. The sigaction system call takes a pointer to the sigaction data structure which has the following structure layout shown here in C language format 

For a 32 bit application the sa handler field is 4 bytes long. The sa mask field therefore starts at offset 4. However for a 64 bit application the sa handler field is 8 bytes long. The sa mask field for a 64 bit application therefore starts at offset 8.

Consider the case of the sizeof operator which returns the size of a variable In AIX a unsigned long variable in a 64 bit application can contain values up to 2bits and a unsigned long variable in a 64 bit application is 8 bytes long. However for a 32 bit application a unsigned long variable can contain only values up to 2bits and the size of the unsigned long variable is therefore 4 bytes. The compiler must somehow generate code that returns 4 bytes or 8 bytes depending upon the process that is being traced.

Existing solutions that vary offsets sizes of variables etc. depending on whether a 32 bit or 64 bit application is executing the tracing code include the following.

The first solution involves creating two tracing modules. The first module is compiled for 32 bit mode having matching 32 bit long pointer sizes and the second module is compiled for the 64 bit mode having matching 64 bit long pointer sizes. The user uses the 32 bit module if the applications being traced is 32 bit. The 64 bit module is used instead when tracing 64 bit applications.

This approach is taken by the command line kdb or the kernel debugger command which needs to understand both the 32 bit and 64 bit layout of kernel data structures depending upon whether the user is debugging a 32 bit or 64 bit kernel. It consists of a front end and both a 32 bit and a 64 bit backend module. When invoked it first tests the kernel mode whether 32 bit or 64 bit and then invokes the appropriate backend module. The problem with this approach is that it does not work well if both 32 bit and 64 bit applications have to be simultaneously traced in a single session.

A second known solution is to incorporate knowledge of application modes into the programming language and have a mode switch implemented as a new statement within the tracing program. For instance if the same structure was being accessed by both the 32 bit and 64 bit application the user could define a separate structure for each mode Such a solution could take the form of 

This second solution thus would require the user to declare the structure twice with two different names. The first declaration would be built in 32 bit format and the second declaration would be in 64 bit format. This double declared solution allows the compiler to know about both possibilities simultaneously. The tracing program could then initiate a single appropriate tracing script dealing with both types of objects simultaneously. However this double declared solution would require the user to check whether the current process is running in 32 bit mode or 64 bit made within the tracing program and then choose the appropriate structure. Similar considerations would apply when using operators like sizeof on variables.

Thus the second solution requires the user to handle the 32 bit and 64 bit issue explicitly. All structures and variables for the structures and the actions associated with them must be duplicated for the 32 bit and the 64 bit scenarios. The user would need to know the exact mode of every application being probed. The tracing program would be quite complex and possibilities of errors are high. In the future when a 32 bit application needs to be compiled into 64 bit mode all existing tracing programs have to be updated to understand the new mode. Another problem with this solution is if long long fields are present in a 32 bit structure which need to be cast into a pointer that is treat the long long field as a pointer rather than as an integer because pointers are only 4 bytes long while long longs are 8 bytes long correct casting may require special language constructs to be employed by the user further complicating this solution.

A computer implemented method a computer program product and a data processing system trace information about current context and system state for either 32 bit or 64 bit applications. A 32 bit trace executable code and 64 bit trace executable code are compiled for a trace script. A determination is then made as to whether an application process is a 32 bit process or a 64 bit process. Responsive to determining that the application process is the 32 bit process or the 64 bit process an internal indicator is set to indicate the application process as either a 32 bit process or a 64 bit process. Subsequently the internal indicator is identified as either indicating the 32 bit process or the 64 bit process. If the internal identifier indicates the application process is a 32 bit process an instruction pointer is set to indicate the 32 bit trace executable code and the 32 bit trace executable code is executed. If the internal identifier indicates the application process is a 64 bit process an instruction pointer is set to indicate the 64 bit trace executable code and the 64 bit trace executable code is executed.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer usable medium may include a propagated data signal with the computer usable program code embodied therewith either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions.

These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . Clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments. In this illustrative example data processing system includes communications fabric which provides communications between processor unit memory persistent storage communications unit input output I O unit and display .

Processor unit serves to execute instructions for software that may be loaded into memory . Processor unit may be a set of one or more processors or may be a multi processor core depending on the particular implementation. Further processor unit may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another illustrative example processor unit may be a symmetric multi processor system containing multiple processors of the same type.

Memory and persistent storage are examples of storage devices. A storage device is any piece of hardware that is capable of storing information either on a temporary basis and or a permanent basis. Memory in these examples may be for example a random access memory or any other suitable volatile or non volatile storage device. Persistent storage may take various forms depending on the particular implementation. For example persistent storage may contain one or more components or devices. For example persistent storage may be a hard drive a flash memory a rewritable optical disk a rewritable magnetic tape or some combination of the above. The media used by persistent storage also may be removable. For example a removable hard drive may be used for persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit is a network interface card. Communications unit may provide communications through the use of either or both physical and wireless communications links.

Input output unit allows for input and output of data with other devices that may be connected to data processing system . For example input output unit may provide a connection for user input through a keyboard and mouse. Further input output unit may send output to a printer. Display provides a mechanism to display information to a user.

Instructions for the operating system and applications or programs are located on persistent storage . These instructions may be loaded into memory for execution by processor unit . The processes of the different embodiments may be performed by processor unit using computer implemented instructions which may be located in a memory such as memory . These instructions are referred to as program code computer usable program code or computer readable program code that may be read and executed by a processor in processor unit . The program code in the different embodiments may be embodied on different physical or tangible computer readable media such as memory or persistent storage .

Program code is located in a functional form on computer readable media that is selectively removable and may be loaded onto or transferred to data processing system for execution by processor unit . Program code and computer readable media form computer program product in these examples. In one example computer readable media may be in a tangible form such as for example an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage for transfer onto a storage device such as a hard drive that is part of persistent storage . In a tangible form computer readable media also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that is connected to data processing system . The tangible form of computer readable media is also referred to as computer recordable storage media. In some instances computer recordable media may not be removable.

Alternatively program code may be transferred to data processing system from computer readable media through a communications link to communications unit and or through a connection to input output unit . The communications link and or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non tangible media such as communications links or wireless transmissions containing the program code.

The different components illustrated for data processing system are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system . Other components shown in can be varied from the illustrative examples shown.

As one example a storage device in data processing system is any hardware apparatus that may store data. Memory persistent storage and computer readable media are examples of storage devices in a tangible form.

In another example a bus system may be used to implement communications fabric and may be comprised of one or more buses such as a system bus or an input output bus. Of course the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example memory or a cache such as found in an interface and memory controller hub that may be present in communications fabric .

With reference now to a block diagram illustrating the relationship of software components operating within a computer system that may implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. Java virtual machine JVM is one software application that may execute in conjunction with the operating system. Java virtual machine provides a Java run time environment with the ability to execute Java application applet which is a program servlet or software component written in the Java programming language. The computer system in which Java virtual machine operates may be similar to data processing system in or data processing system in described above. However Java virtual machine may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the Java virtual machine which supports all aspects of Java s environment including its architecture security features and mobility across networks and platform independence.

The Java virtual machine is a virtual computer for example a computer that is specified abstractly. The specification defines certain features that every Java virtual machine must implement with some range of design choices that may depend upon the platform on which the Java virtual machine is designed to execute. For example all Java virtual machines must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A Java virtual machine may be implemented completely in software or somewhat in hardware. This flexibility allows different Java virtual machines to be designed for mainframe computers and PDAs.

The Java virtual machine is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the Java virtual machine which is itself a piece of software running on the processor. The Java virtual machine allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the Java virtual machine. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format. This compiled code is executable on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the Java virtual machine that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just in time JIT compiler.

A Java virtual machine loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the Java virtual machine. The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. Java virtual machines usually interpret bytecodes but Java virtual machines may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on a Java virtual machine that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a Java virtual machine is depicted in accordance with an illustrative embodiment. Java virtual machine JVM includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. Java virtual machine also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by Java virtual machine to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the Java virtual machine creates a new Java stack for the thread. The Java virtual machine performs only two operations directly on Java stacks. It pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the Java virtual machine pushes a new frame onto the Java stack of the thread. When the method completes the Java virtual machine pops the frame for that method and discards it. The Java virtual machine does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a Java virtual machine method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined.

Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some Java virtual machine implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The Java virtual machine specification strictly defines data types and operations. Most Java virtual machines choose to have one method area and one heap each of which are shared by all threads running inside the Java virtual machine such as Java virtual machine . When Java virtual machine loads a class file it parses information about a type from the binary data contained in the class file. Java virtual machine places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . Java virtual machine includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

A computer implemented method a computer program product and a data processing system trace information about current context and system state for either 32 bit or 64 bit applications. A 32 bit trace executable code and 64 bit trace executable code are compiled for a trace script. A determination is then made as to whether an application process is a 32 bit process or the 64 bit process. Responsive to determining that the application process is the 32 bit process or a 64 bit process an indicator is set to indicate the application process as either a 32 bit process or a 64 bit process. Subsequently the internal indicator is identified as either indicating the 32 bit process or the 64 bit process. If the internal identifier indicates the application process is a 32 bit process an instruction pointer is set to indicate the 32 bit trace executable code and the 32 bit trace executable code is executed. If the internal identifier indicates the application process is a 64 bit process an instruction pointer is set to indicate the 64 bit trace executable code and the 64 bit trace executable code is executed.

Referring now to a block diagram of a compiler generating code streams for 32 bit and 64 bit applications is shown in accordance with an illustrative embodiment. is a software component executing on a data processing system such as data processing system of and data processing system of .

Compiler is a software component that processes statements written in trace script of a particular programming language and turns them into machine language or code that a computer s processor uses. Trace script is a program written in a programming language understandable by compiler . Trace script can be used to identify the trace points where a trace is to be dynamically enabled specify the conditions if any which must be satisfied for the actions to be executed when a trace fires and specify the actions to be executed including what trace data to capture. In short the trace script tells a trace application where to trace when to trace and what to trace.

Trace script consists of an optional declaration section followed by one or more trace clauses . Each of trace clauses consists of three elements trace point specification predicate and action .

Trace point specification identifies a set of trace point s to be dynamically enabled. Trace point specification consists of one or more trace point ordered set of values or tuples. Each trace point tuple identifies a code location whose execution or an event whose occurrence should trigger the trace actions. Multiple trace points can be associated with the same set of trace actions and the predicate if any by providing list of trace points at the top of one of trace clauses .

Predicate if present identifies a condition that is to be checked at the time the trace is triggered. That is predicate is used when execution of trace clauses at trace points must be performed conditionally. Predicate must evaluate to TRUE for the trace actions of the clause to be executed.

Action is used to identify the sequence of trace actions to be performed when the trace fires. Action consists of a sequence of statements that are executed in order. Action identifies the trace actions to be performed when the associated trace point is triggered. Supported actions are not restricted to the mere capturing and formatting of trace data.

Compiler compiles trace script into machine executable code streams onto memory locations. Trace header contains supplemental data that provides control and summary information about the generated trace code. Compiler compiles predicates and and actions both as 32 bit code streams and as 64 bit code streams. 32 bit code streams are stored at 32 bit executable code while 64 bit code streams are stored at 64 bit executable code . Compiler also generates clause data for trace clause and clause data for trace clause .

Clause data and clause data include offsets to direct applications to the appropriate code stream. If tracing is requested for a 32 bit application offset direct the trace to the appropriately compiled 32 bit code streams in 32 bit executable code . If tracing is requested for a 64 bit application offset direct the trace to the appropriately compiled 64 bit code streams in 64 bit executable code . Other clause data fields can be stored in other trace data structure .

Referring now to an exemplary layout for a trace clause is shown according to an illustrative embodiment. Trace clause can be trace clauses of .

Clause header consists of supplemental data that provides summary and control information about trace clause . 32 bit predicate offset is an offset within a location containing 32 bit executable code such as 32 bit executable code of . 32 bit predicate offset points to a compiled 32 bit predicate code for trace clause . 32 bit executable offset is an offset within a location containing 32 bit executable code such as 32 bit executable code of . 32 bit executable offset points to a compiled 32 bit executable code for trace clause . 32 bit size is a descriptor of the size of the 32 bit executable code for trace clause within a 32 bit executable code region such as 32 bit executable code of .

64 bit predicate offset is an offset within trace clause that points to a related compiled predicate code within a location containing 64 bit executable code such as 64 bit executable code of . 64 bit predicate offset points to a compiled 64 bit predicate code for trace clause . 64 bit executable offset is an offset within trace clause that points to a related compiled executable code within a location containing 64 bit executable code such as 64 bit executable code of . 64 bit executable offset points to a compiled 64 bit executable code for trace clause . 64 bit size is a descriptor of the size of a location containing 64 bit executable code such as 64 bit executable code of .

Other clause data fields can be stored in other data fields . Other data fields can be other trace data structure of .

Referring now to a data flow is shown for installing trace traces within various client and kernel processes according to an illustrative embodiment of the present invention.

Trace script which can be trace script of is fed into compiler which can be compiler of to generate trace stream . Trace stream includes a header such as header of executable code such as executable code of clause data such as clause data of and any other data such as other trace data structure of .

The clause data also contains information about the trace point. The trace point is identified using a string. The kernel then understands from the string what the location where you need to put the trace in.

Compiler then passes trace stream into the kernel to a system call. Inside the kernel data tracing framework determines trace location points within either user process code or kernel code at which to install a trace.

Data tracing framework then saves the different trace streams that correspond to each trace location and . Data tracing framework sets a pointer to identify the trace streams. The trace streams can be traced back from a trace identifier stored in a trace identification data structure so that the correct stream can be executed when its corresponding trace location such as trace location is encountered during execution of a user process or a kernel process.

Referring now to a data flow for executing probe traces is shown according to an illustrative embodiment.

Trace clause can be trace clause of . Trace clause has pointers to direct the trace clause to either 32 bit executable code or 64 bit executable code . Pointer indicates 32 bit executable code that is contained within data structure and indicates 32 bit executable code for trace clause . Data structure contains 32 bit executable code for each of the trace clauses such as trace clause . Pointer indicates 64 bit executable code that is contained within data structure and indicates 64 bit executable code for trace clause . Data structure contains 64 bit executable code for each of the trace clauses such as trace clause .

Pointer identifies trace identifier within trace identification data structure . Trace identification data structure is a data structure containing an identification of each trace trigger that has been inserted into either the client process code or the kernel code. When the trace framework such as trace framework of installs a trace at a certain trace location it creates a trace identifier such as trace identifier . The trace identifier is itself an index indicating a trace clause such as trace clause of .

Each trace identifier such as trace identifier itself has access to its corresponding trace location such as trace location and of . The access can be but is not necessarily a simple pointer. Trace locations are not always straightforward. A trace location can reference information with an effective address that is inside a process or information with an effective address that is the kernel. A trace location can be an event. In each of these scenarios a pointer is often not adequate to identify the trace location from the trace identifier. Other methods such as process or thread IDs module name within the process etc. may also be required to uniquely identify the trace location.

Trace location can be one of trace location of . When trace location is encountered firing mechanism is trigged. Firing mechanism is a software process that identifies the trace identifier such as trace identifier associated with the trace location . Responsive to identifying trace identifier the firing mechanism looks at each trace clause such as trace clause that is associated with the trace. A processor then executes the associated action for each trace clause such as trace clause . As stated above because the location of the trace is often complex the link from the trace clause to the action may not be direct the path may comprise a loop or other structure however the trace clause can always be identified from the trace location .

Referring now to a process for performing a pre trace within a trace launching mechanism responsive to a thread triggering a trace point is shown according to an illustrative embodiment. Process is a software process executing on a software component such as firing mechanism of .

Process begins when an active thread triggers a trace point step and identifies jump code associated with the triggered trace. There is a separate trampoline code associated with each trace identifier. When the trace point is triggered the firing mechanism such as firing mechanism of branches to the associated jump code for that trace point.

Responsive to the active thread triggers a trace point process saves a general purpose register and a condition register step . A modification to the contents of the registers affects the behavior of the active thread process when it resumes execution. The compiler may save some specific values into these registers. Because these registers are not always volatile an error may occur if the contents of that register are lost. Therefore depending on where the trace point is inserted saving these registers is necessary.

Process then identifies whether the process is a 32 bit process step . The check to identify a 32 bit process is made by checking state flags associated with this process s data structure in the kernel. This check can be made using only well defined volatile registers and the single saved general purpose register.

Responsive to identifying that the process is a 32 bit process yes at step process sets an internal indicator that the process is a 32 bit process step . The indicator can be the setting or clearing of a corresponding bit in the saved condition register.

Responsive to not identifying that the process is a 32 bit process no at step process sets an indicator that the process is a 64 bit process step . The indicator can be the clearing or setting of a corresponding bit in the saved condition register. In one illustrative embodiment the bit that is cleared is the same bit that can be set in step .

Process continuing to execute the jump code then saves its associated trace identifier in the saved general purpose register step . The trace identifier to be saved is hard coded inside the trampoline code depending upon which trace identifier it is associated with thus allowing this to be accomplished without availing any of the other general purpose registers.

Process continues by receiving a trace identifier from a pre trace manager step . The pre trace manager is a software process such as firing mechanism of and shown in more detail by as the jump code . The trace manager is entered with a general purpose register indicating the trace identifier and a condition register indicating the mode of the process 32 bit or 64 bit .

Responsive to receiving the trace identifier from the pre trace manager process performs a mini context save step . The mini context saves a few general purpose registers and some system registers like the machine state register 

Responsive to performing the mini context save process identifies the trace clause at this trace point from the trace identifier step . To identify the trace clause process can follow a pointer associated with the general purpose register that is set at step to the trace clause. The trace clause is a data structure such as trace clause of .

Responsive to identifying the trace clause at this trace point from the trace identifier process sets up a context for the trace virtual machine excepting the instruction pointer step . The virtual machine can be virtual machine of . The context can include but is not limited to the status condition or mode of the system state information variables contents and bit settings.

Process determines whether the process to be traced is a 32 bit process or a 64 bit process. In one illustrative embodiment process determines this by examining the condition register bit that was set or cleared by step or . Thus in order to determine whether the traced process is a 32 bit process or a 64 bit process process can simply identify whether a corresponding condition register is set or cleared. In the present illustrative example process determines if the condition register is set step .

Responsive to determining that the condition register is set yes at step process sets the virtual machine instruction pointer to the trace clause s 32 bit code pointer step . In this illustrative example the set bit indicates that the process to be traced is a 32 bit process. Therefore the pointer was set to indicate that the 32 bit trace instructions should be executed. Control of the trace is passed to the virtual machine step with the process terminating thereafter.

Returning now to step responsive to determining that the condition register is not set no at step process sets the virtual machine instruction pointer to the trace clause s 64 bit code pointer step . In this illustrative example the cleared bit indicates that the process to be traced is a 64 bit process. Therefore the pointer was set to indicate that the 64 bit trace instructions should be executed. Control of the trace is passed to the virtual machine step with the process terminating thereafter.

A computer implemented method a computer program product and a data processing system trace information about current context and system state for either 32 bit or 64 bit applications. A 32 bit trace executable code and 64 bit trace executable code are compiled for a trace script. A determination is then made as to whether an application process is a 32 bit process or a 64 bit process. Responsive to determining that the application process is the 32 bit process or the 64 bit process an internal indicator is set to indicate the application process as either a 32 bit process or a 64 bit process. Subsequently the internal indicator is identified as either indicating the 32 bit process or the 64 bit process. If the internal identifier indicates the application process is a 32 bit process an instruction pointer is set to indicate the 32 bit trace executable code and the 32 bit trace executable code is executed. If the internal identifier indicates the application process is a 64 bit process an instruction pointer is set to indicate the 64 bit trace executable code and the 64 bit trace executable code is executed.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

