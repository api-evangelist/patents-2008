---

title: Gathering state information for an application and kernel components called by the application
abstract: Provided are a method, system, and article of manufacture for gathering state information for an application and kernel components called by the application. An implementation of a component to execute in a kernel space is instantiated in a user space. An application invokes a call to the component in the kernel space. The call to the component in the kernel space is invoked and an implementation of the component in the user space is invoked to execute the call in the user space. State information related to the execution of the call to the component in the user space to include in checkpoint information for the application is gathered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08209707&OS=08209707&RS=08209707
owner: Google Inc.
number: 08209707
owner_city: Mountain View
owner_country: US
publication_date: 20080111
---
The present invention relates to a method system and article of manufacture for gathering state information for an application and kernel components called by the application.

An operating system may designate processes that are assigned to execute applications and components as running in a user space or kernel space. Typically user applications are assigned to execute in the user address space and essential operations are assigned to execute in the kernel address space such as resource allocation low level hardware interfaces security etc. A process may comprise one or more threads allocated to processor and computer resources to execute computer instructions. Multiple processes or multiple threads in one process may concurrently execute instructions for one application or multiple processes may concurrently execute instructions for multiple applications. Multiple processes may execute on multiple processors. The term process as used herein refers to a process thread or any other unit of execution allocated to execute instructions.

Certain applications may gather state information on the execution of an application to store in checkpoint information. The state of an application maintained in checkpoint information may be used for debugging development and record and replay purposes. A record and replay program would allow the recreation of an application state to recreate the application so that it may run from the state as indicated in the checkpoint information.

To fully record the state information of an application the state of kernel components the application calls would also have to be recorded. For instance the application may call a graphics engine or network stack for network communication that are implemented in the kernel space. Proprietary operating systems such as Windows a registered trademark of Microsoft Corporation may not provide the tools to enable easy access to the state and system information of kernel components that are called by an application.

There is a need in the art for improved techniques to gather state and system information related to application execution to allow improved recording of the checkpoint information for the application.

Provided are a method system and article of manufacture for gathering state information for an application and kernel components called by the application. An implementation of a component to execute in a kernel space is instantiated in a user space. An application invokes a call to the component in the kernel space. The call to the component in the kernel space is invoked and an implementation of the component in the user space is invoked to execute the call in the user space. State information related to the execution of the call to the component in the user space to include in checkpoint information for the application is gathered.

In a further embodiment the checkpoint information includes system information related to operations of the application and the execution of the calls to the implementation of the component in the user space and a state of memory regions used by the application.

In a further embodiment the intercepted call is translated to a format compatible with implementation of component in the user space wherein the translated call is invoked to the implementation of the component.

In a further embodiment the implementation of the component in the user space comprises a subsystem that executes in the user space and wherein the state information of the subsystem related to the call from the application is gathered for the checkpoint information.

In a further embodiment the application is loaded and initialized and an agent is loaded in response to loading the application. The agent intercepts the application calls to the component in the kernel space and invokes the call to the implementation of the component in the user space.

In a further embodiment the agent instantiates the implementation of the component executing in a kernel space in the user space.

In a further embodiment wherein intercepting the call comprises modifying by the agent the call made by the application to invoke the implementation of the component in the user space to execute the call in the user space.

In a further embodiment wherein the component comprises a network communication data structure residing in the kernel space that is used to process network communication packets. The implementation of the component in the user space comprises the network communication data structure in the user space used to process the network communication packets.

In a further embodiment the component comprises a graphics engine residing in the kernel space that is used to calls to a graphics engine to render graphics and wherein the implementation of the component in the user space comprises a graphics subsystem in the user space used to process the calls to the graphics engine and render graphics.

The operating system may allocate processes operating in the memory into a kernel space and a user space . Higher priority applications and operating system processes may execute in the kernel space . The application executing in the user space may invoke component application programming interfaces APIs to call kernel components executing in the kernel space such as a network stack storing packets for network transmission or a graphics engine to render graphics on a display monitor. The kernel components may comprise other high priority applications and subsystems that typically execute in the kernel space .

An agent is loaded and initialized when the application is loaded and initialized. The agent initializes a user space implementation of the kernel components called by the application in the user space or user space component implementation . The agent may gather information related to the application s execution of the user space component implementation . The agent may store the gathered information as checkpoint information to provide state information related to the application execution including system information on the execution of the components called by the application . This checkpoint information may be used to replicate the application state on the same or different systems by restoring the application to the state indicated in the checkpoint information . The applications and other data may be stored and loaded from a storage such as a non volatile storage device.

In one embodiment the kernel component and user space component implementation may exist simultaneously. In alternative embodiments only the user space component may remain in memory .

Once the state and system information is stored with the checkpoint information a checkpoint manager or other program may resume the operation of the application from the state represented in the checkpoint information . The address space of the recreated application may be populated with the memory state information stored in the checkpoint information . To recreate an application a new process for the application is created. The newly created process contains the executable image ntdll.dll PEB and other system regions such as ANSI code page shared memory data mapped at the top of the process address space. The data segment portions of the executable image and ntdll.dll are overwritten from the respective contents saved in the checkpoint information . The rest of the address space of the process may be populated with the memory regions described by the checkpoint information . The application default heap thread stacks regions containing the loader data and process environment variables etc. are restored by mapping memory regions with appropriate size and attributes and overwriting them with the contents saved in the checkpoint information without regard to their internal structure. In particular the memory region containing the agent is also mapped so that the restarted instance of the process already has the agent for subsequent checkpoints.

Described embodiments provide techniques to implement kernel space components as user space component implementations accessed by an application in the user space to allow the gathering of state information related to the component execution from the user space . In certain proprietary operating systems it may be difficult to access and gather state information on the kernel components an application calls from the kernel space . The described embodiments circumvent this limitation with proprietary and other operating systems by executing kernel components called by applications in the user space where system and state information on the component execution can be more easily gathered.

The described operations may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. The described operations may be implemented as code maintained in a computer readable storage medium where a processor may read and execute the code from the computer storage readable medium. A computer readable storage medium comprises non transitory storage media such as magnetic storage medium e.g. hard disk drives floppy disks tape etc. optical storage CD ROMs DVDs optical disks etc. volatile and non volatile memory devices e.g. EEPROMs ROMs PROMs RAMs DRAMs SRAMs Flash Memory firmware programmable logic etc. etc. The code implementing the described operations may further be implemented in hardware logic implemented in a hardware device e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. . Still further the code implementing the described operations may be implemented in transmission signals where transmission signals may propagate through space or through a transmission media such as an optical fiber copper wire etc. The transmission signals in which the code or logic is encoded may further comprise a wireless signal satellite transmission radio waves infrared signals Bluetooth etc. The article of manufacture may comprise a transmitting station and or a receiving station for transmitting and receiving transmission signals in which the code or logic is encoded where the code or logic encoded in the transmission signal may be decoded and stored in hardware or a computer readable storage medium at the receiving and transmitting stations or devices. An article of manufacture comprises a computer readable storage medium hardware device and or transmission transmitters or receivers in which code or logic may be implemented. Those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention and that the article of manufacture may comprise suitable information bearing medium known in the art.

In the described embodiments the access parameters are changed for process accesses to memory addresses in a shared memory. In an alternative embodiment access patterns may be monitored for computer resources other than memory addresses such as addresses in a storage device and other computer resources.

The terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments of the present invention s unless expressly specified otherwise.

The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise.

The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries.

A description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments of the present invention.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously.

When a single device or article is described herein it will be readily apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be readily apparent that a single device article may be used in place of the more than one device or article or a different number of devices articles may be used instead of the shown number of devices or programs. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments of the present invention need not include the device itself.

The illustrated operations of and show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover steps may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The foregoing description of various embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

