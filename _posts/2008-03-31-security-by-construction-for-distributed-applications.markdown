---

title: Security by construction for distributed applications
abstract: Secure distributed applications are produced by default upon construction. Mechanisms are provided to address distributed application vulnerabilities (e.g., cross-site scripting, cross-site request forgery, replay attacks. . . ) automatically. These mechanisms are provided in conjunction with a tier split component that breaks up an application for execution across multiple contexts or tiers. As a result, any application that is tier split is protected from security vulnerabilities by default without any intervention on the part of a developer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08806618&OS=08806618&RS=08806618
owner: Microsoft Corporation
number: 08806618
owner_city: Redmond
owner_country: US
publication_date: 20080331
---
In recent years the battle for software security has largely moved into the area of web applications with vulnerabilities such as cross site scripting and SQL injection dominating mailing lists and bulletin boards once populated by buffer overruns and format string attacks. Web applications present an attractive attack target because of their wide attack surface and the potential to gain access to sensitive information such as credentials and credit card numbers or to perform unauthorized actions on the part of innocent users which is routinely accomplished with cross site scripting XSS and cross site request forgery XSRF attacks.

While security experts routinely bemoan the current state of the art in software security from the standpoint of the application developer application security requirements present yet another hurdle to overcome. Given pressure for extra functionality other concerns such as performance and security often do not receive the time they deserve. While it is common to blame this on developer education a big part of the problem is that it is extremely easy to write unsecure code.

By way of illustration consider an application that prompts a user for her name and sends a greeting back through the browser. The following example illustrates how one can accomplish this task in a Java J2EE application 

In effect the most natural way to achieve the task of printing the user s name is unsafe. To make this secure the developer has to apply input sanitization which is often a tedious and error prone task. Further after the issue of data sanitization has been dealt with the developer still needs to consider all the ways in which tainted input can propagate through the application and make sure it is sanitized on all paths.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the disclosed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject disclosure pertains to distributed application security. More specifically mechanisms are provided to afford default security by construction. Rather than requiring user involvement to address web application vulnerabilities such as cross site scripting and cross site request forgery such security vulnerabilities are prevented automatically. In accordance with an aspect of the disclosure a development system includes a security component coupled with a tier split component to analyze and inject and or transform tier split code to address security issues. As a result secure code is generated by default upon employment of the subject system.

Various techniques are provided for securing distributed application within a development framework for instance. In accordance with one aspect a capability can be provided by a server to a client and exchanged with requests by the client to enable authorized interaction while preventing unauthorized access. According to another aspect a request stream can be monitored and a capability revoked and or access blocked upon detection of inappropriate action. In accordance with another aspect client server interactions can be encrypted to prevent interception and snooping among other things. According to still another aspect application data can be sanitized to ensure code is not injected unintentionally. In accordance with yet another aspect techniques are disclosed to enable mashups or application combinations without compromising an otherwise secure application.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

Systems and methods pertaining to automatic security of distributed application upon construction are described in detail hereinafter. Conventionally absent developer involvement distributed applications are insecure by default. Now the situation is reversed such that applications are secure by default upon construction. More particularly common vulnerabilities associated with web applications including cross site scripting and cross site request forgery are prevented without developer intervention at an application runtime and or development framework level. In one implementation this can be accomplished in conjunction with a distribution compiler or like component which generates distributed applications. A brief overview of common vulnerabilities afflicting web applications is first provided followed by a description of mechanisms to prevent them automatically in accordance with an aspect of the claimed subject matter.

By far the most common type of attack on web applications is cross site scripting XSS . XSS is a security vulnerability involving malicious code injection in the form of a browser script. The vulnerability exists as a result of a number of factors including the mixture of data and code supported by HTML HyperText Markup Language an inability of web browsers to distinguish between trusted and un trusted code as well as insufficient data validation and or encoding by developers. The root problem is that data can be interpreted as code. Accordingly most attacks involve attempts to pass code off as data. If an XSS attack is successful an injected piece of script can perform just about any action including information theft account hijacking presentation modification and malware installation.

XSS attacks generally fall into one of three categories XSS 0 client side XSS 1 reflected and XSS 2 persistent . XSS 0 is a bit of a misnomer because it does not involve the server at all but rather script injection occurs entirely on a client side. For example an assignment div.innerHtml userComment can cause a form of XSS if the value of userComment is obtained from unsanitized user provided input that contains embedded script. XSS 1 is probably the most common category of cross site scripting that involves input being reflected by the server back to the client verbatim in the output thus creating an easy vector for script injection. This enables an attacker to execute script with user privileges at the site being attacked allowing for theft of cookies associated with the site among other things. XSS 1 is typically initiated by a phishing email to the client. XSS 2 is a variation on XSS 1 where input is stored on the server and then included in the output at a later point. A typical example is embedding malicious code within a blog posting. XSS 2 may lead to large scale outbreaks such as JavaScript worms.

Cross site request forgery XSRF is related but slightly different from XSS. Rather than requiring script injection XSRF entails employing user credentials for a particular web application in a malicious way. An attack typically involves tricking a user into loading a page or executing a script that executes a request on the user s behalf with the user s credentials. For example an attacker could provide a page that upon viewing obtains a user s credentials from a cookie and performs actions on a user s behalf.

Distributed applications are also vulnerable to replay attacks. This vulnerability is similar to XSRF but without the scripting aspect. In this situation a valid data transmission is intercepted and fraudulently repeated. The receiving server is tricked into executing unauthorized operations by using a duplicate transaction. For example a user s login credentials can be captured and resent later or a bank transaction transferring money out of an account can be intercepted and replayed.

Various aspects of the subject disclosure are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Referring initially to a secure application development system is depicted in accordance with an aspect of the claimed subject matter. The system includes tier split component that facilitates splitting or otherwise partitioning an application in a variety of ways. Generally the tier split component can partition a single application for execution across multiple execution contexts wherein the contexts can belong to different security realms. In one particular instance the tier split component can transform a single tier application into a multi tier application suitable for distributed deployment. This can be accomplished automatically however support for manual or semi automatic operation is also possible.

It is to be noted that in one instance the single tier application can be a component of a distributed application that executes within a single execution context. Further yet if the application does not have any inflows from external sources like a distributed application would have then it is relatively secure.

Moreover it is to be appreciated that tier split component splits an application in a manner that preserves program semantics. Accordingly split application execution is semantically equivalent to sequential execution of the application on a single tier. In one embodiment the tier split component can correspond to a distributing compiler.

Unfortunately tier splitting can introduce a considerably less secure application than the original because it introduces a data flow input i.e. inflow that did not exist prior to tier splitting. Indeed consider an application including an identity function string id string input return input . If the application is distributed so that the function id is located on a server this function becomes an entry point for potentially malicious input thus creating a classic reflective XSS 1 vulnerability. This results because tier splitting an application creates an attack perimeter that was previously not there. Not only might this newly created vulnerability not be obvious to a developer it is not even clear how to plug it since conventional sanitization approaches rely on knowing how to sanitize the input which is far from clear from a function as general as id .

Security component addresses the attack perimeter problem as well as other security issues automatically without developer intervention. The security component is communicatively coupled with the tier split component . Accordingly the security component can influence tier splitting operations to ensure production of safe code. For example the security component can inject transform and or rewrite client and or server side code in a secure manner.

Turning attention to a representative security component is illustrated in accordance with an aspect of the claimed subject matter. The security component can include five sub components namely capability component request analysis component encryption component sanitization component and mashup component . The capability component governs client server interactions by allowing a server to identify to a client its available capabilities with respect to the server. The capability can be returned to the client along with a request. The request analysis component analyzes requests and can prompt revocation of client capability or otherwise block interaction upon identification of potentially malicious or unsecure actions for example.

The encryption component injects encryption decryption logic or components into an application to secure distributed application communication across a network. For example the encryption component can provide one or more mechanisms to encrypt client side application requests or commands and decrypt the requests on the server side. Similarly the encryption component can provide the same or similar mechanisms to encrypt server side responses and decrypt those responses on the client side. In one embodiment hypertext transfer protocol can performed over a secure socket layer HTTPS . This provides a layer of protection against data interception or snooping among other things.

The sanitization component sanitizes presentation code such as HTML HyperText Markup Language to prevent code injection and ensure the code is well formed. Typically this can be accomplished by analyzing and sanitizing any data received from the outside. However this turns out to be a pretty challenging task because locating all the places data can be received is a difficult problem in practice. To circumvent this problem sanitization can be performed on display output. However the claimed subject matter can encompass user input and or display output sanitization amongst others. For example the sanitization can also occur in the middle since a presentation layer can include a safe sanitizing abstraction layer on top that sits between code and the presentation layer. In this case the sanitization component need only validate the sanitization abstraction layer and not the presentation directly. Further yet sanitization can be performed not only on presentation could but also dynamic code coming from different sources e.g. jscripts eval function CSS Cascading Style Sheets . . . .

The mashup component provides mechanism to prevent security vulnerabilities when mashing or combining foreign code with an otherwise secure distributed application. As will be described further infra this can be accomplished by limiting applications that can be combined and or rewriting or removing features that pose a security threat.

As shown the server or server side application can include or be associated with a generation component a key store and a validation component . The generation component generates or commissions generation of a unique identifier such as a key. This can involve utilization of one or more global user identifiers timestamps or the like. In any event the generation component is able to produce a cryptographically strong key for provisioning to a client. Upon generation the key and associated information e.g. client identity is stored at least temporarily in key store component . The key store can correspond to volatile or nonvolatile memory or a persistent storage technology among other things. The validation component is a mechanism for validating client requests commands or the like based on a provided key. In essence the validation component can identify a transmitted key and attempt to match it with the key the server was expecting. If the keys match the request can be processed. Otherwise the request is blocked ignored or simply dropped.

Client or client side application includes an acquisition component key store and key transmission component to facilitate capability based interaction. The acquisition component receives retrieves or otherwise acquires a key from the server . The acquired key can be housed in key store at least temporarily. Similar to key store store can correspond to volatile or nonvolatile memory or some persistent storage mechanism. Key transmission component retrieves a corresponding key and ensures that it is transmitted with a requested to grant permission for request processing.

In accordance with one aspect of the disclosure a key can be provided by the server to the client for an application session. Furthermore the key can be transmitted back to the server as a cookie. For example the server can volunteer a key for a session to the client . The client can then store that key as a browser cookie. Each request command or like sent to the server from the client will also include the browser cookie. Prior to processing the server will validate the key in the cookie by attempting to match it with that which was expected. If there is a match processing continues. Alternatively the request is not processed or rejected by the server . This protects against reflected cross site scripting XSS 1 because attacker messages will be dropped since they do not include or are not encoded with the correct key.

According to another aspect of the disclosure a key can be generated with each request to enforce a sequence of operations. An initial key can be provided by the server to the client for use in a first request command message or the like. Upon processing of the request the server can generate a new key and transmit it back to the client with a request response for instance. A subsequent request will need to transmit the new key together with the request for processing. In this manner the server is sending back a capability that encodes the next possible actions a server is willing to take in response to sending that capability. Among other things this can prevent replay attacks and user errors. For example suppose a user opens a browser window to book a flight and then clones that window. Further suppose that the user books a flight in the cloned window. Now the state in the original window and the cloned window are different where the original window state is incorrect. If a user then believes the booking did not go through and subsequently books a flight in the original window they will have booked two flights unintentionally. By using new keys after transactions the second booking would be disallowed because it did not have a valid capability or permission to perform that action the second time.

In accordance with yet another aspect of the disclosure more than one copy of the key can be provided by the client to the server to enable processing. For instance the cookie including the key can be sent together with a request that injects a copy of the key into the client side state. If one were simply interested in cross site scripting and replay attacks duplication may not be necessary. However if one also desires to prevent cross site request forgery an addition copy should be transmitted. Sending a cookie alone with the request may not be sufficient in light of XSRF since that cookie can be automatically returned to the requesting server. Accordingly the key value should be stored on the client and be duplicated as part of the request. By way of example if the request is an HTTP Get request then the key can be part of the URL. If it is an HTTP Post request then it can be part of the post. Other requests may need to be modified to include the key. For instance if the request involves submitting of an HTML form a hidden field can be added which includes the key. In the case of an AJAX Asynchronous JavaScript and XML request a global variable on the client can include the key and the key will be made part of each AJAX request transmitted to the server. Upon arrival of the request the validation component can first check to see if the keys match. If they do not the request can be denied and no processing performed. If the keys match then the validation component can check to ensure the matching keys are correct in light of what is expected prior to processing. Furthermore it is to be noted that an encrypted key could also be required to initiate server process because if it is not encrypted by the server it could be forged by a malicious client. If the server encrypts the key without handing out the encryption key the data is guaranteed to be from the original server.

Referring to a representative request analysis component is depicted in accordance with an aspect of the claimed subject matter. The request analysis component includes a request monitor component that receives retrieves or monitors server side requests. Block component can analyze one or more requests in light of various policies or signatures in store . The policy store provides a collection of policies and or signatures that identify known or potential attack characteristics or general policies to prevent attack. Upon determining or inferring that a request or group of requests satisfies a policy or signature the block component can block processing thereof. In other words client capability or permission can be revoked. By way of example if a request arrives after a predetermined time the capability can be removed. In another instance where a request returns within a millisecond for example processing will be blocked since it is likely that this is an automated request. Overall a stream of requests can be analyzed to determine if a request or pattern of requests corresponds to something believed to be malicious or a potential security issue. Capability can then be revoked by blocking specific requests or requests from particular Internet protocol IP addresses among other things.

A representative sanitization component is depicted in in accordance with an aspect of the claimed subject matter. The sanitization component includes a serialization component communicatively coupled with a safe encoder component . The serialization component is a mechanism for serializing and deserializing data in the context of storage and transmission. The safe encoder component applies one or more encodings to block unintended script injection as well as ensure well formed presentation code e.g. HTML CSS XAML among other things. In accordance with one aspect of the claims the safe encoding can be applied upon output to HTML for example rather than attempting the more difficult task of sanitizing all input. Further sanitization functionality can be injected where needed in system libraries and or user specified code. In any event automatic sanitization avoids the possibility of XSS 0 XSS 1 and XSS 2.

By way of example and not limitation consider a blog or guestbook application that simply acquires data and provides it an executable context. If those comments include script it can be executed when presented in a web page. However by sanitizing the output it can be ensured that the data is presented as data and not interpreted as code.

In one implementation escaping can be utilized to prevent code execution. For example consider the following code snippet 

Further application programming interfaces APIs or one or more other components can return a safe writer. For instance sometimes developers want to build HTML strings for performance so they write 

Referring to a representative mashup component is illustrated in accordance with an aspect of the claimed subject matter. The mashup component seeks to prevent security issues caused by mashing or combining a foreign application with a secure distributed application as described herein. One exemplary mashup could correspond to combining a mapping application with a secure statistics application to overlay statistics onto of a map. Unless precautions are taken the foreign application could circumvent the security mechanisms employed by the secure application for example by snooping to discover a capability or key representative thereof. Mashup component can prevent such security breaches.

As shown the mashup component includes analysis component and execution prevention component and rewrite component . The mashup component can operate in two different modes. The first mode corresponds to simply limiting the applications that can be combined with a secure application. In this instance the analysis component can determine the expressiveness of a foreign application and the execution prevention component can block or prevent execution of the foreign application where the expressiveness exceeds a threshold. Applications of little expressiveness are not able to negatively impact security mechanisms in place for the secure applications and as such will be allowed to run. However some highly expressive applications may be blocked. In practice this policy might be too restrictive.

The second mode can be utilized where foreign applications are modified statically on the server or at runtime on the client to prevent actions that may threaten security. More specifically the analysis component can analyze the foreign code and the rewrite component can rewrite transform and or filter out portions of the code determined or inferred to be a threat to security. In accordance with an aspect of the claims rewriting can be performed upon deployment. In one instance this can be done on the server side where the distributed application is hosted for example through tunneling. Alternatively rewriting can be done on the client side where the secure application is loaded first and is therefore in control of the page.

Both approaches are beneficial. The advantage of the second approach is that more applications are allowed to co exist with a secure application while preserving the secure properties thereof. However there is a runtime overhead because there is so much security checking. It should be appreciated that a hybrid approach is also contemplated where a higher expressiveness threshold is set and such applications are subject to filtering transformation and or rewriting.

It is to be appreciated that while the foregoing security techniques are disclosed with respect to a development framework that provides automatic tier splitting the claimed subject matter is not limited thereto. Other systems or frameworks can employ the techniques in a similar manner.

The aforementioned systems architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component to provide aggregate functionality. Communication between systems components and or sub components can be accomplished in accordance with either a push and or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems above and methods below can include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation the security component can employ such mechanisms in various manners to identify and or extinguish security threats automatically.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Referring to a method of application construction is depicted in accordance with an aspect of the claimed subject matter. At reference numeral an application is received. At numeral the application is split into different execution contexts or tiers e.g. client server . At reference security mechanisms are injected within the split applications automatically without developer intervention. The security mechanisms can seek to address common distributed application vulnerabilities including cross site scripting cross site request forgery and replay attacks among others. This can be accomplished by utilizing static and or dynamic code analysis and subsequent transformation. Further such security can be afforded by use of system code libraries or the like that include secure code.

Referring to a client side client server interaction method is depicted in accordance with an aspect of the claimed subject matter. In contrast to client side method of it is to be noted that method enforces a sequence of actions. At reference numeral an initial key defining client capabilities with respect to a server portion of an application is acquired. At numeral a request is provided to the server including the current key. The key can be included as part of a cookie and or the request itself. At numeral a result and or a new key is received. Where the request requires a response such a result can be received. Alternatively no result will be received. In any event a new key is provided defining a new capability with respect to the server application. A determination is made at as to whether more requests are to be processed. If yes the method continues at where a request is provided to the server including the current key. If no the method proceeds at where the current key is destroyed.

The method provides an additional mechanism to control interactions in addition to or as an alternative to key matching. By way of example even where a key is valid if it is presented after a time out period the capability can be revoked. Additionally if a series of requests from a client include incorrect keys all requests from the client can be blocked for instance by blocking an associated IP address.

Turning attention to a flow chart diagram of method data sanitization is depicted in accordance with an aspect of the claimed subject matter. At reference numeral data is received. Safe encoding is applied to the data at numeral to identify and remove vulnerabilities. For example HTML can be escaped to avoid injection of script and ensure the HTML is well formed e.g. begin and end tags match . Other techniques can also be applied for example to ensure URL references are local. At numeral the code is serialized or deserialized perhaps to an output web page.

Referring to a secure mashup method is shown in accordance with an aspect of the claimed subject matter. At reference numeral a foreign application is identified for mashing or combination with an application rendered safe by way of the aforementioned mechanisms. At numeral the application is analyzed to identify potential security issues. The foreign application is then transformed or rewritten in a manner that eliminates the potential security issues. This can be accomplished statically or dynamically at runtime. In one instance this can be performed upon deployment on a server. Alternatively the transformation can occur on a client side subsequent to safe application deployment. In this manner the safe application can control deployment of the foreign potentially unsafe application.

The word exemplary or various forms thereof are used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit or restrict the claimed subject matter or relevant portions of this disclosure in any manner. It is to be appreciated that a myriad of additional or alternate examples of varying scope could have been presented but have been omitted for purposes of brevity.

As used herein the term inference or infer refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject innovation.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a program that runs on one or more computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the systems methods may be practiced with other computer system configurations including single processor multiprocessor or multi core processor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. It is to be appreciated that dual microprocessors multi core and other multiprocessor architectures can be employed as the processing unit .

The system memory includes volatile and nonvolatile memory. The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory. By way of illustration and not limitation nonvolatile memory can include read only memory ROM . Volatile memory includes random access memory RAM which can act as external cache memory to facilitate processing.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass storage . Mass storage includes but is not limited to devices like a magnetic or optical disk drive floppy disk drive flash memory or memory stick. In addition mass storage can include storage media separately or in combination with other storage media.

The computer also includes one or more interface components that are communicatively coupled to the bus and facilitate interaction with the computer . By way of example the interface component can be a port e.g. serial parallel PCMCIA USB FireWire . . . or an interface card e.g. sound video network . . . or the like. The interface component can receive input and provide output wired or wirelessly . For instance input can be received from devices including but not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner camera other computer and the like. Output can also be supplied by the computer to output device s via interface component . Output devices can include displays e.g. CRT LCD plasma . . . speakers printers and other computers among other things.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

Client server interactions can be utilized with respect with respect to various aspects of the claimed subject matter. In fact a large portion of the disclosure concerns automatically securing distributed applications such as web applications. In one particular instance capabilities as well as requests and responses thereto can be exchanged between client s and server s across communication framework .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes contains has having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

