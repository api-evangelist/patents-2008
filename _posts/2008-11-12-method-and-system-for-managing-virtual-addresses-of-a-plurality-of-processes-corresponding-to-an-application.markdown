---

title: Method and system for managing virtual addresses of a plurality of processes corresponding to an application
abstract: The present invention provides a method and system for managing virtual addresses of a plurality of processes corresponding to an application. The method comprises designating a first set of ranges of virtual addresses to the plurality of processes, wherein the virtual addresses of the first set of ranges map to a memory region shared among the plurality of processes. Further, the method comprises designating a second set of ranges of virtual addresses to the plurality of processes, wherein the virtual addresses of the second set of ranges map to a memory region independently used by a process of the plurality of processes. Furthermore, the method comprises adding or removing virtual address ranges from one of the first set of ranges and the second set of ranges based on requirements of the application, wherein the addition or removal is performed in virtual addresses of the plurality of processes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117418&OS=08117418&RS=08117418
owner: Tilera Corporation
number: 08117418
owner_city: San Jose
owner_country: US
publication_date: 20081112
---
This application claims the benefit of U.S. Provisional Application No. 61 003 507 filed Nov. 16 2007.

The present invention relates to memory management in an operating system. More specifically the present invention relates to sharing of memory among multiple processes for facilitating concurrent execution of the multiple processes on the operating system.

Sharing memory is a method of inter process communication i.e. a way of sharing data among multiple processes running at the same time on an operating system of a computing device. Various operating systems such as Unix Windows and Linux facilitate the sharing of memory to perform parallel processing of more than one application on the operating system.

Various conventional methods are used to facilitate the sharing of memory in real time among multiple processes. One such conventional method uses memory mapping of the shared data. The operating system maps a file or a shared data object onto the virtual addresses of multiple processes but at potentially different virtual addresses of the memory. In such cases indirect pointer addressing is used to access the memory. The indirect pointers to the memory may be treated as offsets from the beginning of a virtual address of the memory. As a result all references to data in the virtual addresses are made by adding an offset to the base of the mapped data. Further all the references are returned separately to each of the multiple processes. This operation is slow and lacks convenience in comparison to direct pointer addressing. In addition the pointers may not be saved to the shared memory and may cause subtle bugs in the system.

In another conventional method the operating system executes multi threaded programming. In multi threaded programming multiple threads share the same address of the memory. However writing via an incorrect pointer to the memory in a thread can corrupt data from another thread or other data that is not meant to be visible to other threads. Further in the thread model the size of available virtual address is limited to the amount addressable in a single address. In such a system the amount of memory that can be allocated is limited to the available virtual address.

In case of a shared virtual address the multiple processes need to make coordinated attempts to allocate memory in the shared address to exchange information through some external channel. Examples of external channels include but are not limited to file descriptors sockets and files. The multiple processes may keep trying to locate a corresponding suitable physical address of the memory. Alternatively the processes involved may choose a single fixed physical address that works on a given machine but may fail with slight changes to the operating system with the passage of time causing unexpected program failure. Therefore the process of sharing memory through the sharing of the virtual address is failure prone.

In light of the foregoing discussion there exists a need for a method and system that can efficiently manage addresses in a multi processing environment. The operating system should preferably avoid the acquiring of multiple locks across the multiple processes to perform a single system call. Further the operating system should preferably include high performance techniques for allocating shared memory across multiple processes without the requirement to lock addresses of all the processes running on the operating system. Furthermore there exists a need for a method and system that facilitates the direct pointer addressing to the memory. Furthermore the method and system should preferably lower the risk of data corruption in the memory. Additionally there exists a need for a method and system which can scale the amount of allocable memory in proportion to the number of processes running on the operating system and prevent performance loss.

An object of the present invention is to provide a method system and computer program product for managing virtual addresses of a plurality of processes corresponding to an application running on an operating system in a computing device.

Another object of the present invention is to provide a method system and computer program product for direct pointer addressing to a memory.

Yet another object of the present invention is to provide a method system and computer program product for scaling the amount of allocable memory in proportion to the number of processes running on the operating system.

Various embodiments of the present invention provide a method for managing virtual addresses of a plurality of processes corresponding to an application running on the operating system in the computing device. The method includes designating a first set of ranges of virtual addresses to the plurality of processes. The virtual addresses of the first set of ranges map to a memory region shared among the plurality of processes. Further the method includes designating a second set of ranges of virtual addresses to the plurality of processes. The virtual addresses of the second set of ranges map to a memory region independently used by a process of the plurality of processes. Furthermore the method includes performing either addition or removal of virtual address ranges to from one of the first set of ranges and the second set of ranges based on the requirements of the application. The addition or removal is performed in virtual addresses of the plurality of processes.

Various embodiments of the present invention provide a system for managing virtual addresses of a plurality of processes corresponding to an application. The system includes a common map and a multi level page table. The common map is an operating system data structure which includes a first set of virtual address ranges a second set of virtual address ranges and a third set of virtual address ranges. The virtual addresses of the first set of ranges map to a memory region shared by the plurality of processes. Further the virtual addresses of the second set of ranges map to a memory region independently used by a process of the plurality of processes. The virtual addresses of the third set of ranges is configured to be used as one of a virtual address of the first set of ranges and a virtual address of the second set of ranges based on requirements of the application. The multi level page table is a data structure for storing mapping between virtual addresses and physical addresses of memory and includes a mapping between the first set of virtual address ranges and a set of physical address ranges of memory corresponding to the first set of ranges stored at one or more levels of the multi level page table. Further the multi level page table includes a mapping between the second set of virtual address ranges and a set of physical address ranges of memory corresponding to the second set of ranges stored at one or more levels of the multi level page table.

Various embodiments of the present invention provide a computer program product for managing virtual addresses of a plurality of processes corresponding to an application. The computer program product includes program instructions for designating a first set of ranges of virtual addresses to the plurality of processes. The virtual addresses of the first set of ranges map to a memory region shared among the plurality of processes. Further the computer program product includes program instructions for designating a second set of ranges of virtual addresses to the plurality of processes. The virtual addresses of the second set of ranges map to a memory region independently used by a process of the plurality of processes. Furthermore the computer program product includes program instructions for performing either addition or removal of virtual address ranges to from one of the first set of ranges and the second set of ranges based on requirements of the application. The addition or removal is performed in virtual addresses of the plurality of processes.

Various embodiments of the present invention provide a method system and computer program product managing virtual addresses of a plurality of processes corresponding to an application running on the operating system in the computing device. The method system and computer program product provide an operating system data structure that facilitates the sharing of the memory among multiple processes. The operating system uses a common map wherein the common map is the operating system data structure to allocate various types of memory to the multiple processes. The common map partitions the virtual addresses of the memory into three types of virtual address ranges. In the common map a first set of ranges of virtual addresses are designated as common addresses. A second set of ranges of virtual addresses are designated as private addresses. Additionally a third set of ranges of virtual addresses are designated as unreserved addresses. Hereinafter for the sake of clarity of the description the first set of ranges of virtual addresses will be collectively referred to as common addresses. Similarly the second set of ranges of virtual addresses will be collectively referred to as private addresses and the third set of virtual addresses will be referred to as unreserved addresses. Virtual addresses corresponding to common addresses can be shared by more than one process virtual addresses corresponding to private addresses are exclusively used by a process and an unreserved address can be used either as a private or common address depending upon the requirement of the memory by the multiple processes. Virtual address ranges can be added to one of the first set of ranges and the second set of ranges. The addition is performed in virtual addresses of the plurality of processes. Similarly virtual address ranges can also be removed from one of the first set of ranges and the second set of ranges. The removal is performed in virtual addresses of the plurality of processes.

Various embodiments of the present invention provide a method and system for managing virtual addresses of a plurality of processes corresponding to an application running on an operating system in a computing device. Examples of the computing device include but are not limited to personal computers mobile devices and handheld devices. The method and system provide a new operating system data structure that facilitates the sharing of the memory among multiple processes. The operating system uses the data structure to allocate various types of memory to the multiple processes. In accordance with an embodiment of the present invention the data structure is referred to as the common map. The common map partitions the virtual addresses of the memory into three types of virtual address ranges private common and unreserved. In the common map a first set of ranges of virtual addresses are designated as common addresses. A second set of ranges of virtual addresses are designated as private addresses. Additionally a third set of ranges of virtual addresses are designated as unreserved addresses. Virtual addresses corresponding to common addresses can be shared by more than one process virtual addresses corresponding to private addresses can be exclusively used by a process for private memory and an unreserved address can be used either as a private or common address depending upon the requirement of the memory by the multiple processes. Virtual address ranges can be added to one of the first set of ranges and the second set of ranges. The addition is performed in virtual addresses of the plurality of processes. Similarly virtual address ranges can also be removed from one of the first set of ranges and the second set of ranges. The removal is performed in virtual addresses of the plurality of processes.

A person of ordinary skill in the art will understand that the number of processes is not limited to six but has been assumed as six for the exemplary purpose of explaining the invention. Operating system allocates memory to processes to facilitate concurrent execution of processes on it. In accordance with various embodiments of the present invention processes of a single application program may belong to one group. There can be one or more groups of processes running at the same time on operating system . For example processes and may belong to a first group of processes hereinafter referred to as processes of the first group. Further processes and may belong to a second group of processes. Operating system assigns a data structure such as a common map to the first and second group. The common map includes various types of virtual addresses for processes of a particular group. For example a common map for the processes of the first group will include various types of virtual addresses for processes and . The common map for the first group is illustrated in detail with reference to .

The addition or removal of the virtual address ranges is performed dynamically at run time i e. when the processes are in execution stage. The number of private common and unreserved addresses can vary according to the requirements of memory by the processes of the first group. Further the update module is configured to delay modification of the multi level page table until one or more processes of the plurality of processes is referencing to a set of physical address ranges of memory corresponding to the common addresses. In this case referencing refers to association of one or more processes with a set of physical address ranges of memory corresponding to the common addresses and or the private addresses.

Each of the common addresses can be used and shared by more than one process. For example common address can be used and shared by two processes and . Further each of the private addresses can be used independently by each process for its own purposes. For example process may use private address for some private purpose while process may use private address for a different purpose referencing different physical memory via its private page table. Private page table is a part of the multilevel page table that stores the mappings between private addresses and and corresponding physical addresses of memory for each of the processes. Furthermore the unreserved address can be used either as a common address or a private address depending upon the requirements of memory for the processes of the first group.

In accordance with an embodiment of the present invention a common address for the first group cannot be shared by processes of the second group. For example processes and cannot use and share the common addresses for the first group as the common addresses of the first and second groups are unrelated. Moreover memory is allocated to them independently of each other. The physical addresses of memory corresponding to the common addresses are hereinafter referred to as common memory. Similarly the physical addresses of memory corresponding to the private addresses are hereinafter referred to as private memory.

Operating system uses page tables and to manage the allocations and de allocations of the various types of memory to processes of the first group. A process can require private as well as common memory. Each of the page tables and is a process specific table that maps the virtual address of the process to memory . For example page table stores the mappings of the virtual address of process and memory and page table stores the mappings of the virtual address of process and memory . When memory is allocated to process page table includes the address entries corresponding to the allocated memory . When memory is de allocated for process page table of process is updated i.e. the address entries corresponding to the de allocated memory are removed from page table . For the sake of explaining the invention only two page tables have been illustrated in the figure. However it would be apparent to a person of ordinary skill in the art that operating system can use more than two page tables for managing the allocations and de allocations of memory .

In accordance with an embodiment of the present invention page tables and are multi level page tables. Each of multi level page tables and include top level and lower level page tables. In accordance with an embodiment of the present invention common map corresponds to some level of a multi level page table. For example in case of a two level page table common map will correspond to the top level page table. The multi level page tables and are explained in detail with reference to .

Lower level page tables and correspond to private addresses and of processes and . Lower level page tables and are used to provide independent private memory to processes and . Lower level page tables and are also referred to as private page tables. Common addresses and and private addresses and are represented as separate mapping for each of the plurality of processes. Further common addresses and have identical mapping to the same shared memory in each of the plurality of processes for virtual addresses. As illustrated in lower level page tables and are shown as unrelated to each other. This implies that each of the private page tables can be used by one process at a time. A private page table cannot be shared by two processes simultaneously whereas as illustrated in the lower level page tables and corresponding to common addresses are shared by processes and . The common page tables can be shared by two or more processes simultaneously. In accordance with an embodiment of the present invention process allocates memory to private address by using lower level page table . Further process allocates memory to private address by using lower level page tables and

When there is any change in allocation of memory to common addresses and lower level common page tables and are updated. Further when there is any change in allocation of private memory to private addresses and private page tables and are updated. Furthermore there is delaying in modification of the common page table until one or more processes of the plurality of processes is referencing the common memory.

If private memory is not available at private address operating system locks common map at step . Further at step operating system marks a new private address for process . If an unreserved address such as unreserved address is present in common map then unreserved address is marked as the new private address. If no unreserved address is present in common map then the allocation fails and the application receives an error notification from the operating system. At step memory is allocated to process at the new private address. Further at step the lock of common map is released.

If common memory is available at step the common memory corresponding to common address is allocated to process . The allocations made for the common memory are referred to as MAP COMMON allocations. When common memory is allocated to common address the shared lower level page table that corresponds to common address is updated. Further at step the lock of common map is released. If common memory is not at any of the common addresses then operating system marks a new common address at step . An available unreserved address such as unreserved address can be marked as a new common address. Further steps and are repeated for allocating memory at the new common address.

In accordance with an embodiment of the present invention a page fault handler of operating system is modified to discover new common memory for process when a new common address has been formed by another process. A page fault is an operating system interrupt that occurs when process tries to access a virtual address that does not correspond to a physical address in memory . A page fault occurs when the new common address may not be mapped onto a physical address in memory . When a page fault occurs the page fault handler locks common map and checks whether a new common address has been added to common map . If a new common address has been added to common map then the page fault handler copies the pointer to the shared lower level page tables and into page table of process and releases the lock. In this case the pointer to the shared common page table may be a pointer to memory of common address if common address is now used as a new common address. Similarly the pointer to the shared common page table may be a pointer to unreserved address if unreserved address is now used as a new common address.

When common memory is allocated to process process may pass a pointer to the common memory of other processes of the first group through a simple unidirectional one time channel to make them aware of the allocated common memory. Examples of the one time channel include but are not limited to a common writable configuration file.

In accordance with an embodiment of the present invention when process deallocates common memory then the common page table corresponding to common address is updated. The shared lower level page tables are updated by unmapping the pages of common address and the corresponding common memory. To implement the process of unmapping the pages of shared lower level page tables operating system sends an interprocessor interrupt to the processors running processes and . The interrupt is sent to clear the physical address entries corresponding to the unmapped common memory from the Translation Lookaside Buffer TLB of the processor. Also the new common address which was formed from unreserved address can be reset to unreserved address when the shared common page table corresponding to the new common address has no pages corresponding to memory .

In accordance with an embodiment of the present invention process can perform a fork . The fork is a UNIX Application Programming Interface API that creates a new process which is almost identical to the creating process. When process uses the fork common map is shared by the two new processes. Process can make its own calls to fork and start a new group of processes that share common addresses. The processes created from fork belong to the same group of processes.

In accordance with another embodiment of the present invention process can perform an exec . The exec is a UNIX API that starts the execution of a specific executable program by overwriting the current process with new code and data. When process performs an exec common map is maintained. Operating system will likely not flush any references to common mappings out of the top level page table to maintain high efficiency. A high efficiency is achieved as the new program avoids taking the common lock and searching the common page table.

In accordance with another embodiment of the present invention process calls set common . Set common is a system call that tells operating system to treat process as the parent of a group of future processes that will participate in the allocation of the common memory. When process calls set common operating system drops the reference to common map and unmaps all the common pages from the virtual address of process

In accordance with an embodiment of the present invention the method of the present invention can be implemented in an Intel x86 architecture by using segment registers. One or more segments can be dedicated to the private memory. For example the ds and fs segments on Linux x86 can be dedicated to the private memory. Further one or more segments can be dedicated to the common memory. A common segment can be allocated to a memory mapped region of memory and even if the data is mapped at different virtual addresses in different processes the segment override can be used to make memory effectively appear at the same address for all processes.

In accordance with another embodiment of the present invention memory can be shared in real time among processes with a user space solution. By defining an API for the dozen odd kernel APIs newAPI xxx variants can be created that broadcast the call out to all processes and apply it. For example the set of syscalls for which the variants can be created are brk mmap munmap shmat mprotect msync mlock munlock mlockall munlockall mremap madvise remap file pages and mbind. For mmap a newAPI mmap common API is created that would choose a MAP FIXED address out of a reserved pool of virtual address . The newAPI secures up front and requires all the peer newAPI processes to reserve. When a newAPI spawn is created part of it is used to recreate the common mappings in the new process first by reserving virtual address during newAPI init s early startup and then by just re issuing the common mmap commands that the other peer processes have issued over their lifetime. The malloc library can be changed so that mmap munmap and mremap function pointers can be provided for a given mspace. Further newAPI offers malloc shared API by creating an mspace that was built on ilib mmap ilib munmap and ilib mremap. The advantage of implementing the data sharing scheme in user space is that it completely decouples the kernel. A kernel based solution tracks future operating system kernel releases merges in platform independent code corresponding to all the APIs and modify calling methods. The calling process first locks the map common table and finds a virtual address for the common memory. Then it broadcasts to the other tiles interrupts them and causes them to copy the new common region into their private page tables via a call to the operating system s normal mmap API which maintains the private page table. When all of the tiles have updated their private page tables via mmap the calling process releases the map common table and returns.

In accordance with an embodiment of the present invention the method of marking virtual addresses as private and common addresses improves the program security.

In accordance with an embodiment of the present invention only common addresses are meant to be visible to the processes of the first group thereby lowering the risk of data corruption.

In accordance with an embodiment of the present invention the method and system of the present invention facilitate the allocation of common memory across the processes of the first group without acquiring multiple locks.

Further the present invention allocates private and common memory to an application without the requirement to lock the common map on every allocation. This is ensured by partitioning the addresses at one level of the multi level page table such that all addresses represented by that level s page table are either private or common.

The present invention allocates private memory and or common memory to an application without requirement to lock the common map on every allocation by partitioning the addresses at one level of the multi level page table into private and common addresses. Since private addresses need not be locked during allocation the common map is required to be locked for only those processes which require common memory.

In accordance with an embodiment of the present invention the processes of the first group with distinct virtual addresses and using common memory can scale the amount of addressable memory in proportion to the number of processes. The amount of addressable memory is scaled in proportion to the number of processes as the common memory can be used by more than one process simultaneously.

The present invention provides efficient techniques for allocating new private memory or common memory to any of the processes for choosing appropriate addresses for new private and common memory and for efficiently discovering changes to the common address when another of the plurality of processes has made modifications.

The method and system as described in the present invention or any of its components may be embodied in the form of a computer system. Typical examples of a computer system include a general purpose computer a programmed microprocessor a micro controller a peripheral integrated circuit element and other devices or arrangements of devices that are capable of implementing the steps that constitute the method of the present invention.

The computer system typically comprises a computer an input device and a display unit. The computer further comprises a microprocessor. The microprocessor is connected to a communication bus. The computer also includes a memory. The memory may be Random Access Memory RAM or Read Only Memory ROM . The computer system further comprises a storage device which may be a hard disk drive or a removable storage drive such as a floppy disk drive optical disk drive etc. The storage device may also be other similar means for loading computer programs or other instructions into the computer system. The computer system also includes a communication unit. The communication unit allows the computer to connect to other databases and the Internet through an Input Output I O interface allowing the transfer as well as reception of data from other databases. The communication unit may include a modem an Ethernet card or any other similar device which enables the computer system to connect to databases and networks such as LAN MAN WAN and the Internet. The computer system facilitates inputs from a user through an input device accessible to the system through an I O interface.

The computer system executes a set of instructions that are stored in one or more storage elements in order to process input data. The storage elements may also hold data or other information as desired. The storage element may be in the form of an information source or a physical memory element present in the processing machine.

The programmable instructions may include various commands that instruct the processing machine to perform specific tasks such as the steps that constitute the method of the present invention. The method and systems described can also be implemented using only software programming or using only hardware or by a varying combination of the two techniques. The present invention is independent of the programming language used and the operating system in the computers. The instructions for the invention can be written in all programming languages including but not limited to C C Visual C and Visual Basic . Further the software may be in the form of a collection of separate programs a program module with a larger program or a portion of a program module as in the present invention. The software may also include modular programming in the form of object oriented programming. The processing of input data by the processing machine may be in response to user commands results of previous processing or a request made by another processing machine. The invention can also be implemented in all operating systems and platforms including but not limited to Unix DOS and Linux .

