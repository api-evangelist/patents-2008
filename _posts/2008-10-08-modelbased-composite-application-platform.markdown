---

title: Model-based composite application platform
abstract: Embodiments provide an architecture to enable composite, autonomous composite applications and services to be built and deployed. In addition, an infrastructure is provided to enable communication between and amongst distributed applications and services. In one or more embodiments, an example architecture includes or otherwise leverages five logical modules including connectivity services, process services, identity services, lifecycle services and tools.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08751626&OS=08751626&RS=08751626
owner: Microsoft Corporation
number: 08751626
owner_city: Redmond
owner_country: US
publication_date: 20081008
---
This application stems from and claims priority to U.S. Provisional Application Ser. No. 60 982 032 filed on Oct. 23 2007 the disclosure of which is incorporated by reference herein.

Developing and deploying data driven composite applications that is applications that are built by combining multiple modules can be a challenging task particularly when one considers deployment in a distributed environment.

To date the need for specific low level programming knowledge has presented formidable barriers to the development and deployment of data driven composite applications.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Embodiments provide an architecture to enable autonomous composite applications and services to be built and deployed. In addition an infrastructure is provided to enable communication between and amongst distributed applications and services.

In one or more embodiments an example architecture includes or otherwise leverages five logical modules including connectivity services process services identity services lifecycle services and tools.

As noted above applications that are built by combining multiple modules are referred to as composite applications . The different parts of a composite application e.g. the client part business process part data store part and the like can run in completely different environments e.g. ASP.NET BizTalk SQL Server which greatly increases the difficulty of dealing with the application as a whole. In addition the different moments in the composite application lifecycle are often poorly automated if at all. To date composite application infrastructure currently lags its requirements e.g. it is not at all unusual for rich composite application authors to report that they spend more than 90 of their resources writing infrastructure code. As distributed processing and bandwidth becomes more and more ubiquitous businesses and others face a tantalizing gap between what they conceive and what they can afford to build deploy and manage.

Development of a model of a composite application should make it possible for non traditional programming communities to participate in building significant applications. This is made possible by enabling people to work on applications without necessarily writing scripts or code. Functional abstractions such as rules or workflows described below are somewhat closer to the way people actually think about systems than code and installation scripts.

In the discussion that follows the notion of a platform or architecture is introduced. The platform can provide a unified target for declarative programming experiences and domain specific languages. Declarative experiences can be provided across the lifecycle of an application such that programming end users can deal with their particular systems in terms of declarative abstractions and not in terms of code or scripts. As will be described below a common repository shared by applications tools and services is utilized and simplifies development and management by reducing the number of different stores involved in the application lifecycle. The greater value of the repository is that it contains schemas and content in the form of models. Ongoing use of the repository can teach application writers to think in terms of models. As more aspects of applications appear as content in the repository new synergies between parts will become apparent and exploitable in ways never before possible.

Today managing and analyzing a composite application involves completely different experiences for each part of the application. In accordance with the embodiments described below composite applications can be managed and analyzed as a whole rather than as different parts. In at least some embodiments it is possible to deploy manage and analyze applications as entire entities through a single interface. Additionally individual parts of those applications can be incrementally versioned using the described platform. In one or more embodiments observation models can be established from the point of view of the entire application which leads to an understanding of the execution of the composite application through its various parts in terms of unified analyst friendly metaphors.

In the embodiments described below an architecture is described and enables autonomous composite applications and services to be built deployed and managed. The architecture can enable different types of composite applications to be described in terms of models. Composite applications are applications that are driven by data change events. Composite applications are typically specified in terms of rules that specify exactly what sort of data changes are interesting and actions that are triggered when the data changes. For example message driven composite applications are applications that are driven by the exchange of messages. This group breaks down into n tier request response composite applications queued composite applications and pub sub or event driven composite applications. Scheduled composite applications are applications that are driven by a scheduler. The scheduler is programmed by a model describing control flow through modules. A workflow application is a good example of this type of application. For each of these types of applications there is a corresponding communication infrastructure or rather a corresponding usage pattern of the communication infrastructure.

In addition an infrastructure is provided to enable communication between and amongst distributed applications and services. The architecture also referred to as a platform provides a mechanism that enables developers to build rich autonomous composite applications and services. A composite application is described by data in the form of a model which is then used to build and deploy application components in a distributed manner. The described platform or architecture can be used to manage a set of machines or computing devices and a set of applications that run on them.

In one or more embodiments an example architecture includes or otherwise leverages five logical modules including connectivity services process services identity services lifecycle services and tools although the functionality embodied by the modules need not necessarily be represented by this particular architecture. Rather other architectures can be utilized without departing from the spirit and scope of the claimed subject matter.

In the discussion that follows a section entitled Composite Applications is provided and discusses the notion of a composite application and what is meant by a composite application . Following this a section entitled Example Architecture or Platform is provided and describes in accordance with one or more embodiments one example architecture or platform that can be utilized to enable development and deployment of composite applications. Within this section several sub sections will be provided to describe various aspects of the architecture. Lastly a section entitled Example System is provided and describes an example computing device that can be utilized to implement one or more aspects of the described embodiments.

As noted above a composite application is an application that is described by a model. The model can then be used to select an application s constituent parts build an instance of a corresponding application and deploy the application instance in an appropriate environment. Hence one goal of the platform is to be able to describe composite applications with models and then design develop deploy and manage those applications on the platform.

Specifically in at least some embodiments the structure of an entire connected application is described in terms of a distributed model. This model can assume one or more of several types of models such as by way of example and not limitation a message driven model a data driven model a scheduled or workflow model and the like. Individual components of an application at one level of granularity can be an entire connected application at the next level of granularity. As one becomes more specific the types of models used to describe parts of the application may change rather dramatically. So for instance at one level one might have a message or call driven application consisting of a web page some business logic and a database. This application would then be described by one type of model. Looking specifically at the business logic aspect of the application one might find it to be described by a second type of model made up of rules and declarative workflows. By expressing applications in at least some embodiments in terms of rules and declarative work flows a higher level of abstraction is provided for the developer so that the developer does not have to necessarily understand low level programming details. Hence flexibility is enhanced by opening up the development process to those who do not necessarily have knowledge of low level programming languages.

In some embodiments an application shell or some other tool such as those described below in the form of a user interface is provided and allows the developer to develop an application. Through the application shell the developer can provide a declarative description of his or her application and can define such things as commands documents visualizations jobs or tasks communication contracts identity and more. Thus the shell can provide a mechanism by which a developer can develop and plug in their application. The application shell then has the mechanisms to use lower levels of the architecture at execution time. These lower level mechanisms can be transparent to the developer.

Having discussed the general notion of a composite application consider now a discussion of an example architecture or platform that can enable such applications to be developed and deployed.

In the discussion that follows an example architecture or platform is described. It is to be appreciated and understood that the described architecture or platform constitutes but one way of describing the functionality described herein. Accordingly other architectures or platforms can be utilized without departing from the spirit and scope of the claimed subject matter.

Briefly though the connectivity services component includes in this example a service bus component a transaction services component and a messaging services component . Process services component includes a workflow rules component . Identity services component includes a directory services component and an access services component . Lifecycle services component includes a repository component an integration component an executive component and an analytics component . Tools component includes a code based component such as Visual Studio a model based tool such as Quadrant and an enterprise management tool such as a system center component .

Collectively architecture and its constituent parts enable composite applications to be developed and deployed as will become apparent below.

In one or more embodiments connectivity services component includes in this example a service bus component a transaction services component and a messaging services component .

In one or more embodiments service bus component or more simply the service bus provides an infrastructure that allows applications and services to communicate with one another. To this extent the service bus can be thought of as the connective fabric between services and applications.

From a functional standpoint the service bus is utilized to virtualize transfer discovery and synchronization between diverse endpoints . Notably in at least some embodiments the service bus also offers transformation filtering assembly and disassembly and protocol transport bridging at endpoints.

Endpoints examples of which are provided below can include applications that are built on or utilize the described architecture. The service bus builds on a layered data model provides name based and predicate based lookup and discovery functionality and so called claims based security described below. Endpoint characteristics i.e. characteristics of the location at which listening takes place are modeled in this example through a layered and extensible metadata stack. The service bus utilizes or otherwise can provide various pluggable entities to accomplish its tasks. For example pluggable transports can be utilized to virtualize message transfer independent of endpoint semantics. Pluggable encoders can be utilized to virtualize message representation independent of local data models. Further pluggable adapters are used to bridge the metadata and messages from a set of endpoints onto the bus.

In practice applications utilize the service bus to communicate with services or other applications. With respect to services and applications consider the following analogy. Services are components of composite applications in the same way that objects are components of local applications. When one is writing an object oriented application the entire application is an object and then one just writes that object in terms of other objects. Just so when one is writing a service oriented application the application might be a service and then one would write those services in terms of other services. Eventually the services have a local implementation and they are written with objects. Prior to communicating with another application or service the application can in some embodiments search and find the particular entity with which communication is desired. To this end the service bus provides search and discovery components that enable the discovery of the applications or services via for example a network address with which the application desires to communicate. Alternately or additionally a communication pattern can be modeled and the entity with which communication is desired can be identified in a particular model. In addition the service bus includes synchronization functionality that functions to ensure that data between entities that communicate over the service bus is synchronized. That is the service bus can provide in some embodiments both a message based communication pattern and a data based communication pattern. The message based communication pattern might for example specify that A sends messages to B or A multicasts messages to B1 B2 B3 B4 and so on. The data based communication pattern may on the other hand specify that if A changes data all parties interested in changes to that data are triggered. Then any interested party can read or modify the data at any time. The protocols used to communicate this information or data are configurable and extensible.

In one or more embodiments the service bus can further include a federated naming component that ensures that applications resources and the like are named consistently. A messaging adapter and framework deals with the notion that data that comes from different sources may be the same logical piece of information. However the data may need to be transformed so that others on the service bus can recognize it. Hence the messaging adapter and framework deals with data transformation to ensure cross platform data consistency and compatibility. For example in at least some embodiments applications can create a set of names that are used by that application. Names are then associated with metadata and applications can search for names by queries on the metadata. Applications can send messages directly to names and namespaces can be secured by claims based mechanisms. The service bus abstracts the notion of senders and receivers. Receivers can thus act on data without concern for where the data emanates. In a multicast version of the service bus senders can send to a name and receivers can listen on a name. Thus in at least some embodiments the sender cannot tell whether 0 or N people were listening and the receiver cannot tell who sent a particular message.

Further in at least some embodiment the service bus endpoints can support a variety of features that are utilized to transform messages from sender formats into a format expected by the application at the endpoint. These features can include by way of example and not limitation raw transformation filtering aggregation and disaggregation often called batching e.g. pulling many messages from a single message or building many messages into a single message and protocol bridging causing a message arriving at an endpoint to be resent on a different instance of the service bus .

The service bus also includes messaging and channel security functionality that pertain to securing communications between the different entities that utilize the service bus. For example both message exchange and access to service bus resources e.g. configuration namespaces can be secured. Security on features can include by way of example and not limitation authentication that is are they who they say they are and authorization that is are they allowed to do what they are asking to do . Additionally security functionality can also provide for encryption and other digital rights management DRM on individual messages and or message parts.

As but one example of a service bus in accordance with one or more embodiments consider . There an example service bus component is shown generally at . In this example service bus component includes an encoder layer a channel layer and various other higher level components that provide functionality described above and below. Specifically in this example service bus component includes a discovery component a federated namespaces component a federated identity component and a relay component . When a relay component is integrated into the service bus it is then possible for service bus participants to communicate between endpoints that are separated by firewalls or are otherwise mutually unaddressable. The relay functionality can be implemented using a combination of advanced networking features and intermediaries visible to both endpoints to achieve this purpose as will be appreciated by the skilled artisan.

In this example the encoder and channel layers provide functionality that enables point to point communication. To this extent encoder layer supports a number of different encoding standards e.g. SOAP XBIN POX RSS and the like as well as character sets. The channel layer comprises different components that facilitate point to point communication. By way of example and not limitation these components include listener components transport components adapter components and feature components.

In one or more embodiments listener components are responsible for monitoring communication systems and firing events when messages are available on the system. Listener components are used to trigger things such as activation in host systems.

Transport components serve to move messages between one endpoint and another. By definition transport components use raw transport systems such as TCP or HTTP. Transport components can be linked directly with corresponding listener components. For example a listener component may fire a connection available event and the application may then create a transport channel for that event. The application can then read the new messages on the connection whose existence was signaled by the listener component.

Adapter components can appear like transport components to their users. Adapter components wrap sources or sinks of messages and make them seem like transport components. In at least some embodiments there can be different types of adapter components. For example line of business LOB adapter components wrap a line of business system such as SAP or Peoplesoft. Messaging adapter components wrap messaging infrastructure or intermediaries like DCOM MSMQ MQ or TibCo.

Feature components are components that implement features at the endpoint that are not encoders or transports. These include protocol components like WS Security or WS RM transformation and filtering components like those found in BizTalk pipelines and protocol bridging components.

In one or more embodiments individual adapters can be written as transport channels so that the same software architecture that receives or gets messages can also be used to connect applications to other applications messaging infrastructures and the like as will be appreciated by the skilled artisan.

Collectively the encoder and channel layers can be considered as a message bus which sends receives and processes data in the form of messages that are sent by or received into the platform. The message bus can process messages perform transformations on the messages in various forms e.g. in an infoset or binary representation and or otherwise make the message content available for other components of the platform.

In addition to message processing and serving as a lower level point to point transport service service bus component also includes higher level components such as the illustrated discovery component federated namespaces component federated identity component and relay component .

In the illustrated and described embodiment discovery component includes functionality that enables individual queries into the service bus and returns results that match the individual queries. For example an application may issue a query to find a printer find a service that handles purchase orders and the like. The discovery component enables such queries and associated results to be returned to querying parties. Thus discovery component supports indirection between modules in a connected application. For example in the previous discussion the notion of naming was discussed. In at least some embodiments two kinds of names are germane to consider here. First endpoints can have names. Thus the service bus can be presented with a name with which communication is desired. Entities who wish to communicate with other entities use an associated name rather than a particular address. Second the service bus infrastructure has names inside of itself e.g. names of resources that outlive any particular endpoint. Those names can be by way of example and not limitation names of queues which are names with a single reader as well as a single writer and or they can be names of topics which are names with multiple readers and or multiple writers . These names can be associated with metadata meaning structured data describing the thing being named. Discovery as implemented by the discovery component pertains to the business of finding names in the service bus either directly by name if known or indirectly by means of querying the metadata e.g. if you know you need whomever processes purchase orders .

This can be implemented by the messaging infrastructure in cases dealing with adapters that wrap an infrustructure that has its own decorated names. It can also be implemented by a discovery server in cases where a service using a lightweight transport HTTP wishes to register names with the service bus. illustrates generally at an environment in which the federated namespaces component can operate in accordance with one or more embodiments. Here the federated namespaces component includes two layers a rendezvous layer and a namespaces layer . These layers are shown logically interposed between a channel layer which corresponds to the channel layer of the message bus of and which is used for point to point communication and a number of features that can be built on top of the namespace layer . These additional features are logically represented at and include by way of example and not limitation discovery services notification services directory services and message server services. All of these services can utilize the namespace layer to in essence plug in to the platform and use the namespace functionality to provide a rich suite of functionality.

In the illustrated and described embodiment the rendezvous layer implements wide area proximity aware routing. In the illustrated and described embodiment the rendezvous layer provides federated address spaces. Machines or devices can join a particular address space regardless of whether the machines or devices are actually visible to the other machines or devices in the address space. For example machines or devices might be separated by firewalls might be located in corporate subnets that are not publicly addressable and the like. Machines or devices can send to particular machines or devices on the federated address space by address and they can multicast to all the machines or devices in the address space. So in some instances features of a TCP subnet are provided except that they can be set up and taken down dynamically and do not have to be co located.

The namespace layer is located logically on top of the rendezvous layer and provides support for names for particular addresses or groups of addresses in the federated address space. Multiple services can listen at the same name and names can be associated with metadata. Names can be searched for based on their metadata. The names give the user a level of indirection when using the federated address space. Names can be created and destroyed dynamically and on a per application basis.

Additional features shown generally at constitute either uses of this infrastructure or services that are built on top of it. For example Discovery can sometimes refer to the ability to examine the names on top of the address space in order to find names associated with certain sorts of metadata. Discovery can also refer to a service on top of this infrastructure that keeps track of metadata address associations and offers that information through standard discovery protocols such as UDDI WS Discovery and the like. Notification refers to the ability to register a service at names to which notifications are sent. Directory refers to an application that provides management services of a set of repositories e.g. access control replication control and the like . Message Server refers to services that live in on the component that provide reliability and or durability to users of the component.

In one or more embodiments federated identity component provides a security architecture and paradigm for the platform. As one example of a security architecture consider . There an example security architecture or system is shown generally at . Here system includes one or more server technology service components which manage tokens a policy manager a cardspace system a cardspace agent security token managers a client a service and a service authorizing manager .

In operation and in accordance with one or more embodiments security architecture works in the following way. In a messaging stack when client wishes to use service client does so by utilizing a claim such as a key. A claim can be considered at a basic level as data that constitutes an assertion of some fact. The integrity and secrecy of claims is protected by means of security techniques. Accordingly in this example client communicates with the security token manager to ascertain whether there is a claim or key associated with service that it can use to utilize service . Policy associated with service identifies claims that are required to access service or the security protocols can be used to ask service what claims are needed. Client passes the claims it has and information about the claims it needs to its security token manager . The security token manager consults with various claims policy stores such as cardspace system and or policy manager in order to ascertain which claims it can provide to client to use in its communication. At this point client communicates with service which takes the claims provided by client . Service undergoes a similar claims resolution process with the service authorization manager . Once again the set of claims provided by the client can be augmented on the server side with claims associated with the client s claims in the server s policy store. Eventually this process completes and the final client claim set is calculated. If the claim set includes the claim needed to communicate with service access is granted.

In at least some embodiments another level of recursion can take place in which service can point at an intermediary claims server that the client can use to get a claim. The intermediary claims server can redirect to a further claims server and so on. Eventually the recursion stops when there are no more steps to be taken or the required claims are acquired.

Thus in one way the mechanism on the service side is the same as the mechanism on the client side. That is the service starts with claims presents them to a policy store e.g. policy manager and has the claims augmented. The policy store can redirect to another policy store and so on.

Transaction services component supports the coordination of the responses of modules in distributed applications to both expected and unexpected states in one or more of the modules. One basic pattern that can be encountered is as follows. A set of resource managers decide to coordinate through a transaction. Those resource managers send their state to a transaction manager who aggregates the states into a transaction outcome and that outcome is sent back to the resource managers. In the context of longer running stateful business processes or service oriented applications the pattern can be generalized as follows. Information from the distributed application model can be used to identify the set of resource managers involved in a transaction. Stateful application modules need to behave as logical resource managers. The protocol between resource managers and transactions needs to be rich and application specific and the aggregation of local states into transaction state needs to be general and policy driven.

As but one example of a transaction services process consider the following in connection with . There a transaction services environment is shown generally at . In this example environment includes a programming model a transaction stack and a resource . Each of these in turn have individual constituent parts or processes.

Specifically programming model can include both managed code and native code . Transaction stack can include a systems transaction API a distributed transaction coordinator DTC and a KTMRM component which communicates with a kernel mode KTM component as shown. Resource can include a number of different types of resources such as database resources MDAC resources local and remote distributed transaction coordinators HIS resources Interop with TMs RMs remote TMs TxF and TxR .

In operation when programming model wishes to coordinate with other software it utilizes systems transaction API which is a local API or framework that can be used to interact with the system. In this case API serves as a front end for the distributed transaction coordinator . So for example programming model uses this API to establish a domain for coordination of errors. API returns the name of the coordination domain which is then passed around to other entities with which programming model communicates. These other entities then communicate with distributed transaction coordinator as shown and indicate that they are doing work within this particular domain. The distributed transaction coordinator can then communicate with other resources such as database resource and the like to coordinate errors.

In the illustrated and described embodiment DTC coordinates transactions by for example creating transactions keeping track of all the resources that are part of a transaction handling voting on transactions and notififying resources of the results of voting. Transactions have transaction IDs created by the DTC . The transaction IDs uniquely identify both the individual transaction and the transaction coordinator that created it.

In the illustrated embodiment five different examples of interaction patterns with various transaction managers or coordinators are shown. In this example KTM is the transaction manager for kernel code and is used primarily in connection with files and the registry. KTM can coordinate with DTC and through DTC with other remote transaction managers i.e. local and remote DTCs HIS Interop with TMs RMs and remote TMs . KTM can allow changes to files and registry settings. The illustrated example shows both the mechanism used to communicate with other transaction coordinators i.e. Ole TX LU6.2 etc and the type of transaction coordinator with which communication takes place. Transaction coordinators use a kind of master slave strategy with the creator being the master and the other coordinators being the slaves.

Database and MDAC are examples of resources whose state changes are being coordinated by DTC . The other remote transaction coordinators deal with other resource managers. When resource managers are asked to change state in a transaction they have to make sure they present the view of that state as if the change was made to everyone who brings along the same transaction. Additionally they lock access to the state to any other entities. By doing this and then following through the change to the state good state conditions are maintained.

As an example of the life of a transaction consider the following. First a transaction is created and the creator passes the transaction to all resource managers involved. Each resource manager either fulfills the transaction promises or goes into a bad state. At the end the code that creates the transaction announces that the transaction is finished. The resource managers may then make their changes at once. If for some reason a resource manager chooses not to make their state changes there is a failure and no changes are made.

The programming models abstract this process from the programmer. The programming models handle negotiations with the transaction manager around transaction lifetime creation and completion and make transactions available to resources managers. Programming models also know when a transaction is over. If no local errors have occurred they send an appropriate vote back to the transaction manager.

In one or more embodiments the messaging services component provides a higher level message brokering service such as durability and standing queries. The messaging services component can be implemented as a hosted service that can operate in standalone mode in a clustered mode where several services communicate directly or in a distributed mode where services can run on clients on enterprise servers and or on servers hosted by a network such as the Internet. In one or more embodiments the messaging services component implements common messaging patterns such as queuing and publication subscription also referred to as pub sub and richer features like content based routing and event correlation. In the illustrated and described embodiment messaging services are accessed through the message bus s channel abstraction described above which provides both a standard API and flexibility insofar as protocols and integration is concerned. In the discussion that follows an example message node is first described in connection with . Following this an example of how message nodes can be connected together is provided to illustrate the flexibility and robust interconnectivity that the described architecture provides.

As but one example of an architecture that can be utilized to implement the functionality described just above consider . There a system includes a so called individual message node . Message node includes in this example a number of components or constituent parts. Specifically a first layer of the node includes a subscription management component a capture component and a delivery component each of which exposes a flexible set of application program interfaces APIs to implement its functionality. This layer deals primarily with processing messages coming into and going out of the node.

Specifically in this example subscription management component represents a subscription endpoint and is responsible for managing registrations for messages and other events. For example a message node may register for messages or events from one or more different applications as shown. Capture component represents a capture endpoint that is responsible for receiving messages that are given to the node. Delivery component represents a delivery endpoint that is responsible for sending or otherwise delivering messages from the message node.

A second layer of the node includes a queuing and routing layer that is responsible for queuing messages and events and routing the messages and events to the proper entities. Pub sub can also take place at this layer. Further in at least some embodiments functions such as filtering and transformation can also be implemented at this layer. Filtering involves comparing messages to a standing query and only passing them through the delivery component if they satisfy the query. Transformation involves registering a map that translates an incoming message before sending it through the delivery module. Transformation might act on a single message i.e. translate all strings into a particular format or on groups of messages e.g. someone may ask for the average of integers in messages over groups of hundreds of messages .

Further in one or more embodiments individual queues and pub sub topics can be named in terms of channel addresses. Filter and transformation channels in the channel stack can attach filters and transformations to message properties in the local stack which can then be communicated to the message service node by the message service transport channel. When a message is delivered the transport marks a flag in the message if the channel stack s filters and or transforms have been applied. The filter and or transformation channel only needs to act on the outgoing message if the transport did not.

The third or bottom layer of node includes various components that can be used to connect up with other nodes. For example a transfer component can be used to connect in a point to point manner with other nodes. Alternately or additionally transfer component can be used to connect into a rendezvous network which runs against the service bus. Further transfer component is extensible in that it can be used to connect in a variety of other manners.

In one or more embodiments the third layer includes a content based routing module that can implement content based routing. Content based routing pertains to the notion of sending content to other nodes based on the particular content as will be appreciated by the skilled artisan. This can allow for streamlined processing for large distributed queuing systems in the node. For example if a message is sent into a pub sub system and the message pertains to the weather in New York state then it is unlikely that someone in California cares about the message. Hence content based routing might then send the message to computing devices in New York state only.

In one or more embodiments the third layer includes an event correlation services component . Component can allow for a rich set of services such as retaining messages over time operating on the messages and then responsive to a particular event sending the message out. For example in one or more embodiments each message service node has an event correlation services component that can be programmed to act on message streams in certain ways while the message streams are in flight. With regard to the stream part consider the following. In one or more embodiments the event correlation services component interacts with the queues in the system and so can act on a historical series of messages as well as individual messages. The functions that the event correlation services component can apply to messages or streams of messages include transformation and filtering as mentioned above in the less specific case.

Further in one or more embodiments the event correlation services component can take a relatively straightforward abstract request e.g. measure the average response time for a message call and translate it into operations running on a distributed set of event correlation services modules. This in a sense pushes calculation upstream . For instance if the calls are happening on a large number of machines event correlation services nodes on each machine can calculate the average for calls on their own machine and then send periodic messages on downstream containing the average and the count of calls at that node. This can drastically reduce network load when compared to the less distributed alternative which involves sending in out messages for each call back downstream.

Having described the notion of a messaging node consider now various ways that messaging nodes can be connected together in connection with . There a connectivity environment is shown generally at . Environment includes a number of different connectivity paradigms in accordance with one or more embodiments. Here there are a number of hosts hosts individual ones of which are running message service nodes .

In this example starting at the upper right side of the figure host is running a message node and because the interfaces associated with this node are distributed interfaces host can use the message node system by simply sending messages directly to the node on host .

Hosts and illustrate that two nodes can be directly connected using the transfer component . Accordingly a message that might be captured on host can be inserted into the system. If the message satisfies a subscription on host the message can simply be sent to host .

Broad collaborative scenarios such as SOAP scenarios where many different people can collaborate can be supported by a connection such as the one shown between hosts and . This connection constitutes a rendezvous circle and is an example where message nodes have plugged into the service bus and have built on top of the service bus. Once plugged in when one of the nodes captures a message the node can multicast the message to all of the other nodes that are participating in that circle. Thus many different services can become connected and receive broadcast messages. This particular arrangement can very quickly route messages to members of the circle where the member nodes can receive process and if appropriate route the messages to other members in an efficient and streamlined manner.

Thus in the above examples the relationship between hosts and illustrate how on a small scale direct connections can be utilized. The circle on the other hand illustrates how message service nodes can be utilized in broader scenarios.

Hosts and illustrate other scenarios. For example host illustrates how proprietary protocols can be utilized to communicate with other pub sub systems here a BizTalk Server. Host illustrates how other interoperable protocols such as WS Interoperability protocols can be used to communicate between the message service node and some other foreign queue service that also happens to understand the interoperable protocol which service can then deliver messages to their own application in whatever form they like.

Host shows how even though the message service node has its own capture and subscribe process the node can also connect to communicate in generally standard ways such as through an RSS feed or through a REST connection.

Having now discussed the connectivity services component consider now the process services component .

In one or more embodiments process services component serves as a host that includes features that are used to run long lived stateful operations such as workflows or rule sets. The process services component includes a workflow rules runtime that can run workflows or rule sets. Thus the process services component provides an integrated collection of frameworks and services providing a runtime environment in which programs run. The runtime environment includes by way of example and not limitation activation scheduling error handling state management interfaces with the environment and the like. In one or more embodiments all programs run in runtime environments according to this definition. There is an unmanaged runtime environment in which one can run for example Win32 applications. Additionally there is a managed runtime environment in which one can run common language runtime CLR applications. In the present example the runtime environment can run code services but is tailored to run models e.g. workflows rule sets and the like .

As an example of a process services component consider which illustrates an environment in which a process services component can operate in accordance with one or more embodiments generally at . In this example environment includes a process server component a service bus described above a repository described below and instance data store .

In this example process server component is used to run applications native code or rules or workflows. That is in one or more embodiments the process server component can run declarative code e.g. graphical workflows and the like as well as imperative code e.g. C . The process server component can run stateless processes with a lifetime equal to a single invocation and it can run processes that are long lived i.e. processes that live across many invocations separated by potentially long periods of time.

The constituent parts of the process server component include by way of example and not limitation an activation service instance session correlation component a run time environment that includes a common language runtime component a rules engine that runs activities contingent on changes in state a workflow engine that allows specification of either single activities or graphs of activities that will be run by the rules engine and activity libraries that constitute pre defined or pre configured activities . The process server also includes domain specific language programs .

In operation in this example all of the messages that arrive to trigger work at the process server component arrive off of the message or service bus . The instance session correlation component examines incoming messages and decides whether they can be routed to an existing instance of the runtime and the user application module. These instances might be in memory or they might be on disk. The activation service also creates new instances of the runtime and the user program as required by the incoming message stream i.e. a new instance is created if an existing instance is not already suitable . The process server has a runtime suitable for declarative programs workflow rules managed imperative programs C VB.NET and unmanaged imperative programs C C . Additionally the process server has actual programs which may or may not be DSLs .

When a message arrives from the service bus the instance session correlation component decides whether a running runtime instance is acceptable or whether a new runtime instance is appropriate. The activation service s responsibility is to provide a new environment where appropriate that can be used to run the process for which the message has been sent. The activation service is communicatively linked with repository where all of the applications models and rules and workflows reside. When a message arrives and the activation service knows that it needs to start up a new application the application is pulled out of the repository .

In one or more embodiments processes can be very long running and because of this when messages arrive instance session correlation component processes the incoming message and attempts to associate it with a process that may be running. When it find the appropriate process component retrieves the current state of the process out of the instance data store loads the process and then runs the next part of the workflow.

Processes can be built using a rich collection of resources. Specifically processes can be built using common language runtime CLR component . Rules engine provides a workflow foundation and can be extended to run a process using only rules. Thus programs can be built using only rules. Workflow engine can be built on top of rules and on top of this activity libraries can be built sufficient to enable developers to write programs without writing any code thus providing in at least some instances a program comprising packaged components and models. The program is an executable model. The model can be represented graphically as a text language or in the repository. In the illustrated and described embodiment the CLR is the common language runtime that makes up the core of .NET. The CLR is a virtual machine and a runtime that together can execute the logical opcodes into which C and VB.NET code are compiled. Rules are condition activity pairs. Conditions are connected to data which can sometimes be fixed data and sometimes be data that is presented to the rules. The activities fire when the rule matches its data.

The relation between the CLR and this particular system is best seen when considering what constitutes an activity. Specifically an activity is either a portion of code implemented against well known instances i.e. code that is invoked when the rule is satisfied or graphs of rules activities that act as if they were a collection of code. The activity libraries are equivalent in a sense to the base class libraries that come with .NET or the libraries that come with any other software environment i.e. common libraries that one does not have to independently author.

Domain specific language DSL programs pertains to languages that are defined and utilized for particular subsets of tasks. Thus one can generate DSL programs that are made up of subsets of rules or activities that make it convenient to build certain kinds of processes. Essentially then DSLs are specific pre packaged activities and rules that are restrictions or subsets of the more general system that make it easy to build particular kinds of applications.

Having discussed the general notion of a process server component consider now how process server components can be employed in connection with . illustrates how the system of can be scaled out to multiple different machines. One of the problems addressed by the system of pertains to how to get messages to the place that happens to be managing instances currently in the context of a system in which instances can be recycled or lost due to machine failures.

There an example environment is shown generally at . In operation messages arrive off the service bus through so called ports associated with a router . Thus messages flow through the port into a router. The ports are endpoints associated with the service bus and correspond to the channel stacks described in . The router in this embodiment has a function in a distributed world that is very similar to the instance manager in . The router figures out whether an instance is already in one of the process servers or whether it is a new instance. If the message is for an existing instance the router sends the message to the process server that holds the instance. If the message is for a new instance or for an instance not currently pinned to a particular process server then the router chooses a process server and then forwards it. The instance part of the process server maps to the router.

In at least some embodiments protocols can be used to associate messages with instances of long running processes. In the illustrated and described embodiment there are a couple of ways that this can work. For example the message might contain headers for a particular instancing protocol. This makes it easy to deal with the instance location logic. If on the other hand the message does not contain instancing protocol headers then a mapping function creates the information that would be in the protocol based on information in the message that uniquely identifies the instance e.g. a purchase order for instance . It can do this by utilizing a database of identifying properties . The properties can define how the message is to be mapped to an instance through a transform in the port. Continuing messages come into the port and are then sent to the router . The router ascertains which process servers are running via process server database . In this example this is done using a table that tracks running process servers. Instance mapping database or store keeps track of instances that are associated with one of the process servers. The router ascertains which process server the message is to be routed to. This is done via an instance mapping store that maintains a mapping of process instances to process servers. The router can then route the message to the correct process server which in turn can route the message to the correct instance. For an existing instance the router ascertains where the instance is running so that it can send the message to the right process server and . If the instance is new or if the instance is not currently mapped to a process server router selects a process server from among the running process servers. Alternately or additionally the situation might be that it has been a long period of time e.g. 3 weeks since a message arrived for a particular instance. In this case the particular instance may have been placed back in instance state store . If that is the case the instant state is retrieved and pulled into the memory of an appropriate process server.

The link between the identifying properties store and instance state store is maintained to enable the identifying properties store to have a mapping of individual instances that are running.

In one or more embodiments identity services component includes in this example a directory services component and an access services component . The identity services component provides services that can be used to perform relatively complex identity manipulations.

As but one example of a directory services component consider which illustrates an example system generally at . In this example the directory services component includes what can be considered as an access layer and a directory stack . Access layer includes one or more components through which the directory stack can be exposed. In the illustrated and described embodiment these components include an API component a Messaging API MAPI component a KDC component and or a service bus component .

API component can be considered as a legacy API or a standard API which can optionally be used to access the directory stack. Here APIs of the API component are more specifically linked to the data that is available in the directory stack.

MAPI component refers to programming interfaces that are used by MAPI subsystems by client application writers and by service provider writers. The main programming interface is an object based interface known as the MAPI programming interface. Based on the OLE Component Object Model the MAPI programming interface is used by the MAPI subsystem and by messaging based client applications and service providers written in C or C as will be appreciated by the skilled artisan.

KDC component is a key distribution center that contains policies that map between identities in the directory and security keys that can be issued for a particular individual. When an individual approaches the directory they typically ask for a key. A policy is run against the individual and a key may or may not be returned depending on the policy.

Service bus component can be utilized to access the directory stack . Here the service bus component includes a set of more generalized APIs that can allow communication with a wide variety of entities. The generalized APIs provide create read update and delete functionality for data in or accessible through the directory stack.

In the illustrated and described embodiment directory stack comprises components including a directory service agent that includes a replication component a data access component and a core security module . Further the directory stack also includes a repository and a store . In this example the repository is the entity that stores data in a form that can be utilized by the platform described in this document. Hence it can be considered as serving as a store for data in a new format . Similarly store serves as a store for what can be considered as legacy data or data that resides in a legacy format. In this particular example core security module provides a security layer for store so that it presents correctly to data access component .

The directory service agent can be thought of as a general layer that all the different access APIs use to interface with the database system. This software layer understands the location of other data stores in the system. As such it uses this knowledge for data access e.g. in a case where the APIs are trying to get some information that is not available in local stores and it also uses this knowledge for replication e.g. placing data in strategic locations around the network so that it can be accessed efficiently from where it is needed . This distributed access work takes place between various directory service agents e.g. the Other DSA entity in the figure . Because this information happens to be available at this layer the domain information is also provided from the directory service agent to the DNS system to keep track of machine names IP addresses and subnets and the like.

In this example data access component is utilized to enable not only API component i.e. the legacy API to access data that it was not originally architected to access but also allow service bus component to access legacy data.

Access services through access service component provide rich support for the management and use of identities within distributed applications. In the illustrated and described embodiment the approach is centered around claims claims about entities claims about resources claims about actions undertaken by entities on resources and claims about the environments in which these actions might take place. Rules or policies can be expressed over these claims. These rules can then be evaluated in a variety of contexts as a way of doing authorization checks for resources is the entity allowed to look at the resource in the given environment or more generally as business rules has entity s manager authorized a purchase order of the given amount . These rules can be completely processed locally or they might lead to partial results that are passed to some federated processing authority for further analysis.

In one or more embodiments the access service component constitutes an extension of the system that uses the power of the process server for the purposes described above and below. To this extent the discussion that follows describes a specific application of the general architecture of .

As an example access service architecture consider which illustrates a system generally at . Here system includes repository service bus and server technology service logically interposed between the repository and the service bus. Here service includes an access policy component and a process server . The process server includes a workflow component and a rules component . Here access policy component contains relevant policies for accessing resources. Workflow component and rules component define or otherwise describe access relationships. These components run in a server to implement a server technology service that provides access to resources. Specifically in one or more embodiments the access service as implemented by the access service architecture comprises a process server running a specific program with the appropriate interfaces to plug into the architecture of .

In one or more embodiments lifecycle services component includes a repository component an integration component an executive component and an analytics component . In the illustrated and described embodiment these components work cooperatively to provide an environment in which a distributed heterogeneous application can run.

Consider first the integration component in connection with . There a system includes an integration component in the form of an integration server logically interposed between a repository a metaverse component and a plurality of data sources . One of the endeavors of the integration component is to be able reconcile data that may reside in different stores in an enterprise. To do this and as described below the integration component is able to hook into all of the different data stores that might be used across an enterprise. In addition the specific types of declarative programs running in the integration component are aimed at implementing policies used by an enterprise to deal with potential conflicts. In addition another of the endeavors of the integration component is to build a unified or single view for an application over data that resides at different locations such as different databases different LOB applications and the like. Thus in this endeavor the application defines and establishes a working view of the data identifies a mapping between the application s view and the underlying data stores and then establishes policies for reconciling changes in the data stores with changes in the application s view. These policies typically reside in application logic.

To this extent the integration server about to be described constitutes in at least some embodiments a modified form of the process server depicted in .

In this example integration server includes a synchronization policy component and a process server that includes a workflow component and a rules component .

In operation data that is to be utilized by a particular composite application can reside in many locations some of which are illustrated by data sources . Typically however programs expect to find data in one location such as on a local computing device. In the illustrated and described embodiment data can be accessed from a number of different places i.e. data sources processed through synchronization policy component to a central location referred to as the metaverse . The metaverse constitutes the view of the data that the application expects to see and synchronization policy component is responsible for processing data from the various sources and placing the data in the form that the application expects to see. Once in the appropriate form the application whose constituent parts reside in the repository can operate on the data in the metaverse .

Once the application has operated on the data in the metaverse it can be flushed back to its appropriate data source. The synchronization policy component together with its process server and associated workflow and rules components work together to ensure that data is and remains synchronized. Once the data is synchronized it can be pushed back out to its appropriate data source s . With respect to the metaverse component consider the following. In the reconciliation scenario above i.e. the first of the mentioned endeavors the metaverse constitutes a data view that is the combination of all the data in all the systems being reconciled. The reconciliation policy is usually handled in terms of the metaverse schema and the original sources. In the unified view scenario i.e. the second of the mentioned endeavors the metaverse constitutes the view that the application cares about that is a specific subset of the data in all the surrounding stores that is relevant to the specific application.

In one or more embodiments part of the program that is executed can include portions that are executed by computing devices such as the process server and portions that are executed by individual people using a so called people ready process. An example of a people ready process might be considered to be a process that a business might typically implement. In this scenario part of the people ready process might be to present a particular user interface through a user interface process that allows an individual to perform some of the work. For example if a particular process involves three steps A B C in a fully automated process A and B and C would be specified by code rules or workflow. In a people ready process perhaps B sends mail to a person asking for a copy of a report and C inserts a task into Outlook asking for a manager to read the report and approve it. illustrates an example application lifecycle services environment generally at . Here environment includes an executive component a repository an analytics component and application and a variety of authoring or development tools that feed into the repository.

Here code modules can be written using a variety of the development tools stored in a source control system for testing and ultimately published into the repository . The source control system can be used for reasons that such systems are typically used e.g. to keep track of history and revisions as well as to flow into processes that build and test systems. The development tools can provide a number of different levels of granularity at which an individual can author code modules.

When an application is to be deployed the executive component accesses the application from the repository and readies it for execution. To do this the executive component makes decisions such as the machines on which the application will run the transports that are to be used security credentials and the like. In this regard the executive implements what is known as process refinement which in this example is driven by workflows. When the executive has completed its work and all deployment parameters have been decided upon the application can run. To this extent the executive component puts the connected application through various state changes. Such state changes can include by way of example and not limitation moving from a built state to a refined state from a refined state to a deployed state and or from a deployed state to a running state. This generalizes in a sense the set of states that an application might go through. In the illustrated and described embodiment individual state changes are implemented as a workflow that does the work of causing the state change.

In operation the executive can distribute components of an application on different machines and then treat them as one logical unit. In one or more embodiments the executive component can run components in different environments e.g. IIS WAS BizTalk SQL . These environments might be on different machines but they also might be on different operating systems. The executive component is agnostic to infrastructure as compared to other technologies which are more oriented toward programming a coordinating infrastructure.

Thus the repository brings diverse sources of information together in particular the models in the repository including centrally the distributed model . The repository has adapters that let it plug into other data sources so it can provide a unified view of models to the infrastructure and to applications.

From the executive component s point of view the repository provides a unified view of the application. The executive component s task is to get that application ready to run by refining it by deploying it by turning it on and the like.

The diversity that the executive component deals with is the diversity of hosting and other infrastructure subsystems that the application needs to run in or on. To this extent the executive can be thought of as federating this diversity providing a view of a single logical host on top of all these different sorts of software infrastructure.

To avoid building knowledge of the specific kinds of infrastructure directly into the executive component the executive component has models called drivers that it uses to deal with the underlying infrastructure. The executive component acts on the distributed model by generating instructions for each bit of the infrastructure and then sending the instructions to the corresponding driver. Individual drivers implement the same interfaces so the executive component can deal with the underlying infrastructure abstractly by communicating to and with the drivers interfaces.

One can think of this as the command and control part of the executive component. If one wishes to perform tasks in a distributed model the executive component is notified. The executive component then analyzes the appropriate model and creates commands for each host and infrastructure module. It then sends those commands to the infrastructure via the drivers. So the executive allows one to think they are giving commands to the whole model and hides all the diversity in the runtime environment.

Notice now the loop between the executive component application the analytics component and the repository . One specific reason for the loop is that there is the notion of a service level agreement which defines how and when an application is to answer queries. For example the analytics component can be queried to ascertain how quickly the application is answering queries or performing some other task. If the application s performance is not desirable or does not otherwise satisfy some performance metrics then the model can be tuned in the repository so that the application can meet the performance metrics. The executive component can then update the running model to make the application more efficient. Thus dynamic feedback loops can achieve goal oriented behavior and can make sure that application end users are receiving good performance. More generally though in addition to supporting federated command and control the executive component also supports federated intelligence gathering about the application. To gather intelligence about an application an observation model can be added to the repository as part of a distributed application model. The executive component analyzes the observation model ascertains what data should be gathered at each part of the application and pushes those requests into the drivers. The drivers then perform whatever tasks are used to make their part of the system gather the appropriate data.

As the application runs it emits events in each of its parts. The events emitted by each part can typically be in different formats e.g. databases emit one sort of event web pages a second and so on. In the intelligence gathering side of the application the task of the drivers is to gather those diverse events transform the events into a generic format and insert the transformed events into the analytics component . The analytics component does processing on the events according to the observation model. For example if asked to report on average response time the analytics component would turn enter and exit events into response time events and then average them. These results would eventually be available through the repository . Thus what happens is that a set of events correlated to the application and the observation model is generated by the executive component.

The service level agreement example above constitutes a particular specific use of this system. Service level agreements are implemented as observation models to measure relevant data and event handlers that watch the event flow coming out of the analytics component and to take some action if the agreement is violated. That action might for example constitute a human process e.g. an email sent to somebody an alert generated on a portal and the like or the action might be an automated process such as re tuning the application.

In one or more embodiments integration services component can process all of this data and make it visible through the repository . In practice the repository can be implemented as a SQL application. Accordingly the API utilized to access the repository can be a SQL API. As an example of how this can all work together consider the following. Suppose an application has a web page a workflow and a database. A user might typically use an existing tool to build the web page and the database that stores those artifacts in source code control. The user would use a modeling tool to build the workflow and the distributed application model in the repository. The distributed application model points out at the web page and workflow in the source code control system. When the executive component goes to read the model the repository makes it seem like the web page and database descriptions are in the repository when in fact the descriptions reside in other stores and are bridged out to the repository via the integration services component .

In one or more embodiments executive federates hosts or containers such as SharePoint IIS WAS BizTalk and SQL Server to provide application scoped i.e. the entire application command control and monitoring for distributed applications. Among the functions that the executive performs are by way of example and not limitation translating command and control requests at the scope of the whole model into command and control requests on the containers in which parts of the distributed model will run. In the illustrated and described embodiment this translation is driven by workflows implementing customizable business processes. In addition the executive translates observation models specified at the scope of the whole models into requests that individual containers generate specific sorts of events. As those events are generated in the containers the executive translates them back into a standard format and sends them via the service bus to a performant store exposed as part of the repository . The executive supports changes to some of the configuration of parameters of running models in real time so that applications can be tuned and observation models can be changed without restarting the underlying applications. By supporting the ability to apply verbs like Deploy and Run to models and by aggregating observed information about the models the executive federates existing containers and provides the experience of distributed models running on a single system.

Turning more specifically to the illustration repository holds applications and policy assertions which are the rules that the application follows. The repository also includes all of the resources that are associated with an application e.g. this particular application can run on these particular eight computers four SQL servers and two web servers. These applications resources and other repository data can be accessed in a number of different ways. For example access can occur through a portal through a management console MMC or through Quadrant or some other modeling tool targeted directly at the repository . Accordingly the executive is the entity that accesses applications from the repository and refines deploys starts stops versions and performs other functions with respect to the applications.

In operation the executive is made up of a number of different services each of which can run of different machines. In this particular example the deployed application model may be a Sharepoint application with a process administered by a process server and a SQL database as illustrated. The executive typically takes the application model and performs some refinements such as ascertaining which particular SQL and process servers are going to be used and the like. After ascertaining which particular servers or services are to be used the executive knows which drivers to use for deployment and can then deploy the model. The executive s driver management functionality provides the executive with the ability to deal with all of the different places that an application may run e.g. Sharepoint SQL COM SQL Windows Shell and the like.

Thus an application resides in the repository and is built from conceivably many different component modules. The executive understands these modules acquires the modules or knowledge of the module and deploys the module out to the location where the modules are to run.

These component modules can then use the service bus for two different purposes. First the component modules can communicate with one another using the service bus. In addition the component modules can acquire relevant event data and use the service bus to provide the event data back into the repository via an analytics component such as the one in . This enables an observation model to be employed in connection with the application. The observation model provides instructions to the application modules running in the hosts telling them which events should be generated. The observation model also instructs the analytics component on how to post process the events so that they answer the observation requirements of the observation model. Thus the observation model selectively gathers information about an application that can be used to conduct analysis that pertains to that application s execution. Such information can be used to refine the application or to make changes on the fly that improve the application s execution. Such information is more generally useful for such things as logging governance monitoring and the like.

Specifically here analytics component is configured to read event data i.e. event instances from the repository and act on the event data in some way. Recall that the event data was previously developed and provided into the repository via the service bus.

In operation analytics component can process the event data in any suitable way. For example the analytics component can run statistical analysis on the events in order to answer questions about an application s performance. In addition users can access the data developed by the analytics component via a portal which provides a user interface that describes how a particular application is operating.

In addition the analytics component can also be configured to read key performance indicators KPIs and service level agreements SLAs and use those in its analysis of an application s performance. Such can then be used to improve application performance by for example reconfiguring the application or one of its components and redeploying the application.

In one or more embodiments tools component includes a various tools examples of which include a code based tool such as visual studio component a model based tool such as a quadrant component and an enterprise management tool such as system center component .

In one or more embodiments there are a number of different models that can be utilized and each can be tightly related. Specifically applications are built of models and code artifacts and managed in the larger context of an enterprise management tool. The code based tools such as Visual Studio support the creation testing and updating of code artifacts. The model based tools such as Quadrant support the creation testing and updating of models. The model based tools are aware of the relationships amongst models and the relationships between models and code artifacts because those relationships are described in the models.

Fundamentally the model based tool provides a generic editing experience that allows one to see all models through views that make certain qualities of the models apparent box and line form table and so on . The user can customize this generic editing experience and store the customized view and then recall it when dealing with similar data in the future. Developers can build new editors customized for particular models. These might provide custom editing experiences or these might provide features specific to certain models for instance being able debug workflows in the workflow editor .

The repository contains both the schema for models and instances of models. Because model schemas are just models and because the repository has a schema various model based tools can be used to generate new models as well as instances of existing models.

Computing device includes one or more processors or processing units one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

One or more input output devices allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Embodiments provide an architecture to enable composite autonomous applications and services to be built and deployed. In addition an infrastructure is provided to enable communication between and amongst distributed applications and services.

In one or more embodiments an example architecture includes or otherwise leverages five logical modules including connectivity services process services identity services lifecycle services and tools.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

