---

title: Systems and methods for pagination and co-pagination
abstract: Methods and systems are provided for controlling pagination in computer software applications. Abstract classes and methods are provided with programming interfaces to improve the ease with which developers can create applications that allow for co-pagination with arbitrary object types, and can create arbitrary object types that can co-paginate with arbitrary applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08145996&OS=08145996&RS=08145996
owner: Microsoft Corporation
number: 08145996
owner_city: Redmond
owner_country: US
publication_date: 20080630
---
This patent application is a divisional of U.S. patent application Ser. No. 10 692 111 entitled SYSTEMS AND METHODS FOR PAGINATION AND CO PAGINATION filed on Oct. 23 2003 and assigned to the same assignee as this application. The aforementioned patent application is expressly incorporated herein by reference.

This invention pertains generally to the fields of computer software development and view layout and more particularly to the management of pagination within software applications.

A feature of many modern computer software applications is the ability to determine break points for the presentation of output. Existing applications that support printing such as MICROSOFT WORD 2000 by the MICROSOFT CORPORATION of Redmond Wash. for example include pagination routines for determining where page breaks should occur. Pagination is the process by which more than one page worth of data is broken up into portions that will each fit on a single page. The techniques of pagination are similarly employed when displaying output to a monitor or other types of output devices particularly when the output device is limited to displaying a fixed finite amount of output at a given time or when multiple views are presented simultaneously such as a 2 column view of text.

Many modern computer software applications further have the ability to embed different types of objects within each other. For example in MICROSOFT WORD 2000 a user may embed a graphical table graphical drawing or other graphical object within the context of a word processing document. When documents containing embedded graphical objects are paginated problems may arise if a page break falls across an embedded graphical object. The embedded objects may not be co paginated. That is unless pagination has been specifically defined for the embedded graphical object s type in the context of the particular application the embedded graphical object will either not be allowed to break across the page or will exhibit unpredictable results. Although some existing applications contemplate embedding and pagination for particular object types such as MICROSOFT WORD allowing embedded tables to break across pages there does not exist a general extensible way in which an application can allow co pagination with arbitrary object types.

Embodiments of the present invention provide methods and systems for management of pagination within software applications.

In accordance with one aspect of the invention a system is provided for controlling pagination of a presentable object in a computer application the system comprising a set of user definable classes for representing pages on which the presentable object is paginated and a set of user definable methods utilizing the user definable classes to paginate the object.

In some embodiments the set of user definable classes comprises a first class for representing display information of a page a second class for representing descriptive information of a page a third class for representing page break information and a fourth class for representing positional information of content.

In some embodiments the set of user definable methods comprises a method for measuring the object for pagination and a method for arranging paginated pages of the object for display.

In some embodiments the set of user definable methods further comprises a method for updating the pagination of an object.

In some embodiments the set of user definable methods further comprises a method for calculating page break positions for an object to be paginated.

In some embodiments the set of user definable methods further comprises a method for setting a host of the object.

In accordance with another aspect of the invention a system is provided for hosting a paginating control for an object in a computer application the system comprising a set of user definable classes for representing pages on which the object is paginated and a set of user definable methods utilizing the user definable classes to interact with the paginating control.

In some embodiments the set of user definable classes comprises a first class for representing display information of a page a second class for representing descriptive information of a page a third class for representing page break information and a fourth class for representing positional information of content.

In some embodiments the set of user definable methods comprises a first method for receiving notification that content in the object has changed.

In some embodiments the first method includes a start position and an end position between which content in the object has changed.

In some embodiments the set of user definable methods further comprises a method for receiving notification that content in the object requires a different page size.

In accordance with another aspect of the invention a system is provided for controlling pagination of and hosting paginating controls for objects in a computer application the system comprising a set of user definable classes for representing pages on which objects are paginated a set of user definable methods utilizing the user definable classes to paginate objects and a set of user definable methods utilizing the user definable classes to interact with paginating controls.

In some embodiments the set of user definable classes comprises a first class for representing display information of a page a second class for representing descriptive information of a page a third class for representing page break information and a fourth class for representing positional information of content.

In accordance with another aspect of the invention a method is provided for formatting a page for presentation in a computer system the method comprising receiving a size parameter receiving a page descriptor parameter and causing a page measuring function to provide a formatted page using the size parameter and page descriptor parameter. In some embodiments the page descriptor parameter comprises page break information.

In accordance with another aspect of the invention a method is provided for arranging a page for presentation in a computer system the method comprising receiving a page parameter receiving a size parameter and causing a page arranging function to arrange the page for presentation using the page parameter and the size parameter.

In accordance with another aspect of the invention a method is provided for calculating page break information for a page in a computer system the method comprising receiving a size parameter receiving a page descriptor parameter and causing a page break calculating function to provide a page break information parameter using the size parameter and page descriptor parameter.

In accordance with another aspect of the invention a method is provided for notifying that a page requires formatting for presentation in a computer system the method comprising receiving a child element parameter representing the page and causing a notification function to notify a host element of the child element s need to be formatted using the child element parameter. In some embodiments the method further comprises receiving a start position parameter and receiving an end position parameter.

The methods and systems to improve the ease with which developers can create applications that allow for co pagination with arbitrary object types and can create arbitrary object types that can co paginate with arbitrary applications will now be described with respect to preferred embodiments however the methods and systems of the present invention are not limited to software development tools and computer operating systems. Moreover the skilled artisan will readily appreciate that the methods and systems described herein are merely exemplary and that variations can be made without departing from the spirit and scope of the invention.

The present invention will be more completely understood through the following detailed description which should be read in conjunction with the attached drawings. In this description like numbers refer to similar elements within various embodiments of the present invention. The invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as procedures being executed by a personal computer. Generally procedures include program modules routines functions programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices. The term computer system may be used to refer to a system of computers such as may be found in a distributed computing environment.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers hereto illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. For example in the present invention the computer may comprise the source machine from which data is being migrated and the remote computer may comprise the destination machine. Note however that source and destination machines need not be connected by a network or any other means but instead data may be migrated via any media capable of being written by the source platform and read by the destination platform or platforms.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Pagination is not limited to text however. illustrates an instance of pagination with multiple types of embedded objects in accordance with an embodiment of the invention. The objects to be displayed and paginated are logically represented in a tree . Objects may be called parents and children according to their natural hierarchical relation to other elements. The root of the tree represents the top level object for example a document . Node represents a block of text . Node represents a table embedded in the document . The rows are represented by nodes and in the tree . The third row represented by node contains three cells and represented by nodes and . The first cell represented by node is empty. The second cell represented by node contains a graphic image . The third cell represented by node contains a block of text . If the output device is of a fixed size that is smaller than the content to be displayed then the document must be broken into pages each page capable of being displayed by the output device. One possible pagination of the document breaks into two pages page 0 and page 1 . In this example the page breaks across the document the table the third row cells and the image in the second cell and the text in the third cell . This particular result may not be desirable for numerous reasons. It may be desirable for the table to appear fully on one page. It may be desirable for the third row to appear fully on one page. It may be desirable for a particular cell to appear fully on one page. It may be desirable for the contents of a cell such as the image to appear fully on one page.

In accordance with an embodiment of the invention specified abstract classes and interfaces of methods allow developers to define pagination rules for objects. The classes and methods allow an object to be a paginating control element or a host control element. A paginating control element uses the classes and methods to determine how it should break across pages in the context of its host. A host control element uses the classes and methods to provide a context in which paginating control elements exist such as when display objects are embedded within other display objects. The host control element further uses the classes and methods to allow its pages to be rendered to an output device. The host control element further uses the classes and methods to manage the pagination process. In this way the abstract classes and interfaces provided in an embodiment of the invention are divorced from the type of content that flows across pages.

The general architecture for the pagination portion of a presentation system in an embodiment of the invention is shown in . Object is a paginating control element and thus has access to various page management methods via an IDocumentFormatter interface . A more detailed discussion of these methods appears below. Object is hosted by a host control element . The host control element has access to various page management methods via an IDocumentContentHost interface which are discussed in more detail below. Host control element interacts with paginating control element to manage pagination for paginating control element . Host control element further interacts with the operating system to render pages to an output device . In this example object also includes a host control element . Object therefore has access to the various page management methods via an IDocumentContentHost interface and can host other paginating control elements.

In an embodiment of the invention a PageDescriptor class provides input information required to format a page. The PageDescriptor class comprises two members a PageSize property and BreakRecordIn . The PageSize member represents the size of the page. The BreakRecordIn is the BreakRecordOut of the previous page which is used to continue page formatting. For the first page of the document BreakRecordIn is NULL. In an embodiment of the invention the PageDescriptor class is a sealed class.

In an embodiment of the invention a BreakRecord class stores information about where pages break during pagination. Each type of paginating control element provides its own customized BreakRecord class. The customized BreakRecord classes are derived from the general BreakRecord class . For example a TableBreakRecord class RowBreakRecord class and CellBreakRecord class are used in paginating table objects such as table in . A TableBreakRecord contains an array of RowBreakRecords a RowBreakRecord contains an array of CellBreakRecords etc. In this way a single BreakRecord potentially contains other BreakRecords internally. The general BreakRecord class comprises two members a BreakPosition property and an IsInvalid function . The BreakPosition represents where a page breaks. More specifically the BreakPosition indicates where the previous page ends. For example if a text document contains 100 characters and 60 characters are placed on the first page while 40 characters are placed on the second page then the BreakPosition for the second page equals 60. If 30 characters are placed on the first page 40 on the second page and 30 on the third page then the BreakPosition for the third page equals 70. The IsInvalid function is used in conjunction with a host control element to determine if a page is invalid for a content change. A host control element calls IsInvalid for a BreakRecord passing in start and end positions of a content change. If the content change affects the BreakRecord IsInvalid returns TRUE. Otherwise it returns FALSE.

In an embodiment of the invention a ContentPosition class specifies positions within a given content type. Each type of paginating control element provides its own content position class based on the ContentPosition class specific to its content. For example in a text element a ContentPosition object represents a character position. In a JPEG image ContentPosition represents a scanline. In a table ContentPosition represents a row. Other representations for ContentPosition are possible due to the abstraction of the ContentPosition class . The ContentPosition class comprises one member an IsComparableTo function . The IsComparableTo function is used to determine if two ContentPositions may be compared via equal greater than less than or other comparing functions. For example if ContentPosition is defined in one paginating control element as a scanline of a JPEG while another ContentPosition is defined in another paginating control element as a number of characters then these two ContentPositions are not comparable and the IsComparableTo function returns FALSE. If the two types of ContentPositions are comparable the IsComparableTo function returns TRUE.

The IDocumentFormatter interface is now described with respect to in accordance with an embodiment of the invention. The IDocumentFormatter interface is implemented by paginating control elements to support pagination and other document features such as footnotes. The IDocumentFormatter interface comprises five methods a MeasurePage method an ArrangePage method an UpdatePage method a CalculateBreakRecord method and a SetDocumentContentHost method . The methods of the IDocumentFormatter interface are described with greater detail below.

The IDocumentContentHost interface is now described with respect to in accordance with an embodiment of the invention. The IDocumentContentHost interface is implemented by host control elements to allow the hosting of paginating control elements that use the IDocumentFormatter interface . The IDocumentContentHost interface comprises three methods a first OnContentChanged method a second OnContentChanged method and an OnPageSizeMismatch method . The methods of the IDocumentContentHost interface are described with greater detail below.

Turning to the methods associated with the IDocumentFormatter interface are now described in accordance with an embodiment of the invention. The MeasurePage method is shown as a flow diagram in . MeasurePage is called by a parent element to create and format a new document page. It takes two inputs a constraint and a pageDescriptor. The constraint is the size of the parent s current page available for content. pageDescriptor is a PageDescriptor containing current pagination information. pageDescriptor contains a pageSize and a breakrecordIn. The pageSize of pageDescriptor represents the size of the page to be created e.g. 8.5 by 11 inches 640 by 480 pixels etc. . MeasurePage creates and formats a new page of the DocumentPage class which is returned to the caller of the MeasurePage method . The code of the MeasurePage method is written by developers of paginating control elements to be used in paginating those control elements.

The ArrangePage method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The ArrangePage method is used to arrange the content of a page. ArrangePage assumes the page measurements are valid. ArrangePage takes as input a DocumentPage and an arrangeSize which represents the final size computed size of the DocumentPage. It then arranges the content of the DocumentPage subject to the arrangeSize and exits. The code of the ArrangePage method is written by developers of paginating control elements to be used in paginating those control elements.

The UpdatePage method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The UpdatePage method is used to incrementally update the layout of content within an existing page. It takes as input a DocumentPage a size constraint and a pageDescriptor. The UpdatePage method performs a re layout for that page and exits. This potentially results in a new BreakRecord calculated for the page that was just updated. The code of the UpdatePage method is written by developers of paginating control elements to be used in paginating those control elements.

The CalculateBreakRecord method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The CalculateBreakRecord method is used to calculate page breaks in a document without performing the full preparations necessary to display the pages. The CalculateBreakRecord method is used for example in scenarios when only the total number of pages and break records of individual pages are required such as background calculation of all pages. Because no renderable entities are used in CalculateBreakRecord there is potentially large computational savings by using the CalculateBreakRecord method instead of the MeasurePage method . The CalculateBreakRecord method takes as input a size constraint and a pageDescriptor. The CalculateBreakRecord method computes a break record for the pageDescriptor subject to the size constraint. The break record is then returned to the caller of the CalculateBreakRecord method . The code of the CalculateBreakRecord method is written by developers of paginating control elements to be used in paginating those control elements.

The SetDocumentContentHost method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The SetDocumentContentHost method is used to set the host control element for a paginating control element. The host control element is typically the direct parent of the paginating control element. The host control element has implemented the IDocumentContentHost interface . By using the SetDocumentContentHost method a paginating control element enables communication with its host regarding content changes and page size mismatches via methods associated with the IDocumentContentHost interface described below. The SetDocumentContentHost method takes as input a host control element and sets this host control element as the host for the calling paginating control element. The code of the SetDocumentContentHost method is written by developers of paginating control elements to be used in paginating those control elements.

Turning to the methods associated with the IDocumentContentHost interface are now described in accordance with an embodiment of the invention. The first OnContentChanged method is shown as a flow diagram in . The first OnContentChanged method is called by a child paginating control element on a host control element to notify the host control element that content has changed and that the host needs to reformat at least part of its content to reflect changes on the child. The first OnContentChanged method takes as input a paginating control child element a start position and an end position. The first OnContentChanged method notifies the parent host that the child s content has changed between the start and end positions. An embodiment of the invention keeps an array of break records and on receiving a change notification via the first OnContentChanged method finds the affected break records and repaginates the corresponding pages via MeasurePage or UpdatePage methods. The code of the first OnContentChanged method is written by developers of host control elements to be used in managing the pagination of paginating control elements.

The second OnContentChanged method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The second OnContentChanged method is called by a child paginating control element on a host control element to notify the host control element that content has changed and that the host needs to reformat all of its content to reflect changes on the child. The second OnContentChanged method takes as input a paginating control child element. The second OnContentChanged method notifies the parent host that the child s content has changed. An embodiment of the invention assumes the entire child needs pagination and arranges all pages associated with the child. The code of the second OnContentChanged method is written by developers of host control elements to be used in managing the pagination of paginating control elements.

The OnPageSizeMismatch method shown as a flow diagram in is now described in accordance with an embodiment of the invention. The OnPageSizeMismatch method is called by a child paginating control element on a host control element when content with an explicit page size requirement is not matching the current page size in PageDescriptor. The child requires a new page size. The OnPageSizeMismatch method takes as input a paginating control child element and a pageSize. The OnPageSizeMismatch method notifies the parent host that the child s page size requirement does not match the current page size. The code of the OnPageSizeMismatch method is written by developers of host control elements to be used in managing the pagination of paginating control elements.

A programming interface or more simply interface may be viewed as any mechanism process protocol for enabling one or more segment s of code to communicate with or access the functionality provided by one or more other segment s of code. Alternatively a programming interface may be viewed as one or more mechanism s method s function call s module s object s etc. of a component of a system capable of communicative coupling to one or more mechanism s method s function call s module s etc. of other component s . The term segment of code in the preceding sentence is intended to include one or more instructions or lines of code and includes e.g. code modules objects subroutines functions and so on regardless of the terminology applied or whether the code segments are separately compiled or whether the code segments are provided as source intermediate or object code whether the code segments are utilized in a runtime system or process or whether they are located on the same or different machines or distributed across multiple machines or whether the functionality represented by the segments of code are implemented wholly in software wholly in hardware or a combination of hardware and software.

Notionally a programming interface may be viewed generically as shown in FIG. A or FIG. A. FIG. A illustrates an interface Interface as a conduit through which first and second code segments communicate. FIG. A illustrates an interface as comprising interface objects I and I which may or may not be part of the first and second code segments which enable first and second code segments of a system to communicate via medium M. In the view of FIG. A one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although FIGS. A and A show bi directional flow and interfaces on each side of the flow certain implementations may only have information flow in one direction or no information flow as described below or may only have an interface object on one side. By way of example and not limitation terms such as application programming interface API entry point method function subroutine remote procedure call and component object model COM interface are encompassed within the definition of programming interface.

Aspects of such a programming interface may include the method whereby the first code segment transmits information where information is used in its broadest sense and includes data commands requests etc. to the second code segment the method whereby the second code segment receives the information and the structure sequence syntax organization schema timing and content of the information. In this regard the underlying transport medium itself may be unimportant to the operation of the interface whether the medium be wired or wireless or a combination of both as long as the information is transported in the manner defined by the interface. In certain situations information may not be passed in one or both directions in the conventional sense as the information transfer may be either via another mechanism e.g. information placed in a buffer file etc. separate from information flow between the code segments or non existent as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation e.g. depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration and so this list should be considered illustrative and non limiting.

This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are however other ways to implement a programming interface and unless expressly excluded these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of FIGS. A and A but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in FIGS. B and B. As shown some interfaces can be described in terms of divisible sets of functionality. Thus the interface functionality of FIGS. A and A may be factored to achieve the same result just as one may mathematically provide 24 or 2 times 2 time 3 times 2. Accordingly as illustrated in FIG. B the function provided by interface Interface may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA Interface B Interface C etc. while achieving the same result. As illustrated in FIG. B the function provided by interface I may be subdivided into multiple interfaces I I I etc. while achieving the same result. Similarly interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces etc. When factoring the number of interfaces included with the 1code segment need not match the number of interfaces included with the 2code segment. In either of the cases of FIGS. B and B the functional spirit of interfaces Interface and I remain the same as with FIGS. A and A respectively. The factoring of interfaces may also follow associative commutative and other mathematical properties such that the factoring may be difficult to recognize. For instance ordering of operations may be unimportant and consequently a function carried out by an interface may be carried out well in advance of reaching the interface by another piece of code or interface or performed by a separate component of the system. Moreover one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.

In some cases it may be possible to ignore add or redefine certain aspects e.g. parameters of a programming interface while still accomplishing the intended result. This is illustrated in FIGS. C and C. For example assume interface Interface of FIG. A includes a function call Square input precision output a call that includes three parameters input precision and output and which is issued from the 1Code Segment to the 2Code Segment. If the middle parameter precision is of no concern in a given scenario as shown in FIG. C it could just as well be ignored or even replaced with a meaningless in this situation parameter. One may also add an additional parameter of no concern. In either event the functionality of square can be achieved so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system however once it is recognized that precision is not necessary for the narrow purpose of calculating the square it may be replaced or ignored. For example instead of passing a valid precision value a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly as shown in FIG. C interface I is replaced by interface I redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I redefined to ignore unnecessary parameters or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects such as parameters that are not needed for some purpose and so they may be ignored or redefined or processed elsewhere for other purposes.

It may also be feasible to merge some or all of the functionality of two separate code modules such that the interface between them changes form. For example the functionality of FIGS. A and A may be converted to the functionality of FIGS. D and D respectively. In FIG. D the previous 1and 2Code Segments of FIG. A are merged into a module containing both of them. In this case the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus for example formal Call and Return statements may no longer be necessary but similar processing or response s pursuant to interface Interface may still be in effect. Similarly shown in FIG. D part or all of interface I from FIG. A may be written inline into interface I to form interface I . As illustrated interface I is divided into Iand I and interface portion Ihas been coded in line with interface I to form interface I . For a concrete example consider that the interface I from FIG. A performs a function call square input output which is received by interface I which after processing the value passed with input to square it by the second code segment passes back the squared result with output. In such a case the processing performed by the second code segment squaring input can be performed by the first code segment without a call to the interface.

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in FIGS. E and E. As shown in FIG. E one or more piece s of middleware Divorce Interface s since they divorce functionality and or interface functions from the original interface are provided to convert the communications on the first interface Interface to conform them to a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. This might be done e.g. where there is an installed base of applications designed to communicate with say an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. The point is that the original interface used by the 2Code Segment is changed such that it is no longer compatible with the interface used by the 1Code Segment and so an intermediary is used to make the old and new interfaces compatible. Similarly as shown in FIG. E a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to for example interfaces Iand I redesigned to work with DI but to provide the same functional result. Similarly DI and DI may work together to translate the functionality of interfaces I and I of FIG. A to a new operating system while providing the same or similar functional result.

Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example there may be a system in which a code segment presented in an intermediate language e.g. Microsoft IL Java ByteCode etc. is provided to a Just in Time JIT compiler or interpreter in an execution environment such as that provided by the .Net framework the Java runtime environment or other similar runtime type environments . The JIT compiler may be written so as to dynamically convert the communications from the 1Code Segment to the 2Code Segment i.e. to conform them to a different interface as may be required by the 2Code Segment either the original or a different 2Code Segment . This is depicted in FIGS. F and F. As can be seen in FIG. F this approach is similar to the Divorce scenario described above. It might be done e.g. where an installed base of applications are designed to communicate with an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed base applications to the new interface of the operating system. As depicted in FIG. F this approach of dynamically rewriting the interface s may be applied to dynamically factor or otherwise alter the interface s as well.

It is also noted that the above described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways serially and or in parallel or with other intervening code. Thus the alternative embodiments presented above are not mutually exclusive and may be mixed matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in FIGS. A and A. It is also noted that as with most programming constructs there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein but nonetheless are represented by the spirit and scope of the invention i.e. it is noted that it is at least partly the functionality represented by and the advantageous results enabled by an interface that underlie the value of an interface.

In view of the many possible embodiments to which the principles of the present invention may be applied it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of the invention. For example those of skill in the art will recognize that the illustrated embodiments can be modified in arrangement and detail without departing from the spirit of the invention. Although the invention is described in terms of software modules or components those skilled in the art will recognize that such may be equivalently replaced by hardware components. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

