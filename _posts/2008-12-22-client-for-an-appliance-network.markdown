---

title: Client for an appliance network
abstract: A client having at least one memory location is provided for use with an appliance network. The client includes an arbitrary software component for performing a useful function, a software architecture or a software architecture driver configured to generate or enable transmission of messages, and means to communicate by message over a network. Thus, the client can have full capability to act as an accessory to an appliance to communicate with and to enhance or alter the operation of the appliance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09264252&OS=09264252&RS=09264252
owner: Whirlpool Corporation
number: 09264252
owner_city: Benton Harbor
owner_country: US
publication_date: 20081222
---
This application is a continuation of U.S. patent application Ser. No. 11 953 595 filed Dec. 10 2007 which is a continuation in part of International Application No. PCT US2006 022420 filed Jun. 8 2006 and International Application No. PCT US2006 022503 filed Jun. 9 2006 both of which claim the benefit of U.S. Provisional Patent Application No. 60 595 148 filed Jun. 9 2005 all of which are incorporated in their entireties by reference.

Household appliances are typically comprised of one or more components which cause the electromechanical electrothermal and electrochemical operations of the appliance. For example an oven may include an appliance management component having a printed circuit board PCB with memory thereon as well as a user interface component such as a control panel or keypad for a user to issue commands to the oven appliance. The basic appliance models typically are difficult to design develop test diagnose control and debug due to the diversity of componentry and the associated diversity of implementation choices. This diversity is an impediment to creating interoperable reusable value added componentry.

It has become known in recent years to interlink the components of an appliance by an internal communications network capable of sending and receiving control messages for controlling the interaction between the internal components of an appliance as opposed to the use of a plurality of discrete circuits with each discrete circuit responsible for an individual communication between related components and implemented by hard wiring ribbon cables or other connectors or harnesses between the components. This internal network affords some degree of universality in connecting the components internal to the appliance however each component typically needs to be enabled with software within its microprocessor and the adjacent hardware circuitry to achieve network participation. One example of this internal network used within a household appliance is the WIDE network protocol created by Whirlpool Inc. the assignee of this document.

According to the invention a client having at least one memory location is provided for use with an appliance network. The client includes an arbitrary software component for performing a useful function a software architecture or a software architecture driver configured to generate or enable transmission of messages and means to communicate by message over a network. Thus the client can have full capability to act as an accessory to an appliance to communicate with and to enhance or alter the operation of the appliance. The client can be a physical device.

In one aspect the client can include one or more identifiers residing in one or more memory locations. Preferably the identifier will be one of a class identifier a sub class identifier at least one instance ID a model number and a serial number of the appliance or components of the appliance a functional identifier identifier of a method identifiers of objects identifiers of class attributes network identifiers a unique numeric addressing identifier a unique numeric functional identifier and an API ID that can serve as a portion of a unique numeric addressing identifier.

In another aspect the identifier includes one or more class identifiers and one or more instance identifiers where the instance identifiers are cached and indexed to a class identifier. In another aspect the identifier is an identifier of function or an identifier of another client node on a network. Preferably an arbitrary software component the software architecture or the software architecture driver develops references to the identifier of a different node on a network so that the client can communicate with the different node by message using the references.

The client can include a display for communication with a user. The client can also include a control command for communication by message that can affect a cycle of operation of a networked appliance. In one aspect the control command is configured to create objects or instances of classes in a networked appliance. In another aspect the control command is configured to change values in a first objects field to a third object from a second object in an appliance control system of a networked appliance. In another aspect the control command is configured to place a networked appliance into one of two or more operating modes.

The client can be configured to query a network for information such as the identity of another node on a network an appliance a client an arbitrary software component a device comprising a node a coupler one or more of a plurality of identifiable software elements on any node or the functional identifiers thereof. In one aspect the query can be a propagated message. In another aspect at least one identifier can be received in response to a query.

The arbitrary software component of the client can be one of a clock and time synchronization accessory a stirring and ingredient addition accessory a cooking sensor accessory an operation cycles accessory a consumable messaging and reader accessory a recipe book a recipe wand a laundry credit accessory a smart dimmer and adapter a network binder accessory a remote user interface a smart coupler a resource communication accessory a cellular telephone accessory a configuration mechanism an audio communication accessory and a remote audio communication accessory.

The software architecture or software architecture driver can be configured to communicate a password. The client can also include identification information in order for the client to establish useful communications with other communicating nodes without the arbitrary software component having knowledge of routing information otherwise required to enable the useful communication.

The software architecture or software architecture driver can be configured to collect data associated with a node synchronously for a complete snapshot of updates to the state of the node for one scan of a processor so that meaningful dynamic and virtual data aggregation can occur regardless of changing states of the node. As well the software architecture or software architecture driver can be configured to send a plurality of commands to a second node by a message protocol enabled by the one of a software architecture and a software architecture driver wherein multiple messages are used to convey elements of a command bounded together synchronously whereby the receiving node will know when to begin executing the command.

In one aspect the arbitrary software component is configured to send configuration messages over a network to create an event structure in a memory heap. In another aspect the arbitrary software component is further configured to classify the event structure as acknowledged or unacknowledged. In another aspect the arbitrary software component is configured to invoke a function of a second arbitrary software component utilizing encapsulated routing information where the invocation does not contain routing information. The arbitrary software component can be configured to listen to a heartbeat of a networked appliance.

The client can include a source of information about a resource used by an appliance of the type configured to perform an operation on a physical article where the appliance consumes at least some of a resource in performing the operation. The source will typically include a request to change the operation of an appliance in response to a resource parameter or a request for the status of a resource used by the appliance.

The client can include an embedded virtual router in which case the arbitrary software component is configured to collaborate with another software component by a method of access or exposure to each other. Here the embedded virtual router encapsulates the method so that the collaboration can be uniform and identical whether the collaboration is over a network or sharing a runtime environment.

A brief overview of the invention should be helpful before examining the multiple aspects of the invention. The invention relates to a software architecture SA that is implemented on and communicates over an internal communications network on an appliance which connects the various physical components of the appliance.

Some of the physical components have a corresponding controller main controller motor controller user interface etc. which may be a simple microprocessor mounted on a printed circuit board. Other components have no controller. Typically the components that have controllers and if there are more than one are typically also network enabled cooperate through network messaging or other forms of data transmission to directly or indirectly through other components control the operation of all of the components and their contained or attached devices to implement an operation or cycle for the appliance.

The SA can but does not have to reside on each of the components with a controller. Those components with the SA or a variant of the SA compliant with the SA compliance determined by the ability to send receive and process packets form a node on the network that can communicate with the other nodes.

The SA performs multiple functions identifying each of the components corresponding to a node to the network identifying the capabilities or functions of the identified components to the network identifying the status of the components to the network providing well defined command interfaces for each component providing communication between internal and external software components that are not part of the SA and providing communication between components non SA software components on different physical components. In this way the SA functions to inform all of the nodes on the network of the presence capabilities and status of the other nodes.

The SA comprises multiple modules each of which has different functionality. Various combinations of the modules or all of the modules can reside on each of the components. One module having the basic or core functionality for the invention resides on all of the components. In one anticipated configuration all of the modules reside at least on the main controller which establishes the main controller to function as a primary or controller SA with the other nodes functioning in a client relationship to the controller SA. In such a configuration all of the nodes would communicate through the controller SA.

The SA is sufficiently robust that it can permit configurations without a controller SA or with multiple controller SAs. Regardless of the configuration any component with a residing SA can function as a client with respect to the other components.

The internal communications can be connected to one or more external components directly or through an external network. The external components would also have one some or all of the SA modules in resident.

Beginning with the specifics of the invention will now be described. is a schematic illustrating one environment of a software architecture embodying the systems and methods described herein and those which would be apparent to one skilled in the art in the form of a household appliance having an internal communication network interconnecting a plurality of components which can be internal clients when they include at least a portion of the SA or can otherwise exchange messages across the network wherein the software architecture resides on at least one component to enable the component and preferably each additional component has the software architecture in resident or an alternate able to be interoperable with. The household appliance also has an internal external communications connection shown interconnected to various network interface devices for communication with various embodiments of an external client .

The external clients will typically comprise computing hardware and software and networking hardware and software able to interact with the software architecture . This may be achieved by including all or a portion of the software architecture within the embodiment of the external client or an alternative to the software architecture which is able to communicate and fully or partially interact with the software architecture . A number of alternate components C dll Visual Basic Driver Java Driver and Active X driver able to fully interact with the software architecture have been implemented.

In connection with the text of this patent application and in review of the drawings accompanying the text of this application it will be understood that the abbreviation SA refers to software architecture as described by reference numeral in this application.

Further the term client is used to refer a component on which all or a portion of the SA resides and which fully or partially enables the functionality of the component. The component can be either an internal or external component. While client will primarily be used to describe a component enabled by the SA client is also used to describe a component that is enabled by an alternate software that is able to successfully exchange messages on internal communication network and communicate with the SA. Generally the term client is used when referring to the software aspects and not the hardware aspects of the node.

The components can comprise one or more devices. Thus the term device as used in the application can refer to a component or to a device. The devices can be any electronic electro thermal and electromechanical elements which collectively form the component or which are attached to a component with a controller via electrical circuitry e.g. wiring harness a physical part which can execute logic and a physical part which has memory.

As described herein the appliance can be any of the well known variety of appliances which would be well known to one skilled in the art. For example the appliance can be a washer a dryer a microwave a dishwasher a refrigerator a refrigerator freezer combination a stand alone freezer a warming drawer a refrigerated drawer an oven a combination cooktop and oven a cooktop and the like. While the described environment of the invention is that of an appliance the invention has applicability to any type of machine having networked components.

As described herein the internal communication network can be any well known interconnecting conduit wiring and or harness or wireless system suitable for interconnecting the various internal components of a household appliance . As described in the background section of this application the WIDE network is a suitable internal communication network to provide the internal communications necessary to support the software architecture according to the invention. It will be apparent to one skilled in the art that the software architecture can run on any suitable internal network and that the illustrative example provided herein i.e. the WIDE network is simply one example of a suitable internal communication network .

As previously stated component is any processor based component or sub component of a household appliance . Examples of components suitable for receiving and installation of the software architecture according to the invention include but are not limited to motor control microprocessors microprocessor enabled key pad controllers LCD user interface controllers and other device controls typically included within a household appliance .

The internal external interface connector or slot is suitable for connecting a plurality of types of devices which are able to communicate on the internal communication network and at least one other network such as RS 232 serial various forms of wireless Zigbee Wi Fi etc USB or wired Ethernet etc. The functionality of the device may be strictly limited to protocol and physical layer conversion or may be expanded to support value added services in addition to its base protocol bridging function.

Examples of external clients to which the software architecture permits a household appliance to be connected include but are not limited to a personal computer based control development a factory testing application a diagnostic application a field test application and an interface to a connected home environment. This connection to the external environment whether adjacent to or remote from the appliance enables value added applications to communicate with the appliance . Some examples are 

The system level architecture mechanical electrical and software elements participating to achieve a useful purpose of the household appliance includes the software architecture and software elements apart from the software architecture . The collection of software elements including but not limited to the software architecture within the microprocessor of a component of the system architecture is herein referred to as a software operating environment A. The software architecture is comprised of three components a core implementation an application protocol definition one or more application program interfaces referred to herein as API or APIs in the plural .

The core implementation of the software architecture is a collection of software modules examples found in are SACore SADiscovery SADAQ SAPortMemory SAPollVariable executing in an appliance control microprocessor. As shown in the core implementation is preferably executed in the MAIN loop of the appliance control microprocessor which will be apparent to one skilled in the art. The core provides a common application messaging layer over the internal communication network and is based on a flexible design enabling the development of cross platform connectivity applications. As part of the core implementation a core API will exist which will be uniformly implemented on each appliance. Moreover where uniform implementation is not practical a discovery mechanism may be used allowing adaptation by the client to the non uniformity.

A protocol is a standard procedure for regulating data transmission between nodes in a network. Messages are sent across the internal communication network in one or more packets of data which are then assembled to form a communicated message. There are two applicable areas of definition relative to the software architecture .

An API is a communication and messaging contract which specifies how one network node communicates with another. This is accomplished by defining the available function calls the arguments to each function call the data type of each argument and in some cases the valid values of each argument.

In many cases APIs are specific to an application or appliance and therefore are not considered as part of the software architecture collection of Core standard set of APIs rather the software architecture core enables and exposes multiple API s to the client and possibly the device .

To realize the full potential of this architecture a simple connector can be available on the appliance so that a network card can be plugged into the appliance. See FIGS. and for examples of suitable external devices connected to the appliance . As the appliance already has an internal low cost network for its internal purpose additional wiring to connect the internal communication network with the external device via the internal external interface is minimal and can be accomplished in a known manner such as by a three wire serial cable an external connector and a mounting fixture.

The software architecture can preferably reside on all components of the household appliance control system. However where cost or other constraints are prohibitive the software architecture can reside on a sub set of the components within the control system of the household appliance .

Example benefits of this connectable architecture include but are not limited to external device can be added after market reducing base cost of the appliance . Devices can be developed supporting multiple network technologies applications and devices can be cross platform and generic due to the standard interface presented by the software architecture an internal low cost network such as the WIDE network example is used as a standard API framework and discovery allows many value added commands the software architecture uses bounded events to preserve state and make efficient use of bandwidth and the software architecture is designed to be configured at runtime allowing program developers a more flexible architecture that can reduce time to market.

In addition the software architecture can be extended to many other types of system architectures where data exchange over peer to peer communication is desired. These include multi node systems where multiple printed circuit boards such as a motor control board appliance control board and smart sensor boards communicate within the appliance using the software architecture . The software architecture discovery protocol illustrated in and described later herein can be used to enable a component whose presence causes other components to adapt their control functions to create new behavior or performance or expose new capability to the consumer. The component architecture of structural model along with the discovery behavior of along with the component identification scheme of API ID Type Version see API ID 3 are a basis for the invention embodied in to enable the appliance with a new dynamic and intelligent system architecture.

In addition provides a schematic illustration of two modes of operation enabled by the software architecture which control access to and the level of intervention between the network messages exposed by the software architecture and the internal RAM EE and other forms of non volatile memory of the software operating environment A as well as an output device layer which comprises the low level software operating layer representing the software components B residing within the software operating environment A and providing direct control of the devices for the component . The software components B having direct control of the devices do so by having direct access to the microprocessor port address memory which in turn maps to the physical pins of the microprocessor which in turn are connected through various electronic apparatus to the electro mechanical devices.

Software operating layer of represents appliance specific software components B which interface the network messages received by software architecture to the application control logic resulting in the application control logic to take some action. When the appliance is in a development state an additional software operating layer comprised of API or low level API and API which is the memory port API enables the network messages of API and API to change the state of the physical memory of the software operating environment A and the devices. In this way the devices can be controlled independently of the application software which typically controls the devices in accordance with an operational cycle. The direct control permits the each function of the devices to be independently controlled which is very beneficial in development or diagnostic conditions.

Software operating layer is enabled to effect state change by a special network message exposed by software architecture as well as by additional logic customized for the various states of the appliance an example of which is shown in . During the development state it is preferred that when the user interacts with the appliance via the user interface of software operating layer will not receive the associated user interface inputs. Instead software operating layer will receive the inputs from the user interface. Subsequently software operating layer may interact with the alternate logic of . The alternate logic may in turn make function calls onto the control logic of software operating layer change values in memory or change the state of the attached plurality devices. However during the development state software operating layer is not able to effect the state of the user interface e.g. LEDs lamps buzzers text and graphic displays . The development state renders the control logic of software operating layer ineffective unless invoked from software operating layer . During the development state the implementation logic of APIs and and the alternate logic are in complete control of the appliance and its associated components .

The development state reverts back to the idle state when a special network message is received. In addition it is contemplated that at least one predetermined key press or a predetermined sequence of key presses may also result in a transition from the development state to the idle state.

Software operating layer operates independently of the enablement of software operating layer . The purpose of the development state is to allow and enable operational cycles that have not been previously contemplated. The advantage to this approach is that implementations and configurations of the appliance some of which are illustrated in do not require new software modifications to any component of the appliance because the appliance has the capability through the software architecture to support any implementation or configuration contemplated.

In a network protocol a packet sometimes called a message is a collection of bytes which are transmitted sequentially representing all or part of a complete message. Generally a packet is composed of a header which includes routing information a body also referred to as the payload portion of data and a footer that sometimes contains a checksum e.g. a CRC sum or a terminator such as an end flag. The payload is a collection of bytes contained in a packet. The payload is the data being transmitted between the application layers of two nodes which are components comprising the SA or an SA driver. The function of the network and the protocol is to get the payloads from one node to the other. Sometimes one protocol is sent as the payload of another and in this way protocols can be nested or stacked. Variables are named memory locations that have associated values. One or more variables can comprise the payload. A transaction is a series of messages or packets that represent a complete data exchange between a plurality of nodes.

The relationship between a packet and a payload can have an impact on the efficient use of available bandwidth. The tradeoff to be considered is the amount of overhead needed to get the payloads from one node to another in the context of application layer requirements.

The protocol packet structure has a first header byte that is identified for example as 0xED followed by an address byte having four portions. The first portion of the address byte comprises a destination portion D of bits . The second portion of the address byte comprises a broadcast portion B of bit . The third portion of the address byte comprises a source portion S of bits . The fourth portion of the address byte comprises a reserved portion R of bit seven. The address byte is followed by an identification byte comprised of a service data unit length SDU L comprised of bits and a SAP identifier comprised of bits . A SAP identifier defines the structure of the enclosed payload . A SAP of 4 indicates that the enclosed payload also called a service data unit SDU is defined by the packet structure associated with the software architecture . The identification byte is followed by the payload . The payload is followed by a standard validation byte such as a high byte low byte combination or generally referred to by those skilled in the art as CRC16 CCITT.

The application packet structure is formed from the payload portion of the protocol packet structure . It is within this application packet structure that the communications protocol and data exchange permitted by the software architecture is carried out. The first byte of the application packet structure contains an identifier API ID an integer from 1 255 of the particular API carried by the particular instance of the application packet structure . The second byte up the application packet structure contains in operation code abbreviated herein as op code as an integer from 1 31 in bit followed by a command or feedback Cmd Fb flag of bit a fragmentation frag flag of bit and a more messages pending MMP flag in bit . Bytes of the application packet structure comprise the payload i.e. message data of the particular instance of the application packet structure .

Essentially the software architecture uses two bytes of the payload of the network packet structure of the internal communication network for additional protocol. The API ID is a unique identifier for a collection of Op Codes which are organized into functional units. 0xFF 255 and 0x01 1 are preferably reserved. An Op Code is a unique ID within an API which defines and identifies a single command or feedback message. Each API has an associated Type 2 bytes and Version 2 bytes allowing for a large library of identifiable functionally related groups of messages op codes to be created over time.

Preferably x1F 31 is a reserved value for Op Code. The Cmd Fb flag indicates whether the message is a classified as a command or a feedback. A command is some message that requests an action to be taken where a feedback is some message that simply contains information e.g. acknowledgement event data . Preferably the Cmd Fb flag is 0 for commands and 1 for feedbacks.

The frag flag specifies whether the received message is being broken into multiple messages fragments by the sender because of the size limitations of the lower layer protocol s payload . The first fragment of the message will take on the structure of . All subsequent fragments of the message will take on the structure of . The frag flag is preferably set until the fragmented message is completed.

The MMP flag indicates that events are sent as individual messages but are bounded together by protocol so that the client can group events together as a complete snapshot for one scan of the micro controller. The MMP flag is preferably set until the last message for a snapshot is sent out. and the accompanying discussion provides more detail on bounded messages.

The MMP flag provides the software architecture the capability to express the state of an appliance as a function of independently meaningful feedback variables bounded together in snapshots.

When the internal state of an appliance changes multiple events may be sent that in total describe the new state of the appliance . The number of events required to describe a state change is appliance state specific. Therefore special protocol delimiters are used to allow an implementation specific number of feedback variables to be associated with a particular appliance state change. Because these events are independently meaningful this approach is preferable in that all permutations of event data aggregations can be created through the use of MMP. This results in efficient use of the identification namespace API Id and Op Code because no new identifiers are required when the client requires a new combination of data to be sent. In summary MMP and the associated rules thereof allow dynamic and virtual data aggregation eliminating the need for special application case specific solutions. In the net effect of the MMP flag is shown.

The MMP flag also provides the capability for the embedded implementation to suppress the invalid transient condition. As the appliance state transitions it is possible for a set of related variables to change several times very rapidly. When appliance state is expressed in terms of independent feedback variables sent as separate events feedback messages without a binding mechanism ambiguous or invalid transient states are likely to occur. Moreover if the client is executing business logic during the invalid transient state logic errors may result in incorrect control or user display actions. Refer to the section hence labeled State Integrity for an example of how asynchronous data collection is an inferior approach to data collected synchronously within each scan of the microprocessor and transmitted within the snapshot enabled by MMP. In addition message binding can be used to group independent command invocations so that they may be processed in batch.

The packet structure also governs incoming messages. In general networks allow asynchronous processes to communicate creating the potential for one network node to exceed the processing capacity of the other by sending too many requests within a short time window. To prevent message overruns a protocol is used according to the invention which allows the sender to wait for an acknowledgement before sending a second message.

This feature permits the software architecture to use an enumeration for this acknowledgement based on the execution state of the software architecture . In this way necessary information describing message success or failure is communicated with fewer messages. The command sender will receive an enumerated acknowledgement for each command sent. The most common is a positive ACK which means that the node is ready to receive its next command. All other enumerations are a form of failure. Failure is characterized by the remaining 254 possible values of the acknowledgment byte. Of this range of 254 values some are standardized and some are reserved for application specific failure codes.

Frag flags and MMP flags allow the user of the software architecture flexibility in designing the application messaging strategy. If a developer chooses to use very large messages the frag flag can be used so that messages larger than the packet structure A i.e. 13 bytes within the exemplary application packet structure shown herein can be sent by sending the original large data set as multiple smaller data sets within multiple packets of packet structure .

By the same token if a developer chose to use smaller messages which are often the case but wanted to group those messages together MMP flags can be used. For example if 10 messages of 3 bytes each needed to be sent as a group so that the client application could know that the messages were related to the same scan of the microcontroller then the first 9 messages would have the MMP flag set and the last message of the group would have the MMP flag 0.

The following presents a summary of defined APIs for the software architecture and then each one of these commands and feedback messages is described in detail. The advantage of this approach is that it allows the developer to choose the modules within the software architecture that are appropriate for the current stage of development e.g. unit test engineering testing production . Furthermore compiling out certain modules allows developers to use portions of the software architecture in those cases were RAM ROM resources would otherwise be prohibitive. The APIs are described with their currently selected application program interface identifier API ID however any identifier can be employed without departing from the scope of this invention. The associated functions made capable by the particular API are enumerated beneath each API. Bulleted functions are feedback messages which are sent from the software architecture to the client such as an internal client or an external client and non bulleted functions are commands which are sent from client to the software architecture .

One note on a convention used in this application. The word extends refers to the ability of one API to build on the functionality of a baser level API. The extends keyword means When API x EXTENDS API y then API x API x API y. This notation simplifies the task of record keeping and API documentation. In other words API x also includes those functions specified in API y. If API x and API y each specify a function with the same Op Code the implementation of API x implementation can take precedence.

The following table describes the extended data acquisition API Extended DAQ API ID 2 Type 2 The extended DAQ is inclusive of the Basic DAQ at runtime.

The Energy Management API is API ID 8. As does the other APIs the Energy API is made of a collection of Op Codes each representing a useful function relating to energy management and having an associated collection of bytes which are the appropriate parameters to achieve the function.

The Core API API ID 1 herein is the smallest subset of the software architecture functionality that can be deployed. However it is contemplated that other embodiments compliant with packet structure may be developed. It makes provisions to design the two hard coded data acquisition schemes referenced in .

In the Core API a protocol mechanism send Events of allows the client to request the event source to send all or send a specified set of events. In this way a type of polling is possible within the framework of the eventing architecture without separate message definitions or implementation structures and logic. Moreover this mechanism enables robust system startup conditions. For example if all network nodes send all events simultaneously at system power up misoperation within the software of a client or where the software components therein would not be able to accurately process the plurality of messages generated as a result of a power up condition are more likely.

The DAQ API API ID 2 presents a dynamic mechanism query for a component enabled by the software architecture . This feature allows the client to configure an embedded software engine an array of structures whose elements are instanced and stored in a dynamic memory heap see DynamicMemoryHeap of containing a collection of NVOEvent structures which associates a section of microprocessor memory with an event operator described in a table below and arguments. Pointers into memory values of the memory event operators and operator arguments are stored in the memory heap s array of structures Heap containing NVOEvent structures . As shown in the DAQ engine can be configured in 2 ways 

1. Application software apart from the software architecture which resides in the same microprocessor can configure the DAQ as is shown by the arrow in from the DAQ Init software component.

2. Secondly external clients may use the DAQ API described herein to configure the DAQ from the network .

As shown in the Process DAQ Events State Diagram of when the DAQ engine is executed it iterates over each event structure checking the associated memory locations against the event operator and arguments. When the event conditions evaluate to a TRUE message buffers are constructed within the internal memory reflecting the data associated with the event condition. When the iteration is complete notification messages are generated and preferably broadcast to the network. Alternatively notification messages can be directed to a specific component if additional memory is allocated to store the network identifier of the component which initially requested or configured the event.

A developer can use several event operators. Examples include on change greater than less than equal to deadband and bitmask. Several Op Codes of the DAQ API are provided to control the memory heap at runtime such as clear Events add Events External notification on off get Events get Event Data etc.

In total the software architecture supports four schemes for data collection all of which are shown in . Two of the four schemes describe briefly above are reliant on the DAQ. The other two schemes also briefly described above are hardcoded. Each scheme can co exist within the software architecture . Each scheme provides certain optimizations at the expense of other resources.

In a client configured data acquisition scheme dynamic events are created. This method can be used if the microprocessor has enough RAM ROM capacity and is most commonly used when the client is a PC application. Using the DAQ API a developer can re use code require less engineering time leverages a proven re useable eventing module is flexible e.g. can be configured at runtime and there can be an optimization of network bandwidth. However this method can require more RAM ROM than hard coded methods and an embedded client might not have access to needed data files at runtime.

In the client configured data acquisition scheme the DAQ engine must be provided a memory location in order to watch for an event. With a variable map this is practical when the client is a PC application as in . However when the client is for example another control board that implements the software architecture access to a variable map is impractical. Thus this invention provides functionality for an embedded variable map located in the memory of a node implementing the software architecture . This variable map links an API and Op Code to a variable address as in . Thus in order to register for an event on said node the client needs only know the API and Op Code for that variable not the specific memory address.

Using the embedded variable map in the client configured data acquisition scheme the situation may arise where a particular client is restricted from creation of an event because the associated API and Op Code pair has already been registered by another node. In such a situation this invention provides that node the ability to request information about the embedded variable map. Included in this information is the variable s memory address. With this information the client node can the register for an event of the same variable using the variable s address and a different API and Op Code pair than previously attempted see .

An alternative to the client configured DAQ is a self configured DAQ. In this case the internal logic uses the DAQ engine to create NVOEvent structures in the DynamicMemoryHeap of . This can be a useful scheme when the events to be realized are fixed and are known at the time of design and there are enough RAM and ROM resources to reuse the difference engine the logic contained within the DAQ of the DAQ . Therefore this method has similar benefits as the client configured dynamic event scheme and moreover will require more RAM ROM than hard coded methods described below .

In a hard coded eventing module a developer can optimize network bandwidth optimize use of RAM ROM and can conform to the DAQ API. However this scheme requires a custom coded solution to generate the events and does not rely on the software and logic of the DAQ as shown in .

Using the hard coded polling method provided by the Core API a developer can optimize use of RAM ROM by creating custom coded solution. Polling will generally waste network bandwidth but is sometimes used due to its simplicity.

The software architecture can be customized to allow for the needs of different implementation platforms. RAM and ROM space and time complexity can be managed as well as access to memory locations and timeouts. All of these are located in a predetermined parameters file. It will be understood that the parameters can be renamed changed retyped added or deleted without departing from the scope of this invention.

A Discovery API API ID 3 enables the concept of Plug n Play architecture. The Discovery API implies that a physical network node or client can contain n functions each encapsulated by a known API with a unique ID Type and Version. These APIs are portable meaning they represent functionality and are independent of the microprocessor software language and network topology and re useable on other components where the functionality therein is applicable. The Discovery protocol described in API of allows the client to learn the associations between the components and the groups of functionality APIs which they contain.

In addition when a component enabled by the software architecture and having resident the sub component of the software architecture discovery which is API Id 3 initializes it will automatically send out a message announcing itself API Id 3 Op Code 2 publishSANode .

Also if the user of the software architecture so chooses the discovery sequence of may be altered by omitting messages and op codes respectively . The approach is valid in that the client may initiate discovery by issuing an Op code 3 message getSAAPI collection that will result in responses from all components enabled by the software architecture thus obviating the need for messages and in most cases.

It is also contemplated that an abbreviated messaging sequence could achieve the same results as the aforementioned discovery sequence. In an abbreviated discovery sequence each node issues a message after power up containing within one message the totality of information which was described in the aforementioned discovery sequence. Each node receiving this message would reply back with the same information about itself giving the node which just powered up the discoverable information from all the nodes that were already powered up.

This Discovery API protocol mechanism allows a client to locate a logical entity at runtime without prior compile time programming. Moreover this mechanism allows the client to determine if expected components are resident or missing. From this knowledge the client can configure itself and or present the user with the appropriate inferred functionality.

The Low Level API API ID 5 exposes via the network capabilities allowing the client to control or actuate the output devices which are electrically connected to the containing component and to provide read and or write access to the numeric value which represents the current state and potentially the state history of the electrically connected input device. Typical examples of outputs are valves relays triacs solenoids LEDs lamps buzzers and on the like. Typical examples of inputs are push buttons switches sensors e.g. pressure temperature and over temperature and on the like. In the preferred embodiment the Low Level API as well as the Memory Port API are available only in the development state of of the software architecture of the appliance . The development state can only be entered from the appliance idle state of the exemplary appliance state diagram of . Also in the preferred embodiment if any user interface actions are initiated via a keypad LCD or other user interface device of the appliance during the development state the appliance can revert back to the idle state of and set each output back to its un actuated state. The messages for initiating the development state can be found in the message definition specification for the low level API see API Op Code . This network message is defined to allow the appliance to enter the development state. In the development state a special API is enabled and exposed to the network which allows the client to control the electronic outputs of the appliance directly. In development state production oriented business rules such as validation are by passed giving the client complete control of the electronic sub system.

The low level API can be used to implement non standard operation of the appliance in that the appliance can be operated in a manner other than in accordance with one of the predetermined operating cycles implemented by the appliance software operations layer which typically resides on the component for appliance control. In this way the low level API can be thought of as enabling additional cycles of operation. Some examples of additional cycles of operation include a demonstration cycle a development cycle an error detection cycle a diagnostic cycle a cycle that reduces the time of at least one timed step of one of the predetermined cycles of operation a cycle that bypasses at least one operational step of one of the predetermined cycles of operation a cycle that substitutes a timed step for a step that responds to an event of one of the predetermined cycles of operation and a cycle that exposes the low level API to the network

The Key Press API API allows the client to press virtual keys. This provides an equal method by which to exercise and test the software without mechanical or human actuation of the physical key pad.

One note on a convention used in this application. The word extends refers to the ability of one API to build on the functionality of a baser level API. The extends keyword means When API x EXTENDS API y then API x API x API y. This notation simplifies the task of record keeping and API documentation. In other words API x also includes those functions specified in API y. If API x and API y each specify a function with the same Op Code the implementation of API x implementation can take precedence.

Exemplary application packets for the payload portion of the packet structure for the internal communications network of the household appliance follow. The application packets are grouped according to API.

Core API API ID 1 Type 3 Version 1 . The following application packet represents a directed message from the software architecture to a client for publishing acknowledgement Publish Acknowledgement . This message is sent by the software architecture to the sender of a previous message. It contains an enumerated value representing the results of the previous command processed by the software architecture . Generally the receipt of the acknowledgment indicates that the sender can initiate the next message.

Note that the API and op code of the previously received command the one that is being acknowledged is contained within byte and of the payload. This provides the receiver of the acknowledgment the component which sent the original command certainty as to which previously transmitted command is being acknowledged. The previously transmitted command having the unique identifier of API Id and Op Code. It should be noted that in the drawings and descriptions the ACK is generally assumed and is not continuously repeated or documented. Enumeration values for the reason code of the above application packet are shown in the table below.

The following application packet represents a broadcast message from the software architecture to a client or for publishing heartbeat Publish Heartbeat . This message is periodically sent by the software architecture . This allows nodes which have registered for events to maintain confidence in the event sources. In other words heartbeat insures connection integrity. Alternatively the client or may determine that each or some event s sent by the software architecture should receive an acknowledgement sent by the client back to the software architecture before the software architecture deems the transaction associated with the generation and transmission of the event to be complete. If a particular event has been created with the acknowledgment classifier according to the message specification of API Op Code 1 2 12 or 13 the software architecture will define the end of the transaction associated with the generation and transmission of the event to be complete when an acknowledgment message is received according to the message specified by API Id and Op Code .

Publish Heartbeat will not be sent until after the software architecture receives a command. This can be used to prevent a misoperation or Traffic Storm condition during power up. Traffic Storm refers to a misoperation within the software of a client or where the software components B therein would not be able to accurately process the plurality of messages generated as a result of a power up condition. Publish Heartbeat will be suspended after a Reset SA message which is described below with respect to the Core DAQ API and Op Code is received but will resume after the next subsequent command. This is a feedback message.

The following application packet represents a directed message from a client to the software architecture for setting heartbeat period Set Heartbeat Period which is setting a frequency at which the heartbeat message is sent by the software architecture . Exemplary frequencies range from 0 seconds off to 3600 seconds 1 hr .

The following application packet represents a broadcast message from the software architecture to a client for publishing the heartbeat period Publish Heartbeat Period . This message is a response to Set Heartbeat Period. It is necessary so that if a second client changes the heartbeat period the first client will be notified. Clients who require non changing heartbeat periods should use the DAQ API to set up an event with a constant broadcast operator See DAQ API Id 2 Op Code Byte 4 5 or 6 see change operator table .

The following application packet represents a directed message from a client to the software architecture for reading memory particularly the RAM Read Memory . It is sent to the software architecture and results in a Publish Memory Data response which is shown below Op Code and contains values specified in Bytes of the packet below.

The following application packet represents a directed message from a client to the software architecture for reading EE memory Read EE . It is sent to the software architecture and results in a Publish EE Data response Op Code 8 which is shown below and contains the values specified in the Read EE packet Bytes below.

The following application packet represents a directed message from the software architecture to a client for publishing memory data Publish Memory Data and is a response to Read Memory.

The following application packet represents a directed message from the software architecture to a client for publishing EE memory data Publish EE Data and is a response to Read EE.

The following application packet represents a directed message from a client to the software architecture for sending events Send Events . The message instructs the software architecture to send specified events regardless of event trigger criteria.

Note Event Id is used synonymously with Op Code. Event Id is a more descriptive term for Op Code when describing an Event which is part of an API.

Note the notation used below is repeated through out the document and is described here only. If Byte contains the reserved value 0xFF then the software architecture interprets Byte to mean all API Ids. Otherwise Byte specifies a particular API Id. Likewise If Byte contains 0xFF the software architecture interprets Byte to mean all Events for the API or APIs specified in Byte . Otherwise Byte contains a single Event Id. Bytes through Byte n contain a single Event Id.

The following application packet represents a broadcast message from the software architecture to a client for publishing events Publish Event and is a response to the above Send Events message. Alternatively if the DAQ Engine is being used this message is sent when the event trigger criteria is satisfied. Below API Id and Op Code are notated as client defined . This refers to the assignment made of API ID and Op Code by the createEvent commands sent by the Client of DAQ API API Id 2 specifically in Bytes and of Op Code and Bytes and of Op Code 

Core DAQ API API ID 2 Type 3 Version 1 . The following application packet represents a directed message from a client to the software architecture for creating a numeric event Create Numeric Event . The message identified by API Id of and Op Code of or allows the client to create and configure feedback variables NVOEvent structures of . Byte and are used to assign the identifier API Id and Op Code which will be used to populate fields in the publish event message API Id when the event conditions are such that an event message is generated. Generated event messages are of the form found in the preceding description of the Core API where the message packet is labeled as Publish Event . The identifiers API Id and Op Code located in bytes and respectively of the Publish Event message. The values found in these bytes can be assigned through the messages defined for the DAQ API Op Codes and below. Bytes contain the address in the memory of the software operating environment which will be evaluated for the event condition represented by Byte which is an enumeration of evaluation rules and Bytes A and B which are arguments to the evaluation rules. Byte specifies the number of contiguous bytes which should be evaluated as a single numeric value with respect to Bytes A and B

Event operators associated with Byte of the above application packet are discussed in further detail following this section of exemplary application packets and are shown in the table that denotes event operators available when creating a numeric based event. Additionally byte C corresponds further classification resulting in either acknowledged or unacknowledged events discussed later . See for an example of the operation of an acknowledged event.

The following application packet represents a directed message from a client to the software architecture for creating a byte event Create Byte Event . The messages definitions identified by API Id 2 and Op Code 1 or 2 allows the client to create and configure feedback variables events . The message specification for Op Code is similar in intent but has different implementation details that provide usefulness for certain application use cases. API Id with Op Code differs in functionality from API Op Code in that depending on the value of Byte A either only 1 byte within the range specified by Bytes and Byte or all the bytes will be evaluated based on Byte s change operator and Byte B s change value. Whereas in the case of Op Code the specified bytes were evaluated as a single numeric. In the case of Op Code each byte or a single byte according to the value specified in Byte A will be evaluated independently according to the change operator specified in Byte and the change value specified in Byte B.

Event operators associated with Byte of the above application packet are discussed in further detail following this section of exemplary application packets and are shown in the table that denotes event operators available when creating a byte based event. Additionally byte C corresponds to further classification resulting in either acknowledged or unacknowledged events discussed later . See for an example of the operation of an acknowledged event.

The following application packet represents a directed message from a client to the software architecture for clearing event s Clear Event s . The Clearing Events message allows the client to clear the event definitions previously created with either of the create event Op Codes or as shown above . The client can send multiple Clear Event commands to the software architecture using the MMP flag if synchronization is needed across multiple commands.

The following application packet represents a broadcast message from the software architecture to a client for publishing events cleared Publish Events Cleared and is a response to Clear Events. The message notifies the clients of the software architecture when Op Codes or APIs are removed from the existing the software architecture node interface.

The following application packet represents a directed message from a client to the software architecture for resetting the software architecture Reset SA . The Reset SA command instructs the software architecture to re initialize as if it had just powered up.

The following application packet represents a broadcast message from the software architecture to notify that the software architecture has been reset Publish SA Reset and is a response to Reset SA.

The following application packet represents a directed message from a client to the software architecture for turning on external notification for a specified event Set External On . The command instructs the software architecture to externally notify clients of the event. See for an example of the usage of this command.

The following application packet represents a broadcast message from the software architecture to notify that external notification of the specified event has been turned on Publish External On and is a response to Set External On. See for an example of the result of this command.

The following application packet represents a directed message from a client to the software architecture for turning off external notification for a specified event Set External Off . The command instructs the software architecture to not externally notify clients of the event.

The following application packet represents a broadcast message from the software architecture to notify that external notification of the specified event has been turned off Publish External Off and is a response to Set External Off.

Core DAQ API API ID 2 Type 4 Version 1 Extends Type 3 Version 1 . The following application packet represents a directed message from a client to the software architecture for getting event data Get Event Data . Get Event Data instructs the software architecture to send definition s of specified events. The definition is a mirror image of the data sent in the Create Event Op Code messages which are shown above as Op Codes or for the Core DAQ API. The software architecture will respond with a collection of Publish Event Data messages which are shown below.

The following application packet represents a directed message from the software architecture to a client for publishing numeric event data Publish Numeric Event Data and is a response to Get Event Data. Each event definition is reported in a separate internal network message and is governed by snapshot rules associated with the MMP flag of of . The event definition contains the information specified about the event in Create Numeric Event.

Event operators associated with Byte of the above application packet are discussed in further detail following this section of exemplary application packets and are shown in the table that denotes event operators available when creating a numeric based event.

The following application packet represents a directed message from the software architecture to a client for publishing byte event data Publish Byte Event Data and is response to Get Event Data. Each event definition is reported in a separate internal network message and will be governed by the snapshot rules associate with the MMP flag of of . The event definition contains the information specified about the event in Creation Byte Event.

Event operators associated with Byte of the above application packet are discussed in further detail following this section of exemplary application packets and are shown in the table that denotes event operators available when creating a byte based event.

The following application packet represents a directed message from a client to the software architecture for creating a remote numeric event Create Remote Numeric Event . The message allows the client or another module in the embedded system to configure feedback variables associated with an existing API and Op Code using an embedded variable map. Although the number can be 4 bytes the change value is limited to 2 bytes. illustrates the embedded variable map. defines the interaction between 3 network nodes where Node A successfully creates a Remote Numeric Event on Node B. And where Node C attempts the same but through the interaction with Node B is able to accomplish the intent of the request without duplication of the Identifier API Id and OpCode . This is accomplished because Node C is able to query Node B for the address in memory of the initial Identifier so that an alternative non duplicated Identifier may be selected. The alternative identifier is then used to create the Remote Numeric Event by sending see message in a new message to Node B with the original memory address and the alternative Identifier.

The following application packet represents a directed message from a client to the software architecture for creating a remote byte event Create Remote Byte Event . The message allows the client or another module in the embedded system to configure feedback variables associated with an existing API and Op Code using an embedded variable map.

The following application packet represents a directed message from a client to the software architecture for getting remote variable data from an embedded variable map Get Remote Variable Data . The message instructs the software architecture to publish information concerning the data that exists in the embedded variable map. See for an example of use of this command.

The following application packet represents a directed message from the software architecture to a client for publishing remote variable data Publish Remote Variable Data and is a response to Get Remote Variable Data. It reports data from the embedded variable map such as the API op code size and address.

Core Discovery API API ID 3 Type 3 Version 1 . Referring to the following application packet represents a broadcast message from a client to find nodes of the software architecture Find Node s . This broadcast message enables a node to locate other nodes of the software architecture .

The following application packet represents a broadcast message Publish Node from the software architecture allowing it to publish its presence to other components participating on . This message is sent when a node of the software architecture powers up or is re set or is sent as a response to Find Nodes. Additionally this message can be sent when the node of the software architecture through a secondary Discovery process adds to itself an API or adds Op Codes to an existing API. Publish Node is not sent when a client dynamically adds an API or Op Code to the software architecture via DAQ Op . The payload of the feedback message contains a firewall password which is to be used by the firewall security feature of the software architecture see for an example of this feature . This allows the sender of the message to become a trusted node on network .

The following application packet represents a message which can be either directed or broadcasts from a client to the software architecture for getting API s Get APIs of the software architecture . This directed message allows the client to discover the APIs that are supported by a specific node of the software architecture . API Id must be unique within an appliance.

The following application packet represents a broadcast message from the software architecture to a client for publishing API s Publish API s of the software architecture . This message is a response to Get API s and is a directed message that allows the client to discover the APIs that are supported by the sending node of the software architecture .

The following application packet represents a message which can be directed or broadcast from a client to the software architecture for getting API information Get API Info . This directed message allows the client to discover Version and Type information about the specified API s .

The following application packet represents a directed message from the software architecture to a client for publishing API information Publish API Info and is a response to Get API Info. This directed message allows the client to discover Version and Type information about the specified API s . There is one message per API and the messages are bounded using the MMP flag of .

Bytes and represent an API s Type which can be used As an indication of a specific sub classification of an API. The value of Type can be used to determine compatibility concerns between sub components APIs . Byte and represent an API of a particular Type s Version. This value can be used to indicate bug fixes or changes to functionality. As with Type it enables a runtime compatibility check which can inform the client if the versions are compatible. Alternatively Bytes can be used in conjunction with Byte to form a 5 byte class identifier where class refers to a class definition within a class library whom one of typical competence with the state of the art would understand . Using the alternate approach Byte API Id is a runtime object handle and Bytes numerically concatenated form the class id.

The Number Instances associated with Byte signifies to the client than an API has multiple instances. The client can follow up with Get Instance Info which is described below to find the Instance Ids that belong to the API. The Descr Char Descr Char n is an optional feature that can be helpful to developers. Descriptive text can be used to annotate API Id. For example upper or lower could be used for the two cavities of a double oven.

The following application packet represents a directed message from a client to the software architecture for getting instance information Get Instance Info . This directed message allows the client to discover the Instance Ids for the APIs that report more than one Instance of an API. The first instance of any API uses API Id as its Instance Id. If there are multiple Instances of an API Id on the same addressable node subsequent instances are assigned an Instance Id dynamically. These dynamically assigned Ids can be discovered by sending the Get Instance Info message. The value of the Instance Id should be used in place of API Id when there are multiple instances of an API on a physical network node.

The following application packet represents a broadcast message from the software architecture to a client for publishing instance information Publish Instance Info and is a response to Get Instance Info. This directed message allows the client to discover the Instance Ids. The first instance of any API uses API Id as its Instance Id. If there are multiple Instances of an API Id on the same addressable node subsequent instances will be assigned an Instance Id dynamically. These dynamically assigned Ids are communicated via the Publish API Info message described above. For purposes of uniformity Publish API Info is sent for the first instance i.e. where API Id Instance Id . There will be one message for Instance of API which is bounded using the MMP flag. The value of Instance Id should be used in place of API

Preferably the Descr Char Descr Char n allows the client to associate an Instance Id with its physical function. For example upper or lower could be used for the two cavities of a double oven. However the user of the software architecture may use Descr Char Descr Char n for any useful purpose.

Core Debug API API ID 4 Type 1 Version 1 . The following application packet represents a broadcast message from the software architecture to a client for publishing saturation Publish Saturation . Saturation happens when the supporting layers of the internal network are unable to deliver the data that the software architecture has put into the outbound queue of WIDE A. The software architecture has no queue if the WIDE A cannot service the outbound data then the software architecture sends out Publish Saturation.

The following application packet represents a directed message from a client to the software architecture for setting a register for saturation Register for Saturation . The client sends this message to a software architecture node which enables the Saturation message. Only the node that enables saturation can disable saturation.

Low Level API API ID 5 Type 1 Version 1 . The following application packet represents a broadcast message from the software architecture for publishing state Publish State . This message sent as a result of a changed internal state of the machine resulting from normal cycle progressions user interactions Op Code below or other messages received via network .

Exemplary machine state enumeration values are presented in the following table. According to one embodiment of the invention the running state is included. However in some cases the running state is somewhat ambiguous and additional phase variables must be exposed so that proper client side business logic can be written. In an alternative embodiment the running state is eliminated in favor of a more granular and definitive state machine where each phase of each state is documented properly. In this embodiment sufficient address space exists in the byte for the additional enumerations.

The following application packet represents a directed message from a client to the software architecture for toggling the household appliance software operating environment governing state of between the development state and the idle state. Note that the development state not shown on but one with ordinary skill in the art can contemplate a development state which can only be entered from an idle state and when an exited state goes back to an idle state.

Core Key Press API API ID 6 Type 1 Version 1 . The following application packet represents a directed message from a client to the software architecture for pressing a key Key Press . This directed message allows the client to send virtual key presses. Key indexes are not discoverable due to coding techniques used in the embedded processor therefore key indexes may be extracted from the source code files manually or through other automated mechanisms.

The following application packet represents a broadcast message from the software architecture to a client for publishing key press Publish Key Press .

Memory Port API API ID 7 Type 3 Version 1 . The following application packet represents a directed message from a client to the software architecture for writing memory Write Memory . The Memory Port port API is enabled via the Development State of and the associated interaction is similar to the previously described association between Development State of and the Low Level API API ID 7 .

This directed message allows the client to write to a specified RAM location. The write to the specified RAM location is limited to a single packet. In the current embodiment this would be 13 bytes shown in A of . MMP of 1 is not valid for this message.

The following application packet represents a directed message from a client to the software architecture for writing EE memory Write EE . The write to a specified EE location is limited to a single packet. In the current embodiment this would be 13 bytes shown in A of . MMP of 1 is not valid for this message.

Poll Variable API API ID 10 Type 1 Version 1 . Referring to the following application packet represents a directed message from a client to the software architecture for reading poll variables Read Poll Variable s . This message instructs the software architecture to send a Publish Poll Variable message which is shown below for poll only variables. Poll variables can be hard coded by a developer for a specific application and can be used if RAM ROM resources do not allow the use of the DAQ API.

The following application packet represents a directed message from the software architecture to a client for publishing poll variables Publish Poll Variable and is a response to Read Poll Variable s . There is one message per poll variable index as specified in the initiating Read Poll Variable message.

A note on the event operators discussed in the DAQ API section above. Byte of the Create Event Numeric and Byte message DAQ API opcodes and Byte of CreateNumRemoteEvent and CreateByteRemoteEvent DAQ API op codes are the event change operator shown in the NVOEventStructure of . Operators are instructions which describe to the software architecture the mathematical condition at which the software architecture should generate an event message. The table below describes examples of event operators. The arguments for event operators are dependant on the type of event being created numeric based or byte based which are op codes and respectively .

Event operators are part of the DAQ API which has two variations basic Type 1 and an extended Type 2 . Note the fifth column in the table which denotes the availability of each Event Operator for the plurality of revisions 4 of the DAQ API. Note that Types 1 2 are deprecated and the preferred embodiments are the Basic Type 3 or the Extended Type 4 which is inclusive of Type 3 functionality.

The following table denotes the event operators available when creating a numeric based event API ID Op Code and 

The following table denotes the event operators available when creating a byte based event API ID Op Code and 

The BIND operator allows the client to create multiple memory events from a single event trigger. In other words once an Event ID has been assigned subsequent events can be created which will automatically be sent when the original master event is triggered.

When a byte based event op code 3 is set up with the On Change operator a value of 255 in byte will instruct the software architecture to do a change detect for all bytes in the range specified by the address and size arguments.

The Bit Mask operator allows the ability to watch for bit transitions within a byte. The mask value should be set such that bit 1 is a care about and bit 0 is a don t care . When set to don t care a value transition at that bit location will not result in an event generated.

The software architecture does not provide an explicit solution for time synchronization but does provide an enabling mechanism. The capability of the client to create an event that is periodically broadcast allows the client to maintain a time of day clock which is synchronized with the appliance . Since the software architecture may not explicitly expose a time of day clock API the client can have the address in memory where time of day is stored. It is to be understood that an external client can have all or at least some of the same messaging discovery broadcasting and other capabilities of the client .

The software architecture core has several design considerations which can be considered and contemplated to create alternative embodiments of the invention described herein.

The following items can be considered when determining alternative embodiments of the core implementation of the software architecture 

Message architecture is a primary design element whose solution has many dependent design consequences. The internal communication network packet structure provides new possibilities for event driven message architecture as opposed to previous networks. An element to consider is whether nodes will poll one another if they will register for notification messages.

Polling is a practice of nodes which can be clients or components periodically sending messages to the owners of data requesting updated values e.g. continually request data every 100 ms . Polling is generally simpler to implement and more commonly used and can maintain connection integrity verified with each request. However when polling the client must continuously ask for information. Network Bandwidth is used up with data that is not changing bandwidth is the amount of data that can be passed along a communications channel in a given period of time and there are several factors that effect bandwidth such as number of nodes on a network the transmission frequency baud rate and the protocol overhead CRCs acknowledgements source destination IDs etc the transport protocol hardware and cabling govern the limits of bandwidth however the Application protocol has the responsibility to make the most efficient use of the available bandwidth . Polling architectures do not scale as nodes increase the number of messages increases exponentially. Assuming there is information on each node that every other node needs messages n 2 n. Data is typically not synchronized with the memory of the control and message latency can be as much as twice the polling rate.

Eventing is a practice of nodes registering with the owners of data to be notified under certain conditions with new value of data. The data owner is then responsible to send a message to the observing nodes when the data meets the criteria originally specified during registration. e.g. send data only when data changes . In an eventing model bandwidth usage is optimized because data is only sent when it changes. This model scales well with message traffic and minimizes latency. Data is synchronized with the control. However a connection validation heartbeat is needed. Otherwise a client may not know when an event source is offline. Alternatively connection validation in an eventing model can be achieved using acknowledgments which are an additional message transmitted from the event observer back to the event source. When the event source transmits an event message the event source will not consider the transaction to be complete until an acknowledgement message is received. After a timeout has expired the event source may retransmit the event. This process may repeat for a configurable number of acknowledged event transmission retries.

In eventing architectures the message binding capabilities of that are governed by the MMP bit of the packet structure can be used to group events which were generated from the same scan of the microcontroller.

In this case the preferred embodiment is an eventing model since eventing has advantages listed above as well as the simplicity of the remedies which address the disadvantages of eventing. Connection validation is addressed by use of a heartbeat and or acknowledged events. When the heartbeat is used the event source will send out an event periodically so that all of the event listeners of that node can know that the event source is healthy. Likewise implementing the heartbeat such that its frequency is programmable can also be used to notify all event subscribers that the event source is healthy. The heartbeat period is configurable from the network. Acknowledged Events which are described in detail herein are an alternate method which can be used in addition to the heartbeat or programmable heartbeat to insure connection integrity. Message binding is addressed with the message bounding bit in the payload of each packet structure . This allows the software architecture driver to collect messages corresponding to the same microcontroller scan and present those to the application layer as a whole.

Using a the a sub component of the invention known as the DAQ the software architecture allows a client to dynamically register with a component for appliance control which is enabled with the software architecture and including the optional sub component of the software architecture DAQ via the internal communication network to receive notification when the value at a specified memory location changes relative to a specified condition. This relieves the component for appliance control from having hard coded feedback variables and allows real time feedback to change according to the application without client polling because event based updates are accurately broadcast as needed.

A dynamic memory heap of which is a memory reserved for runtime configurable feedback messages is employed wherein the size of the heap is configurable at compile time. It has been found that each feedback event variable requires about 10 bytes of RAM. The events registered in the heap NVOEvent of can be added or reset through internal communication network commands issued by the client to a component enabled by the software architecture having also installed the optional sub component DAQ .

One example of payload structure is a static compound payload which consists of grouping multiple variables together at design time so that the client can with one transaction send a complete command to or receive the complete state of a component within the appliance . In the case of a command the client may not intend to change every variable in a payload therefore a pre requisite status update is required to populate the command payload with the current status for those variables which are not intended to change. Moreover the variables that change may not map directly into a single payload definition resulting in multiple messages containing interspersed changed and non changed data.

In a simple payload structure only one variable can exist in a payload. This has a simpler easier implementation and can approximate a dynamic compound payload described below . However bandwidth is not optimized because of a larger ratio of message overhead to data and message binding needed as variables are sent separately.

In a dynamic compound payload structure payloads are not statically defined at design time but are dynamically created by the sending node. In this case the length of the payload is determined by the data which the sender wishes to send and moreover there must include identifiers and possibly delimiters in the payload which will allow the receiving parser to un marshal the component parts of the payload. To reiterate the receiving node must have a parser sophisticated enough to separated the multi variable payloads into their component parts. This payload structure optimizes bandwidth but can increase ROM requirement due to the sophistication required by the parser. There is also some added overhead to the application protocol since the dynamic compound payload must embed op code lengths as part of messages requires additional parsing by the receiving component and can be hard to understand and implement.

It is a preferred embodiment of this invention to employ a simple payload structure for the application protocol. The complexity of a dynamic compound payload can have difficulties in a cost benefit analysis for the messages employed in the software architecture . To maximize the use of the software architecture the complexity of the interface should be preferably minimized. By way of using compound payloads by their complex nature would potentially retard the use of the software architecture especially with embedded clients. Simple payloads are a good approximation of dynamic compound payloads even though there can be additional message overhead i.e. there are five bytes of overhead for every the internal communication network message . There is an additional two bytes of overhead to support the software architecture packet structure . This leaves 13 bytes per the internal communication network protocol packet structure for data in some application specific conditions. Using a static compound payload can be inflexible and wasteful.

The message binding of is addressed with the use of the MMP bit in the payload of each message packet. This allows the software architecture driver to collect the messages corresponding to the same microcontroller scan and present those to the application layer as a whole.

Relative to a user interface for an appliance the appliance acts like a state machine. As keys are pressed the state machine transitions from one state to another. For each state it is known what keys are valid candidates for the next push. Likewise it is also known which keys are not valid for the next push.

Generally when a key is pressed that is invalid the appliance will produce an audible alarm to indicate to the user that the appliance was in an inappropriate state for that key. The same concept applies to commands being sent by an external client which may or may not be in the form of key presses in that some sort of indication can be produced when the commands are invalid.

In general two types of state machines are developed for appliance control the key press state machine as mentioned above and a process state machine. An example of a typical process state machine is shown in .

The states of the process state machine can be reported to the internal client or external client . However upon inspection it can be seen that the process state machine in does not address events from all possible user inputs i.e. clock set spin speed selection load size option etc . In general the logic in the component for appliance control has a final else clause which handles all other cases which were not pre defined.

It can be desirable for the client to understand the rules governing the state transitions of the control so that the client can avoid sending invalid commands. Accounting for the fact that the client will not typically be sending key press commands the designer must understand that there is no available document or data structure allowing client side validation i.e. validation before the request is sent . Eventually this can lead to client applications that are likely to send a command that the receiving component will not execute due to its validation logic which is based on the exemplary state of .

The solution can have an effect not only on bandwidth usage but also on the overall robustness and end user satisfaction of the application. From a bandwidth perspective it can be stated that a message not resulting in the desired action but rather an error code or retry is a waste of bandwidth when the problem can be prevented. From a user satisfaction perspective applications that prevent the user from making mistakes are generally considered more user friendly than those which allow the user to make mistakes and then use dialog boxes to explain what happened.

Various embodiments of state appropriate commands have been contemplated in accordance with this invention.

Using a client coded rules section a subset of state information is used to develop case logic or an emulation of the state of the control for the purpose of preventing invalid requests. This model typically does not impose change on the control architecture but can have the client and control can easily be out of sync. The rules and logic development can be based on trial and error e.g. code test re code . A client design will rapidly evolve creating poorly designed procedural code.

Using a design time state based API data model a data model is developed such that the client can interpret it and prevent invalid requests. In essence it is a correlation between state and valid op codes op codes are message identifiers . The advantage to this is that the developer of the Op Code or API is also responsible to publish information to the client developer at design time allowing the designer to emulate the state machine on the client. This emulated state machine enables the client application from sending invalid requests. It is necessary for the control to expose each state defined in the API data model. The design time data model requires the control developer to be responsible to communicate state rules governing Op Code usage. The client and control can easily get out of sync because data is not available at runtime. A document must be created which reflects the as written code. This document must be maintained and published. The document must be parsed or converted into client side logic and this does not work all of the time. The appliance state can change just as a command is being sent resulting in an invalid command.

Using a run time state based API data model this solution is identical to the previous with the exception that the data model is not shared between developers at design time but between client and control at runtime. Some additional messaging is required for this data to be communicated from the control. In the runtime data model the control developer must be responsible to communicate state rules governing Op Code usage. A client can discover at runtime the Op Code State correlation definition. The client and control are always in sync and the client and developer activities are optimized no manual translation to from a document. Additional code ROM written once required to marshal and un marshal Op Code state correlation definition. Some network bandwidth required for transmission of data and some start up latency as a result of transmission of data. This does not work all of the time. The state can change just as a command is being sent resulting in an invalid command.

Using a post command acknowledgment enumeration model the three options above have the goal of preventing the command from being issued by client to control in the invalid state. This solution does not attempt this pre emption. Instead this technique allows the client application to send any command at any time. If the command is invalid an acknowledgment will occur so that the client can take appropriate action. This acknowledgment may or may not include an enumerated reason code. In a post command reason code model there is no change imposed on the control architecture but a client is more likely to send commands which will be rejected. The client developer must design a strategy to handle rejection acknowledgment and the end user experience may not be as pleasant due to frequency of rejected command messages.

Using a design time naming convention and source code parsing model which is a combination of the design and runtime data models this has the least impact on the structure of the embedded code as well delivers the desired runtime functionality. It is accomplished by creating a client side parser which can parse the embedded source code and determine the variable to be monitored for each external Op Code. The requirements for this solution are 1 each non diagnostic external command Op Code will have an associated single Boolean variable which represents the permission state required for execution and 2 a naming convention is used such that a parser can associate each permission variable to the corresponding external Op Code. In a source code parsing model the control developer is responsible to communicate state rules governing Op Code usage. A client can discover at runtime the Op Code State correlation definition pending proper versioning and the client and control are always in sync with proper versioning. The extra reference document is not needed however there are non trivial changes to coding practice additional logic to be executed each scan small additional RAM and ROM required and only sophisticated clients are able to parse source code.

Using a learning client model this solution requires no change to the embedded system. In this case the client would learn after each rejected command and build a client side permission map that could over time achieve the desired runtime behavior. In a learning client model there is no change imposed on the control architecture however this assumes that the correct state variables are being evaluated at the time of rejection. If no state variables are being observed then the client cannot learn what caused the rejection.

It has been found that several of these options are preferred embodiments. For now a main preferred embodiment is the runtime API data model. An exemplary beneficiary of this design would be the home control application. The model however requires additional embedded design. And because the current business environment does not create a requirement for this embodiment the post command acknowledgment is adopted until such time that the cost benefit of adopting the runtime API data model also referenced as Taxonomy Engine becomes favorable.

One of the challenges of the software architecture is to provide functionality without impacting the production schedule of the appliance . The software architecture can implement an acknowledged request model. NVORecipeStatus API ID 1 Op Code 1 is a preferred acknowledgment message that the software architecture sends after each message received.

Although the core of the software architecture is independent of any API its purpose for the software architecture is to expose multiple APIs. It is realistic to expect that APIs will be continually added to the software architecture over time. In anticipation of this consideration for API discovery and versioning is made.

It is also conceivable that as the software architecture applications grow the microprocessor resources will not be sufficient to support all the software architecture APIs and functions simultaneously. With the use of compiler directives the software architecture can be configured so that APIs will appear and reappear for the same model over the development life of the machine.

Discovery is a key to the long range success of the software architecture . A fundamental purpose of the software architecture is to act as middle ware between client and control component . Given the scenario described below it will be necessary for clients to query the control to discover what the current capabilities are. If certain capabilities are not present i.e. compile time decision it is desirable for the application to be able to gracefully fail and communicate to the user that the support for the application is not currently compiled into the appliance control software.

There can be dozens of client implementations and dozens of cross platform and platform specific APIs. Compiler directives can be developed to include or exclude certain functions of the software architecture . There may not be space on the control for all possible functions of the software architecture to exist on the microprocessor simultaneously.

Various embodiments of the invention described herein relating to the versioning and discovery methods of APIs are contemplated without departing from the scope of this invention.

Using a model number based discovery model the client is responsible to understand the capabilities of the control. This can be done using client based data structures remote data bases or runtime code delivery vehicles like OSGi which include all relevant information on a particular model number for an appliance . In a model number based discovery model there is no additional requirement on the appliance control. However a model number is not typically assigned at beginning of a product development cycle so it is not available in early software development. Model numbers can be changed due to color schemes branding and other irrelevant factors. Different APIs can be residents on the same model due to compiler directives. The client can be required to be responsible to acquire capabilities definition or equivalent code after discovery.

Using an API ID based discovery model API based discovery does not rely at all on model number but rather defines any product as a collection of well defined interfaces. This technique allows for the same APIs to be resident on multiple products resulting in some reuse. In an API ID based discovery model the reference to API ID compensates for the shortcomings of a model number based approach. This model allows multiple products to share same compiler directives and same API definitions and can promotes sub function reuse of the software architecture . However the client can be responsible to acquire capabilities definition or equivalent code after discovery additional management overhead can be required to maintain and assign unique APIs and additional resources from a control microprocessor can be required to support discovery Op Codes i.e. additional messaging .

Using a capabilities discovery model also referenced as a Taxonomy Engine this model takes API Discovery an additional step. In addition to the ID of an API the client will also request and obtain the data definition corresponding to that API. In other words the client will discover each function call each function calls arguments and all the valid values for each argument. In the capabilities discovery model no secondary lookup is required to acquire capability definition. This model approaches a UPnP or Web Service type concept and sets the foundation for the conversion to LCD screen user interfaces which can be data driven. However this concept may be cost deficient when applied to low margin mechanical key pads and actuators. And to take advantage of this technique the client must develop an interpreter for the capabilities definition which can require more intensive modeling effort by the software architecture sub function developer and significantly more resources from the control microprocessor.

It has been found that at the time this application was prepared an API ID based discovery model is a preferred embodiment. In addition to API ID each API can have a type and a version so that many different permutations of an API can exist over time. This can make the protocol much more flexible e.g. there can be many types of APIs for a particular appliance such as a dryer as well as a different version of each type Dryer API Horizon Dryer Type Version 1 .

Discovery can be initiated in a number of ways according to the invention. On power up each node enabled with the software architecture broadcasts a message on the internal communication network called Publish Node.

Secondly a node at any time can broadcast a message on the internal communication network called Find Nodes. This message will result in all nodes responding with a Publish Node message. This API is discussed in more detail with respect to and the Discovery API.

As discovery is a key to the software architecture versioning is a key to successful discovery. The same rationale used to justify API discovery can be applied to API versioning. Versioning allows the client to find out more information about the API which it has discovered.

During API discovery the API version and type is reported within the same data structure as the API ID. For example a simple number bumping approach can be employed. Further a one or two byte or n byte data structure for API ID and a version number are contemplated.

In eventing architectures connection integrity is an issue whereas in polling architectures connection integrity is inherent. In eventing architecture the client can successfully register to listen for feedback such as for a temperature reading . Once registration is complete the client relies on the control for notification of changes to temperature. As such the client would interpret a network problem as a constant temperature. By contrast in a polling architecture the client would constantly ask the control for temperature feedback the response or lack thereof would immediately indicate the integrity of the connection.

Using an optional heartbeat model to perform connection integrity a client must register for a network based heartbeat. Using an automatic heartbeat model the software architecture produces a heartbeat automatically when a notification registration buffer is not null. Heartbeats can be broadcast messages or messages directed at a specific node.

In an optional heartbeat model if there is an instance when it is not needed the heartbeat can be eliminated. In instances where it is needed a client must configure the software architecture to produce a heartbeat. In an automatic heartbeat model there is no effort required for desired functionality the software architecture is inherently robust. In a broadcast heartbeat fewer messages need to be sent a custom heartbeat can be accomplished through time based event updates and it has simpler implementation. However this can result in message handling from other network nodes which are not participating in the software architecture collaboration. Also nodes not properly handling broadcast messages can misinterpret incoming messages. In a directed heartbeat model only enabled nodes need to handle the software architecture application protocol. However more messages can be sent using a directed heartbeat model.

For this invention it has been found that a preferred embodiment is a heartbeat for connection integrity and specifically a broadcast messages can be used for a heartbeat. Clients that do not prefer the broadcast heartbeat rate can alternately use a periodic time based NVO event update instead. Making the heartbeat automatic can lessen the burden on the client. With respect to the APIs contained in the software architecture the following functions are supported as part of the Core API Id 1 Heartbeat Message Set Heartbeat Period. The heartbeat is preferably automatically initiated with a default period upon receipt of the first message from a client .

An additional optional preferable method for connection integrity can be introduced into the software architecture . It has been found that as the application of the software architecture proliferated it was determined that an additional method of connection integrity was needed. Using the heartbeat method for connection integrity is appropriate for many application scenarios. This method is chosen because it represents a good tradeoff between utilization of bandwidth and confidence level of the event source. However it is possible that an event message sent by the software architecture will fail to be processed by the intended event subscriber even when the event subscriber did not detect a missing heartbeat. In this case the event subscriber cannot detect failure and therefore cannot take corrective action. The corrective action in the case of a detected missing heartbeat is that the event subscriber may request that the event source re send all or a sub set of all events so that the event subscriber has the most current data. To address this potential undetected failure mode a second method of connection integrity has been made available through the software architecture . The method known as acknowledged events allows the integrity of each event message to be individually managed. illustrates the functionality of the acknowledged event. Further details concerning acknowledged events are described in the descriptions of .

Configurable asynchronous processes are powerful but can fail when configured beyond their physical processing and bandwidth limits. Mechanisms are introduced to prevent saturation in four known failure scenarios inbound invalid requests inbound valid requests outbound message events and a power up condition.

Inbound Invalid Requests. It is likely that the client will format and send a request that cannot be properly parsed or understood by the control or may be invalid per the state of the control.

Inbound Valid Requests. Without consideration the client may ask the control to do a second task before the control has been able to process the first.

In a buffering model a receive buffer could be used allowing the client to send many requests without concern for the control s ability to service them. In this model the client has no responsibility even though the implementation of this model is simpler. However buffering does not solve the flow control problem it only delays or makes the problem less likely or less frequent and buffering requires more RAM.

In a flow control model messaging can be used so that the client is required to wait until a control is ready before sending a second request. In a flow control model the flow control problem is solved robustly and failure modes are eliminated. However a client must implement a flow control protocol.

In an acknowledged request model a control provides a response either positive or negative to each client request. In an acknowledged request model this model allows a client to develop simple re try or recovery scenarios. However this model requires more bandwidth for the acknowledgments and additional ROM and design is required.

In an unacknowledged request model client requests are un acknowledged a client must use state information to determine if the command succeeded. In the unacknowledged request model less bandwidth and ROM is employed. However application user experience can suffer a client application has no indication if an issued command was successful and therefore cannot automate retries and a user will notice an unsuccessful command and need to manually replicate the command actions.

It has been determined that a preferred embodiment of this invention is a flow control protocol with an acknowledged command model. Moreover acknowledgments can be enumerated such that a client process can develop the most robust recovery scenarios as possible. Because the acknowledgement message previously mentioned in this invention provides the API and op code for the acknowledged command a client can discern the command being responded to. This prevents confusion in a multiple control board network in which multiple control boards inside of an appliance all utilize the software architecture . Flow control and command acknowledgment are techniques which allow the client to send data as rapidly as possible without saturating the control. The benefits can be very responsive applications without introducing unnecessary latency or unexpected application failures.

The flow control benefits are achieved using publish Acknowledgement API Id 1 Op Code . Each command is acknowledged with a publish Acknowledgment response. A new command is only allowed after receipt of a publish Acknowledgment value of READY or UNSUPPORTED. Publish Acknowledgment has the state machine for command flow control as shown in .

Outbound Messages Events Feedbacks . During each scan of the microcontroller the DAQ of software architecture collects byte arrays representing the events that must be sent out on the bus see PROCESS DAQ EVENTS state of . The DAQ of software architecture is configurable as shown in and therefore it is possible that the client or clients could configure the software architecture to transmit more data than is possible for the bandwidth of the communication bus i.e. over configuration .

In order to prevent this a configuration limit model can be employed which would limit the ability of clients to configure the software architecture to avoid this problem. In a buffering model the software architecture can be equipped with a transmit buffer. In a saturation message model the software architecture detects when there is too much data presented to the transport layer such that the data may not be sent to the client. In a require re initiation model event distribution is suspended and an event saturation message is send out and or broadcasted. Eventing is resumed once a SendEvents e.g. 255 ALL message is received. In a no re initiation model a saturation message is sent out and or broadcasted and then the software architecture continues eventing.

In the transmit buffer model the client has no responsibility and client implementation is simpler. However buffering does not solve problem it only delays or make problem less likely or less frequent and requires more RAM.

In the configuration limit model this model would prevent problem so that a recovery process is not necessary it is impossible to derive a configuration limit and the limit is based on machine state transitions which are of a random nature relative to the software architecture .

In the saturation message model the client can detect that the software architecture was unable to submit new data to the internal communication network on at least one scan. The client is unable to determine if data was missed and the saturation message does not necessarily mean there was failure only the possibility of missed data.

In the no re initiation model the client has no responsibility however the client developer is not forced to implement saturation recovery process the client developer can not be aware that events can be dropped due to over configuration of the software architecture . This type of failure is not catastrophic and therefore client applications may be oblivious to the loss of data.

In the require re initiation model the client developer must consider the saturation failure and its implication to the application this prevents transient hard to find bugs and the failure modes are catastrophic and or obvious. However the client must implement a saturation recovery process and there may be momentary latency during a required re initiation process.

In a do nothing model unnecessary work is avoided but an unforeseen situation may arise causing client developer to spend time troubleshooting something which can be diagnosed pro grammatically.

It has been determined that a saturation message that does not require re initiation to be available via compiler directive is a preferred embodiment of this invention. The saturation message must be successfully transmitted before further events are put into the transport layer transmit buffer. The following messaging functions are supported as part of the software architecture Debug API API Id 4 get Saturated and Register for Saturation Message.

As shown in packet structure all packets of the software architecture use a Cmd Fb flag enabling the possibility of namespace conflict. Thus it is possible to overlap op codes under the same API using the Cmd Fb flag for discernment.

Power Up Condition. If the software architecture node experiences a transient loss of power or micro reset it might be possible for the client to have an incorrect snapshot for the software architecture modules variables. For robust operation the software architecture can notify its client that the previously exported variables can no longer be considered valid. When considering the transient condition the configuration of the software architecture could potentially be stored in non volatile memory which would allow for the automatic resumption of communication.

In a broadcast message model the software architecture can send a special broadcast message notifying all clients to dump their cache upon power up. It is understood that some applications of client may not need to consider this failure mode and therefore would not make use of the special message. It is also known that the software architecture s software operating environment could experience a failure resulting in a reset of its internal memory and a recovery within the heartbeat period. With only the heartbeat as a means of detection this fast recovery would obfuscate the probability that the client s memory holding copies of certain values from the memory of the software operating environment of the software architecture would no longer correspond to the current values within the memory of the software operating environment. To address this failure scenario a power up message can be included in the software architecture . This message is independent of the heartbeat and would indicate to any client that any previously held values of the memory of the software operating environment of the software architecture would be most probably be invalid and that the client should through the use of the sendEvent message of API Op Code re acquire the current values. It is also understood that the client should suspend or modify any logic or calculations which operate on these memory values in an appropriate way until the current values are re acquired.

In a loss of heartbeat model the software architecture can discontinue its heartbeat allowing the client to determine the proper failure mode action. However as described above loss of heartbeat model does not cover all failure scenarios. This is especially true when using the automatic resumption model.

In an automatic resumption model the software architecture can automatically resume normal operation from the last known state after a power up or reset. In the automatic resumption model the client may misinterpret the information received as state transitions that did not occur. In other words for some State A existing before a Reset or Power up and some State B which is the initial power up State without additional indication of a State I representing power up or reset the client may interpret a State A to State B transition as occurring without having passed through State I.

In a require re initiation model a client developer must consider the scenario of the preceding paragraph and its implication to the application. This can prevent transient hard to find bugs because the failure is catastrophic and as such easily identified and fixed. However the client must implement transient recovery process and there can be a momentary latency during re subscription data re acquisition process.

It has been determined that a loss of heartbeat model requiring re subscription after a power up reset is a preferred embodiment of this invention. The advantage of a special broadcast message indicative of the state of initial conditions is also understood to be a useful indication when the resources within the software operating environment allow for such additional feature. Even though the heartbeat mechanism can be made to approximate the utility of a power up message mechanism by making the heartbeat time out small a preferred solution will include a power up message when resource constraints of the software operating system are not prohibitive. For this reason the software architecture supports as an optional feature a power up message which is API Id 3 Op Code 2 publishSANode. Re subscription can be required because the dynamic event triggers are stored in RAM and will be lost on a power up.

Preferably the software architecture module does not send any messages out until it has detected a client except the optional power up message publishSANode. A client is detected by the receipt of a valid command. Once the client is detected a configurable heartbeat message begins broadcasting and the software architecture is then ready for normal operation. Therefore if the host microprocessor for the software architecture experiences a power up RESET the client will be notified by sensing the absence of the Heartbeat message see API Id Op Code 2 and optionally sensing the message publishSANode see API Id 3 and Op Code 2 .

The DAQ of of the software architecture provides several distinct advantages over a commercially available DAQ systems. The software architecture can expose any variable in the microprocessor memory. In general this will also include the I O signals of interest. Prior art DAQs cannot do that. The software architecture is available to production machines via a single 3 wire plug whereas prior art DAQs or emulators require more wiring or harnessing. Prior art DAQs are not practical in the context of a consumer field test. The software architecture can be deployed on the production system. The software architecture coupled with a modem can provide remote monitoring.

The most fundamental aspect making the software architecture different from prior art devices is that it runs as a blocking subroutine SA ProcessOutgoingEvents of and called synchronously from the main function of the microprocessor. This insures that the client can have within the limits of network bandwidth a complete scan by scan snapshot of microprocessor memory exactly as the execution engine of the microprocessor scanned it. This opens up many interesting possibilities ranging from low cost emulation and debugging to hybrid algorithm development using the software architecture to enable PC aided co processing with the production electronics.

A comparison of asynchronous data collection and synchronous data collection methods will now be described. In asynchronous collection 

7. Client calculates C C A B 23 77 this combination of A and B never occurred on the microprocessor .

Most applications will work with asynchronous data collection. It is simple and straight forward. However problems associated with asynchronous collection are extremely time consuming to debug and identify.

In synchronous collection the client defines or registers A and B with the software architecture . This allows the software architecture to maintain coordinated values of A and B on every scan.

With synchronous data collection the data collection is robust and virtually bulletproof. It enables applications which have not yet been conceptualized and allows for real time debugging of production software w o special coding on the production electronics. However additional RAM is required on the control to maintain snapshots of client care about variable or property list.

It has been determined that the software architecture preferably can support and promote the synchronous data collection technique. However asynchronous memory polling is available in the Core API API ID 1 .

With the synchronous data collection technique being employed the concept of bounded updates should be discussed. Bounded updates are events that are grouped together as a snapshot of the appliance state taken during the same scan of the host microprocessor s Main loop execution. The appliance control main loop will allow for an iterative update of feedback variables that are registered with the DAQ API e.g. every 25 ms . Each registered variable is monitored and only those that change value according to their memory monitor change operator are broadcast as updates to the client. When updates are in the process of being broadcast no new updates are allowed in order to preserve the snapshot in time. A snapshot is communicated to the client using the MMP flag in Byte of the software architecture header as shown in the packet structure in .

While the MMP of the packet structure of is true more messages are pending for the snapshot. When MMP is false the current message is the last message in the snapshot. Therefore if the first message of a snapshot is the only message in that snapshot MMP will be false.

The example in illustrates a bounded command Cycle Temperature MMP with acknowledgements followed by two consecutive bounded updates. Where bounded refers to elements of protocol which indicate to the receiver that more messages are coming from the source and that data processing by the application logic of the receiving component should be delayed until the bounding indicators of the protocol within the packet structure MMP bit indicate a complete transaction at which time data processing by the application logic is permitted. The bounded command is shown by reference numeral and the two consecutive bounded updates are shown by reference numbers and respectively. Notice that updates do not begin until bounded command execution is complete providing the client the ability to filter away transient feedback data. Bounded commands are provided by the same mechanism MMP found in the packet structure as bounded updates in order to provide applications a greater level of control.

The example of is conceptual. The actual mechanism is MMP found in the packet structure . However for illustrative purpose the bounded command begins with an initial begin command initiator MMP set and includes commands to set a washer cycle to wash a recipe status to ready a water temperature to medium again a recipe status to ready and finally a cycle start indicator followed by a command terminator MMP unset . It can be noted that in updates such as by eventing are disabled to prevent updates from happening before the bounded command is complete. In addition a process command indicator is shown periodically throughout the bounded command processing in the appliance to illustrate the portions of the command issued from the client through the internal communications network are processed.

In the bounded updates the updates are once again enabled since they were disabled at the beginning of the bounded command to allow the appliance to report its status to the client . In the example shown in bounded updates the acknowledgment state is shown to ready the cycle is reported as wash the state is reported as running the basket is reported as fill the pump is reported as on and the temperature is reported as medium. Again beginning and terminating indicators enclose the bounded update . These beginning and terminating indicators can be reported by use of the flag MMP in the application packet structure as discussed in or another method which would be apparent to one skilled in the art of network protocol.

In the bounded update the basket is reported as agitate the pump is reported as off and the motor is reported as on. Again beginning and terminating indicators MMP enclose the bounded update .

In almost all cases the appliance is controlled by an integrated keypad. The embedded software handles the key presses or user events generated by the keypad and action is taken. In effect the key press handling function s are the API for the appliances. In other embodiments a second API can be developed for an external client .

In a key press model to use the Key Press API the external client can create virtual key presses and transmit those over the network. The external client can be designed with the knowledge of the integrated keypad so that these key presses can be generated correctly. This requires an external network interface card to generate key presses. In this model no modification is needed for the underlying keypad programming. However the client must monitor the current keypad state in order to determine the key presses needed to achieve a desired state. The Client API must change if the design of the key pad changes rather than machine capabilities. This architecture breaks best practices of software development by interposing a presentation tier between a middle tier and the persistence tier. Extended commands can be included for energy management service diagnostic testing and the like that are not available in the basic keypad interface. A logical API can be used while leveraging as much as possible the validation code associated with the key press handling routines without needing to duplicate code.

In a logical API model by contrast the logical API is developed from an abstraction of the machines capabilities rather than the design of the keypad. For example Bake on a European oven using key presses might require that the client read the encoder position of the cycle dial and programmatically change the encoder to correspond to a Bake setting. If using a logical API the client need only send the Op Code for set Cycle with the enumeration value for Bake 0x01 0x01 setCycle Bake . In the logical API model the client need not be concerned with the keypad state keypad design or key press handling routines. The API remains independent of changes to the keypad design allows for extended commands and is an industry best practice.

It has been determined that the software architecture will use a logical API which is integrated with the key press handling routines. The logical API exposes many of the extended commands which enable various value added applications. In the appliance control when a key on the user interface is pressed or an external command is issued it is directly mapped to a Logical API function call as a common entry point e.g. when the WASH key is pressed or an external WASH network command is issued will both call the SetCycle WASH function in a washer with the software architecture installed thereon . A Logical API function aims to describe a set of functionality in a parameterized manner so that it can be re used. For example non logical specialized functions for temperature might be IncrementTemp or DecrementTemp which cannot easily be used to set the temp to any value. But a logical API function can be SetTemperature newTemp or temp or temp . This last function can be used by both key presses and external commands.

A command handler for the software architecture can comprise a method for the embedded software to response to either logic commands e.g. setCycle bake or key presses e.g. pressing the Bake button on an oven appliance . The method translates incoming key presses and results in an invocation of the appropriate function within the logical API.

As much validation and state based logic as possible exists inside this Logical API function so that external commands are treated the same and execute the same code as key presses. This API can be implemented without a major redesign of appliance control software. Only the Customer Interface Manager software must be reorganized and grouped to call API functions as the entry point for each key press command. This is not a requirement of the software architecture however. It only serves to minimize the amount of code that must be written. If a collection of Logical API functions is not available to the external command engine then validation and state logic found scattered in the appliance control must be duplicated for each external command resulting in larger code size and increased possibility for error.

The discussion above on API Versioning and Discovery established a benefit for a mechanism to discover the APIs resident on any one node having the software architecture installed thereon. Taken to the next step there are additional considerations 

Multiple Nodes. It is probable that multiple components on the network will implement the software architecture . Therefore considerations should be made for networks with multiple components which implement the software architecture .

In a fa ade pattern model the fa ade pattern is used to create simple access to a collection of objects. This is done by creating an interposing software layer between the client and the various target objects so that the client has a simple interface to a single object. This single source is then responsible to forward requests to the appropriate target object. In the fa ade pattern model this model is easier to manage because the API is centrally defined. In most applications the fa ade presents a simpler interface to the client. However this model requires compile time design to include other nodes APIs into the fa ade node. Additional RAM ROM can be required for the fa ade to handle and forward requests to the target node. And if two nodes are clients to one another then the fa ade pattern would create unneeded processing as the fa ade node would first make request through its own fa ade only to forward those to the target node.

In a distributed services model this method uses discovery protocol as the means for the client to find the target objects. The client is responsible for the independent interaction with each target object. In other words the client will discover the software architecture node s and then will interrogate each as to what API s are supported by each node. In the distributed service model this model scales well such that components can be plugged together at runtime. However this model can require multiple documents to manage the network variable definitions APIs .

It has been determined that the software architecture will use the distributed service model for managing multiple enabled nodes on the network . The fa ade approach can be undesirable because changes to the target object API require changes to the fa ade change compile download test . Whereas in a single compile time environment supported by good re factoring tools fa ade could be a good choice. In a distributed environment the more flexible distributed service model will allow for faster development and flexible configurations. However in some cases there may not be enough resources on each microprocessor in the system to support the software architecture . In other cases there may be legacy protocol and there is no desire to make modifications to a legacy board. In these cases fa ade can be a good alternative to the distributed service model.

Multiple Clients. As shown in multiple nodes or clients on the network will implement the software architecture . Therefore considerations should be made for networks with multiple occurrences of . One major consideration is that of event registration and notification. If multiple clients register with the software architecture for events the software architecture should be able to manage the event distribution.

Using a node ID directed message eventing model the software architecture will store the node ID s of each event requestor such that when that event is triggered a directed message will be sent to the requesting node s . In this model messages are only sent to nodes that care about the event. However this model requires one byte per message to store the node ID and requires more RAM to create additional memory structures for each requesting node.

In a node ID directed message eventing with API ID Identifier using this approach the software architecture stores the node ID s of each event requestor such that when that event is triggered a directed message is sent to the requesting node s . In addition the API ID of the host node is included in the event. This model allows the client transport layer to better route messages internally. However this model also requires one byte per message to store the API ID and requires more RAM to create additional memory structures for each requesting node.

In a broadcast message eventing model using this approach the software architecture does not track the node ID of the event requester. When the event is triggered the software architecture sends a broadcast message. In this model the software architecture implementation is simpler and smaller there is no need to spend one byte per message to store the Node ID. However broadcasting can create unnecessary event processing by other nodes.

A forth hybrid approach which is the preferred approach comprises a model where broadcast messages are used which eliminates the need to store node Id. However the client will include API Id and Op Code in the Event Creation Messages of the DAQ API Id Op Codes such that they are dynamically assigned as discussed in the paragraph below . Using this approach the resultant event message will contain the assigned API Id and Op Code as shown in the publishEvent message of API Id 1 In this message publishEvent the API Id and Op Codes of Bytes and of in are those assigned by the client using the event creation messages cited above .

It has been determined that the software architecture described herein will use the broadcast messaging model which includes the API ID and Op Code. This will provide the benefit of routing by trading API ID storage for node ID storage. Given the discussion on SAP below the risk of broadcast messaging is much lessened. Although some amount of processing will be used by the nodes to discard irrelevant messages it is superior to directed messages which could eventually cause saturation of the network and of the software architecture code. Including the API ID allows the client to configure the control with dynamic APIs which will encourage better modular designs in the future.

Using the Same API on Multiple Nodes. It is probable that some optional network component will implement the same API as does the UI or Appliance Manager board i.e. service diagnostic or energy . This will allow the optional network component to manifest itself to an external client . Thus the software architecture can permit the client to interact with two physical nodes each implementing the same API. This design consideration is at the intersection of several others and likewise its resolution is a combination of pre existing design solutions.

Optional nodes are possible through dynamic membership. The client will be able to find out which nodes support the packet structure through the discovery API see . Each node may be interrogated to find out what APIs are supported through discovery as well. Op codes are not globally unique but the internal communication network node id coupled with the API ID and the Op Code are unique. The API ID is embedded into each event.

To summarize the client may first discover the software architecture nodes and then discover the support APIs of each. The client may then initiate an interaction with each API of each node. As each packet includes both the node ID and the API ID both client and target will be able to avoid namespace conflicts and route messages to the appropriate application space.

Multiple Instances of APIs on the same Network Node. There are appliance designs which lend themselves to API re use on the same microprocessor. Examples would include a double oven i.e. two separately controlled baking chambers or a two compartment refrigerated drawer. In other words in some cases there are multiple cavities that perform the same function and can therefore be controlled via the same API. The design approach for this case is discussed.

In a unique function name model the designer will create an API ID that has unique Op Codes for each command or variable without concern for re using the definition. In other words Op Code lower oven set temp and Op Code upper oven set temp. In this unique function names model there is less messaging during discovery. However this model does not promote modular design and code reuse.

In a multiple API ID model the designer uses the same Op Code definition but will designate a unique API ID for each instance of the API. In other words upper oven API Id 1 lower oven API Id 2. In this model there is less messaging during discovery and this model promotes modular design and reuse. However this model will result in consuming the available API IDs at a faster rate.

In an instance ID model the software architecture dynamically assigns the API ID to each instance of the API except for the first instance. The first instance of the API will be identified by a global API ID repository. To enable this the software architecture specifies API IDs e.g. 246 255 as reserved APIs for dynamic assignment to API instances. This model promotes modular design and code reuse and does not consume API IDs. However there is more messaging during discovery.

The software architecture is an object oriented protocol designed to allow objects to discover and collaborate with each other in a robust manner. Basic to these requirements are 1 collaboration entities must be uniquely addressable so that messages can be appropriately routed on the network and 2 collaboration entities must be uniquely identifiable so their messaging contracts rules for interaction and compatibility concerns may be understood. In a single runtime environment the compiler is capable to enforce item 2 . In a networked or distributed environment embedded compilers do not generally address item 2 .

Collaboration entity object or API addressing uniqueness is governed by the combination of a 3 bit node ID found in the address field of the protocol packet structure in and an 8 bit API or Instance ID found in byte of packet structure in . Any network message containing these two pieces of information can be correctly routed. This provides for 255 unique collaboration entities or objects for each network node.

Entity identification is defined by an 8 bit API ID a class identifier a 2 byte type ID sub class or specialization and a 2 byte version ID where the type ID is representative of intent and the version ID is representative of compatibility

This two tiered approach recognizes uniqueness of addressing separately from uniqueness of identification. This separation provides for a more efficient use of bandwidth by removing four bytes of identification information from each packet. In turn the client must cache the identification information and index it by the eleven total bits of address.

It has been determined that the Instance ID model is a preferred embodiment of this invention. The Discovery API API ID 3 has support for the Instance ID in messages Publish API Info Get Instance Info and Publish Instance Info. Instancing is a very powerful concept which can be exemplified by its use in the protocol.

API Op Code Namespace. Messages on a serial network generally have a ASCII or numeric identifier which allow the receiver of the message to route the data contained in the message to the appropriate internal function. This function will then operate on the remaining data in the payload.

The remaining data in the payload is defined at design time in a document. This document describes the meaning of each bit and or byte in the payload. From this internal software message handlers are developed specifically for each payload definition. Therefore there is in general one message handler for each unique Op Code and Cmd Fb pair.

Normally if there were multiple independent payload definitions that shared the same Op Code without any additional identification mechanism it would be impossible for the receiver to route that message to the appropriate message handler. However this invention provides the Cmd Fb flag to support the overlap of Op Codes using the flag for differentiation. Thus this invention provides the functionality to overlap a command and its corresponding feedback message using the same Op Code.

This section discusses techniques that can be employed to provide unique identification to message payload definitions.

In a globally unique Op Code model using this approach Op Codes must be globally unique. In other words each platform or API developer must be allocated an Op Code range e.g. 350 385 which must not overlap with the Op Code range of any other project. This model is inefficient due to range allocations which require spare IDs. Further API developers will not have control over their Op Code numbering scheme and this model requires an order of magnitude more coordinated decisions information handoff .

In a globally unique API ID model using this approach Op Codes are grouped into logical collections forming an API. The API will be assigned a globally unique ID composed of API Id Type and Version. Therefore thy Op Codes therein need only be unique within the API. In this model there is no need for allocated spare IDs API developers can start at Op Code 1 and this model requires less information coordination to avoid namespace conflicts.

It has been found that this invention employs the globally unique API ID strategy as a preferred embodiment. Certain fixed Op Codes which are part of the software architecture Core API revert to the common starting number 1 and the Core API can preferably be assigned an API Id of 1 .

SAP Assignment. SAP found in the protocol packet structure identifies the structure of the payload portion or SDU . It is the same concept as an API ID which was introduced earlier herein. The advantages of SAP are also the same in that incoming messages need to be identified and routed to the correct internal handlers or quickly discarded. In the example WIDE network discussed herein there are sixteen available SAPs. The software architecture fits the criteria for SAP membership. In this scenario the internal communication network administrator can approve the software architecture application protocol and assign the software architecture an official SAP. Other network identifiers for the protocol packet structure are contemplated without departing from the scope of this invention. For example the software architecture can be assigned a default SAP of 1 on the internal network .

A SAP or other sub protocol identifier allows the internal communication network node to participate in the software architecture and non architecture messaging. The software architecture SAP fits into global architecture and adds more scope to the software architecture . The internal communication network SAP is a sound concept from both a technical and practical perspective. Securing a network specific ID provides the software architecture with global visibility and official acceptance which can help to proliferate its use and propel it to a global standard.

The software architecture Discovery . In the previous section it was established that the software architecture s API ID is analogous to the internal communication network s SAP. Likewise in previous sections it is established that it is advantageous for the client to discover by interrogation the API s which reside on each physical node of the software architecture .

A similar question and or solution can be presented for the software architecture discovery. If a service tool wanted to dynamically discover all of the software architecture API s it would first need to discover the node IDs of the internal communication network node s which supported the software architecture protocol. This can be accomplished by a broadcast message model that sends a broadcast command that the nodes will respond to. In this model the software architecture can broadcast a new API which is added to the software architecture or can broadcast the addition of new network node s that implements the software architecture . The Discovery API of can serve as the mechanism for the software architecture discovery. There can be both a polling discovery message and an unsolicited broadcast message available as is discussed with respect to the Discovery API API ID 3 .

The frag flag which can comprises bit of byte in the software architecture header enables the software architecture to send payloads greater than that of the underlying protocol i.e. that of the internal communication network . When the frag flag is set the receiver should realize that the current message will be fragmented into multiple packets or fragments.

In the message fragment id model the first fragment of a fragmented message uses the standard packet structure as described in . This initial fragment provides the message s API Op Code and Cmd Fb flag. All subsequent fragments of the message will preferably assume the fragmented message structure described in . In this structure the frag flag still exists along with the MMP flag to reinforce the data. However byte now contains the more fragments pending flag MFP in bit message ID MID in bits and fragment ID FID in bits .

The MFP flag informs the receiver that at least one more fragment of the current message should be expected. The transition of MFP from 1 to 0 informs the receiver that the current packet is the final packet of the current message. MID provides an 2 bit identifier for each message. Thus each fragmented message group of fragments will be assigned a MID and this MID will then increment for each subsequent fragmented message group of fragments . The MID will increment to 3 and then rollover back to 0. FID provides a 3 bit identifier for each fragment within a message. Thus for a particular message the first fragment will always be assigned and FID of 0. For each subsequent fragment of that message the FID will be incremented. The FID will increment to 7 and then rollover back to 0.

The fragmentation protocol provided by this invention allows the receiver to check the integrity of a fragmented message. By monitoring the frag and MFP flag the receiver can ensure no erroneous halts to a fragmented message. By checking that the MID does not change within reception of a single fragmented message the receiver can ensure that two separate fragmented messages do not become merged perhaps due to a lost fragment . By checking that the FID correcting increments per fragment the receiver can ensure that not fragment is lost within a message or received out of order . See for an example of the message fragment id model.

In a summary CRC model this solution makes use of a well known existing cyclic redundancy checksum CRC concept. An additional two byte CRC can be appended to the last payload of a multi payload message. The CRC is the CRC representation of all payload bytes concatenated into a single combined payload. The sender generates this CRC. The receiver validates this CRC according to well known methods. In this summary CRC model this solution re uses existing CRC algorithms which are established and well known however the CRC algorithm is more complex than frame counter and the CRC may not be easily portable to a third party vendor.

Therefore it has been determined that the message fragment id model is a preferred embodiment for confirming multi payload message integrity in the software architecture according to the invention. The message fragment id model is easier to implement for third parties and is easier to add to the existing architecture .

With respect to the software architecture the code organization and implementation files will now be discussed with respect to . is a schematic illustration showing the software architecture of according to the invention in relation to the software operating environment A of a component containing various software components B wherein the software architecture comprises a command handler an update handler and an internal communications network layer interface for interconnecting the software architecture to the internal communications network software operating layer A which creates and sends data over the communications network of the household appliance . Also shown is an example of how other software components B within the software operating environment A would invoke on and interact with the components of the software architecture and .

In order to create a more generic implementation of the software operating environment A dependency upon the UI Manager which is one of several software components B within the software operating environment A can be eliminated. In this implementation a main controller software component B executes the invocation onto the command handler . It was previously believed that the previous implementation afforded more accurate and robust performance of the software architecture due to the particular timing details associated with the execution timing associated with the UI Manager software component B.

To define the first level of detail for the software architecture three main software components B sub components are shown the update handler the command handler and the internal communications network layer interface . The update handler interacts with the DAQ engine in order to identify information flagged for updates within the operation of the DAQ such that the internal communications network layer interface can process said information resulting in interaction with internal communications network software operating layer A resulting in a packet structure transmitted onto network . The command handler validates and processes incoming commands from the internal communications network layer interface invoking onto the appropriate software operating function according to the Identifiers API Id and Op Code values of packet structure . The internal communications network layer interface is meant to decouple as much as practicable the particulars of the software architecture from the internal communications network software operating layer A the network of and the packet structure of . The internal communications network layer interface interfaces with the internal communications network software operating layer A which creates and sends data according to the definition of over the communications network of the household appliance .

Software operating layer sub components and of the software architecture shown in work together to manage communications with other components or clients which also have the software architecture or an alternative capable to interact with packet structure .

SACore.c .h. This file for the software architecture core software contains the update handler and command handler which processes commands manages flow control feedback and takes snapshots of appliance data for dynamic updates.

SAAppSpecific.c .h. This file for the software architecture core software contains appliance specific command handlers and command implementations for driving a particular type of appliance such as a file specifically directed for management and communication with a washing machine for example . Any command that is not generic to all appliances is implemented in this function. These commands are enumerated in SA prm.h and are called by the command handler.

SAWideComm.c .h. This file contains the internal communication network application layer which provides the interface to the internal communication network protocol and controls bounding of messages into snapshots parsing incoming commands and processing update flags to send out update messages.

SADaq.c .h. These files contain all functionality for the DAQ engine . Thus all functionality concerning the update handler and eventing is contained here.

SADiscovery.c .h. These files contain all functionality for a node implementing the software architecture to discover other nodes and the corresponding functionality of other nodes which implement the software architecture .

SAVariableMap.h. This file contains the embedded variable map which allows for event creation by an external client without knowledge of a variables address in memory.

The table following this paragraph illustrates a documentation example of how APIs will be managed including the mechanism of Compiler Directives to control the deployment of the functionality exposed through the APIs of the software architecture .

In the above table API Ids in the 241 254 range can be used without consideration for standards. They are intended to allow a designer the flexibility to use the software architecture in an application where the expectation of re use is minimal. In such cases this will eliminate the need to develop a specific API Id and Type for a collection of messages which are expected to be a one off . These Ids can also be used for candidate standard APIs which have not yet received their official ID. Additionally in the above table the RAM and ROM estimates are taken using Motorola HC08 Cosmic Compiler version 4.3f with the software architecture configured to have 30 dynamic events allowed i.e. heap size 300 bytes 7 APIs defined and a maximum command size of 15 bytes.

Prior to describing the collaboration examples a description of the structure of should aid in the understanding of the collaboration examples. Each software operating environment A contains representations of a sub set of useful software operating components B including the software architecture internal communications network layer interface a sub component of the software architecture the DAQ and a hardware abstraction layer .

The hardware abstraction layer comprises a mechanism to encapsulate the particular fixed address of the connected electrical circuits on which the software operating layers of the hardware abstraction layer will operate. The hardware abstraction layer uses software interfaces A or to encapsulate occurrences of B in the form of one of the following the packetized representation an ordered collection of bytes of a message in the form of application packet structure exchanged by the software architecture the packetized representation an ordered collection of bytes of a message exchanged by the software architecture representing only the packet structure A the valid data arguments expected by the software operating component or or an alternate representation of either application packet structure or packet structure A where the intent and data values and resultant actions are functionally identical but not of the form of an ordered collection of bytes. The alternate representation is in the form of a unique software function having arguments represented by individual named variables whose value are derived from A or represented by an ordered collection of bytes derived from A.

Application GDMs are variants of software components B known as global design modules which are standard software operating components having been subjected to a standard development process including functional and non functional requirements testing documentation and implementation guidelines. Application GDMs address appliance specific concerns such as defrosters heaters door closure. Application GDMs can be classified in at least two variants. The first variant contains specific application logic apart from the application logic used to govern the behavior and gather information from a collection of other software operating components including a plurality of other GDMs . The second variant contains specific application logic apart from the application logic used to govern the behavior and gather information from a specific electro mechanical device or sensor such as a heater evaporator motor valve solenoid relay pressure or temperature sensor. The second variant can be configured to address specific concerns made relevant by the specific manufacture s variant of the device by the particular configuration of the device based on the usage mode determined by the application requirements i.e. scaling values or by a confluence of factors which create specific concerns not mentioned heretofore.

Infrastructure GDMs address specific recurring concerns which are independent of the application of the system architecture of . They can be re used across a plurality of appliances such as refrigerators cooktops dishwasher dryers clothes washers etc. Infrastructure GDMs can be classified in at least two variants. The first variant is associated with a particular concern resulting from a recurring combination of electrical components or electrical constraints. Some examples are manufacture interface constraints device duty cycles electrical load characteristics examples of which are inrush and steady state current limits or other constraint such as the mode of analog conversion to digital examples of which are 4 20 mA current loops vs. 0 5Vdc analog voltage feedbacks. The second variant is associated with appliance and application independent software components known as utility functions. They provide logic used by other B components including application logic and hardware abstraction layer . The second variant may contain or use references to the first variant of the infrastructure GDM . Examples include timers zero cross detection and other useful software components whose purpose is more utilitarian than driven by application or electro mechanical requirements.

An embedded virtual router provides an encapsulating layer by which architectural dependencies the method by which one software component B is accessed by or exposed to another B examples of B are within or between at least two software operating environments connected by the network alone or a combination of network and other networks between the application logic of the software operating environment A of the component and the components comprised by the hardware abstraction layer DAQ another instance of application logic or component therein or any other useful component B are minimized or eliminated.

A software component used by other software components B to obtain references to any other software components B where the referenced software component B may be part of a software operating environment A existing in or on the same hardware component a different hardware component connected by the network an external client connected by a combination of network segments including the network or a different hardware component of a different appliance connected by the network or a combination of different network segments between the two appliances and the network of the first appliance .

The software component also provides the mechanisms for other software components B residing within the same software operating environment A to publish the necessary identification and or routing information into the memory of such to enable the aforementioned enumerated uses of . The identification and routing information may be associated with components residing within the same software operating environment A or the identification and routing information may be associated with components apart from the components residing within the same software operating environment but are known by components residing within the same software operating environment.

Structures in the memory of are able to receive messages or provide functions for invocation of messages and are able to send messages or provide callback functions for the distribution of information. These structures having an access definition of A or corresponding to an occurrence of a software component B such as components within or any other useful software component located in the aforementioned enumerations of and the capability to route the information to that software component B or to an appropriate intermediate software component B having the same or similar purpose of .

Looking now at the possible collaboration examples it is expected that the structures of will be created and populated based on discovery queries containing requests for access to specific software components B which are both identifiable and routable invocations implying said access or by software components B which are able to invoke on on behalf of themselves or other components B resulting in creation and population of structures .

Collaboration a command is issued by software component of the right hand software operating environment A and received by a software component contained in the collection of with an identifier of API within component of the same software operating environment. Using the identification and routing information contained within the component identified by API transmits the received information through the other local software operating layers and and finally transmitted over and received by of left hand software operating environment. The message is then handled by and routed to the appropriate component within of the left hand software operating environment. The appropriate of the left hand software operating component using identification and routing information contained within of the same software operating component then invokes on or sends the message to the local implementation of API contained in the left hand software operating environments hardware abstraction layer . Thus the application logic within software component B of the right hand software operating environment invoked a function implemented in the software operating environment of the left hand side without information contained therein for the realization of said invocation. Therefore the value of the design implied by is that application logic is re useable with respect to the location of the of the other software operating components B within a plurality of software operating environments A connected by a network or a plurality of network segments which may include .

Collaboration In this case the initiation of the message is from of the left hand software operating environment A. Illustrated is the case where the final invocation is on a software component in this case API within the same software operating environment using the same methodology described in greater detail in Collaboration . Therefore in Collaboration an alternative architectural disposition between an occurrence of Application logic to some other useful software component API of Hardware abstraction Layer is shown to have no effect on the implementation of either. And furthermore it is the purpose of software component also being able to comply with the Identification and interface requirements imposed by the software architecture to provide this capability.

Collaborations show additional uses for the Embedded Virtual Router . The mechanisms used to accomplish these variants are the same as described in Collaborations and . They are included to illustrate the usefulness of the design and the expected additional message patterns to be available with respect to the DAQ . Local event listeners and remote event listeners of Application Logic are provided with an interconnection to a representation of the DAQ engine providing not only a connection to the DAQ in the local software operating environment but also to the DAQ s which reside in remote operating environments. DAQ generated messages based on the occurrence of DAQ events can be transmitted locally and remotely through mechanisms available in .

In an extended application of the embedded virtual router illustrated in an appliance is connected to external clients and a second appliance by a plurality of networks. A first network comprises a first internal client a second internal client and the external client . A second network comprises the external client . And a third network comprises the second appliance . Each client is characterized as a node on the respective network. Local clients are clients that communicate with nodes on the same network. Remote clients are clients not directly coupled to the same network as the node to which they are communicating. In this embodiment external client would be a remote client of the nodes on the first network .

Each client node comprises a software architecture driver SA driver for exchanging messages with any node having a software architecture SA thereon. The nodes on any given network are in operable communication with the other nodes in that network and are optionally in communication with the nodes present on other networks.

The appliance further comprises at least one node having the SA thereon. The second appliance will also likely have a node with the SA on it and may have one or more clients as well. The first network also comprises the node .

Smart couplers are special devices that connect to the appliance and or to a network and or to two or more networks and communicate therebetween. Each smart coupler can comprise all the functionality of a node and each node can comprise all of the functionality of a coupler. In the embodiment shown in the coupler couples the second network to the third network and can function as a node on each network. The smart coupler couples the second network to the first network . It could also be considered as coupled to the appliance . A smart coupler can comprise a processor memory fixed and or removable software components and circuitry coupled to at least one transmission media. The smart coupler is configured to take information from the memory of its processor and with the circuitry and components produce a signal representing that information onto a transmission media. A smart coupler can also comprise a source of power a GFA sensor an opto isolation circuit a converter circuit an interface expander network health analyzing circuitry and software.

The smart coupler can be used to communicatively couple at least one external client to a network of the appliance such that the external client and the appliance can exchange messages therebetween. The external client and the smart coupler can each comprise a network. If desired multiple external clients can be communicatively coupled to the appliance using one or more smart couplers.

Either of the couplers can propagate discovery messages issued by the SA or an SA driver across the networks in order to enable the SA and SA drivers or their coupled arbitrary software components to develop references to identifiers of functionality for the different nodes. Each coupler can have a routing table stored in a memory for enabling communication between nodes on different networks. The memory can also store identifiers identifying the functionality of each node. The identifiers can be linked to the routing information held within the routing tables so that when a message comprising an identifier is sent to either of the couplers the coupler receiving the message can send the message to the appropriate next node.

Each node can comprise a unique combination of software elements. The software elements on any given node include at least one of the SA and an SA driver. The SA driver enables a node to communicate with the SA. The SA inherently includes an SA driver or a variant of the SA Driver. Each node comprising the SA can communicate with other nodes comprising the SA. However a node can have both the SA and separate SA driver thereon. Each node must also include a suitable communication protocol or communication protocol driver for the respective network type to which it is coupled. An exemplary protocol is the WIDE network protocol a proprietary appliance network protocol utilized by Whirlpool Corporation. For a client not having WIDE network protocol that needs to communicate WIDE messages e.g. external client a WIDE driver can be used. A port driver couples the external client to the network .

Each node can also comprise one or more arbitrary software components. Here each node is shown as having two arbitrary software components. Thus node has arbitrary software components A and A node has arbitrary software components B and B node has arbitrary software components C and C node has arbitrary software components D and D and node has arbitrary software components E and E. The SA driver is a software element configured to allow an arbitrary software component to communicate with the SA over at least one network. An arbitrary software component is any software component or subcomponent that performs a useful function. Examples include but are not limited to a communication driver an application a user interface a control algorithm message routing a control for an operational cycle message handling data storage data transformation data referencing and software that instructs other software. The SA driver can receive and at least partially interpret messages from the SA and or from another SA driver which are specified as feedback events. In some instances the SA driver can also send command messages to the SA . In this respect the external clients can have full capability act as an accessory to communicate with and to enhance or alter the operation of the appliance.

It will be understood that any or all of the external clients the couplers and the internal clients can be physical devices that have a processor a memory software circuitry and some source of power. In the general sense they are coupled to transmission media and are preferably configured to take information from the memory and with the processor and the circuitry produce a signal representing that information in the transmission media. When the information includes an identifier in memory the node or client is discoverable by other nodes connected via the transmission media.

Discovery is a process by which a first node in communication with at least one coupled network sends discovery messages to the network or networks. Discovery messages generally comprise at least some query information specifying what the sender of the discovery message seeks. The information sought can be information such as another node an appliance a client an arbitrary software component a device comprising a node a coupler or one or more of a plurality of identifiable software elements on any node.

A discovery confirmation message is a reply message sent to the sender of a discovery message. Discovery reply messages typically comprise confirmation information and identification information. The confirmation information is an acknowledgment in the form of a positive or a negative response. The identification information is information enabling the sender to send subsequent messages to that which has been discovered. The identification information could be raw routing information or could be an identifier which could be used to pull raw routing information out of a routing table. Further the identification information could be an identifier used to get raw routing information from a routing table and other functional identification information out of a routing table. With the ability to create routing tables either by the method of propagated discovery or by a combination of propagated discovery and manual or semi manual configuration clients can establish useful communications with other communicating nodes and can rely on the propagated message and the routing table to enable the useful communications without the arbitrary software components of the clients to have knowledge of the routing information required to enable the useful communication.

Where more than one network is connected by a smart coupler such as couplers a message received by the smart coupler from one network can be propagated and sent to the second network. The smart coupler may create a second separate message with the same information compatible for a second network but together the first and the second messages are considered a single propagated message even though they may be literally two messages. A propagated discovery message then is a discovery message that is propagated to a receiver. A coupler may be configured to inspect propagated messages to prevent propagation of a circular message i.e. a sent message that is also received by the sender on a second network to which the sender is coupled.

See for example illustrating a system where resources in an appliance can be monitored managed or changed as in the energy controller accessory of . A likely scenario has a coupler connected to an appliance by a network . The coupler also connects to a coupler via network that may be a different type of network from network . Coupler connects to a source of information about resources used or generated by the appliance by a third network that may be a different type of network from either network or network . Assume that the source wants to send information about the resource to the appliance . The invention enables a node in the source on network to communicate with a second node having SA for example which may be among several on the appliance . We assume that the source has at least an appropriate communication driver or one of the couplers has software to translate any message from the source to the communication protocols of the incorporated PCT US2006 022420 for example.

In this scenario the source sends a discovery message over the network seeking any consumer of resources to which the source wants to send information. The coupler receives the discovery message translates the message if necessary and propagates the discovery message to the next nodes over the network including coupler . Coupler receives the discovery message translates the message if necessary and propagates the discovery message to the next nodes over the network including the appliance . The relevant nodes in the appliance evaluate the message and determine a discovery reply message and send respective replies. Here we assume at least one reply is positive.

The discovery reply message is received by the coupler which populates its routing table and sends it to the coupler which populates its routing table and sends it to the source in accord with the foregoing process. Each node retains the relevant identifiers so that subsequent message can be communicated without repeating the discovery sequence. As well those nodes with memory such as the couplers can be configured to save messages.

With this structure a source of information about a resource such as electricity hot water gray water gas water replaceable parts or other consumables can request a change in the operation of the appliance based on the information. For example if an electric utility is facing a brownout a source of information about the electricity can request that an electric dryer not commence an operation for a period of time. Similarly a source of consumables such as filters or spare parts can ascertain from an appliance the status of the consumable and send information about the timing and availability of replacement.

At least the smart coupler can hold a routing table constructed from a plurality of discovery confirmation messages. In one embodiment the routing table holds identifiers from other nodes with each identifiers routing information. In a second embodiment the routing table holds identifiers from other nodes with each identifier s routing information and with a new identifier that will be used to represent the identifiers from other nodes. The new identifier can be considered a proxy identifier.

In a third embodiment the routing table can have software function pointers linking the arbitrary software component to the functional identifiers and associated routing information instead of proxy identifiers. As stated previously nodes can have the same functionality as couplers. This embodiment is an exemplary embodiment where the routing table is coupling an arbitrary software component to another arbitrary software component or to a routing table held by a coupler or to second arbitrary software component on another node.

In addition to the six collaboration examples a seventh collaboration example includes first and second arbitrary software components comprised within the application logic where both the first and second arbitrary software components have identifiers and can be identified within the structures which can comprise the routing table. In this collaboration the first arbitrary software component sends a message to the second arbitrary software component by invoking a software function linked to a plurality of function pointers within the routing table. One of the function pointers of the plurality of function pointers links the message to at least the second arbitrary software component. Likewise if there is a second instance of the second arbitrary software component residing in the application logic of the first arbitrary software component function invocation may not change. In this case the plurality of function pointers would include a pointer linking the invocation to routing information contained in the routing table. The routing information is necessary for enabling the message to be routed from the invocation to the receiving second instance of the second arbitrary software component.

It is preferred that the routing tables are populated by one of at least discovery confirmation messages propagated discovery confirmation messages manual configuration semi manual configuration hard coded configuration software and the software compilation process. It should be noted that using discovery messages to populate routing tables is the preferred embodiment. However routing tables can also be populated using conventional configuration methods involving a manual or semi manual configuration process such as with the use of a visual configurator see for example used for another purpose . In addition a manual or semi manual configuration process can be used in addition to discovery generated routing tables. In this approach the discovery process or the configuration process can incrementally add or delete routing information within a routing table.

The various techniques described above with respect to the use of the embedded virtual router can also be applied in a variety of other network configurations in order to enable communication between objects in the system. Examples include but are not limited to enabling communication between two different arbitrary software components within an application logic an arbitrary software component of an application logic and an arbitrary software component of a hardware abstraction layer any arbitrary software component of a first processor and any arbitrary software component of a second processor on the same component any arbitrary software component of a first processor and any arbitrary software component of a second processor on different components within an appliance any arbitrary software component of a first processor and any arbitrary software component of a second processor on different components in different appliances any arbitrary software component of a first processor and any arbitrary software component of a second processor on different computers where the computers can be dislocated from one another but coupled via a network.

It should be understood that the arbitrary software components above are preferably associated with an identifier associated with the functionality of the software component a class and with an arbitrary identifier used as an object handle. A comprehensive namespace can contain unique identifiers for each arbitrary software component on the system. An exemplary namespace can create identifiers comprising a class ID including of an API ID an instance ID and a type ID and an object ID comprising a node ID and an instance ID. Other namespaces can use any desired combination of identifiers to give each arbitrary software component a unique identifier.

Various examples of the connectors and protocols RS 232 wireless WIDE etc. are shown within the components of each client which communicate with one another along an internal network on each component appliance and persistence node . In summary the persistence node is a logical entity which is discoverable and useable by all components sharing a network or a runtime connection. This entity will provide services and protocol mechanisms necessary to read write and store information.

As discussed above appliances are state driven machines and typically have a user interface e.g. a keypad using which a user can effect a change in state of the appliance e.g. change a washer from an idle state to a wash state . As applications are developed that require external communication with an appliance e.g. testing diagnostics remote control etc. there are three possible techniques to perform this interface 1 translate external commands into key presses see and discussion 2 use custom software to execute state change commands see and discussion or 3 simply translate key presses into a logical API see and discussion .

In an new method of operating and testing an appliance is a schematic illustration of the interaction of user initiated key presses and externally fed software commands typically from a client are both passed as arguments to the software architecture of according to the invention for issuing commands to a household appliance to for example test household appliance functionality and or change the state i.e. actual operation of the household appliance .

The method discussed with respect to is novel because instead of translating external messages treating the appliance as a closed system it exposes the functionality of the appliance independently of whether the message is received as an external key press or a software command local or remote to the appliance . The messages commands are processed through an API of the software architecture now an open system as opposed to the prior art closed system while preserving key press validation and feedback to the user.

Currently appliance control software is not set up to validate and execute external commands. To remedy this an appliance API is defined that includes both user functionality as well as low level machine control commands. During normal operations when a key is pressed or an external command is issued it is directly mapped to an user functionality API function call as a common entry point e.g. a WASH key is pressed on a user interface keypad or an external WASH command is issued will both call a setCycle WASH function immediately regardless of the state of the appliance . All validation and state based behavior will exist inside this function so that external commands are treated the same end execute the same code as key presses .

This API can be implemented without a major redesign of appliance control software. Only a user interface software would need to be reorganized to call API functions as the entry point for any command instead of just reacting to key presses inside of the state machine . Use of this method of enables the manufacture of an appliance to test and diagnose the keypad user interface separately. This saves time and effort in development diagnosis and testing of appliances. This will also eliminate the need for complex mechanical keypad actuation devices as well as mechanical actuation harnesses which were conventionally used to test user interfaces and appliance functionality.

In addition the appliance API contains a command to send the appliance into a diagnostic or factory test mode. In this mode all state based behavior and command validation code is disabled to allow for a low level API. API commands in this mode can access and control low level parts of the appliance such as reading and writing to EEPROM pressing keys reading sensor values writing to cycle parameters actuating relays and other actuators etc.

The API interface discussed with respect to the software architecture is an object oriented software package that is effective when one object appliance functionality has multiple clients that need to interact with it e.g. both key presses and external commands . This is a new approach because appliances do not currently contain object oriented software and are generally thought of as being a closed system and having only one client user interface keys. This invention contemplates that appliances will have many clients through the introduction of an internal communication bus i.e. network and external connectivity . These clients may include web applications diagnostic tools testing tools and home automation systems among others.

Appliances with the API software architecture described herein will be future proofed and ready for many advanced remote applications that customers may request. These can include energy management improved service and diagnostics tools and remote control and monitoring. In addition since the API is the entry point into all appliance functionality customers can benefit from improved automated development testing and factory testing of appliances .

The software architecture also contemplates that the virtual device model can be aware of the current capabilities of the physical device the appliance . For example if an oven is baking the appliance clock cannot be modified. Capabilities synchronization is a general solution meant to allow a virtual model to recognize changes to the capabilities of a device based on its state.

Currently this purpose is achieved through code which is written per appliance . The solution contained in the software architecture replaces device specific code with a general solution. This solution is comprised of additional messages which the software architecture broadcast containing the current set of invalid commands API and Op Code . This information is evaluated at runtime so that the user interface will be expressed in such a way that the user may only modify those device characteristics which are modifiable so that the customer is not given the opportunity to modify a device characteristic which is currently immutable as dictated by the actual device.

The software architecture is a cross product system of applications and tools. These applications help to increase both quality and speed to market in the product development process. This is done by interacting with the data that is stored in memory inside the appliance .

In order to stay flexible configurable and generic the applications interact with the appliance by specifying numeric memory locations addresses which are required. Each time the software in the appliance changes however these locations in memory can move around and take on a very different meaning. In order to solve this problem a variable map file standard and generator were created.

The variable map file generator takes the software names textual descriptions written in code and associates them with the numeric address and size of that piece of data. It then outputs this information in a standard file format. This is executed each time the code is changed and compiled. The information in this standard file provides independence from both the compiler and from where data is located in memory.

The variable map file is then read by any application that wants to interact with a software architecture based appliance . Applications are coded against the meaningful textual names of data rather than the numeric addresses of data which greatly simplifies application development.

1. An engineer builds an application coded against the textual descriptive names of meaningful data located in the appliance control.

3. An engineer compiles the new appliance code which also automatically generates an associated variable map file. The new code and variable map file are deployed together.

4. When the application is run against the new code it does not have to change as long as it has the proper variable map file.

5. If new data is required by the application it can be easily identified or retrieved from the variable map file.

Thus as shown above the development engineer need only remember the Variable Name column in the table above and not need to constantly look up the constantly changing address values in the Address columns above.

Referring now to the household appliance which is shown as an oven for exemplary purposes having an internal communication bus can be electrically coupled to an external network through a network interface card NIC similar to the aforementioned network interface connector . A NIC is a well known device that connects a computer or other client to a network and any suitable NIC can be utilized with the appliance . According to one embodiment of the invention the NIC is electrically connected to the internal communication bus and adapts an internal communication bus protocol to a standard communication protocol such as TCP IP and GSM so that the appliance can communicate with an external client not shown through the external network such as a local area network LAN and or a wide area network WAN . Thus the external client can communicate with the software architecture associated with various internal components of the appliance that reside on the internal network . For example the appliance in is shown as comprising a user interface UI and a sensor actuator board each comprising a printed circuit board PCB with the corresponding software architecture and the external client can communicate with the software architectures through the NIC .

The NIC can be mounted to the communication bus which is preferably externally exposed of the appliance through any suitable mounting means as is well known in the computer network art. According to one embodiment of the invention the communication bus is located in a recess defining an opening that is flush with a wall such as a rear wall of the appliance as shown in . When the communication bus is located within the recess the communication bus and the NIC when mounted to the communication bus are protected from damage that can occur during transport of the appliance .

The NIC can be supplied with the appliance at the time of manufacture or can be purchased separately from the appliance as an accessory. Thus a customer can choose to purchase the appliance without the capability to connect to the external network and upgrade the appliance at a later time to add connectivity if desired.

The NIC can communicate with the external network through a wired connection or wirelessly. For example the NIC can communicate with the external network via wireless infrared IR communications or other short range wireless means. In such situations the NIC is preferably mounted to a front side of the appliance to facilitate robust communication. According to one embodiment of the invention the NIC can be mounted in a recess at the front side of the appliance as illustrated in with respect to an oven for example. When mounted to the front side of the appliance the NIC can be connected to a rear side of the appliance via wires disposed in a wiring conduit that extends from the mounting recess at the front side to the rear side of the appliance where the wires enter the appliance .

Another example of wireless communication is radio frequency RF communication. For example a RF printed circuit board PCB can be located inside the appliance which requires connection between the RF PCB and an externally mounted antenna. Alternatively the RF PCB can be mounted externally of the appliance but this configuration requires an electrical connection between the RF PCB and appliance control electronics and an installer must open a cabinet or case of the appliance during installation of the RF PCB . According to one embodiment of the invention the RF PCB is mounted within the appliance and a non metallic safety barrier that is a poor conductor of heat and electricity is provided as part of the appliance case . An exemplary safety barrier is a plastic window such as a Plexiglas window integrated with the appliance case as shown in for an appliance in the form of an oven for illustrative purposes. The safety barrier allows for RF communication with the internally mounted RF PCB without an external antenna and prevents human contact with excessive heat or electricity.

Referring now to the appliance can be configured with hardware to facilitate service and diagnostics of the appliance . In one embodiment a service module adapted to removably connect with a standard communication bus on the appliance is configured to record diagnostic data such as by communicating with the software architecture on the internal network . The service module can readily connect to the internal network . The connection of the service module to the appliance is represented by step in . The service module is then removed from the appliance and connected to a personal computer such as through a USB port or other suitable standard communication bus. The connection of the service module to the computer is represented by step in . After the service module is connected to the computer the service module connects to the Internet preferably automatically and uploads the diagnostic data to a remote client not shown as indicated by step in . The remote client processes the diagnostic data to identify an appliance problem or failure and potentially prevent a service call or if the problem or failure requires a service call to optimize the effectiveness and efficiency of the service call. Optionally the service module can download customized testing scripts based on the diagnostic data to run tests on the appliance to further diagnose or eliminate the problem or failure. Reconnection of the service module to the appliance to execute the testing scripts is represented by step in .

An exemplary architecture for the service module is illustrated schematically in . The service module comprises a pair of communication buses such as external serial buses. According to the illustrated embodiment the service module comprises a USB at one end for connection to the personal computer and an RS 232 EIA 232 bus at an opposite end for connection to the appliance and particularly to the software architecture residing on various nodes of the appliance internal network . The service module further comprises memory such as flash memory for storing the diagnostic data the testing scripts and other data. The flash memory communicates with a service logic that controls the operation of the service module .

Referring now to the service module for use with the system shown in is similar to the service module illustrated in except that the USB is replaced with a telephone line plug such as an RJ11 plug for connecting a modem of the service module with the telephone line to establish a connection to the Internet.

The service modules described above can be supplied with the appliance at the time of manufacture or sold as an accessory during or after the sale of the appliance . Other various types of accessory modules can be provided with the appliance or purchased later by a customer for upgrading the appliance . An exemplary accessory module can comprise a display operably connectable to the internal network and the external network and visible to the user when mounted to the appliance . The display can communicate various data the user including but not limited to data such as operational status related to the appliance and obtained via the software architecture on the internal network or information downloaded from the Internet through the external network . An exemplary accessory module is a weather station module which is shown in as mounted to an appliance in the form of a refrigerator for illustrative purposes. In addition to displaying weather related information or other information that can be downloaded from the external network the display of the weather station module can also include one or more touch pads or a touch screen with selector areas for controlling various operations of the refrigerator such as for controlling an ice dispenser and a light and for accessing settings such as temperature of the refrigerator.

For the entirety of a fragmented message the flag should bet set. The MFP flag more fragments pending should be set until the final fragment of the fragmented message. MID message id gives each fragmented message the group of fragments a handle or id preventing merging of separate fragmented message. FID fragment id gives each fragment of a fragmented message a handle or id allowing the detection of a lost fragment. A more in depth explanation can be found in the discussion on multi payload message integrity.

Variable map information in relates variable symbolic names to their address in the memory of A. relates variable identifiers API Id and Op Code to their address in the memory of . The rational for the alternate architectures is that these support both interactions with a human actor who might find it advantageous to work in symbolic names which tend to be meaningful and communicate will the usefulness of the variable and interactions with other instances of the software architecture or some component or or some other software component which is able to interact with the software architecture . In software based interactions non human interactions it is advantageous not to use symbolic names as they require more memory to store more bandwidth to transmit and more computational cycles to process. Instead numeric identifiers can be substituted for symbolic names. The software architecture uses the numeric identifier API ID and Op Codes as numeric substitutes for symbolic names. Additional numeric identification is available for any valid occurrence of API Id. Where the former numeric identification is sufficient to provide a unique index per component residing on the network and where the latter the additional identification information can be obtained using a secondary query requiring a component of the former numeric identification API Id. Then together API Id and the additional numeric identification the latter provides identification unique within the totality of possible software components able to be represented within the software architecture .

In this way the invention has the ability to disable and re enable the realization of the NVOEvents of onto the internal communication network . In addition the ability to disable and re enable the realization of the NVOEvents of as internal messages sent to software component B within the same software operating environment A of the software architecture .

Preferably all nodes start with an access level of Access Denied by default. In this access level the node is only allowed to execute the commands in front of the firewall. Thus commands behind the firewall or listed in the firewall table are not allowed to be executed. Upon successful submission of a permanent password within the payload of the Publish Node feedback message a node is promoted to the Access Granted security level. In this access level the node is allowed to execute all commands in front of and behind the firewall. For temporary access behind the firewall a node can successfully submit a temporary access password within the payload of the Publish Node feedback message . In this access level the node is given access to all commands in front of and behind the firewall for a configurable amount of time. After this time has expired the node s access level is reverted to its previous state.

Specifically contemplates two passwords each representing a security level recognized by the logic of the command firewall. A password will be transmitted by a component or client when the message of the DAQ API publish SA Node is broadcast see bytes and or Op Code . One of the passwords represents permanent access to all special commands that are considered to be behind the firewall. The second password will grant temporary access to all special commands that are considered to be behind the firewall. Without a password clients will have access to all commands which are considered to be in front of the firewall. The engineer responsible for the installation of the software architecture onto a component of the household appliance will determine which commands are in front of and which commands are behind the firewall of .

The MAIN function of the software operating environment aA shown in and in invokes on SA WideComm shown in the SA class definition where SA and its aggregate functionality is the Software Architecture . The result of the function invocation is shown in . As shown in MAIN invokes on SA WideComm periodically within the software operating systems execution.

The COMM EXPECTING ACK state of is a result of an outbound event having been initially created with a special indicator denoting acknowledgment required. If the event also referred to as update which is being operated on within the COMM PENDING state requires acknowledgment the state transition from COMM PENDING will be to COMM EXPECTING ACK. In this case the event will be re sent by re entering the COMM PENDING state if a time out has expired without receipt of the expected Acknowledgment message. This process will be repeated until either an Acknowledgement is received or until the configurable retry parameter MAX EVENT RETRY which is incremented each time the event is re transmitted is exceeded.

The purpose of the functionality represented by is to evaluate the structures NVOEvent of determining if the conditions for event transmission have occurred collecting those and setting the appropriate flags Updates Pending Bounded Update so that when the State Machines of are executing events conditions detected by the DAQ are realized as WIDE Packets onto the WIDE bus .

A typical prior art approach to using a new controlling device to control an appliance is to have the software component of the new controlling device duplicate the logic of the appliance controller so that the new controlling device does not inadvertently request the software component of the appliance controller to perform an operation of which it is incapable. This prior art approach further requires communications between the appliance and the new controlling device regarding the current state of the appliance. This prior art approach is inefficient since it requires a lot of overhead on the new controlling device and takes time to be loaded on to the new controlling device and translated into a form understandable by the new controlling device. Furthermore this prior art approach requires that a variant of the software component for the appliance controller must be constructed for each new appliance and each time the appliance gets a new or altered functionality.

The purpose of a control taxonomy is to avoid requiring this duplication of software logic often called business logic between two interacting software components in a controlling device and a controlled appliance. In particular this permits a command generator in a controlling device to readily control an appliance without any information about the appliance being controlled except the control taxonomy itself. This can increase the flexibility of introducing generic control devices to control new appliances adapting control devices to newly available cycles or functionalities which have been added to an appliance and switching appliances between modes of operation where different operating cycles or functionalities are available. It also makes control of appliances easier for users since they need only be presented with choices which are currently available from the appliance.

The present invention uses a structured taxonomy dataset to efficiently communicate to the controlling device just that information which the controlling device needs in order to generate a well formed command for the appliance. As used herein a well formed command is a command which has meaning and is performable by the appliance. The information conveyed by the dataset includes a hierarchy of options and data inputs required to form the well formed command. In the preferred embodiment it also includes semantic or contextual information to communicate in word or iconic form the available options so that a user can understand the available choices and enter the appropriate data. This is preferably accomplished by labels within the dataset that are associated with arbitrary or non user friendly identification elements. This allows the logic of the software componentry which must interpret and process the taxonomy to be decoupled from the presentation of the taxonomy on a user interface e.g. foreign language labels units .

Referring to the generally illustrating the improved control structure and method of the present invention the appliance being controlled has a software component B having a appliance controller and status generator. The controlling device used to control the appliance has a software component B with a command generator a selection builder and a status interpreter. The controlling device may be a programmable user interface such as a PDA web tablet a cell phone an LCD attached to the appliance or a client device.

The taxonomy architecture shown disposed in the appliance controller and logic may alternatively be disposed in a remote location such as in a controlling device or on the internet. The taxonomy architecture includes a taxonomy generator a taxonomy engine a taxonomy translator and a taxonomy structure. The taxonomy architecture generates a taxonomy dataset defining taxonomy capabilities facilitating the creation by the software component of well formed commands that can be executed by software component . Each of these components and their interrelationships are described in greater detail below.

The taxonomy dataset is derived from the operational capabilities of the appliance controller structured in a manner to allow the command generator in the software component to interpret the dataset to accomplish several results. More particularly from time to time the taxonomy engine uses the taxonomy structure and the state aware information to generate a taxonomy dataset reflective of the subset of the universe of options for commands that would be available from an appliance to those that are currently available from the appliance.

For example the taxonomy dataset describes the available functions supported by a software component B each functions argument and the valid values of each argument in a data structure. In addition taxonomy dataset defines the valid values of feedback variables. Since this in a data structure it can be transmitted and re transmitted to clients or as required. Changes to taxonomy dataset occur as the cycles of operation progress and the available commands or the valid values of their arguments change. Moreover additional commands may become available or may become invalid as the cycle of operation progresses from Idle see .

More particularly the selection builder registers with the taxonomy manager to receive notifications for new taxonomy engines. In response the taxonomy manager passes references to all known taxonomy engines back to the selection builder. The selection builder then requests from each taxonomy engine a taxonomy capabilities data set. The taxonomy engine evaluates a taxonomy structure comprised by the controller logic of software component or alternatively a document to generate a taxonomy capabilities dataset. The selection builder then populates a set of pseudo command structures appropriate for an application end point and passes those structures to the application end point allowing the application end point to be configured. Examples of application end points are user interfaces for control or service or other intermediate application layers like an energy controller or home automation mode such as vacation or goodnight. Alternatively the selection builder may directly configure the application end point.

When a controlling device is networked with the appliance the taxonomy manager establishes a relationship between the software component and the taxonomy architecture allowing the command generator to query for the existence of taxonomy datasets providing the software architecture access to a taxonomy dataset and allowing the command generator and status interpreter to subscribe to taxonomy dataset updates. The taxonomy translator is an optional component that translates the taxonomy datasets between software components and .

The taxonomy dataset is communicated to the controller of software component and to the selection builder of software component . Optionally the taxonomy translator translates the taxonomy dataset to a different schematic definition of the command generator.

The command generator uses the taxonomy dataset to construct and populate a set commands structures available for selection by a user interface or other client applications comprising a set of valid commands their valid arguments and each arguments valid values. More particularly the command generator uses the taxonomy dataset to construct one or more well formed commands which can then be transmitted to the controller. Since the taxonomy dataset can be reset and sent at different times by the taxonomy engine or the dataset can be updated by revisions from the taxonomy engine the command generator can have a current set of command structures then available for selection by a user interface or other client application.

Thus in essence through use of the taxonomy architecture the software component or its proxy the taxonomy translator communicates to software component a rule set that can be interpreted by software component so that software component does not request something of software component which software component cannot accommodate and does not operate on a state variable which is set to an invalid value.

Before the application end point is able to commence execution it will request or register for status updates with a status interpreter. This will allow the application end point to be populated with valid state variables from the controller before logic is executed and before user interface componentry is rendered. The status interpreter will process taxonomically correct status datasets and validate those datasets against the taxonomy capabilities data set. The status interpreter request or register for status updates from the status generator of software component via the taxonomy engine. Upon receipt of a taxonomically correct status the status interpreter will provide new status values to the application end point.

The application end point executes resulting in a rendering of the current status of software component and a rendering of selectable pseudo command structures. Each time a selection is made from the pseudo command structure the selection builder populates a set of valid sub commands appropriate for the selection for further selection by the application end point. When a complete selection is made a structure containing all pseudo commands are passed to the command generator.

The command generator will construct a taxonomically correct well formed command and optionally via the taxonomy translator invoke the command onto the controller of software component via the taxonomy engine.

The well formed command is delivered to the controller of the appliance and executed by the appliance.

Typically the command will result in a state change to the associated memory of software component which will trigger a status update created by the status generator and resulting in new renderings of state to the application end point. This change in state will result in a new capabilities taxonomy or a partial capabilities taxonomy which can replace portions of the original capabilities taxonomy. The new capabilities taxonomy resulting in a different set of valid selections for controlling the cycles of operation of software component .

The status interpreter uses the taxonomy dataset to validate status updates from the controller or taxonomy translator. The dataset contains information structured in such a way to allow the controller to fully validate incoming commands according the structure without additional logic outside of the dataset. For example the dataset can be conceptually thought of as one or multiple decision trees with each level of the taxonomy forming a different decision branch with each of the options and or data inputs can form a different level. The key presses on the user interface required to select the options and or data inputs in forming the well formed command can be compared against the decision tree to confirm that each key press is found within a common branch on the decision tree. If the key presses are not found then it is an indication that the command contains an error. The taxonomy structure thus serves to populate the user interface with available options and data inputs for a given state of the appliance and also serve as the logic for validating the resulting command.

The taxonomy dataset can be thought of as all available options and settings for an appliance at the current state. For example the appliance comprises multiple components interconnected by the internal network. Each of the components can have one or more devices. Each of the devices has one or more functionalities which has one or more settings. All of the functionalities for all of the devices will not necessarily be available during each state of the appliance. As such the taxonomy dataset will comprise all options and data inputs for all devices that are currently available.

Once the user selects an option from the top level the next level of the hierarchy is exposed to the user based on the top level selection. In the user has selected the COOK option and the user interface then displays data inputs in the form of TIME and POWER LEVEL available for that option and necessary to form the well formed command.

Once the user has selected the options and data inputs from the taxonomy dataset accessed by the user interface the command generator will form the well formed command and send it to software component on component of the appliance for implementation. This is done only after the well formed command has passed through the validation process. The controller and logic of software component then uses the well formed command to control the operation of the devices to effect the well formed command.

A detailed example of the creation of the taxonomy dataset and the well formed command should prove useful. The creation of the taxonomy dataset for the microwave of that discloses multiple cooking cycles was constructed by the selection builder from the taxonomy capabilities dataset as is illustrated in XML as follows 

If the user of the microwave of chooses to Cook for 30 seconds at 90 power with the turntable on a well formed command of the taxonomic schema would be transmitted optionally to the taxonomy translator and to the taxonomy. The command of the form 

The taxonomy engine would then traverse the taxonomy structure to transform the well formed command of the taxonomic schema to a well formed command of the controller of software component of the packet structure . The taxonomy structure is a superset of the taxonomy capabilities dataset. For each specifiable command element above i.e. cycle power duration and turntable an additional collection of key words and values necessary to form packet structure A would be associated within the taxonomy structure. These key words would include API Id Op Code and position index into the packet structure A where position index could be a byte offset or a bit offset.

The taxonomy dataset could be constructed to directly represent the universe of possible commands of the APIs of software architecture providing useful functionality for a service factory or laboratory engineer or technician.

Referring again to it will be understood that the structure illustrated in is more conceptual than physical. show embodiments of the taxonomy architecture of partitioned according to the physical architecture of an appliance or an appliance network as shown for example in .

The software component B in is represented as being within a remote client such as a remote controller with a user interface. Consequently the sub components of software component the selection builder the command generator and the status interpreter are specialized for this user interface application. shows software component in such a user interface device identified here as a thick client. A thick client would have the ability to parse a data structure such as an XML document interpret its meaning and implement the Selection Builder functionality. Software component and the taxonomy architecture reside in the appliance .

It will be apparent from that the selection builder the status interpreter and the command generator found in the software component of is now in the taxonomy translator. Taxonomy translator comprises the selection builder and is responsible for the conversion of taxonomy datasets to software component specific interfaces. Therefore in this example the software components are not comprised with the functionality of interpretation or generation of taxonomy datasets. Rather they are comprised with handling inputs from the translator and sending outputs to the translator.

It is contemplated that a taxonomy architecture through the use of multiple translators can simultaneously connect to software components similar to software component of and software component of .

Looking now at it is generally known that complex data structures have tremendous advantages because they can be easily varied and re used with a single complied source code. But this complexity can be troublesome to understand create troubleshoot debug explain and generally manage. Object oriented languages provide some level of hiding complexity relative to non object oriented languages such as C. Similarly XML data structures are human readable in contrast to byte arrays and therefore can eliminate complexity. But it is currently cost prohibitive to implement technology such as XML or Java in most appliances for domestic use. The invention offers a visual configuration utility that simplifies handling complex data structures at much less cost than known systems.

Following the flow of a designer in step starts the visual configuration utility. A designer can be someone who does the role of product or feature planning user experience or user interface design engineering or anyone else with a need to retrieve value from or provide value to the information contained by an instance of a configuration held within the memory of the visual configuration utility. In step the designer uses the configuration utility. In this step the design will load a configuration file from a persistent store such as a hard drive or database or web site. Alternatively it may be checked out from a document version control system such as visual source save.

In step the designer creates a new configuration comprising a taxonomy structure or begins editing an existing configuration comprising a taxonomy structure. The editing process includes steps like adding new taxonomy elements deleting taxonomy elements moving taxonomy elements or modifying the properties of a taxonomy element. Other sub steps of step may include binding taxonomy elements to message identifiers or functional identifiers of arbitrary software components of which taxonomy elements either relate to or represent. In step the designer will save the taxonomy configuration appropriately and notify the appropriate office mates such that if one of the office mates is the appropriate controls development engineer he may immediately acquire the saved taxonomy configuration file and begin step . In step an appliance controls development engineer will generate a software and software data file appropriately configured such that a compiler can be invoked preferably from the Visual Configuration Utility to create a downloadable image appropriate for execution by a processor. Further the controls development engineer will combine the generated software and software data file with a plurality of other arbitrary software components. Preferably the Visual Configuration Utility can accomplish this task. In step the appliance controls development engineer will invoke the compiler on the combined file and the compiler will generate a downloadable image. And in step the appliance controls development engineer will download the downloadable image to the embedded appliance control processor and test the result. At any step in the process the process actor may stop activities and move another step taking appropriate action to mitigate the incomplete step and or the potential re ordering of steps.

Looking more closely at the example of it can be seen that there is no wash phase definition. This is because a wash phase is not a valid feedback until the appliance is in a running state. In there is no cycle definition. This is because during running the cycle definition cannot be changed.

The data structure of is very powerful and is the heart of the taxonomy architecture. It consists of a nested tree of elements where each element of the tree has a type where that type dictates to the taxonomy operators of how to properly traverse and extract information from the Tree. Attributes should have corresponding Active Values which are one of the child Values of the plurality of child Values. Attributes contain a plurality of child Values which represent the valid selections of the Attribute. A Value which contains a plurality of Attributes is a Value which must be further specified by having each contained Attribute be defined by its contained active or selected Value. When a child Value is selected or active the taxonomy operator looks to see if the child Value contains children of the Attribute type. If so the taxonomy operator continues the tree traversal repeating the function of the taxonomy operator on the next level of the tree. Ranges are children of Attributes and are equivalent to a plurality of Values which can be mathematically derived from the values of min max and inc.

The information contained in the data structures of is therefore more useful than one would at first realize. For example taxonomy operators can be written to do a variety of useful functions across a number of the elements of the taxonomy architecture especially when there is a graphical user interface or an external client. A first taxonomy operator could use the data structure to determine what content should appear on a user interface. As a user makes selections on the user interface the first taxonomy operator could re examine the current active selections of the user and repopulate the user interface with the new valid user selections and the valid options of each. A second taxonomy operator could be informed of changes to the appliance state. Upon change to the state of an appliance the second taxonomy operator could retrieve a new taxonomy capabilities dataset so that the user interface could be repopulated based on the new valid selections and or new valid operators for each. A third taxonomy operator can be configured to receive taxonomically correct inputs and check to see that the input corresponds to a valid well formed command. The third taxonomy operator would accomplish this by walking the taxonomy structure in the taxonomy architecture of . The third taxonomy operator would evaluate all of the potential roots of the taxonomy structure and find a corresponding root identifier in the taxonomically correct input structure. From the root the third taxonomy operator would begin to recourse down the tree determining which branches of the tree to continue down by finding a corresponding identifier in the taxonomically correct input structure. When the third taxonomy operator reaches the end of the tree or alternatively exhausts the elements in the taxonomically correct input structure having used all of them at least once a valid taxonomically correct input structure is determined if both there are no other un accounted for elements in the taxonomically correct input structure and there are no child elements remaining un walked in the taxonomy data structure. This third operation is the equivalent of portable state based business logic enabling the thin client of to be completely devoid of any logic associated with the operation of the appliance. The benefit of this is that user interfaces and all external clients with proper communication and taxonomy dataset interpretation operators can be developed with only knowledge of how to interoperate with taxonomy datasets and therefore can be devoid of all knowledge of the connected device with which it is in operable communication.

It will be seen in that messaging can occur among microprocessors on the same board connected on a network different from . As well messaging can occur between boards on at least two networks where the networks are not of the same type. Further messaging can occur between appliances between boards carried on at least three networks where at least one of the three networks is a network external to the appliance. Yet further the third party device can communicate with nodes implementing SA or nodes that can route messages to a node implementing SA in accord with the invention.

It will be understood that the architectural characteristics of a network configuration normally impact the implementation of the arbitrary software components which communicate within the architecture. By architectural characteristics we refer to the distinctive features of individual networks the way the various boards are interconnected and the combinations of network routes interposed between connected boards . An embedded virtual router in a processor on a board in accord with the invention will enable the arbitrary software components in that board to communicate independently of the architectural characteristics of the associated networks.

An advantage of an embedded virtual router according to the invention can be seen in an appliance having a plurality of useful arbitrary software components each providing at least one useful consumer benefit. Since different consumers typically prefer different combinations of features it has been a long standing problem in the appliance industry to be able to supply only the sub set of specific features that an individual consumer would prefer. Typical approaches include 1 providing multiple appliance models or sku s each with a unique feature set and 2 providing an appliance with the superset of features insuring that the customer can have all the available features. Both are costly because arbitrary software components in appliances are hardware dependent at a minimum software for a board controlling a device in an appliance must be reworked for use in a different appliance even if it is the same or similar device. This invention provides a third more cost effective alternative. With the use of an embedded virtual router according to the invention all arbitrary software components are independent of one another with respect to their architectural location. An appliance manufacturer can thus provide a user specific capability for an appliance at much lowest cost by providing an external client having any combination of arbitrary software components that can be purchased separately as part of an external accessory but with full capacity to participate in all forms of useful communication with other arbitrary software components within the appliance because of the embedded virtual router.

Assume for example an appliance with three possible features a a door switch b an LED and c an LCD either or both of the LED and the LCD to indicate the state of the door switch. All versions of the appliance will have a door switch. But some will have only an LED some will have LCD and some may have both an LED and an LCD. With the prior art the manufacturer has to provide three software architectures one for communication between the door switch and the LED one for communication between the door switch and the LCD and one for communication among the door switch the LED and the LCD. With an embedded virtual router according to the invention designer need only have software architecture for the door switch and an embedded virtual router. An accessory can enable the door switch in any version of the appliance having an embedded virtual router to handle communication with any combination of LED and LCD without further software architecture.

For another example assume an appliance with three controller circuit boards each having a feature. If a manufacturer sought to save costs by combining two features on a single board any costs savings would have be adjusted by the added cost of reconfiguring the software architecture on the third board. A software architecture with an embedded virtual router according to the invention would enable such a change without the necessity of reconfiguring the software architecture.

In an embodiment of the invention embodiment shown in a smart cable comprises a smart coupler enclosed within a length of conduit with connectors and on either end. The smart cable includes wiring between at least one external device and the appliance by way of the smart coupler such that the external client and the appliance are able to exchange information via the smart coupler . Alternatively the smart cable can be hardwired to a network having the external client thereon. The smart cable can comprise any type of transmission line within the length of cable suitable for the purposes described herein. The smart cable can comprise multiple types of cable and is preferably over molded. The advantage of an over molded cable is that it is a single article not subject to inadvertent separation from its component functional parts. This will make the total cost of ownership less and will make the distribution and testing of the smart cable simpler. Examples include but are not limited to multicore cable twinax cable ribbon cable optical fiber twisted pair cable dielectric slabs or electric power lines or any combination thereof.

In another embodiment illustrated in a smart cable comprises an appliance pigtail and an external client pigtail with a smart coupler connected therebetween. Both the appliance pigtail and the external client pigtail comprise a length of cable. The pigtails also include an appliance connector and an external client connector on their respective ends. The connectors are configured to communicatively couple the smart cable to the appliance and to the external client respectively. The pigtails can be permanently coupled to the smart coupler at ends opposite the connectors .

Alternatively as illustrated in the pigtails can be removably coupled to the smart coupler by smart device connectors at ends opposite the appliance connector and the external client connector respectively. The smart device connectors enable the pigtails to be interchanged with other pigtails having smart device connectors on one end and different types of appliance connectors and external client connectors on the other. This facilitates connection of the smart cable to a plurality of different appliances and external devices .

Alternatively appliance connector or can be coupled to a smart connector defined below for the purpose of coupling the smart cables or or a smart wireless coupler to an internal communicating node of the appliance not directly compatible with the interface provided for by or .

The smart cables can be different types of cables in order to accommodate different transmission standards employed by different appliances and external devices . For example if the external device connected to the smart cable uses two wire cable and the appliance connected to the smart cable uses one wire cable the smart cable can comprise a one wire portion of cable and a two wire portion of cable with a suitable converter therebetween. Alternatively the appliance the external client or the smart coupler can comprise a suitable converter for transmitting messages between different types of transmission lines.

Preferably a conventional opto isolation circuit for providing separation between the electrical networks of the coupled devices and is included in some portion of the apparatus comprising the smart cable and any smart connectors interposed between the client and the appliance . Opto isolation requires a 2 wire communication configuration so preferably the opto isolator is provided in the portion of the apparatus where there is 2 wire communications. The opto isolation circuit electrically isolates the appliance from the smart cable . A grid friendly appliance sensor a type of frequency sensor see discussion below can also be included in the smart coupler the appliance or any another node in communication on the network. The grid friendly appliance sensor instructs the appliance when the AC Voltage frequency falls below a given threshold. An exemplary threshold is a lower threshold of 59.95 Hertz when the monitored frequency falls below 59.95 Hertz various loads of the appliance can be instructed or requested to turn off. A software component configured to respond to resource related commands will determine the appropriate response to the information provided by the grid friendly sensor. Generally the software component configured to respond to a resource related command will not compromise the appliance cycle of operation with respect to any consumer benefit.

The smart coupler can be used as the primary smart component within several embodiments. For example it is the smart component within the smart cable . It can also be operated in a stand alone mode. In the stand alone mode the smart coupler can be connected to only one of the appliance and the external client . The smart coupler can receive power from the external client or the appliance in the stand alone mode or it can be powered by an auxiliary power source which will be discussed in more detail hereinafter. The smart coupler is also the primary smart component within the embodiments of and .

Looking now at the smart coupler can also provide information to any software component configured to respond to resource related commands with respect to certain standard energy information signals when it is in communication with a source of information about a resource . Such software component can reside on the smart coupler itself in the appliance in smart coupler in client and or in device . An example of a source of information about a resource would be a power utility that would be in communication with a smart coupler. The signals can include but are not limited to a demand response DR signal instructing a component of the appliance to reduce consumption of the resource a signal indicating time of use pricing of the resource TOU pricing a critical peak pricing of the resource CPP signal indicating a significant short term price increase due to demand exceeding supply or inability of the power grid to handle high energy demands a signal specifying real time pricing RTP and critical peak rebate CPR signals indicating a rebate for reduced consumption at a given time. The software component configured to respond to a resource related command can reside in the smart coupler in the appliance in the source of information about a resource in a second appliance or in any other node in communication with the smart coupler.

Referring again to the smart coupler or smart wireless coupler can also include authentication and encryption capabilities. Authentication serves to validate the connected appliance and or external client and or applications included on the appliance and or on the external client . Encryption acts as a key to unlock and expose the appropriate services to the connected appliance external client or application and prevents the unauthorized use of services which are not exposed and not intended for use by a non authenticated appliance external client or application. The smart coupler whether wired or wireless can include special proprietary electronics that enable communication between the appliance and the external client . As a result unauthorized persons who lack the smart cable or smart wireless coupler cannot couple an unauthorized external client with the appliance.

Any of the connectors or an appliance connection element can be a smart connector. A smart connector is a wired or wireless connector that has specialized circuitry structural adaptations hardware and or software that provide additional functionality beyond that of a conventional connector. Conventional connectors are passive devices that do not modify or examine the packets sent therethrough. The function of a conventional connection is to electrically mate the pins of one connector to the corresponding sockets of another connector. In addition to the conventional function of a connector smart connectors can incorporate one wire to two wire conversion other types of conversion level shifting of the electrical signals power management functionalities protocol translation opto isolation authentication encryption mechanical adaptations or any combination thereof. A smart connector can be more or less permanently connected to an appliance. Smart connectors can be ganged or daisy chained together to provide a composite function from a collection of functions comprised by each individual smart connector. Power management functionalities can include AC DC conversion and the ability to control the amount of power drawn through the smart connector. Smart connectors can also be designed so as to expose additional networks or other points of connectivity for example a smart connector can have a first connection point designed to accept a smart cable as well as a second connection point designed to accept a second cable of a specialized diagnostic device. Preferably the appliance connection element is a smart connector see .

For example the embodiment illustrated in comprises a smart wireless coupler coupled to a smart cable . The smart wireless coupler comprises a first wireless communicating component communicatively coupled to an external client smart device and a second communicating component in communication with the first communicating component and communicatively coupled to a smart coupler of the smart cable . The smart cable comprises the smart coupler and an appliance pigtail similar to the appliance pigtail . The appliance pigtail communicatively couples the smart device to the appliance .

Looking now to the smart coupler comprises a microprocessor having at least one arbitrary software component stored in the memory thereon. The arbitrary software component can be an application or driver stored in memory thereon and accessible by any external clients or other appliances connected to the smart coupler . Preferably the arbitrary software component comprises at least a driver for enabling communication between the smart coupler and a second device coupled to a network on which coupler is also coupled. An exemplary arbitrary software component is an SA driver. Referring again to client can establish minimal functional communications with smart coupler as long as is configured with the proper port driver . Further SA driver or a useful application such as a service and diagnostic software application in the form of an arbitrary software component can be automatically sent to or loaded by client from the memory of smart coupler . In this way a smart coupler can enable connected clients to install software components necessary of full functional communications from the smart couplers with which they are connected or conversely the smart coupler can install the software on the client. Likewise a smart coupler can use the internet connection of its connected clients to retrieve new arbitrary software components for its own internal operation or for further distribution to other any other coupled clients or any appliances . The smart coupler can further comprise any number of additional arbitrary software components.

Looking again at the microprocessor can include any number of elements common to microprocessors such as ROM RAM on chip flash memory transistors and various communication buses. The smart coupler further includes analyzing circuitry and software that monitors physical signals associated with the circuitry coupled to at least one transmission media. This feature can be useful during the diagnosis process because the client can check the health of before commencing any useful diagnosis processes requiring communications with appliance .

The smart coupler can further comprise an alternate power source an interface expander a variable display enabled to display licensable content simultaneous with indications about the information relating to the smart coupler and information about devices with which it is in communication with and a removable memory . The smart coupler can be powered via connection to the external client and or the appliance . When in stand alone mode or at a user s selection the smart coupler can also be powered by the alternate power source which can be electrically isolated from the appliance and or the external client . The alternate power source can be a battery. The alternate power source can also be a connection to another power source such as a wall transformer that can be plugged into a conventional electrical outlet.

The interface expander comprises a plurality of ports for enabling the microprocessor to communicatively couple with a plurality of additional external auxiliary sources of information. Each port can be configured by a port configuration tool in order to communicate with the plurality of external auxiliary sources of information having their own physical connection and protocol requirements. The port configuration tool can reside on a PC and couple to the smart coupler via for example . The importance of the port configuration tool is that it allows the interface expander pin definitions to be redefined by the client . Alternatively the port configuration tool can be stored in the memory of the smart coupler and for uploading by or installing on the client .

The removable memory can also be used to configure the interface expander by using an external client having the port configuration tool thereon to write instructions to the removable memory . Once the removable memory is connected to the smart device the microprocessor can read the instructions on the removable memory and configure the ports accordingly. Examples of the different pin configurations on the interface expander include but are not limited to a general purpose input output a power port a wireless port a USB port a serial ports like SCI SPI or RX TX a ground an analog to digital converter port a plurality of Boolean IO Points analog inputs and outputs configured in the form of 0 5Vdc 10Vdc 4 20 ma PWM outputs. The removable memory can also be used with the smart coupler to deliver upgrades deliver applications store data and event logs deliver and store data about a cycle structure deliver and store information about a resource deliver drivers or other applications to an external client hold data about messages hold data to populate a routing table and hold data about consumables. The display can visually convey information about the status of the smart coupler to a user. An exemplary display can consist of tri color LED lights that produce different patterns depending on the status of the smart coupler. The display can also include an illuminated image depicting a brand name logo or other indicia associated with the appliance.

The interface expander can be configured to couple to any electronic peripheral including sensors data sources and auxiliary communicating nodes. An auxiliary wireless device can be coupled to the interface expander when it is properly configured. It is anticipated that when smart coupler receives a propagated message smart coupler will propagate the message to the networks to which its coupled including any network configured to receive the propagated message that is in communication to the smart coupler coupled to the smart coupler via the interface expander .

Referring now to the smart coupler is directly coupled to appliance connection element on the appliance in a direct mount configuration. In this embodiment smart coupler further has a smart auxiliary wireless communicating component coupled to the smart coupler via the interface expander . In this embodiment the interface expander has at least some of its pins configured as general purpose input Booleans with an associated component of software configured to receive messages from a source of information about a resource. In this embodiment the path of the messages is between the source of information about a resource and a first coupler then between the first coupler and the smart auxiliary wireless device which acts as a second coupler. Then the messaging passes between the smart auxiliary wireless communicating component and the smart coupler directly mounted to the appliance where the transmission media coupling smart auxiliary wireless communicating component to the smart coupler is the Boolean or Binary network provided by the interface expander . The advantage of this network optimally configured for resource messages is that it allows a decoupling point between two complex halves of the network where the first half comprises componentry from the source up to the interface of the interface expander and the second half comprising the interface expander through the appliance . As the configuration of the interface expander in this embodiment is exceedingly simple the information contract comprising the aforementioned exemplary energy management signals DR TOU and the like is most easily and rapidly described promoted and adopted. Further the information contract is advantageous when the messaging architecture and protocols implemented by the smart couplers in communication on either side of that contract are different from one another and where the dissimilarities of the differences are significant from one region of the country to the next or one type of appliance coupler to the next and so on.

The appliance connection element provides access to an internal network of the appliance as is illustrated in . The internal network connects the various internal components of the appliance . The appliance connection element can connect to any internal component of the appliance such as a control board or it can connect directly to the internal network . The appliance connection element can be a standardized connection element integrated into all appliances manufactured by a particular company or it can be a specialized connection element unique to certain models of appliances. A single instance of an appliance typically comprises multiple various and different embodiments of the connection element where there is at least one connection element on each node in communication with the network and at least one additional connection element for connecting external clients such as a smart coupler .

Referring now to an appliance connection element can be a conventional connector or it can be a smart connector. It can be configured to facilitate communication between the appliance and the smart coupler . If the appliance connection element is not structured to receive the desired connector on the smart coupler a suitable connector adapter can be used e.g. a conventional connector or a smart connector. In this way the smart cable or a smart coupler or the Appliance Half of the smart wireless coupler can be connected to any appliance connection element by using a suitable connector adapter. An example would be a converter dongle that plugs into the appliance connection element and provides a suitable port for receiving the connector or see . Another example is an adapter comprising a length of cable with connectors at each end configured to couple to the smart coupler and to the appliance respectively. Adapters and smart connectors can also be used to communicatively couple the external device with the smart coupler. Preferably an appliance comprises an appliance connection element configured as a smart connector and further configured to receive external clients either by a direct mount or by a length of cable and further configured to receive external s installed by the consumer without uninstalling the appliance and without or without significant tool usage.

Smart coupler connects to a source of information about at least one resource generated or used by the appliance and or by a different kind of resource consuming device such as a light switch ceiling fan water heater or the like. The connection between the smart coupler and the source is by a third network that can be a different type of network from either network or network . Assume that the source wants to send information about at least one resource to the appliance or to the device . The information can include a request for a change in the operation of the appliance based on the information. The resource can be electricity hot water gray water gas water replaceable parts or other consumables. The source can send information about multiple resources if desired. The invention enables a source of information about a resource in effective communication with consumers of the resource to affect the level of consumption of that resource. Preferably the source of information about a resource is communicatively coupled to the network to communicate with a second node having SA for example which may be among several on the appliance or on the device . We assume that the source has at least an appropriate communication driver or one of the smart coupler and the connecting element has software to translate any message from the source to the aforementioned communication protocols for example.

In this scenario the source sends a discovery message over the network seeking any consumer of resources to which the source wants to send information. The connecting element receives the discovery message translates the message if necessary and propagates the discovery message to the next nodes over the network including the smart coupler and devices . Coupler receives the discovery message translates the message if necessary and propagates the discovery message to the next nodes over the network including the appliance . The relevant nodes in the appliance evaluate the message and determine a discovery reply message and send respective discovery confirmation messages. Here we assume at least one reply is positive.

The discovery confirmation message is received by the smart coupler which populates its routing table with routing information about the replying nodes and with identifiers about the replying nodes and sends at least one identifier representing the information in its routing table to the connecting element which populates its routing table preferably using the same technique as and sends at least one identifier representing the information in its routing table to source in accord with the foregoing process. Each node retains the relevant identifiers routing information so that subsequent message can be communicated without repeating the discovery sequence. As well those nodes with memory such as the couplers can be configured to save messages.

The functionality described above can be extended to communicate information from the source to an additional device connected to the network by a network . The device can be an additional appliance or other device that is configured to utilize information from the source .

With this structure if an electric utility is facing a brownout for example a source of information about the electricity can send a general message asking for resource consumption reduction to the plurality of communicating nodes which had previously positively responded to the first discovery message sent from . The general message is propagated by the plurality of smart couplers coupled to via the network or other networks to which is coupled. Similarly a source of consumables such as filters or spare parts can ascertain from an appliance the status of the consumable and send information about the timing and availability of replacement.

In certain embodiments there could be a first appliance with a graphical user interface coupled to a smart coupler in communication with a source of information about a resource. The first appliance could also be in communication with a second appliance via at least one smart coupler. The second appliance does not have a graphical user interface. A user of the first appliance could input a parameter into the graphical user interface such as a price threshold at which the user would prefer to reduce the level of consumption of a resource. This parameter could be stored in the memory of a node in first appliance in the memory of a smart coupler in communication therewith or in the memory of the source of information about a resource. When a message is received from the source of information about a resource the software component configured to respond to information about a resource can use the parameter to determine the response to the information about a resource. The response could be to change the operation of the appliance to reduce a level of resource consumption. The response could also include sending message to the second appliance. The message to the second appliance could either be a command to reduce a level of resource consumption or a message to a second software component configured to respond to the information about a resource. Further information about the response to the information about a resource can be displayed on the graphical user interface and the information about the response can come from the first and or the second appliance.

It should be noted that using discovery messages to populate routing tables is the preferred embodiment. However routing tables can also be populated using conventional configuration methods involving a manual or semi manual configuration process. In addition a manual or semi manual configuration process can be used in addition to discovery generated routing tables. In this approach the discovery process or the configuration process can incrementally add or delete routing information within a routing table.

As illustrated in a smart coupler can be communicatively coupled to the appliance an external client in the form of a diagnostic PC and a source of information about operation of the appliance so that failures or other problems in the appliance can be diagnosed monitored and or resolved. The smart coupler which could be a smart cable is communicatively coupled to a network of the appliance via connection element . The smart coupler also connects to the source directly via the interface expander port or via an auxiliary wireless or wired communicating component coupled to the smart coupler via the interface expander port and via a wired or wireless communicating component see . The wireless communicating component can be any arbitrary wireless or wired communicating component able to establish communications with the wired or wireless communicating component coupled to the interface expander port .

The source connects to the appliance in a manner enabling the source to obtain information about at least one operational parameter or measured value associated with the operation of the appliance e.g. direct connection . Exemplary operational parameters include power consumption temperature data about the cycle of operation vibration noise and the like. The source can communicate with the network to send information about at least one operational parameter of the appliance to the smart coupler and or diagnostic PC. Alternatively the source is not in communication with the network and monitors at least one operational parameter of the appliance by other means. For example if the appliance is a conventional washing machine the source can be in communication with an accelerometer attached to the exterior of the washing machine for monitoring vibrations which enables the detection of an imbalance in the washing machine.

The source can communicate with the smart coupler the appliance the diagnostic PC or any combination thereof. We assume that the source has at least an appropriate communication driver or at least one of the smart coupler the appliance and the diagnostic PC has software to translate any message from the source to the aforementioned communication protocols for example. It should be understood that the functionality employed by the source can include functional identifiers which can be discovered through propagated messages by any node in communication therewith.

If the appliance experiences a failure that requires a service person to visit the appliance in the home the service person can couple a PC or other portable computing device to the appliance to diagnose the problem using at least one of the smart cable or using the smart wireless coupler or by using a service key or by using a central collector. Problems can be diagnosed by sending low level commands to the appliance from the PC instructing various components in the appliance to turn on or off and or change their operating parameters. One exemplary way of accomplishing this is by using multiple modes of operation as disclosed above whereby the client puts at least one software operating layer into a different mode and the different mode configures the software architecture to receive and act on a different set of messages that provides a different set of functionalities to the external client. Information from the source regarding the operation of the appliance can then be examined in order to see if the instructions from the PC have resulted in a predictable outcome. For example in order to test a heating element in an oven the PC would send a command to the oven instructing the heating element to turn on. A measured temperature of an oven cavity having the heating element therein can be sent to the PC by the source or from componentry including a smart cable connected to or in communication with internal components or preferably both. This information can be used to determine whether the heating element is functioning properly and heating the oven cavity to a desired temperature.

Information from the source can also cause the PC or any other element in the system to prompt a user at a user interface to choose at least one component to be turned off in the appliance or to take some other action. A user can also enter default actions at the user interface to be taken in response to the receipt of certain information from the source . For example a user can configure the heating element to turn off if the source notifies the system that the temperature of the oven cavity is dangerously high.

Alternatively the failure code can be sent directly to the appliance to turn off a low priority component . Failure codes can also be sent to the smart coupler which can use the processor to analyze the code and generate appropriate instructions to be sent to the appliance .

Various configuration mechanisms are available to create change or initiate the behavior of the appliance control system . The configuration mechanisms include anything that can create delete change stop or initiate behavior in the appliance control system . The configuration mechanism can for example be an arbitrary software component data about a cycle structure data about a consumable an appliance accessory a client or other examples not illustrated in including but not limited to a control board data about an algorithm data about a consumer benefit data about a consumer preference data about a consumer data from a consumer data from a user interface a functional component with a driver configured to communicate with an appliance a remote user interface a functional component able to generate or communicated a taxonomy dataset any other functional component in operable communications with the appliance control system or any functional component of the appliance control system or another appliance control system. The invention introduces methods techniques messaging protocols and software componentry as the building blocks for a new intelligent appliance control system that will enable the appliance control system to be effectively built from re usable components and to be dynamically configured by at least one among a variety of different configuration mechanisms . An object oriented control system according to the invention will deliver the benefits of re usability robustness quality and configurability.

Configurability is one of the hallmarks of the oriented control system . Object oriented programming has not heretofore been suited for inexpensive real time embedded control systems because it generally requires more memory and was thought to be cost prohibitive as compared to procedurally oriented or hard coded control systems. Moreover real time embedded control systems are very in flexible due to the nature of the procedural programming methodologies used in very small micro processors exemplified by those ranging from 4 16 bits of address space and 8 k to 64 k of ROM with very little RAM. The present invention anticipates that sufficient and cost effective memory is now or soon will be available for an embedded real time control system to allow the cost effective commercialization of an object oriented real time control system. The present invention also incorporates an expansion of an object oriented real time control system to include a distributed object oriented real time control system wherein at least one object oriented real time control system is operatively coupled to another node on a network or to a component with an embedded virtual router provided to direct message traffic. The expansion enhances the invention by allowing multiple components of the design to be interoperable and useful in a plurality of various combinations therefore further enhancing the value of the invention in the areas of re use configurability flexibility.

Definitions of Object Oriented Terms Basic. Object oriented techniques in software architecture such as the software architecture discussed with reference to and and in and in promote and enable software re use. A first component enabling re use is the class library. Class library contains a plurality of class definitions. A class definition comprises an interface with a plurality of method definitions and a plurality of field definitions.

Field definitions are named variables that have a known data type. The value of a field definition must be a value corresponding to the field data type. For example say field x is an unsigned integer. The value of x can be a number within the range of 0 to 65535. Field definitions can also have a data type corresponding to another class definition.

A method definition is a function with a name and a description a return value and a set of arguments. Each argument of the method can also have a name and a description. Each argument can also have a data type and a set of valid values. The data type can also be a class definition.

Each method definition further comprises executable software which can use the arguments in conjunction with the executable software so that the executable software returns a result and or executes the behavior corresponding to the logic of the executable software and the values of the argument received in the set of arguments. A method definition can further comprise invocations onto other method definitions of its containing class or to method definitions which it has visibility to. The approach to gaining visibility to other classes methods is known in the art. The return values from the other method definitions can be used by the executable software of the first method either to influence the return value of the method or to influence the behavior of the logic of the executable software.

Preferably a class definition is confined to a single logical purpose to which the plurality of methods contributes the enablement thereof. A class library can be governed independently of the appliance control system to which it is applied. Class library governance includes deployment documentation development testing bug fixes revision control and the like.

Class definitions are made executable in two ways. The first way is via a method known as static. When a class is executing statically all executions of the methods of the class are occurring within the same memory of the processor. This means that if there are two executions occurring simultaneously the methods of the class must be designed such that any state information used within the execution and stored in memory by a first execution is guarded against inadvertent use by a second execution.

Two factors giving rise to the second way are that 1 it is advantageous for methods to store state information in memory for later use and 2 to enable the first way it is required to index that state information to a particular execution or execution context so that when there are multiple executions or execution contexts that the method can retrieve the appropriate state information.

Therefore the second way a class definition is made executable is by instancing a class into an object thereby creating the mechanisms to assign an instance of a class to a particular execution or execution context. Instantiation refers to the allocation and assignment of memory sufficient to hold a unique collection of information associated with a unique object instance and defined by the field and method definitions of the class definition.

Instantiation is the mechanism which allows a class s state information and references to other objects to be encapsulated together and associated with a particular execution or execution context and to expose that instantiated memory to other objects via some type of memory pointer or unique identifier.

An object has the ability to store information associated with its execution context and in its fields. When an object has a field of a data type that corresponds to a class the value of the field can be an object. In this way objects can be composed of their own fields of data and methods and of a plurality of other objects.

Definitions of Object Oriented Terms Advanced. Patterns pattern categories frameworks and layer architectures are terms of art that reference certain advanced design concepts which are not applied to real time embedded control systems. A design pattern is a standard solution that addresses a recurring design problem. Well known design patterns include Composite Recursive Composition Observer Builder Factory Abstract Factory Strategy Decorator Fa ade Singleton Adapter Proxy Command State Hierarchical State Iterator Fa ade Flyweight Template and Chain of Responsibility. Patterns are organized into Categories of Creational Structural and Behavioral wherein each pattern belongs to only one category. Structural patterns are used to organize objects into appropriate structures associated with the domain of the design. Objects organized according to creational patterns facilitate the creation of the structures. Objects organized according to behavioral patterns operate on the structures for the purpose of creating a result such as modification addition deletion data extraction data calculation and the like. The advantage of this type of organization is that certain arbitrary software components are more re usable. For example a portion of a cycle engine that executes the cycle can be the same software for every appliance because it is configured to operate on the components configured using the composite pattern to representing a cycle structure. A second portion of the cycle engine is configured according to the builder pattern so that it can retrieve data about the cycle structure and create the cycle structure from the data about the cycle structure. Using this technique a plurality of appliances can be configured to perform a plurality of operations providing a plurality of consumer benefits using exactly the same software except for the values of the data about the cycle structure. Even the location of the data about the cycle structure can be different and distributed by configuring the Creational component with advance discovery techniques previously described in CyclesOfOperationsAccessory . Without these techniques a reasonable level of re use and configurability would not be possible.

Frameworks are more specialized than pattern. Frameworks are a plurality of software components operatively coupled to address a specialized problem domain with an expected set of variability. In other words a framework is designed to solve a set of related problems wherein some instances of the related problems are not known but anticipated and wherein the framework can operably address the some instances when the some instances occur without additional changes to the framework. A layered architecture is a plurality of frameworks that are in operable co operation wherein each of the frameworks is independent and can be used in other occurrences of layered frameworks.

The invention further includes an appliance control system for controlling an appliance control system apparatus using a layered architecture of a plurality of frameworks wherein each framework comprises at least one implementation of an object oriented pattern. Preferably there are multiple patterns implemented wherein there are patterns for creating structures structures and behavioral patterns that operate on the structures.

Alternatively or additionally the invention comprises an appliance control system for controlling an appliance control system apparatus using objects instantiated from class definitions.

Typically a software operating environment which supports object oriented techniques is able to allocate RAM memory dynamically at runtime. Dynamic memory allocation might be used when new objects are created because address and memory space must be allocated to hold the data associated with the object and any address identifiers required for operable use. There is a correlative relationship between memory allocation and object creation as well there is a correlative relationship between object creation and configurability of the behavior of the arbitrary software components within the object oriented software operating environment. The invention encompasses an appliance control system configured to allocate memory at runtime for the purpose of assigning memory to instantiated objects.

Dynamic Configuration. As previously stated objects can be composed of a plurality of other objects according to the objects field definitions. If an object comprises a method which has executable software to set the value of a field defined to hold an object then that object can be reconfigured by changing the value of the a field from a first object to a second object. This reconfiguration can then result in a different composite or overall appliance control system behavior. There are many useful purposes for an appliance control system whose behavior can be changed by changing the values in a first objects field to a third object from a second object. For example a cycle accessory could use this technique to change a cycle structure. Likewise both a consumables reader and a recipe book wand could use these techniques to customize the behavior of the appliance control system according to the data about the cycle the data about a consumable and the like.

There are many mechanisms which can initiate and manage the Dynamic Configuration of an appliance control system. However these mechanisms see will need a common design framework with which to accomplish the dynamic configuration. And some portions of the dynamic configuration can be accomplished during the compile process while other portions may be accomplished at post compile time a k a runtime .

In any event discloses the basic mechanisms needed to create and manage the software portion of an appliance control system such as the appliance control system from comprising at least one class library with classes that can be instantiated as objects and referenced to other objects in a form of at least one composite structure and the configuration mechanism such as the configuration mechanism from which may be a client client accessory or another arbitrary software component either within a shared runtime environment with the other objects in the diagram or in effective communication with the other objects across a network.

In message the configuration mechanism is able to discover the available functionality of the software operating environment exposed with the discovery software architecture FIG. or the embedded virtual router FIG. by sending a message to the discovery software architecture or the embedded virtual router to getClassLibrary .

This message is a form of discovery of functional identifiers and is restricted to discovery of classes and not instances of classes. The class library is itself an object instantiated from the ClassLibrary class. An example of a unique numeric functional identifier in an appliance would include an API ID plus Type and Version.

In message a unique numeric addressing identifier is returned so that the configuration mechanism can address the class library object directly. An example of a unique numeric addressing identifier in an appliance would include Node ID plus API ID.

In message the configuration mechanism sends a message to the discovery software architecture or the embedded virtual router with a unique numeric addressing identifier enabling it to be forwarded to the object corresponding to the unique numeric addressing identifier in this case oid for the class library .

In message the discovery software architecture or the embedded virtual router forwards the message getClasses to the class library object .

In message the class library object returns unique numeric addressing identifiers for objects representing the classes contained by the class library objects.

In messages and the configuration mechanism sends a message to the class library object requesting unique addressing identifiers for objects instantiated on Class X. Class X is specified as an argument to the message and Class X is represented by a unique numeric functional identifier also known as a class identifier.

In message the unique numeric addressing identifier is returned allowing the configuration mechanism to address subsequent messages to the object representing the Class which is identified by the unique numeric functional identifier of X where X can be any number .

In messages and the configuration mechanism sends a message to the object representing Class X requesting unique numeric addressing identifiers for all objects instantiated on Class X.

In messages and the configuration mechanism requests that the object representing Class X create a new instance of Class X.

In messages and a method is invoked on an instance of Class X where the first argument is MID which is an identifier of the method to which the request is purposed for. MID is the equivalent of OP code discussed above. A second set of arguments are arbitrary and will correspond to the method definitions of the class of which the object is instantiated. In this case one of the arguments is a second unique numeric addressing identifier for a second object different from the object receiving messages and . This allows the oid to address a subsequent message contained within the software of the method corresponding to MID to oid.

In this case the software of the method corresponding to MID could have set a field value of oid to oid resulting in oid being partially composed by oid. Composition is a preferred technique to create re usable structures. Black box re use refers to establishing or changing structures of composition of objects at runtime by enabling objects to obtain references to other objects at runtime. Adopting this technique allows an object oriented control system to be modified at runtime by a plurality of configuration mechanisms. Several embodiments of appliance functional configurations can benefit from black box re use techniques. Examples are appliances with cycle engines appliances that need to change or allow their cycle structure to be changed in response to an interaction with a consumable or consumable reader a recipe book or any other configuration mechanism especially those which effect the cycle of operation either directly or indirectly by way of data about themselves a consumable a person an appliance a benefit an outcome or a behavior.

Appliances can also hold data about themselves their componentry and the organization of their componentry. In one embodiment the appliance would have a composition with a root container of an appliance object having attributes of model number and serial number methods for setting and getting those attributes and at least one attribute containing a plurality of other objects representative of a first set of child containers. An example of a first set of child containers might be an appliance control system which in turn might have a second set of child containers of control boards wherein each object within the composition would also comprise a plurality of known methods and attribute names such as part numbers model numbers vendor ids serial numbers and the like wherein some of the methods could be exposed to other local or remote objects for invocation and wherein the attribute names would be associated with values determined by the instance of that appliance its current or past state other factors or any combination thereof. The classes available to be composed in the composition could be designed such that a client could bi directionally traverse the composition and collect relevant attribute data or invoke appropriate methods according to the behavioral purpose of the client. In one embodiment the client would be configured as a behavioral component of the visitor pattern within the same software operating environment of the composite structure. In a second embodiment the client would be external to the composite structure and would access the structure over a network preferably using an embedded virtual router to encapsulate the difference between the external interface of the network and the internal interface of object to object collaboration within a single software operating environment. In one embodiment the object composition of an appliance control system would be comprehensive and would be representative of the types of objects suggested in .

For an object oriented control system to be distributed means that multiple software operating environments each with a plurality of objects will have the objects in operable communication. The invention blends object oriented messages between messaging in a runtime environment with messaging between objects across a network. A communications network like WIDE having a protocol like SA can be used to enable the operable communications between objects not sharing a runtime environment. Further an embedded virtual router can be used to selectively encapsulate the communications between objects independent of the interposing architecture. It is preferred then that the packet structure be specifically designed and optimized for object oriented messaging. Therefore a plurality of namespaces comprising identifiers either individually or in sets must be defined to uniquely identify classes objects methods method arguments object and class attributes. Namespaces are the range of identifiers for a given set of things where each identifier can have an unambiguous meaning.

The packet structure can then be defined wherein fields of the packet can contain elements of the various namespaces allowing operable communications between objects. An exemplary packet structure might contain object ids method ids class ids and argument values wherein the ordinal position of the argument value would designate the argument. An alternative to argument values by position would be pairs of argument ids and argument values wherein the ordinal position of the argument value within the packet would not have meaning and the meaning would be derived from the argument id.

See for example that shows an exemplary packet structure for an object oriented message in an appliance according to the invention. In this case illustrates the packet structure for message sent from the configuration mechanism to the SA or to the embedded virtual router in . The packet will include at least 4 bytes one to set the oid one to set the MID and one each for the arguments argthrough arg. It will be understood that the packet can be included in a larger message including values for MMP or Frag as well as network identifiers as shown for example for the packet in .

This invention thus comprises at least one object oriented control system configurable by a configuration mechanism in selective operable communication with a plurality of object oriented control systems using a packet protocol for constructing messages comprising identifiers from a plurality of namespaces associated with the building blocks of object oriented systems wherein the meaning of each unique identifier within class library namespace is uniquely meaningful throughout the universe of appliances. The operable communications between objects can be selectively encapsulated through the use of an embedded virtual router and the context of more data about an object can be ascertained by traversing the composite structure from the object or knowing the class from which the object is instantiated. The invention further comprises a comprehensive approach to create a control system which can be configured to deliver the desired benefits of the user.

While the invention has been specifically described in connection with certain specific embodiments thereof it is to be understood that this is by way of illustration and not of limitation and the scope of the appended claims should be construed as broadly as the prior art will permit.

