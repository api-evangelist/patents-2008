---

title: Method and apparatus for monitoring runtime of persistence applications
abstract: A monitoring method and apparatus monitors a runtime application to collect and display static and dynamic data concerning software entities and database operations in a runtime environment. In one embodiment, monitoring classes are used to collect monitoring data from at least one PersistenceUnit (PU) and at least one PersistenceContext (PC) associated with the PU of an application the uses an in implementation of a Java Persistence Application Programming Interface (JPA). A Java Management Extension (JMX) MBean communicates with the monitoring classes to expose monitoring data outside the runtime environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08356288&OS=08356288&RS=08356288
owner: SAP AG
number: 08356288
owner_city: Walldorf
owner_country: DE
publication_date: 20081110
---
This invention relates generally to the field of computer systems and more particularly to the monitoring of executing software applications.

The administration and management of software systems is an ever increasing challenge as the solutions grow ever more numerous and complex. At the same time organizations have grown increasingly dependent on enterprise applications and their continuous and uninterrupted operation. It is not uncommon for such applications to perform well under certain load or conditions of use but to degrade in performance under other conditions of use. The ability to monitor application performance in real time can be very helpful to personnel responsible for administering and maintaining such applications as well as developers and others involved in the development and configuration of the applications.

According to one example embodiment there are provided monitoring systems and methods for monitoring a runtime application and to collect process and display both static and dynamic data concerning the runtime application. In another embodiment a user interface provides navigation to display monitoring information including or derived from the monitoring data the monitoring information including information concerning software entities and database operations associated with those entities. In another embodiment quality assessments may be made based on comparing the observed behavior of a runtime application versus the expected behavior.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that logical mechanical electrical and other changes may be made without departing from the scope of the present invention.

Referring now to there is illustrated a high level block diagram of an example embodiment of a monitoring infrastructure using an application runtime environment in which one more applications may be executed. According to one example the monitoring infrastructure runtime environment and application are implemented using the JAVA Platform. In an example runtime environment conforms to the Java Runtime Environment and application is written according to specifications of the Java Programming Language. According to one embodiment infrastructure may use Java Management Extensions JMX technology to provide the tools for building distributed Web based modular and dynamic solutions for managing and monitoring devices applications and service driven networks. JMX resources are represented by objects called MBeans for Managed Bean .

The monitoring system includes a lower level monitoring layer to gather relevant monitoring data and provide it to an upper level monitoring layer wherein upper layer is external to environment . Layers and are in one embodiment a user interface UI independent monitoring infrastructure. A third monitoring layer may include at least one UI interfacing with layer to enable the user to work with the monitoring data . As explained in more detail below monitoring data may include both static data and dynamic data associated with application s executing in environment . Static data may include for example data concerning the structure attributes or entities of the applications while dynamic data may include data relating to operations performed by the applications such as database operations. In one example embodiment the UI of monitoring infrastructure is integrated with an existing monitoring and management infrastructure of a further software system.

As illustrated in the example embodiment of the runtime application interfaces with a Java Persistence Application Programming Interface JPA implementation deployed in a JPA Container including a Java PersistenceUnit PU and a PersistenceContext PC operating therein. In general a Java PU can be a software object that provides functionality for defining a persistence provider a data source to use and object relational mapping information. A Java PC can be one or more software objects that are managed by a manger software object to perform a designated function. However Java PUs and PCs are only exemplary and other PUs and PCs may be used from other persistence frameworks. Accordingly in this embodiment in the lowest layer of infrastructure relevant monitoring data is gathered in response to actions from the PU and the PC operating within a EntityManagerFactory EMF . In this example lower layer is comprised of monitoring classes and termed PU monitor and PC monitor respectively to collect data from the PU and PC including static metadata located in the EMF .

All the data for all deployed and running JPA applications may be collected at a central point in a further monitoring class named the ORPersistenceMonitor ORP in and this central point may be exposed as one or more JMX MBeans deployed in layer of that is outside the runtime environment . In one embodiment the MBean forms a thin interface between the JPA integrated monitoring implementation of layers and . According to another example embodiment the monitor classes and are integrated into the JPA runtime environment to minimize the influence on the implementation s classes.

Accordingly in one example embodiment the central access point for the JPA monitoring may be a monitoring class that exposes the monitoring data through various interfaces such as UI for example by passing through a JMX MBean as shown in . The data structures of ORP are filled with data out of the runtime application and make it accessible to components outside of the runtime environment. In order to be accessible from outside the interfaces in one embodiment the monitors are part of the API of the JPA implementation.

In another example embodiment illustrated in the JMX MBean is deployed in a JMX infrastructure that enables arbitrary Java resources to be managed in a standard way. The resources can provide a management interface at the instrumentation level and register the MBean object that implements it in the local MBean Server at the agent level . At the distributed services level the infrastructure provides adaptors and connectors to connect to the MBean Server . A user of the JMX infrastructure can work with distributed MBean servers transparently i.e. from the user s perspective there is only one MBean server that contains all the registered MBeans . In one example embodiment one or more MBeans are implemented to access the underlying monitors and provide the management interface for retrieving the actual monitoring data about the JPA runtime.

As indicated above and as further illustrated in the monitoring infrastructure collects data of at least two different types from the JPA runtime . The first is static metadata about a given JPA application. This data is stored in the PU that is provided to the JPA runtime at application startup and will not change until the next application startup or deployment. The second part is the volatile dynamic data that represents an application s state regarding its object persistence. According to one example embodiment JPA state is held in the PC . The PC has only a short lifetime relative to a PU that maximally endures as long as a transaction does. In an example embodiment a transaction is a JTA transaction that is bound to the application s request. Accordingly it is considered difficult to display the current state of a PC directly in a monitoring user interface.

Additionally in one example embodiment there is a data structure called active PCs. Active PCs are those that are still bound to a JPA client and contain managed JPA entity objects. PCs that are visible in this data structure have an extended lifetime. In most cases this means that the PCs are kept in a stateful session bean SFSB and have thus have an extended lifecycle that spans over multiple requests to the SFSB. Another reason a PC may have an extended lifetime is that the calling JPA client code has semantic errors and somehow circumvents the lifecycle management of a Java Enterprise Edition EE server. Hanging transactions can also be a cause. However such PCs are kept in that structure and their data is added to the accumulated monitoring data as soon as they reach the end of their lifecycle.

In a further embodiment as illustrated in the data structure diagram of the static data for a PU is computed once in an application s lifecycle and includes a list of entities per PU the persistent fields per entity and a list of named queries . Further the aggregated data collected for database operations can include create read update and delete CRUD operations on JPA entities operations for relationship navigation Java Persistence Query Language JPQL queries and native queries . For a given PC collected for the lifecycle of the PC the different type of dynamic data collected during runtime of an application can include CRUD operations execution time aggregated by managed entities and operation type execution time aggregated by query named dynamic lifetime of a PC and the number of managed entities at transaction end . In one embodiment a monitor stores the collected data in an internal data structure of a Java class. According to one example embodiment the size of the PU is measured once at the creation of the EMF . All relevant sizes of the PU can be acquired via the PU itself. Thus the monitor can be provided with only a reference to the PU . The information needed for monitoring the PU can then be retrieved by the monitor .

According to one example embodiment the monitoring implementation of infrastructure is designed to minimize the influence on an existing JPA implementation that the infrastructure is deployed to monitor. According to one approach to minimize the influence as illustrated in the classes that are monitored are accompanied by proxied classes proxied versions of the classes . The proxied classes execute the calls to the monitors and delegate to the target methods. In the case that a target class does not implement an interface to the monitors an interface may be declared that contains at least all methods that are relevant for the monitor calls.

For static methods the proxy approach based on interfaces may not be applicable. However according to one example embodiment the actions that are taken in such classes are monitored according to one or more other approaches. One example approach is to use a slim object that is handed over to each static method via an interface that offers simple methods to start and stop monitoring database operations. As shown in this interface is represented as MonitorManager . According to one example embodiment if the monitoring is turned off this interface is implemented by a dummy implementation that does nothing but call return. In another example embodiment if the monitoring is turned on the MonitorManager implementation uses a DatabaseStatistics object of the Open SQL for Java runtime to monitor the database operations. Using this approach in one example embodiment classes with static methods may be monitored with almost no overhead when the monitoring is turned off.

According to another example embodiment illustrated in two additional classes are used to implement the monitoring for the PC accompanied with the previously described mechanisms. First the PC is proxied with a PC Proxy to allow it to measure lifetime of the PC as well as the number of managed entities. The PC Proxy has the same lifecycle as the PC itself. Second all relevant method signatures of a StoreManager class e.g. a StoreManager as in a JPA implementation can be extended with an argument of type MonitorManager. The implementation of the StoreManager methods can be extended with calls that start and stop the MonitorManager within the relevant methods.

Referring now to an example embodiment the monitoring classes and associated data structures are described in more detail. In the monitoring class for a given JPA PU is shown as a PUMonitor . In one embodiment it contains a data structure for static information about the PU that is called PUMonitorInfo . Aggregated data about database operations triggered by JPA operations are stored in three maps inside the PUMonitor . The entities map can hold aggregated data for CRUD operations triggered by operations on JPA entities. Next a queries map can hold aggregated data for JPQL and SQL queries. Lastly a relationships map can hold aggregated data for relationship navigation between JPA entities.

In another example embodiment since the PUMonitorInfo counts properties of a referenced PU the monitor contains a map that has the names of the entities as keys and the number of the entities fields as values. As may be understood the overhead of monitoring the PU will grow with the size of the PU . The values for the PUMonitor will only be computed once at the creation of the EMF for example at the first injection of an EntityManager into the client application. According to one example embodiment of monitoring a JPA application only aggregated values for PCs are needed. In this embodiment only one data structure per JPA application is used. The PUMonitor can store average values for the values that are supplied from the respective proxied PCs .

Referring to an example embodiment the monitoring class for a given JPA PC is shown as a PCMonitor . In one example embodiment the PCMonitor contains several data structures. A first map holds the average execution time of CRUD statements per entity. A map key provides the name of the entity. A map value specifies a Java class that holds a map with all CRUD operations that have been executed for the given entity with the map values grouped by the CRUD operation type. Each item of the map contains the type of the operation the database time the number of database operations and the number of operations on the entity. A second map holds all named and dynamic queries and their average execution time. A map key contains a QueryIdentifier which contains the SQL statement String and the type of the query which can be one of the following DYNAMIC DYNAMIC NATIVE NAMED NAMED NATIVE. A map value specifies a Java class that holds the overall execution time and the number of executions of the respective entity. A third map holds all relationships between JPA entities and the average execution time of the according database operations. A map key specifies the JPQL query string. A map value specifies a Java class that holds the overall execution time and the number of executions of the respective entity. The PCMonitor further includes a field that holds the overall lifetime of all PCs for the given PU and the number of all PCs that have been created for the given PU since its creation. PCMonitor further includes a field that holds the overall number of managed entities for the given PU as well as the number of all created PCs for the PU.

As indicated in in at least one example embodiment JMX MBeans can provide access to all monitoring data and to all administration and configuration functions which are necessary to operate the JPA monitoring in the runtime environment . Hence the JMX MBeans can call the appropriate monitors and provide according methods. The MBeans can provide multiple methods as illustrated in . For example monitoring methods can get data about all PUs including data about the number and lifetime of all PCs created within a PU get data about all entities managed within a given PU and get data about all named and dynamic queries for a given PU . Also in an embodiment administrative methods can toggle the switches for monitoring issues especially methods for switching on off the JPA monitoring or for toggling only the time measurement. Lastly configuration methods can change monitoring settings like number of entities or queries to be monitored. In one embodiment if the monitoring is switched off there is preferably not any measurable influence on the runtime application s resource consumption time memory .

According to still another example embodiment an MBean supports a UI independent monitoring infrastructure allowing multiple different clients to use the MBean. Thus in one example embodiment the MBeans do not imply resource specific classes. In an example embodiment a resource is a piece of data that can be accessed by the code of an application. A resource specific class may be a class that implements data types beyond those that have been predefined. Therefore all clients may be able to use the MBean as long it has been configured to use the predefined data types. Thus this may be relevant for those methods that require returning not only one item of a simple Java type but a set of items or fields representing the current status of a resource. MBeans of Complex data types are in one embodiment addressed by using a JMX Open Type a predefined data type instead of resource specific classes. For example the Java type of a complex return value could be CompositeData that could be described in an Open Type.

As illustrated in in one embodiment of an MBean there are several complex return values realized as interfaces extending a CompositeData interface including a PUData interface a PCData interface an EntityData interface and a QueryData interface . The PUData interface provides setters and getters for PU data like application and data source name and total number of created PCs and the like. The PCData interface that provides setters and getters for PC data like start time of the PC. The EntityData interface provides setters and getters for entity data like total number of CRUDs. The QueryData interface provides setters and getters for named or dynamic query data like total number of executions. In one example embodiment illustrated in when a client calls a method of a JPA MBean the corresponding method of the underlying monitor is called. If the monitor returns complex data values the MBean creates appropriate implementation objects of the above mentioned interfaces and returns them to the client . Any client can access the data by means of the composite type descriptors that are provided by the CompositeData interface .

In still another example embodiment illustrated in the JPA monitoring infrastructure is integrated into a development framework as a managed resource provider . Within an agent layer of the framework the JPA monitoring integrates in the form of MBeans . These MBeans are registered on every cluster node in the framework when starting the JPA container allowing monitoring of those nodes. The JPA monitoring infrastructure may also be integrated as a UI provider to a UI layer of framework by implementing a plug in in a development component DC . The DC may be created within a software component SC that defines a deliverable deployable unit. In case of JPA Monitoring one DC representing the monitoring of the persistence units is sufficient.

According to one embodiment the development framework follows the MVC Model View Controller paradigm that is based on a clear separation of the functions of data model model presentation logic view and program control controller . In an embodiment there is a JMX Model Importer an Integrated Development Environment IDE plug in that can extract information about the framework model classes out of the set of compiled management interfaces of the implemented MBeans and generates two types of data. First it generates model classes for each imported MBean and for each composite data that is used as attribute parameter or return type in the MBean interfaces. Second it generates MBean proxies that make direct calls to the corresponding MBeans transparent. Thus the resulting JMX model of the JPA Monitoring can for example include classes like PUData or EntityData that contain the necessary monitoring data. The model allows the direct binding of UI elements like component and view contexts to the model classes.

In one embodiment the JPA Monitoring plug in needs a JMX connection to the selected system to perform monitoring operations i.e. call methods of the registered MBeans. The plug in gets a JMX connection by registering the selected system properties at the connection registry that is provided by the framework .

In a further example embodiment a multistate approach to UI level access is implemented. An example is illustrated in . The framework supports security roles in order to allow the customer to restrict the access to administrative tasks to certain users for example using permission objects for granting access to certain actions in the UI as well as to the APIs in the JMX model. According to one embodiment there are two predefined roles SuperAdmin and Read Only .

In another example embodiment the UI framework provides a display or read only action for each plug in. For any configuration or administrative task JPA Monitoring can perform checks on application specific e.g. change permissions based on which UI elements are enabled or disabled. For example switching off on a time measurement within JPA Monitoring should only be possible for a user who has change permission. In an example embodiment if the user has only the read permission the corresponding button in the UI will be disabled.

According to still another example embodiment illustrated in the UI uses a hierarchical approach of displaying a defined set of objects and its related information in two main patterns and . The first is the Object Identification Pattern OIP in which a collection of defined objects is displayed in a standard table or table tree view. The second is the Object Data Pattern ODP which contains detailed information of the selected OIP object. If needed an ODP is shown to display the details of an ODP.

For the JPA Monitoring infrastructure described herein the monitoring objects may be displayed within a hierarchy such as that shown in wherein an OID shows a view of Current PUs including summary data about the number and lifetime of created PCs and the average number of entities per PC . An ODP is illustrated as a tab strip including details about PCs such as start time number of managed entities and CRUDs for each Entity the name number of fields number of CRUDs and CRUD time for each Relationship the declaring and target entity the declaring field cardinality number of DB operations and operation time for each Named Dynamic Query the text SQL text number of executions and execution time and for each Cache the type current and maximum size number of hits and requests and hit ratio.

According to another example embodiment for the infrastructure described herein the JPA implementation is used as the O R Object relational mapping technology in the Java Server provided in the Netweaver system commercially available from SAP. In this embodiment the JPA Monitoring infrastructure is integrated into the NetWeaver Administrator NWA . In still another embodiment JPA Monitoring can also form a unified persistence view with the Open SQL Monitoring that is already integrated into NWA meaning that is reachable by the same navigation as Open SQL Monitoring. In an example embodiment Open SQL refers to an infrastructure which controls a set of statements that perform operations on a central database. Results of the operations and any accompanying error messages may be independent of the actual database system in use. Thus Open SQL provides a platform independent set of statements that may operate on disparate database systems. In an example embodiment Open SQL for Java is the application of Open SQL to a Java environment. In an example embodiment Open SQL Monitoring refers to monitoring the execution of SQL statements when Open SQL for Java is used to access a database. As may be appreciated to one skilled in the art other frameworks providing databases independent monitoring beyond Open SQL may be used.

In some embodiments professional applications for NWA need to provide configuration data required to work within the NWA UI framework. The configuration data is stored in the Portal Content Directory PCD . This data can include but is not limited to for example name title and description of the application and the components a local central mode a place in the NWA navigation or a customer service network CSN component. In an embodiment the JPA Monitoring is available in local and central mode. The place in the NWA navigation is the same as for the Open SQL for Java Monitors e.g. the monitors used for Open SQL Monitoring .

Accordingly as described above there is provided a monitoring infrastructure for monitoring JPA applications. According to one embodiment since Java EE applications have a strict concept of visibility and packaging a consumer of the persistence monitoring for JPA would not need to care about any visibility class loading issues or packaging limitations or issues. The monitoring infrastructure provides static data relating to monitoring JPA applications as well as the collection and display of dynamic runtime information e.g. database time . It further provides an aggregated view over all cluster nodes and for filtering and grouping for various key attributes of running JPA applications in order to enhance supportability of various applications. Strong integration of the monitoring capabilities into a JPA library is also provided.

Many of the disclosed embodiments have been described as being implemented using Java. However as one skilled in the art will recognize the present invention can be implemented using any programming language object oriented or otherwise including but not limited to C C VB.NET Python PHP Perl and Ruby.

Referring now to there is illustrated a computing platform that may host the monitoring infrastructure . According to one example embodiment monitoring infrastructure may be stored on one or more machine readable media on platform such as a hard drive or memory circuits and execute on one or more processors . Platform may take the form of one or more servers or other computing systems such as workstations personal computers or mainframes.

Thus other embodiments may be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device and or any type of electronic device or system may include one or more processors coupled to a machine readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The machine may take the form of a computer system having a processor coupled to a number of components directly and or using a bus. Such components may include main memory static or non volatile memory and mass storage. Other components coupled to the processor may include an output device such as a video display an input device such as a keyboard a cursor control device such as a mouse and a signal generation device such as a speaker. A network interface device to couple the processor and other components to a network may also be coupled to the bus. The instructions may further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus may be absent present singly or present in plural numbers depending on the specific example to be realized.

The processor the memories and the mass storage device may each include instructions which when executed cause the machine to perform any one or more of the methods described herein. In some examples the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked environment the machine may operate in the capacity of a server or a client machine in server client network environment or as a peer machine in a peer to peer or distributed network environment. The machine may be a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine. Further the term machine shall also be taken to include any collection of machines that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers and or a variety of storage media such as the processor registers memories and the mass storage device that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term machine readable medium shall accordingly be taken to include tangible media such as solid state memories and optical and magnetic media.

