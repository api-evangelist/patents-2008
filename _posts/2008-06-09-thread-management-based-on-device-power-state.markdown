---

title: Thread management based on device power state
abstract: Managing threads for executing on a computing device based on a power state of the computing device. A power priority value corresponding to each of the threads is compared to a threshold value associated with the power state. The threads having an assigned power priority value that violates the threshold value are suspended from executing, while the remaining threads are scheduled for execution. When the power state of the computing device changes, the threads are re-evaluated for suspension or execution. In an embodiment, the threads on a mobile computing device are managed to maintain the processor in a low power state to reduce power consumption.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09027027&OS=09027027&RS=09027027
owner: Microsoft Technology Licensing, LLC
number: 09027027
owner_city: Redmond
owner_country: US
publication_date: 20080609
---
Traditional power management methods modify a power state of a processor based on a system load an estimated trend in processor usage or other heuristic to achieve better performance. For example the clock speed of the processor may be increased to handle an increase in the system load. On a mobile computing device the processor typically executes infinite loops for animation background services or implementing parallelism. To allow these processes to execute continuously the traditional power management methods limit or entirely prevent the processor from entering an idle state or other low power state even when the device is in standby mode e.g. the display is off . Thus the processes rapidly drain the battery while providing little value to a user of the mobile device.

Embodiments of the invention control thread or process execution to manage a power state of a computing device. In some embodiments a scheduler filters access to a processor in the computing device based on a power priority value assigned to each thread. A threshold value for the computing device changes as the power state of the computing device changes. The scheduler analyzes the power priority value of each thread relative to the threshold value to determine whether to suspend the thread. Execution of the suspended threads may resume upon another change in the power state of the computing device.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Embodiment of the invention manage a load on a computing device such as shown in based on a power state of the computing device . For example the load is limited to maintain the computing device in a low power state by restricting execution of threads. In some embodiments a power priority value or other indicator of priority is assigned to each of the threads. The threads are filtered by comparing each power priority value to a threshold value associated with the power state of the computing device . Those threads with power priority values violating the threshold value are suspended from execution while the other threads are allowed to execute. In this way threads with a higher priority are allowed to execute.

While the power priority value is described in some embodiments as being separate and distinct from a process priority value traditionally used for managing the power state of a processor such as shown in other embodiments are operable with using the process priority as the power priority value to manage the threads based on the power state.

While some embodiments of the invention are illustrated and described herein with reference to a mobile computing device e.g. see or other power constrained device such as a telephone a personal digital assistant or a gaming console aspects of the invention are operable with any device that performs the functionality illustrated and described herein or its equivalent. For example embodiments of the invention are operable with a desktop computing device a laptop computer and other computing devices to reduce the power draw of the device thereby reducing infrastructure power costs among other benefits. Further aspects of the invention are operable with any system including systems that idle the processor by placing the processor into a halt state when no threads are being executed e.g. hibernate and suspend are system states .

Referring again to an exemplary block diagram illustrates the computing device managing threads. The computing device includes a memory area and at least one processor . The memory area or other computer readable medium stores a list of active threads such as active thread through active thread N where N is a positive integer value. The memory area further stores a list of suspended threads such as suspended thread through suspended thread M where M is a positive integer value. Each of the active threads and the suspended threads has a power priority value . The power priority values are assigned to each of the active threads and the suspended threads by for example an application program developer or by a user of the computing device . In the embodiment of as illustrated the list of active threads is stored in an active queue and the list of suspended threads is stored in a suspended queue .

In an embodiment the processor is transformed into a special purpose microprocessor by executing computer executable instructions or by otherwise being programmed. For example the memory area stores computer executable components for scheduling threads based on the power state of the computing device . Exemplary components include a detection component a state component a priority component a dispatcher component and an inheritance component . The detection component receives a request for execution of a thread e.g. at thread creation and determines the power priority value associated with the thread. For example the detection component determines the power priority value by querying a database via an application programming interface API .

The state component determines a power state of the computing device and a corresponding threshold value. For example the state component accesses a lookup table or other mapping between power state and threshold value. Alternatively or in addition the power state corresponds to a power state associated with the processor . The state component determines the power state for example upon detection or notification of a change in the power state e.g. when the computing device becomes idle . Exemplary power states include but are not limited to one or more of the following ON IDLE and BACKLIGHT OFF. In another embodiment the power states correspond to a battery power level and or state. For example the power states include but are not limited to one or more of the following RECHARGING 100 75 50 25 and LOW.

The priority component compares the power priority value determined by the detection component with the threshold value determined by the state component . The dispatcher component alters the contents of the active queue and the suspended queue based on the comparison performed by the priority component . For example the dispatcher component schedules the thread for execution if the power priority value determined by the detection component violates the threshold value determined by the state component . Otherwise the dispatcher component suspends execution of the thread. In an embodiment the dispatcher component schedules the thread for execution if the power priority value exceeds the threshold value.

In some embodiments the dispatcher component schedules the thread for execution by moving the thread from the suspended queue to the list of active threads in the active thread queue. Alternatively if the thread is already in the active queue the dispatcher component maintains the thread in the active queue .

In an example two threads are being executed by the processor one thread in the foreground e.g. a high priority electronic mail application and one thread in the background e.g. a low priority synchronization application . When the power state of the computing device changes to standby mode e.g. display turns off the synchronization application will continue to run while the electronic mail application will be suspended.

The inheritance component increases the power priority value of the thread above the threshold value if the thread is blocking a resource required by another thread being executed or to be executed . This allows the thread to execute until completion which releases the resource required by the other thread. The operation of the inheritance component is further described and illustrated with reference to below.

In an embodiment the processor and computer executable components operate as part an operating system scheduler for managing the threads. Alternatively aspects of the invention may be implemented outside the operating system scheduler as for example a power priority monitoring service. The power priority monitoring service monitors and alters the threads in the active queue and in the suspended queue .

Referring next to an exemplary flow chart illustrates operation of a scheduler identifying and managing threads. In an embodiment an operating system scheduler performs the operations illustrated in the flow charts including . Aspects of the invention however are operable with any logic embodied in hardware or software that provides the illustrated functionality. For example the logic may be performed by a web service or special purpose hardware.

At a plurality of the threads for execution is identified. At the power priority value is determined for each of the identified threads. In an embodiment the scheduler assigns the power priority value based on factors such as a recommendation from the application developer e.g. a power profile as illustrated in rules or guidelines established by an original equipment manufacturer of the computing device or the processor or the like. In the absence of any provided basis for assigning the power priority value for each of the threads a default power priority value is assigned to each of the threads. For example the default power priority value is a value that prevents the threads from running in any power state other than ACTIVE.

At the current power state of the computing device or processor is determined. In another example element occurs when the power state of the computing device or processor changes. A threshold value corresponding to the power state is identified at . For example the relationship between the threshold value and the power state is defined in a lookup table or other data structure. At the threshold value is compared to the power priority value for each of the threads. The list of active threads and the list of suspended threads are altered at as a function of the comparison. In general one or more of the threads are selected based on the comparison and the execution status of the selected threads is adjusted. For example if the power state changes to a more restrictive state e.g. from ACTIVE to IDLE the threads with a power priority value less than the threshold value are selected and moved from the list of active threads to the list of suspended threads e.g. for suspension . In another example if the power state changes to a less restrictive state e.g. from IDLE to ACTIVE the threads with a power priority value greater than or equal to the threshold value are selected and moved from the list of suspended threads to the list of active threads e.g. for execution . Aspects of the invention are not limited to the specific examples described herein. That is aspects of the invention are operable with any form of comparison between the threshold value and the power priority value for each of the threads.

Referring next to an exemplary flow chart illustrates the assignment of power priority values for threads based on a power profile or other configuration information for an application program. If the power profile exists at the scheduler determines the power priority value for each of the threads in the application program based on the power profile at . In the example of the power priority value for the main thread is set at and the power priority values for the secondary threads are set at . Alternatively or in addition the power profile defines a single power priority value for all the threads associated with the application program. If the power profile does not exist at a default power priority is assigned to all the threads at .

Referring next to an exemplary block diagram illustrates a kernel scheduler managing user mode threads on the mobile computing device . In the example of a power manager detects changes in the power state of the mobile computing device and communicates the power state information to the kernel scheduler . Both the power manager and the kernel scheduler operate in kernel mode . The kernel scheduler schedules the threads associated with a user process executing in user mode on the mobile computing device .

Referring next to an exemplary flow chart illustrates the scheduling or suspension of a thread based on the power priority value upon thread creation. At an operating system scheduler or other component identifies a new thread for execution. An application program for example spawns forks or otherwise creates the new thread. The operating system scheduler detects creation of the thread and determines the power state of the computing device at . The operating system scheduler determines the threshold value associated with the determined power state at . In an embodiment the operating system scheduler defines a plurality of power states for the computing device and defines the power state value or other threshold value for each of the defined plurality of power states.

The determined threshold value is compared to the power priority value for the new thread at . If the power priority value violates the threshold value at the new thread is suspended from executing at . If the power priority value does not violate the threshold value at the new thread is scheduled for execution at . The thread then executes at .

Referring next to an exemplary flow chart illustrates operation of the scheduler with particular power priority values . The power state value for the computing device is set to zero at . The next thread is selected at . If a thread list is empty at e.g. no threads to execute the power state value is increased at . If the power state value exceeds at the scheduler stops. If the power state value does not exceed at the next thread is selected at .

If the thread list is not empty at e.g. there are threads to execute and if the thread quantum has not expired at the power priority value is compared to the power state value at . The quantum is a unit of scheduling time for which a thread is given control over the processor . If the power priority value does not violate the power state value at the thread is executed at . If the thread quantum has expired at or if the power priority value exceeds the power state value at the scheduler continues at .

Referring next to an exemplary block diagram illustrates the scheduling of threads based on a threshold value associated with a power state of the mobile computing device such as the mobile computing device shown in . In the example of three power states and corresponding threshold values are defined as shown in Table 1 below for the mobile computing device . The priority levels range from zero highest priority to 255 lowest priority . Priorities below are considered real time priorities and are not available to normal applications in an embodiment. In the example of power priority filtering is used only for non real time threads.

In the example of six non real time threads belong to the Home Screen Telephone Application Synchronization Application Cool Game and Anti Malware Application. Table 2 below lists exemplary power priority values for the applications.

As shown in the Cool Game and the Home app do not use a processor in the mobile computing device when the screen is off. Further the anti malware application does not waste resources when the system is IDLE. In an embodiment the dispatcher ready list is a weighted round robin data structure used by a kernel to make scheduling decisions.

In one scenario the mobile computing device is in an ACTIVE power state. The scheduler manages the processor in the exemplary order shown in Table 3 below.

In another scenario the mobile computing device is in a BACKLIGHT OFF power state. The scheduler manages the processor in the exemplary order shown in Table 4 below.

In another scenario the mobile computing device is in a SYSTEM IDLE power state. The scheduler manages the processor in the exemplary order shown in Table 5 below.

Referring next to an exemplary flow chart illustrates inheritance of the power priority value to avoid thread blocking. In this example a lower priority thread e.g. a blocking thread holds a resource and delays the execution of a higher priority thread e.g. a current thread when both threads are contending for the same resource.

At the current thread attempts to acquire a mutual exclusion object e.g. a MUTEX . The MUTEX is associated with the resource required by the current thread. Unlike a semaphore the MUTEX will be owned by the current thread. Successfully acquiring the MUTEX will cause other threads or processes attempting to access the resource to block on the MUTEX. If the MUTEX is locked by the blocking thread at and the current thread is real time at the scheduler determines if the power priority value of the blocking thread is less than the power priority value of the current thread at . If the power priority value of the blocking thread is not less than the power priority value of the current thread at the current thread blocks and is added to a waiting queue for the MUTEX at .

If the power priority value of the blocking thread is less than the power priority value of the current thread at the scheduler saves the power priority value for the blocking thread e.g. in a thread structure sets the power priority value for the blocking thread to be at least equal to the power priority value of the current thread at and then blocks the current thread at . The blocking thread executes until the resource is released.

If the computing device transitions to a new power state having a lower power priority value e.g. less permissive one or both of the blocking thread and the current thread may block. For example if the new power state of the computing device permits or allows execution of threads with the power priority value of the current thread the blocking thread executes until the resource is released. If the new power state of the computing device does not permit or allow execution of threads with the power priority value of the current thread both the current thread and the blocking thread block or are filtered out until the power state of the computing device transitions to a more permissive state. Alternatively or in addition the power priority value of the blocking thread may be increased again to enable the blocking thread to execute in the new power state to allow the resource to be released.

In an example the power priority value is adjusted by updating a database via an application programming interface API . In an embodiment the power priority value for the blocking thread is set to the maximum power priority value among the threads waiting for the resource. Additionally a flag bit or other indicator is created to reflect that the power priority value of the blocking thread was adjusted and the original power priority value is stored or otherwise preserved for eventual restoration in a data structure see . Element reflects inheritance priority borrowing priority inversion or other adjustment of the power priority value to enable the resource to be eventually released.

In general if a first thread blocks a resource but has a power priority value less than the threshold value for a newly detected power state of the computing device and a second thread requires the resource and has a power priority value greater than the threshold value the power priority value of the second thread is assigned to the first thread to enable the first thread to execute to release the resource. Release of the MUTEX is next described in .

Referring next to an exemplary flow chart illustrates restoration of an inherited power priority value after thread completion and release of a resource. At the blocking thread from releases the MUTEX. At the scheduler determines whether the power priority value of the blocking thread was inherited from another thread boosted or otherwise adjusted. For example the scheduler accesses a data structure used to indicate whether the power priority value had been adjusted e.g. as described in . If so the original power priority value is restored from the data structure or other data structure e.g. a thread data structure at . A next thread in the MUTEX waiting queue is signaled at that the resource is available for use by the next thread.

Referring next to an exemplary flow chart illustrates adjustment of the power priority value for a thread contending for a semaphore. In an embodiment the semaphore is not owned by a thread. At a WaitForSingleObject function is called for the semaphore. This function returns when the semaphore has been signaled. When the semaphore is available the power priority value of the blocking thread inherits the threshold value to ensure that the blocking thread will run. For example at the power priority value of the blocking thread is saved and then set to be the lesser of the power priority value of the blocking thread and the threshold value minus one. Additionally a flag bit or other indicator is created to reflect that the power priority value of the blocking thread was adjusted and the original power priority value is stored or otherwise preserved for eventual restoration in a data structure see . The current thread then contends for the semaphore. If the semaphore has not signaled at the current thread blocks and is added to a waiting list for the semaphore at . Release of the semaphore is next described in .

Referring next to an exemplary flow chart illustrates release of the semaphore and restoration of the power priority value . At the semaphore is released by the blocking thread. At the scheduler determines whether the power priority value of the blocking thread was inherited from another thread boosted or otherwise adjusted. For example the scheduler accesses a data structure used to indicate whether the power priority value had been adjusted e.g. as described in . If so the original power priority value is restored at . A next thread in the waiting queue is signaled at that the semaphore is available for use by the next thread e.g. the current thread from .

A computer or the computing device such as described herein has one or more processors or processing units system memory and some form of computer readable media. By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Combinations of any of the above are also included within the scope of computer readable media.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer. Although described in connection with an exemplary computing system environment embodiments of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of any aspect of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments of the invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. The computer executable instructions may be organized into one or more computer executable components or modules. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the invention may be implemented with any number and organization of such components or modules. For example aspects of the invention are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other embodiments of the invention may include different computer executable instructions or components having more or less functionality than illustrated and described herein. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

The embodiments illustrated and described herein as well as embodiments not specifically described herein but within the scope of aspects of the invention constitute exemplary means for maintaining the list of active threads and the list of suspended threads as a function of the power priority value and the threshold value and exemplary means for managing execution of the threads based on the power state of the computing device .

The order of execution or performance of the operations in embodiments of the invention illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and embodiments of the invention may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the invention.

When introducing elements of aspects of the invention or the embodiments thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

Having described aspects of the invention in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the invention as defined in the appended claims. As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

