---

title: Query processing pipelines with single-item and multiple-item query operators
abstract: Queries against data sources (such as language-integrated queries to be applied against relational databases) may be prepared for processing by a query processing pipeline. This pipeline performs services including transforming the query into a form more easily applied by the data source, e.g., into SQL, by matching query terms with query operators configured to handle various query operations. Many query processing pipelines include single-item query operators that perform individual operations (e.g., an updating query operator that specifies an updating of individual records of a table.) An integrated query pipeline may be devised that includes both single-item query operators and multiple-item query operators that specify operations on sets of data items. An integrated query processing pipeline may analyze the query to determine whether a single-item or multiple-item operation is specified in order to select an appropriate query operator, which may improve the efficiency and performance of the data source querying.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08375044&OS=08375044&RS=08375044
owner: Microsoft Corporation
number: 08375044
owner_city: Redmond
owner_country: US
publication_date: 20080624
---
Queries of data sources e.g. SQL queries applied against a relational database are often written in a programming language such as a source code for an application. A query written in one manner e.g. a language integrated query specified according to a programming language is often processed by a query processing pipeline which interfaces the query with the data source by parsing the query translating it into a more easily managed form e.g. SQL or an expression tree serializing any objects or values used in the query and sending the translated query to the data source. The query processing pipeline may also receive a query result such as a result data set and may present it to the rest of the application.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Query processing pipelines often involve one or more query operators which are components configured to provide querying services e.g. parsing the query validating the syntax and generating a translation for a particular query term such as SELECT WHERE JOIN ORDER BY etc. The query processing pipeline may therefore parse the query by selecting a query operator for respective query terms and by invoking the selected query operators to generate appropriate elements of the translated query.

In many query processing pipelines these operators act on a per item basis and may reference a local representation of the data source. For example an UPDATE query operator may operate on a local representation of a data table and may specify a SQL query for each updated record that specifies how the record in the local representation differs from the corresponding record in the data source. While this is suitable for some scenarios e.g. where the records have changed in individualized ways this may be very inefficient in other scenarios e.g. where a set of records having a certain characteristic are to be updated in bulk. For example where a particular attribute of records in a table is to be incremented an individualized query may examine the local representation of the data table compute the new value of the attribute and set the attribute or the individual records of the data source e.g. set X 12 where ID 1 set X 46 where ID 2 . . . The use of an individualized query operator for an operation on more than one item results in an undesirable multiplication of queries which may create considerable performance difficulties.

A more efficient technique for processing queries involves a query processing pipeline having two types of query operators single item query operators that operate on one item e.g. one record and multiple item query operators that operate on many items having a shared property. When choosing a query operator for a term of a query the query processing pipeline may assess the logic of the query term and may select either a single item version or a multiple item version of the query operator based on the desired operation. By adding multiple item query processors to the set of single item query processors the query processing pipeline may therefore achieve a more efficient and robust parsing translating and applying of the query to the data source.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Queries against data sources such as relational databases may be devised in many computing scenarios such as data driven applications and websites rendered from content management systems. A query is conventionally written in a language such as a general query language such as SQL a domain specific query language or a programming language such as a language integrated query and specifies the logical operations to be performed on a data source in order to retrieve a desired set and shape of data from the data source and or to alter the data source in a desired manner.

A query written in a language is often processed in order to issue the query against the data source. This processing may involve e.g. validating the syntax of the query according to the conventions of the language transforming the query into a form that is more easily processed by the data source such as an expression tree and serializing local objects to be used in the query. The query may then be delivered to the data source e.g. a relational database server for application against the data source. If the application results in a response such as an indication of query success or completion or a result data set retrieved by the query the processing may also involve receiving and handling the response e.g. by deserializing one or more objects representing the result data set. Together these processing aspects form a query processing pipeline that provides a variety of services while operating as an interface between the query and the data source.

Query processing pipelines are often designed predominantly to handle the four basic types of queries CREATE or INSERT queries which insert new records or objects into the data source READ or SELECT queries which retrieve data from the data source UPDATE queries which modify data already in the data source and DELETE queries which remove records or objects from the data source. Other types of queries may also be available such as queries that explore or modify the structure of the data source but these four types of queries often comprise the bulk of interactions with the data source.

In order to handle the four predominant types of queries CREATE INSERT READ SELECT UPDATE and DELETE query processing pipelines are often configured with a set of query operators that are configured for one of these actions such as an insert query operator a select query operator an update query operator and a delete query operator. Other query operators may be included to handle other operations of the query e.g. a join query operator may be provided for operations that involve connecting different sets of relationally linked data a sum query operator may be provided for operations that involve adding a series of values and a sort query operator may be provided for operations that involve sorting values. These query operators may provide a variety of services in the query processing pipeline such as validating the syntax and logic of the specified operation and generating SQL or a node of an expression tree representing the specified operation. The processing of the query may then involve parsing the query to identify the types of operations specified in the terms of the query selecting an appropriate query operator for respective terms of the query and invoking the query operators to perform a service such as generating SQL for these query terms.

Different types of query processing pipelines may feature different sets of query operators that perform different types of services. However in many query processing pipelines the predominant query operators are devised to handle data on a per item basis. For example an update query operator may be configured to update records of a relational data source or objects of an object oriented data source etc. by querying the data source for each update on a per item basis. If the query updates several items the update query operator may individually request each update. This may be achieved with reference to a local representation of the items to be changed. The update query operator may examine each item to be changed determine which aspects of respective items have been altered since retrieval from the data source and may issue one updating query for each item to request the alterations that synchronize the version of the item in the data source with the local representation.

A per item configuration of query operators may be suitable for many types of query operations and for many types of queries. If respective items have changed in individualized ways it may be efficient to record the changes to each item in the data source. However for other types of query operations and queries a per item configuration may be inefficient. If a query specifies an updating of many items in the data source in a similar manner such as by incrementing a numeric property of the items by a fixed amount then it may be inefficient for the query operator to specify a new value for each updated item. This per item manner may involve reading the former value of each item incrementing the value and querying the data source to set the new value for the item. Similarly if many items matching a certain condition are to be deleted it may be inefficient for the delete query operator to identify the individual items to be deleted and to query the data source to delete respective items. These inefficiencies may create significant problems where the query operates on a large number of objects since data sources often include millions or billions of items.

The first query in is parsed into constituent query terms comprising a from query term a where query term a select query term and two set query terms. The parsed query terms are matched with query operators which are then invoked to generate SQL query terms that are combined to form a translated query in SQL. This translated query specifies an updating of a particular record identified by an ID field presumably a primary key of the relational table and indicates that a couple of attributes are to be set to particular values. Similarly the second query in is parsed into constituent query terms comprising a from clause three where clauses a select clause and a set clause. The portion of the query processing pipeline again matches the parsed query to query operators configured to perform the operations specified by the query terms and the query terms are subsequently invoked to produce a set of translated queries in SQL that together perform the update operation. However the second query specifies an operation to be performed on multiple items sharing some properties in this case multiple books written by the author Clarke in the category of science fiction that are not currently checked out are to be marked as Reserved . Because the query operators are configured to process the query terms on a single item basis the query operator for the Update operation generates SQL statements by referencing the local representation of the data source identifying the records that match the Where clause conditions selecting the primary key the ID attribute of the records and generating a translated query that updates each item identified by its primary key. As a result the single item Where query operator produces one query for each item to be updated. This single item processing may be very inefficient where the number of updates is very large e.g. where the local representation and the data source include a large number of records to be updated.

An alternative technique may be devised that reduces the inefficiency of processing multiple item queries with single item query operators in the query processing pipeline. Instead of operating on a per item basis it may be more efficient for a query operator to specify the operation to be performed and the types of items involved. For example the updating query operator may instruct the data source e.g. by generating appropriate SQL or a particularly configured node in an expression tree to increment the specified property by a fixed amount for all items matching a certain condition and the delete query operator may specify that all items matching certain criteria are to be deleted. Thus instead of formulating a series of queries such as delete item delete item delete item the delete query operator may formulate a single query such as delete items where property X 100. 

One technique for achieving this capability is to supplement the set of single item query operators with multiple item query operators. For example a single item delete query operator may be included that deletes items on a per item basis and a multiple item delete query operator may be included that deletes sets of items having specified characteristics. The query processing pipeline may parse a term of a query to determine not only which type of query operator is to be selected but also to determine whether the query term specifies a single item operation that is better handled by a single item query operator or a multiple item operation that is better handled by a multiple item query operator. The query processing pipeline may therefore provide an improved interface that more flexibly operates on the data source e.g. by formulating operations that are more appropriate to the circumstances of a query and by economizing resources such as network bandwidth while performing such operations.

Moreover the integration of the multiple item query operators with the single item query operators in the query operators set promotes the processing of queries in a consistent manner. It may be possible to devise a first query processing pipeline for single item queries and a second query processing pipeline for multiple item queries. However this solution may be less advantageous in several aspects. As a first example the creation of two or more query processing pipelines may involve a duplication of query processing components such as those that perform query translation query sending and query mapping. The duplicate components may consume additional computing resources volatile system memory storage etc. and separate maintenance steps may be involved to keep the duplicate components in order. Additionally the duplicate components may process queries in a different manner giving rise to discrepancies in parsing similar queries that may be difficult to explain. As a second example the query processing pipelines may generate some data structures to facilitate query processing such as a set of mappings of data source objects and caches of various aspects of the data source such as the local representation of the data source illustrated in . A non integrated set of query processing pipelines one for single item queries and one for multiple item queries may result in a duplication of such resources and additional resources may be involved in synchronizing these resources. For example if an alteration of a single item is made through the single item query processing pipeline a cached version of the item in the multiple item query processing pipeline may become stale without notice unless a resource consuming synchronization is performed to promote consistency of the caches. In these and other aspects an integrated query processing pipeline having both single item query operators and multiple item query operators may be advantageous over solutions featuring a multitude of query processing pipelines.

The exemplary system utilizes these resources to process the query and deliver it to the data source in the following manner. The exemplary system includes a query transforming component which is configured to transform the query into an expression tree . The exemplary system also includes a query identifying component which is configured to identify the query as one of a single item query and a multiple item query. The exemplary system also includes a query operator selecting component that utilizes the identification of the query as a single item query or a multiple item query to select at least one single item query operator of the set of query operators invoked by a single item query and or at least one multiple item query operator of the set of query operators invoked by a multiple item query. The exemplary system also includes a query translating component which is configured to invoke the selected query operators to map the data source references of the expression tree to respective aspects of the data source using the data source mappings and to translate the expression tree into a translated query in a query language such as SQL. Finally the exemplary system includes a query sending component that is configured to send the translated query to the data source for processing. By processing the query in this manner the exemplary system achieves the application of the query to the data source in an efficient manner that is better suited to the single item or multiple item nature of the query .

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary method of and the exemplary system of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments of these techniques relates to the exchange of data associated with the query and the data source. As a first example the query may reference one or more local objects e.g. an object to be compared with items in an object database to determine if it is already present in the database or an object containing a stored procedure to be invoked during the query. The query processing pipeline may facilitate the delivery of the object to the data source by serializing the at least one local object and sending a serialized representation of the at least one local object to the data source. As a second example the query may produce a result such as an indication of success or failure of a query or a data set returned by a select query. The query processing pipeline may also facilitate the receipt of such results from the data source by receiving the query result from the data source in response to the query. The query processing pipeline may simply store the query result for use by the application. Alternatively if the query result comprises at least one object the query processing pipeline may deserialize the at least one local object or if the result is data bound within the application the query processing pipeline may store at least one aspect of the query result e.g. an attribute a count of returned items etc. in at least one of a primitive variable and or at least one field of at least one local object. Many additional features may be added to the query processing pipeline to facilitate the exchange of data with the data source while implementing the techniques discussed herein. Those of ordinary skill in the art may devise many techniques for handling data exchange between the query and the data source while implementing the techniques discussed herein.

A second aspect that may vary among embodiments relates to the data set mappings. The data set mapping provide information about the objects of the data source databases tables attributes stored queries and procedures etc. and facilitate the association of references in a query with the objects of the database. This resource may be formulated and stored in many ways e.g. as a schema definition of the data source such as an XML Schema Definition object or XSD and or as a set of metadata associated with respective aspects of the data source e.g. as part of a local representation of the data source. It may be appreciated that the development of a set of mappings as part of an integrated query processing pipeline featuring both single item query operators and multiple item query operators may be advantageous over embodiments featuring separate query processing pipelines for single item queries and multiple item queries wherein duplicate sets of mappings may be generated that consume additional computing resources and may produce erratic query processing results if the sets of mappings fall out of synchronization. Those of ordinary skill in the art may devise many techniques for mapping aspects of the data source query references to while implementing the techniques discussed herein.

A third example that may vary among embodiments of these techniques relates to the formulation and use of one or more data source caches which may be configured to store one or more aspects of the data source for local access that reduces the costs of network transport. One example of a data source cache is the local representation of a portion of the data source illustrated and utilized in the exemplary scenario of . By referencing a cached version of an aspect of the data source the application may reduce an unnecessary fetching of data from the data source and enhance the completion of query processing. The data source cache may be configure to store aspects of a result data set received from the data source so that subsequent queries pertaining to the same data items may instead use the values stored in the data source cache instead of re querying the data source. For example the query processing pipeline may evaluate whether a query is a selecting query or an updating query. If the query is a selecting query the query processing pipeline may query the data source cache to identify at least one cached data source aspect referenced by the selecting query. If such an item is found the query processing pipeline may return the cached data source aspect to the application in response to the query but if such an item is not found the query processing pipeline may send the query to the data source and store one or more aspects of the result data set in the data source cache to facilitate subsequent queries for these data items. The query processing pipeline may also cache updated values written to the data source e.g. by identifying an altering query and caching at least one altered data source aspect in the data source cache. Again it may be appreciated that an integrated query processing pipeline may be advantageous as compared with a set of two or more query processing pipelines for processing single item queries and multiple item queries respectively which may involve a duplication of data source caches and a potential for inconsistent query processing of single item and multiple item queries in the event of a desynchronization of the data source caches. Those of ordinary skill in the art may devise many techniques for caching aspects of the data source while implementing the techniques discussed herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

