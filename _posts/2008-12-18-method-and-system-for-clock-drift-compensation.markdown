---

title: Method and system for clock drift compensation
abstract: Different sampling rates between a playout unit and a capture unit are compensated for via a system, method and computer program product. The playout unit receives samples from a computational unit, and the capture unit sends samples to the computational unit. A playout FIFO buffer operates in a playout time domain, and a capture FIFO buffer operates in a capture time domain. The computational unit is synchronized to a common clock. A first relationship is calculated between the common clock and a playout fifo buffer read pointer, and a second relationship is calculated between the common clock and a capture FIFO buffer write pointer. For each sample in the playout time domain a corresponding sample in the samples from said computational unit is found and sent to the playout FIFO buffer. For each sample in the common clock time domain the corresponding sample in the capture time domain is found and sent to the computational unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08515086&OS=08515086&RS=08515086
owner: 
number: 08515086
owner_city: 
owner_country: 
publication_date: 20081218
---
This application claims the benefit of U.S. Provisional Application No. 61 014 636 filed Dec. 18 2007 the entire contents of which being incorporated here by reference.

The present invention relates to clock drift compensation and in particular clock drift compensation methods apparatuses and computer program product for echo cancellers implemented on computer based systems.

In a conventional conferencing system or any hands free e.g. not a handheld telephone held to a person s ear system one or more microphones capture a sound wave at a site A and transforms the sound wave into a first audio signal i.e. an electric signal that conveys the audio content . The first audio signal is transmitted to a site B where a television set or an amplifier and loudspeaker reproduces the original sound wave by converting the first audio signal generated at site A into the sound wave which is audible to the human ear.

If the uncancelled microphone signal were transmitted to the far end the participants at the far end site would hear an echo s of themselves and if a similar system were present at the far end even howling feedback might occur.

To deal with this problem it has been proposed to add an acoustic echo canceller to the digital microphone signal path. This canceller uses the digital loudspeaker signal as a signal reference and estimates all of the loudspeaker to microphone paths and subtracts these estimates from the uncancelled microphone signal making the cancelled microphone signal which is transmitted to the far end as signal .

Two main approaches are widely used for acoustic echo cancellers today a full band canceller and a sub band canceller. Both of these approaches normally use adaptive FIR finite impulse response filters for the echo path estimating however applying these in full band domains and sub band domains respectively.

An acoustic echo canceller used in a product will typically include several further sub blocks not shown in the figures in this document a double talk algorithm a non linear processing unit comfort noise generation etc. For simplicity these sub blocks are omitted. These blocks may vary and also are well documented in papers patents and literature. For a person skilled to the acoustic processing art integrating of these blocks in a signal processing stream is straightforward.

The digital signal from far end is passed to the loudspeaker as signal and is also used as the loudspeaker reference signal .

The loudspeaker reference signal is filtered through the adaptive FIR filter . This adaptive filter converges to and tracks the impulse response of the room in which the microphone is located. For the initial convergence and for any acoustic changes in the room door opens people move etc. the adaptive FIR filter has to adapt. Many different adaptive algorithms can be used for this purpose from the inexpensive low processing power least mean square LMS to more sophisticated and more resource demanding algorithms as affine projection algorithm APA and recursive least squares RLS . However in common all these algorithms use the FIR filter update loop for adapting.

The adaptive FIR filter outputs an inverted echo estimate which is added to the uncancelled microphone signal calculating the echo cancelled microphone signal .

The digital signal from the far end is passed to the loudspeaker as signal . It is also divided into a chosen number of subbands using the analyze filter .

For each subband the loudspeaker analyze filter outputs a subband reference signal which is filtered through a subband FIR filter calculating an inverted subband echo estimate . The microphone analyze filter outputs a subband uncancelled signal which is added to the inverted echo estimate outputting a subband echo cancelled microphone signal . The echo cancelled microphone signal is used for the adapting of the FIR filter shown as the subband FIR filter update loop .

The echo cancelled microphone signals from all subbands are also merged together to a fullband cancelled microphone signal by the synthesize filter .

Both the fullband and subband echo cancellers estimates the response from output digital samples to input digital samples . This response is affected by any software or hardware that the signal passes through including but not limited to sampling rate converters mixers the D A converter the loudspeaker the acoustic coupling the microphone and the A D converter. It is inherent in the design that the rate of samples in the input signal equals the rate of samples in the output signal . For best performance the response including the delay of controllable parts should be kept constant.

In well designed systems the equal sampling rate is ensured by using the same clock source for the D A and A D converters whereas constant or at least predictable delay is maintained by proper hardware and software design.

However in some designs as recognized by the present inventors different clock sources are used for the A D and the D A converter. This is for example the case in personal computers PCs where the A D converter and D A converter can be placed on different cards with conversion clocks generated locally on each card respectively. A typical and widely used situation is the case where audio is captured A D converted by a Web camera while the audio is played out D A converted by the PC s audio card.

Two types of drift may be present between the A D conversion rate and D A conversion rate. Both may be present at one time.

Drift occurs due to the clock source crystal oscillator etc. deviation from its nominal value. Crystals have varying levels of performance. Some of the parameters that can be specified for a crystal are frequency stability accuracy in parts per million or ppm as well as limits on the variation in the above parameters due to temperature changes. In general no two crystals are exactly the same. They will oscillate at slightly different frequencies and their other characteristics will differ as well. This means that if the A D and D A converters are driven by clock signals derived from different crystals there will be a slight difference in the rate at which those converters will run even when the crystals run at the same nominal frequency and the dividers for the A D and D A match. In this case the number of samples produced over time by the A D will not match the number of samples consumed in the same period of time by the D A. The longer this period of time during which the number of samples generated by the A D is compared to the number of samples consumed by the D A the greater the difference in the number of samples processed by the A D and D A.

Drift can also occur due to incompatible sample rates. When a capture playout device does not support the sample rate of the audio stream a software sample rate converter is inserted by the operating system. However this sample rate converter may have a limited resolution and thus the nominal sampling frequency will vary. The difference is constant over time but can be considerably big. A typical value often experienced is 0.625 i.e. 6250 ppm.

In the playout system the DAC digital to analog converter is clocked by the DACCLK i.e. the DAC processes samples with a rate dictated by DACCLK . The DACCLK is usually derived from a much higher frequency of the crystal oscillator. The DAC processes one sample at a time from the DAC FIFO . The DAC FIFO can be implemented both in hardware or software. When the DAC FIFO is empty it retrieves Nsamples from the playout SRC sample rate converter which again takes a number of samples from the playout ring buffer which is part of the playout FIFO . Ncan be as low as one but larger numbers groups of samples are also common e.g. N 128 has been observed . Each situation varies depending on the make model software and components used in respective PC s. The playout read pointer is updated with the same number of samples taken from the ring buffer of the playout FIFO . It is the software application s task to ensure that it fills the correct number of samples in the playout FIFO from the playout write pointer . One exemplary software application is a software based echo cancellation application employed at an endpoint terminal used with a videoconference system. This software application may be preinstalled on the PC distributed on a physical media or downloaded over a network from a server.

Similarly in the capture portion of the system the ADC is clocked by the ADCCLK i.e. it produces samples with a rate of ADCCLK . ADCCLK is usually derived from a much higher frequency provided by a crystal oscillator but as stated before not necessarily the same as the ADCCLK. The ADC delivers one sample at a time to the ADC FIFO . The ADC FIFO can be implemented in hardware or software or a hybrid. When the ADC FIFO is full it delivers Nsamples to the capture SRC sample rate converter which again delivers the calculated number of samples to the capture ring buffer directly or indirectly which is part of the capture FIFO . Ncan be as low as one but higher numbers are also common. The capture read pointer is updated with the same number of samples delivered to the capture ring buffer of the capture FIFO . It is the software application s task to ensure that it processes the correct number of samples from the capture FIFO read from the capture read pointer .

The software application transmits and receives samples to from the playout and capture FIFOs respectively.

For applications reading writing audio data to a file or other unclocked sources it is usually simple to produce consume the correct number of samples to from the playout capture FIFO. Even for simplex applications getting delivering audio data from to another clocked source sink correcting the number of samples delivered processed to from the playout capture FIFO is usually rather straightforward by either inserting or removing one or more samples. Such insertions or removals can be performed without audible degradations and techniques for this are well known. As these techniques either insert or remove samples there will be time delay changes but in most applications this is acceptable.

However as recognized by the present inventors for applications where an exact relationship between the samples delivered and the samples processed by the software application is critical another solution must be found. This is the case for echo canceling. It should be pointed out that there are also other applications with this demand for instance measuring applications etc.

Consequently at least one aspect of the present invention is to provide a device and method that solves at least one of the above mention problems with conventional systems.

In the following aspects of the present invention will be discussed by describing example embodiments and by referring to the accompanying drawings. However people skilled in the art based on the teachings herein will realize other applications and modifications within the scope of the invention as defined in the enclosed independent claims.

A common feature of the several embodiments is a clock drift compensator for computational units such as PCs compensating for different sampling frequencies in analog to digital A D and digital to analog D A converters e.g. in audio I O devices connected to or included in the computational unit. The need for this compensation is due to the use of different circuit boards e.g. audio board that include different clock sources which may not be and usually are not derived from a common source. As such the clocks drift relative to each other and unlike custom design circuitry where it is possible to use a phase lock loop to lock the different clocks to one another in a PC environment software providers have limited access to the specific hardware used in the PC as well as the drivers used with that particular hardware. As a consequence in a PC setting audio processing applications interface with audio package sent to the hardware by way of the Microsoft API. Consequently direct measurement and feedback loops at the hardware and driver level are not available for audio processing algorisms available from third parties.

As mentioned above illustrates a typical setup of the playout system and capture system in a PC. In the setup in is extended with a clock drift compensator in accordance with the principles of the present invention. The clock drift compensator is configured to compensate for different sampling frequencies in the playout and capture signal. The clock drift compensator includes a common high frequency HF clock a playout time device or playout time estimator a playout time corrector a capture time device or capture time estimator and a capture time corrector . The drift compensator can write data to the playout buffer which may be queue buffer in particular a FIFO buffer such as a circular buffer or ring buffer and read data from the capture buffer which may also be a queue buffer in particular a FIFO buffer such as circular buffer or ring buffer. Further the drift compensator sends and receives data to from the software applications also referred to as a computational unit e.g. an audio echo cancellation or mechanism . The clock drift compensation unit provides a high frequency clock signal from a common HF clock to the software application such that the software application is synchronized to the common HF clock .

The frequency of the common clock should in this context be understood as high with respect to the nature of analog signal captured by the capture unit and the analog signal output by the playout unit. A clock frequency in the range of approx. 1 MHz to 1 GHz may e.g. be used recognizing that the sample rate of an audio signal is just a fraction of these rates.

The clock drift compensator requests position information from the playout FIFO read pointer and common HF clock as well as from the capture FIFO write pointer and the common HF clock . The clock drift compensator uses the position and clock information to calculate a first relationship between the common HF clock and the playout sample number or the playout read pointer and likewise a second relationship between the common HF clock and the capture sample number or the capture write pointer. Based on these calculated relationships for each sample in the common clock domain the corresponding samples may be found in the capture FIFO and thus creating an input signal to the software application in common clock sampling frequency. Likewise for each sample in the playout domain the corresponding samples are found in the samples from the software application ensuring that the correct number of samples is sent to the playout FIFO.

In the following the clock drift compensator will be described in more detail. When ring buffers are used as buffers e.g. queue buffers FIFO buffers pointers will wrap i.e. wrap around from one end of the buffer to the opposite end . When referring to pointers below an wrapped pointer is described.

In reference to the playout time device or playout time estimator reads multiple sets of data wherein each set is a sample readout of the common high frequency clock and of the playout read pointer . Based on many such sets of data the relation between the playout read pointer and the high frequency clock is estimated. The playout read pointer is used as a representation of the DAC conversion clock . For each sample time in the DAC time domain the software application s corresponding time measured by the application reference clock the common HF clock is able to be calculated. Thus the correct sample value for each sample in the playout domain DAC can be calculated by using a nearest application domain sample and a subsample delay filter by the playout time correcting block . Finally this sample is written to the playout ring buffer . It should be noted in the case where the DAC conversion clock drifts compared to the application common clock the number of samples generated on the output of the time corrector will differ marginally from the number of samples consummated by the time corrector i.e. it will work as a sample rate converter.

Likewise the capture time device or capture time estimator reads multiple sets of data wherein each set is a sample readout of the common high frequency clock and of the capture write pointer . Based on many sets of data the relation between the capture write pointer and the high frequency clock is estimated. The capture write pointer is used as a representation of the ADC conversion clock . For each sample time in the application s time domain measured by the application reference clock the common HF clock the ADC corresponding time can be calculated. Thus the application s correct sample value can be calculated by the capture time correcting block by using the nearest ADC domain samples and known interpolation methods e.g. SINC function weighting between adjacent sample sets to produce new sample s . It should be noted in the case where the application s common clock drifts compared to ADC clock the number of samples generated on the output of the capture time corrector will differ marginally from the number of samples consumed at the input of the capture time corrector i.e. it will work as a sample rate converter. Likewise the sample rate converter can also perform a decimation function to reduce sample rate as part of a compensation function. The decimation rate is adjustable based on the amount of conversion needed to offset the observed drift.

For the compensation between the ADC and DAC only the drift compensator as shown in can be simplified in two ways.

According to one exemplary embodiment of the present invention the software application is synchronized to the DACCLK . In this case the playout read pointer acts as common clock and the capture time device and clock corrector uses this clock as the common clock as illustrated in . Since the playout system and software application are synchronous the playout time device and time corrector may operate in a simplified manner but still consistent with the principles of the invention. In this embodiment the first relationship may be set rather than calculated while the second relationship is calculated.

According a second exemplary embodiment the application is synchronized to the ADCCLK . In this embodiment the capture write pointer acts as common clock and the playout time estimator and playout clock corrector uses this clock as the common clock . Since the ADC and application is synchronous the capture time device and time corrector may operate in a simplified or even trivial manner but they are still consistent with the principles of the invention. In this embodiment the second relationship may be set rather than calculated while the first relationship is calculated.

However in many cases synchronizing to one trusted clock source is advantageous. First of all the common clock should be of high resolution as explained later the playout or capture pointers are not necessarily high resolution . Secondly the software application should use a clock which is as synchronous with real world clock as possible. The latter is important when a communication system communicates with another system or when a measurement system refers to a measurement in real world time.

Therefore according to one embodiment of the present invention a stable and trusted clock source not being DACCLK or ADCCLK is selected as the common HF clock . This common clock also acts as the software applications reference clock. For example the common HF clock could be the PC s system clock. In this embodiment the first and second relationships are both calculated.

Operation begins in step when the software application starts and initiates sending and requesting data to from the playout capture system respectively. According to one exemplary embodiment of the invention software application is an audio echo canceller AEC receiving a digital audio signal from a far side not shown via a communication network such as the Internet or a local network or a hybrid and playing it out on a speaker via a playout system including components and . Sound from the near end is captured and digitalized by a capture system including components and . As described in the background section the AEC calculates an echo free audio signal and sends it back to the far side not shown via a communication network.

As recognized by the present inventors when implemented in a personal computer for example there are some factors complicating the above described compensation scheme.

When the playout capture time estimator reads a data set step the common HF clock and the playout capture FIFO pointer can not be acquired totally simultaneously. One of them will always have to be read first and the other subsequently. Of course as the first clock in the data set is read the second clock continues running. As long as the time between the readings is constant this does not create any problems. However computer hardware and applications often demand various interrupts etc. which in turn would result in variable times between readings. In some cases by disabling interrupts the time estimator can ensure that the time variance between the two readings in each set is insignificant or at least small enough to make it possible to remove the time uncertainty by filtering situation . However some applications do not have the authority to disable interrupts leading to significant time variance between the readouts.

Since some application do not have the authority to disable interrupts the method and device according to the present embodiment checks each data set according to certain criteria and removes the data sets not complying with the criteria. As illustrated in step for each data set the HF clock readout is checked to determine if it is acceptable. This may be done by first reading the common HF clock thereafter the FIFO pointer followed by another reading of the common HF clock . Now each set of data contains three data points instead of two triplet . By analyzing many sets of data a distribution of the time between two common HF clock readouts can be calculated. If the time between the two common HF clock readouts in a data set triplet is abnormal too long according to the distribution such as greater than two or more clock periods it is assumed that something unusual e.g. an interrupt has occurred making the data set uncertain. Such uncertain data sets are disqualified step leaving only data sets with low uncertainty for further calculations step .

Another problem as described above is that the FIFO pointer may be updated in rather large steps. In other words the FIFO buffers may not always write read one and one sample at a time but rather read write chunks of data periodically e.g. 128 samples at a time or 16 samples at a time. Therefore consecutive readouts of the playout capture pointer may give the same result or two consecutive reads may also differ by a large value. This is illustrated by an example in .

In the example of the read sets of data would be 0 0 1 0 2 0 3 0 4 0 5 2 6 2 7 2 8 2 9 4 10 4 etc. This acts as a quantization of the actual conversion clock and might cause problems if not treated correctly. Read directly this quantization introduces quantization noise but unlike regular quantization noise this noise cannot be assumed to be a white random process it is very regular and correlated to the clock. The noise manifests as a triangular signal pattern which may give rise to alias problems and similar issues when under sampled due to CPU complexity data sets should not be read too frequently .

One way the present inventors solved this problem was by reading the FIFO pointer when the pointer updates. This saves precious CPU resources since the CPU can be freed during intervals between updates. Typically the software application must ensure request run time just before an expected update of the pointer e.g. using a time interrupt . The expected update time may be found by analyzing the update procedure of the FIFO in an initial phase. For example if the FIFO typically updates with blocks of 128 samples and the conversion clock has a frequency of 48 kHz the drift compensator can stop reading the FIFO pointer and or for approx N 128 48000 seconds where N is any positive integer number chosen as a compromise between CPU complexity and accuracy after an update before it resumes reading new data sets. Just before an expected update the drift compensator reads triples until the pointer updates between two consecutive common HF clock readouts. In practice this is implemented by reading common HF clock then FIFO pointer HF clock FIFO pointer and so on until the pointer has been updated e.g. C P C P C P C etc. where C denotes read of clock and P denotes read of pointer. If the FIFO pointer updates from P to P the common HF clock being registered is C or some average or weighting of C C and C . The pointer being registered is typically but other variants are applicable the average of P and P . To comply with the previous criteria the time between C and C must not be abnormal high or else the date set would be discarded step . From a CPU load point of view it would be best to test for a transition in the pointers while reading them. However to reduce time uncertainty i.e. ensure as low time as possible from in this case C to C it may be advantageous to log the sequence for a given time until expected transition of pointer a margin and locate the transition afterwards.

Yet another problem needs to be addressed in order to ensure that further calculations are not influenced by incorrect or uncertain data sets. Due to deficiencies in personal computers strange and unexpected behaviors of the FIFO pointers are experienced unexpected update steps pointers going backwards etc. This behavior may be caused by the audio card drivers trying to compensate for drift queuing problems out of order execution of requests etc. Therefore as illustrated in step for each data set not discarded in step another check is performed. As mentioned above data is analyzed over time and statistics are also kept over normal pointer increments. If the pointer is updated by an abnormal value that data set is discarded step . For example if a pointer is consecutively updated with 128 samples over a period of time an update deviating considerable from 128 samples is considered as an uncertain dataset and hence discarded. However due to the sample rate converter a deviation with one sample i.e. an update of either 127 or 129 must be considered as a valid update.

Over time multiple pairs of C and P data will be approved in both step and step and are then registered step . This data is processed with an algorithm forgiving all disqualified pairs meaning it must not require uniform sampling. Further from the noisy noise from situation set of pairs it must estimate the relationship between the common HF clock denoted by C and the pointer denoted by P with adequate accuracy. Therefore according to one embodiment of the present invention the relationships between the common clock and the capture pointer and between the common clock and playout pointer are calculated based on statistical models. In the following some suitable linear regression methods are introduced. However other statistical models may be used within the scope of the invention.

The factor is the rate relationship between the common HF clock and the pointer and will have a value of nominal HF clock frequency divided by the pointer update rate plus minus a smaller value defining the clock drift constant. The factor is just an offset eliminating the normal case where C and P do not start at zero at the same time.

Therefore in step the factors and are calculated. According to one exemplary embodiment of the invention the least mean square algorithm is used as a filtering algorithm 2 3 4 5 

The accuracy of Cimproves with higher number of data pairs M . However over time the drift offset may change invalidating the linear relationship between Pand C a changes . Therefore the time between the first and last data sets in the calculation must be selected as a compromise between accuracy requires long time and ability to track changing drift factor requires that the linear relationship is a good approximation therefore a limitation of time . A higher order model could be used simplifying this compromise but in practice the drift factor varies slowly enough to make a suitable compromise using a linear first order model.

The necessity of keeping track of changing drift factor means that the oldest sets of clock pointer data must be left out of the calculation as new data sets are retrieved i.e. the sums above will be calculated as a sliding window. It is not necessary to calculate the sum directly for each new pair of data. To save CPU cycles an update of the new and oldest data sets is sufficient 8 9 10 11 

Although the above equations are theoretically correct error build up due to limited precision rounding may cause problems. Therefore according to another exemplary embodiment of the present invention a loss factor is added to the calculation 14 15 16 17 0 . . . 1 18 19 20 Sis constant and thus only needs to be calculated once.

The loss factor is typically selected a little smaller than unity e.g. 0.95 0.9 0.85 etc. . This factor will reduce the influence of older data which is not intentional necessary but will not cause any problems either and it will also introduce a forgetting factor for round off errors.

The adding of a loss factor makes it possible with one further simplification. By selecting M as infinity approaches 0 and therefore the subtractions in the sliding sums 14 17 can be omitted and no data has to be stored in delay lines for the summing purposes. The drawback is an even harder compromise between proper filtering and the ability to track changing drift factor. All data pairs will live forever but tracking the drift factor may in many cases be possible since older data pairs by proper selection of the loss factor may have an insignificant weight in the calculations.

The correct time C with respect to the common HF clock of any sample pointer can be calculated based on the estimated and equation 1 C P step .

The task of the playout time corrector and the capture time corrector is to calculate correct sample values in one time domain based on the known samples in another time domain knowing the time offset skew between the different domains.

In the following a description is provided on how to capture domain samples converted to common domain samples according to one embodiment of the present invention. However the conversion from common domain to playout domain is similar.

Based on the calculated clock relationship step for each sample in common domain the capture sample time corrector finds the corresponding samples in the capture domain. The term corresponding sample is to be interpreted as for each sample time in the common domain the sample value in the capture domain for that time is found either by copying a sample value directly if a sample at that time exists or by calculating the sample value at that time using some sort of interpolation technique. So for each sample in common domain the capture sample time corrector finds the sample index j in the capture domain which is closest in time to the sample in common domain step . If the offset time skew between the domains is an integer sample j can be copied and used directly step . However the offsets time skews are usually not integers. Therefore a fractional value hereafter referred to as residual factor is calculated step . The residual factor is the remainder after subtracting the integer offset skew value and defines the sub sample delay and should be between approximately 0.5 and 0.5. It should be noted that values marginally outside the 0.5 0.5 range may occur due to the drift in sampling frequencies.

Delaying a signal with a sub sample delay may be performed using an all pass filter with a constant time delay. A sinc pulse with an offset has these properties. A sinc pulse however is by definition infinite in length and in practical implementations a window must be applied. The window s characteristics and length must be chosen to ensure that the frequency response both magnitude and delay has adequate accuracy in all frequencies of interest. For example if the echo canceller works with a sampling rate of 16 kHz audio signals up to 7 kHz are normally present. In this case the magnitude and delay of the frequency response must be flat up to 7 kHz whereas the magnitude and phase may deviate from the ideal response above 7 kHz since there are no signals in this band. One window type found to have very good characteristics for this purpose is the Blackman window.

When selecting L 48 Blackman window sampling frequency of 16 kHz and frequencies of interests up to 7 kHz the time delay error of this filter is less than 0.005 samples and the amplitude error is less than 0.005 dB such small errors will not cause noticeable degradations of echo canceller performance.

Finally in step the sample y in other words sample value at j in the common clock domain is calculated as the convolution of the time delay filter h and a series of samples from the capture domain 2 2 22 

Here x is the time series of samples from the capture time domain. The vector of samples used in the calculation is centered around the sample closest in time defined by j whereas remaining sub sample delay is defined by the all pass filter h.

In the case of drifting the residual factor will change for each sample and hence a new filter h is necessary for each sample. Calculating a new filter for each sample may be too computationally exhaustive. Although proper selection of data sets and proper filtering is secured there will always be some residual noise on the time delay. Therefore without noticeable degradation it is possible to define a e.g. uniformly distributed discrete set of delays and corresponding set of precalculated filters. During processing the precalculated filter with the smallest error compared to the actual delay is selected. The effect of this is the same as a quantization of . It should be noted that since the sub sample delay may exceed the 0.5 0.5 range there should be some precalculated filters dealing with these exceeding delays as well.

This time correction algorithm will for consecutive common clock domain samples act as a resampler from the capture domain to the common domain. If there are any drift in frequency the estimated times will drift correspondingly and therefore the rate and number of samples will be changed slightly from the capture domain to the common clock domain as intended. It should be pointed out that using an all pass filter as the filter in a rate conversion algorithm according to one embodiment of the invention has some theoretically scruples e.g. the SINC width should ideally be adapted to the sample conversion rate. However for practical purposes these theoretical aspects are insignificant since the conversion rate is always very close to unity.

The same type of correction as discussed above is performed on the playout side. Hence the software application e.g. the echo canceller algorithm implemented in the computational unit sees the same sample frequency time base on all signals sent and received. Therefore no modification of e.g. standard echo canceling algorithms are required to make it work on systems with non synchronous ADC and DAC conversion rates.

In PCs glitches in audio capture or playout are frequently present. These may be big glitches caused by complete lost frames of audio data or loss of a single sample. The reason may be CPU overload or similar. It is out of scope of this invention to define methods for detecting and adjusting for such glitches. However using the described approach timing calculation is possible with an accuracy of a small fraction of a sample and eventual glitch is possible simplifying such detection and correction.

The method and drift compensator according to the present invention have several advantages. Any drift or other differences in timing is efficiently detected with high accuracy making the software application e.g. echo canceller or other computational units work properly. Due to the high accuracy other infirmities like glitches can be easily detected and compensated for.

Since there are no resetting algorithms any change of situation will be automatically detected and compensated for by the algorithm. There will be no error or offset build ups the path from the application output e.g. echo canceller loudspeaker signal to the applications input e.g. the echo canceller microphone input through the playout and capture systems and software layers are always constant.

The complete system is clocked synchronized to a trusted and well known clock source and not relying on any vendor of ADC or DAC subsystem.

The clock drift compensator is a completely separate module which means that it can be used with standard applications without any need for adjusting these applications. For example an echo canceller developed for embedded products with synchronous ADC and DAC can be used in a PC with drift issues as discussed without further modifications.

The clock drift compensator according to the present invention is applicable for any type of application requiring a known fixed relationship between DAC and ADC.

The clock drift compensator may be used for acoustic echo cancelling in a teleconferencing system such as a telephone conferencing system or a videoconferencing system. One exemplary platform is a personal computer having a processor based system like that described in co pending U.S. application Ser. No. 11 966 773 filed in the US on Dec. 28 2007 the entire contents of which being incorporated herein by reference. A particular example is an Intel Mobile Core 2 Quad laptop or desktop computer which may or may not be running TANDBERG s MOVI software and connected to a TANDBERG MOVI server. Likewise teleconference endpoints such as H.323 endpoints or even conference room systems such as the MXP product line e.g. MXP 8000 available from TANDBERG could host the acoustic echo cancelling system. The PC includes an audio board such as a SOUND BLASTER X Fi by CREATIVE.

In particular the clock drift compensator may be incorporated in a teleconferencing terminal such as a telephone conferencing terminal or a videoconferencing terminal for obtaining acoustic echo cancelling in a teleconferencing system wherein such teleconference terminals intercommunicate via a communication network.

Such a teleconferencing terminal may further include a computational unit such as a regular personal computer executing an operating system and software applications a D A converter configured to read digital data from the playout FIFO buffer comprised by the playout unit included in the clock drift compensator an audio amplifier configured to amplify the analog signal provided by the D A converter an audio loudspeaker connected to the output of the audio amplifier a microphone a microphone amplifier connected to the microphone an A D converter arranged for converting the microphone amplifier output signal to digital form and providing the digital signal to the capture FIFO buffer comprised by the capture unit included in the clock drift compensator. The computational unit may be operatively connected to a communication network such as a local area network and or the Internet thus enabling a teleconference system over the network. The teleconferencing terminal may additionally include a camera a display and further structural and functional features for enabling video conferencing.

