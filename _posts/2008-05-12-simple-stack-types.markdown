---

title: Simple stack types
abstract: Embodiments that facilitate type checking of assembly language instructions are disclosed. In one embodiment, a method includes receiving a low level language instruction in a memory. The instruction includes a word having a first type. The memory includes either a stack or a heap. Each of the stack or heap includes a plurality of positions. The method also includes labeling the plurality of positions in one of the stack or the heap as one or more specified positions and one or more unspecified positions. The method further includes assigning a second type to the memory, the second type including the first type of the word. The word is stored in a specified position or an unspecified position. The method additionally includes determining whether the instruction is well-typed by applying one or more rules to the instruction and to the second type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07975121&OS=07975121&RS=07975121
owner: Microsoft Corporation
number: 07975121
owner_city: Redmond
owner_country: US
publication_date: 20080512
---
High level programming languages such as Java C and C are generally used to produce source codes. These source codes are optimized and compiled by compilers to assembly language code before they are executed on machines. Compilers may contain program errors which are also known as bugs which may cause the compilers to compile safe source code to unsafe assembly language code. Programs based on unsafe assembly language code may malfunction and or cause other programs to malfunction. In some instances the safety of assembly language code may be verified after compilation by type checking mechanisms provided that the source code is compiled into the assembly language code by a special type of compilers known as type preserving compilers. A type preserving compiler generates the evidence needed by the type checking mechanisms by transforming a well typed source code into a well typed assembly language code preserving the types in the intermediate code during each compilation phase between the source code and assembly language code. Type checking relies on the premise that a specific type indicates a set of values or expressions that have the same sort of generic meaning or intended purpose.

This Summary is provided to introduce a selection of concepts in a simplified form that is further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Described herein are embodiments for implementing a type checking system that enables a compiler to detect program errors during the compilation of a source code into an assembly language code. As used herein assembly language code refers to any low level language code. Such low level language code may include but is not limited to intermediate code bytecode typed assembly language TAL code and the like. For example a compiler may transform a source code into an assembly language with stack and or heap operations. Accordingly the embodiments described herein may enable a type checker function of a compiler to perform type checking on stack and or heap operations. In other words the type checker function may perform type checking during compilation by the compiler.

In one embodiment a method includes receiving a low level language instruction in a memory. The instruction includes a word having a first type. The memory includes either a stack or a heap. Each of the stack or heap includes a plurality of positions. The method also includes labeling the plurality of positions in one of the stack or the heap as one or more specified positions and one or more unspecified positions. The method further includes assigning a second type to the memory the second type including the first type of the word. The word is stored in a specified position or an unspecified position. The method additionally includes determining whether the instruction is well typed by applying one or more rules to the instruction and to the second type. Other embodiments will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings.

This disclosure is directed to embodiments that enable type checking of assembly language code compiled from source code by a compiler. Assembly language code typically performs stack operations. A stack may be described as a container of sequential locations in a memory wherein each location is capable of storing a data item. The data item may also be referred to as a word. During operation data items are added and removed from the stack on a first in first out FIFO basis. In other words data items may be added one at a time into each location of the stack. The data items may be thought of as being stacked one on top of the other so that the last data item added that is allocated to the stack is always the first to be removed that is deallocated from the stack. Furthermore the stack may also include a stack pointer such as hardware register that points to the most recently referenced location on the stack. Accordingly as data items are added or removed from the stack the stack point may be displaced to indicate the current extent of the stack.

The embodiments described herein are directed to implementation mechanisms for a type system that enables a type checker to perform type checking functions on the stack operations. For example the type system may include logical operation rules. The logical operation rules may be implemented by the type checker to perform the type checking functions. The logical operation rules may include operand typing rules stack rules stack implication rules lookup rules heap rules and instruction typing rules. Accordingly various examples of the logical operation rules as well as type checking mechanisms that implement these logical operation rules are described below with reference to .

A type system defines how a programming language classifies values and expressions into types. Additionally a type system also governs the manipulation of those types by the programming language as well as the interactions between the types and the programming language.

Embodiments described herein are direct to a type system also referred to as Simple Stack Type SST which enables a type checker to perform type checking functions on the stack operations. In order to accomplish this task the type system described herein supports identifying specified labeled locations and unspecified unlabeled locations for one or more data items in a stack. For example SST may represent that two integers are present at the top of the stack but all locations deeper in the stack may be unspecified. It will be appreciated that the stack type representation in the type system for stack operations as further described in the various embodiments below is in Backus Naur Form BNF notation. Accordingly in the example describe above the representation described above may be written as intint using BNF notation which represents that two integers are present at the top of the stack but all types deeper in the stack are abstracted by which represents stack type variables. In various instances SST is generally implemented into an assembly language that supports types. SST is further described below.

SST splits a pointer type into two parts the location l of the data and the type of the data at location l. Additionally a pointer to the data has a singleton type Ptr l which indicates that the pointer points exactly to the location l but does not specify the type of the data at location l. Instead a separate capability specifies the current type at l. For example the capability lint represents that l holds an integer. Because of the separation between singleton pointer types and capabilities the capabilities can evolve independently of the pointer types to track updates and deallocation.

To ensure that no two capabilities specify contradictory information about a single location SST imposes a linearity discipline on the treatment of capabilities prohibiting arbitrary duplication of the information contained in a capability. Accordingly the type system in accordance with various embodiments uses operators and rules that include elements of standard linear logic and separation logic to form a decidable logic. 

Thus the type system in accordance with the embodiments may incorporate the singleton pointers and the elements from standard linear logic and separation logic to represent stack type . Linear logic and separation logic share a core of basic operators. Two are of particular interest for stacks multiplicative conjunction written as in separation logic and additive conjunction written as in separation logic . For instance to have coffeetea is to have both coffee and tea. However to have coffee tea is to have a choice between coffee and tea but not both. For example the stack type intint may be represented in linear logic notation as lintlint where land lare the locations of each of the two integers on the stack. Each integer on the stack has a capability lint. The operator would glue capabilities together to form a complete stack capability The type system in accordance with the embodiments advantageously improves on these notations. First for the purpose of simplifying the type checking algorithm the type system replaces the commutative associative operator with the non commutative non associativeoperator resulting in a stack capability lintlint . Second rather than showing one location per stack slot the notation of the type system puts stack slots in between locations thus l intl intl indicate that one integer falls between locations land l and the other falls between locations land l. These improvements add the extra location lto the representation. For instance the stack pointer may have type Ptr l pointing to the top of the stack when a frame pointer has type Ptr l pointing to the bottom of the frame.

Further the operator indicates aliasing. Accordingly the stack type l indicates three things. First is a valid stack that holds stack items words . Second the location l resides either in the heap or in the part of the stack described by . Third l currently contains a data item word of type .

Accordingly SST may use labeled stack types and unlabeled stack types where indicates a single word type such as int as further described with respect to Labeled stack type l 1 Unlabeled stack type EMPTY l 2 Wherein the notation indicates alternative choices represents unlabeled stack type variables EMPTY represents empty stacks represents the type for a particular location and is the stack concatenation operator. The notation represents that a data item of a type is being pushed onto the stack . The l notation represents that somewhere in the stack there is a data item word with the type but the exact location of the data item with the type is unknown.

The representation illustrates the stack type of with location notions. The location notation l represents a location in the stack. Accordingly the pairing of the type with the location notation l provides the location of data item of type in the stack. In one instance of SST each data item of a specific type in the stack may be assigned a location as soon as it is pushed onto the stack . As shown in representation each data item of a specific type is represented by a location l as indicated by the colon notation. For example as shown in representation the data item with the type is located in the location l the data item with the type is located in the location l and so on and so forth.

Representation adds aliasing notations to . As shown in representation each data item of a specific type e.g. is paired with a location l e.g. l. Additionally l represents the fact that the data item with type resides at location l. Likewise l represents the fact that the data item with type resides at location l but the location lis in the portion l l l l of the stack . For example such an instance for lmay occur when a first method may provide the location lto a second method where the second method does not know the location l.

As shown in the location notation l as used in the type system may be further expanded. For example an location lthat corresponds to the base or the first slot of a stack may be written as l base . Likewise an location l or a slot that is directly adjacent to location l may be written as l next l . However while some locations may be represented by specific location such as base most methods are configured to run without knowledge of the actual locations of the stack. Accordingly representation illustrates an unspecified location as represented by the notation . In other words the notation represents a location that is present in the stack but not precisely specified. Representation also illustrates a location l that references a heap location with the use of a heap pointer . In general it will be appreciated that the notation illustrated above are also applicable to a heap data structure in a memory.

The application of the notation system described above is also illustrated in . As shown in representation an exemplary function h takes two integer parameters such as int x and int y . The parameters int x and int y may be stored in a stack such as stack . Thus when the function h is called the structure of the stack may be represented by representation . The function h may declare intint or that it needs a first integer e.g. int x a second integer e.g. int y and one or more other words of unspecified locations from the stack as represent by . Using the notation the unspecified location of the one or more words may be represented as demonstrated by the part . Further one of the integers in the stack may be represented as being stored at location next indicating a location that is relative to that is next to the location represented by the notation . Similarly the other integer in the stack may be represented as having a location of next next . The next next representation indicates a location that is next to the next location.

Representation shows an exemplary swap function swap. The exemplary swap function takes references to integers rather than integers as indicated by ref int x and ref int y so that changes to x and y in swap will be visible when swap returns to a caller function. When the function swap is called the structure of the stack may be represented by representation . As shown the ref int y may be stored as a reference pointer or Ptr at a location in the stack next . Likewise the ref int x may be stored as a reference pointer or Ptr at a location in the stack next next . Additionally in order to use the pointers Ptr and Ptr a method needs to know that an integer is stored at and another integer is stored at . Thus because the integers are generally located in the notation int int indicates that an integer is located somewhere in at a location and another integer is located somewhere in at a location . Accordingly representation represents information that enables a method to find an address at an stack slot referenced by Ptr and de reference that address to find the integer stored at as indicated in int. Similarly a method may find the integer stored at as indicated in int by finding an address at an stack slot referenced by Ptr and de referencing that address.

Returning to a stack representation may be manipulated using a set of logic stack implication rules. These stack implication rules as show below may enable a type checker mechanism such as type checker engine to manipulate the stack types 

Further the s imp expand alias rule expands the scope of an alias. For example for the swap function 

In various instances the syntax l expresses a clear scope in which l remains safe to use l definitely contains type as long as remains unmodified. Accordingly if the program deallocates a data item from for example then the alias l is generally discarded. Thus the scope is governed by the fact that s imp expand alias expands the scope of an alias but a logical implication rule to contract the scope is not implemented.

The type system in accordance with the various embodiments may be formalized for execution by a type checking mechanism such as the type checker of a compiler. First a type system may support at least integer type int nonsense type Nonsense for uninitialized stack slots heap pointer type HeapPtr for pointers to heap values of type singleton type Ptr and code type . Accordingly the exemplary types supported by the type system may be summarized as follows type int Nonsense HeapPtr Ptr 14 The type describes preconditions for code blocks. The location environment is a sequence of location variables and stack type variables. The register file is a partial function from registers to types. and describe the initial register and stack states for the blocks. They may refer to the variables in .

Second the formalized type system also includes a plurality of standardized values and operands. These values and operands may include the stack location d which refers to either a base stack location or the next stack location next d . A word sized value w may be an integer i the nonsense value for uninitialized stack slots a heap location p a stack location d or instantiated values w l and w where w points to code blocks polymorphic over location variables and stack type variables. Contents of registers and stack slots are word sized. Moreover word sized values may be separated from operands to prevent registers from containing registers. An operand o may be a register r a word sized value w or instantiated operands o l and o . A special register sp is used for the stack pointer. Accordingly the exemplary stack location word value and operand values may be summarized as follows stack loc base next 15 word value nonsense 16 operand 17 

Third the type system in accordance with various embodiments may be used to type check standard instructions such as mov and add instructions. However in some instances specialized instructions are needed in order to access the stack or the heap. For example values on a heap or a stack are accessed through explicit load and store instructions. Moreover ladd instructions are used for stack location arithmetic. In a ladd instruction ladd r i the first operand r points to a stack location and the second operand i is a constant integer positive or negative . A ladd instruction moves the stack pointer along the stack according to the integer value. In contrast standard add and subtract instructions deal with only integer arithmetic. The heap allocation instruction heapalloc r o allocates a word on the heap with initial value o and assigns the new heap location to r. The unpack instruction r unpack o coerces a heap pointer o to a heap location. Moreover the instruction also introduces a fresh location variable for o and assigns to r. Accordingly these instructions may be summarized as follows instr ins mov add sub ladd load store jumpif0 heapalloc o unpack 18 

Fourth in order to implement the type system in accordance the various embodiments a plurality of environments are maintained by the type checker. In addition to the location environment and the register file the type checker may also maintain the heap environment . The heap environment is a partial function from heap locations to heap pointer types.

In various embodiments the type system may include operand typing rules as shown below. In these operand typing rules the rule o means that operand o has type r under the environments. The heap location may be presented in two ways the type in the heap environment o p H or a singleton type o p as shown below in 23 and 24 . A stack location has a singleton type o d as shown below in 22 o reg 19 o int 20 o ns 21 o d 22 o p H 23 o p p Ptr p 24 

If an operand o has a polymorphic type o l and o instantiate the first variable in with l and respectively. The rules l and mean that l and a are well formed under respectively as shown below 

The rule r means that assigning a value of type to register r results in new environments and . Only is changed if r is not sp. Otherwise the stack grows or shrinks according to the new value of sp as shown below 

Moreover the type system may also include stack rules that resize the stack. For instance when the stack grows or shrinks the type system in accordance with the embodiments may implement the judgment Resize l to get the new stack type. The judgment means that resizing stack to l location results in stack . The location l will be the top of . Accordingly the stack shrinks if l is inside s shrink and grows if l is beyond the top of s grow . The stack drops all aliases beyond l when shrinking to avoid dangling pointers as shown below 

Moreover the rule l r means that the location l in stack has type . The location l can be either an alias in or be on the spine of the stack type obtained by dropping all aliases from .

Additionally the rule l rmeans that updating the location l in stack with type results in stack . As used throughout the notation may be interpreted to mean leading to. Weak updates do not change the stack type s update weak . Strong updates change the type of l and drop all aliases beyond l because they may refer to the old type of l s update strong as shown below 

The type system may further include instruction typing rules. The instruction typing rules enable a type checker to verify that a particular instruction does not adversely affect the types of words stored in a stack or a heap. Additionally the instruction typing rules may also ensure that the instructions are type safe that is they will not cause type errors during execution. Instruction typing rules according to various embodiments are listed below 

As shown each instruction typing rule includes an instruction portion that is below a line and a requirement portion that is above the line. The instruction portion of each rule follows the general form ins . The form ins means that checking the instruction ins changes the environments and to new environments and . An instruction checked by each corresponding instruction typing rule is considered to be well typed if the instruction as shown in the instruction portion satisfies the one or more criteria set in the requirement portion.

For example with respect to the rule i add 37 the add r o portion indicates addition of two integers r and o. The requirement portion above the line indicates that there are three criteria that the instruction need to satisfy to be considered well typed. First the requirement o int indicates that o must have the type int that is o must be an integer. The second requirement r sp indicates that the stack pointer sp should be not be used for the integer r. Thirdly the requirement r int indicates that r must also have the type int that is r must also be an integer. Thus a type checker may determine that the add r o instruction is valid if all the requirements are satisfied.

In another example the rule i load aliased 44 checks an instruction that loads a word at a memory address stored in rinto a register r that is load r r 0 . In order to do so the requirement portion of the rule verifies that ris a valid address and that the address contains a word of a valid type and determines the type for the word. This rule is designed to be applied to the loading of words that are stored on the stack or on the heap. The r Ptr l portion verifies that rhas a pointer type to location l. The l portion verifies that the location l is in the stack and has some type represented by . The r portion indicates that once ris verified to have a valid type the word in the memory address rmay be moved into a register rprovided that the old environment as represented by is updated to the new environment represented by . Accordingly the type checker may use the requirement portion of the i load aliased 44 rule to check the validity of the load r r 0 instruction.

Additionally in the rule i ladd 37 the location arithmetic instruction ladd r i requires that r point to a location l and i be a multiple of 4. The stack grows toward lower addresses. If i is negative the result location is further outward from l. Further load and store can operate on heap locations i load p 40 and i store p 41 stack locations on the spine i load concat 42 and i storeconcat 43 and aliases i load aliased 44 and i store aliased 45 . The type system in accordance with the embodiments also supports weak updates on heap locations and aliases and both strong and weak updates on stack locations on the spine.

The rule for heap allocation i store heapalloc 46 assigns a heap pointer type to the register that holds the pointer instead of a singleton type because the new heap location is statically unknown. The heap environment does not change after heap allocation because the rest of the program does not refer to the new heap location by name.

Accordingly when controlling transfers the type checker matches the current environments with those of the target. The location environment of the target should have been fully instantiated. requires that be a subset of . It will be appreciated that while some of the instruction typing rules described above are applicable for use with both stacks and heaps a portion of rules may be used with only stacks or only heaps. For example the i load p 40 i store p 41 and i heapalloc 46 are only applicable to heaps while i store concat 43 is only usable with stacks.

The type checker of a compiler may check a program using the type system that includes one or more of the stack rules the operand typing rules and the instruction typing rules as described above. For example a program may consist of a heap H a register bank R a stack s and a block body as the entry point. H is a partial function from heap locations to heap values. R is a partial function from registers to word sized values. The stack s records values on the spine. It is either the empty stack empty or a concatenation of a word sized value with a stack ws . heap value v block w 48 block block 49 block body ins jump 50 heap H pv . . . pv 51 reg bank R rw . . . rw 52 stackvalue empty 53 program 54 

As shown above a heap value v is either a code block block or a heap word w . A code block b describes the precondition and its body b. The block body is a sequence of instructions that ends with a jump instruction. Only variables in A can appear free in and the block body.

The program P H R s b is well formed illustrated by the judgmentP if H matches a heap environment R matches a register file s matches a stack type and b is well formed under and . The notion means empty environments. Accordingly this may be represented as 

To type check a block body the type checker may check the instructions in order b ins until it reaches the jump instruction b jump . The unpack instruction r unpack o generally requires o have a heap pointer type b unpack . The rule introduces a fresh location variable to assigns r a singleton type Ptr and updates the stack type to contain .

Furthermore the compilation of the exemplary source code swap function into an assembly language code swap function that incorporates the type system described above may also be illustrated. For example given the swap function in the source code 

It will be appreciated while the type checker may implement the various rules described above to perform the type checking of assembly code the rules may be written in other forms for implementation by the type checker. The actual syntax and format of the rules are dependent on the notation systems employed to represent the structures of stacks and or heaps. Therefore the syntax and format of the rules described above are exemplary and not intended to be construed as a limitations 

The compiler interface module may retrieve one or more assembly language instructions from a compiler such as the compiler as the compiler transforms source code into assembly language code. In one instance the source code may include the code . Moreover the compiler interface module may also be employed to return one or more type checked assembly language instructions to the compiler.

The operand rules module may be configured to implement the operand typing rules as described in to one or more retrieved assembly language instructions. The instruction typing rules module is configured to implement the instruction typing rules as described in to the one or more retrieved assembly language instructions. The stack update rules module is configured to implement stack update rules as described in to the one or more retrieved assembly language instructions. Similarly the stack implication rules module is configured to implement stack implication rules as described in to the one or more retrieved assembly language instructions.

The location lookup module is configured to implement the location lookup rules as described in to the one or more retrieved assembly language instructions. The stack type lookup module is configured to implement the stack type lookup rules as described in to the one or more retrieved assembly language instructions. Accordingly each of the rule modules may be configured with the ability to determine the appropriate rule to apply to the one or more retrieved assembly language instructions. It will be appreciated the various rules implemented by the rule modules may be stored in the database .

At block the type checker engine may determine whether the instruction is a jump instruction. If the type checker engine determines that the instruction is a jump instruction yes at decision block the type checker engine may apply a jump rule at block . In one embodiment the type checker engine may apply the b jump rule 63 as described with respect to to the instruction. Following the application of the jump rule to the instruction at block the process may terminate at block .

However if the type checker engine determines that the instruction is not a jump instruction no at decision block the process may proceed to block . At block the type checker engine may apply one or more rules to type check the instruction. Accordingly to various embodiments the one or more rules are configured to ensure that the instruction is well typed. In other words the one or more rules ensure that the one or more words operated on by the instruction are of the proper types and the operation does not invalidate the types of the words. The application of one or more rules by the type checker engine is further described in . Once the instruction is type checked at the block the process may loop back to block so that the type checking of additional instructions may be implemented.

At block the type checker engine may apply one or more location look up rules to the instruction. For example the type checker engine may apply the location look up rules 31 32 as described with respect to . At block the type checker engine may apply one or more stack type look up rules to the instruction. For instance the type checker engine may apply the s lookup rule 33 as described with respect to .

At block the type checker engine may apply one or more stack update rules to the instruction. For instance the type checker engine may apply the stack update rules 34 35 as described with respect to . Finally at block the type checker engine may apply one or more stack implication rules to the instruction. For instance the type checker engine may apply the stack implication rules 3 10 as described with respect to . Once the one or more rules have been applied the process may return to the block of the process at block .

In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more program modules and may include program data . The operating system includes a component based framework that supports components including properties and events objects inheritance polymorphism reflection and provides an object oriented component based application programming interface API such as but by no means limited to that of the .NET Framework manufactured by Microsoft Corporation Redmond Wash. The device is of a very basic configuration demarcated by a dashed representation . Again a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well know in the art and are not discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. These networks may include wired networks as well as wireless networks. Communication connections are one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules etc.

It is appreciated that the illustrated computing device is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well known computing devices systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor base systems set top boxes game consoles programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and or the like.

In closing although the various embodiments have been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended representations is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed subject matter.

