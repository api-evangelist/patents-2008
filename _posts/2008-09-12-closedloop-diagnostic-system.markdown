---

title: Closed-loop diagnostic system
abstract: Problem diagnostics may be obtained from components that log messages using a unique component identifier which is provided within each message so as to enable routing of callbacks to the component that originated the message. Similarly, problem diagnostics may be obtained from components that generate alerts, where the alerts contain the unique identifier of the component that generated the alert. Each component supports a diagnostic provider interface comprising operations which may be dynamically invoked, for example to solicit information from the component such as its configuration data, its state information, to execute self-diagnostic tests, and so forth. In addition or instead, operations may be provided that can be invoked to cause the component to alter its configuration data (such as notifying the component to change its level of message logging) or its behavior.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08224625&OS=08224625&RS=08224625
owner: International Business Machines Corporation
number: 08224625
owner_city: Armonk
owner_country: US
publication_date: 20080912
---
The present invention relates to computer programming and deals more particularly with problem diagnostic information which may be obtained from components.

Complex information technology IT systems are generally composites of many components which communicate over various interfaces and buses. Troubleshooting such systems can be difficult as it may not be obvious which component is manifesting a problem and if applicable what other component s may have contributed to the problem. Once the component s is are identified it is often the case that component specific knowledge is needed to understand and isolate the problem and to do further diagnosis or to perform problem resolution.

The present invention defines techniques for obtaining diagnostic information from components and or resources which are accessible to components. In one aspect the present invention is directed to component diagnostics comprising including in each message generated by each of a plurality of components a unique component identifier that identifies the generating component and providing for each of the components a diagnostic provider interface the diagnostic provider interface for each component comprising at least one operation implemented by that component the operation being invocable by a callback to the component wherein the unique component identifiers enable identifying that one of the components to which each callback is to be routed.

This aspect may further comprise executing at least one of the operations provided in the diagnostic provider interface of a selected one of the components in response to an invocation by a callback received at the selected component. The received callback may comprise a request for further information from the selected component and this requested further information may comprise as one example current state information of the selected component or as another example current configuration information of the selected component. As an alternative to requesting further information the received callback may comprise as one example a request for the selected component to provide a list of diagnostic tests available for execution by the selected component or as another example a request for execution of at least one diagnostic test by the selected component.

The received callback may as one example be generated responsive to evaluation of at least one message generated by the selected component. As another example the received callback may be generated responsive to evaluation of at least one message generated by another component or components distinct from the selected component.

The component diagnostics may further or alternatively comprise including in each alert generated by each of the components the unique component identifier for identifying the generating component. In this case the component diagnostics may further comprise executing of at least one of the operations provided in the diagnostic provider interface of a selected one of the components in response to an invocation by a callback received at the selected component and the received callback may be generated as one example responsive to evaluation of at least one alert generated by the selected component. As another example the executing may occur responsive to evaluation of an alert or a plurality of alerts generated by another component or components distinct from the selected component.

The component diagnostics may comprise registering the unique component identifier during an initialization phase wherein each unique component identifier includes information indicating existence of the diagnostic interface provided for each respective component. The component diagnostics may further comprise registering a diagnostic interface specification for each component. Each diagnostic interface specification preferably specifies a method signature for each of the invocable operations implemented by that component and the method signature for at least one of the invocable operations may comprise a parameter name parameter type pair for each parameter of that invocable operation. Preferably the diagnostic interface provided for each component specifies at least one of at least one state attribute for which state information can be dumped by that component at least one configuration attribute for which configuration information can be dumped by that component and at least one diagnostic test that can be carried out by that component.

The component diagnostics may further comprise generating for each of the components the unique component identifier during an initialization of the component. The unique component identifier for each component may be generated as the unique object name of an instance of the component and or may be generated using topology information of the component.

The component diagnostics may further comprise including in each message generated for at least one resource which is accessible from a selected one of the components the unique component identifier that identifies the selected component and providing in the diagnostic provider interface for the selected component at least one operation implemented by that component the operation being invocable by a callback to the component to interact with each of the at least one resources. In this case the component diagnostics may further comprise executing for a selected one of the resources which is accessible from the selected component at least one of the operations provided in the diagnostic provider interface of the selected component in response to an invocation by a callback received at the selected component to interact with the selected resource.

Each of the callbacks for a selected component preferably uses the unique component identifier of the selected component.

In another aspect the present invention is directed to performing component diagnostics comprising including in each message generated by each of a plurality of components a unique component identifier that identifies the generating component providing for each of the components a diagnostic provider interface for that component the diagnostic provider interface for each component comprising at least one invocable operation implemented by that component the operation being invocable by a callback to the component and using the unique component identifiers to route callbacks to selected ones of the components wherein each of the callbacks comprises invoking one of the at least one invocable operations implemented by the selected one of the components.

In another aspect the present invention is directed to component diagnosis comprising evaluating at least one message generated by a component wherein the evaluated message comprises a unique component identifier that identifies the generating component identifying an operation implemented by the component in a diagnostic provider interface and using the unique component identifier from the at least one evaluated message in an invocation that calls back to the component to request execution of the identified operation thereby enabling routing of the invocation to the component. In one embodiment the operation is identified by consulting a registry in which the component registers each of at least one operation implemented in its diagnostic provider interface. The operation may comprise a request for the component to dump state information a request for the component to dump configuration information a request for the component to provide a list of diagnostic tests available for execution by the component or a request for the component to execute at least one diagnostic test.

It should be noted that the foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail consequently those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects inventive features and advantages of the present invention as defined by the appended claims will become apparent in the non limiting detailed description set forth below.

The present invention will be described with reference to the following drawings in which like reference numbers denote the same element throughout.

Meaningful messages message coding systems and messages with significant context are all in use in many products to help with problem determination. These messages often include information about the originator of the message such as a class name and or method name when using object oriented programming line number of code at which the message was generated or at which the problem was detected process identifier of the process in which the code is executing and or thread identifier of the thread executing the code. A current limitation to this approach for identifying a message source is that there is no programmatic way to call back to the originator to communicate with it. As used herein call back callback and related terms refer to invocation by an entity external to a component of an operation provided by that component and include requests for information from the component. Instead the message recipient is typically left to read product documentation if any to understand what to do with the message and how to proceed. Expert users of such products may over time learn what to do when they see a particular message but novice users frequently must call technical support to get help.

The current technique of emitting messages into message logs is akin to leaving a computer generated phone message with no return phone number there is no way to call back to the message source for clarification or to get more information. Preferred embodiments address this problem providing techniques for programmatic call back to the originator of an emitted message. The programmatic call back preferably allows gathering additional information about the component that emitted the message as will be described in more detail herein.

According to a preferred embodiment each component and optionally each sub component in the IT system is assigned a unique identifier. Components are also referred to herein as diagnostic providers. As messages are created for detected problems the detecting component s identifier is included in the message payload thereby identifying which component generated the message to record the problem.

See which provides a sample message structure that may be used with embodiments of the present invention. As shown therein a message may comprise a message identifier which is msg1234 in this sample message various message header information which is typically application specific and which is therefore shown in an abstract manner in an originating component identifier as disclosed herein which is compABC in this sample message and message text which is Out of disk space in this sample message. It will be obvious to those of skill in the art that while simple relatively short component identifiers have been used herein for ease of reference the unique component identifiers used in preferred embodiments may be more complex and or may comprise data of a different format. Optionally a message may comprise a unique identifier of one or more diagnostic provider interface discussed further below associated with the originating component and may also provide an identification of the operations enabled by that one or more diagnostic provider interface.

As indicated above according to preferred embodiments of the present invention components of the IT system implement an interface referred to herein as a diagnostic provider interface or DP interface which provides operations useful for in depth problem determination. This interface preferably includes operations to collect state information about a component gather configuration information about a component and run component self diagnostics and may optionally include operations to change the component s level of message logging change the component s configuration and so forth. Additional fewer or different operations may be supported without deviating from the scope of the present invention. 

Preferably each component registers its diagnostic interface and its unique identifier at a central service that has the ability to communicate with external programs. These programs may include by way of illustration one or more applications or systems which are adapted for monitoring operation of one or more components of the IT system performing problem detection and determination collecting data about components of the IT system and perhaps suggesting problem resolution. Techniques disclosed herein enable these external programs to gather further information which may then be used in application specific ways responsive to detecting that a message has been generated as will be described.

Using techniques disclosed herein a message recipient can call back to the originating component and interact with the component further regarding a particular message. For example the message recipient may gather further information by using the component s diagnostic interface to request state information from the originating component and or by requesting configuration information pertaining to the component. As another alternative the message recipient may use the component s diagnostic interface to request execution of one or more diagnostic tests which are available from that component. The term message recipient as used herein includes human beings such as systems administrators as well as programmatic processes such as an autonomic problem determination application.

Notably information needed to call back to the message originator is provided within the message. See sample message format of where a component s unique identifier is carried within the message payload. Accordingly external programs can be written to receive messages or inspect a message log and where desired call back to the originating component to execute methods on the component s diagnostic provider interface. In a preferred embodiment diagnostic provider interfaces provide a known fixed set of operations and accordingly each message will contain an indication that the component implements a diagnostic provider interface with the external program being aware of the fixed set of available operations. In one alternative embodiment the message may merely identify the originating component for example by way of unique component identifier as shown in . In a first version of this embodiment an external program receiving a message could call back to the originating component to inquire whether the originating component includes a DP interface and if so what operations it implements. In a second version of this embodiment an external program receiving a message could using the unique component identifier consult a central service or registry to determine whether the originating component includes a DP interface and if so what operations the DP interface implements. In another alternative embodiment the message may include a specific indicator of the DP interface and may further include an indication of the operations implemented by the DP interface allowing an external program to access the DP interface immediately upon receipt of the message. By calling back to the originating component through the DP interface the message recipient can gather more information about the general health of a component which may for example prove useful prior to contacting product support. And in some instances the information which can be obtained through the component s diagnostic interface may enable the message recipient to fully resolve a problem without contacting product support.

As a further advantage of techniques disclosed herein components no longer need to provide extensive information in messages to be logged in an attempt to guess what logged information will prove useful in the event of a failure. Instead fewer details may be logged as techniques disclosed herein enable retrieving more detailed information upon request using a callback to the diagnostic provider interface of the originating component.

The dynamically invocable operations which may be made available through a component s diagnostic provider interface may vary from one component to another and each component preferably includes operations deemed useful to diagnostics of that particular component.

The diagnostic provider interface for a particular component may include methods for invoking one or more of the following operations 

Note that while discussions herein are primarily in terms of invoking operations that pertain to components the diagnostic provider interface may also comprise dynamically invocable operations for interacting with one or more resources which are accessible from the component. The term component as used herein may comprise a software package that groups a set of related functions. As one alternative a component may comprise an instance of a resource created by such a package. For example a component may be a database connection management software package or a single instance of a connection to a database.

In a preferred embodiment illustrated by the operations for viewing state information viewing configuration information obtaining a list of available diagnostics tests and executing identified ones of those diagnostic tests are shown. In a sample diagnostic provider interface is illustrated that comprises methods for invoking the above described operations in a Java environment using Java Management Extensions JMX . Java and all Java based trademarks are trademarks of Oracle America Inc. in the United States other countries or both. In a sample diagnostic provider interface is illustrated that may be used in a web service environment. These execution environments are discussed in more detail herein. As will be obvious these sample interfaces are provided by way of illustration and not of limitation and it will be obvious given the teachings provided herein how these sample interfaces may be extended to support other operations such as changing message logging changing configuration and so forth .

In for example the syntax specification for operation indicates that the method signature has a parameter named attributeId which is of type java.lang.String . See reference number . The method signature for operation is similar in this example while the method signature for operation indicates that the method uses a parameter named testId which is of type java.lang.String . See reference number .

Note that techniques disclosed herein enable a remote client to optionally invoke operations not illustrated in or that cause a properly enabled component to dynamically modify its operation. For example a component may include code that logs debugging type messages where operation of this code can be switched on or off through a Boolean flag setting. Using the component s diagnostic provider interface a requester such as a remote client may signal the component to change the setting of the Boolean flag thereby causing the component to begin logging debugging messages or conversely to stop logging such messages. While a ChangeMessageLogging operation has not been illustrated in or it will be obvious to one of skill in the art how such interface can be designed and supported given the teachings provided herein. 

In one approach a preferred embodiment uses two Java technologies namely JMX and the java.util.logging package when implementing the present invention for a Java execution environment as will now be described in more detail.

JMX is an infrastructure and application programming interface API for managing server resources such as the components described herein . Management modules may be defined using Java classes referred to as MBeans . These MBeans may be hosted in a JMX server. As one example environment a JMX server may run within the WebSphere Application Server WAS from International Business Machines Corporation IBM . External programs may communicate with a JMX server using the client API provided by the JMX server implementation. IBM and WebSphere are registered trademarks of International Business Machines Corporation in the United States other countries or both. 

The java.util.logging package provides a logging infrastructure and API. The logging API provides facilities with which to create and log messages to the logging infrastructure. The logging infrastructure provides a means for distributing logged messages to various handlers . These handlers in turn write logged messages to output devices such as a log file a socket an automated message e mailer and so forth. Customized handlers may be written to write logged messages to particular output devices if desired.

WAS also adds a DiagnosticProvider Java interface and DiagnosticProvider MBean declaration capability as well as a custom subclass of the java.util.logging.Logger Java class for use by a preferred embodiment of the present invention as will now be described in more detail.

Preferably WAS provides the DiagnosticProvider interface as part of its core API where this DiagnosticProvider interface comprises a set of methods as discussed above with reference to that are useful to problem determination for any component. Components within a WAS system then provide implementations of this interface. The stateDump operation for example may be provided by a method exposed on the MBean interface that dumps state information for the component for which the method is invoked. The configDump operation may be provided by a method exposed on the MBean interface that dumps configuration information for the component for which the method is invoked. The getSelfDiagnosticList operation may be provided by a method exposed on the MBean interface that lists the names of tests provided by the component for which the method is invoked and the selfDiagnostic operation may be provided by a method exposed on the MBean interface that executes the named test on the component for which the method is invoked and returns information describing the result.

As one example of self diagnostics that may be provided a connection management test might be provided that attempts to get a connection from a particular data source or other resource pool to determine if the data source is working properly. As another example a webContainer may attempt to read a particular test Uniform Resource Locator URL to verify that its infrastructure is working properly. As yet another example an agent that provides administrative functionality may verify connectivity between a deployment manager e.g. a central administrative entity and agents on the nodes it manages.

Preferably WAS uses the unique identifier ID of the MBean known as a JMX ObjectName as the unique component ID. In the particular embodiment described herein the unique component ID also serves as the diagnostic provider ID or DPID . Alternatively a message may include a DPID which does not expressly identify the component that generated the message but instead merely directs an external process to the relevant diagnostic provider interface. Such an approach might be desirable for example to avoid exposing the component s identity to the message recipient for security reasons. The use of such a DPID is still considered to identify the generating component albeit indirectly because it identifies the relevant diagnostic provider interface to the message recipient and the diagnostic provider interface is itself part of the generating component. The JMX ObjectName is generated by the JMX registration code using topology information for the object. Alternatively a unique identifier may be generated for components in another way without deviating from the scope of the present invention provided this unique identifier is usable for unambiguously routing requests to components. 

The custom subclass of the java.util.logging.Logger Java class is preferably provided as a class which can hold extension data. In a preferred embodiment the Logger subclass for a particular component holds the component s DPID as an extension. Extension data associated to the Logger subclasses is then included by that logger with each message forwarded to the handlers. In addition to a component s DPID an example of other data that might be provided using extension data is a vendor name of a vendor who provided the code that is using the Logger.

In another approach an alternative preferred embodiment may use in place of JMX and MBeans web services or another means of remote procedure invocation. Web services are well known in the art and a detailed description thereof is not deemed necessary to an understanding of the inventive concepts of the present invention. Instead of the java.util.logging package an embodiment of the present invention may use the log4j package or any other logging facility with extensible log events. And instead of using WAS as a base an embodiment of the present invention may use any application server product or any componentized software server that supports raising events and which also supports invocation of remote requests.

Returning now to discussion of a WAS based embodiment the DiagnosticProvider interface may be used by products within the execution stack and or other external programs including third party software that are to be integrated into the WebSphere environment for example to perform monitoring to provide added functionality and so forth . The use of a WAS based implementation also provides the ability to include a DPID in any message by providing the DPID as one of the message s substitution parameters. This is of benefit in cases where more than one DPID may be used with the same Logger. This situation may be common where a component has different DPIDs for each of its resources that are related to it but that component does not have a separate Logger for each of these same resources.

During WAS server start up components initialize their DiagnosticProvider MBeans and register them with the JMX MBean server. See flow . Also during start up each component assigns the JMX ObjectName which as stated earlier is used for the component s DPID and assigns that value to each of the java.util.logging.Loggers that the component will use to log messages not shown in by writing the JMX ObjectName into the Logger s extension data. As discussed earlier this DPID is preferably included in the information that is registered with a central service during the registration process. 

At run time as the component encounters problems it logs messages to its Loggers. See flow . Each message automatically includes the DPID of the MBean according to preferred embodiments through functionality of the Logger subclass. See also where a sample message format including a component ID is illustrated. As noted above in the particular embodiment described the component ID also serves as the DPID because it uniquely identifies the component with which the diagnostic provider interface is associated. Alternatively another way of associating a DPID with a message is to provide it as a parameter during the logging of a message preferably prefaced with an indication that the parameter represents a DPID. The WAS logger subclass will look for this DPID in the message parameters and will include the DPID in the message passed to the handlers. This may be useful for example where a component controls multiple resources each potentially with its own DPID while the component may only have one logger.

In a WAS environment a runtime message utility is preferably provided using a web interface where this interface displays or otherwise renders messages emitted from Loggers along with their DPIDs as clickable links. See flow which depicts a message being sent from a logger MBean to the runtime message utility and flow which depicts this message being sent to a user interface of a user who is referred to herein as an administrator. Log messages may also or alternatively be made available to programmatic processes which may for example have registered as listeners. This has not been depicted in . Interactions with a programmatic process in the environment of are discussed below. 

When an administrator clicks on a selected DPID link focus of the user interface preferably transfers from the display of messages to a web page that allows the user to choose from among operations that may be invoked against the diagnostic provider interface of the component i.e. the DiagnosticProvider MBean in a preferred WAS environment that is identified by the DPID embodied in the corresponding message. As indicated above identification of available operations may be made by reference to data stored in a registry by reference to data embedded in the message itself or by reference to data provided by the originating component in response to a request for identification of available diagnostic provider interface operations. Alternatively a particular diagnostic provider interface may be known by a message recipient to include certain operations.

Once the administrator chooses the operation to invoke see flow of the diagnostic provider utility interacts with the JMX MBean server invoking the corresponding method on the DiagnosticProvider MBean of the component identified by the DPID in the logged message see flow .

The DiagnosticProvider MBean then interacts with the component that originated the logged message where this interaction may comprise requesting state data configuration data etc. or requesting execution of self diagnostic tests according to the administrator s request. See flow . The results of the invoked method are then preferably provided for display to the administrator using the web page interface.

As an alternate flow a programmatic process such as an autonomic problem determination application may take the place of the administrator shown in . In this scenario the programmatic process receives messages from the server and invokes methods on the component MBeans identified by the DPIDs contained in the logged messages.

Optionally a component may provide a selection of self diagnostics as discussed briefly above. In this case a graphical button provided on web page display such as graphical button for example may request the component to return a list of its available tests. illustrates a sample web page that may be displayed in response whereby a clickable link is provided for each test available from the component see generally and whereby clicking on a selected link then preferably invokes execution of the corresponding test. Following execution of the diagnostic test a web page display is preferably rendered for the administrator to provide results of the test not shown .

Turning now to a flowchart is provided that depicts logic that may be used when implementing a preferred embodiment of the present invention. As shown in when a problem occurs in a component Block the component logs a message containing a DPID Block . The administrator reads a logged message from a user interface such as a message console Block and then may select an operation available from the corresponding component s diagnostic provider interface Block . Alternatively Block may represent the administrator selecting an operation available from the diagnostic provider interface of a component that is different from the component that generated the logged message. This may be useful for example if a particular component is unaware that it has a problem but that problem is causing other components to log messages e.g. because the component which has the problem is sending corrupted data which is then recognized by the other components as being corrupt . discussed above presents a sample diagnostic provider interface display from which operations can be selected.

If the selected operation is to view state information of the component then the diagnostic provider console invokes a method of the component s diagnostic provider interface to request state information Block . In preferred embodiments the diagnostic provider interface reports internal state information that is gathered using logic provided by the component implementation Block . Optionally an input parameter may be supported that informs the component of pertinent parts of the component s available state information that are of interest to the requester as illustrated by reference number in although this has not been illustrated in . The state information returned by the component is then displayed on the diagnostic provider console Block after which the processing of this invocation of the logic in ends.

If the selected operation is to view configuration information of the component then the diagnostic provider console invokes a method of the component s diagnostic provider interface to request configuration information Block . In preferred embodiments the diagnostic provider interface reports configuration information that is gathered using logic provided by the component implementation Block . Optionally an input parameter may be supported that informs the component of pertinent parts of the component s available configuration information that are of interest to the requester as illustrated by reference number in although this has not been illustrated in . The configuration information returned by the component is then displayed on the diagnostic provider console Block after which the processing of this invocation of the logic in ends.

In a preferred embodiment various components may implement different sets of self diagnostic tests since certain tests may be useful for one or some components but of little or no value to other components. Accordingly if the selected operation is to perform diagnostic tests which are available from the component then in one approach the diagnostic provider console invokes a method of the component s diagnostic provider interface to request a list of the available tests Block . Preferably the list of tests is returned by the component Block for display on the diagnostic provider console Block . In one alternative approach information about available tests for the various DP interfaces is stored in a registry and a list of available tests may be retrieved from the registry for presentation to the administrator. In a second alternative approach information representing the available tests may be included in the message itself. For example an abbreviated code could be included in the message and the message recipient could have access to a table containing information about the correspondence between abbreviated codes and available tests implemented by the diagnostic provider interface. Where a limited number of tests are potentially available depending on the diagnostic provider interface a simple integer or bit mask may be sufficient as a code. In a third alternative approach diagnostic provider interfaces may have uniform self diagnostic testing capabilities and the message recipient may be aware of those uniform capabilities. discussed above depicts a sample list of tests available from a hypothetical component. The administrator may then select a test from this display Block and in response the diagnostic provider console invokes a corresponding method to execute the selected test Block . In preferred embodiments the diagnostic provider interface reports the test results that are provided by the component implementation Block . These results are then displayed on the diagnostic provider console Block after which the processing of this invocation of the logic in ends.

In an alternative approach a component may implement a single diagnostic test or a collection of diagnostic tests which are invoked using a single request in which case the processing of Blocks may be omitted. Or as illustrated in the method signatures in see reference numbers and respectively a parameter may be specified on the method invocation to inform the component of the particular diagnostic test s to be executed. See references numbers and where a testID parameter is illustrated for this purpose. 

Optionally the diagnostic provider console may be modeled as a dashboard interface whereby different colors such as green yellow and red are used to graphically indicate the health of the overall system and or components thereof In this approach as the logs are monitored for incoming messages callbacks may be invoked to gather further information for each message or for selected messages such as all messages for which a red indicator is appropriate . An automated analysis may be performed of the returned information and a color may then be selected to represent the health of the component on the dashboard interface.

Note that while preferred embodiments have been described herein with reference to code from the Java programming language and execution in a Java run time environment this is by way of illustration and not of limitation. Alternative execution environments include a web services environment as has been discussed.

Furthermore while preferred embodiments have been described with reference to invoking methods from a component s diagnostic provider interface responsive to a logged message from the component the disclosed techniques may also be used responsive to an alert generated by a component where the alert contains the component s DPID in a similar manner to that which has been described for messages . Methods from the diagnostic provider interface may also be invoked for example in response to evaluation of messages in a log at some variable time after the messages have been entered into the log. Furthermore methods from a component s diagnostic provider interface may be invoked in an unsolicited manner i.e. without regard to particular logged messages or alerts for example by obtaining a component s unique identifier and diagnostic provider interface from the information the component registered with the central service of during initialization.

As will be appreciated by one of skill in the art embodiments of the present invention may be provided as for example methods systems and or computer program products. The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc. Furthermore the present invention may take the form of a computer program product which is embodied on one or more computer usable storage media including but not limited to disk storage CD ROM optical storage and so forth having computer usable program code embodied therein where this computer program product may be used by or in connection with a computer or any instruction execution system. For purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

Referring now to a data processing system suitable for storing and or executing program code includes at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories not shown which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output I O devices including but not limited to keyboards displays pointing devices other interface devices etc. can be coupled to the system either directly or through intervening I O controllers or adapters .

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks as shown generally at . Modems cable modem attachments wireless adapters and Ethernet cards are just a few of the currently available types of network adapters.

Still referring to the networks and may also include mainframe computers or servers such as a gateway computer or application server which may access a data repository . A gateway computer serves as a point of entry into each network such as network . The gateway may be preferably coupled to another network by means of a communications link . The gateway may also be directly coupled to one or more workstations using a communications link and or may be indirectly coupled to such devices. The gateway computer may be implemented utilizing an Enterprise Systems Architecture computer available from IBM. Depending on the application a midrange computer such as an Application System also known as an AS may be employed. Enterprise Systems Architecture Application System and AS are registered trademarks of IBM in the United States other countries or both. 

Those skilled in the art will appreciate that the gateway computer may be located a great geographic distance from the network and similarly the wireless devices and or workstations may be located some distance from the networks and respectively. For example the network may be located in California while the gateway may be located in Texas and one or more of the workstations may be located in Florida. The wireless devices may connect to the wireless network using a networking protocol such as the Transmission Control Protocol Internet Protocol TCP IP over a number of alternative connection media such as cellular phone radio frequency networks satellite networks etc. The wireless network preferably connects to the gateway using a network connection such as TCP or User Datagram Protocol UDP over IP X.25 Frame Relay Integrated Services Digital Network ISDN Public Switched Telephone Network PSTN etc. The workstations may connect directly to the gateway using dial connections or . Further the wireless network and network may connect to one or more other networks not shown in an analogous manner to that depicted in .

The present invention has been described with reference to flow diagrams and or block diagrams according to embodiments of the invention. It will be understood that each flow and or block of the flow diagrams and or block diagrams and combinations of flows and or blocks in the flow diagrams and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer embedded processor or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions specified in the flow diagram flow or flows and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the function specified in the flow diagram flow or flows and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flow diagram flow or flows and or block diagram block or blocks.

While preferred embodiments of the present invention have been described additional variations and modifications in those embodiments may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore it is intended that the appended claims shall be construed to include preferred embodiments and all such variations and modifications as fall within the spirit and scope of the invention.

