---

title: Systems and methods for optimized printer throughput in a multi-core environment
abstract: Systems and methods consistent with some embodiments presented provide methods for the concurrent generation and parallel rasterization of at least one display list in a memory pool comprising frame buffer memory and display list memory, wherein the display list comprises a plurality of equal sized display list blocks, the method comprises: monitoring the completion status of the display list blocks; monitoring the availability of rasterization processes; assigning a completed display list block to an available rasterization process; and rasterizing the display list block using the available rasterization process. In some embodiments, rasterization processes may run concurrently and operate on distinct blocks corresponding to distinct bands. Rasterized display list blocks are returned to the memory pool. In some embodiments, each concurrently executing rasterization process may execute on a distinct core of a multi-core processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08861014&OS=08861014&RS=08861014
owner: Konica Minolta Laboratory U.S.A., Inc.
number: 08861014
owner_city: San Mateo
owner_country: US
publication_date: 20080930
---
The present invention relates to the field of printing and in particular to systems and methods to optimize printer throughput utilizing a multi core environment.

Document processing software allows users to view edit process and store documents conveniently. Pages in a document may be displayed on screen exactly as they would appear in print. However before the document can be printed pages in the document are often described in a page description language PDL . A PDL description of a document provides a high level description of each page in a document. This PDL description is often translated to a series of lower level printer specific commands when the document is being printed. As used in this application PDLs may include Personalized Print Markup Language PPML PostScript Adobe PDF HP PCL Microsoft XPS and variants thereof as well as any other languages used to describe pages in a document. The Personal Printer Markup Language PPML specification permits printer languages to identify store and re use objects such as text and graphic elements.

The PDL description is parsed and typically converted to an intermediate form termed a display list which can hold objects including commands also called display list primitives . Display list commands define data objects and their contexts within a document or a page within the document to be printed. The display list is parsed and then converted into a final form which can be used to place marks on a print medium. The process of translation from a display list representation of a document to a lower level description that may be used to place marks on a print medium is termed rasterization. Rasterization may be performed on a computer printer or distributed between the computer and printer.

Rasterization typically renders pages one at a time by determining pixels affected by a display list command and modifying those pixels appropriately. When a page is ready to be rasterized it may be operated upon by a rasterizer. However in some instances the time taken to generate the entire display list for a page may be significant. During this period a processor may be idle. In addition in modern multi core processors which can contain several processor cores in a single chip or package one or more cores may be idle while waiting for the generation of the entire display list for a page.

Idling of processors is a waste of computational resources and suggests either a poor design excessive capacity or poor utilization inability to use existing resources . In addition idle cycles on processors can affect performance and rendering speed. Thus better utilization of available computing resources permits greater functionality and or better performance at a lower price point.

In accordance with the present invention systems and methods for print resource management are presented. Embodiments of methods for the concurrent generation and parallel rasterization of at least one display list in a memory pool are presented. The memory pool comprises frame buffer memory and display list memory and the display list comprises a plurality of equal sized display list blocks. In some embodiments the concurrent generation and parallel rasterization method comprises monitoring the completion status of the display list blocks monitoring the availability of rasterization processes assigning a completed display list block to an available rasterization process and rasterizing the display list block using the available rasterization process.

Embodiments of the present invention also relate to instructions created stored accessed or modified by processors using computer readable media and or computer readable memory.

Consistent with disclosed embodiments systems and methods for the concurrent generation and parallel rasterization of an intermediate form of data generated from a first form of data are presented. In some embodiments the first printable data may take the form of a PDL description of a document and the intermediate printable data may take the form of a display list generated from the PDL description.

As shown in exemplary system includes computers such as a computing device and a server . Computing device and or server may be multi processor or multiple Central Processing Unit CPU systems. In some embodiments the processors may comprise multiple processor cores in a single package. For example Intel Pentium processors include dual core two core and quad core four core systems. The processor cores behave like independent closely coupled CPU s and can work in a coordinated fashion under program or hardware control.

Computing device and server may communicate over a connection which may pass through network which in one case could be the Internet. Computing device may be a computer workstation desktop computer laptop computer or any other computing device capable of being used in a networked environment. Server may be a platform capable of connecting to computing device and other devices not shown . Computing device and server may be capable of executing software not shown that allows the printing of documents using printers .

Exemplary printer includes devices that produce physical documents from electronic data including electro photographic printers such as laser printers and LED printers ink jet printers thermal printers laser imagers and offset printers. Printer may have an image transmitting receiving function an image scanning function and or a copying function as installed in facsimile machines and digital copiers.

In some embodiments printer may also be capable of directly printing documents received from computing device or server over connection . In some embodiments such an arrangement may allow for the direct printing of documents with or without additional processing by computing device or server . In some embodiments documents may contain one or more of text graphics and images. In some embodiments printer may receive PDL descriptions of documents for printing. Note too that document print processing can be distributed. Thus computing device server and or the printer may perform portions of document print processing including some portion of rasterization half toning color matching and or other manipulation processes before a document is physically printed by printer .

Computing device may also contain removable media drive . Removable media drive may include for example 3.5 inch floppy drives CD ROM drives DVD ROM drives CD RW or DVD RW drives USB flash drives and or any other removable media drives consistent with embodiments of the present invention. In some embodiments portions of the software application may reside on removable media and be read and executed by computing device using removable media drive .

Connection couples computing device server and printer and may be implemented as a wired or wireless connection using conventional communication protocols and or data port interfaces. In general connection can be any communication channel that allows transmission of data between the devices. In one embodiment for example the devices may be provided with conventional data ports such as parallel ports serial ports Ethernet USB SCSI FIREWIRE and or coaxial cable ports for transmission of data through the appropriate connection. In some embodiments the data ports may be wireless and the communication links could be some combination of wireless links or wired links that allows communication between the various devices.

Network could include a Local Area Network LAN a Wide Area Network WAN or the Internet. Printer may be connected to network through connection . In some embodiments printer may also be connected directly to computing device and or server .

A computer software application consistent with disclosed embodiments may be deployed on any of the exemplary computers as shown in . For example computing device could execute software that may be downloaded directly from server . Portions of the application may also be executed by printer .

In some embodiments printer may also be able to access secondary storage or other memory in computing device using I O ports and connection . In some embodiments printer may also be capable of executing software including a printer operating system and other appropriate application software. In some embodiments printer may allow paper sizes output trays color selections and print resolution among other options to be user configurable.

In some embodiments CPU may be a general purpose processor a special purpose processor or an embedded processor. In one embodiment CPU may be a multi core processor with the cores capable of parallel operation. In some embodiments each core of the multi core processor may be able to independently perform functions recited below for CPU . CPU can exchange data including control information and instructions with memory and or firmware . Memory may be any type of Dynamic Random Access Memory DRAM such as but not limited to SDRAM or RDRAM.

Firmware may hold instructions and data including but not limited to a boot up sequence predefined routines and other code. In some embodiments code and data in firmware may be copied to memory prior to being acted upon by CPU . Routines in firmware may include code to translate page descriptions received from computing device to display lists and image bands. In some embodiments firmware may include rasterization routines to convert display commands in a display list to an appropriate rasterized pixel map and store the pixel map in memory . Firmware may also include compression routines and memory management routines. In some embodiments data and instructions in firmware may be upgradeable.

In some embodiments CPU may act upon instructions and data and provide control and data to ASICs FPGAs and print engine to generate printed documents. In some embodiments ASICs FPGAs may also provide control and data to print engine . FPGAs ASICs may also implement one or more of translation compression and rasterization algorithms. In one embodiment portions of concurrent generation and parallel rasterization routines may be performed in parallel by multiple cores of DSP .

In some embodiments computing device can transform document data into a first printable data. Then the first printable data can be sent to printer for transformation into intermediate printable data. Printer may transform intermediate printable data into a final form of printable data and print according to this final form. In some embodiments the first printable data may correspond to a PDL description of a document.

In some embodiments the translation process from a PDL description of a document to the final printable data comprising of a series of lower level printer specific commands may include the generation of intermediate printable data comprising of display lists of objects. In some embodiments display lists may hold one or more of text graphics command and image data objects. In some embodiments objects in display lists may correspond to similar objects in a user document. In some embodiments display lists may aid in the generation of intermediate printable data.

In some embodiments display lists may be stored in memory or secondary storage . Exemplary secondary storage may be an internal or external hard disk memory stick or any other memory storage device capable of being used by printer . In one embodiment printer may have a removable media drive not shown . In some embodiments the display list may reside in one or more of printer computing device and server . Memory to store display lists may be a dedicated memory or form part of general purpose memory or some combination thereof according to some embodiments of the present invention. In some embodiments memory may be dynamically allocated to hold display lists as needed. In some embodiments memory allocated to store display lists may be dynamically released after processing.

Memory manager can allocate and manage memory. Routines in memory manager may be accessed using memory management API . Consistent with disclosed embodiments architecture permits memory pool to be managed as a single memory pool comprising blocks corresponding to both frame buffer and non frame buffer blocks. On one hand memory manager may permit memory allocation in blocks to prevent fragmentation to abstract away implementation details pertaining to memory management and to provide a standard interface through memory management Application Programming Interface API for access to its routines.

On the other hand pixmap code allows pixmaps to be viewed logically as an integral unit while permitting pixmaps to occupy one or more discontiguous memory blocks in memory pool by leveraging the functionality provided by memory manager through memory management API and frame buffer management library . This abstraction can be achieved using frame buffer management library to manage block and pointer allocation and deallocation for pixmaps state information pertaining to pixmaps and to track processes utilizing pixmaps. In some embodiments pixmap code may enable access to memory blocks for pixmaps. Each memory block is a chunk of contiguous memory. Memory blocks may contain one or more scanlines. A scanline is one row of pixels in the image.

In some embodiments frame buffer management library may allocate memory in blocks. In one embodiment the blocks may be of equal size. In another embodiment memory may be allocated either as a block or as an integral multiple of blocks called a super block. A super block is a set of contiguous blocks. For example frame buffer management library may allocate memory in blocks and super blocks where a super block may comprise four blocks. Super blocks may be useful to hold larger pixmaps and also to facilitate support for different paper sizes resolutions and orientations.

In one embodiment routines in memory manager may manage some subset of available memory in memory as memory pool and allocate memory from memory pool to requesting processes through memory management API . When memory is no longer needed by the requesting processes the memory may be deallocated and returned to memory pool where it can be made available to other processes. Thus exemplary memory manager may also provide various other memory management functions including routines to free memory routines to recover memory and swapping routines that can swap memory to secondary storage .

In some embodiments frame buffer may also be a part of memory pool and may be managed by memory manager . For example calls to functions in frame buffer management library may result in calls to functions in memory management API . Memory management API may then invoke one or more functions in memory manager . Results of the actions taken by memory manager may be routed back to the calling process.

Frame buffer management library may use memory manager to obtain blocks and pointers using interfaces specified in the memory management API . In one embodiment frame buffer may be allocated an initial contiguous block of memory and subsequent memory blocks may be allocated to frame buffer when requested. Memory blocks may also be allocated for other non frame buffer purposes from memory pool . In some embodiments distinct memory blocks assigned to the frame buffer or to other processes may occupy non contiguous memory locations in memory .

In some embodiments the display list may include commands defining data objects and their contexts within a document or a page within the document to be printed. These display commands may include data comprising characters or text graphic objects such as lines and images or raster data. In some embodiments the display list may be dynamically reconfigurable and is termed a Reconfigurable Display List RDL .

In some embodiments an exemplary RDL may be stored in a data structure that facilitates the dynamic manipulation and processing of data objects. For example objects in the RDL may include pointers to other objects in the RDL. Accordingly an application may be able to traverse the list from one object to the next to identify update manipulate and process objects. In addition the application may be able to track processed objects and identify the current object being processed.

In some embodiments a physical printable page may comprise one or more virtual or logical pages also termed an RDL page. In some embodiments an RDL page may further comprise one or more bands also called geometric bands. A band can refer to a geometrically defined region within the geometrical bounds of an RDL page. In some embodiments each band may be a horizontal section that holds objects present within that section of the logical page. In some embodiments an RDL page may comprise a linked list of instances of exemplary individual band data structures. In some embodiments the printable region of an RDL page can include all geometric bands contained within that RDL page.

In some embodiments bands may further comprise a set of RDL data blocks which hold objects within the band. In some embodiments the RDL data blocks may be of equal size. In some embodiments RDL data blocks may be used to store intermediate graphical objects and other data generated from a PDL description. In some embodiments data sent to Language Server for processing may include PDL data and language server may generate intermediate graphical objects and other data objects from the PDL description for use by raster servers to N. In some embodiments objects generated by language server may be used to build an RDL page.

In some embodiments when data or graphical objects generated by language server span band boundaries the objects may be stored in a separate referenced band and an offset to the location of the object in the referenced band is stored at an appropriate location in that specific geometric band. In some embodiments objects that are repeatedly used in an RDL page or a document may also be stored in a referenced band. The referenced bands can include objects which are referred to by other bands. So for example a single object in a single referenced band may be referred to multiple times by other bands.

In some embodiments referenced data or graphical objects generated by language server can comprise part of a larger complex object. In some embodiments the complex object is rasterized before being used by geometric bands. Such complex objects may be stored in a separate resource band. For example items in the resource band may include complex tiles or patterns which can comprise simpler graphical image or text primitives. These complex objects are rasterized prior to their use by geometric bands.

In one embodiment an RDL may be implemented using a data structure that allows certain display list objects to be stored in a manner that allows their manipulation dynamically. For example image objects may be compressed in place to increase the amount of available memory and decompressed when referenced and or used. In some embodiments an RDL may also permit RDL objects to be stored in memory and or secondary storage by holding pointers offsets or addresses to the actual locations of RDL objects which can then be retrieved when referenced and or used. In general the RDL allows display list objects to be flexibly stored and manipulated based on system constraints and parameters.

In one embodiment the translation of a PDL description of a document into a display list and or RDL representation may be performed by language server using routines in RDL library and memory manager . For example language server may take PDL language primitives and transform these into data and graphical objects and add these to the reconfigurable display list using the capability provided by functions in RDL library and memory manager . In one embodiment the display list may be stored and manipulated in a dynamically allocated memory pool such as exemplary memory pool which may be part of memory .

In some embodiments creation of the RDL may be an intermediate step in the processing of data prior to actual printing. The RDL may be parsed before conversion into a subsequent form. In some embodiments the subsequent form may be a final representation and the conversion process may be referred to as rasterizing the data. For example rasterization may be performed in parallel by raster servers to N using routines in frame buffer management library and pixmap code . Upon rasterization the rasterized data may be stored in frame buffer which may be part of memory pool using routines in memory manager which may be accessed through memory management API . In one embodiment the rasterized data may take the form of a bitmap or pixmap that specifies the marks to be made on a printed page.

Bands of an RDL page may be rasterized in parallel by one or more raster servers to N. In some embodiments bands in an RDL page may be rasterized in parallel until all bands have been processed. In some embodiments a band may be rasterized in a serial block by block manner until all objects have been provided to the rasterizer for that band. In some embodiments the parallel processes performing the rasterization may be slave processes operating under the control of at least one master process which can provide control and synchronization information. For example raster server may operate on a block in a band while raster server may operate on a different block in a different band. In some embodiments raster servers through N may be distributed among the various cores of CPU or DSP .

In a further embodiment multiple finished RDL pages may exist in the system at any given time. These may include RDL pages whose rasterization process has not completed. In some embodiments RDL pages need not be rasterized in the order of their construction. After rasterization is complete engine server may invoke routines in RDL library to delete the RDL page from memory and release memory used by that RDL page to memory pool .

In one embodiment multiple rasterization processes can rasterize different parts of the display list for a single RDL page simultaneously. For example in a master slave environment each parallel slave process can be assigned a band to rasterize. In some embodiments the bands assigned to each slave process may be distinct.

In some embodiments rasterization may occur when a block is filled or completed by language server . Language server may then generate additional blocks in parallel to the rasterization of the first block. When a second block for a different band has been completed rasterization may commence for the second block in parallel to any other block rasterization or generation process currently in progress. Additional concurrently completed blocks for different bands may also be rasterized in parallel with any other blocks that are currently being rasterized. In some embodiments rasterization processes operating in parallel may run on different cores of multi core CPU or multi core DSP .

In some embodiments the parallel rasterization processes may be part of raster servers to N. In one embodiment the parallel rasterization routines operate on distinct individual blocks corresponding to different bands. In some embodiments the order in which bands may be rasterized may not be sequential. In one embodiment parallel rasterization routines may be slave processes under the control of a master rasterization process. For example a master process may control the creation and deletion of RDLs. In some embodiments rasterization routines may operate in parallel on blocks in distinct bands while blocks within a band are processed in sequence in a serial manner. In one embodiment raster servers to N may also use routines in RDL library and pixmap code to perform their functions. For example routines in pixmap code may provide raster servers to N with access to pixmap routines to support parallel rasterization.

Exemplary engine server may process data in the pixmap for printing of the document. In some embodiments engine server may provide control information instructions and data to print engine . In some embodiments engine server may invoke routines that lead to freeing memory used by frame buffer objects after processing. In some embodiments portions of memory pool and or frame buffer may reside in memory or secondary storage . In some embodiments routines for language server raster servers to N and engine server may be provided in firmware or may be implemented using ASICs FPGAs .

Print engine may process the rasterized data in frame buffer and form a printable image of the page on a print medium such as paper using routines in frame buffer library . In one embodiment engine server may also use routines in RDL library and pixmap code . For example routines in pixmap code may permit a final pixmap comprising one or more color plane components and an alpha plane component to be utilized by print engine through engine server .

As noted earlier referenced band can store objects that span band boundaries and objects that are used repeatedly across bands while resource band can hold complex objects used across different drawable bands that need special processing before they can be used in conventional drawable bands . In traditional methods rasterization can commence when pages are completed. Therefore in traditional methods some of the cores in CPU may idle until the page has been completely processed by language server .

In some embodiments rasterization can begin as soon as the first RDL block in drawable band becomes full. In some embodiments a rasterization routine running on a core of CPU or DSP may begin processing completed RDL block . In some embodiments completed RDL block can be processed or consumed by an available slave rasterization process . During this time language server may continue to populate display lists in the RDL page. When an RDL block in a different band becomes full then RDL block can be processed by another available slave rasterization process .

When a slave rasterization process completes the rasterization of RDL block RDL block can be freed and returned to memory pool . The process may be repeated for all completed blocks using available slaves. In some embodiments slave rasterization process may be marked as available when it completes the rasterization of RDL block . In some embodiments slave rasterization process may be marked as unavailable when it starts processing RDL block . In some embodiments each slave rasterization process may run on a distinct core of CPU and or DSP . In some embodiments the process may run on a multi core CPU in computing device .

As shown in slave rasterization process has started rasterizing RDL block and begun the generation of pixmap corresponding to band . Concurrently slave rasterization process is starting the rasterization of a newly completed RDL block while language server continues to build RDL blocks and . In one embodiment slave rasterization processes may be implemented as part of raster servers to N. In one embodiment RDL may also be used to keep track of blocks that have been rendered. In some embodiments a master rasterization process or a page management task PMT can keep track of available slaves.

Any RDL referenced bands which can hold referenced objects and attribute objects can continue to accumulate RDL blocks . Data in RDL blocks in referenced bands may be referenced and used throughout the life of the page. Therefore in some embodiments data in RDL blocks in referenced bands may be rasterized more than once during the rasterization of an RDL page. Because drawable bands are continuously rasterized a greater portion of memory pool may be available making it less likely that RDL blocks will be swapped to secondary storage or compressed in place. If memory is unavailable then language server may wait for consumed blocks to be freed or may delete reference bands or invoke memory manager to apply one or more memory recovery strategies. Any deleted referenced bands can be regenerated at a later point.

In some embodiments resource band may be rasterized as soon as the display list for a single complex object is generated. In some embodiments the processing of bands that reference resource band may be stalled until the referenced complex object in resource band have been completely processed.

In some embodiments the disclosed parallel rasterization schemes can make use of available processor cores by scheduling additional slave rasterization processes on the cores. Accordingly rasterization processes are effectively pipelined so that a page is being rendered in stages corresponding to completed RDL blocks as the page is being built. Accordingly when an RDL page has been produced by language server a substantial portion of the page may already have been rasterized by slave rasterization processes . Therefore rasterization for the entire page can be completed shortly thereafter.

Other embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of one or more embodiments of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the invention being indicated by the following claims.

