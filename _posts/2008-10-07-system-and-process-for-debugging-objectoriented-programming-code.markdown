---

title: System and process for debugging object-oriented programming code
abstract: A process and system for interactive debugging of a computer program, is provided. One implementation involves providing a class for an object oriented computer program capable of executing on a computer system, the class having class methods defining a semantic field of the class; automatically monitoring the class during execution of the program, and leveraging said class methods by executing the class methods upon object-typed variables to obtain a pseudo-field value; and presenting the pseudo-field value along with fields of the said object-typed variables, on a user interface for debugging purposes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291386&OS=08291386&RS=08291386
owner: International Business Machines Corporation
number: 08291386
owner_city: Armonk
owner_country: US
publication_date: 20081007
---
The present invention relates generally to software program debugging tools and more particularly to software debugging tools for object oriented software programs.

In existing software debugging tools debuggers while debugging applications written in object oriented OO programming languages objects are presented into a debugger according to their structure that is the fields that their class define. This requires that the fields cleanly map the semantics of the objects. However frequently a class defines parts or whole of its semantics through methods while its fields mostly map to implementation details that may or may not help the developer depending on his focus on the class or classes that use it and his level of knowledge of the class internals. In certain cases the developer intimately knows the class but the class implementation for performance reasons or otherwise encodes its semantics in very difficult to understand fields.

The invention provides a process and system for interactive debugging of a computer program. One embodiment involves providing a class for an object oriented computer program capable of executing on a computer system the class having class methods defining a semantic field of the class automatically monitoring the class during execution of the program and leveraging said class methods by executing the class methods upon object typed variables to obtain a pseudo field value and presenting the pseudo field value along with fields of the said object typed variables on a user interface for debugging purposes.

Other aspects and advantages of the present invention will become apparent from the following detailed description which when taken in conjunction with the drawings illustrate by way of example the principles of the invention.

The following description is made for the purpose of illustrating the general principles of the invention and is not meant to limit the inventive concepts claimed herein. Further particular features described herein can be used in combination with other described features in each of the various possible combinations and permutations. Unless otherwise specifically defined herein all terms are to be given their broadest possible interpretation including meanings implied from the specification as well as meanings understood by those skilled in the art and or as defined in dictionaries treatises etc.

The invention provides a system and process for debugging object oriented programs code by leveraging all methods that have no parameters and returning a value. Certain methods of the class under test have defining semantic fields of the class wherein a debugger according to the invention recognizes and leverages those methods at debug time. In object oriented programming a class is template for creating objects and defines attributes e.g. name value and methods e.g. associated subroutines functions behaviors of each object.

The debugging computer system provides a debugging session wherein an object oriented software application is running on a computing system. The application at the moments in time that are of interest to debugging runs executes under the control of a debugger e.g. a software module . The application may run on a computer based system that may include a single machine that comprises a single core processor or a networked system that comprises multiple machines some of which include a single processor or some of which include multiple processors etc.

The debugging computer system further includes database of symbolic information about the application under test. The database may include various structures use diverse storage technologies be packaged with the executable components of the application etc. The debugger is configured to query information in the database about the application at the level of detail needed to implement its base debugging functions and implement debugging functions according to the invention.

In one implementation the debugger comprises a specialized software module configured to control execution of the application under test and to provide the user of the debugger with tools to diagnose the execution of the application from multiple points of view. The debugger further interacts with the application to selectively interrupt execution of one or more process threads of the application at precise points in time depending on specific conditions. As such the debugger controls execution of the application on behalf of the user leverages the symbolic information to provide debugging functions and interacts with the user via a user interface module .

The user interface module is configured to enable the user to interact with the debugger and control execution of the application and to diagnose the behavior of the application . The user interface provides several views and dialogs that may leverage a graphical user interface or rely upon character based multi line views and dialogs. Said views and dialogs provides controls e.g. interfaces to at least present the user with breakpoints which are points at which the execution of one or more threads of the application can be interrupted. Said views may also provide controls to resume the execution of the application in various manners e.g. step by step up to the following breakpoint etc. .

Preferably said views further include a view which for a given moment in time at which a given thread of the application is stopped at a given point in the executable code of the application presents the user with the variables that are in context. Such variable values are in memory and the application typically uses their addresses to fetch them. The debugger leverages the symbolic information database to fetch types etc.

The view provides controls for filtering part of the available information and for presenting variables that are not of elementary types via means that makes this practical within a finite view i.e. types more complex than simple types of a considered programming language such as int and other integral types chars strings of chars booleans etc. .

The view also provides controls for the user to choose how much of the internal presentation structure of the view should be displayed. It is important to consider the relationship between the view and structured variables e.g. objects and depending on the programming language other structures that are supported by dedicated language features such as arrays tuples etc. . A typical object or class instance may have many fields. Some of these fields can be objects or even of the type of the considered object itself. The view provides controls for the user to focus on presenting a subpart of the available information as desired.

For example the view may provide controls such as scrolling controls for a windowing system wherein the information is presented into what may be considered as an infinite view a small part of which is presented to the user on a display and scroll bars are provided to move up or down parts of the available information.

Another control of the view includes presenting information using a tree hierarchical metaphor wherein only digging deeper into the tree the user can view further information. For example having a JAVA Java is a trademark of Sun Microsystems Inc. in the United States and foreign counties class X int i X next at hand the three metaphor would involve presenting the user with only the following view this at 000

where the is in fact a control that enables the user to instruct the view to expand the tree doing so could for a given execution of the application result into this at 000 i 0 next at 000

Another control of the view includes filters that leverage properties that are more related e.g. field visibility inherited fields etc. or less related e.g. field name name matching a regular expression etc. to the semantics of the programming language used by the application .

Other controls for the view provides strategies for rendering information on a display for the user may also be implemented. Such strategies may also be combined. The rendering presented in the above examples are eventually subject to various embodiments of the debugger . The operation of an example debugger may rely upon one or more processes described below as described in relation to . Only methods that have a suitable signature can be used i.e. methods defining semantic fields . Such methods present pseudo field values along with fields of object typed variables on a user interface for debugging purposes 

At block since the variable is of simple type the debugger fetches the value of that variable which depending on the runtime environment may involve various techniques. For a compiled language such as C this would involve computing the memory address and size of the variable then interpreting the resulting memory chunk according to the variable type. For an interpreted language like JAVA in which a virtual machine is equipped with dedicated application programming interfaces APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value.

At block the debugger presents information about said variable into the view and the process proceeds to block . The information displayed may include the type name and value of the said variable other information about said variable may also be displayed .

At block if additional variables remain in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and the debugger awaits a next command.

At block referenced above since said variable is of complex type the debugger fetches an identifier for the variable e.g. memory address of the variable or any other value guaranteed to identify the variable . At block the debugger presents information about the variable into the view and the process proceeds to block . The display of information about the variable in view may include the type name and identifier of the variable. The user is also enabled to request the details of the variable value which may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. the user utilizes a contextual menu . The information presented may include automatically or on demand the string representation of the variable e.g. in JAVA this would result from the call of the toString method upon the object since all classes ultimately inherit from Object .

According to the present invention the debugger further presents in the view the result of the execution of eligible methods upon object typed variables along with the true fields of the said variables. Whenever fields of an object type are considered for all methods that have a return type and do not take parameters the process involves deriving a pseudo field name from the method name running the method to obtain a pseudo field value and leveraging those names and values as if they were the names and values of a regular field.

At block the debugger interacts with the symbolic information to determine the names and types of the fields of the variable and to elaborate a list of all methods that can be called upon the variable said methods having no parameter and return a value. For each of those methods the debugger remembers its name and its return type. Optionally the debugger associates a short name to each method deriving that short name from the method name using rules e.g. method getName may be associated to name name by a rule strip leading get and lowercase leading letter and uses the resulting short names for sorting in block further below.

At block optionally the debugger filters out some of the fields and methods based upon various criteria and only retain the remaining ones for presentation.

At block optionally the debugger sorts the collection of fields and methods according to sorting criteria associated with the view or the debugger itself. Depending on the sorting criteria the fields and methods may be interleaved.

At block the debugger selects the first field or method of the variable and removes it from the list of fields and variables to be considered.

At block if the field or the method return value is of complex type then the process proceeds to block otherwise the process proceeds in sequence to block .

At block if a field was obtained at block the debugger determines the value of the field for the considered variable. Depending on the runtime environment this may involve various techniques e.g. for a compiled language such as C this would involve computing the memory address and size of the field then interpreting the resulting memory chunk according to the field type for an interpreted language such as JAVA in which a virtual machine is equipped with dedicated APIs to do so this would involve communicating with the virtual machine through the appropriate API to obtain the value . If at block a method was obtained then in block herein the debugger calls that method upon the variable at hand to get a value.

At block if a field was obtained at block then the debugger displays the field related information via the view then proceeds to block . The information displayed may include the type name and value of the said field other information may be displayed . If at block a method was obtained the debugger performs the same as for a field using the name of the method or the short name associated to the method as if it was a field name and the value computed at block as a field value.

At block if a field was obtained at block then since the field is of complex type the debugger fetches an identifier for the field e.g. this can be its memory address or any other value guaranteed to identify the field . If a method was obtained at then at the debugger calls that method upon the variable at hand to obtain any missing information e.g. determine if the value is null or it points to a specific memory location .

At block if a field was obtained at then the debugger presents the field into the view then the process proceeds to . The presentation of the field typically includes the type name if its enclosing type and identifier of the field. The user is also enabled to request for the details of the field value. This may involve explicit graphics e.g. when a click able plus sign is provided or may not involve explicit graphics e.g. when a contextual menu is provided . The information that is presented may include automatically or on demand the string representation of the field e.g. in JAVA this would result from the call of the toString method upon the object since all classes ultimately inherit from Object . If a method was obtained at then at the debugger performs the same as for a field using the name of the method or the short name associated to the method as if it was a field name and the information computed at .

At block if there are more fields or methods to handle for the considered complex variable the process loops back to block otherwise the process proceeds to block for completion and awaiting next commands.

At block the debugger presents the user in the user interface with information about the current point of execution of the application . At block the debugger collects the variables that are in scope at the current point of execution again . At block optionally the debugger filters out some of the variables based upon various criteria and only retains the remaining ones as needing to be presented. At block optionally the debugger sorts the variables according to sorting associated with the view or the debugger itself. At block the debugger selects the first variable in scope and removes it from the list of variables to handle. At block the debugger tests whether the current variable was already displayed in view or not. If not the process proceeds to block otherwise the process continues to block .

At block the debugger utilizes the process of starting at block and ending before block then branches to block instead of from block and . In effect the debugger handles the display of a variable that was not in scope at the former breakpoint.

At block the variable being considered was already displayed in view wherein the debugger considers whether the variable is of complex type or not. If the variable is of complex type the process branches to block otherwise the process continues to block . At block since the variable being considered is of simple type the debugger fetches the values of the variable. At block the debugger refreshes the variable display into the view then proceeds to block . In one implementation a brute force approach is used to simply display the variable as if it had not been seen at the previous step. In another implementation it is determined which variables may have changed and which have not changed and only the ones changed are refreshed.

At block since the variable being considered is of complex type it is refreshed accordingly an example is described in conjunction with further below . At block if there are more variables in scope that have not been presented yet the process loops back to block otherwise the process proceeds to block for completion and awaiting a next user command.

At block since the variable is of simple type the value of the variable is fetched. At block the value of the variable is refreshed in the view and the process proceeds to block . At block since the variable is of complex type it is checked against void e.g. null in JAVA or 0 in C programming language . If the variable is void the process proceeds to block else the process proceeds to block .

At block since the variable of complex type is void it is displayed as such in the view this includes pruning the subtree that previously showed detailed values for the same variable at the previous breakpoint if any . The process then proceeds to block .

At block since a variable of complex type is non void it is checked if its details were displayed or not. If not the process proceeds to block otherwise the process proceeds to block .

At block since a non void variable of complex type was displayed without its details or was displayed with details but changed its type the display of its value is refreshed e.g. display the same information as that in block in . The process then proceeds to step .

At block since a non void variable of complex type was displayed with its details it is checked if its type has changed or not. If yes the process proceeds to block else the process proceeds to block .

At block since a non void variable of complex type was displayed with its details and its type has not changed its fields and suitable methods are collected. There are both real fields and semantic fields as for any complex type variable or method result.

At block optionally the debugger filters out some of the fields methods based upon various criteria and only retains the remaining ones as needing to be presented.

At block optionally the debugger sorts the fields methods according to sorting criteria associated with the view or the debugger itself.

At block the first field methods that is still to be handled is selected and removed from the list of fields methods to handle.

At block if there are more fields methods on the stack to handle the process loops back to block else the process loops back to block .

At block the stack is empty and all visible variables have been refreshed wherein the process proceeds to block .

Blocks use the method name and return the value computed at block as if they were the name and value of a field.

Another example involves calling methods more sparingly. The debugger presents methods as special fields and provides the user with controls to call them either individually or batches at a time. There is a continuum of possible implementations ranging from systematic execution described hereinabove to the display of a refresh indicator close to each special field which the user would have to click to obtain the corresponding value.

Embodiments of the present invention are applicable to all object programming languages that are equipped with debug time runtime introspection at least to the point of enabling the execution of methods which are selected at runtime. This includes at least most interpreted programming languages certain semi interpreted programming languages e.g. JAVA and certain compiled programming languages. In the case of compiled programs it is common practice to pass compiler specific options to produce a debug enabled version of the executable application that version carries sufficient information for the debugger to interpret memory and registers contents and to modify the memory and registers contents with the effect of assigning new values to attributes or running methods of objects this is not using introspection per se but points to the same needed basic abilities i.e. access to an object instance access to its type description read its attributes execute its methods.

All methods that take no parameter and return a value are eligible for application of the present invention and the debugger may apply matching and filtering rules to select certain methods e.g. the debugger may be equipped with built in or user level matching rules such as all instance methods whose name starts with get .

All the application code is elaborated in the context of normal programming with the full support of the integrated development environment IDE chosen by the developer user of the class under test. As noted the developer should keep in mind that only methods that have a suitable signature can be used i.e. methods defining semantic fields . However even developers who may be unaware of the use of their classes by the invention may equip their classes with a few useful eligible methods for the benefit of the applications that use their classes. Their classes then are at least partially equipped for the invention without the developer even knowing it. The renderers are a true part of the class under in the application under test and are managed with it from the source code management system point of view. The debugger is automatic from the standpoint of the class user. As such once the developer of a class has equipped it properly with renderers which can be implicit as explained above users of the class can automatically use said renderings e.g. view in interface . In certain variants of the invention user intervention may be received to refine program behaviors.

The invention only leverages the user code as it is written and can be readily adopted by diverse debuggers without requiring sharing of knowledge about the debugger implementations. The invention can be reused with logging frameworks since the invention enables writing of rendering methods that are available with the code under test wherein said methods can be reused for other debugging purposes and especially logging. The invention further provides efficient encapsulation wherein the effort of bridging the internals towards semantics is left with the class under test author which is the most capable of doing so.

PCI bus provides an interface for a variety of devices that are shared by host processor s and Service Processor including for example flash memory . PCI to ISA bridge provides bus control to handle transfers between PCI bus and ISA bus universal serial bus USB functionality power management functionality and can include other functional elements not shown such as a real time clock RTC DMA control interrupt support and system management bus support. Nonvolatile RAM is attached to ISA Bus . Service Processor includes JTAG and I2C busses for communication with processor s during initialization steps. JTAG I2C busses are also coupled to L2 cache Host to PCI bridge and main memory providing a communications path between the processor the Service Processor the L2 cache the Host to PCI bridge and the main memory. Service Processor also has access to system power resources for powering down information handling device .

Peripheral devices and input output I O devices can be attached to various interfaces e.g. parallel interface serial interface keyboard interface and mouse interface coupled to ISA bus . Alternatively many I O devices can be accommodated by a super I O controller not shown attached to ISA bus .

In order to attach the computer system to another computer system to copy files over a network LAN card is coupled to PCI bus . Similarly to connect computer system to an ISP to connect to the Internet using a telephone line connection modem is connected to serial port and PCI to ISA Bridge .

While the computer system described in is capable of executing the processes described herein this computer system is simply one example of a computer system. Those skilled in the art will appreciate that many other computer system designs having one or more processors are capable of performing the processes described herein.

As is known to those skilled in the art the aforementioned example embodiments described above according to the present invention can be implemented in many ways such as program instructions for execution by a processor as software modules as computer program product on computer readable media as logic circuits as silicon wafers as integrated circuits as application specific integrated circuits as firmware etc. Though the present invention has been described with reference to certain versions thereof however other versions are possible. Therefore the spirit and scope of the appended claims should not be limited to the description of the preferred versions contained herein.

Those skilled in the art will appreciate that various adaptations and modifications of the just described preferred embodiments can be configured without departing from the scope and spirit of the invention. Therefore it is to be understood that within the scope of the appended claims the invention may be practiced other than as specifically described herein.

