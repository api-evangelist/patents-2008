---

title: Altered token sandboxing
abstract: Embodiments of the present invention relate generally to application security. In an embodiment, a method for altered token sandboxing includes creating a process based on a naked token and suspending the process. The method further includes obtaining an impersonation token and resuming the process with the impersonation token. The method further includes acquiring resources needed for the process with the impersonation token. The method also includes replacing the impersonation token with the naked token. In a further embodiment, the method further includes executing the suspended process with the naked token and the acquired resources. In another embodiment, a system for user-mode, altered token sandboxing includes a security module, an acquisition module and a replacement module. In a further embodiment, the system may include an execution module. In another embodiment, the system may include a request module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08429741&OS=08429741&RS=08429741
owner: Google, Inc.
number: 08429741
owner_city: Mountain View
owner_country: US
publication_date: 20080829
---
It is important for computer systems to run untrusted software securely. Untrusted code such as spyware viruses or adware may be received through the Internet and executed on a computer system. During execution these software processes may be able to unsafely access and use system resources. Executing untrusted software can compromise or destroy an unprotected computer. Untrusted software may also compromise the privacy of a computer s users.

The security of a computer process can be handled in different ways. For example some operating systems such as WINDOWS VISTA presently handle security through the use of tokens. A token may encapsulate a user identity and specific rights allowed or denied to that user. A token is like a badge that identifies the bearer. Each object of an operating system is annotated with a list of users or groups that can access the object. An operating system will create a handle based on an object and a token when a desired action is granted. The handle will include the user s identity and an action the user may perform. A system may look at this handle determine if a user can take a requested action and then either allow or deny the requested action. Tokens may be altered to provide a limited set of privileges. These limitations may leave a process with access to either too many or too few resources.

Running software processes securely is more difficult in multi threaded systems. Multi threaded systems allowed processes to spawn sub processes or threads that can be run concurrently. A process may limit the actions its threads may take. To limit the rights of its threads or child processes a process can copy and alter the original process token so that a more restrictive token can be attached to each thread. These token copies could be altered to restrict certain actions by the thread.

Even with these precautions applications could use holes in security or the threading environment to access sensitive portions of the computer. Sandboxing has been developed to secure these holes. Sandboxing may be defined as a mechanism which allows a host system to execute guest code in a confined environment so that the guest code can only affect the host system according to a defined policy. Sandboxing may be performed in kernel mode or user mode.

Kernel mode sandboxing may modify an operating system by adding additional device drivers. These device drivers provide additional privilege checking to restrict guest code from affecting the host system. Because this method deals with manipulating the operating system directly it does not require a lot of overhead or significantly affect the performance of applications. Kernel mode sandboxing also allows users to run any application without requiring application code to be rewritten. However kernel mode sandboxing is highly risky. A designer must write or rewrite portions of the operating system. This is a highly sensitive area and any mistake can have drastic consequences.

In a few cases sandboxing may take place in user mode. User mode sandboxing may be implemented as a program that can be loaded by any user not just a privileged user. User mode sandboxing may include dynamic translation. Dynamic translation involves rewriting instruction code at execution time into a safe form before executing the code. Dynamic translation is performed for example with VMWARE. Because the operating system is not reconfigured or added to user mode sandboxing is safer than kernel mode. However user mode sandboxing reduces application performance because of the overhead involved in rewriting code during execution.

User mode sandboxing may also include segmentation. VX32 is a user level sandbox which uses segmentation and dynamic translation. Bryan Ford and Russ Cox Vx32 Lightweight User level Sandboxing on the x86 Massachusetts Institute of Technology PDOS 2008. Segmentation is implemented by cordoning off memory access for specific applications. This implementation of sandboxing requires rewriting the software code depending on the application and the operating system. It is also limited in the security it can provide. While memory cannot be accessed outside of specified regions this system only provides memory protection. Applications may still spawn other processes and have access to other system resources.

Many network applications such as browsers run guest code from other sources. These applications need to be restricted in order to secure the system. But in order to start an application the application must be granted certain access to memory and system resources. Once the application is granted access and started that access may not be further restricted due to present system limitations. These limitations have been used by untrusted and malicious code to run unauthorized code.

What is needed is a way to run guest code in a multithreaded system with more process security and with less performance loss.

Embodiments of the present invention relate to systems and methods for altered token sandboxing. According to an embodiment a method for altered token sandboxing is provided. The method includes creating a process based on a naked token and suspending the process. The method also includes obtaining an impersonation token and resuming the process with the impersonation token. The method further includes acquiring resources needed for the process with the impersonation token. The method also includes replacing the impersonation token with the naked token. According to a further embodiment the method may include executing the suspended process with the naked token and the acquired resources.

According to another embodiment a system for altered token sandboxing is provided. The system includes a security module configured to create and suspend a process using a naked token. The system further includes an acquisition module configured to use an impersonation token to acquire resources needed for the process. The system also includes a replacement module configured to replace the impersonation token with the naked token. According to a further embodiment the system may include an execution module configured to execute the process with the impersonation token and the acquired resources.

Further embodiments features and advantages of the invention as well as the structure and operation of the various embodiments of the invention are described in detail below with reference to accompanying drawings.

While the present invention is described herein with reference to illustrative embodiments for particular applications it should be understood that the invention is not limited thereto. Those skilled in the art with access to the teachings provided herein will recognize additional modifications applications and embodiments within the scope thereof and additional fields in which the invention would be of significant utility.

Embodiments described herein refer to systems and methods for user mode altered token sandboxing. As described above sandboxing allows a process to get access to safe handles. If a process gets a handle that is dangerously privileged malicious code can destroy a program or computer or access confidential files. Some developers could be more careful. Coding bugs may provide such dangerous handles. These bugs may exist in an operating system API or in a third party component. Some software gives users handles with more privilege than is necessary. Most WINDOWS users run programs with Admin level privileges. Application installers sometimes create objects with a security descriptor that gives everyone full access to it. Many handles allow users to modify objects.

According to an aspect of the invention sandboxing may prevent malicious code from obtaining bad handles and affecting a host system or reading a user s personal files. Sandboxing may protect against things such as buffer overflows integer overflows and format parsing decoding flaws that could be exploited. User mode altered token sandboxing works within the framework of the operating system. In one embodiment an example operating system may be but is not limited to WINDOWS VISTA WINDOWS XP or other MICROSOFT operating system. User mode altered token sandboxing does not require modification of the operating system and it does not inspect or rewrite pieces of code. It leverages the operating system to keep things safe. This requires a knowledge of the operating system in order to make necessary API calls. User mode altered token sandboxing prevents access to files pipes threads process tokens registry keys inter process communication IPC objects and WINDOWS services. It may not limit access to central processing unit CPU usage but use of a CPU can be controlled by the use of a job as described below.

Handles may be provided based on altered tokens or tokens with a different set of privileges than the user. These less privileged tokens may limit what processes may be effected. For instance plug ins may be given lesser rights to the file system or registry and no rights to operating system services. However limited privileges are often not limited enough as these less privileged processes may still be able to access the file system and registry. Some operating system engineers have created least privilege tokens or tokens with a minimum amount of privileges. To start a process the operating system requires the parent process to have access to certain key components. Some privileges are required during some periods of processing or else a process will fail.

According to an embodiment all privileges and effective groups may be removed from a token in order to produce a naked token. A naked token has no privileges. A naked token would have no access for example to the file system registry operating systems services or APIs. Engineers previously have not used naked tokens because they believed that naked tokens would have resulted in many process request denials upon execution of a new process. These denials would cause an operating system to forcefully abort process creation or the process would crash. This might have been the case if a process had a naked token during its entire lifetime. Typically once a process is started its rights may not change.

According to an aspect of the invention a sandboxed application may require two processes a parent process and a child process. These processes may be referred to as a broker and a target. These can both have the same process image. Both processes may use a sandbox library which provides a high level API for managing sandboxing. A broker may be for example a browser. shows browser in exemplary system illustrating a multi process application according to an embodiment. In such a case a target process may be a renderer. There may be multiple renderers as shown in . The browser may run trusted code while each renderer may run guest code or untrusted code. For example renderer may execute JAVASCRIPT. Renderer might perform HTML rendering or image decoding. Renderer may run a plug in or a flash object. These renderer processes may be locked down with sandboxing. That is the sandboxing will secure the processes. The privilege perimeter will ensure that any external code that gets loaded will fail if it tries to create or open objects.

According to an aspect of the present invention a naked token removes all access privileges from the target process. When a thread attempts to access an object an operating system security manager may compare the principals listed in the thread s access token against the rights defined on the object s discretionary access control list DACL . A naked token may not allow actions based on a DACL. A target process running with a naked token cannot access any object with a non NULL DACL. Objects with NULL DACLs cannot be secured either because a security manager skips the access check.

Principals are represented by security identifiers SIDs representing the token owner and all group membership. According to an aspect of the present invention a token may be made naked in at least three ways. First a token may enumerate all SIDs in the original token and mark them DENY ONLY according to an embodiment. When a SID is marked DENY ONLY a security manager will only use the SID to check if access is denied the SID cannot be used to grant access to an object. Second an SID may be added to the Restricted SIDs list according to a further embodiment. This is needed where all SIDs are not marked DENY ONLY. If a Restricted SIDs list is not NULL a security manager may do a two pass authorization check. Access is first checked using the regular SIDs list and then the Restricted SIDs list. Access must be granted in for a thread to get access to an object. Third all privileges and SIDs may be removed according to an embodiment.

Target may also be associated with a job object according to an embodiment. This restricts behaviors that are not subject to security manager checks. The job prevents target from sending window messages to processes outside the job creating new processes creating or changing desktops changing display settings calling an exit function using the global Atoms table using user handles owned by other processes reading writing the clipboard changing system parameters or excessively using a CPU or memory. Security module may set the security level of a job object to which a target process will belong. The job object s security level cannot be changed once the target process is spawned.

Security module then resumes target . Security module may resume target with an impersonation token according to an embodiment. The impersonation token may have a user s privileges so it can access objects. It may be based on a user token of broker . According to a further embodiment the impersonation token may also be a token with full privileges. According to an embodiment this token may have some restricted privileges. It may also include one or more handles required to acquire the resources necessary for the process. According to another embodiment a token may have just enough privilege to acquire resources and proceed to a main function and no more. The impersonation token may not have administrator rights but may do work as needed.

According to another embodiment a handle of a process may be duplicated. The handle may then be transferred to a thread of the process such as target . According to a further embodiment target may resume with an impersonation token. Initialization or further initialization of the process may take place before approaching the main function on the thread. Acquisition module may be called by target . Acquisition module may be coupled to security module directly or through API intercepts.

According to an embodiment acquisition module is configured to use an impersonation token to acquire resources needed for the process. A necessary handle a dynamic link library DLL a plug in an interface or a memory allocation may be acquired. Acquisition module may also acquire resources necessary to execute the operating system OS loader find a main function of an application proceed to a main function of a process execute a main function of a process or execute a run time library.

According to an embodiment replacement module may be configured to replace the impersonation token with a naked token. The impersonation token may be released. A naked token may then be the remaining token. The naked token may also be a default token. According to a further embodiment replacement module may also be configured to lower the token to be naked. Replacement module may be an API call by target to lower its token. According to a further embodiment target may not make explicit calls to the broker. The calls may be made from API intercepts when the sandbox policy allows it.

Security module may also include resume module according to an embodiment. Resume module may be configured to resume the suspended process. Resume module may replace a user token with an impersonation token prior to resuming the process. This replacement may also be performed by security module spawn module or replacement module . According to a further embodiment resume module may resume the process for acquisition module .

According to an embodiment broker may make calls to the sandbox API to set up a sandbox. Broker and target may use API intercepts for communication. Such communication may be prepared by security module . According to a further embodiment security module may include patch module . Patch module may be configured to generate at least one API wrapper. Patch module may also be configured to set up API patches. It many cases target may not contain code that makes explicit calls to broker from target . The calls may be made from API intercepts when the sandbox policy or configuration allows it. According to a further embodiment target may not open files and network ports. If target needs any such resources it may request the resources from broker . Interception capabilities allow for flexibility in dealing with low privilege applications. However user mode interceptions are not the place to enforce security as they can be bypassed by malicious code.

According to an embodiment a sandboxing inter process communication IPC may be a low level high performance IPC crafted to perform same machine cross process call invocations. Such an IPC can occur at the NTDLL layer. An IPC may be blocking on a target side but multiple target side threads can have IPC serviced simultaneously. An IPC may also be designed for small payloads that can be expanded to handle larger payloads.

According to a further embodiment an IPC may be a channel. A channel may include a shared memory section and two events. Each channel can only service one IPC at a time but between broker and a target there may be several channels all lined up in a larger memory section. The two events are used to signal three different phases of an IPC. Target initiates IPC by copying data into the section. When broker is signaled by target broker copies the data out processes it and fills the section with the result. Broker signals to target that the IPC result is ready. Target is awakened.

Replacement module may include API module according to an embodiment. API module may be configured to replace an impersonation token with a naked token. According to another embodiment replacement module may include lower token module . Lower token module may be configured to lower the impersonation token to the naked token. Replacement module may have either API module or lower token module . According to a further embodiment replacement module may have both.

According to a further embodiment execution module may include request module . Request module may be configured to generate a request for additional resources. This request may take place after acquiring resources with an impersonation token and then dropping the impersonation token. To handle this request for additional resources broker may include intercept module policy evaluation module and result module according to an embodiment. Intercept module may be configured to intercept a request for additional resources.

Policy evaluation module may be configured to receive the intercepted request evaluate the intercepted request against a policy and return a policy evaluation result. The policy may include privilege information a DACL or use any other common methods for access verification. According to an embodiment policy evaluation may involve code generation on the fly. Policy op codes may be used. A mini program may be used to generate the code. Performance may be improved using such pre compiled code.

Results module may be configured to receive the policy evaluation result from the evaluation module execute at least one requested operation and return at least one additional resource to the execution module.

In step the impersonation token may be used to acquire resources needed for the process. These include resources needed to load any necessary resources to prepare to start the main function. Other resources that may be acquired are described above. For instance target may be bootstrapped. DLLs or plug ins may be loaded. An interface may also be retrieved. Step may be performed by acquisition module . After which the target process may enter the main function. The code of main function may be under more control by the host system.

In step the impersonation token may be replaced with a naked token. This step may be performed by replacement module . The impersonation token may be removed and a naked token used in its place. This may be performed by replacement module or API module . In another embodiment the impersonation token may be lowered to be naked. This may be performed by security module or lower token module . An IPC communication channel may be setup between processes before the token is dropped.

In step the child process is executed with the naked token and the acquired resources. This step may be performed with execution module . According to a further embodiment target may revert to a naked token following a global initialization function. Untrusted code may start running only after the global initialization function returns. Steps to may be performed by a child process or thread such as target .

Embodiments of the present invention may be used for many and different applications. Altered token sandboxing such as user mode may be used for but not limited to web browsers. Loading and executing untrusted code may take place when a browser goes to a new website. Though a browser s code may be trusted renderers may be sandboxed for each new website aspect of a website or content associated with a website. Such sandboxing may provide for better host system security. This may result in a better experience for both the user of the browser and for legitimate providers of web content.

Aspects of the present invention for exemplary system system system system and or method or any part s or function s thereof may be implemented using hardware software modules firmware tangible computer readable media having instructions stored thereon or a combination thereof and may be implemented in one or more computer systems or other processing systems. Examples of computer systems include but are not limited to a computer mobile device such as a handheld mobile phone smart phone personal data assistant or laptop workstation server cluster of computers embedded system game console kiosk set top box or television.

The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

