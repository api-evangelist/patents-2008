---

title: Application-managed file versioning
abstract: In accordance with one or more aspects of the application-managed file versioning, a request to store a new version of a file is received from an application, the request having been generated by the application. A filename for the new version of the file is generated, derived from a standardized naming convention. The filename includes a first portion having at least a portion of a name of the file, and a second portion having data indicating that the new version of the file is a version of the file. A set of application programming interfaces (APIs) can be exposed that allow the application to manage file versions, such as creating a new version of a file, identifying one or more versions of the file, listing one or more versions of the file, and deleting one or more versions of the file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856088&OS=08856088&RS=08856088
owner: Microsoft Corporation
number: 08856088
owner_city: Redmond
owner_country: US
publication_date: 20080401
---
Users sometimes accidentally lose data in a file they are working on. Some losses occur because users change their mind about an edit they made such as deciding they want to keep a paragraph that they deleted the previous day. Other losses occur because users inadvertently delete a portion of a file such as by not realizing they hit the delete key while certain words were selected. Such accidental data loss is problematic for users and unfortunately is oftentimes irreversible by the time the user realizes the data has been lost.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects of the application managed file versioning a request to store a new version of a file is received from an application. A filename for the new version of the file is generated. The filename includes a first portion having at least a portion of a name of the file and a second portion having data indicating that the new version of the file is a version of the file.

In accordance with one or more aspects of the application managed file versioning an event in an application is identified the event corresponding to an application specific event. In response to the event being identified the application determines that a new version of the file is to be saved. A request is sent to a file system module to save the new version of the file the request including a name of the file for which the new version is to be saved.

In accordance with one or more aspects of the application managed file versioning a set of application programming interfaces APIs is exposed that allow an application running on a device to manage file versions. The set of APIs include one or more APIs to create a new version of a file and one or more APIs to identify one or more versions of the file.

Application managed file versioning is discussed herein. An operating system of a computing device supports file versioning exposing functionality to applications running on the computing device that allows the applications to manage file versions including creating new versions of files. The applications determine when a new version of a file is to be created with different applications using different criteria to make this determination. To create a new version the application invokes the functionality exposed by the operating system which in turn saves a new version of the file. This new version of the file is saved with a name derived from the standardized naming convention in a known location using a particular filename format with the combination of this known location and the particular filename format allowing the new version of the file to be subsequently identified as a version of that particular file.

Computing device includes an operating system and one or more applications running thereon. Operating system and applications are typically implemented as software or firmware instructions that are stored in one or more memories and executed by one or more processors of computing device . Alternatively operating system and or applications or portions thereof can be implemented in other manners such as in hardware.

Operating system includes a versioning module exposing functionality to applications . In the illustrated example of this functionality is exposed via one or more application programming interfaces APIs . It is to be appreciated that APIs are only one example way in which applications can access functionality of versioning module . Other techniques can alternatively be used such as Component Object Model COM technologies Microsoft .NET connection software different technologies for allowing processes and or functions to be invoked and so forth.

Operating system also includes a file system module that saves retrieves and deletes versions of files as directed by versioning module . Although illustrated as a separate module external to file system module versioning module can alternatively be included as part of file system module . Additionally although illustrated as being part of operating system versioning module could alternatively be implemented external to operating system .

Versioning module directs file system module to save versions of files retrieve versions of files and delete versions of files based at least in part on direction received from applications via APIs . File system stores versions of files on a storage device included as part of computing device and or a storage device external to computing device . Each storage device and or can be a variety of different devices on which files can be stored such as a magnetic or optical disk flash memory and so forth.

Each application can access multiple files managed by file system and each of these multiple files can have multiple corresponding versions. A version of a file refers to a copy of the file saved at some point in time and changes made to the file after saving that version of the file are not included in the file. So if a user decides that he or she wants to recover a paragraph of a document that he or she deleted after saving the version of the file that saved version can be accessed and the desired paragraph recovered.

In one or more embodiments the initially created file is used as the file to which changes are made and copies of that file are saved at the appropriate times as versions of that file. For example a user may request creation of a new word processing document with additions and or deletions of text being made to that originally created document. When a new version of the document is to be created a copy of that document as it exists at the time of creating the new version is generated and saved. Subsequent additions and or deletions of the text continue to be made to the originally created document.

In other embodiments the initially created file is kept unchanged and changes made by the user are made to a version of that file. For example a photo editing application may access a digital picture. This digital picture is viewed by the application as the original document. A new version of that original document is created and edits made by the user are made to that original document. When a new version of the document is to be created the currently used version is saved and a new version is created with subsequent edits to the digital picture being made to the newly created version.

Each application manages the versions of the files that it opens edits and or otherwise accesses. This management includes requesting that new versions of files be saved requesting that particular versions of files be deleted recovering data from previously created versions of files and so forth.

As part of this management an application determines when a new version of a file is to be saved. In one or more embodiments this determination is made automatically by application and can be made based on a variety of different criteria as discussed in more detail below. Different applications can employ different criteria to determine when a new version of a file is to be saved. When an application determines that a new version of a file is to be saved the application sends a request to versioning module to save a new version of the file. This request can be sent in a variety of different manners and in one or more embodiments is sent by invoking one or more of APIs . In response to this request versioning module saves the requested new version of the file using file system module .

Also as part of this management an application determines when a version of a file is to be deleted or purged. As discussed in more detail below the number of versions that can be maintained for a particular file may be limited in some embodiments. Application enforces such limits by deleting one or more versions of a file so that such limits are not exceeded.

File versions can be managed in system similar to that discussed with respect to computing device of except that the application requesting saving of the new version retrieving versions and deleting versions is running on a different computing device than versioning module . Accordingly application sends a request to a different computing device rather than accessing functionality on the same device as application is running.

Upon receipt of a request to save a new version of a file versioning module directs file system to save the file to a storage device that is included as part of computing device or alternatively on a storage device that is external to computing device . A storage device external to computing device can be directly coupled to computing device such as storage device . Alternatively computing device can access a storage device via a network .

Computing devices and can communicate with one another as well as with a storage device e.g. a file server via network . Network can be a variety of different networks including the Internet a local area network LAN a public telephone network an intranet other public and or proprietary networks combinations thereof and so forth.

Returning to each version of a file is saved by file system as a separate file from other versions of the file. In one or more embodiments each version of a file is saved with a read only attribute marked preventing changes from being written to the file after it is created. The filename for a version of a file conforms to a particular format including two or more portions. One portion of the format stores at least a portion of a name of the file and another portion of the format stores data indicating that the new version of the file is a version of the file.

Having at least a portion of the name of the file included in the filename of a version of the file allows the version relationship between the file and each version of the file to be easily identified. No separate record need be kept to maintain this relationship as it is inherent in the filenames. The data indicating that the new version of the file is a version of the file allows different versions of the file to be easily distinguished as well as to distinguish the versions of the file from the file itself.

Additionally in one or more embodiments the versions of a file are stored in a known location by file system as directed by versioning module . Versioning module uses particular criteria or rules to determine where this location is. In one or more embodiments this known location is a sub directory of the directory in which the file is stored this sub directory having a known name such as versions . In other embodiments this known location is elsewhere such as in the same directory as the directory in which the file is stored some other directory or location and so forth. These locations however are only examples the application managed file versioning discussed herein is not limited to these example locations and other locations can alternatively be used.

The following illustrates an example standardized format for the version filenames. It is to be appreciated that this is an example standardized format the application managed file versioning discussed herein is not limited to this example format and other formats can alternatively be used. In one or more embodiments the standardized format for the version filenames of a file named . is 

Following this format for version filenames the portion of the version filename corresponds to the of the name of the file for which the version is created and the portion of the version filename corresponds to the of the name of the file for which the version is created.

The portion identifies a date and time at which the version of the file is created. In one or more embodiments the portion is based on Greenwich Mean Time GMT and an indication of such is included in the filename or alternatively can be assumed . In one or more embodiments the portion is based on the Gregorian calendar and can have a variety of different formats such as 

The portion is one or more characters used to associate specific information with this version. Which particular flag if any is to be set is indicated by the application requesting creation of the new version. In one or more embodiments a flag character of p is used to indicate that a particular version is flagged as pinned and a default character e.g. n is used to indicated there is no flag for this version. A version flagged as pinned indicates to the user and or versioning module that the version is of particular importance and can be treated differently by the versioning module as discussed in more detail below. For example an original digital picture stored by the application can be flagged as pinned allowing that original digital picture to be readily identified separately from other versions of the file.

A variety of other flags can also be used. For example an auto versioning flag can be used to indicate that the versioning module is to perform auto versioning as well as the application managed file versioning discussed herein. With auto versioning the versioning module automatically generates versions of the file at particular intervals e.g. every fifteen minutes hourly daily etc. in addition to versions created in response to application requests.

The portion is optional. When included the portion includes one or more characters that tag this version with specific information. Certain characters can be restricted from use such as the hyphen the dot . the other characters that are not legal in a file name and so forth. In one or more embodiments the default value of is an empty string indicating that there is no tag for this version.

The tag portion allows the application requesting creation of the new version of the file or a user of that application to provide metadata regarding the file version. Various different metadata can be included such as version 1 final version ready for review Matts comments and so forth. The particular data to be included in the tag portion if any is indicated by the application requesting creation of the new version.

The following are example formats of the version filenames. However it is to be appreciated that these are only examples the application managed file versioning discussed herein is not limited to these specific formats and any of a variety of other formats can alternatively be used. For example a version of foo.doc taken at Jul. 5 2007 at 14 55 GMT and flagged as pinned and with a tag of Matts Comments could be 

A version of foo.doc taken at Jul. 5 2007 at 14 55 GMT without a flag and with a tag of Matts Comments could be 

Alternatively using other formats a version of foo.doc taken at Jul. 5 2007 at 14 55 GMT without a flag and with a tag of Matts Comments could be one of the following 

Returning to the designer of an application is typically most knowledgeable about what makes sense or is logical in determining when to create a new version of a file and thus the designer of the application and thus the application is typically in a better position to determine when to create a new version of a file than versioning module is. Accordingly an application determines when a new version of a file is to be created in response to particular application specific events.

The application can employ a variety of different criteria in determining when a new version of a file is to be created in response to particular application specific events and different applications can employ different criteria. Examples of events for which an application can determine to create a new version include opening a file receiving a user request that a file be saved ending of an editing session making of a significant change to a file e.g. deleting a paragraph deleting a worksheet or page cropping an image performing red eye correction performed on a digital image etc. and so forth. In response to one of these events occurring the application automatically determines that a new version of the file is to be saved no manual input from a user of the application need be received in order for the new version of the file to be saved. Additionally in one or more embodiments the application specific event can be a manual event triggered by a user such as a user request to create a new version of a file.

In one or more embodiments each application is expected to have a limit on a number of versions e.g. 5 versions 20 versions etc. it will maintain for each file. In such embodiments each application is expected to delete versions as appropriate when new versions are created so that this limit is not exceeded. In response to a request received from an application to create a new version of a file versioning module can optionally return an indication that the limit has been exceeded and that the application is to delete one or more versions of the file. The application can request that versioning module delete one or more versions in a variety of different manners such as by invoking one or more of APIs . In one or more embodiments versioning module can refuse to create the new version of the file until one or more versions of the file have been deleted.

However in one or more embodiments situations can arise where this limit is not maintained by each application . In such situations versioning module can optionally employ an automated clean up process to delete versions of the file so that the limit is not exceeded. Versioning module can use various criteria to determine which versions to delete such as deleting the oldest versions first not deleting versions that are flagged as pinned and so forth.

Versioning module can also employ such an automated clean up process to delete file versions in different situations. For example situations can arise where the original file corresponding to the file versions has been deleted or moved but the file versions remain. In such situations these remaining file versions can be deleted by the automated clean up process optionally only if the remaining file versions are not flagged as pinned . By way of another example one or more versions could be deleted as part of a disk clean up process to increase the usable storage space on a storage device. In such situations the user could be given an option to clean up versions in order to recover storage space on the storage device.

Additionally situations can arise where a user decides to delete one or more versions. This can be performed manually by the user such as the user navigating to the folder in which the versions are stored and selecting a delete option. This can also be automated for the user such as an application providing a user interface via which the user can select to delete one or more versions of a file. In one or more embodiments constraints can be placed on the deletion of certain versions such as those flagged as pinned in which case versioning module does not delete such versions displays a warning to the user about deletion of the version and so forth.

In one or more embodiments a user interface is presented to the user giving the user access to the versions. The user interface allows versions to be deleted as discussed above. Additionally the user interface can allow the user to perform other actions such as open previous versions of a file restore a particular file to a previous version of the file copy versions of a file to another storage device and so forth. This user interface can be presented in different manners. For example the user interface can be part of a normal shell or file navigation user interface via a previous versions window or tab that can be displayed when a file or version of a file is selected by the user via an interface of an application and so forth.

The user interface can also display versions of files generated in different manners. File versions can also be generated in different manners such as using any of a variety of different legacy techniques such as shadow copy techniques supported by some operating systems that create versions of files at particular intervals e.g. daily . Such shadow copy versions can coexist with the application managed file versions created using the techniques discussed herein. In embodiments where multiple file versioning techniques are employed the user interface can give the user access to the versions generated by the various different techniques employed.

Additionally situations can arise where a file having one or more file versions is also pointed to by a symbolic link and or a hard link. Both symbolic and hard links are mechanisms for pointing to files but are typically treated differently by file system . For example a symbolic link to a file points to that file but allows that file to be accessed only so long as the file is not deleted or moved. A hard link to a file however points to that file and allows that file to continue to be accessed until the hard link is deleted even if the pointed to file is deleted or moved the file can still be accessed via the hard link . In one or more embodiments file system allows both symbolic links and hard links to file versions to be created.

In response to determining that a new version of the file is to be saved a request to save a new version of the file is sent to the versioning module act . As discussed above this sending of the request can be invoking of an API exposed by the versioning module or alternatively other request mechanisms. The application can include as part of this request various information such as metadata e.g. for a tag portion of the filename flags to be included in the filename and so forth.

The versioning module receives the request to save a new version of the file act . In response to this received request the versioning module generates a filename for the new version of the file act . As discussed above this generated filename conforms to a particular format including two or more portions. The new version of the file is then saved with the filename generated in act in a known location act . This saving is performed for example by the versioning module directing a file system to store the new version of the file with the filename generated in act in the known location. As discussed this known location can vary by implementation and can be determined using various criteria or rules.

Computing device includes one or more processors or processing units one or more computer readable media which can include one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Computer readable media and or I O device s can be included as part of or alternatively may be coupled to computing device . Bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port a processor or local bus and so forth using a variety of different bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

The techniques discussed herein can be implemented in software with instructions being executed by processing unit s . It is to be appreciated that different instructions can be stored in different components of computing device such as in a processing unit in various cache memories of a processing unit in other cache memories of device not shown on other computer readable media and so forth. Additionally it is to be appreciated that the location where instructions are stored in computing device can change over time.

One or more input output devices allow a user to enter commands and information to computing device and also allows information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Generally any of the functions or techniques described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module functionality and logic as used herein generally represent software firmware hardware or combinations thereof. In the case of a software implementation the module functionality or logic represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices further description of which may be found with reference to . The features of the application managed file versioning techniques described herein are platform independent meaning that the techniques can be implemented on a variety of commercial computing platforms having a variety of processors.

As discussed above one or more APIs can be exposed by the versioning module to carry out the application managed file versioning techniques discussed herein such as APIs of . The following are examples of APIs that can be exposed by the versioning module. In one or more embodiments these example APIs are used with one or more of the family of Windows operating systems available from Microsoft Corporation of Redmond Wash. It is to be appreciated that these are only examples and that other APIs could be used and or functionality exposed in different manners.

Creation of a new version of a file is supported through two APIs the ReplaceFile API and the SaveFileVersion API.

The ReplaceFile API is used by applications for safe save . The ReplaceFile API allows replacing one file with another file with the option of creating a backup copy of the original file. The replacement file assumes the name of the replaced file and its identity.

 in The name of the file that will serve as a backup copy of the lpReplacedFileName file. If this parameter is NULL no backup file is created.

The replacement options. Besides the existing options the new option that triggers file version creation is REPLACEFILE SAVE VERSION which informs this API to create a file version based on the current time stamp before the lpRelacedFileName file is replaced. In one or more implementations this flag cannot be specified if the lpBackupFileName parameter is not NULL.

When REPLACEFILE SAVE VERSION is specified in dwReplaceFlags this parameter supports an optional pointer to the REPLACEFILE PARAMS structure.

 in A tag string for the version. In one or more implementations the tag string is defined as discussed above with reference to the tag portion. It cannot contain characters that are not legal in a filename. If the version is not tagged then this parameter is 0 .

dwVersionFlags may be a combination of the valid flags but note FILE VERSION FLAG NONE are mutually exclusive with other flags.

 out A pointer to a buffer that receives the name of the file version that is to be created. This parameter is optional and may be NULL.

 inout The size of the lpFileVersionName buffer in characters. If the lpFileVersionName parameter is NULL then this parameter is set to 0. If the size is not large enough to receive the name of the generated file version this size parameter will be used to return the minimum required size in characters.

To save a version the caller of ReplaceFile will call the ReplaceFile API with the REPLACEFILE SAVE VERSION flag set. If the caller wants to tag that version then the caller will specify the tag in the lpVersionTag parameter in the REPLACEFILE PARAMS. The API when invoked with the REPLACEFILE SAVE VERSION flag set will fail if a version cannot be created for some reason. If the number of versions for the file exceeds the number of versions allowed for a file then the API will fail with an error code ERROR VERSION LIMIT EXCEED to indicate this condition. If the caller does not need to specify a parameter defined in REPLACEFILE PARAMS then the lpReserved parameter can be NULL. The lpFileVersionName parameter in REPLACEFILE PARAMS returns the name of the version created by this API. The caller can use this name to do further processing on the newly created version.

The SaveFileVersion API supports creation of a version by applications that do not use ReplaceFile for safe save . The SaveFileVersion API is defined as follows 

dwVersionFlags may be a combination of the valid flags but note FILE VERSION FLAG NONE are mutually exclusive with other flags.

 in A tag string of the version. If the version is not to be tagged then this parameter is set to 0 or NULL.

 in The name of the file to be used as a version for lpFileName. This parameter is optional and can be NULL.

 out A pointer to a buffer that receives the name of the file version that is to be created. This parameter is optional may be NULL.

 in When it is not NULL it is a pointer to the length of the lpFileVersionNameBuffer in characters. In output it is used to return the number of characters that is copied to the lpFileVersionNameBuffer.

If the lpFileVersionNameBuffer parameter is present lpFileVersionNameLength is not NULL lpFileVersionNameLength is greater than 0. If the lpFileVersionNameBuffer parameter is NULL and lpFileVersionNameLength is not NULL or if the lpFileVersionNameBuffer parameter is present and its buffer length by lpFileVersionNameLength is not large enough this API will set the last error ERROR INSUFFICIENT BUFFER and use the lpFileVersionNameLength to return the required buffer length in the number of characters including the terminating null .

Using the SaveFileVersion API if the caller wants to tag a version then the caller will specify the flag and or tag in the dwVersionFlags and or lpVersionTag parameter. If the number of versions for the file exceeds the number of versions allowed for a file then the API will fail with an error code ERROR VERSION LIMIT EXCEED to indicate this condition. If lpFileNameToSaveAsVersion is not NULL then the temp file specified by lpFileNameToSaveAsVersion will be used as a version of the file specified by lpFileName. The temp file is expected to be identical to the file that would be passed to the ReplaceFile API. The SaveFileVersion API will take care of propagating properties from lpFileName to lpFileNameToSaveAsVersion. If lpFileNameToSaveAsVersion is NULL then the API will create a copy of the file specified by lpFileName as a version of lpFileName. The lpFileVersionNameBuffer parameter returns the name of the version created by this API. The caller can use this name to do further processing on the newly created version.

The PurgeFileVersions API purges deletes versions of the file. PurgeFileVersions The API is defined as follows 

 in The name of the file whose versions are to be deleted. It can be a file name or a name with wild cards.

 in The purge options to specify whether to purge versions that are tagged as important non important or some combination.

If dwVersionFlagsToPurge 0 this parameter will be ignored. It indicates that matching versions with without a flag are to be purged 

dwVersionFlagsToPurge may be a combinations of the valid flags. Note that for this API FILE VERSION FLAG NONE and FILE VERSION FLAG PINNED can co exist to indicate to purge versions with pinned flag and without a flag.

 in The list of tags to operate on. Each element of the array specifies one tag in this list of tags. Versions that are tagged with the tags listed in this array are included in the list of candidate versions to purge. 0 is also a valid tag to purge. It indicates to purge versions without a tag. 0 can coexist with other tag strings in the list. If the lpTagsToPurge parameter is NULL then the purge operation will apply to versions irrespective of their version tag. Note wildcards are not supported in the tag string.

 in The number of tags in the lpVersionTagsToPurge array. This parameter is ignored if lpTagsToPurge is NULL.

Using the PurgeFileVersions API the dwNumberOfVersionsToKeep determines the number of versions that will be retained as follows 

The lpVersionTimeToKeep determines the oldest version that will be retained based on the time the version was taken. Versions taken before the time represented by lpVersionTimeToKeep will be deleted. If this parameter is NULL then it will be ignored. The candidates of the versions of the file preserved is a union of the criteria specified by dwNumberOfVersionsToKeep and lpVersionTimeToKeep. The list of flags tags to operate on specified by dwVersionsToPurge and lpVersionTagsToPurge determines the versions this purge operation applies to. lpFileName is the full path to the file whose versions are to be deleted.

The CheckIsFileVersionName API returns if the specified file name is a version of a file. This allows an application to identify versions of files when it enumerates a directory. The CheckIsFileVersionName API is defined as follows 

 out This parameter is optional. It receives the version s base name flag tag information. The structure of the returned information is defined as

If the CheckIsFileVersionName API returns TRUE then lpVersionFileName is a name of a version of a file. In this case if lpVersionInfo is supplied then cFileBaseName will return the name of the file whose version is represented by lpVersionFileName ftVersionTime will return the time that this version was taken and dwVersionFlags and dwVersionTagOffset will return additional flag tag information about the version. This API is based on the supplied name and does not check to see if the file or the version actually exists on the volume.

These APIs allow an application to enumerate or list versions of files in a directory and include a FindFirstFileVersion API a FindNextFileVersion API a FindFileVersionDirecotry API and a FindFileVersionClose API. These APIs are defined as follows 

 in The name of the file whose versions is to be enumerated. The final component of the name can contain supported wild cards such as and .

 in The flags to be enumerated. If dwVersionFlagsToFind 0 this parameter will be ignored. If it is FILE VERSION FLAG NONE versions without a flag are to be returned. If it is FILE VERSION FLAG PINNED versions with the pinned flag are to be returned. It may be a combination of all the valid flags. FILE VERSION FLAG NONE can coexist with other valid flags.

 in This parameter specifies the tags array whose versions are to be enumerated. It is optional. If it is NULL all versions are to be returned. If it is not NULL only the file versions with the matching tags are to be returned. 0 is used to represent the absence of a tag. Note the tags containing wildcards are not supported. A tag string with wildcards indicates that file versions with the matched tag are to be returned.

 in The number of tags in the lpVersionTagsToFind array. This parameter is ignored if lpFindTags array is NULL.

 out A pointer to the WIN32 FIND DATA structure that receives information about a found version where WIN32 FIND DATA is a well known data structure that is defined for the existing Win32 FindFirstFile and FindNextFile APIs additional information regarding the WIN32 FIND DATA structure is available from Microsoft Corporation .

If the FindFirstFileVersion function succeeds the return value is a search handle used in a subsequent call to FindNextFileVersion or FindFileVersionClose. If the function fails the return value is INVALID HANDLE VALUE.

 out A pointer to the WIN32 FIND DATA structure that receives information about the found file version.

If the return value is less than cchBuffer then the return value is the length of the string copied to the lpBuffer in characters not including the terminating null character. If the return value is greater than cchBuffer the return value is the length of the required buffer to hold the parameter.

The FindFileVersionDirectory API will be called after the caller calls FindFirstFileVersion. The FindFileVersionDirectory API will return the directory in which the File Version is located.

The TagFileVersion API support tagging and untagging of existing file versions. The TagFileVersion API is defined as follows 

 in The new flags for the version name. If there is already at least one flag in the version name the new flags will overwrite it. To remove existing flags FILE VERSION FLAG NONE is specified. If it is 0 this parameter will be ignored.

 in The new tag for the version name. If there is already a tag as specified by lpFileVersionName the new tag will overwrite it. To remove an existing tag the tag is set to 0 . If it is NULL this parameter will be ignored.

These APIs allow legacy techniques in this example shadow copy versions supported by previous operating systems to be incorporated with the application managed file versioning discussed herein. These APIs include a PverQueryPreviousVersions API a PverCheckPreviousVersionAvailable API and a PverGetVersionInformationFromPath API. These APIs are defined as follows 

 in This parameter is the file path whose previous versions are to be queried. This path name can be a local path name a remote full path name with a mapped drive letter a UNC Universal Naming Convention path name or a relative path name either local or remote.

 out This parameter returns a pointer to the query result data. The buffer is allocated by this API. It is the caller s responsibility to free the data using PverFreeBuffer.

The PverQueryPreviousVersions API integrates the shadow copy previous version enumeration and file version enumeration altogether into a unified list. The PverQueryPreviousVersions API will return a subset of the list based on the user specified options.

The PverCheckPreviousVersionAvailable API returns if a previous version is available for the file. The PverCheckPreviousVersionAvailable API is defined as follows 

 in This parameter is the file path name to be checked for the availability of its previous versions. This path name can be local full path name a remote full path name with a mapped drive letter a UNC path name or a relative path name either local or remote.

 in This parameter is the version types to be checked. The valid flags are VERSION FILE VERSIONS and VERSION SHADOWCOPY VERSIONS. The two flags can co exist. At least one of the two flags is specified otherwise the API will fail with ERROR INVALID PARAMETER.

 out This parameter returns TRUE if the versions are available for the lpFilePath and FALSE otherwise.

The PverGetVersionInformationFromPath API parses the version file path name and returns more information about the version. The PverGetVersionInformationFromPath API is defined as follows 

 in This parameter specifies a file path name to be checked for the version information. For a shadow copy version path name the path may need to be a full path. For a file version path name full path and relative path are both valid.

 out opt this parameter returns the version creation time. For the shadow copy versions this is the shadow copy creation time For the file versions this is the time stamp that the file version is saved.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

