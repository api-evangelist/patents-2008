---

title: Collocation in a Java virtual machine of JSLEE and Java EE
abstract: In one embodiment, a mechanism for collocation in a JAVA Virtual Machine of Java™ APIs for Intelligent Networks Service Logic Execution Environment (JSLEE) and Java™ Enterprise Edition (J2EE) is disclosed. In one embodiment, a system includes an integrated application server including JSLEE and J2EE, one or more resource adapters communicably coupled to the integrated application server, and one or more management interfaces communicably coupled to the integrated application server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924988&OS=08924988&RS=08924988
owner: Red Hat, Inc.
number: 08924988
owner_city: Raleigh
owner_country: US
publication_date: 20080530
---
The embodiments of the invention relate generally to communication platforms and more specifically relate to a mechanism for collocation in a Java virtual machine of JSLEE and Java EE.

Voice over Internet Protocol VoIP has seen a rise in popularity in recent times and has become more than just a telephony application. For instance several highly popular applications have come into existence like Skype Google Talk and MSN Messenger . All of these applications combine voice instant messaging IM and other modes of communication into unified clients and greatly enhance the user experience. Previously these means to communicate were islands largely isolated from each other. However engineers visited them and found large areas of community between these different modes of communication resulting in integrated clients that have changed the way in which communication and business is conducted.

For integrated communication applications such as those described above server support needs to be provided. An examination of the structure of such applications indicates that there are two parts to the application the signaling part and the media part. The signaling part is an event oriented activity. Network endpoints exchange one way messages through various servers and signal the establishment of a session. Interesting services can be built by placing fragments of code or event handlers in the signaling path at the server. Furthermore service providers may speed up their innovation processes and quickly launch new services if they use a standards based component model and container architecture.

One standards based application execution framework is JAIN SLEE or JSLEE. JAIN is an acronym for Java APIs for Intelligent Networks. JAIN aims for an enabling set of Java APIs to develop and deploy service driven network applications. SLEE is an acronym for service logic execution environment. Together JAIN SLEE is an application execution framework analogous to the Java Enterprise Edition J2EE environment. However in comparison to J2EE JSLEE s design principles explicitly aim for a low latency 

JSLEE addresses unique requirements for performance and availability in communications applications that are not addressed by the execution environment of J2EE. One present issue with JSLEE is that although it can interface with other application servers this interfacing does not provide the same level of availability performance security and scalability as the J2EE environment does. As a result a way to integrate the robust component model and scalability characteristics designed for high volume low latency signaling of JSLEE with the established and well known modular architecture of J2EE in a single Java virtual machine would be beneficial.

Embodiments of the invention provide for collocation in a Java virtual machine of JSLEE and J2EE. In one embodiment a system for collocation in a Java virtual machine of JSLEE and J2EE includes an integrated application server including JSLEE and J2EE one or more resource adapters communicably coupled to the integrated application server and one or more management interfaces communicably coupled to the integrated application server.

In the following description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as sending receiving attaching forwarding caching or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The present invention may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

Embodiments of the invention provide for collocation in a Java virtual machine JVM of JSLEE and Java EE J2EE . is a block diagram of a communications platform according to an embodiment of the invention. In one embodiment communications platform is a single JVM. A JVM is a set of computer software programs and data structures that use a virtual machine model for the execution of other computer programs and servers. Communications platform enables the creation deployment and management of services and applications that integrate voice video and data. It also functions seamlessly across a range of Internet Protocol IP and communications networks and can be accessed by computers handsets and other network enabled devices.

Communications platform includes an integrated JSLEE and J2EE application server external resources and management interfaces . The integrated JSLEE and J2EE application server combines JSLEE with J2EE to enable the development deployment and management of applications that integrated of voice video and data across a range of networks and devices. JSLEE enables web applications to interface with communications networks and devices. JSLEE is the J2EE for communications as it is event driven high throughput and low latency.

The integrated JSLEE and J2EE application server is a single integrated stack with JSLEE and J2EE running in the same JVM. In one embodiment this integrated application server provides high availability HA features such as JBoss Cache JGroups support for mid call failover and support for between call failover. The integrated application server may also provide high performance characteristics such as for example 250 calls per second on 3 GHz Xeon 4GB RAM or 400 calls per second on 4CPU server. The integrated application server further provides scalability via a flexible architecture for multiple topologies data center scalability with local network protocol load balancing and geographic scalability via DNS load balancing. The integrated application server of embodiments of the invention additionally provides development benefits such as not limiting users to an exclusive choice of J2EE OR JSLEE a continuous step through debugging experience a common microkernel architecture e.g. JBossMX and shared container building blocks e.g. Java Naming and Directory Interface JNDI Java Management Extensions JMX Java Transaction API JTA Web Services Aspect Oriented Programming AOP etc .

In one embodiment external resources provide a network abstraction layer for the communications platform . The network abstraction layer provides connectivity between applications of the communications platform and any network environment including an IP network or a Legacy network. In this way application logic is network protocol agnostic so that the application developer is insulated from the underlying network protocol and thereby simplifies porting between networks. The network abstraction is achieved by the external resources via Resource Adapters RAs . For example RAs may include but are not limited to Session Initiation Protocol SIP Extensivle Messaging and Presence Protocol XMPP Google Talk Asterisk Parlay Diameter Media Real Time Transport Protocol RTP Short Message Peer to Peer Protocol SMPP Intelligent Network Application Part INAP HyperText Transport Protocol HTTP and Production Rules.

In one embodiment management interfaces provide third party application programming interfaces APIs . These third party APIs simplify integrating with core business systems. For example some of the management functions provides by management interfaces may include but are not limited to full visibility for monitoring and management via JMX internal system APIs Event Router Activities Time Facility RA APIs and application APIs service usage service building blocks usage event traffic control . Third party APIs also provide Operational Business Support Systems OSS BSS connectivity. For example this may include remote J2EE connectivity via a JCA SleeConnection ability to expose JSLEE services as Web Services and AAA RAs e.g. Diameter Ro and Sh for authentication authorization and billing .

To better understand the JSLEE and J2EE application server component of communications platform a closer look at the building blocks for JSLEE is helpful. is a block diagram illustrating a JSLEE architecture according to an embodiment of the invention. The JSLEE architecture consists of four main areas management framework resource adaptors RAs and the component model .

In one embodiment the management entities allow the whole JSLEE environment to be managed through Java Management Extensions JMX MBeans. The various entities in the framework support the business logic implemented in distributed components the service building blocks SBBs . Within the framework the trace entity allows a centralized and single point for logging the alarm entity informs external management systems the timer entity invokes components in pre defined intervals and the profile entity provides the business logic with information and data during execution. The event router of the framework routes incoming and newly created events to previously registered SBBs and resources. The event router is more or less the heart of JSLEE s event routing system.

Resource adaptors bridge the component model and the underlying event infrastructure. An event source from the event infrastructure could be anything emitting events implemented in any language or environment. The resource adaptor converts incoming protocols and network specific events into generic semantically equivalent JAVA events and fires them into the JSLEE application server for further processing. As a result the application and the source of events are logically decoupled so that applications may execute on any network.

The component model defines how components interact with each other and with the environment the bundling of services and their deployment. The JSLEE environment invokes SBBs according to a standardized lifecycle model for SBBs comparable to an Enterprise JAVA Bean s EJB s lifecycle. The runtime environment secures and manages event processing and framework invocation with transactions. Doing so the JSLEE application server remains in a defined and consistent state even in case of failure.

A service is essentially a management artifact in JSLEE and is bundled as a jar file. A JSLEE container may simultaneously house several services. Each service is a logical grouping of functionality and consists of several SBBs . Among them there is a distinguished SBB called the root SBB not shown that is automatically instantiated by the JSLEE container. If appropriate this root SBB instantiates child SBBs and routes events to these children.

In one embodiment incoming events emitted by external sources reach the JSLEE application server through resource adaptors which in turn fire Java events towards the event router . The event router routes these events to SBBs following predefined prioritizations. Related events are clustered as activities. Events of one activity share a common state the activity context. For example one activity may be a phone call with the sequenced events CALL SETUP CALL ESTABLISHED and CALL TERMINATED.

Another way to describe the event processing of follows. In one embodiment the JSLEE follows a typed event model. Each RA may be thought of as an event source that produces a stream of typed events and each SBB is an event sink that consumes the stream of typed events. For example an event XXX is consumed by a container invoking a user written on XXX method with the appropriate signature on the SBB. SBBs may also fire events on activity contexts. In concrete terms a RA is a wrapper around a protocol stack e.g. the SIP stack . Its job is to react to incoming messages and generate a typed stream of events that it feeds to the event router. The event router in turn starts appropriate transactions possibly creating root SBBs of service instances and routing events to such SBBs.

Initially the JSLEE instantiates services in the following manner 1 An event for example an incoming SIP message arrives on an activity and is fielded by the container via a resource adaptor. 2 The JSLEE container creates an activity context for the activity if needed. 3 The container searches through the installed services to discover if there is one or more services that are interested in the incoming event.

This works by each active installed service advertising a convergence name which is consulted for a match. If a match is found the container automatically creates the root SBB of the service if not already instantiated attaches the root SBB to the activity context and routes the event to the root SBB via the activity context.

The JSLEE execution model defines transactional boundaries for SLEE originated invocation sequences. As in EJB terminology a transaction is an atomic resilient unit of work. However unlike EJBs transaction boundaries are not directly visible. Transactions are started by the system at the beginning of JSLEE originated sequences and committed at the end of such sequences. Application errors and exception conditions result in the rollback of the enclosing transaction. Concurrently executing SBBs have a serializable view of the world and are isolated from each other. That is the final outcome of concurrent execution is some serial ordering of the execution sequences.

The JSLEE does not mandate a specific implementation of the concurrency model. In one embodiment pessimistic concurrency control may be implemented. In this implementation a thread pool is used and assigned an executor per activity context. This is a reasonable choice because an activity context is an event bus and events on that bus should be consumed in FIFO order.

The JSLEE derives some of its efficiency by relaxing disk persistence requirements. Very few data structures need to survive a full JSLEE restart. Most sensitive structures can simply be replicated across the cluster rather than persisted to disk. In one embodiment JBoss Cache technology may be used to achieve this. JBoss Cache is tightly coupled with the JBoss Transaction Manager and provides in memory replication services across the cluster. Structures in the implementation that need to be replicated by placing them in the cache include activity contexts SBB entities and service instances. However in general there is no need to replicate the event queue. The final point is a subtle one that works under the assumption that the endpoint will retransmit the message.

In light of the above description of the JSLEE environment the following description provides explanation of integrating this JSLEE environment with J2EE according to embodiments of the invention. is a block diagram depicting a communications platform that integrates JSLEE as an extension of J2EE according to an embodiment of the invention. As illustrated the hierarchy of components supporting the integrated JSLEE and J2EE components include a JSLEE network abstraction component third party services an operating system and third party industry standard hardware . There are also JSLEE APIs to interface with other outside applications. In one embodiment the J2EE component may be a JBoss application server distributed by Red Hat Inc. of Raleigh N.C. In another embodiment the operating system may be Red Hat Enterprise Linux system.

It should be noted that JSLEE is not a J2EE specification. However it utilizes many J2EE components like JMX and Transactions. J2EE is an application building platform that provides many facilities that JSLEE uses. For example some useful J2EE services and tools may include but are not limited to JBoss cache JMX Java Naming and Directory Interface JNDI JavaAssist and JBoss clustering.

The use of the modular J2EE architecture with JSLEE results in a simple and cleanly separable architecture for the implementation of embodiments of the invention. Each management interface mandated by the JSLEE is installed as a logically separate microkernel service of the J2EE. The J2EE microkernel architecture allows JSLEE to work with a minimal set of installed J2EE services thus making for an integrated extensible and modular architecture. In particular embodiments of the invention provide for the integrated JSLEE and J2EE environment with communication between the J2EE components such as HTTP Servlets and EJBs and JSLEE components such as SBBs via local in VM passes by reference semantics.

The J2EE microkernel architecture is a natural fit for building that JSLEE. In one embodiment the JSLEE specification is a service in the JMX microkernel of J2EE. JMX is a Java technology that supplies tools for managing and monitoring applications system objects devices e.g. printers and service oriented networks. Those resources are represented by objects called MBeans for Managed Bean . In other embodiments other similar frameworks may be utilized for the microkernel architecture of J2EE including Open Service Gateway initiative OSGi for example.

With regard to the JMX agent of and its associated MBean objects is a block diagram providing a JMX Agent View of all the JSLEE services and a JMX MBean view according to an embodiment of the invention.

Method begins at block where a JSLEE specification is provided as a service in a JMX kernel of a J2EE implementation to create an integrated JSLEE and J2EE application server. Then at block external RAs are associated with the integrated application server to provide interaction capabilities and services to one or more telecommunications protocols. Lastly at block management interfaces are associated with the integrated application server to interface with core business systems to provide for monitoring and management services of activities of the telecommunications protocols.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored one or more set of instructions e.g. software embodying any one or more of the methodologies of functions described herein. The software may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media. The software may further be transmitted or received over a network via the network interface device .

The machine readable storage medium may also be used to implement embodiments of communications platform described with respect to and or a software library containing methods that call the above applications. While the machine accessible storage medium is shown in an exemplary embodiment to be a single medium the term machine accessible storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine accessible storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine accessible storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as the invention.

