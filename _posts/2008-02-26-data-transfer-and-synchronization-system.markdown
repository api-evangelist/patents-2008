---

title: Data transfer and synchronization system
abstract: A data transmission system is disclosed which optimizes transfer and updates of information between systems by providing difference information between the systems. The system transmits data packages having instructions for manipulating user data. The data packages include a header identifying the respective packages, as well as transaction objects for effecting a change to user data on a device having object instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08315976&OS=08315976&RS=08315976
owner: Synchronoss Technologies, Inc.
number: 08315976
owner_city: Bridgewater
owner_country: US
publication_date: 20080226
---
This application is a divisional application of U.S. patent application Ser. No. 10 976 584 filed on Oct. 28 2004 entitled Data Transfer And Synchronization System which is a continuation of U.S. patent application Ser. No. 09 491 675 filed on Jan. 26 2000 entitled Data Transfer And Synchronization System which applications are incorporated herein by reference.

A portion of the disclosure of this patent document contains material to which the claim of copyright protection is made. The copyright owner has no objection to the facsimile reproduction by any person of the patent document or the patent disclosure as it appears in the U.S. Patent and Trademark Office file or records but reserves all other rights whatsoever.

The invention relates to the transference of data between two systems independent of the form in which the data is kept on the respective systems and in particular to providing an efficient means of communicating data between systems and devices.

The growth of computing related devices has not been limited to personal computers or work stations. The number of personal computing devices has grown substantially in both type and format. Small hand held computers carry a multitude of contact personal document and other information and are sophisticated enough to allow a user to fax send e mails and communicate in other ways wirelessly. Even advanced cellular phones carry enough memory and processing power to store contact information surf the web and provide text messaging. Along with the growth in the sophistication of these devices the need to transfer information between them has grown significantly as well.

With a multitude of different device types on the market keeping information between the different devices synchronized has become increasingly problematic. For example if an individual keeps a calendar of information on a personal computer in his or her office using a particular personal information manager application the individual would generally like to have the same information available in a cellular phone hand held organizer and perhaps a home personal computer. The individual may additionally have a notebook computer which requires synchronizing file data such as presentations or working documents between the notebook and the office computer.

Until now synchronization between both documents and personal information managers has occurred through direct connection between the devices and generally directly between applications such as a personal information manager in one device and a personal information manager in another device or using an intermediary sync mapping program.

One example of this is the prevalent use of the 3Com Palm OS based organizer such as the 3Com Palm series of computing devices which uses its own calendaring system yet lets users synchronize the data therein with a variety of different personal information manager software packages such as Symantec s ACT Microsoft s Outlook and other systems. In this example an intermediary synchronization program such as Puma Technology Inc. s Intellisync is required. Intellisync is an application program which runs on both the hand held device and the computer which stores the information data and maps data systems between non uniform data records. In other cases direct transfer between applications such as transfer between Microsoft s Outlook computer based client and Microsoft s Windows CE Pocket Outlook application is possible. Nevertheless in both cases synchronization occurs through direct connection between a personal computer and the personal computing device. While this connection is generally via a cable directly connecting for example Palm device in a cradle to the personal computer the connection may be wireless as well.

One component of these synchronization systems is that the synchronization process must be able to delineate between when changes are made to specific databases and must make a decision about whether to replace the changed field. Normally this is measured by a change in one database and no change in a second database. In some cases both databases will have changed between syncs. In this case the sync operation must determine which of the two changes which has been made is to win and replace the other during the sync. Generally this determinant of whether a conflict exists allows some means for letting the user resolve the conflict.

In a technical sense synchronization in this manner is generally accomplished by the copying of full records between systems. At some level a user is generally required to map data fields from one application to another and specify which data fields are assigned to which corresponding field in a different device. Less mapping is required where developers more robustly support various platforms of applications.

In many instances the data to be synchronized is generally in the form of text data such as records of addresses contact information calendar information notes and other types of contact information. In certain instances data to be synchronized will be binary format of executable files or word processor specific documents. In many cases where document synchronization is required the synchronization routine simply determines whether or not the documents in question have changed and uses a time based representation to determine which of the two files is newer and replaces the older file with the newer file to achieve synchronization as long as the older of the two files was in fact not changed. This is the model used in the familiar Briefcase function in Microsoft Windows based systems. If both files have changed then the synchronization routine presents the option of conflict resolution to the user.

Such synchronization schemes are generally relatively inefficient since they require full band width of the document or binary file to be transferred via the synchronization link. In addition at some level the synchronization programs require interaction by the user to map certain fields between different programs.

One of the difficulties in providing synchronization between different computing devices is that the applications and platforms are somewhat diverse.

Nevertheless all synchronization programs generally require certain functions in order to be viable for widespread usage. In particular synchronization programs must work with popular applications on various platforms. Sync applications must allow for conflicts resolution when changes are made to the same information on different devices between syncing events. They must provide synchronization for all types of formats of data whether it be text data in the form of contacts e mails calendar information memos or other documents or binary data in the form of documents or programs in particular types of formats.

In a broader sense applications which efficiently synchronize data between disparate types of devices can provide advantages in applications beyond synchronizing individual personal information between for example a personal information manager hardware device such as a Palm computing device and a personal computer. The same objectives which are prevalent in developing data transfer between personal information management PIM devices and desktop systems lend themselves to furthering applications requiring data transfer between other types of devices on differing platforms. These objectives include speed low bandwidth accuracy and platform independence.

For example current e mail systems use a system which is somewhat akin to the synchronization methods used for disparate devices in that an entire message or file is transferred as a whole between different systems. When a user replies to an e mail generally the entire text of the original message is returned to the sender who now has two copies of the e mail text he she originally sent out. The same is true if an e mail attachment is modified and returned. All of the text which is the same between both systems is essentially duplicated on the originator s system.

The invention comprises a data transmission system which optimizes transfer and updates of information between systems by providing difference information between the systems. Information transfer can occur one way broadcast or two way sync .

The invention roughly described comprises a data transmission system. In a first aspect the system includes a differencing transmitter transmitting at least one set of difference transactions and a differencing receiver receiving said at least one set of difference transactions. The differencing transmitter of the data transmission system may comprise a difference source interface a copy of a previous state of said difference source and a difference transaction generator. The differencing receiver of the data transmission system comprises a difference destination interface a copy of a previous state of said difference destination and a destination data constructor. The difference source interface converts difference source data to a universal format. The differencing transmitter and differencing receiver may be coupled to a storage server and said difference information is transmitted to said storage server by said differencing transmitter and retrieved from said storage server by said differencing receiver. The data transmission system further includes a management server communicating with said differencing transmitter and said differencing receiver.

In a further embodiment the data transmission system is coupled to a network. The system includes a differencing transmitter the transmitting at least one set of change transactions reflecting changes to a data source to the network and a plurality of differencing receivers coupled to the network receiving said at least one set of change transactions from the network.

In another embodiment the invention comprises a data synchronization system for a first system having a plurality of data sources each with a data source format and a second system having a plurality of data sources each with a data source format. The data sync system comprises a first data synchronizer on the first system transmitting at least one set of difference information to an output and a second data synchronizer on the second system coupled to the first system receiving said at least one set of difference information from the first system.

In yet another embodiment the invention comprises a data synchronization system which includes a server. A first system having a plurality of data file types on the system is coupled to the server. The first system includes a differencing synchronizer on the first system extracting a first set of differencing data from the data files on the first system when the data files on the system are changed outputting the differencing data to the server and retrieving differencing data from the server and applying it to selected data files on the first system. The system includes at least one second system having a second plurality of data file types on the second system and a differencing synchronizer on the second system extracting the differencing data from the data files on the second system when the data files on the system are changed outputting the differencing data to the server and retrieving the first set of differencing data from the server and applying it to selected data files on the second system.

In a still further aspect of the invention a method for synchronizing at least a first file and a second file resident on a first and a second systems respectively is provided. The method comprises the steps of determining difference data resulting from changes to a first file on the first system transmitting the difference information to a second system applying the difference information to generate change data for the second file and updating the second file on the second system with the difference data.

The present invention includes a system and a method for transferring data between two devices which require information to be shared between them. In accordance with the discussion herein a device is defined as a collection of elements or components organized for a common purpose and may include hardware components of a computer system personal information devices hand held computers notebooks or any combination of hardware which may include a processor and memory which is adapted to receive or provide information to another device or any software containing such information residing on a single collection of hardware or on different collections of hardware. Such software might include applications such as personal information managers which include contact data and other such information e mail systems and file systems such as those utilized by Microsoft Windows NT operating systems Unix operating systems Linux operating systems or other systems capable of storing file types having binary formats which translate to application formats of differing types.

In one embodiment the invention comprises a set of programs specifically designed to transmit and or receive differencing data from one device to another device irrespective of the type of file system data content or system hardware configuration.

In a further aspect the system comprises store and forward technology which utilizes the differencing technology to implement services via a public or private network such as the Internet.

The system of the present invention finds particular usages in synchronizing personal contact information between different systems but it will be readily apparent to one of average skill in the art that the present invention provides advantages having broader applicability than merely synchronizing various types of systems. For example replying and forwarding e mail can be made more efficient by forwarding only the differences in e mails between systems. As a further example updates to systems software via a network can be made more efficient where for example instead of completely replacing different modules of an application only the differences of the modules need be forwarded resulting in more efficient use of existing bandwidth.

The differencing transmitter upon receipt of a control signal enabling operation of the transmitter examines a specified data structure of information which is to be transmitted to system B. Differencing transmitter extracts such information from System A and converts the information extracted into difference information . Difference information comprises only the changes to System B s data which have occurred on System B and instructions for implementing those changes. Hence if the data to be transferred is a change to a file which exists on system B difference information comprises only the differences in such file and where such differences occur. If the data does not exist at all on System B the difference information will be the entire file. Difference information received by differencing receiver at System B is reconstructed at System B and the changes reflected therein are updated on System B.

For example if System A and System B are two computers and an update for certain binary files on System A is required the differencing transmitter on System A will extract the differences in the file known to exist on System B and any new files and transmit only those differences an instructions for where to insert those differences to the differencing receiver . Differencing receiver will interpret the difference information and reconstruct the binary files on System B. In this manner the information on System B is updated without the need to transfer the entire binary files between the Systems.

Once again the storage server is coupled by a direct connection to both System A and System B. Storage server may be a server specifically adapted to receive differencing information from the receiver and provide it to the transmitter . In one embodiment server includes specific functional routines for enabling this transfer. Alternatively server comprises standard information server types which respond to standard Internet communication protocols such as file transfer protocol FTP or hypertext transfer protocol HTTP .

In the following description an embodiment wherein the differencing receiver transmitter and synchronizer are described will be discussed with respect to its use in synchronizing contact information calendar information and binary file information between a plurality of different devices in the context of data synchronization. It will be readily understood that the system of the present invention is not limited to synchronization applications or applications dependent upon specific types of data such as contact information or scheduling information. In particular it will be readily understood that the transmission of data comprising only the differences in data between two systems via routines which extract the data and reassemble data on the various systems represents a significant advancement in the efficient transmission of data. The present invention allows for optimization in terms of a reduction in the bandwidth utilized to transmit data between two systems since only changes to data are transferred. This consequently increases the speed at which such transactions can take place since the data which needs to be transmitted is substantially smaller than it would be were entire files transferred between the systems.

In a particular embodiment of the present invention the ability of devices to connect to the Internet is leveraged to manage data transfer between the systems. In essence each particular device which requires information access which can connect to the Internet may become part of the system of the present invention and synchronize its data with other devices defined by a user as being part of the system.

Generally the system comprises client software which provides the functions of the differencing transmitter differencing receiver and differencing synchronizer in the form of a device engine. The device engine includes at least one component particular to the type of device on which the device engine runs which enables extraction of information from the device and conversion of the information to difference information and transmission of the difference information to the storage server. This allows the replication of information across all systems coupled to the system of the present invention. Although the storage servers utilized in the system of the present invention may be any type of storage server such as an Internet server or an FTP server and may be provided from any source such as any Internet service provider ISP particular aspects of a storage server which may be useful and which may be customized to optimize transfer of information between systems coupled as part of the present invention will be described below. Synchronization of devices utilizing the synchronization system of the present invention is possible as long as an Internet connection between the devices is available.

In a key aspect of the invention the Internet connection between the devices or between the devices and a server need not exist at the same point in time and new devices may be added to the system of the present invention at any point in time without the loss of information. The system provides totally transparent access to information and the device engine on each device provides an operating system independent extension which allows seamless integration of the personal information services in accordance with the present invention.

In a particular unique aspect of the present invention only those changes to the information which are required to be forwarded to other systems on the system of the present invention are transmitted to enable exceptionally fast response times. In a still further aspect of the invention information which is transferred in this manner is encrypted to ensure security over the public portions of the Internet.

The present invention contemplates the use of two types of device engine one totally embodied on the server which outputs change data to the server and a second totally embodied on the server receiving device generated change information from the device. In addition a hybrid of the two having a portion of the device engine on the device and a portion on the server is disclosed.

As shown in any number and type of devices may be utilized in accordance with the system of the present invention. A telephone may comprise a cellular phone or a standard POTS connected telephone. Telephone may include contact information and as is supported with a newer generation of cellular telephones appointments and task data stored in a data structure . The application which utilizes the application data comprising such information is all stored in the telephone unit . Likewise a personal digital assistant such as a Palm computing device includes application and application data which may include information such as contacts appointments and tasks and may also include file information such as documents which are created and stored on the PDA . Device is represented as a Windows personal computer running an operating system such as Microsoft Windows 95 98 NT or 2000. Applications which may be running on device include the Windows operating system itself Microsoft Outlook Symantec s ACT Personal Information Manager Goldmine Software s Goldmine Lotus Organizer Microsoft s Internet Explorer web browser Netscape s Communicator Suite Qualcomm s Eudora e mail and various other programs each of which has its own set of application data which is required to be synchronized not only with devices outside the system but also between devices and applications within the system itself. Finally a dedicated web browser client is shown which couples via the Internet to web portal applications which have their own set of application data . Unlike devices which store the application and application data substantially in their own hardware web portal applications are provided on a separate server and provided to browser via an Internet connection. Nevertheless the web portal application stored on the portal application provider includes a set of application data which a user may wish to synchronize. For example a large web portal such as Yahoo and Snap.com provide services such as free e mail and contact storage to their users. A user may wish to synchronize this with applications running on their cellular phone PDA or Windows devices.

In order to access the specific application data of each of the systems shown in a device engine is associated with each type of device. A cellular device engine communicates and incorporates itself with the application data of the cellular phone. Likewise a PDA device engine is provided which may be based on either the Palm operating system Windows CE operating system or other PDA type operating systems as necessary. A Windows based device engine includes a mechanism discussed below for extracting application data from supported Windows applications and a web services device engine incorporates to extract application data from web portal applications .

As shown in some device engines are provided entirely on the device and are referred to herein as desktop device engines while others include components a the back end server which may comprise storage server or a specialized server as shown in . This is illustrated generally by lines and in . Also in elements above dashed line are provided by an administrator or service provider of the system of the present invention. Each of the device engines and is configured relative to the type of device on which it resides. For example the Cell phone device engine includes one or more components arranged on the phone while others are on server . Conversely device engine resides entirely on the windows device .

Data from each of the devices is coupled via an Internet connection with a storage server . As noted above storage server may be a generic storage server or it may be a storage server specifically adapted for use with the system of the present invention as discussed below. One or more of the storage servers are used to communicate transactions amongst the collection of systems . It should be readily recognized that any number of different types of systems may be provided in accordance with the present invention and incorporated into the system. However for brevity not all the different types of commercially available computing devices which are currently in use or in development in which the system of the present invention may be incorporated are listed.

In its simplest embodiment the storage server is simply a dumb storage server and each of the device engines transmits only difference information thereto to be stored in a particular location accessible by other device engines in the system. In one embodiment each device engine implements all processing required to keep all the systems fully synchronized. Only one device engine needs to be coupled to the storage server at one particular point in time. This permits synchronization of multiple systems in a disconnected fashion. Each device engine will download all transactions encapsulating changes that have occurred since the last synchronization from the server and apply them to the particular device.

The change or difference information is provided in one or more data packages the structure of which is described herein. Each data package describes changes to any and all transfer information across all device engines including but not limited to application data files folders application settings and the like. Each device engine can control the download of data packages that include classes of information that apply to the specified local device or attached to that specific device engine. For example device engine will only need to work with changes to information describing contact names and phone numbers in application data while device engine will be required to work with changes to e mail changes to document files notes as well as contact and address information since the application data is much more extensive than application data .

Each device engine includes compression decompression and encryption decryption components which allow encryption and or compression of the data packages transmitted across Internet connection . It should be recognized that compression and encryption of the data packages may be optionally provided. It is not required in accordance with the present invention. Each device engine performs mapping and translation steps necessary for applying the data packages to the local format required for that type of information in the application data stores . The device engine also includes components which allow it to track ambiguous updates in cases where users have changed data to a particular data field on two different systems simultaneously since the last update. In this case the device engine includes a mechanism for drawing this to the attention of the user and allowing the user to resolve the conflict.

While the invention will be described with respect to the embodiment of the invention as a differencing synchronizer it will be readily understood that portions of the functionality are utilized as needed in a forward only a differencing transmitter or a receive only a differencing receiver capacity as required by the particular application.

As noted above a device engine exists for each and every device that makes up a user s personal information network of devices in the system. As shown in each device engine includes an application object . The application object is specific to each particular application and provides a standard interface between the device engine and the balance of the data transmission system of the invention and the application . Details of the application object will be described in further detail below. The application object is a pluggable architecture which supports a wide variety of vendor unique applications. The job of the application object is to map data from the application into a temporary or universal data structure by connecting to the application via any number of standard interfaces to gain access to the applications data. The data structure of the application object puts the data in a generic or universal data format which may be used by the device engine components to generate data packages for provision to the storage server.

Also provided is an application object store AOS which includes a copy of the device s data at a point just after the previous data extraction and synchronization occurred. Application object store is a mirrored interface which stores a snapshot of the previous state of the data from the application object in the device engine. The size of the AOS will depend on the data being collected by each device engine.

The generic output of the application object is provided to a delta module . Delta module is a differencing engine which calculates differences in data between the output of the application object and the copy of the data which is provided in an application object store AOS . The actual differencing and patch routine can comprise a routine such as XDelta or YDelta. The delta module will be referred to herein alternatively in certain portions of the description as CStructuredDelta. In addition the difference information is alternatively referred to herein as a change log. Each change log or set of difference information is a self describing series of sync transactions. As described below the change log may be encrypted and compressed before output to the network.

Hence during a sync the Application Object will using a mechanism discussed below extract the data of each application in the device and convert it to a universal data format. The delta module will then generate a difference set by comparing the output of the Application Object and the AOS. This difference information is forwarded to the encryption and compression routines for output to the storage server in the form of a data package. Alternatively the data from one application can be used to synchronize to data in another application in for example a windows environment as shown by arrow in .

It should be specifically noted that the application object may interface directly unstructured binary data or with structured application data. The differencing routine supports both uses of the delta module in comparison generation.

In some cases operation of the application object and delta module is simplified by the fact that some applications such as PDA s have the ability to output changes to its data. In such cases the delta module need only provide the data into the data package since comparison to an AOS is not required the application already includes a mechanism for tracking changes made to its own data. However in many cases the applications provide at most a standard interface to access the data such as Microsoft s OBDC interface the Microsoft standard Application Programming Interface API or other similar standard interfaces.

Device engine further includes a versioning module which applies a version number per object in the data package. As explained further below each object in the data package is assigned a universally unique ID UUID . Hence unlike many prior synchronization systems the system of the present invention does not sync data solely by comparing time stamps of two sets of data. Versioning module allows each device engine to check the state of the last synchronization against data packs which have been provided to the storage server to determine which data packages to apply. This allows the device engine to sync itself independently of the number of times another device engine uploads changes to the storage server. In other words a first device engine does not care how many times a second device engine uploads data packages to the server.

An events module controls synchronization initialization events. Items such as when to sync how to sync trigger the delta module to perform a synchronization operation.

A user interface is provided to allow additional functional features to a system user of the particular device to which the device engine is coupled. The user interface is coupled to a conflict resolution module a filtering module and a field mapping module . Each of the modules provides the functionality both necessary for all synchronization programs and which users have come to expect.

Filtering module allows filtering for types of content based on for example a field level content search. The field mapping module allows for the user to re map certain interpretations of items which were provided in the document stream. For example if the device engine is operating on a personal computer and a synchronization is occurring between the personal computer and a notebook computer and the user has a my documents directory on the personal computer which he wishes to map to a different directory on the notebook computer the field mapping module allows for this re mapping to occur. It should be recognized that the field mapping module allows for changes in directing the output of the data package. The field mapping module is not necessary to map particular data fields of for example contact information from one application such as Microsoft Outlook to a different application such as Symantec s ACT as is the traditional use of field mapping and synchronizing applications.

Delta module is further coupled to a compression module and an encryption module . It should be recognized that the compression encryption modules need not be enabled. Any type of compression module such as the popular PK Zip or Winzip modules or those available from HiFn Corporation may be utilized in accordance with the invention. Moreover any type of encryption algorithms such as MD5 RCH 6 Two Fish or Blowfish or any other symmetric encryption algorithm may be utilized. In one embodiment of the invention encryption without compression is used. In a second embodiment of the invention compression without encryption is used. In a third embodiment of the invention neither compression or encryption is used and in a fourth embodiment of the invention both compression and encryption are used.

Versioning module also allows the device engine to support multiple users with distinct synchronization profiles. This allows multiple users accessing the same machine to each synchronize their own data set using the same device engine. For example if the application on a particular device comprises Microsoft Outlook on a personal computer coupled to a Microsoft Exchange server and Outlook is configured to have multiple user profiles versioning module will track the data applied through the device engine when a sync request occurs. This allows two users of the same Outlook client software which access different data sets either in the client computer or on a separate server to utilize the same device engine and the system of the present invention via the same machine. In a further embodiment a particular device engine supports the use of foreign devices accessing the system via the same connection. Palm devices for example use a cradle to connect to a computer and or Internet connection. If a particular user wishes to allow another user to use his Palm pilot cradle connection to synchronize the other user s Palm pilot the device engine can generate data packages to update the local application object store for the foreign device. The application object store can therefore be used as a temporary storage for cases allowing synchronization of foreign devices.

The output of the device engine comprises a data package which is output to storage server . As noted above only one device engine need be connected to the storage server at a given time. The data package can be stored on the storage server until a request is made to a particular location of the storage server by another device engine. Likewise delta engine can query alternative locations on the storage server for access to synchronized data within the system of the present invention. Access to areas of the storage server is controlled by a management server MS described more fully below. In one embodiment each sync operation requires that the device engine for each device login to the management server to authenticate the device and provide the device engine with the location of the individual device s data packages on the storage server.

Data packages may be advantageously provided to the device engine from the storage server in a streaming format allowing processing to occur using a minimum of bandwidth and storage in the devices. The device engine and particularly the delta module interpret data packages based on the versioning information and the mirrored data present in the application object store . When data is returned to the delta module from the storage server the delta module returns differenced data to the application object for the particular application which then translates the delta information into the particular interface utilized for application . Once a device engine has been fully applied all data packages from an input stream it generates a series of data packages that describe the changes made on the local system. The device engine uses the local application object store to keep track of the last synchronized version of each application s actual data which is then used for the next data comparison by the delta module on the next sync request. Generated data packages can include operations and encode changes generated from resolving ambiguous cases as described above.

Shown therein are two sync servers and each of which is dedicated to syncing one particular type of application. Sync server is dedicated to the Palm device while sync server is dedicated to for example a portal application Portal .

Since the Palm Device includes a mechanism for transmitting changes to its data directly data may be transmitted using HTTP request and response via the firewall to the sync server where differencing and updating of data in the AOS can occur after which changes can be downloaded to the Palm 

The synchronization server is an application handles concurrent synchronization of user s data. Each Sync Server includes plug in support for multiple devices to be synchronized using the same sync server executable. Each device type has it s own device name that identifies which AO AOS components will be used during the sync.

The sync server uses the concept of a universal data record in its internal sync differencing engine and when sending data to and retrieving from external entities such as the AOS and AO. Hence in the Palm application the job of a server AO is simply to take the device specific format of its record and convert into a universal record format.

The Sync Server has a plug in architecture so that 3rd party application partners can easily add their services into the server. Currently if the server is operated in a Microsoft Windows NT Server the sync server discovers the sync components via the Windows NT registry. In alternative embodiments this function is performed in a Component Manger which operates on each sync server to manage processing by each of the AO and AOS on the server. Each AO and AOS are implemented as a stand alone DLL that the Sync Server loads at initialization time or when adding a new component via the Component Manager.

Each sync server is shown as dedicated to a single application. However a sync server may handle multiple device types.

In the embodiment of it should be noted that depending on the device type there are different configurations for the AOS and AO s. For example the Palm AO data store resides on the Palm device itself and a separate AOS data store exists for this configuration an Oracle database . In the case of Portal the AOS and AO use the data store .

Device engines can generate additional data packages intended to resolve synchronization problems in other systems. For example interfacing with the conflict resolution module if the user makes a change to a particular data store on an application object on his Palm pilot then makes an additional change to a personal information manager PIM application on his personal computer the user can specify that the change made on the personal computer will win when the conflict is detected by the A engine and the versioning information between the two devices. This is essentially a definition that one particular set of data is correct and should replace the second set of data.

As shown in a Windows operating system may have at least three specific applications which may require synchronization. In the system includes Netscape Communicator application having data such as bookmarks contacts and e mail a Microsoft Outlook application which includes contact information calendar information e mail information note information and tasks information and Windows operating system information including Favorites data file system information and individual files .

Each particular application has an associated application object . Each of the respective application objects provides data back to delta module in a generic format which is usable by the delta module in accordance with the foregoing description of the apparatus shown in . From it will be additionally seen how the delta module may be utilized to synchronize data between applications running on the same particular server. The device engine hence does an intra system sync such as for example between the contact information from Netscape and the contact information from Outlook.

In operation during an installation of a device engine into a particular system the installation program may be tailored to provide application objects which may be present on a given system. For example and with reference to the installation program for a Windows machine will carry any number of application objects for systems and applications which may be present on a Windows machine. The installer will check for the presence of given applications and allow the user to add additional applications which may be installed in locations that are not the normal default installation areas for application support by the application objects which the installer is carrying or de select certain applications which for one reason or another the user may not wish to install an application object for and render a part of the system of the present invention.

As noted above there are different types of server and desktop device engines some having application objects entirely on the server while others have application objects entirely on the desktop.

Each application object will include a connector which may comprise a generic interface to the particular application for which the application object store has been designed. For example when connecting to a Palm device the connector will be an HTTP protocol request routine which interfaces with the Palm device s own built in synchronization manager which provides an output of records which have been changed on the Palm device. As in since the Palm outputs all the changes to its data via its own sync manager in the Palm application the job of a server AO is simply to take the device specific format of its record and convert into a universal record format.

The connector provides access for the application object to remove the data field from a particular application and convert it to a universal record structure. In the desktop AO where for example the application object is designed for a Windows interface the connector may be the Windows API and the job of the AO will be to translate data from for example the windows file system to a universal data format. This universal data structure is then used by the delta module to build data packages to be used in synchronization between components of the systems provided in the network system of the present invention.

Universal data structure mapping used on desktop application objects and universal data record mapping used by the server device engines is further detailed below.

Each Application Object AO is a software component that interfaces with the third party application APIs Application Programming Interface to provide the programming services to the delta module for extraction and deposition of information data from and to the third party application domain during synchronization. In addition the AO maps the third party application data fields to system s domain.

The AO service is a collection of COM Component Object Model objects that can be developed in conjunction with the third party Windows application APIs as a form of a DLL Dynamic Linked Library in C or C . The DLL is loaded on demand at runtime during synchronization. It should be recognized that the application object need not be implemented using the COM model but may be developed with other distributed object models.

There are a number of the related subsystems and documents that the developer must be familiar with and this document has made many references to those subsystems during the course of presenting the AO.

Each AO has a COM interface based design built in. That is instead of providing a set of traditional APIs as programming services it provides a set of interface based objects as programming services.

StructuredDelta the delta module the primary intended user of each AO. StructuredDelta instantiates these COM objects and uses them throughout the synchronization session exclusively through the COM interfaces on those objects to interface with the third party application database.

Each AO component consists of a set of objects that translate the third party application data into the universal data middle format which underpins the entire spectrum of PIM data regardless of which third party application the data comes from. The objects in universal data format are device application data class store folder item and data fields. The AO digests the third party application data of any kind and reduces it into a few handful simple objects and field types. These objects and field types are fed into StructuredDelta engine and are compared by StructuredDelta in order of their hierarchy. The resulting differences add delete modify are logged as transactions in the difference information. The data packs are transported to a storage server that may be actively managed by a management server for each individual user account and devices.

StructuredDelta uses AO objects to access and modify the individual AO objects and data fields. AO objects serve as a buffer between individual application data and StructuredDelta so that StructuredDelta does not require knowledge of each application and database. All AO objects are temporary and created in the space of each AO by StructuredDelta through COM interfaces. AO objects are referenced when they are in use and they are freed when StructuredDelta stops using them. One can think of AO objects as merely placeholders of each application objects for StructuredDelta to access. Once StructuredDelta has a particular Application s data StructuredDelta would free AO objects immediately without storing them internally.

AppObj is a root object of each AO component and there is one and only one per AO. AppObj provides an entry point into the individual application s database. StructuredDelta instantiates it and holds it on during the entire synchronization session and releases it afterward. AppObj offers a number of services such as what class of data it supports. The C example of AppObj s definition is shown below 

AppObj can contain children objects. They are Store objects. EnumItems interface is used to enumerate Store objects. FindItem interface is used to find the contained objects. ModifyItem interface enables AppObj to create a new Store object. AppObj is created by StructuredDelta calling CreateAppObject HWND hWndParent AppObj ppObj .

The Store object represents a database of the individual application information. If the individual application can handle multiple databases at same time one needs multiple Store objects. One can think of Store object as a specialized Folder object the root folder of each particular application data domain. The C example of Store s definition is shown below 

Store is a container of Folder objects. EnumItems interface enables the enumeration of its contained folders while FindItem and FindItemByData interface is used to find contained Folders or Item objects. ModifyItem and ReadWrite interface enables the modification of each application database.

Folder object is a specific data class of each individual application such as a table in the relational database or a collection of data records in each application. For example the applications contact collection can be thought as a Folder object. The C example of Folder s definition is shown below 

Folder object is also container. It can contain Item objects as well as Folder objects. EnumItem interface allows the enumeration of either Folder objects or Item objects or both. FindItem and FindItemByData interface is used to find contained Folder objects or Item objects. ModifyItem and ReadWrite interface enables the modification of an application s data tables.

Item object represents an individual entity of each application s domain specific data. Item object can be thought as a record of each application s relational table. For example a contact email calendar to do item in the particular application can be thought of as an Item object. The C example of Item s definition is shown below 

Item can contain Attachment objects only. EnumItems interface enables the enumeration of Attachment objects if any. ModifyItem and ReadWrite interface enables the modification of an application s records or data fields.

Attachment object is a specialized Item object that encapsulates an attachment data or relationship. Only Item can have Attachment objects. Attachment object can be thought as attachment data such as attached email files. Attachment can also be thought as attachment relationship to other Item objects. The example of that is the distribution list Item object can contain contacts Item objects . The C example of Item s definition is shown below 

Variant object represents a data field of each particular application data. For example a first name of a contact or the birthday date of a contact can be thought as Variant object. StructuredDelta only understands Variant object and the types of data fields it encapsulated. Variant object can contain any one of the following data field type 

Variant tag is an identification tag of data field and variant flag specifies the type of data field while Variant value member variable stores each application s field value. One data field type is Collection. Collection object is an array of Variant objects. It can be used to represent a compound data fields.

Another data field type that is worth exploring is Binary. Binary object can be used to represent a binary data as it is.

Each AO object has an AO COM interface. Each object must implement some of those interfaces to create certain capability or desired behavior that are expected by StructuredDelta.

This is the base interface of all application objects. It provides the identification service to StructuredDelta. Every object must have a unique ID parent unique ID display name and item type information eItemType FOLDER eItemType CONTACT etc . The unique ID is a unique string only in a given device. It is not persistent cross the Internet to other devices. The ID usually comes from the third party application database domain such a unique ID of a record.

This is the base interface of all application container objects store folder . These container objects must have this interface implemented so that StructuredDelta would recursively descend in them if they have IItemContainer capability.

This is an error reporting interface for every application object. It is used by StructuredDelta to query the error string after a failure. The AO should implement this on every object after the error occurs and before returning the control to StructuredDelta.

This is an interface for collection enumeration used by StructuredDelta to enumerate the objects of the third party application database. IEItemEnumFlags eItemEnumFlags FOLDER eItemEnumFlags ITEM and eItemEnumFlags ATTACHMENT is used to enumerate only the requested type of objects.

This is an interface for recursively finding object within the third party application database used by StructuredDelta to find application object by its unique ID.

This is an interface for recursively finding the object that matches the search criteria data. The search criteria are represented as Collection that allows the multiple search field keys to be used during the search. The multiple objects may be found that match the search criteria. The interface also provides enumeration capability of the search results.

This is an interface for StructuredDelta to add delete and re parent application data in the third party database during synchronization.

This is an interface for accessing writing and mapping the third party application data fields by StructuredDelta. It provides the capability of read and write data fields from and to the third party application database and the capability of mapping data field of the third party application to universal data format of the system of the present invention. Any object that has data fields and require field level synchronization must implement this interface.

This is an AppObj only interface. It provides the capability of logon and logoff to the third party applications during synchronization. The data class filter mechanism is used by StructuredDelta to filter the enumeration of contained data classes eDataClass CONTACT eDataClass CALENDAR etc .

This is an AppObj only interface. It provides DLL module identification information to the Manager object such as the name of the third party application enum ID of this application and the application installation detection support.

This is an AppObj only interface. It provides the information on the number of item types supported by AO what type items are supported and the capabilities for a specific item type. This returns a DWORD containing bits set.

This is a CAppObj only interface. It provides the information on the number of data classes that are supported by the application object and what the data classes are supported

This is a CAppObj only interface it provides information on the number of database files and database filenames supported by AO to avoid being synched twice by application sync and file set sync.

This is a CAppObj only interface that is used by StructuredDelta to query the data fields of given application object. For example what are data fields in application object called eItemType CONTACT 

This is a CAppObj only interface used by StructuredDelta to obtain the special and default folders unique IDs and UUIDs.

This is a CAppObj only interface that is used by StructuredDelta to query if the given AO also provides FastSync service or not. FastSync is a DLL component that is written using the third party APIs and loaded into the third party application to receive the changes in database while users are operating the application. It is used to speed up the synchronization performance by syncing only the objects that are known to IFastSync component.

This is a CAppObj only interface that is called by Manager to notify the third party application the state of synchronization start finished or reset so that the application can prepare itself accordingly.

Server Application Objects share many characteristics with desktop application objects including support for reading and mapping to the universal record structure set forth above.

Nevertheless among various devices incorporated into the system of the present invention each application object database will be quite different. For example the Palm database on the device is really just a memory space with records laid out sequentially in memory. In a web portal type application the application object may be an Oracle database. Server application objects may generally have less difficult tasks since the applications supported are generally either devices providing their own change data output such as Palm type PDA s or which do not have a great deal of data to export such as cell phones having only name and number information .

Nevertheless each application object must support all calls defined in a class interface definition as follows 

As noted above because each application object database is different the calling convention and the application object itself will likewise be different. The calling convention for a Palm device s sync manager application object is given in the following pseudo code 

The above example of mapping the contact field files maps contact fields from a particular web contact information database to fields in the universal record format from the master list header file pio types.h in the system of the present invention. This mapping is for a specific contact table and it should be understood that other information such as phone numbers e mail addresses and other contact information may be stored in a separate table.

Once data is extracted from a particular application the server application object must then convert the information into the universal record format which can be utilized by other server device engines to take content information into their own particular application.

The universal record format is used by each server device engine to handle various tasks of encapsulating records in a common format comparing records creating and holding differences between records and other tasks of synchronization.

The universal record format allows the application objects to support a wide range of extensible application item types such as contacts calendar mail bookmarks and the like. Flexible type name and value associations permit synchronization without regard to individual vendor application information formats. Each application object encapsulates mapped knowledge from the vendor unique format to the universal format of the present invention. As such an application object can be designed to support any combination of application and binary information types. In essence application objects can be designed to support a vendor application using only binary file synchronization if the internal format of the application is not known.

Server application objects can also be designed to create collections. For example if the user wishes to create a my pictures collection which consists of some collection of information and synchronize this collection of information such an arbitrary grouping of classes of information into appropriate representations is supported.

Because the connector layer of the interfaces to the actual storage with a vendor application varies with application type application access methods can include but are not limited to disk or database access network protocols wireless device protocols and the like.

An example of how data is removed from one particular application data type and converted into the universal record format is given below for an Oracle database 

While the above identified code is specific to for example an Oracle database one of average skill in the art will readily recognize that the technique utilized above may be adapted to other types of databases containing records and fields of interest. In the above code examples all fields which are mapped from a particular application are mapped to fields in the master mapping file.

In order to provide security and identification of particular users in an Internet implemented synchronization system a management server may be provided in the system of the present invention. The management server is a centralized server which controls behavior and characteristics of the entire network of device engines across all users.

The management server communicates using hypertext transfer protocol HTTP which may be implemented with a secure sockets layer SSL to ensure security.

In particular the management server supports an authentication interface that requires each device engine to authenticate with the management server before performing synchronization. Certain storage server implementations may utilize locking semantics to control read and write access to storage for multiple device engines. For example in a generic FTP request if two device engines attempt to connect to the same data at the same time there must be some form of locking control to prevent device engines accessing the same data at the same time. In this instance the management server controls the device engine acquisition renewal and releasing of locks against data stored in the network.

Each device engine is uniquely identified and tracked by the management server. This allows for tailoring behavior between the management server and specific types of storage systems and device engine components. All device engine components are tagged and version stamped for management via the management server.

Device actions can request updated copies of individual device engine components permitting self update and configuration of device engine systems. This permits minimal download designs for device engines that are on low bandwidth connections enabling the device engines to download additional required components at a later time.

In a further aspect of the system a value added component may be provided where the management server can support client s advertising mechanisms enabling the display of banner or similar advertising on a device engine system without the need for a web browser. Cycling of advertisements statistic collection and the like are managed via management server protocols. Online purchase and subscription mechanisms are also supported using the management server protocol.

The management server further supports the accounting sign up registration device edition storage server selection and similar functions for each user in the system. In one embodiment the management server may retain password and encryption information for a given user account. In a second embodiment such information is not retained. The second embodiment provides the advantage that users may feel more secure if the maintainer of the management server is not in possession of the password to access data in the user s account.

Further information with respect to the management server and the data flow from the management server to other components of the system of the present invention will become apparent with respect to the discussion of the process flow and data flow diagrams in .

As shown in following a welcome request a user is allowed to sign out which enables an add user module and subsequently enables an add device module . If sign up is not requested information may be provided via module .

As indicated in the add user module adds user records to the user in device database . Additionally the add device module adds users and devices to the user device database . A device list and a device engine download and update database provide selection data for the add device module . The account authentication module receives input both directly from a user log in from the welcome screen at and from the add device module .

Once an account is authenticated and confirmed the administrator of the system of the present invention having a private data store at may choose to provide a web desktop which allows access to a user s records such as file e mail calendar contacts notes and tasks . The information will be culled from a provider database which will be synched in accordance with the system of the present invention as previously described. In essence the provider database accesses data from the device engines which include as discussed above the storage server each individual device engine and a settings database .

Other portions of the management server include the locking modules for beginning a sync continuing a sync and ending a sync and for updating user information including modifying a user adding devices removing devices and modifying devices .

Shown in is the storage server . While storage server may include a generic storage model accessible through any number of standard Internet protocols in accordance with the present invention a flexible storage architecture is provided that permits various standard implementations of the system of the present invention. This allows deployment of network services without installation of new server applications and can be responsible for communicating change information between multiple device engines in a consistent fashion.

One or more storage servers may be used to communicate transaction amongst a collection of devices. Each user s personal information network is represented by a unique account within its own data package storage section. The storage server maintains persistent store collection of data packages which is at a minimum enough data packages to be capable of synchronizing the most out of date system in a user s given information network or add information to new devices which are provided in the network. Additional data packages can be maintained to permit rollback of previous versions of information. The storage server can automatically dispose of older data package storage and can support aging of an inactive accounts.

Each storage server may be implemented using a variety of implementations including a standard FTP server for any operating system platform. The storage server can be implemented using HTTP protocols for increased efficiency and firewall avoidance. The storage server may be implemented using techniques for local storage such as database access or single file storage of a user s entire file system tree. The storage server may utilize the stored foreign protocol model for moving copies of data packages to other storage servers in the system. In one embodiment the storage server can allow tunneling of information using an alternative protocol to other storage servers in cases where firewall prevents originating protocol. For example a storage server can relay an FTP traffic inside an HTTP protocol. Storage servers may include their own locking semantics to arbitrate multiple device engine access to the same server without the need for a separate management server. Each device engine can access only a specific user s data package storage area even though the storage server may maintain a larger number of data packages across a large number of users. This allows for increased scaling when the storage server is implemented using file system techniques.

In one aspect the storage server is implemented using standard FTP or HTTP connections for each operation. HTTP is composed of request response pairs. All requests are supposed to be posting commands. Parameters can be set in the form known as application X WWW form URLENCODED . The encoding is specified as in RFC1866. Functions for the storage server include testing if the storage server can reach other users which will retrieve a simple text string a get command which transfers the contents of a file as in a binary stream of byes a put command as a binary stream of data to the storage server a directory listing command a remove command a rename command an exist command and the like.

A pull synchronization as illustrated in is always performed prior to a push synchronization. This allows the device engine to know whether synchronization of its own data is necessary.

Each device has its own triggering mechanism for initiating synchronization. Some devices such as Windows clients and Palm pilots are triggered manually when the user presses a sync button. Other devices such as a cellular telephone may be triggered automatically after another device completes a sync. Regular time based triggers are supported as well. A web based application portal will sync when a user logs into the website security authorization mechanism and may optionally sync on a log out of the user or on the session time out but only if the user has changed data during the session.

For each sync the triggering event specifies which application types are to sync for the device. This enables a triggering event to trigger only a sync for a particular application type. The management server can specify that no sync is needed for a particular type of application to minimize traffic to the storage server. Syncs may be triggered via an HTTP request to the server. This request holds information about which device to sync and the user log in information is bounced to the management server for authorization and validation. Syncs may be triggered by sending an HTTP request to the server and passing the authentication information in the data portion of the request to the management server. Each device may include a servlet that is responsible for retrieving the request and ensuring its proper format before passing the synchronization request on to the server.

The device name and device class uniquely identify a particular device type that is being synchronized and is contained in the management server. Each user has one or more device entries in the management server authorization records and each device name is unique for this user s space. For example if a user has five devices with his or her own personal identification number there will be five authorization records. There may be two Windows devices two different Palm devices and a web service portal each having their own personal identification number.

As shown in the pull synchronization process starts at an idle state when the triggering event described above triggers a synchronization request. The synchronization request is confirmed at and if the request is verified a connection is made to the storage server at step . Once a connection is established the connection to the management server is made at step to authenticate the user identification via the management server. If authentication is successful the management server may initiate a management server lock on the storage server so that no conflicting device engines may couple to the same data at the same time. A failure at any of the steps will return the system to its idle state . Once the engine server lock is acquired the storage server will be checked to determine whether a new version of the data exists on the storage server at step . If no new version exists the synchronization process ends.

If a new version of the data exists the device engine will retrieve the difference information at step to get . 

Once a is retrieved conflicts are resolved at step . The resolve conflicts step allows a user to resolve conflicts to multiple types of data which have been changed on both the server portion of the device and in the local data.

Once the conflicts have been resolved at step the s are applied at step . The apply step allows for filters and mappings to be accounted for on the local device engine side of the system. As shown at steps and the may include updates at the item level application level device level or network level . In each of the aforementioned steps a loop back to the retrieval step is provided. When no further s are available the management server lock is released at step .

The foregoing description of a pull synchronization is further described in the following pseudo code 

Once the s for a given application have been created the method of the present invention continues at step which enables a connection to a storage server. Upon connection to the storage server a further connection to management server will occur to authenticate the user in the system. Failure at any of the aforementioned points will result in returning to idle state . Upon authentication a management server lock is enabled to ensure that multiple device engines do not connect to the same data at the same time.

Once a lock is acquired at step s are uploaded to the system. As shown this may include uploading an item an application uploading a device or a network . Once s have been uploaded to the server management lock server is released and the connection to the storage server is terminated at step .

It should be recognized that such a push synchronization need not occur directly to a server but may occur directly to a second device engine in accordance with the depiction of the multiple embodiments of the invention in .

Once information is provided into the universal data format the device engine organizes the format into a data package. Each data package thus includes a description of changes to any and all information for particular application and a collection of data packages describes changes across all device engines including all different types of data. With encoding and compression data packages can become very compact to minimize bandwidth and storage requirements across the system of the present invention.

In one particular aspect of the present invention encoding of the data packages may be provided in a streaming format to allow processing by the device engines with minimal storage and memory configuration at the device engine level.

The device engine can read the stream and determine which records from which applications it needs to update the particular information present on the system on which it resides.

Data packages can be provided in a binary data format. This allows data packages to encode changes to non application data at a bite level. Hence if a single bit on a system changes the system of the present invention allows synchronization of that bit on another system. Changes are described as a sequence of bite level change operations. One such encoding is using a sequence of insert and copy operations. Insert and copy operations generally define a particular insertion of a number of bites from a source file then how many bites of a changed source file must be inserted to a particular file then how many bites to insert from a particular new file with a differencing engine taking the bites in the stream and inserting them into the new file to create the new version of the file.

As will be readily understood by one of average skill in the art this allows a user to for example change a binary file such as a word processing document or other type of attachment and synchronize such an attachment at the binary level. Specifically if one forwards an e mail of a word document to a second individual the second individual modifies it and wishes to return this document with modifications to the first individual because the first individual has the original file on his system if both systems are enabled in the system of the present invention the second system need only send the changes or the difference information back to the first system in order for the first system to reconstruct the document on the second system using this change data to create the document as intended by the second user.

Multiple caching of both the generation and application of data packages can be utilized to deal with communication issues in accordance with the system of the present invention. It should be further recognized that data packages can be merged into larger meta data packages. Such meta data information such as the organization of multiple device packages may be encoded into a larger system package. Each system package is essentially an encoded sequence of data packages.

Particular examples of item fields which may be included for any given item are shown in . These exemplary item objects may for example be from an allocation such as Microsoft Outlook. Outlook allows for note items e mail items task items calendar items bookmark items file items channel items folder items and contact items all of which have fields such as those represented in .

The data format also contains folder information which allows the classification of items and consequently their associated item fields into particular categories.

Application objects include information on the types of applications from which information in the stream is included. Device objects include information on the origin type of device which the information is originating from. Network objects include information on a user level to define that the information in the data stream is coming from a particular user.

As detailed above each application object supports a folder store interface that permits management of collections of information on a folder level and permits management of folder hierarchies of information. The application object also includes an item interface that permits management of individual information entries such as records or files or components of information entries such as fields within records. Each application object further supports an interface for detection of a vendor application.

A DataPack essentially contains a sequence of transactions describing changes to information. This information can span two basic types structured or application data and unstructured or binary file data.

Transactions are encoded using an efficient streaming format with tags to represent the actual content objects. This technique permits the continuous extension of the DataPack format as new content is supported.

The general architecture of the package provides for transactions application data file data files objects and identifiers to be carried in the data package. Generally transactions application data file data and files have previously been described.

The first portion of the data package will be the data package identifier. Each transaction has a basic architecture of objects and operations. Each piece of content is referred to as an object and is uniquely represented with a Universally Unique Identifier UUID . Objects typically are represented by a dynamically generated UUID but more common objects are represented by static UUIDs. The following static UUIDs are defined 

Transactions are broken down into manageable blocks in the form of individual files. These files are then optionally compressed and encrypted and prefixed with appropriate headers. Transactions are grouped into specific files based on the following rules 

A DataPack file is identified using specific rules based on the file name. The file name is of the form UUID.VER where UUID is the identifier for the specific object and VER is the transaction version number. The version number is of the form D0001 with additional digits used for large version numbers. The D000 value may be reserved for the base version for the object.

The UUID for the user account is generated by the Management Server MS . The MS also maintains a current table of UUID values and version numbers that provides the root structure for understanding the DataPack files within a user account. The MS also provides necessary locking semantics needed to maintain consistency when multiple device engines attempt to synchronize.

All DataPacks are prefixed with a standardized header that provides basic content information regarding the DataPack. Compression and encryption headers follow the DataPack header if needed.

The data package header information will include version signature applied versioning information content type engine type compression type encryption type applied size encrypted size compressed size raw data size and other data useful for the device engine in decrypting the data stream to provide the data into a format usable for the application.

The DeltaType encodes the type of binary file differencing used. The following DeltaType values are permissible using DataPackageDeltaType 

The compression type specifies whether the DataPack has been compressed. A DataPack compression header follows the DataPack header if a compression type is specified. The following CompressionType values are permissible using DataPackageCompressionType 

The encryption type specifies whether the DataPack has been encrypted. A DataPack encryption header follows the DataPack header if an encryption type is specified. The following EncryptionType values are permissible using DataPackageEncryptionType 

An account is the root structure which identifies information about the user s account. It may have exemplary field tags eFieldTag  NAME such as Name Password UserName and Version. The FieldTag ItemType value is specified as ItemType PIN using enumItemType.

A device is a system identified as part of an account. Examples include PCs handhelds Web sites and so on. It may have tags eFieldTag  Name such as name and type and item type values eDevice  Name such as Portal Palm Windows CellPhone.

A data class is a grouping of similar information types. Many data classes may be represented for a particular account. The data class may contain field tags eFieldTag  Name such as Name ItemType SubType IsManaged Provider Filter and Version.

A Provider is the application that maintains specific information within a data class. There can be more than one provider for a particular data class. Field tags include Name AppObjID Password Username and Version. Examples of provider tags permissible for the provider eProvider Name include Portal Palm MicrosoftOutlook Lotus Organizer Microsoft Internet Explorer Microsoft Windows and so on.

Data stores are the containers for storing information within a provider. There can be more than one data store for a particular provider. Folders represent structural organization of information within a data store. Data stores are not required to support folders. Tags eFieldTag  Name supported for each data store include Name ItemType IsManaged and OriginalPath. Item types permissible for the data store include unknown Folder MAPI Database and Store File.

Folders represent structural organization of information within a data store. Data stores are not required to support folders. A folder is represented by a UUID and may contain any of the following field tags eFieldTag  Name Name ItemType IsManaged FileAttributes CreationDate ModificationDate AccessDate SpecialFolderType.

Items are individual informational components consisting of the actual user data. They may contain field tags such as Name ItemType IsManaged and Version.

Item types may take the format eItemType  Name and may include extended folder attachment contact distlist email calendar task call note post journal form script rule favorites subscription common favorites desktop common desktop startmenu common startmenu channels cookies programs common programs startup common startup sendto recent internet cache history mapped drives printers docs doctemplates fonts window settings app data folder app settings fileset pin device data store file provider and data class internal.

A field is based on one of a set of base type definitions. All field tag information is encoded using the following format 

A number of Field types are possible including unknown long dword date string binary float double collection uniqueid qword uuid file invalid. LONG is a four byte value encoded in big endian format. FieldType DWORD is a four byte value encoded in big endian format. FieldType String is a sequence of Unicode characters followed by a single NULL byte. Interfaces are provided with an MBCS value. FieldType Binary is a sequence of bytes. FieldType UniqueID is a sequence of bytes as defined by the Universally Unique Identifier UUID standard. AO interfaces are provided with a Locally Unique Identifier LUID value FieldType QWORD is an eight byte value encoded in big endian format. FieldType File is a UUID that references a separate DataPack containing the file body data. AO interfaces are provided with a sequence of Unicode characters followed by a single NULL byte that describes the full path name for the file.

Any number of filed sub types are possible. Each of the sub types includes all of the possible data types from all of the supported user applications. As should be well understood the possibilities in the number of sub types is quite large and dynamic as each new application supported by the system of the present invention is added. Examples of sub types include 

The aforementioned invention provides a user centric model of communication to deliver personal information via network services. This model accommodates devices that are disconnected from the network such as the Internet at various times. Personal information can continue to exist locally rather than imposing a server centric model on existing information.

In accordance with the foregoing a store and forward information broadcast is utilized. Changes to existing information are replicated to an Internet storage server and changes are then retrieved by other devices on the network at device specific times. In this manner direct client communication is accomplished without requiring one to one communication. While one communication is supported by the system of the present invention it need not be required.

Although the present invention has been presented in the form of an Internet store and forward broadcast for the purposes of synchronizing personal information amongst various types of devices it will be readily recognized that synchronization need not be accomplished as the only application for the aforementioned system. In particular the system can be utilized to efficiently broadcast changes to information in so called push type information applications where only portions of the data need to be changed on a client application. For example in a system where information such as changes in a stock price need to be broadcast to a plurality of users a client application implementing the aforementioned technology can be updated by only changing specific portions of the data in the client application relative to that particular stock price. This can be done using a smaller bandwidth than has previously been determined with other devices.

The many objects and advantages of the present invention will be readily apparent to one of average skill in the art. All such objects and advantages are intended to be within the scope of the invention as defined by the written description and drawings presented herein.

