---

title: Network analysis with Steiner trees
abstract: Networks may be analyzed using Steiner trees. In an example embodiment, a method includes acts of receiving, accepting, creating, and analyzing. Data specifying a network is received. Steiner tree parameters are accepted. A Steiner tree model is created on the data specifying the network responsive to the Steiner tree parameters. The Steiner tree model includes a local representation having a depth constraint for neighborhood vertices. The data specifying the network is analyzed to ascertain a Steiner tree solution based on the Steiner tree model, which includes the local representation, and using a locally-oriented combinatorial algorithm.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07885269&OS=07885269&RS=07885269
owner: Microsoft Corporation
number: 07885269
owner_city: Redmond
owner_country: US
publication_date: 20080627
---
This U.S. Nonprovisional Patent Application claims the benefit of copending U.S. Provisional Patent Application 61 033 214 filed on 3 Mar. 2008 and entitled Optimization of Network Solutions . U.S. Provisional Patent Application 61 033 214 is hereby incorporated by reference in its entirety herein.

Network analysis is performed in a number of different fields. For example network analysis is relevant to telecommunications. A telecommunications network usually includes many different nodes spanning a large geographical area. When a communication such as a telephone call is initiated the telecommunications system decides how to route the communication from the origination point to the destination point via multiple nodes. An efficient selection of nodes can accelerate and or reduce the cost of completion of the communication. The selection of the nodes to carry the communication may be made by performing a network analysis.

With one origination point and one termination point the network analysis is relatively straightforward. There are however other communications with multiple origination points and or multiple termination points. Network analysis in such situations becomes significantly more complicated. Such network analysis is computationally intensive at least partly because there are nodes in the telecommunications network that may or may not be selected for carrying the communication.

The so called Steiner tree problem is applicable to these types of scenarios. Solving a Steiner tree problem can produce a routing that is satisfactory if not optimal for completing the communication among the many nodes that may possibly be used for interconnecting the origination and termination points. The Steiner tree problem is relevant to many different types of real world networks in addition to telecommunication networks. Unfortunately Steiner tree problems are notoriously difficult to solve even with appreciable computational resources.

Networks may be analyzed using Steiner trees. In an example embodiment a method includes acts of receiving accepting creating and analyzing. Data specifying a network is received. Steiner tree parameters are accepted. A Steiner tree model is created on the data specifying the network responsive to the Steiner tree parameters. The Steiner tree model includes a local representation having a depth constraint for neighborhood vertices. The data specifying the network is analyzed to ascertain a Steiner tree solution based on the Steiner tree model which includes the local representation and using a locally oriented combinatorial algorithm.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other systems methods devices media apparatuses arrangements and other example embodiments are described herein.

Solving a Steiner tree problem in the context of network analysis can produce a satisfactory if not optimal result. The Steiner tree problem which is named after Jacob Steiner is a problem in combinatorial optimization . It is a well known mathematical problem per se. The Steiner tree problem in simple terms may be set forth as follows given a set of vertices of a graph and a designated subset of the vertices interconnect the subset of vertices with a subgraph of minimum total weight. The total weight is the sum of the weights of each of the edges that interconnect the vertices of the subgraph. The vertices of the subgraph include the designated subset of vertices and may include any one or more other vertices selected from the overall set of vertices of the graph.

The Steiner tree problem has applications that include but are not limited to circuit layout or network design communication network e.g. Internet broadcasting or multicasting computational or network reconstruction for biology e.g. for phylogenetic trees for identifying regulatory sub networks of a set of genes etc. power or water distribution network design and so forth. Most versions of the Steiner tree problem are considered NP complete i.e. they are thought to be computationally hard and difficult to approximate. In practice heuristics are used to determine a solution that is optimal . In other words a particular solution may not be truly optimal in a purely logical or mathematical sense of the term but the particular solution may nevertheless be acceptable as being sufficiently good.

One common approximation to the Steiner tree problem is to compute a minimum cost spanning tree on the designated subset of vertices that is guaranteed to produce a solution with a total weight that is at most twice the true optimum solution. The currently best known approach to the problem is from Robins and Zelikovsky 2005 . Their approach produces a solution with a total weight that is at most 1.55 times the optimum. However their approach requires a purely global centralized scheme that is not suitable to parallel implementation.

In contrast for certain example embodiments Steiner tree problems may be solved using a localized scheme that is suitable for parallel implementation including using distributed systems. A locally oriented combinatorial algorithm may be employed. An example of a locally oriented combinatorial algorithm is the belief propagation algorithm.

Example implementations may be distributed stateless and or local. They may be distributed because each vertex may update its own beliefs independently of other vertices computations. They may be stateless because each new belief may be computed based on the most recently obtained beliefs with previous beliefs being discarded. Consequently changes in network topology can be gracefully handled. They may be local because each vertex may focus the message passing on its neighbors. A vertex may obtain messages from its neighbors and communicate its beliefs to its neighbors.

In an example embodiment an iterative technique is employed such that in each round each vertex sends to its neighboring vertices a probability vector that reflects its own belief s about i its position e.g. its depth in the tree from a fixed root and ii its parent vertex at that depth. Each vertex then proceeds to accumulate the belief vectors it obtains from its own neighbors and to re estimate its beliefs based on the newly obtained information. The technique then iterates until there is a convergence. Thus for certain example embodiments a message passing technique is used to solve Steiner tree problems in the context of network analysis.

In an example embodiment data specifying a network defines the vertices that form a network. The network may represent a real world network such as one of those listed herein above e.g. circuit biological communication distribution etc. . Steiner tree parameters designate which of the vertices are to be included in the interconnected subgraph or subnetwork. These vertices are called terminal vertices. Steiner tree solution describes the Steiner tree that is output as the solution. Example vertices edges and vertex types including terminal vertices are described herein below with particular reference to .

In an example operation data specifying a network and Steiner tree parameters are input to network analyzer . Network analyzer is to create a Steiner tree model on data specifying a network responsive to Steiner tree parameters . The Steiner tree model includes or is based on local representation . Local representation has a depth constraint for neighborhood vertices. Examples of this depth constraint are described further herein below with particular reference to .

Network analyzer is to analyze data specifying a network to ascertain Steiner tree solution using a locally oriented combinatorial algorithm based on the Steiner tree model. Using a locally oriented combinatorial algorithm to perform a network analysis with a Steiner tree enables distributed and or parallel schemes to be employed. Network analyzer outputs Steiner tree solution e.g. for transmission storage presentation to a user etc. .

In at graph B some of general vertices have been identified as terminal vertices . Terminal vertices are shown as squares and are to be included in the Steiner tree solution. Hence Steiner tree parameters of may designate terminal vertices . It should be understood that a network represented by graphs A D may include a different number of total general vertices different numbers of other vertex types a different configuration and so forth.

In at graph C some of the non terminal general vertices have been selected to be Steiner vertices . Steiner vertices are shown as stars. Steiner vertices are those general vertices that are selected during the network analysis for use in interconnecting terminal vertices . Typically general vertices are selected to be Steiner vertices in an effort to produce a low weight Steiner tree solution. Terminal vertices and Steiner vertices are interconnected by edges . Each edge usually has a corresponding weight not explicitly shown in . The sum of the weights of edges that interconnect the Steiner tree is the total weight of the Steiner tree solution.

In at graph D an edge pointer is associated with each edge not separately indicated in . Each edge pointer has a direction pointing from one originating vertex to another distal vertex. Graph D also indicates a root vertex . In an example Internet multicasting implementation root vertex may be a node that initiates a multicasting session. By convention root vertex has an edge pointer that points to itself. As shown each edge pointer points in a direction along the tree toward root vertex . However each edge pointer may alternatively point in directions away from root vertex .

Specifically data specifying a network includes general vertices and edge weights . Steiner tree parameters include terminal vertices . Steiner tree solution includes Steiner tree vertices Steiner tree edge pointers and a total weight of the Steiner tree. Steiner tree vertices of Steiner tree solution include terminal vertices and Steiner vertices .

In an example embodiment data specifying a network defines the network with general vertices and edge weights that correspond to the edges between any two of general vertices . Alternatively data specifying a network may define the network using edge indicators. Edge weights may represent a cost a length a bandwidth a delay a QoS a value a reliability some combination thereof and so forth.

Steiner tree parameters designate which of the vertices are to be included in the interconnected subgraph by identifying terminal vertices . Total weight of the Steiner tree solution is the sum of a subset of edge weights for the edges that interconnect the subgraph that is produced by the network analysis. Specifically it is the sum of the edge weights that correspond to Steiner tree edge pointers .

Data specifying a network Steiner tree parameters and Steiner tree solution may include different e.g. fewer more and or alternative components than those that are illustrated. For example data specifying a network may include each possible edge for the network being specified and edge weights that are associated therewith. As another example Steiner tree solution may include Steiner tree edge pointers while omitting Steiner tree vertices and or total weight of the Steiner tree solution.

It should be noted that the acts of the various flow diagrams that are described herein may be performed in many different environments and with a variety of different devices such as by one or more processing devices e.g. of . The orders in which the methods are described are not intended to be construed as a limitation and any number of the described blocks can be combined augmented rearranged and or omitted to implement a respective method or an alternative method that is equivalent thereto. Although specific elements of certain other FIGS. are referenced in the description of the flow diagrams the methods may be performed with alternative elements.

For certain example embodiments starting at block data specifying a network is received as input. For example data specifying a network may be received as input to network analysis . At block Steiner tree parameters are accepted as input. For example Steiner tree parameters may be accepted as input. Steiner tree parameters may designate terminal vertices .

At block a Steiner tree model is created on the data specifying the network responsive to the Steiner tree parameters with the Steiner tree model including a local representation having a depth constraint for neighborhood vertices. For example network analyzer may create a Steiner tree model on data specifying a network responsive to Steiner tree parameters . The Steiner tree model may include local representation of that has a depth constraint for neighborhood vertices.

At block the data specifying the network is analyzed to ascertain a Steiner tree solution i based on the Steiner tree model that includes the local representation and ii using a locally oriented combinatorial algorithm. For example network analyzer may analyze data specifying a network to ascertain Steiner tree solution i based on the Steiner tree model that includes local representation and ii using a locally oriented combinatorial algorithm. Examples of Steiner tree models local representations depth constraints and locally oriented combinatorial algorithms that may be utilized are described further herein below with particular reference to .

At block the Steiner tree solution is provided as output of the act of analyzing. For example the providing may include storing Steiner tree solution in a memory transmitting Steiner tree solution over a communication link presenting Steiner tree solution some combination thereof and so forth. Presenting may include for instance displaying printing etc. Steiner tree solution to a user.

In an example system embodiment a system is to analyze networks with Steiner trees. The system may include data specifying a network and Steiner tree parameters both of . The system includes a network analyzer that has a Steiner tree model creator and a Steiner tree solution ascertainer . Steiner tree model creator is to create a Steiner tree model on data specifying a network responsive to Steiner tree parameters . Steiner tree model is to include a local representation having a depth constraint for neighborhood vertices. Steiner tree solution ascertainer is to analyze data specifying a network to ascertain a Steiner tree solution of based on Steiner tree model which is to include local representation and using a locally oriented combinatorial algorithm .

Examples of locally oriented combinatorial algorithms include but are not limited to cluster variation by Kikuchi survey propagation neighborhood greedy decision making general belief propagation tree reweighted belief propagation other variations of belief propagation including those with convex free energies a combination or derivative thereof and so forth. Depth constraint can enable a Steiner tree having global constraints to be modeled with local constraints. The other components introduced in network analysis of are described further herein below.

As noted above by creating a Steiner tree model including a local representation the global Steiner tree problem may be solved using a distributed system and or a parallel scheme. When an embodiment is implemented as processor executable instructions they may be adapted to be executed in parallel and or with a distributed system. A distributed system may entail multiple threads a multi core processor a multi processor device a multiple device system e.g. coupled over a network a combination thereof and so forth. Moreover a network analysis involving a Steiner tree may be distributed geographically and or temporally.

Generally given a graph representing some network finding a subgraph that optimizes some global weight function is a problem that is relevant to many fields. An example version of this problem is known as the Minimum Weight Steiner Tree MST problem. As noted above a particular Steiner tree solution may not provide the actual minimum weight or the true optimum solution but may nevertheless be considered an acceptable Steiner tree solution.

Given a weighted graph finding a Steiner tree solution of entails ascertaining a connected subgraph of minimum weight that contains a designated set of terminal vertices of . The weight corresponding to an edge ij is denoted by c. The production of a Steiner tree solution may involve the inclusion of some non terminal general vertices which are referred to as the Steiner vertices . The sub graph forming the Steiner tree solution is an actual tree in other words cycles are absent from the output of the analysis.

An example network analysis with a Steiner tree that involves an internet multicasting implementation is described below. In this example network multicasting application there is one source of content such as video content that can be represented as a source vertex in a network graph. There are links between many of the nodes in the network. The nodes correspond to and are represented by vertices of the graph and the links correspond to and are represented by edges of the graph. Routers in a network over which the video content is multicast can also be represented as vertices. From one to many end users can be represented by vertices as well. Users that request delivery of the multicast content may be designated as terminal vertices.

For each link there is a Quality of Service QoS measurement. The QoS may include any of many possible attributes that are associated with the link such as delay bandwidth reliability length network charges combinations thereof and so forth. A cost can be assigned to each link based on the QoS. The cost corresponds to and may be represented by weights corresponding to the edges. Each path from the source node e.g. the root vertex to a user node e.g. a terminal vertex can be assigned a cost e.g. a weight that is the total of the costs e.g. weights corresponding to each link e.g. edge included in the path.

A goal is to find an optimum solution by interconnecting a subset of the vertices e.g. at least the terminal vertices such that a minimum of weights is used. In practice an acceptable solution is ascertained with a heuristic approach in a reasonable period of time. The following describes example embodiments to ascertain acceptable Steiner tree solutions.

Although embodiments of the invention may be practiced with locally oriented combinatorial algorithms generally an example embodiment is described below in the context of a belief propagation algorithm. The belief propagation algorithm like certain other locally oriented combinatorial algorithms may be employed to implement a message passing algorithm for analyzing a network with Steiner trees when the Steiner tree is modeled using a local representation . In this example the Steiner tree problem has an arborescent representation. The global constraint of connectivity for the Steiner tree is represented in terms of local constraints. This makes the locally oriented belief propagation algorithm applicable to the global problems presented by Steiner tree analysis.

It should be noted that belief propagation equations are by construction purely local and that the constraints underlying the Steiner tree problem are global i.e. ensuring the overall connectivity of the tree is a global problem . An appropriate transformation of belief propagation equations specifically the so called max sum equations enables a set of iterative equations to be derived that can be computed efficiently. This transforms belief propagation into an efficient solver of Steiner tree problems.

The Steiner tree problem is modeled as a rooted tree such a construction is often associated with the term arborescence . Each edge i j e.g. Steiner tree edge between vertices i and j is associated with a pair of variables x d . The variables x 1 0 define a set of arrows that are referred to herein as edge pointers . If x 1 vertex i points to vertex j. If on the other hand x 1 vertex j points to vertex i. If x 0 the vertices i and j do not point to each other. Thus x 0 if j does not belong to the neighborhood V i of i. For a given vertex each other vertex that has an edge between it and the given vertex is in the given vertex s neighborhood.

Herein the variable d 0 . . . D represents the depth e.g. depth of the edge ij from the root. This depth relates to the depth of the originating vertex of the pair i.e. the vertex from which the edge pointer originates as opposed to the distal vertex at the other end of the edge pointer . The depth of the root vertex is set to zero. For the depths of other vertices a respective depth for a respective vertex is measured by a distance from the root vertex along a unique oriented path from the respective vertex to the root vertex.

To solve the Steiner tree problem each of the terminal vertices is to point to some other vertex in the final Steiner tree solution . Consequently the associated x variables of each edge pointer of each of the terminal vertices have some non zero entry e.g. 1 or 1 . As noted above the root vertex conventionally points to itself. Non terminal general vertices either point to some other vertex in their neighborhood V i or do not point to any other vertex. More specifically if a general vertex is part of the Steiner tree solution e.g. it is a terminal vertex or a Steiner vertex it points to another vertex in its neighborhood V i . If a general vertex is not part of the Steiner tree solution it does not point to any vertex in the network s graph this is permitted for non terminal general vertices and is not part of the resulting subgraph.

In example embodiments to impose a global connectivity constraint for the Steiner tree model the following local condition is imposed if x 1 then d d 1 for any k V i is imposed. In words if an edge pointer points from vertex i to vertex j then the depth for any vertex in the neighborhood of vertex i that points to vertex i is one greater than the depth of vertex i. This depth constraint may be rephrased as the depth of any given vertex is one more than the depth of the vertex that it points to. If a non terminal vertex does not point to any other vertex then there is no constraint on its depth. Alternatively phrased for a given vertex that points to another vertex the depth of the given vertex is one less than a depth of each vertex in the given vertex s neighborhood that points to the given vertex. This depth constraint prohibits cycles a.k.a. loops and ensures that the selected edges form a tree.

In building equations to implement a locally oriented combinatorial algorithm example characteristic functions are introduced. These characteristic functions mathematically realize depth constraint . They impose depth constraints over configurations of the independent variables x d. An example depth constraint function is shown in equation 1 

At block for a particular edge one or more messages relating to depth are passed to one or more other edges. For example messages may be passed that reflect a particular edge s belief s about i its depth in the current Steiner tree iteration from a fixed root vertex and ii its parent vertex at that depth. Formulation of messages and their communication to neighborhood edges may be effectuated using for instance max sum equations . At block a depth constraint is enforced. For example a depth constraint may be enforced using a characteristic function from equation 1 . The depth constraint may also be incorporated into and thus enforced in conjunction with a set of max sum equations e.g. max sum equations that are used to form the messages that are passed to vertices in a given vertex s neighborhood. At block the message passing of block and the depth constraint enforcement of block are repeated for each edge of the graph in the current ordering .

At block local weights are computed for each edge. For example local weights may be computed based on marginal weight equations . At block a subgraph is constructed. For example a subgraph may be constructed by selecting edges for inclusion in the subgraph responsive to maximum values from the marginal weight equations.

At block the procedure is iterated until the weights of the subgraph converge. For example the procedure may be repeated from the act of randomly ordering the edges of the graph until the message passing produces a stable configuration for the subgraph. At block upon convergence the subgraph is output as the Steiner tree solution. For example when the marginal weight equations reach convergence the subgraph may be output as the Steiner tree solution .

This subsection describes additional example details for a belief propagation version in terms of the max sum equations . Messages indicating a belief as to a current depth are passed between each vertex and its neighbors. The form of messages that are sent from vertex i along edge ij are denoted by x d . This describes the cost change for adding an edge ij of weight cwith a given configuration x d.

Three equations A B and C are introduced. These three equations are A x 1 d d B x 1 d d and C x 0 d . With these three equations max sum equations may be expressed as shown below at equations 2a 2b 2c and 2d 

Upon convergence the messages reach a fixed configuration. From this fixed configuration the x d variables can be extracted from the complete local weights which are defined as shown below. These marginal weight equations may be expressed as follows at equation 3 1 1 0 3 by choosing the argmax.

From time to time even after much iteration of the max sum equations they may not converge on their own in a given problem instance. However they may be modified to reach converged solutions in those cases in which the equations might tend to otherwise have a chaotic evolution. In an example embodiment this modification entails applying a convergence mechanism .

In an example implementation convergence mechanism is implemented using a reinforcement term in the update equations. The reinforcement term adds to the current values of the messages a term proportional to the components of the complete local weight at the previous time step. More specifically the following terms multiplied by a proportionality constant are added to the four equations A B c B A c C Cand C C. This produces a set of equations that help provide good convergence properties for a wide range of choices of the proportionality constant. An example implementation of using the reinforcement term having a proportionality constant is described below with particular reference to .

Flow diagram is described in terms of the example pseudo code presented below. The pseudo code below may be implemented for an example embodiment of network analysis with a Steiner tree.

INPUT Two n by n arrays G W representing the graph G and weights c of the edges. A subset of the vertices of G denoted by T for terminals. An integer D between 1 to n 1 for the maximum depth. A real number g between 0 to 1 for a proportionality constant.

The variable g in the pseudo code above is an example implementation of a proportionality constant for the reinforcement terms. The reinforcement terms function as an example convergence mechanism . When g 1 the pseudo code above reduces to a belief propagation algorithm that may not converge in some problem instances. Introduction of the variable g

With reference to flow diagram of example embodiments of the pseudo code may be performed as follows. At block graph G weights W depth D and terminals T are read as input. At block messages A B C and marginal weights v are initialized by 0 according to phase 1 of the pseudo code above. Also the time variable t is set to 0.

At block a random ordering O of the edges of G are determined according to phase 2 a of the pseudo code. At block messages of the edges are updated with ordering O according to the max sum equations of phase 2 b of the pseudo code. At block the marginal weights v are updated according to the marginal weight equations of phase 2 c of the pseudo code. At block the subgraph H is computed by taking the maximum of the marginal weights according to phase 2 d of the pseudo code.

At block it is determined if the subgraph H has converged. If the subgraph H has not converged then at block the time variable t is incremented. If on the other hand the subgraph H is determined at block to have converged then at block the subgraph H is output from the network analysis as a Steiner tree solution.

For example embodiments device may represent any processing capable device. Examples of devices include personal or server computers hand held electronics entertainment appliances network components some combination thereof and so forth. Device and device may communicate over network s . Network s may be by way of example but not limitation an internet an intranet an Ethernet a public network a private network a cable network a digital subscriber line DSL network a telephone network a wireless network some combination thereof and so forth. Person device interface equipment may be a keyboard keypad a touch screen a remote a mouse or other graphical pointing device a screen a speaker and so forth.

I O interfaces may include i a network interface for monitoring and or communicating across network ii a display device interface for displaying information on a display screen iii one or more person device interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports a network communications stack a radio and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii person device interfaces include those that communicate by wire or wirelessly to person device interface equipment .

Processor may be implemented using any applicable processing capable technology and one may be realized as a general purpose or a special purpose processor. Examples include a central processing unit CPU a microprocessor a controller a graphics processing unit GPU an application specific integrated circuit ASIC a derivative or combination thereof and so forth. Media may be any available media that is included as part of and or is accessible by device . It includes volatile and non volatile media removable and non removable media storage and transmission media e.g. wireless or wired communication channels hard coded logic media combinations thereof and so forth. Media is tangible media when it is embodied as a manufacture and or as a composition of matter.

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device . Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth.

Thus realizations for network analysis with Steiner trees may be described in the general context of processor executable instructions. Processor executable instructions may include routines programs applications coding modules protocols objects components logic metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

As specifically illustrated media comprises at least processor executable instructions . Processor executable instructions may comprise for example network analyzer of and Steiner tree model of a locally oriented combinatorial algorithm of logic implementing the pseudo code described herein some combination thereof and so forth. Generally processor executable instructions when executed by processor enable device to perform the various functions described herein. Such functions also include by way of example but not limitation those that are illustrated in the various flow diagrams and those pertaining to features illustrated in the block diagrams as well as combinations thereof and so forth.

The devices acts features functions methods modules data structures techniques components etc. of are illustrated in diagrams that are divided into multiple blocks and other elements. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks and or other elements can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices media apparatuses arrangements etc. for network analysis with Steiner trees.

Although systems methods devices media apparatuses arrangements and other example embodiments have been described in language specific to structural logical algorithmic and or functional features it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claimed invention.

