---

title: Methods and systems for providing, to a first application executed by a first operating system, an interface for communicating with at least one application executed by a second operating system
abstract: A method for providing, to a first application executed by a first operating system, an interface for communicating with at least one application executed by a second operating system includes providing, by a first interface object executed by the first operating system, a mechanism for external communication with a first application executed by the first operating system. A second interface object executed by the second operating system provides a mechanism for external communication with a window handler executed by the second operating system. The first interface object receives an identification of a window displayed by the first operating system and generated by a second application executed by the second operating system and requests, from the second interface object, analysis of the identified window. The first interface object receives, from the second interface object, an identification of contact information displayed by the window resulting from the analysis by the window handler.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938743&OS=08938743&RS=08938743
owner: Citrix Systems, Inc.
number: 08938743
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20081222
---
The present application claims priority to U.S. Provisional Patent Application Ser. No. 61 016 025 entitled Systems and Methods for Obtaining Communications Data filed Dec. 21 2007 which is incorporated herein by reference.

This disclosure relates generally to providing interfaces between remotely executing applications. In particular this disclosure relates to systems and methods for providing to a first application executed by a first operating system an interface for communicating with at least one application executed by a second operating system.

Prior efforts have been made to provide a system and method that allows end users to establish communication sessions from a computing device. These systems and methods include those that establish and facilitate communication via a communication application dedicated to the task of managing the communication and those that establish communications using a website with phone numbers a web server and a dialing application. Still other systems and methods include those that retrieve phone numbers from application output data within a window and further use the retrieved phone numbers to establish communications via a communication agent. In such systems and methods each window displayed on a particular display device is searched for text string sequences similar to those of a phone number regardless of whether or not the window is likely to contain contact information. Alternatively if a window is generated by an application executing on a remote machine but displayed on the computing device conventional systems do not typically provide functionality for analyzing the remotely generated window for contact data.

In one aspect a method for providing to a first application executed by a first operating system an interface for communicating with at least one application executed by a second operating system includes providing by a first interface object executed by a first operating system a mechanism for external communication with a first application executed by the first operating system. The method includes providing by a second interface object executed by a second operating system a mechanism for external communication with at least one window handler routine executed by the second operating system. The method includes receiving by the first interface object an identification of a window displayed by the first operating system and generated by a second application executed by the second operating system. The method includes requesting by the first interface object from the second interface object analysis of the identified window. The method includes directing by second interface object analysis of data displayed in the window by the at least one window handler routine. The method includes receiving by the first interface object from the second interface object an identification of contact information displayed by the window resulting from the analysis by the at least one window handler routine.

In one aspect a system for providing to a first application executed by a first operating system an interface for communicating with at least one application executed by a second operating system includes a first interface object at least one window handler routine and a second interface object. The first interface object executed by a first operating system provides a mechanism for external communication with a first application executed by the first operating system and receives an identification of a window displayed by the first operating system and generated by a second application executed by a second operating system. The at least one window handler routine executed by the second operating system includes a receiver an analysis engine and a transmitter. The at least one window handler receives a request from the first interface object via a second interface object executed by the second operating system and providing a mechanism for external communication with the at least one window handler routine. The at least one window handler analyzes data displayed in the window. The at least one window handler transmits to the first interface object via the second interface object an identification of contact information displayed by the window.

Referring now to a block diagram depicts one embodiment of an environment for providing voice communication e.g. a voice call . The environment includes a plurality of end users A B C D generally referred to end user that communicate using one or more of a mobile network a packet switched network and a circuit switched network . One of the end users is in communication with a communication gateway via at least one network . The communications gateway is in communication with a private branch exchange PBX . The PBX is in communications with one or more of the mobile network the packet switched network and the circuit switched network . The communications gateway and the PBX may communicate with each other via a second network . In one embodiment the first network and the second network are the same network. The second network can include one or more of each of a QSIG trunk an H.323 trunk and a SIP trunk. QSIG refers to the ISDN based signaling protocol for signaling between nodes of a Private Integrated Services Network PISN . The QSIG protocol carries user and feature information between private branch exchanges. H.323 refers to the ITU standard that defines a framework of protocols for inter working voice video and data across an IP network. SIP refers to the Session Initiation Protocol which is used for setting up communications sessions on the Internet such as telephony presence events notification and instant messaging. The SIP protocol initiates call setup routing authentication and other feature messages to endpoints within an IP domain.

Each end user can have a computing device executing software that provides at least some of the below described functionality. The end user interacts with the computing device to cause the computing device to for example issue commands to the communications gateway which in turn issues commands to the PBX to establish a voice communication session with at least one other end user .

The first network and the second network can be a local area network LAN a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. In one embodiment a network may be a private network and a network may be a public network. In another of these embodiments a network may be a private network and a network a public network. In still another embodiment networks and may both be private networks. In yet another embodiment networks and may both be public networks.

The network may be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network may be a bus star or ring network topology. The network and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein. The network may comprise mobile telephone networks utilizing any protocol or protocols used to communicate among mobile devices including AMPS TDMA CDMA GSM GPRS or UMTS. In some embodiments different types of data may be transmitted via different protocols. In other embodiments the same types of data may be transmitted via different protocols.

In one embodiment the system may include multiple logically grouped servers. For example the communications gateway the PBX and machines in the mobile network the packet switched network or the circuit switched network may be provided as one or more servers. In some embodiments a logical group of servers may be referred to as a server farm. In some of these embodiments the servers may be geographically dispersed. In others of these embodiments a farm may be administered as a single entity. In still others of these embodiments the server farm comprises a plurality of server farms. In further embodiments the server farm executes one or more applications on behalf of one or more end users . A server may be a file server application server web server proxy server appliance network appliance gateway application gateway gateway server virtualization server deployment server SSL VPN server or firewall. In some embodiments a server provides a remote authentication dial in user service and is referred to as a RADIUS server. In other embodiments a server may have the capacity to function as either an application server or as a master application server. In still other embodiments a server is a blade server. In yet other embodiments a server executes a virtual machine providing to a user or computing device access to a computing environment.

In one embodiment a server may include an Active Directory. The server may be an application acceleration appliance. For embodiments in which the server is an application acceleration appliance the server may provide functionality including firewall functionality application firewall functionality or load balancing functionality. In some embodiments the server comprises an appliance such as one of the line of appliances manufactured by the Citrix Application Networking Group of San Jose Calif. or Silver Peak Systems Inc. of Mountain View Calif. or of Riverbed Technology Inc. of San Francisco Calif. or of F5 Networks Inc. of Seattle Wash. or of Juniper Networks Inc. of Sunnyvale Calif.

The computing device connects to the network via communications link using any one of a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 broadband connections ISDN Frame Relay ATM and wireless connections. In some embodiments the computing device of the end user connects to the communications gateway through an additional network not shown using another communication link that connects the network to the additional network. The protocols used to communicate through the communications link can include any variety of protocols used for long haul or short transmission. For example TCP IP IPX SPX NetBIOS NetBEUI SONET and SDH protocols or any type and form of transport control protocol may also be used such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCPSACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used. The combination of the networks can be conceptually thought of as the Internet. As used herein Internet refers to the electronic communications network that connects computer networks and organizational computer facilities around the world.

The packet switched network communicates directly or indirectly with the PBX . As used herein a packet switched network refers to a data communications network where information e.g. voice and data is divided into packets and delivered to their destination separately and possibly via different paths. Some packet switched networks provide voice IP VoIP functionality. The PBX can provide telephone services to end users having telephone devices terminated on the packet switched network . As used herein telephone devices refers telephones fax machines computers IP phones soft phones video phones mobile phones wlan phones or other devices capable of transmitting and receiving audible information.

The circuit switched network also communicates directly or indirectly with the PBX . As used herein circuit switched refers to routing traffic between an originator and a destination through switching centers from local users or from other switching centers whereby a continuous electrical circuit is established and maintained between the calling and called stations until it is released by one of those stations. For example the switched circuit network can be the public switched telephone network PSTN . The PBX can provide telephone services to end users having telephone devices terminated on the circuit switched network .

The mobile network communicates directly or indirectly with the PBX . As used herein mobile network refers to facilities operated by a telephony carrier for the purposes of providing public mobile telecommunications services. The PBX can provide telephone services to enterprise subscribers having telephone devices terminated on the mobile switched network .

As an operational summary the PBX interfaces to one or more of the mobile network the packet switched network and the circuit switched network and to the communications gateway . An end user initiates a request for a communications session with another end user . In response the computing device of the end user issues a signal e.g. a command to the communications gateway . In response the communications gateway establishes communications with the PBX and issues a signal e.g. a command to the PBX to establish a communications session between the end users . In such an embodiment the communications session is established and hosted by the PBX .

The computing devices communications gateway and PBX may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein or known in the art. As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device which can control a cursor such as a mouse. Each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client software or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to a client software package . Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 SNA DECNET broadband connections e.g. ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET ADSL SDSL wireless connections or some combination of any or all of the above. Connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET SONET SDH Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g CDMA GSM WiMax and direct asynchronous connections . In one embodiment the computing device communicates with other computing devices via any type and or form of gateway or tunneling protocol such as Secure Socket Layer SSL or Transport Layer Security TLS or the Citrix Gateway Protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein.

A wide variety of I O devices may be present in the computing device some of which may function as pointing devices. Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the MICROSOFT Windows operating systems the different releases of the Unix and Linux operating systems any version of the MAC OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE WINDOWS XP and WINDOWS VISTA all of which are manufactured by Microsoft Corporation of Redmond Wash. MAC OS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

The computer system can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone or other portable telecommunication device media playing device a gaming system mobile computing device or any other type and or form of computing telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. For example the computer system may comprise a device of the IPOD family of devices manufactured by Apple Computer of Cupertino Calif. a PLAYSTATION 2 PLAYSTATION 3 or PERSONAL PLAYSTATION PORTABLE PSP device manufactured by the Sony Corporation of Tokyo Japan a NINTENDO DS NINTENDO GAMEBOY NINTENDO GAMEBOY ADVANCED or NINTENDO REVOLUTION device manufactured by Nintendo Co. Ltd. of Kyoto Japan or an XBOX or XBOX 360 device manufactured by the Microsoft Corporation of Redmond Wash.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a TREO 180 270 1060 600 650 680 700p 700w wx 750 755p 800w Centro Pro smart phone manufactured by Palm Inc. In this embodiment the TREO smart phone is operated under the control of the PALM OS operating system and includes a stylus input device as well as a five way navigator device.

In other embodiments the computing device is a mobile device such as a JAVA enabled cellular telephone or personal digital assistant PDA such as the i55sr i58sr i85s i88s i90c i95c1 i335 i365 i570 1576 i580 i615 i760 i836 i850 i870 i880 i920 i930 ic502 ic602 ic902 i776 or the im1100 all of which are manufactured by Motorola Corp. of Schaumburg Ill. the 6035 or the 7135 manufactured by Kyocera of Kyoto Japan or the i300 or i330 manufactured by Samsung Electronics Co. Ltd. of Seoul Korea. In some embodiments the computer system is a mobile device manufactured by Nokia of Finland or by Sony Ericsson Mobile Communications AB of Lund Sweden.

In still other embodiments the computing device is a Blackberry handheld or smart phone such as the devices manufactured by Research In Motion Limited including the Blackberry 7100 series 8700 series 7700 series 7200 series the Blackberry 7520 the Blackberry PEARL 8100 the 8700 series the 8800 series the Blackberry Storm Blackberry Bold Blackberry Curve 8900 Blackberry Pearl Flip. In yet other embodiments the computing device is a smart phone Pocket PC Pocket PC Phone or other handheld mobile device supporting Microsoft Windows Mobile Software. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

The computing devices may also be referred to as client nodes client machines endpoint nodes or endpoints. In some embodiments a computing device has the capacity to function as both a client node seeking access to resources provided by a server and as a server providing access to hosted resources for other computing devices .

A computing device may execute operate or otherwise provide an application which can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on the computing device . In some embodiments the application may be a server based or a remote based application executed on behalf of the computing device on a server. In one embodiment the server may display output data to the computing device using any thin client or remote display protocol such as the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash. the X11 protocol the Virtual Network Computing VNC protocol manufactured by AT T Bell Labs the SPICE protocol manufactured by Qumranet Inc. of Sunnyvale Calif. USA and of Raanana Israel the Net2Display protocol manufactured by VESA of Milpitas Calif. the PC over IP protocol manufactured by Teradici Corporation of Burnaby B.C. the TCX protocol manufactured by Wyse Technology Inc. of San Jose Calif. the THINC protocol developed by Columbia University in the City of New York of New York N.Y. or the Virtual D protocols manufactured by Desktone Inc. of Chelmsford Mass. The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In other embodiments the application comprises any type of software related to voice over internet protocol VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

In some embodiments the client software provides functionality related to establishing a communication session such as a telephone call a voice over IP call a chat session an e mail session or other communications session. In one of these embodiments the client software can provide the end user of the client with functionality that allows the end user to click a telephone number or other recognized pattern within output of a software application and call that telephone number. Upon selection of the telephone number the client computer signals the communications gateway to issue commands to the PBX which in turn establishes the communication session. In addition the end user can edit the telephone number prior to establishing the call and also designate a phone number that the end user wants to be called at if the end user is away from their telephone that is associated with the PBX . Furthermore the client software may perform directory traversal to locate numbers that are not located in the application output displayed by a window but instead are stored in one or more heterogeneous or homogenous directory services e.g. MICROSOFT OUTLOOK contacts and other directory sources . Additional details of the client software are described below.

Referring now to a block diagram depicts one embodiment of client software . In brief overview the client software includes a cursor detection hooking mechanism a plurality of window handlers referred to generally as processes handler a parser module a call routine and one or more directory handlers. Each of these modules can communicate with each other directly or indirectly using known programming techniques. In some embodiments the cursor detection hooking mechanism is optional. In other embodiments the directory handlers are optional. In further embodiments one or more of each or any of the components may be provided on one or more software applications .

Referring now to and in greater detail the cursor detection mechanism comprises any logic function and or operations to detect a status movement or activity of a cursor or pointing device on the screen of the client computing device . The cursor detection mechanism may comprise software hardware or any combination of software and hardware. In one embodiment the cursor detection mechanism comprises an application a program a library a process a service a task or a thread. In another embodiment the cursor detection mechanism may include an application programming interface API hook into the operating system to obtain or gain access to events and information related to a cursor and its movement on the screen. In still another embodiment using an API hooking technique the client software and or cursor detection mechanism monitors and intercepts operating system API calls related to the cursor and or used by applications. In some embodiments the cursor detection mechanism API intercepts existing system or application s functions dynamically at runtime.

In one embodiment the cursor detection mechanism may include any type of hook filter or source code for receiving cursor events or run time information of the cursor s position on the screen or any events generated by button clicks or other functions of the cursor. In another embodiment the cursor detection mechanism may comprise any type and form of pointing device driver cursor driver filter or any other API or set of executable instructions capable of receiving intercepting or otherwise accessing events and information related to a cursor on the screen. In still another embodiment the cursor detection mechanism detects the position of the cursor or pointing device on the screen such as the cursor s x coordinate and coordinate on the screen. In yet embodiment the cursor detection mechanism detects tracks or compares the movement of the cursor s X coordinate and Y coordinate relative to a previous reported or received X and Y coordinate position.

In one embodiment the cursor detection mechanism comprises logic functionality and or operations to detect if the cursor or pointing device is idle or has been idle for a predetermined or predefined length of time. In another embodiment the cursor detection mechanism detects that the cursor has been idle for a predetermined length of time between 100 ms and 1 sec such as 100 ms 200 ms 300 ms 400 ms 500 ms 600 ms 700 ms 800 ms or 900 ms. In still another embodiment the cursor detection mechanism detects that the cursor has been idle for a predetermined length of time of approximately 500 ms such as 490 ms 495 ms 500 ms 505 ms or 510 ms. In still even another embodiment the predetermined length of time to detect and consider the cursor is idle is set by the cursor detection mechanism . In yet another embodiment the predetermined length of time is configurable by a user or an application via an API graphical user interface or command line interface.

In some embodiments a sensitivity of the cursor detection mechanism may be set such that movements in either the X or Y coordinate position of the cursor may be received and the cursor still detected and or considered idle. In one of these embodiments the sensitivity may indicate the range of changes to either or both of the X and Y coordinates of the cursor which are allowed for the cursor to be considered idle by the cursor detection mechanism . For example if the cursor has been idle for 200 ms and the user moves the cursor a couple or a few pixels coordinates in the X and or Y direction and then the cursor is idle for another 300 ms the cursor detection mechanism may indicate the cursor has been idle for approximately 500 ms.

The window handler analyzes the contents of application output displayed in a window on a display device of a computing device. In one embodiment a resource executing on the computing device generates application output data and directs the display to a user of the computing device of the generated application output data. In another embodiment the application output data is displayed within a window associated with an application executing on the computing device .

In some embodiments each window handler interacts with a single type of application. In one of these embodiments a separate window handler may be provided for each of a type of application such as for example an internet browsing application such as for example MICROSOFT INTERNET EXPLORER a word processing application such as for example MICROSOFT WORD or a spreadsheet application such as for example MICROSOFT EXCEL . In another of these embodiments a separate window handler may be provided for each of a type of field such as for example an Edit field this includes applications providing notepad functionality or a Static text field. In still another of these embodiments additional window handlers are included for other applications e.g. portable document format reader applications such as ADOBE reader presentation generation and viewing applications such as MICROSOFT POWERPOINT and the like . In still even another of these embodiments a window handler that processes a specific type of application may be referred to as an application specific window handler . In other embodiments a single window handler can interact with multiple applications that have similar characteristics. In one of these embodiments there may be fewer application specific handlers than there are resources generating application output data for display.

In some embodiments when the pointer is idle the client software initiates each of the window handlers . In other embodiments only a subset of the window handlers is initiated. In one of these embodiments the client software determines which window is active and thus which application is producing output displayed in the active window. In another of these embodiments the client software transmits to a window handler at least one of a window identifier window identification information and application type. In still another of these embodiments the window handler determines whether or not it includes functionality for processing application output data in the identified window. In still even another of these embodiments a first window handler responds with an indication that it cannot process the application output data at which point a second window handler is called. In further embodiments when a window handler is initiated if the window handler includes functionality for processing application output data displayed in the window the window handler determines whether a specific pattern of characters exists within a specific area determined relative to the location of the cursor such as within a window near the cursor which is described in more detail below with reference to .

In one embodiment and for example if the active window is a static window a window handler retrieves text from within the application using a WM GETTEXT message the window handler analyzes the returned contents for patterns. In another embodiment the parser analyzes the returned contents for patterns. If in one example a telephone number is found the software displays the identified telephone number to the end user. In still another embodiment and as another example if an edit window is the active window the window handler uses EM  messages that are a part of the operating system API text that is in the vicinity of the pointer location is returned using the WM GETTEXT and EM CHARFROMPOS messages.

In one embodiment if the active window is a browser window such as a MICROSOFT INTERNET EXPLORER window the window handler extracts the underlying HTMLDocument2 object from the window using the WM HTML GETOBJECT message. The window handler then traverses the HTML to get the IHTMLBodyElement object from which an IHTMLTxtRange object can be extracted containing the text under the location of the pointer. In another embodiment if the active window is a word processing window such as a MICROSOFT WORD window an application specific window handler extracts the underlying IID Window object from the window using the AccessibleObjectFromWindow API method. From that object the RangeFromPoint method returns an IID Range object containing the text at the location of the pointer.

In some embodiments none of the window handlers include functionality for analyzing application output data of an identified window. In one of these embodiments a default window handler is called. In another of these embodiments the default window handler performs screen captures or screen scraping object character recognition and pattern matching.

Referring now to a block diagram depicts one embodiment of a system including a plurality of routines for processing window information to obtain communication information for establishing and facilitating a communication session. In one embodiment each routine within the plurality of routines is assigned a priority. In another embodiment each of the routines is executed sequentially and a routine with a higher priority executes before a routine with a lower priority. In still another embodiment the routine with the highest priority is the window handler filter routine .

Referring now to and in more detail the system includes a plurality of routines . In one embodiment an execution of the software generates the system . In another embodiment a system is provided within a virtual machine executing on the computing device . In still another embodiment a system is provided by an execution of a software routine or software application executing on a network and in communication with other software routines software applications computing devices and virtual machines also resident on the network. In yet another embodiment the system includes a single window handler routine able to execute at least one sub routines dedicated to executing window handler routines configured to analyze and interpret window information. In some embodiments a system includes a single routine able to execute multiple sub routines where each sub routine is encapsulated in a plug in software application. In one of these embodiments the plug in software application s may reside in any of the following locations within the software within the computing device on a network such as network on a device located on the network on a virtual machine on the network in a storage repository accessible via the network or any other local or remote location able to be accessed by an application or routine executing within the system .

In one embodiment a plurality of routines is included within the system . In another embodiment the system includes a plurality of routines where each routine can be any of the following a software application a software program a set of commands or any other collection of instructions able to receive and process input to generate a responsive output. In still another embodiment the routines included within the plurality of routines may be any of the above mentioned application specific window handlers and

In one embodiment the plurality of routines includes any of the above mentioned application specific window handlers as well as a window handler filter routine . In another embodiment the plurality of routines includes both the above mentioned application specific window handlers a window handler routine and other window handler routines able to utilize window information to obtain communication information and or to determine an optimal method for obtaining communication information.

In some embodiments the system includes a plurality of routines where each routine is assigned a priority. Assignment of the priority can in one of these embodiments be a result of user input designating a priority scheme and further assigning a priority to each routine. In another of these embodiments a priority scheme is used in which a priority assigned to each window handler routine is a result of at least one determination indicative of the necessity that a particular routine execute prior or subsequent to another routine included within the plurality of routines . For example the system may de prioritize a window handler routine that captures data displayed in a region of a screen applies a process for optical character recognition and analyzes the OCR data for contact information and the system may assign a higher priority level to a window handler routine implementing a more efficient process for identifying contact information. In such an embodiment the at least one determination can be generated by any of the following an arbiter application utilizing both system and routine information to determine a priority and further assign the determined priority to a routine an application compiling system statistics to determine a priority and further assign the determined priority to a window handler routine an application able to receive user input indicative of a particular priority level and further assign that priority level to a user specified window handler routine a lookup table including identification information for each window handler routine and a table of priorities where identification information for each window handler routine is linked to a particular priority a listing of each window handler routine where the list further dictates the priority level for each window handler routine or any other system application or data specific method of determining the priority level of a window handler routine . In still another of these embodiments a plurality of window handler routine include a window handler filter routine having the highest priority level of any window handler routine and subsequent window handler routine are arbitrarily assigned priority levels. In still even another embodiment the plurality of window handler routine includes a window handler filter routine having a priority level that is higher than subsequent window handler routines . The priority level in one embodiment can be any of the following values a numeric value a percentage value a value based on prior and subsequent routines in the chain of priorities or any other value able to indicate a routines priority in relation to other routines included within a plurality of window handler routine .

Referring now to a system for efficient processing of data displayed by a window includes a window and a window handler filter routine. In brief overview a window is displayed to a user of a computing device . The window handler filter routine obtains window identification information associated with the window . The window handler filter routine prevents operation on application output data displayed in the window by a window handler routine when the window identification information associated with the window represents a type of window listed within a list of types of window.

Referring now to and in greater detail the window handler filter routine in one embodiment is a routine that preempts the processing of application output data displayed by a window . In another embodiment the window handler filter routine accesses a list of types of windows to determine whether the window is a type of window that a window handler routine should analyze to determine whether the application output data displays contact information. In still another embodiment the list specifies a list of windows for which the system has determined that no analysis by a window handler routine is required for example a predefined list created by an administrator may specify which types of windows the administrator knows do not contain contact information. In some embodiments the window handler filter routine includes programming code containing the list. In other embodiments the window handler filter routine accesses a file containing the list.

In some embodiments the window handler filter routine includes functionality for obtaining window identification information associated with the displayed window the window identification information indicative of a type of the window. In one of these embodiments the window handler filter routine uses an application programming interface API provided by an operating system on the computing device to request information associated with the window .

In one embodiment the system includes a client agent identifying the window displayed to the user and executing the window handler filter routine responsive to the identification. In another embodiment the client agent is the client software . In still another embodiment the client agent is in communication with the client software . In yet another embodiment the client agent includes a module using an API to query a resource such as an application or operating system executing on the computing device to retrieve window identification information. In some embodiments upon determining that a resource executing on the computing device has generated a window and application output data the client agent executes at least one of the window handler routines and the window handler filter routine . In other embodiments the client agent transmits to the window handler filter routine the window identification information and receives from the window handler filter routine an indication that the window handler filter routine has analyzed the application output data to determine whether the application output data contains contact information. In further embodiments a window handler filter routine is implemented via an embodiment of the method illustrated in .

Referring now to a flow diagram depicts one embodiment of a method for efficient processing of data displayed by a window. In brief overview the method includes identifying a window displayed to a user of a computing device . The method includes executing a window handler filter routine responsive to the identification . The method includes obtaining by the window handler filter routine window identification information associated with the displayed window . The method includes preventing by the window handler filter routine operation by a window handler routine on application output data displayed in the window when the window identification information associated with the window represents a type of window listed within a list of types of windows .

Referring now to and in greater detail a window displayed to a user of a computing device is identified . In one embodiment the window handler filter routine identifies the window . In another embodiment the client software identifies the window and transmits an identification of the window to the window handler filter routine . In still another embodiment the client software identifies the window as described above in connection with . In some embodiments and as described above the client software determines that a pointing device connected to the computing device is substantially idle and that a representation of the pointing device is displayed within the window . In one of these embodiments the client software identifies a window displaying application output data and displaying a graphical representation of a pointing device such as cursor which the client software has determined is substantially idle. In other embodiments the client software determines that an input output device connected to the computing device is has focused on a window . In still other embodiments the determination that a pointing device or other input output device is substantially idle is optional. In yet other embodiments no determination is made and the window is identified via alternative mechanisms. In one of these embodiments an operating system is queried to identify a window having window focus.

A window handler filter routine is executed responsive to the identification . In one embodiment the client software executes the window handler filter routine . In another embodiment the client software executes the window handler filter routine as described above in connection with .

The window handler filter routine obtains window identification information associated with the displayed window . In one embodiment the window handler filter routine obtains the window identification information from the client software . In another embodiment the window handler filter routine obtains the window identification information from a resource executing on the computing device such as an operating system or an application in such an embodiment the window handler filter routine may implement an API to query the resource and retrieve the identification. In still another embodiment the window handler filter routine obtains window identification information and determines a type of window associated with the window responsive to an analysis of the window identification information. Additional embodiments of the obtained window identification information are described below in connection with .

The window handler filter routine prevents operation by at least one window handler routine on application output data displayed in the window when the window identification information associated with the window represents a type of window listed within a list of types of windows . In one embodiment the window handler filter routine includes the list of types of windows. In another of these embodiments the window handler filter routine accesses a file containing the list. In still another of these embodiments the window handler filter routine retrieves from a second computing device a file containing the list.

In one embodiment the window handler filter routine determines that the obtained window identification information identifies a type of window associated with the window . In another embodiment the window handler filter routine accesses the list of types of windows and determines whether the list enumerates the type of window identified by the window identification information. In still another embodiment the window handler filter routine determines that because the list enumerates the type of window associated with the window no window handler routines should analyze the application output data . In yet another embodiment the list enumerates types of windows that do not contain contact information.

In some embodiments the window handler filter routine transmits to the client software an indication that the window handler filter routing has analyzed the application output data displayed by the window and determined that the data contains no contact information. In one of these embodiments the window handler filter routine transmits the indication although it has determined that no analysis should occur. In other embodiments the window handler filter routine identifies the type of window as a type not enumerated by the list. In one of these embodiments the window handler filter routine transmits to a client agent such as the client software an indication that the window handler filter routine has not or cannot analyze the application output data .

Referring now to a flow diagram depicts one embodiment of a method for implementing a window handler filter routine. In brief overview window identification information is retrieved from an identified window step . The retrieved window identification information is passed to the window handler filter routine step . The window identification information is analyzed by the window handler filter routine step and a determination is made as to whether or not the window identification information should be processed by subsequent routines step . When a determination is made that the window identification information should be further processed the window identification information is sent to subsequent window handler routines step . When a determination is made that the window identification information should not be processed any further the window identification information is prevented from being processed by any subsequent window handler routines step .

Referring now to and in greater detail window identification information is retrieved from an identified window step . In some embodiments the window identification information is retrieved by the window handler filter routine in other embodiments the window identification information is retrieved by another routine included within either of the system or one of the plurality of routines . An identified window can be a graphical representation of an executing application displayed on the visual display device where a cursor also present on the visual display device has a coordinate position on the display device that positions the cursor in a substantially similar position to that of the window. In other words the identified window is a window displayed on the display device over which the cursor is positioned. Some embodiments determine the identified window via a mouse over function that utilizes the position of a cursor on a display device to determine a selected object. In these embodiments windows displaying application output data are considered a selected object when the cursor is positioned over the graphical display of the application window. Window identification information in some embodiments includes a window handle or other encapsulated data item able to relay information about a particular window. In other embodiments window identification information includes any one or combination of the following data window class information window family information window size information window position information window identification information information regarding the application output data displayed within the window window text information window style information parent window information child window information sibling window information window identification number window caption information or other information pertinent to determining attributes of the window attributes of the window indicative of the application executing and displaying data within the window and or attributes of related windows. Further embodiments may utilize the window identification information to determine a type of window where the type of window may be determined based on the data included within the window identification information or the type of window may be identified by a value included within the window identification information. In embodiments where the type of window may be a value included within the window identification information the type of window may be an attribute of the window defined by the operating system an attributed defined by the application generating the application output data displayed within the window or an attribute assigned by a routine associated with the window handler filter routine .

In one embodiment the window identification information is passed to the window handler filter routine step . In another embodiment the window identification information is passed to the window handler filter routine . In still another embodiment the window handler filter routine retrieves the window identification information step and so there is no need for another component to pass the window identification information to the window handler filter routine step . Transmission of the window identification information to the window handler filter routine step can in some embodiments be carried out by a separate routine or software application executing within or in conjunction with the system .

The window identification information is in some embodiments analyzed by the window handler filter routine step to determine whether or not the window identification information should be sent to subsequent window handler routines for processing step . Analyzing the window identification information can include analyzing any of the following information a window caption information regarding the application output data displayed within the window a window identification number a window handle information regarding related windows a window class name or any of the above mentioned information. Determination as to whether or not the application output data displayed within the window should be processed can in some embodiments be made by comparing any of the above mentioned window identification information data types to an empirically determined listing of corresponding types of windows. In such an embodiment the empirically determined information can be hard coded into the window handler filter routine the information could be stored in a database or lookup table or the information could be listed as an aspect of a policy table. In these embodiments the determination not to process the application output data displayed within the window is made because the window identification information indicates that there is a low likelihood that the application output data will include communication information such as contact information . A low likelihood can be characterized as a likelihood calculation and further determination that the calculated value is below a predetermined threshold or the likelihood could be an absolute determination that the window identification information indicates that the application output data will not contain communication information such as contact information . In some embodiments the determination not to process the application output data displayed within the window is made by comparing the retrieved window identification information with a listing of allowed window types and or allowed window attributes. In one of these embodiments and as described in greater detail below in connection with this listing can be dynamically generated by the system.

When in some embodiments it is determined that the window identification information should be processed the window identification information is sent to subsequent window handler routines step . Each window handler routine will determine whether or not based on the window identification information that window handler routine may process the application output data displayed within the window. The window identification information will continue to be passed to subsequent window handler routines until a routine is identified that include functionality for processing the application output data . In the event that no window handler routine is found a default routine will be called to process the application output data .

When in some embodiments it is determined that the window identification information should not be processed further processing will be prevented step . In such embodiments the window identification information will not be passed to subsequent window handler routines when it is determined that there is a low likelihood that the identified window displays application output data that contains communication data. One example of this includes an attempt to retrieve window identification information from a window displaying a MICROSOFT OUTLOOK calendar. In this example window identification information indicates that the application output data displayed is application output data related to a MICROSOFT OUTLOOK calendar object. The window handler filter routine analyzes this information to determine whether or not a window displaying calendar application data should be searched for communication data. Based on comparison information the window handler filter routine determines that in this example the window displaying application output data generated by the MICROSOFT OUTLOOK calendar object should not be searched and the window identification information related to that window is not passed to subsequent window handler routines. In other words the window handler filter routine responds to the determination that the window displaying the calendar application data does not include communication data by preventing further processing of the application output data within the MICROSOFT OUTLOOK calendar window.

As described above in connection with the client software may access each of a plurality of window handler routines according to a priority level assigned to each of the plurality of window handler routines and requests of each window handler routines an indication as to whether the window handler routines can analyze application output data to determine whether the application output data contains contact information . In one embodiment the priority level assigned to the window handler filter routine is the highest priority level and the client software requests the indication from the window handler filter routine before making the request of any other window handler routines . In another embodiment if the window handler filter routine responds with an indication that the window handler filter routine cannot perform the analysis of the application output data the client software proceeds to make the request of each of the remaining window handler routines until one of the window handler routines responds with an indication that it can analyze the application output data and determined whether the contact information . In still another embodiment if the window handler filter routine responds with an indication that the window handler filter routine can perform the analysis and that no contact information is displayed in the window the client software does not proceed to make the request of any of the other window handler routines . In yet another embodiment therefore if user is aware that a particular type of window does not typically contain contact information the user may add an identification of the type of window to the list accessed by the window handler filter routine which can then identify whether a particular window has that type and indicate to the client software that no contact information is displayed preventing analysis by any of the other window handler routines of a window known not to include contact information. In some embodiments therefore the methods and systems described herein provide an improved process for determining whether a window contains contact information and avoid unnecessary analysis of windows known not to contain contact information.

In some embodiments the window handler filter routine accesses a list to determine whether or not to prevent operation on data displayed by a window. In one of these embodiments the list is predetermined in that a programmer administrator or other user of the systems and methods described herein identifies a type of window that does not contain or is not likely to contain contact information. In another of these embodiments and by way of example although a type of window such as a window displaying a preview of a calendar month generated and displayed by a calendar application may contain numbers and other data that a window handler routine may identify as contact information and that client software may display in a user interface element for establishing a telecommunications session for example a window from which a user can initiate a telephone call to the number displayed a human user of the systems and methods described herein may identify the displayed information not as a phone number but as a numerical representation of a date and therefore not interact with the user interface element. By manually directing the placement of an identification of the type of window on a list of types of windows filtered by the window handler filter routine users of the methods and systems described herein may prevent unnecessary analysis of the data displayed by the window. In other embodiments however the list is predetermined in that a system is provided for automatically generating the list of filtered windows for use by the window handler filter routine .

Referring now to a block diagram depicts one embodiment of a system for identifying a window lacking communications data relevant to a user of a computing device. In brief overview a system for identifying a window lacking communications data relevant to a user of a computing device includes a client agent and an analysis component . The client agent which may be provided as part of client software described above in connection with FIGS. includes a window handler filter routine and a window handler routine . The window handler filter routine generates an identification of each of a plurality of windows displayed to a user of a computing device. The window handler routine generates an indication of whether each of the plurality of windows displays contact information to the user. The client agent generates an indication of whether the user interacted with the information displayed by each of the plurality of windows. The analysis component analyzes for each of the plurality of windows at least one of a received identification of each of the plurality of windows a received indication of whether each of the plurality of windows displays contact information and a received indication of whether the user interacted with the displayed contact information. The analysis component generates an enumeration of window identification information for at least one filtered window.

Referring now to and in greater detail a window handler filter routine within the client agent generates an identification of each of a plurality of windows displayed to a user of a computing device . In one embodiment the window handler filter routine determines whether a window should be analyzed by determining whether the window is a type of window included in an enumeration of filtered windows as described above in connection with . In another embodiment the window handler filter routine determines that the window is not of a type included in the enumeration of filtered windows and indicates to the client agent that data displayed by the window should be analyzed by a window handler . For example in still another embodiment by responding to the client agent request for analysis of the data displayed by the window with a message indicating that the analysis component cannot process the data the window handler filter has indicated that a window handler should be called to process the data . In some embodiments when the window handler filter routine indicates to the client agent that application output data in a window should be analyzed the window handler filter routine also transmits to the analysis component window identification information for the window . In other embodiments when the window handler filter routine indicates to the client agent that application output data in a window should be analyzed the client agent transmits to the analysis component window identification information for the window

As described above the window handler routine receives a request to analyze application output data and determines whether a window displays contact information . In one embodiment the window handler routine is in communication with the analysis component and transmits to the analysis component an identification of whether it has identified information that may constitute contact information .

As described above in embodiments in which the client agent has identified a window displayed to a user of a computing device and in which the window handler filter routine has determined that the data displayed by the window should be analyzed by a window handler routine and in which the window handler routine has determined that the application output data may contain contact information the client agent may generate a user interface element allowing a user to initiate a telecommunications session with an entity associated with the contact information . In one of these embodiments the client agent may include a component for monitoring whether the user interacts with the user interface element to initiate the telecommunications session. In another of these embodiments the client agent transmits to the analysis component an indication of whether or not the user initiated the telecommunications session.

The analysis component analyzes for each of the plurality of windows at least one of a received identification of each of the plurality of windows a received indication of whether each of the plurality of windows displays contact information and a received indication of whether the user interacted with the displayed contact information. In one embodiment based upon the analysis the analysis component determines whether or not users initiated telecommunications sessions with data identified as contact information. In another embodiment therefore the analysis component evaluates the accuracy of the determinations made by the window handler filter routine and the window handler routine . In still another embodiment the analysis component generates an enumeration of window identification information for at least one filtered window. In some embodiments the analysis component determines that the window handler filter routine identified data as appropriate for analysis by a window handler and the window handler identified the data as containing contact information but when presented to a user the user chose not to contact an entity associated with the contact information . In one of these embodiments the analysis component applies at least one heuristic to at least one of a received identification of each of the plurality of windows a received indication of whether each of the plurality of windows displays contact information and a received indication of whether the user interacted with the displayed contact information in determining whether to filter at least one of the plurality of windows. In another of these embodiments by collecting the indications of determinations by the window handler filter routine the window handler and the client agent and applying heuristics algorithms or other artificial intelligence to the collected data the analysis component identifies types of windows that do not typically display contact information used by users to initiate telecommunications systems and to prevent analysis on these types of windows for subsequently displayed windows having these types. In still another of these embodiments the analysis component transmits the enumeration to the window handler filter routine for use in subsequent evaluations of windows.

Referring now to a flow diagram depicts one embodiment of a method for identifying a window lacking communications data relevant to a user of a computing device. The method includes receiving an identification of each of a plurality of windows displayed to a user of a computing device . The method includes receiving an indication of whether each of the plurality of windows contains contact information displayed to the user . The method includes receiving an indication of whether the user interacted with the information displayed by each of the plurality of windows . The method includes analyzing for each of the plurality of windows the received indication of whether the user interacted with the displayed information the received indication of whether each of the plurality of windows contains contact information displayed to the user and the received identification of each of the plurality of windows . The method includes generating an enumeration of window identification information for at least one filtered window .

Referring now to and in greater detail the analysis component receives an identification of each of a plurality of windows displayed to a user of a computing device . In one embodiment the analysis component receives the identification from the window handler filter routine . In another embodiment the analysis component receives the identification after the window handler filter routine has determined that the data displayed by the window should by analyzed by a window handler routine . In still another embodiment the analysis component receives the identification from the client agent .

In one embodiment the analysis component receives information associated with each of the plurality of windows. In another embodiment the analysis component receives an identification of a window type associated with at least one window in the plurality of windows. In still another embodiment the analysis component receives an identification of an ancestor window of at least one window in the plurality of windows. In still even another embodiment the analysis component receives an identification of a descendant window of at least one window in the plurality of windows. In still another embodiment the analysis component receives an identification of a sibling window of at least one window in the plurality of windows. In another embodiment the analysis component receives an identification of a type of class of at least one window in the plurality of windows. In yet another embodiment the analysis component receives caption data associated with at least one window in the plurality of windows. In some embodiments the analysis component receives window identification information as described above in .

The analysis component receives an indication of whether each of the plurality of windows contains contact information displayed to the user . In one embodiment the analysis component receives the indication from the window handler routine . In another embodiment the analysis component receives the indication from the client agent . In still another embodiment the analysis component receives the indication from a parser executing in the client agent .

In one embodiment the analysis component receives an identification of a telephone number displayed to the user. In another embodiment the analysis component receives an identification of a number associated with a facsimile machine is displayed to the user. In still another embodiment the analysis component receives an identification of an electronic mail address displayed to the user. In yet another embodiment the analysis component receives an identification that no contact information is displayed to the user.

In some embodiments the analysis component receives an indication that the window handler has identified information within the application output data that may or may not constitute contact information . In one of these embodiments a parser analyzes the information to determine whether or not the data is contact information. In another of these embodiments the parser transmits a determination to the analysis component as to whether or not the data is or contains contact information . In still another of these embodiments the parser is unable to determine whether the data is or contains contact information .

The analysis component receives an indication of whether the user interacted with the information displayed by each of the plurality of windows . In one embodiment the client agent generates a user interface element displaying information retrieved from one of the plurality of windows and allowing a user to initiate a telecommunications session. In another embodiment the user interface includes an element such as a hyperlink which the user may select to initiate the telecommunications session. In still another embodiment the client agent monitors the user interface element to determine whether or not the user interacts with the user interface element for example by using an input output device to select the hyperlink . In some embodiments the client agent terminates display of the user interface element. In one of these embodiments the client agent determines responsive to the monitoring of the user interface element that the user has not interacted with the user interface element within a period of time for example the client agent may have received or include an identification of a predetermined threshold of time determine that a user has not interacted with the user interface element within the period of time and remove the user interface element from display. In another of these embodiments the client agent determines that the user is interacting with a different user interface element for example a different window and remove the user interface element from display. In embodiments in which the client agent determines that the user has not interacted with the user interface element the client agent may transmit an identification of that lack of interaction to the analysis component .

The analysis component analyzes for each of the plurality of windows the received indication of whether the user interacted with the displayed information the received indication of whether each of the plurality of windows contains contact information displayed to the user and the received identification of each of the plurality of windows . In one embodiment the analysis component applies at least one heuristic to the received indication of whether the user interacted with the displayed information. In another embodiment the analysis component applies at least one heuristic to the received indication of whether each of the plurality of windows contains contact information displayed to the user. In still another embodiment the analysis component applies at least one heuristic to the received indication of each of the plurality of windows. In some embodiments the analysis component determines responsive to the analysis that a type of window does not display contact information relevant to a user.

The analysis component generates an enumeration of window identification information for at least one filtered window . In one embodiment the analysis component generates statistical data during the implementation of the methods and systems described above. In another embodiment the analysis component processes the statistical data to generate data representative of window attributes characteristic of a window that does not contain communication data in the displayed application output data . In still another embodiment the analysis component processes the statistical data to generate data representative of window attributes characteristic of a window that does not contain communication data that should be displayed to the user for example because the number is not relevant to the user or because the user is unlikely to use the number to initiate a telecommunications session.

The statistical data can in some embodiments include data generated when a success or failure condition occurs. In one of these embodiments a failure condition occurs when the methods and systems are implemented to retrieve communication data from an identified window and the application output data displayed in the window does not include communication data. In another of these embodiments a failure condition occurs when data identified as communication data is displayed to a user in a user interface element allowing the user to initiate a telecommunications session such as a telephone call facsimile transmission voice over Internet Protocol call web conference or other session but the user chooses not to initiate such a sessions for example the user may determine that the displayed data is not contact information. In still another of these embodiments a success condition occurs when the methods and systems described above are implemented to retrieve communication data from an identified window and the application output data displayed in the window does include communication data and the user interacts with the user interface element displaying the communication data to initiate a telecommunications session. In yet another of these embodiments the user initiates a telecommunications session but only after modifying the displayed data such a situation may be categorized as a failure or a success or as an intermediate condition. Any combination of statistical data can be combined or separated to provide indicators as to which windows will contain communication data.

In some embodiments the analysis component may determine whether or not a particular window should be searched by employing methods such as those that implement learning algorithms able to use gathered information and make future decisions based on previously generated statistical data autonomous algorithms that react based in part on gathered information where the autonomous algorithms vary in their interaction with presently generated information based on past information and algorithms that compile prior statistical information regarding the searching of application output data and further make decisions about future information input based on patterns information or other informational indicators within the gathered statistical information. In further embodiments the analysis component provides to the window handler filter routine the generated enumeration of window identification information for at least one filtered window.

In one embodiment by determining whether or not a user is likely to use the information displayed in a particular type of window the analysis component can prevent unnecessary analysis of windows for which no user interaction is likely to occur. In another embodiment the analysis component improves the performance of the system and allows the window handler filter routine to more effectively prevent operation on windows of a type not likely to contain contact data or other data prompting a user to initiate a telecommunications session.

Referring now to a block diagram depicts one embodiment of a system for identifying a process for analyzing data displayed by a window to a user of a computing device. In brief overview the system includes a window handler filter routine and a window handler . The window handler filter routine receives window identification information associated with a window displayed to a user of a computing device the window associated with a first type of window. The window handler filter routine determines whether a window handler routine executing on the computing device includes functionality for analyzing data displayed by the window associated with the first type of window. The window handler routine receives the window identification information and applies to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information.

Referring now to and in greater detail the window handler filter routine receives window identification information associated with a window displayed to a user of a computing device the window associated with a first type of window. In one embodiment the type of the window may refer to a type of resource such as an application executing on the computing device that generates the window. In another embodiment the window handler filter routine receives the window identification information from a client agent . In another embodiment the window handler filter routine implements an applications programming interface to query an operating system executing on the computing device to retrieve window identification window associated with a window for example the client agent may indicate to the window handler filter routine that a resource executing on the computing device has displayed a new window and the window handler filter routine may query the operating system to retrieve additional information associated with the window . In still another embodiment the window handler filter routine provides the functionality described above in connection with . In some embodiments the system includes a client agent transmitting to the window handler filter routine the window identification information the client agent may be a client agent or client software as described above in connection with .

The window handler filter routine determines whether a window handler routine executing on the computing device includes functionality for analyzing application output data displayed by the window associated with the first type of window. In one embodiment the window handler filter routine identifies a type for the window . In another embodiment the window handler filter routine identifies the type of window by analyzing the received window identification information. In still another embodiment the window handler filter routine includes functionality for identifying the type of the window as described above in connection with . In some embodiments to determine whether the system includes a window handler routine capable of processing application output data displayed by a window associated with a first type of window the window handler filter routine accesses a mapping between a plurality of types of window and of window handler routines providing functionality for analyzing each of the plurality of types of window. In one of these embodiments and by way of example the window handler filter routine accesses a mapping indicating that a window handler routine A provides functionality for determining whether application output data displayed in a window generated by a word processing application contains contact information while a window handler routine B provides functionality for determining whether application output data displayed in a window generated by a spreadsheet application contains contact information. In other embodiments the window handler filter routine accesses a mapping indicating that no window handler routine provides functionality for determining whether application output data displayed in a window contains contact information. In one of these embodiments the window handler filter routine may prevent operation on the window as described above in connection with . In another of these embodiments and as described in greater detail below the window handler filter routine may identify an alternate window handler routine for determining whether application output data displayed in a window contains contact information. In further embodiments and by way of example a mapping may include a file table database or other data structure indicating whether a window handler routine provides functionality for analyzing application output data for a window of a particular type. In one of these embodiments by way of example and without limitation the mapping may include information such as the following 

In some embodiments the window handler filter routine accesses a first mapping to identify substitute window handlers and accesses a second mapping to identify windows for which the window handler filter routine should prevent operation. In other embodiments a first window handler filter routine determines whether to prevent operation on a window while a second window handler filter routine determines whether to direct a window handler routine to analyze a window associated with a first type of window the window handler routine providing functionality for determining whether a window associated with a second type of window displays contact information.

The window handler routine receives the window identification information. In one embodiment the window handler routine is in communication with the client agent and the window handler filter routine . In one embodiment the window handler routine includes a receiver receiving from the window handler filter routine a direction to apply to the window associated with the first type of window the process for determining whether a window associated with a second type of window displays contact information. The window handler routine applies to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information. In still another embodiment the client agent generates at least one user interface displaying an interface element for initiating a telecommunications session based on identified contact information displayed by the window associated with the first type of window.

Referring now to a block diagram depicts one embodiment of a method for identifying a process for analyzing data displayed by a window to a user of a computing device. In brief overview the method includes receiving window identification information associated with a window displayed to a user of a computing device the window associated with a first type of window . The method includes determining whether a window handler routine executing on the computing device includes functionality for analyzing data displayed by the window associated with the first type of window . The method includes directing the window handler routine to apply to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information .

The method includes receiving window identification information associated with a window displayed to a user of a computing device the window associated with a first type of window . In one embodiment the window handler filter routine receives the window identification information. In another embodiment the window handler filter routine receives an identification of a window type of a window . In still another embodiment the window handler filter routine receives an identification of an ancestor window of the window . In still even another embodiment the window handler filter routine receives an identification of a descendant window of the window . In still another embodiment the window handler filter routine receives an identification of a sibling window of the window . In another embodiment the window handler filter routing receives an identification of a type of class of the window. In yet another embodiment the window handler filter routine receives an identification of caption data displayed by the window. In some embodiments the window handler filter routine receives the window identification information from the client agent . In other embodiments the window handler filter routine uses an application programming interface to query an operating system executing on the computing device for the window identification information.

The method includes determining whether a window handler routine executing on the computing device includes functionality for analyzing data displayed by the window associated with the first type of window . In one embodiment the window handler filter routine determines that the window handler routine does provide functionality for analyzing data displayed by the window associated with the first type of window. In this embodiment the window handler filter routine may execute the window handler routine to analyze displayed application output data . Alternatively the window handler filter routine may direct the client agent to execute the window handler routine . In some embodiments the window handler filter routine determines that the window handler routine does not include provide functionality for analyzing data displayed by the window associated with the first type of window. In one of these embodiments the window handler filter routine determines that none of a plurality of window handler routine provide functionality for analyzing data displayed by the window associated with the first type of window in such an embodiment the window handler filter routine may prevent operation on the window as described above in connection with . In another of these embodiments the window handler filter routine determines that although none of a plurality of window handler routine provide functionality for analyzing data displayed by the window associated with the first type of window at least one window handler routine provides functionality for analyzing data displayed by a window of a second type and that the process for analyzing data of displayed by a window of a second type may be applied to analyze data displayed by a window of a first time.

The method includes directing the window handler routine to apply to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information . In one embodiment the window handler routine receives an instruction from the client agent to apply to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information. In another embodiment the window handler routine receives an instruction from the window handler filter routine to apply to the window associated with the first type of window a process for determining whether a window associated with a second type of window displays contact information.

In one embodiment the window handler routine determines responsive to the applied process that the window displays contact information to the user. In another embodiment the window handler routine determines responsive to the applied process that the window displays a telephone number to the user. In still another embodiment the window handler routine determines responsive to the applied process that the window displays a facsimile number to the user. In still even another embodiment the window handler routine determines responsive to the applied process that the window displays an email address to the user. In yet another embodiment the window handler routine determines responsive to the applied process that the window does not display contact information to the user. In some embodiments the window handler routine provides to the client agent an indication of whether the window displays contact information to the user. In other embodiments and as described above in connection with if the client agent receives an indication that the window displays contact information to the user the client agent generates and displays to a user at least one user interface displaying an interface element for initiating a telecommunications session based on identified contact information displayed by the window associated with the first type of window.

In some embodiments the methods and systems described herein provide functionality for analyzing data displayed to a user of a computing device. In one of these embodiments the methods and systems described herein provide this functionality even in situations in which the window handler routines provided by the system do not include functionality for analyzing data displayed by a window of the type displaying the data for analysis. In another of these embodiments by identifying an alternate window handler routine for analyzing window data displayed in a window having a previously unsupported type the systems and methods described herein provide additional functionality and flexibility supporting a wider range of types of windows displaying different types of data or data in differing formats without requiring the generation of customized software to analyze each of the different types of windows.

The methods and systems described above provide functionality for analyzing data generated by a resource executing in a first operating system and displayed by the first operating system. In some embodiments however the methods and systems described herein also provide functionality for analyzing data generated by a resource executing in a first operating system and displayed by a second operating system. In one of these embodiments the methods and systems described herein include at least one interface providing mechanisms for communication between a first resource executing in the first operating system and a second resource executing in the second operating system.

Referring now to a block diagram depicts one embodiment of a system for providing to a first application executed by a first operating system on a first computing device an interface for communicating with at least one application executed by a second operating system on a second computing device. In brief overview the system includes a computing device a computing device a first interface between a client agent and at least one remote machine window handler routine an interface between the at least one remote machine window handler and the client agent a remote application and a window displaying on the computing device remotely generated application output data . The first interface object executed by a first operating system provides a mechanism for external communication with a first application executed by the first operating system and receiving an identification of a window displayed by the first operating system and generated by a second application executed by a second operating system. The at least one remote machine window handler executed by the second operating system includes a receiver receiving a request from the first interface object via a second interface object executed by the second operating system and providing a mechanism for external communication with the at least one window handler routine . The at least one remote machine window handler includes an analysis engine analyzing data displayed in the window . The at least one remote machine window handler includes a transmitter sending to the first interface object via the second interface object an identification of contact information displayed by the window .

Referring now to and in greater detail the first interface object executed by a first operating system on a computing device provides a mechanism for external communication with a first application executed by the first operating system and receives an identification of a window displayed by the first operating system and generated by a second application executed by a second operating system on a second computing device . In one embodiment the first interface object is a proxy for a window handler routine executing on the computing device . In another embodiment the first interface object is a plug in to the first application .

In one embodiment the first application is a client agent or client software as described above in connection with . In another embodiment the first application interacts with the first interface object as if the first interface object were a window handler routine . In still another embodiment the first interface object provides an interface between a client agent executing on the computing device and a window handler routine executing on the computing device

In some embodiments the client agent includes an analysis component such as the parser described above. In one of these embodiments the analysis component confirms that data identified by the window handler routine is contact information. In another of these embodiments the analysis component executes on the first operating system of the computing device and is in communication with the first interface object . In still another of these embodiments the analysis component receives the contact information identified by the window handler routine and transmits to the first application confirmation that the data displayed by the identified window includes contact information. In yet another of these embodiments the analysis component transmits to the first application an indication that the data displayed by the identified window does not include contact information. In other embodiments the first application generates a user interface displaying the identified contact information .

In one embodiment the at least one window handler routine includes a receiver receiving a request from the first interface object via a second interface object. In another embodiment the receiver receives an identification of a window displayed on the computing device and generated by a remote application executing on the computing device . In still another embodiment the receiver receives a request to analyze application output data to determine whether or not the window displays any contact information . In still even another embodiment the at least one window handler routine includes an analysis engine analyzing application output data to determine whether the window displays any contact information . The analysis engine may analyze the data to make the determination as described above in connection with . In yet another embodiment the at least one window handler routine sends to the first interface object via the second interface object an identification of contact information displayed by the window . In other embodiments the at least one window handler routine sends to the first interface object via the second interface object an indication that the window does not display contact information .

In one embodiment the at least one window handler routine executing on the computing device provides functionality such as that provided by the window handler filter routine described above in connection with . In another embodiment the at least one window handler routine is in communication with an analysis component executing on the computing device and providing functionality such as that provided by the analysis component described above. In still another embodiment the at least one window handler routine executing on the computing device is a plug in module interacting with the second interface object as if the second interface object were a client agent . In still even another embodiment the second interface object provides the at least one window handler routine with a mechanism for communicating with the client agent .

Referring now to a block diagram depicts one embodiment of a system in which two interface objects provide mechanisms for external communication between a plurality applications. In one embodiment the first interface object provides other objects such as the second interface object and a second program B executing on the second operating system B with a mechanism for communicating with a first program program A on the first operating system A. In another embodiment the first interface object provides proxying functionality on behalf of the first program.

In some embodiments the first interface object receives a request from program A for example for analysis of application output data and transmits the request to the second interface object . In one of these embodiments the second interface object transmits the request to one or more resources executing in the second operating system for processing. In another of these embodiments the resources are window handler filters and the second interface object provides the functionality of a client agent identifying at least one of a plurality of window handler filter to analyze data in an identified window as described above in connection with .

In one embodiment program B generates data for transmission to program A transmits the data to the second interface object which transmits the data to the first interface object which transmits the data to program A. In some embodiments program B is unaware that the second interface object is not program A. In other embodiments program A is unaware that the first interface object has not generated the data received by program A.

In some embodiments the first interface object remains unaware of the resource such as program B or resources such as a plurality of window handler routines that provide the processing of the request and interacts only with the second interface object . In other embodiments program A remains unaware that the first interface object did not process the request to generate the response or that resources executed by other operating systems such as program B or a plurality of window handler routines . In still other embodiments the program B remains unaware that the second interface object is not a client agent or the originator of the request for processing. In further embodiments a first resource is unaware that a second resource with which the first resource interacts is a proxy for a third resource because the second resource provides access to the same resources or functionality as the third resource.

In some embodiments the first interface object and the second interface object establish a communications channel between the operating systems. In one of these embodiments the first interface object and the second interface object communicate over a virtual channel. In another of these embodiments the first interface object and the second interface object communicate over a channel according to a presentation layer protocol. In still another of these embodiments a separate component establishes a presentation layer protocol channel such as a virtual channel and the first interface object and the second interface object communicate over the presentation layer protocol channel. In other embodiments the first interface object and the second interface object communicate over any of the networks or using any of the protocols described above in connection with A and B.

Referring now to a block diagram depicts one embodiment of a system for providing to a first application executed by a first operating system on a computing device an interface for communicating with at least one application executed by a second operating system on the computing device. As described in connection with the first interface object and the second interface object each execute in different operating systems and communicate across the operating systems to provide interfaces for two programs such as a client agent and a window handler routine . Although depicted in as executing on two different computing devices in some embodiments and as depicted in the first interface object and the second interface object may execute on different operating systems provided by a single computing device. The computing device may execute both a first operating system and a second operating system . In one embodiment the first operating system is a different operating system than the second operating system . In another embodiment the first operating system is a different instance of the same operating system instantiated by the second operating system . In still another embodiment each of the operating systems execute within at least one virtual machine. For example and in still another embodiment a virtual machine may execute the first operating system and a second virtual machine may execute the second operating system . In some embodiments a hypervisor is provided to manage the virtual machines. In other embodiments each of the operating systems is isolated from operating systems executing within a separate virtual machine.

In some embodiments a user of the computing device views a display of data generated by the first operating system separately from a display of data generated by the second operating system . In one of these embodiments for example only one display device is provided and the display device displays only the output data generated by one of the operating systems executed by the computing device . In another of these embodiments multiple display devices are provided each of which displays separately data generated by one of a plurality of operating systems. In other embodiments a user of the computing device views a display of data generated by the first operating system concurrently with a display of data generated by the second operating system . In one of these embodiments the user views a plurality of desktop environments on one or more display devices providing a concurrent view of the plurality of desktop environments although the user interface elements and displayed data generated or maintained by each of the operating systems are displayed separately. In another of these embodiments the user views a plurality of desktop environments on one or more display devices providing a concurrent view of the plurality of desktop environments and the user interface elements and displayed data generated or maintained by each of the operating systems are displayed in an integrated desktop environment. In further embodiments operating systems and executing on a single computing device may share physical resources provided by the computing device including but not limited to processing capabilities physical disk space and display devices.

In some embodiments a resource executed in one operating system may generate output data for display within a second operating system. In one of these embodiments and by way of example an application executing in an operating system and remote to an operating system either physically or logically may generate application output data for display in a window maintained by the operating system . In another of these embodiments the resource may transmit an agent executing on the output data to the operating system such as a presentation layer protocol client agent and the agent directs the display of the output data by the operating system .

Referring now to a flow diagram depicts one embodiment of a method for providing to a first application executed by a first operating system an interface for communicating with at least one application executed by a second operating system. In brief overview the method includes providing by a first interface object executed by a first operating system a mechanism for external communication with a first application executed by the first operating system . The method includes providing by a second interface object executed by a second operating system a mechanism for external communication with at least one window handler routine executed by the second operating system . The method includes receiving by the first interface object an identification of a window displayed by the first operating system and generated by a second application executed by the second operating system . The method includes requesting by the first interface object from the second interface object analysis of the identified window . The method includes directing by second interface object analysis of data displayed in the window by the at least one window handler routine executed by the second operating system . The method includes receiving by the first interface object from the second interface object an identification of contact information displayed by the window resulting from the analysis by the at least one window handler routine executed by the second operating system .

Referring now to and in greater detail the method includes providing by a first interface object executed by a first operating system a mechanism for external communication with a first application executed by the first operating system . In one embodiment the first interface object receives requests from the first application such as the client agent and forwards them to a second interface object for processing. In another embodiment the first interface object receives information including responses to request for analysis of output data from the second interface object and provides the information to the client agent .

The method includes providing by a second interface object executed by a second operating system a mechanism for external communication with at least one window handler routine executed by the second operating system . In one embodiment the second interface object provides the functionality of a client agent and a window handler routine on the second operating system interacts with the second interface object as described above in connection with . In another embodiment the window handler routine is a plug in module that analyzes output data generated by applications executing on the second operating system and forwards a determination of whether or not the output data includes contact information to the second interface object . As described above in connection with B and C and in one embodiment the interface objects may establish a connection between operating systems over which the interface objects communicate exchanging proxied requests and responses.

The method includes receiving by the first interface object an identification of a window displayed by the first operating system and generated by a second application executed by the second operating system . In one embodiment the client agent identifies a window as described above in connection with . In another embodiment the client agent interacts with the first interface object as if the first interface object were a window handler routine in a plurality of window handlers . In still another embodiment the client agent transmits to the first interface object requests to indicate whether or not output data displayed by a window includes contact information. In some embodiments the first interface object receives window identification information associated with a window and determines that the window displays output data generated by a resource executing on the second operating system which may execute on the second computing device .

The method includes requesting by the first interface object from the second interface object analysis of the identified window . In one embodiment the first interface object analyzes the window identification information to identify an associated resource generating the output data as described above in connection with . In another embodiment the first interface object transmits the window identification information with a request for analysis of output data displayed by the window to the second interface object for processing.

The method includes directing by second interface object analysis of data displayed in the window by the at least one window handler routine executed by the second operating system . In one embodiment the second interface object receives a request from the first interface object and identifies at least one window handler routine providing functionality for processing the received request. In another embodiment the second interface object implementing functionality such as that described above in connection with the client agent and accesses a plurality of window handler routines each of which may have an associated level of priority and requests that at least one of the window handler routines analyze output data . In some embodiments the second interface object transmits the received request to a non window handler application.

The method includes receiving by the first interface object from the second interface object an identification of contact information displayed by the window resulting from the analysis by the at least one window handler routine executed by the second operating system . In one embodiment the client agent displays a user interface for interacting with the identified contact information responsive to receiving the identification of the contact information from the first interface object. In another embodiment the first interface object transmits the identification of contact information to the client agent . In still another embodiment the first interface object receives from the second interface object an indication that the window does not display contact information responsive to the analysis by the at least one window handler routine.

In some embodiments the first interface object transmits the identification of contact information to an analysis component such as parser for confirmation that the identified data is contact information. In one of these embodiments the analysis component determines that the identified information does not include a telephone number. In another of these embodiments the analysis component determines that the identified information does not include a facsimile number. In still another of these embodiments the analysis component determines that the identified information does not include contact information. In still even another of these embodiments the analysis component transmits an identification to the client agent that the identified information is not contact information. In yet another of these embodiments the analysis component transmits an instruction to the client agent not to display a user interface for interacting with the identified contact information.

In some embodiments the methods and systems described herein provide functionality for allowing a client software executed by one operating system to interact with a window handler routine or other application executed by a second operating system either on the same or a different computing device to determine whether remotely generated output data includes contact information. In one of these embodiments by allowing the local client software to request analysis of output data generated by applications executing in an environment remote from the client software the methods and systems described herein improve the functionality of the client software to include the ability to analyze data from output data regardless of the environment in which the resource generating the output data executes without requiring the execution of additional client software in the local environment.

It should be understood that the systems described above may provide multiple ones of any or each of those components and these components may be provided on either a standalone machine or in some embodiments on multiple machines in a distributed system. In some embodiments computer readable media are provided having instructions thereon that when executed provide the methods and systems described above. In addition the systems and methods described above may be provided as one or more computer readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a CD ROM a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language such as LISP PERL C C C PROLOG or in any byte code language such as JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.

Having described certain embodiments of methods and systems for providing to a first application executed by a first operating system an interface for communicating with at least one application executed by a second operating system it will now become apparent to one of skill in the art that other embodiments incorporating the concepts of the disclosure may be used. Therefore the disclosure should not be limited to certain embodiments but rather should be limited only by the spirit and scope of the following claims.

