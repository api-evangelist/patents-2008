---

title: Representing scene description in databases
abstract: Digital production assets and their attributes are stored directly in a scene description database, without any association with a specific enclosing asset data file. Software applications perform database queries to retrieve assets and attributes from the database. Changes to assets or new assets are stored in the database. Query results may be cached to improve performance. Heterogeneous opinion sets including sparse opinions of attribute values may be used to specify scene description data. The database stores heterogeneous opinion set data in association with attribute values. Database-aware applications may change the scene description data in the database without loading, parsing, and instantiating scene description data. An application generates database queries and instantiates scene description data from query results for access and manipulation by other applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08352443&OS=08352443&RS=08352443
owner: Pixar
number: 08352443
owner_city: Emeryville
owner_country: US
publication_date: 20081108
---
The present invention relates to the field of computer graphics and in particular to methods and apparatus for creating modifying and using components to create computer graphics productions. Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional scene from a given viewpoint. This process called rendering generates a two dimensional image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene. Animated sequences can be created by rendering a sequence of images of a scene as the scene is gradually changed over time. A great deal of effort has been devoted to making realistic looking and artistically compelling rendered images and animations.

Computer graphics images animations and other productions involving computer graphics such as interactive entertainment software are created from a number of different components. Generally components include any data and instructions used to create products and applications that include computer graphics. Components can include three dimensional models of geometry texture maps other arrays of data lighting and shading programs used to determine the visual appearance of models and animation data and deformer functions used to specify changes and motion over time. One or more components are typically stored as a digital asset.

Components typically include one or more attributes containing data associated with the component. Attributes can specify any static or varying property of a component. For example a component may be a model of a sphere. Attributes of this example component could describe properties such as the radius of the sphere and the location of the center of the sphere. Different types of components may include different numbers and types of attributes. Components are often related to each other with complex cross reference inheritance and dependency relationships.

Digital production pipelines previously stored its digital assets in data files. Some systems arrange data files in a complex hierarchical file system. Other systems use databases to store the location of data files and metadata summarizing the contents of data files.

Managing the large number of inter related data files is a complex task. In a computer graphics system using a file system hierarchy any errors in the placement of a data file or the specification of a file path may result in erroneous output. Because of the complex relationships between components the source of the erroneous output and the appropriate correction may not obvious to users. Additionally if a small change is made to a digital asset prior data file based systems often must rewrite the entire digital asset data file.

Furthermore it is difficult to search for and or selectively modify digital assets matching specific criteria. Even systems that store digital asset metadata in databases are limited in their search capabilities because the metadata only summarizes the contents of digital assets. Users and applications normally cannot use any arbitrary attribute or characteristic of a digital asset as a search criteria unless metadata has already been generated for this attribute or characteristic. If metadata for an attribute or characteristic does not exist the only alternative is to load each data file into the appropriate application parse all of the data in the data file to instantiate all of the components in the data file in memory and then search the instantiated components for the desired attribute. For digital productions with large numbers of enormous data files this process can take hours or days which makes it impractical for most uses.

Therefore there is an unmet need for a system and method to improve the ease efficiency and reliability of the creation modification and management of components and digital assets in digital production pipelines. There is also an unmet need for a system and method to search and or modify components based on arbitrarily complex and specific criteria. There is also an unmet need for database systems database methods and database structures to enable unrestricted and progressive modifications refinements and variations of any type of data by one or more users or applications such as in a collaborative environment.

An embodiment of the invention stores digital production assets and their attributes directly in a scene description database without any association with a specific enclosing asset data file. Digital production software applications perform database queries to retrieve any required assets and attributes from the scene description database. Any changes to existing assets or new assets created by digital production software applications are stored in the scene description database. In a further embodiment the digital production software applications or the scene description database may cache query results to improve performance.

In an embodiment layers including sparse opinions of attribute values may be used to specify scene description data. The scene description database may stores layer data in association with their encapsulated attribute values.

In an embodiment if a small change is made to a digital asset the scene description database only needs to commit the changed attributes to the database. In a further embodiment database aware applications may make changes to the scene description data in the scene description database without loading parsing and instantiating unnecessary related scene description data. In an embodiment an instantiation application generates database queries and instantiates scene description data from query results for access and manipulation by other applications. Changes to instantiated scene description data are committed back to the scene description database by database aware applications or by an instantiation application.

An embodiment of the scene description database allows for complex queries and modifications of digital assets. For example users can select a set of digital assets according to any criteria including the values of any of their attributes. Once this set is selected the assets of this set may be loaded into memory instantiated modified in any way and stored back into memory without requiring any processing manipulation or instantiation of any other assets.

An embodiment of the invention also includes a general database application with layering and resolving functionality. In this embodiment attributes of data records in a database table may be associated with a layer. Multiple opinions of value of a single attribute may be defined in association with separate layers. A database query may specify a layer stacking order or rely on an intrinsic layer stacking order to select and order a set of layers associated with a database query. Database records matching query selection criteria are selected and resolved from layers according to the layer stacking order and formatted to create a resolved query result.

An embodiment of the invention stores digital assets components and their attributes referred to generically as scene description directly in a database without any association with a specific enclosing asset data file. Digital production software applications perform database queries to retrieve any required assets components and attributes from the database. Digital production software applications instantiate components in memory directly from the results of database queries for viewing editing rendering or any other type of operation. Any changes to the scene description or new digital assets components or attributes created by digital production software applications are stored in the database.

Storing scene description such as digital assets components and their attributes in a database provides several advantages over traditional digital asset data files. First if a small change is made to a digital asset an embodiment of a database based system only needs to commit the changed attributes to the database. This avoids rewriting the entire digital asset data file each time a change is made improving performance.

Second using a database allows for complex queries and modifications of digital assets. For example users can select digital assets or components according to any criteria including the values of any of their attributes. Once this set is selected any attributes of the components of this set can be modified without instantiating the components into memory. If necessary the set may be loaded into memory instantiated viewed modified in any way and stored back into memory without requiring any processing manipulation or instantiation of any other assets or components. With prior data file based systems performing a complex query would requiring opening and instantiating each digital asset and then comparing the instantiated digital asset with the search criteria.

System includes a number of applications for creating viewing modifying and processing digital assets and their components. Examples of these applications include renderer applications inspector applications and editor applications . Renderer applications are adapted to process components to create one or more images. Renderer applications can utilize any rendering techniques or combinations of techniques known in the art including ray casting and ray tracing scanline rendering rasterization micropolygon based or REYES rendering volume rendering and image based rendering. Renderer applications can produce images at interactive frame rates or at substantially slower rates depending upon the rendering technique the available computing resources and the desired degree of visual detail. Renderer applications can also edit and combine sequences of animation.

Inspector applications are adapted to present users with the state of one or more components. The state of components can include the values of one or more attributes. Attributes can define all aspects of a component including whether the component itself is active or is present in a scene. In some applications the association of a component or attributes thereof with one or more tasks is expressed as a task membership attribute as described above. Additionally the state of components can change over time within an animated sequence and at different points in the digital production pipeline. Inspector applications may present state information of components in a number of different formats including in the form of text tables timelines charts graphs images animations and renderings from one or more viewpoints.

Editor applications are adapted to create and modify the state of one or more components. Editor applications can utilize interfaces adapted to manipulate data in the form of text tables timelines charts graphs images animations and renderings from one or more viewpoints to create components and modify their attributes. Additionally a user can input attribute values directly using any type or combination of input devices well known in the art including keyboards mice and digitizer tablets. Additionally editor applications can analyze user input to indirectly set or modify one or more attribute values. For example a user input could be processed by a filtering algorithm in an editor application to modify several attributes simultaneously in varying amounts.

Example applications and can be combined into hybrid applications that perform inspector editor and or renderer functions together. In an embodiment system includes an application programming interface enabling any additional applications to access and modify components.

An embodiment of system includes an instantiated scene description . The instantiated scene description includes an instantiation of the complete state of one or more components for at least one scene. This can include a component such as a model a light or a camera articulation and animation data a supporting component such as a texture map or a shader or any combination of components. As discussed below the instantiated scene description instantiates the complete state of one or more components for one or more scenes. System can instantiate components on instantiated scene description for use at any point in the digital production pipeline. Components may take on different states or augment their initial state with additional attributes at different points of the digital production pipeline. Applications and can create access and modify the state of components for one or more scenes via instantiated scene description .

An embodiment of system stores and retrieves scene description such as digital assets components and their attributes from scene description database . Scene description database stores data as a structured collection of data records. An embodiment of scene description database stores digital assets components and their attributes directly in a database without any association with a specific enclosing asset data file.

Embodiments of scene description database may be implemented using any type of database model including relational database models hierarchical database models and network database models. Scene description database may store data records in volatile or non volatile memory or using persistent data storage such as magnetic or optical disks. Scene description database may use any type of data storage structure for storing data records including flat files ISAM heaps hash buckets and tree data structures such as B trees.

Scene description database includes a number of data records representing scene description data . Examples of the types of scene description data represented by data records in the scene description database include attribute value sets container and reference relationship data cached database queries and reference data to external atomic digital assets

In an embodiment each attribute value set includes an attribute name or other identifier and one or more values associated with this attribute. An embodiment of system allows attribute value sets to store any type of data including integers floating point numbers characters strings Boolean values geometry data compound data types such as vectors or tuples with two or more dimensions matrices arbitrary data structures arrays dictionaries hash tables and objects including data and methods.

In a further embodiment an attribute value set may also store an atomic entity which is a collection of binary or non binary e.g. text or XML data stored as a single entity within the scene description database . Examples of atomic entities include images or textures of one or more dimensions audio video other multimedia objects shader script or executable code in source or object format or proprietary data structures that cannot be parsed directly by the scene description database .

In an embodiment the scene description database may store a digital asset component or one or more attribute values as an atomic entity directly in the database. For example an image may be stored as an atomic entity within the scene description database rather than having separate database records for each individual pixel within the image. If access to individual pixels is requested the image will likely be loaded into an image processing application for modification.

Embodiments of the scene description database may be configured to store data as atomic entities by default or in response to commands instructions or configuration information provided by users or application. The decision to store data as an atomic entity as opposed to parsing the data into its constituent elements and storing each element separately in the scene description database may be determined on a per entity basis based on a type of the entity or based on any other criteria. Generally storing data as atomic entities results in faster database queries at the expense of less control over searching and modification less efficient data updates and more expensive data instantiation.

In a further embodiment the system and scene description database may be configured to access specific data elements within data stored as an atomic entity via an application programming interface to an external application. For example an image is stored as an atomic entity within a database record in the scene description database . However if the system receives a query requesting pertaining to the contents of the image such as the number of pixels having a specific color then an embodiment of the system directs an image processing application via an application programming interface or other inter application communications technique to open the image from the database perform any required analysis or processing of individual pixels and to return any required results to the system .

In an embodiment boundary between database data which can be searched or modified directly using operations on scene description database and atomic entity data which must be accessed and modified via another application may be invisible to end user or other applications accessing the system . For example a system may receive a request to identify all three dimensional model meshes that have points attached to a specified deformer function and add a specified shader to these meshes. If the scene description database includes separate data records for three dimensional mesh data and for the points included in the mesh this request can be satisfied by scene description database using database queries and other database operations. In contrast if the scene description database stores three dimensional model meshes as atomic entities within the scene description database then an embodiment of system converts this request into one or more accesses to a mesh editing application which in turn analyzes and or modifies the mesh data and returns result values to system . In this example system may then combine results from external applications with any results from database queries or other database operations to satisfy this request.

In an embodiment container and reference relationship data specifies a relationship between at least two of the attribute value sets . Container and reference relationship data may associate attribute value sets in one to one relationships one to many relationships many to one and or many to many relationships. In an embodiment container and reference relationship data may include a specification of a container relationship which specifies a container or encapsulation of one or more of the attribute value sets . For example a first attribute value set may define a component and a second attribute value set may define an attribute value of this component. The associated container and reference relationship data specifies that the first attribute value set defining the component contains or encapsulates the second attribute value set specifying the attribute value of this component.

In an embodiment container and reference relationship data may include a specification of a cross reference relationship. For example a first attribute value set may specify that a second attribute value set be incorporated by reference. In a further example if the second attribute value set is associated with a container relationship encapsulating one or more additional attribute value sets then the first attribute value set will incorporate the container of the second attribute value set and its one or more additional attribute value sets.

In an embodiment container and reference relationship data may include a specification of an inheritance relationship. An inheritance relationship specifies that all or part of the data associated with a first attribute value set potentially including one or more attribute value sets encapsulated by the first attribute value set are inherited from at least a second attribute value set potentially including one or more attribute value sets encapsulated by the second attribute value set.

Further embodiments of system may specify other types of relationships in container and reference relationship data including digital asset layer and other types of container data relationships network and dataflow relationships dependency relationships and namespace or other hierarchical relationships.

In an embodiment scene description database may include cache database query data . Cached database query data includes the results of one or more database queries. The cached database query data may include attribute value sets container and reference relationship data and reference data to external atomic digital assets . In an embodiment cached database query data may be generated and stored automatically by the scene description database in response to previously received database queries. In an embodiment cached database query data may be generated and stored in response to instructions commands or criteria for example received from applications users configuration settings or by default.

In an embodiment upon receiving a database query from a user or an application scene description database compares the query to stored queries associated with cached database queries . If the received query matches one of the stored queries then an embodiment of scene description database returns cached database query data corresponding with the received query. Otherwise scene description database processes the received database query to determine a query result which is returned and may also be added to the cached database query data

As discussed above an embodiment of system may store atomic entities as a single entity within the attribute value sets without any association with a specific enclosing asset data file. However in a further embodiment some or all of the atomic entities may be stored external to the scene description database. In this embodiment scene description database includes references to external atomic digital assets . The references to external atomic digital assets specify storage locations of external atomic digital assets for example as paths and file names in a file system. External atomic digital assets are stored in a persistent data storage medium and can be accessed using the references to external atomic digital assets . In still a further embodiment references to external atomic digital assets may include metadata summarizing the contents of external atomic digital assets .

In an embodiment scene description database includes an application programming interface or external module interface . Application programming interface may be used to add additional program modules to parse an external atomic entity such as a proprietary data file into its constituent elements and store each of these constituent elements separately in the scene description database as attribute value sets container and reference relationship data and or references to additional external atomic entities as well as one or more optional corresponding cached database queries

To determine the state of a component for one or more scenes an embodiment of the system generates and processes one or more queries of the scene description data. The results of this query or queries is scene description data specifying one or more attributes and associated values one or more components and or one or more digital assets. An embodiment of system reconstructs or instantiates components in memory using the query results to form the instantiated scene description . The instantiated scene description may be created from query results by an application such as renderer applications inspector applications and editor applications .

In a further embodiment optional separate instantiation application reconstructs or instantiates components using the query results to form the instantiated scene description . Other applications such as renderer applications inspector applications and editor applications may access the instantiated scene description in memory via an application programming interface or other type of interface. Optional instantiation application allows applications to access instantiated scene description without having knowledge of queries or the underlying scene description database . This allows older applications originally designed for data file based systems to be used in system with minimal or no modification.

In an embodiment applications may bypass the instantiated scene description to access and modify scene description data in the scene description database directly. For example an editor application may issues a command to the scene description database to select and modify attribute values meeting a given criteria.

Embodiments of scene description database can use any type of internal representation of data records or database schema for storing scene description data including attribute value sets container and reference relationship data cached database queries and references to external atomic entities . For example an attribute value set and its associated container and reference relationship data may be stored in a single data record of a database or in several related database records. Additional internal reference information such as key values used to associate two or more records together may be included in each data record. For example key values in multiple data records may be used to define one to one many to one one to many and many to many relationships between data records defining scene description data.

In an embodiment scene description database may be a relational database with several tables and specialized functions implementing the functionality described above. For example it is difficult to select data records linked by hierarchical relationships in relational databases.

Table 1 illustrates an example of hierarchical data stored as data records in a table of a relational database. In this example some of the employees identified by the value of the emp ref column have managers identified by the value of the manager ref column. In this example the employee graham works directly under the employer ec. Additionally the employees oreo and derose work directly under the employee graham. Thus the employees graham oreo and derose work under i.e. are in the hierarchy under employee ec. 

An example SQL statement producing this result may be formatted as mgrtree from ec hier select ec employee managers emp ref manager ref 

In this example the SQL function hier select is a specialized function of the scene description database adapted to select all of the data records under one or more specified data records at any level of a specified hierarchy. This function may be implemented natively by the scene description database or as a SQL procedure. For example table 2 lists example SQL pseudocode implementing the functionality of the SQL function hier select as a SQL procedure.

Hierarchical data records may be used by scene description database to represent container or encapsulation relationships cross reference relationships inheritance relationships layer relationships network and dataflow relationships dependency relationships and namespace or other hierarchical relationships.

In an embodiment scene description data in scene description database may include opinion resolution and cross referencing relationships. Components are specified using opinions of component attribute values. In an embodiment opinions of value are grouped into opinion sets. Each opinion set includes an opinion of value for one or more attributes of one or more components. An opinion set may be sparsely populated with opinions of attribute values specifying only a portion of the attributes properties and or relationship targets of one or more components. Many sparsely populated opinion sets may need to be combined to determine or resolve a complete specification of one or more components.

In an embodiment two or more opinion sets may specify different opinions of value for the same attribute. In this embodiment an opinion set order of resolution is used to determine the sequence of evaluation or resolution of component attribute values. The scene description data organizes opinion sets in an opinion set hierarchy. The opinion set hierarchy determines an order of resolution of opinion sets. The order of resolution specifies how the opinions of attribute values from two or more opinion sets specifying the properties and or relationships of a component should be resolved to specify the complete state of the component.

For example the opinions of value in a stronger opinion set may override the opinions of value in a weaker opinion. However because opinion sets may be sparse if a stronger opinion set does not specify any opinion of value for a given attribute the opinion of value of this attribute expressed in a weaker opinion set will pass through the stronger opinion set and be included in the final resolved component.

In an embodiment opinions of value for an attribute are expressed using the semantic structure associated with the attribute. In an embodiment opinions of attribute values are resolved in the semantic structure of the associated attribute. For example if two or more opinion sets include a first attribute that is a text string a second attribute that is an integer and a third attribute that is compound data structure then the complete resolved state of the component will include the first attribute expressed as a text string a second attribute expressed as an integer and a third attribute expressed as the compound data structure. Unlike image processing and compositing applications there is no need to convert data in opinion sets to a common format such as pixels in an image to resolve opinions of attribute values and determine the complete state of the component.

Moreover opinion sets may be referred to as heterogeneous if they include data of many different types and or many different structures. Furthermore the type and structure of data may be different for each heterogeneous opinion set. Regardless of these differences embodiments of the invention allow heterogeneous opinion sets to be resolved to determine the complete state of a component expressed using the semantic structure of its attributes.

One example of heterogeneous opinion sets is the use of layering and cross reference relationships. As described above the order of resolution of opinion sets such as layering data structures enables attribute values of components to be selectively overridden without disturbing other attribute values. Additionally cross referencing relationships enable encapsulation and reuse of components. Cross referencing relationships can encapsulate components defined by one or more opinion. One example application of opinion sets in conjunction with cross referencing relationships is the use of layering and cross reference relationships described in detail in U.S. patent application Ser. No. 11 738 953 which is incorporated by reference herein for all purposes.

The layer data structure enables the progressive refinement and incremental modification of components as needed. The cross reference relationships to components enables the encapsulation and reuse of components. Together this combination of layering and cross referencing enables data modification at any point of a collaborative workflow in any order without any loss of data in upstream or downstream activities of the workflow unrestricted and progressive modification and refinement of components unlimited branching and versioning of data at any point of the workflow and a unified system of data specification and modification that enables any aspects of the data to be added removed reused modified or extended at any point of the workflow.

Each layer may be sparsely populated that is a layer does not have to include every component in a scene and moreover a layer does not have to include opinions for the values of every attribute of any component. Each layer can specify an opinion of value for a new attribute of a component without having that attribute explicitly declared by a prior layer. A layer can include opinions of value for attributes of multiple components. Additionally empty layers can be created in early stages of the digital production pipeline as placeholders for opinions of attribute values to be provided at later stages of the digital production pipeline.

In example layer data structure layer includes an opinion that the position attribute of component should be set to a value of 0.5 and an opinion that the direction attribute of component should be set to a value of 17. As can be seen in this example the opinions of value of other attributes such as the density attribute of component is undefined in layer .

In the above example attribute values are numerical parameters. However embodiments of layer data structure allow the specification of any data type for an attribute value including integers floating point numbers characters strings Boolean values geometry data compound data types such as vectors with two or more dimensions matrices structures arrays dictionaries hash tables elements of edit decision lists references to one or more components references to one or more layers references to elements tables or other structures of a database and references to internal or external functions scripts or executable programs.

Layers provide opinions of value for attributes of components in terms of the semantic structure associated with the components. Any arbitrary abstract attribute of a component can be expressed in a layer. Furthermore one or more layers can provide opinions of value for the attribute of a component in the unique terms or semantic structure defined for that attribute. There is no need to reduce opinions of value of abstract attributes to a common or low level form such as pixels or points to resolve the values.

For example a first layer can specify a model of a character wearing a hat. One attribute of the hat could be its type such as sombrero. Thus the first layer could set a hat type attribute of the component to a value of sombrero. Thus from the view of the first layer the character model should have a sombrero. A second layer that is higher or stronger than the first layer could change the hat type attribute of the component from sombrero to top hat. Thus from the view of the second layer the character model should have top hat. A third layer that is higher or stronger than the second layer could specify that a color attribute of the hat should be purple and a material attribute should be felt. Thus from the view of the third layer the character should have a purple felt top hat. In this example each layer expresses an opinion of one or more attribute values in terms of the semantics associated with each attribute.

Furthermore a component may include a reference to another component defined by one or more layers. For example a Hat component of a character model can be a reference to a specific model of a hat. Thus when reference is set to a sombrero component the character model includes a model of a sombrero. When the reference is overridden by a layer to a top hat component the character model is changed to include a model of a top hat. Each of these models can be defined by one or more layers the attributes of which can be wholly or partially or overridden by other layers as described above.

In an embodiment every layer in the digital production pipeline is associated with one or more tasks or activities. Users can create and manipulate layers manually to provide additional control and ease of use for a component. For example the attributes of different models can be specified in separate layers. In another example related attribute values for different models in a scene can be specified in the same layer to facilitate easy manipulation. In an embodiment applications associated with activities can automatically create access and modify layers based on context such as the activity the type of component and the action being performed by the user.

The complete authored state of one or more components in one or more scenes at a given point of the digital production pipeline is determined by resolving all of the layers associated with a given point to produce a resolved layer . The resolved layer includes opinions of attribute values for the attributes specified by one or more of the associated layers. The resolved layer can also be referred to as a resolve scene description.

In an embodiment a layer stacking order determines the order in which layers are resolved. This in turn specifies how attribute values in one layer override corresponding attribute values in other layers. In an embodiment layers are assigned a strength in absolute or relative terms. For example a first layer can include a relative strength value indicating that it is stronger than or weaker than one or more other layers. In this embodiment opinions of attribute values in stronger layers will be at the top of the stacking order and will override opinions of attribute values in weaker layers i.e. layers that are lower in the stacking order. The example layer stacking order is a linear order however more complicated layer stacking orders with multiple branches can be utilized. In an embodiment layer stacking orders can be set or modified by digital production pipeline applications either manually by a user or automatically by applications. In a further embodiment the strength of layers is defined at least in part with respect to a root layer such as root layer which is by default the strongest or highest level layer.

In example layer data structure layer includes opinions and of the value of attributes and . However stacking order places layer as stronger than or ahead of layer . Thus in the resolved layer the opinions of value and of layer for attributes and will override corresponding opinions and in layer . However as layer does not define an opinion of value for attribute of component the opinion in layer will define the value of attribute in the resolved layer .

In an embodiment the scene description data structure combines two different aspects a layer data structure as described above and cross references to components. As described above the layer data structure enables the progressive refinement and incremental modification of components as needed and the cross references to components enables the encapsulation and reuse of components. Together this combination of layering and cross referencing enables data modification at any point of a collaborative workflow in any order without any loss of data in upstream or downstream activities of the workflow unrestricted and progressive modification and refinement of components unlimited branching and versioning of data at any point of the workflow and a unified system of data specification and modification that enables any aspects of the data to be added removed reused modified or extended at any point of the workflow.

In an embodiment scene description data structure specifies the relationships between components and layer data structures which express opinions of component attribute values in a hierarchical graph structure. Nodes of scene description data structure may correspond with components such as data representing geometry texturing shading articulation animation simulation layout lighting or rendering or with layer data structures.

In an embodiment the hierarchical graph structure includes three different types of relationships between components and layers namespace relationships layer relationships and reference relationships. Namespace relationships establish the namespace or other nomenclature used to identify and organize components. Namespace relationships are used to assign components identities to match up components from different layers that should override each other and to provide the scope of inclusion for references. Alternative embodiments can utilize other attributes such as globally unique identifiers GUIDs to arrange components and layer data structures within the scene description data structure.

Layer relationships specify the relationship between a layer data structure and one or more sublayers. Layer relationships specify the layer stacking order used to resolve or combine layers to determine attribute values of components.

Reference relationships provide links to components specified elsewhere. A reference relationship from a first component in a first layer data structure can reference a second component defined in the same layer data structure a second component in another layer data structure associated with the first layer data structure or a second component in another layer data structure that is not associated with the first layer data structure. Implementations of reference relationships can be restricted to directly referencing only the root component in another layer data structure with any child components referenced implicitly using namespace relationships associated with the root component or alternatively can be unrestricted to allow direct referencing of any arbitrary component in another layer data structure.

In an embodiment the scene description data structure includes a root layer for the scene. In an embodiment the relationships of the hierarchical graph between components and layer data structures are specified at least in part by root layer . Child nodes such as root component and sublayers hierarchy can be directly associated with the root layer .

In an embodiment of the hierarchical graph each non empty layer data structure including the root layer includes at least one root component such as root component . Additional components within the layer data structure are associated as child nodes or grandchild or other descendant nodes of the root component. As an example of this embodiment one or more additional components are associated via namespace relationships as descendant nodes of root component .

In an embodiment the namespace relationships between component nodes in a layer are specified in the form of relationship attributes of components. For example component can include a parent attribute which would be set to reference component . In another embodiment a component can include a child relationship attribute specifying one or more child components of the component. For example root component can include a child relationship attribute which would be set to reference components .

In an embodiment of the hierarchical graph each additional layer data structure of the scene description data structure is a descendant or sublayer of the root layer. As an example of this embodiment the root layer is associated with one or more additional layer data structures via layer relationships . In an embodiment the arrangement of layer data structures relative to the root layer and each other specifies the layer stacking order used to combine and override opinions of component attribute values to form the resolved layer. Although omitted for clarity in an embodiment of the scene description data structure each additional layer data structure that is not empty includes its own root component similar to root component . Furthermore sublayers can include additional components associated with their respective root components via namespace relationships.

In a further embodiment reference relationships such as reference relationship provides a link to one or more components specified elsewhere. A reference relationship from a first component in a first layer data structure can reference a second target component defined in the same layer data structure in another layer data structure associated with the first layer data structure or in another layer data structure that is not associated with the first layer data structure. Implementations of reference relationships can be restricted to target only the root component in another layer data structure with any child components referenced implicitly or alternatively can be unrestricted to directly referencing any arbitrary target component in another layer data structure.

In an embodiment the graph or set of relationships between components and layers defined by the scene description data structure can be orthogonal or completely independent of any other optional graphs associated with the same components. Graphs can be used to define different sets of relationships for the same components in different scenes. For example a second scene description data structure can be created to specify different relationships between components for additional scenes. Additional layers included in the second scene description data structure can further specify different attribute values for the components.

In an embodiment relationship attributes of components can also specify functional relationship between components. For example relationships between coordinate transformation components can specify a specific sequence for applying transformations to models. In a further embodiment relationship attributes can include additional data defining some parameter of a relationship. For example a light source component can be related to a first model component which indicates that the light source component provides light to the model component. The lighting relationship between these two components can further include a light intensity value to indicate the intensity of light from the light source on the first model. If a second lighting relationship is created between the light source component and a second model component the second lighting relationship can include a different light intensity value.

In an embodiment system specifies scene description data in terms of attributes and relationship in layers and layer hierarchies. In this embodiment attribute value sets are stored in scene description database . One or more layers encapsulating attribute value sets are defined as containers and stored as part of the container and reference relationship data in the scene description database . Additionally layer relationships defining one or more layer stacking orders between layers are also defined as part of the container and reference relationship data . Container and reference relationship data also includes cross reference relationships and namespace relationships as well as any other types of relationships between components.

In this embodiment an application such as applications and or an optional instantiation application uses database queries to retrieve one or more layers from the scene description database . Layers retrieved from the scene description database may include attribute value sets and associated container and reference relationship data defining components and digital assets. These attribute value sets and the associated container and reference relationship data may also be retrieved as needed using database queries. The application also retrieves one or more layer stacking orders from the scene description database using database queries or uses an implicit or explicit layer stacking order specified with another data source. Using a layer stacking order an application resolves the retrieved layers and resolves cross references as described by to define scene description data in a form similar to scene description data structure representing the components and digital assets defined by the data retrieved from scene description database . The scene description data can then be instantiated to form instantiated scene description in memory for use by one or more applications.

As described above different layers can be specified in different portions of a workflow and or by different users enabling data to be revised or refined without the need for explicit change isolation or versioning and without destroying the data previously specified in weaker layers. This allows an independent variation of the data to be created and used without affecting the usage elsewhere of either the original data or any other variation of the same data. Moreover because layers can express opinions of value for any attribute of data there are no restrictions on the type or extent of modifications permitted on referenced data. Furthermore if the data includes reference relationships to all or a portion of a layer data structure other data may be encapsulated reused and optionally modified by any other data at any point in the workflow.

Although the above described systems and methods have been described with reference to components digital assets and digital production pipelines the scene description data structure and its layering and referencing relationships can be generalized for use with applications and data of any type stored in a database including text and word processing data spreadsheet data database tables and objects engineering blueprints schematics and specifications and object orientated data structures. The generalized forms of these data structures and the above described methods of manipulating these data structures are particularly useful in non linear workflows. Nonlinear workflows can include collaborative working environments in which multiple users work on the same data. Nonlinear workflows can also enable one or more users to generate multiple variations of the data at any arbitrary point of the workflow without destroying data associated with previous or subsequent portions of the workflow. For example a user could use the above described systems and methods to create multiple financial scenarios within a spreadsheet application based on a common set of initial conditions.

Each of the layers includes one or more data records including for example data record X in layer A and corresponding data records X and in layers B and C respectively. In an embodiment layers of table may be sparsely populated with data records . In this embodiment if one layer includes a data record the other layers do not need to include a corresponding version of this data record.

Each of the versions of data record X in the different layers includes one or more attributes and values. For example record X in layer A includes attribute and value set attribute and value set and attribute and value set . Similarly record X in layer B includes attribute and value set and attribute and value set . Record X in layer C includes attribute and value set and attribute and value set .

In this example data records are sparsely populated with attribute and value sets. If one data record in one layer includes an attribute and value set a corresponding version of the data record in another layer does not have to include this attribute and value set. Furthermore an embodiment of table may be implemented with a database model and or schema in such as way as to allow additional attribute and value sets to be added to data records at any time without substantial overhead. For example data record X in layer C includes attribute and value set even though this attribute and value set is not defined in any other layer for this data record.

In the example a database query includes a selection criteria specifying the characteristics of data records to be retrieved from table and optionally a result format specifying the arrangement of any data records selected from the table . In an embodiment the database query may optionally include a layer stacking order explicitly selecting all or a portion of the layers of the table to be considered in processing the database query and the order that the selected layers should be resolved. Alternatively a database query may omit the layer stacking order and instead rely on a implicit layer stacking order . Embodiments of the implicit layer stacking order include layer stacking orders specified directly or based on criteria defined by default in response to commands instructions or configuration information from users or applications and or attributes of the layers themselves and stored in the database.

In response to a database query and a layer stacking order an embodiment of example returns a resolved query result . The resolved query result includes the data records selected by the selection criteria of the database query and then resolved according to the appropriate layer stacking order . For example if the layer stacking order used with database query specifies that layer C is stronger than layer B and layer B is stronger than layer A then the resolved query result shown in will result.

Resolved query result includes a resolved version of record X . Resolved record X includes a copy of attribute and value set from layer A . Resolved record X includes a copy of attribute and value set from layer B overriding the attribute and value set from layer A . Resolved record X includes a copy of attribute and value set from layer C overriding the attribute and value sets and from layers A and B . Resolved record X also includes a copy of attribute and value set from layer C

In this embodiment the schema or structure of attributes and values in a resolved data record is not fixed. Rather the set of attributes and values included in a resolved data record is dependent on the layers of the table included in the query. For example if a first database query requests database record X and selects layer A A and layer B B the resulting composited query result will be a first resolved instance of data record X that includes attribute attribute and attribute . In this example the schema or structure of first resolved instance of data record X will not include attribute for the first resolved instance of data record X attribute is undefined and does not exist in the first resolved instance of data record X.

Continuing with this example if a second database query also requests database record X and selects layer B B and layer C C the resulting composited query result will be a second resolved instance of data record X that includes attribute attribute and attribute . In this example the schema or structure of second resolved instance of data record X will not include attribute for the second resolved instance of data record X attribute is undefined and does not exist. Thus the structure of data or schema within a resolved data record may change depending upon the combination of layers selected by the query.

In a further embodiment attribute and value sets from one layer may be suppressed by an attribute and value set from a stronger layer such that the resolved version of the record does not include a given attribute value set. For example record X in layer A includes an attribute and value set . Record X in layer B includes an attribute suppression indicator corresponding with attribute and value set . During the data record solution processing the attribute suppression indicator will override the existence of attribute and value set . As a result the resolved query result does not include any attribute and value set corresponding with attribute and value set

In an embodiment layering and resolving may be implemented as native capabilities within the data structures and functionality of a database. In another embodiment a table with layering functionality as shown in example may be implemented using specialized database schema and query procedures on non layered database tables. For example table may implement layering as a field or an attribute in an additional column of a data record. To implement a layered query a database procedure may issue one or more database queries to select data records associated with each layer. The database procedure may then issue further database queries on the data records of each layer to resolve data records according to a layer stacking order resulting in a resolved query result. In this example applications may view the database as natively providing layering functionality. Database application programming interfaces and database procedures translate layered database queries and commands into equivalent non layered database commands.

User input devices communicate user inputs from one or more users to the computer system examples of which may include keyboards mice joysticks digitizer tablets touch pads touch screens still or video cameras and or microphones. Network interface allows computer system to communicate with other computer systems via an electronic communications network and may include wired or wireless communication over local area networks and wide area networks such as the Internet. An audio processor is adapted to generate analog or digital audio output from instructions and or data provided by the CPU memory and or storage . The components of computer system including CPU memory data storage user input devices network interface and audio processor are connected via one or more data buses .

A graphics subsystem is further connected with data bus and the components of the computer system . The graphics subsystem includes at least one graphics processing unit GPU and graphics memory . Graphics memory includes a display memory e.g. a frame buffer used for storing pixel data for each pixel of an output image. Graphics memory can be integrated in the same device as GPU connected as a separate device with GPU and or implemented within memory .

Pixel data can be provided to graphics memory directly from the CPU . In some implementations instructions and or data representing a scene are provided to renderfarm or set of server computers each similar to computer system via the network interface or storage . The renderfarm generates one or more rendered images of the scene using the provided instructions and or data. These rendered images are returned to the computer system for display.

Alternatively CPU provides the GPU with data and or instructions defining the desired output images from which the GPU generates the pixel data of one or more output images. The data and or instructions defining the desired output images can be stored in memory and or graphics memory . In an embodiment the GPU includes 3D rendering capabilities for generating pixel data for output images from instructions and data defining the geometry lighting shading texturing motion and or camera parameters for a scene. The GPU can employ any surface or volume rendering technique known in the art to create one or more rendered images from the provided data and instructions including rasterization scanline rendering REYES or micropolygon rendering ray casting ray tracing image based rendering techniques and or combinations of these and any other rendering or image processing techniques known in the art. The GPU can further include one or more programmable execution units capable of executing shader programs. GPU can be comprised of one or more graphics processing unit cores.

The graphics subsystem periodically outputs pixel data for an image from graphics memory to be displayed on display device . Display device is any device capable of displaying visual information in response to a signal from the computer system including CRT LCD plasma OLED and SED displays. Computer system can provide the display device with an analog or digital signal.

In embodiments of the invention CPU is one or more general purpose microprocessors having one or more homogenous or heterogeneous processing cores. In further embodiments all or a portion of the graphics subsystem or GPU is integrated into CPU .

Further embodiments can be envisioned to one of ordinary skill in the art after reading the attached documents. In other embodiments combinations or sub combinations of the above disclosed invention can be advantageously made. The block diagrams of the architecture and flow charts are grouped for ease of understanding. However it should be understood that combinations of blocks additions of new blocks re arrangement of blocks and the like are contemplated in alternative embodiments of the present invention.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

