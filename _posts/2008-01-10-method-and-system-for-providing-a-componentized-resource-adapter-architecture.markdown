---

title: Method and system for providing a componentized resource adapter architecture
abstract: A computer program product comprises a computer useable medium. The computer useable medium has a computer readable program such that when the computer readable medium is executed on a computer, the computer is caused to configure an adapter such that the adapter is specific to a data source, provides a communication link to the data source, converts a format of the data source to a format native to a middleware system, and converts a format of metadata of the data source to a standard metadata format. Further, the computer is caused to configure an application interface component to convert an invocation of a function in the middleware system to an invocation of a function provided by an Enterprise Information System through the adapter, convert the data format of the middleware system to a format native to the Enterprise Information System accessed through the adapter, and maintain metadata describing a message format and a function provided by the adapter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495594&OS=08495594&RS=08495594
owner: International Business Machines Corporation
number: 08495594
owner_city: Armonk
owner_country: US
publication_date: 20080110
---
This disclosure generally relates to software integration. More particularly the disclosure relates to connectivity to Enterprise systems.

A variety of middleware products are currently utilized to support business software applications. Examples of such middleware products include transaction processing systems message processing systems and Extract Transform Load ETL systems. The various middleware systems have different performance profiles and requirements. Some middleware systems deal with relatively small amounts of data but need to process requests very quickly. Other middleware systems deal with very large amounts of data and need to access this data in pieces of manageable size.

As a result a business software environment may include a large number of runtimes which are engine servers or software applications performing a function that need to access data from external resources. In many cases adapters have been developed for these products to access an external Enterprise Information System EIS such as a database transaction processing system etc. As a result a multitude of adapters have been built using various technologies to provide access to the same resources. This overlap provides tremendous expense e.g. development costs and maintenance costs for the software developer. Further end users are exposed to inconsistencies in the tools and capabilities of the connectivity solutions provided by different products.

Current approaches do not allow for standard connectivity to Enterprise systems from different runtime environments because the current standards are defined for specific environments e.g. Java Platform Enterprise Edition Java EE . Accordingly these current approaches do not permit the reuse of adapters between different runtime environments e.g. Application Server Information Management or System Management.

Attempts have been made to share adapters between products. However these attempts have failed for a multitude of reasons. One reason is that the interfaces are often incompatible with one another. Further additional infrastructure that is foreign to the software environment often needs to be utilized. In addition data and or format conversions which can be costly with respect to central processing unit CPU performance may need to be utilized.

In one aspect of the disclosure a computer program product comprises a computer useable medium. The computer useable medium has a computer readable program such that when the computer readable medium is executed on a computer the computer is caused to configure an adapter such that the adapter is specific to a data source provides a communication link to the data source converts a format of the data source to a format native to a middleware system and converts a format of metadata of the data source to a standard metadata format. Further the computer is caused to configure an application interface component to convert an invocation of a function in the middleware system to an invocation of a function provided by an EIS through the adapter convert the data format of the middleware system to a format native to the EIS accessed through the adapter and maintain metadata describing a message format and a function provided by the adapter.

In another aspect of the disclosure a process is provided. The process configures an adapter such that the adapter is specific to a data source provides a communication link to the data source converts a format of the data source to a format native to a middleware system and converts a format of metadata of the data source to a standard metadata format. Further the process configures an application interface component to convert an invocation of a function in the middleware system to an invocation of a function provided by an EIS through the adapter convert the data format of the middleware system to a format native to the EIS accessed through the adapter and maintain metadata describing a message format and a function provided by the adapter.

In yet another aspect of the disclosure a system is provided. The system includes an adapter. The adapter is specific to a data source provides a communication link to the data source converts a format of the data source to a format native to a middleware system and converts a format of metadata of the data source to a standard metadata format. Further the system includes an application interface component that converts an invocation of a function in the middleware system to an invocation of a function provided by an EIS through the adapter converts the data format of the middleware system to a format native to the EIS accessed through the adapter and maintains metadata describing a message format and a function provided by the adapter.

A componentized resource adapter architecture can be utilized to consolidate the multiple approaches and migrate towards a single adapter for each resource. The single adapter can then be shared by all products that need access to that resource. In other words a componentized resource adapter can be configured for use by multiple runtimes. Architectural differences in software environments are eliminated as the componentized resource adapter architecture enables interface components to be tailored specifically for each product that wishes to consume the adapters. Accordingly efficient and reusable connectivity components can be built. As an example the componentized resource adapter architecture can be based on the J2EE Connector Architecture 1.5 JCA along with extensions to resolve ambiguities in the specification and to address the requirements for metadata efficient data handling and problem determination.

The componentized resource adapter architecture can be utilized to build a common set of adapters to various data sources despite the differences in how middleware systems represent data. Accordingly while an adapter is specific to a data source the adapter is independent of the middleware systems and the data representation of the middleware systems. At the same time in one embodiment the middleware systems interface to various adapters through a single well defined interface.

Accordingly the componentized resource adapter architecture provides a single approach for adapter development and evolution. Further the componentized resource adapter architecture may implement recognized standards provide incentives for partners and third parties to develop connectors based on these standards. For example the componentized resource adapter architecture can support the Java and J2EE environments but allows other runtimes to exploit the adapters also. The componentized resource adapter architecture also enables efficient high performance runtime independent data handling for the exchange of large amounts of data. Further the componentized resource adapter architecture allows the development of adapter components with pluggable subcomponents that fit a common framework.

The adapter tooling in the componentized resource adapter architecture can connect to EISs and discover the data definitions and services they support. Further services can be built for EIS systems that support metadata discovery as well as resources that do not support metadata discovery e.g. a file system.

The componentized resource adapter architecture has a plurality of runtime standards. The first runtime standard applies to the data exchange interfaces. Three core runtime components are utilized to provide a flexible adapter framework with clear component boundaries. These core runtime components are the application interface connector and common services components. In particular the data exchange interface between the connector and application interface components is data independent. These runtime components support data formats that are independent of the runtime data format a metadata format shared between adapters and runtimes both inbound and outbound interactions complex data structures and multiple data formats e.g. Records Rows Documents Streams request response and cursor interactions and Performance Optimization e.g. large data volume support partitioning and streaming and minimized need for conversion copying and canonicalization 

Further the second runtime standard is inbound and outbound processing support. Whenever allowed by an EIS the adapter supports multi directional requests such that it is possible to initiate interactions from either side of the integrated EIS solution.

Finally the third runtime standard is topology. This standard helps ensure that adapters can operate within a variety of topologies to accommodate different integration scenarios. The adapters should meet systems management requirements for recovery when a sub system in a deployed integrated solution fails. Further the adapters should support remote deployment that is independent from the integration server as opposed to the more normal local deployment. The adapters should also support local adapter deployment as components inside a lightweight integration server.

Performance and scalability can also be measured. The adapters should provide sufficient throughput to meet the high performance demands of ETL scenarios scale to support peak user loads without degrading performance objectives provide end to end performance that is comparable to JCA adapter providers and provide end to end performance that is comparable to non JCA adapter providers.

An adapter component encapsulates basic connectivity to the EIS and the exchange of the data with the EIS. The adapter component can be driven by the metadata describing interactions with the EIS. In one embodiment the adapter component includes separate subcomponents for connecting to the EIS and for exchanging data. The first subcomponent is a connectivity subcomponent and the second subcomponent is a data exchange subcomponent .

The connectivity subcomponent includes functionality for establishing maintaining and closing connections to the target EIS. Further the connectivity subcomponent provides support for transactions and security for these connections. The connectivity subcomponent interacts with the specific libraries and functionality of the target EIS. The connectivity subcomponent is exposed to the application interface component through standard JCA common client interfaces CCI including Connection ConnectionFactory Interaction and InteractionSpec for outbound and ResourceAdapter and ActivationSpec for the inbound.

The data exchange subcomponent includes functionality for passing or receiving data from the application component through the data exchange interface. This interface is format neutral and runtime neutral. Accordingly the interface permits any kind of structured or streamed data to be moved between these components. The adapter understands the data format of the EIS and is able to convert it to invocations of Data Exchange interface.

The connector component is developed by the connector provider who has knowledge of the target EIS its interfaces and its behavior. The connector provider can be the EIS vendor a dedicated connector vendor or an in house developer providing access to the required EIS.

The Application Interface Component is a bridge between the runtime environment e.g. a Middleware Application and the adapter . The Application Interface Component enables invocation of the adapter from the clients by using the appropriate programming model. Further the Application Interface Component is responsible for mapping the specific invocation to the invocation of the adapter through the JCA CCI. The component developer who has knowledge of the connector invocation interfaces and the runtime programming model delivers the Application Interface Component . The Application Interface Component consists of a data exchange subcomponent an application interface subcomponent and metadata .

The data exchange subcomponent is an implementation of data exchange interfaces in the Application Interface Component . Accordingly the data exchange subcomponent converts the invocations of the data exchange interfaces to runtime specific data representations. Further the application interface is the interface that matches the runtime programming model and maps runtime specific invocations to the invocation of the adapter through CCI. In addition the metadata describes the structure of the data exchange with the EIS through the Data Exchange Service Provider Interface DESPI which is a set of interfaces to exchange data with the adapter . The metadata can also provide information to the adapter about how the data can be exchanged with the EIS.

A metadata format common between the adapter and the application interface component is supported to allow the structure of the data exchanged through the DESPI interface to be defined. For example the externalized metadata definition format may be based on Service Data Objects SDO specification version 2.1 and represented by the SDO Type.

In one embodiment the metadata produced by the adapter is in the form of annotated Extensible Markup Language XML schemas. The annotations contain application specific information which the adapter utilizes at runtime to associate objects or individual properties with the equivalent in the external resource. This application specific information or appinfo can be used to identify key fields mappings to external types or for any other purpose that the adapter dictates. The appinfo should be treated as an opaque string by all components other than the adapter . At runtime definitions convey the metadata to the adapter . These definitions are typically constructed from the imported XML schemas. Some environments may prefer to programmatically construct the metadata from their own metadata representation which would have been created from the original XML schemas. Any appinfo annotations in the schemas should be preserved by such environments and then provided along with the type definition for consumption by the adapter .

The architecture component model allows a plurality of input sources available through adapters to interact with multiple runtimes by reducing the number of distinct interfaces from M N to 1 N and or M 1. Further the data exchange set of interfaces eliminates the need for an intermediate object as seen for example in SDO when an intermediate SDO object needs to be built and converted to a native object if SDO is utilized to move data between an adapter and a middleware system that does not operate natively with SDO objects. In addition the lack of a defined format for the data to be exchanged between an adapter and its client as seen with JCA is alleviated by the data exchange set of interfaces. Accordingly middleware systems can much more easily adopt JCA by utilizing the data exchange set of interfaces.

The architecture component model intended to support as many runtime and design environments as possible. The adapters developed from the architecture component model are accessible by all runtimes.

The choice of implementation language for adapters is determined by the client Application Programming Interface API that the adapter uses to communicate with the external resource. provides an example of the architecture component model providing support for Java adapters . However this illustration is intended only as an example as the architecture component model can provide support for various languages. Accordingly Java adapter can be built. A Java runtime interacts with the Java adapter through a Java Application Interface. Further the Java Service Provider Interface SPI provides the set of interfaces to exchange data with the Java adapter .

The Java adapters are implemented according to the JCA specification with some extensions. Accordingly the JCA is extended to support several new capabilities. The JCA CCI does not define any data exchange interfaces. Interactions use the opaque Record interface the implementation of which is entirely determined by the Java adapter . This lack of specificity makes it impossible to use a Java adapter without first developing some custom code to create and interpret a Java adapter s Record objects. The Java SPI defines a standard data exchange interface that is utilized to efficiently transfer data between the Java adapter and the Java Application Interface . Further the Java adapter may be utilized for multiple runtimes.

To support DESPI e.g. the Java SPI the JCA CCI is extended with connected records and streams as first class entities. The connected CCI Records maintain active connection to their data source and allow sequential retrieval of records. The connected Records should be supported in both non managed or managed mode. The Records allow the invoker to close the connection. The connected record is not serializable or remotable. When an attempt is made to serialize the connected record the provider must provide the serialization by performing a full data retrieval and store and then issue a warning about suboptimal use of the record. If the serialization could cause unpredictable behavior because of the retrieved data size the Record instead may throw an exception.

In many cases the data accessible through the connector is available in the stream format. The DESPI e.g. the Java SPI exposes streams as first class Records to allow passing of streams between the Java adapter and the Java Runtime for inbound and outbound connectivity

Record classes can be generated for performance benefits. The architecture component model also permits the use of record implementations that provide metadata to be dynamically processed.

As an example the module synchronizes contact information between a file adapter and Customer Information Control System CICS . The ContactSync component listens via an Export for a notification of changes to contacts. The ContactSync component then propagates changes to the CICS system utilizing an Import .

The Import and the Export bridge the gap between SCA components and external EIS systems available through J2C resource adapters. In other words the Import and the Export form the Application Interface Component that exposes EIS services to SCA clients.

The binding of invocations to EIS services is done at three levels interface method and data. The interface binding describes the mapping between EIS Service connection information and the Service interface that represents this service. The method binding expresses the relationship between interface s operations information needed to perform interaction with the EIS service. Finally the data binding defines how the Service input or output data is mapped to the EIS data format.

The Imports and the Exports are provided using the Service Component Definition Language SCDL to describe the bindings Web Service Definition Language WSDL to describe interface of the service and XSDs to describe the data exchanged with the service.

The sample code is utilized for a client to invoke the Import . First the client creates an instance of the ServiceManager and looks up the Import using its reference name. The result of the lookup is a service interface implementation. Subsequently the client creates with the user of an interface implementation an input argument dynamically using the data object schema. This input argument is a generic DataObject. Finally the client invokes EIS and obtains the result.

The sample code is utilized to provide access to the functionality of the services provided by the CICS. The client of the adapter interacts with it using the service interface that is converted to the invocation of the adapter s CCI interfaces.

In general the module is a managed scenario. For example the module may be represented and packaged as a J2EE EAR file. The resource adapter may be deployed either inside the EAR file during EAR installation or separately at the node level with its artifacts created during the application install for either of these cases. The non managed mode is also supported.

In yet another embodiment a process is provided for the middleware system to utilize the architecture component model . The process configures an adapter to access a particular data source instance or the metadata repository corresponding to that specific data source instance. Further the process requests through the architecture component module a list of functions and the corresponding message formats provided by a data source. In addition the process utilizes the returned metadata to allow the selection of the subset of functions required for the given business application. The process also utilizes the returned metadata to build an abstract representation of the selected data source functions and messages. Further the process serializes the abstract functions and messages utilizing the data formats and function of method invocation model of the middleware system. In addition the process builds an application of the middleware system that utilizes the functions of the data source. The process also deploys the application that utilizes functions of the data source. Finally the process utilizes the architecture component model to send and receive data with the data source as directed by the application.

The processor is coupled either directly or indirectly to the memory through a system bus. The memory can include local memory employed during actual execution of the program code bulk storage and or cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

The input output devices can be coupled directly to the system or through intervening input output controllers. Further the input output devices can include a keyboard a keypad a mouse a microphone for capturing speech commands a pointing device and other user input devices that will be recognized by one of ordinary skill in the art. Further the input output devices can include a receiver transmitter speaker display image capture sensor biometric sensor etc. In addition the input output devices can include storage devices such as a tape drive floppy drive hard disk drive compact disk CD drive etc.

Network adapters may also be coupled to the system to enable the system to become coupled to other systems remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

It should be understood that the method and system described herein can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. If software is utilized to implement the method or system the software can include but is not limited to firmware resident software microcode etc.

Further the method and or system can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purpose of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a RAM a ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include CD read only memory CD ROM CD read write CD R W and DVD.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

