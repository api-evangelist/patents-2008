---

title: Client-side management of domain name information
abstract: An exemplary method includes booting a computing device, in response to the booting, accessing a file that includes domain names and resolving at least one of the domain names by issuing a request to a server where the resolving occurs as a background process. An exemplary method includes receiving a notice to invalidate client DNS resolver cache information for a domain name, accessing a list of client subscribers to an invalidation service for the domain name and issuing an instruction to the client subscribers to invalidate their respective client DNS resolver cache information for the domain name. An exemplary method includes receiving a request to resolve a domain name, resolving the domain name and transmitting information for the resolved domain name and additional information for at least one other domain name. Other methods, devices and systems are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966121&OS=08966121&RS=08966121
owner: Microsoft Corporation
number: 08966121
owner_city: Redmond
owner_country: US
publication_date: 20080303
---
Many applications can connect to or require connection to remote resources on the Internet. For example a web browser application allows a user to enter a domain name and then access a host server associated with the domain name. While the user is normally unaware of underlying processes required to connect to the host server the user s experience is more favorable when these processes occur quickly. Unfortunately issues like congestion stemming from rising Internet traffic e.g. due to web innovations globalization and increasing connectivity to billions of people in emerging markets can increase significantly the amount of time required for underlying processes and hence diminish the user s experience.

Various exemplary methods devices systems etc. described herein pertain to techniques for client side management of domain name information that can enhance a user s Internet experience.

An exemplary method includes booting a computing device in response to the booting accessing a file that includes domain names and resolving at least one of the domain names by issuing a request to a server where the resolving occurs as a background process. An exemplary method includes receiving a notice to invalidate client DNS resolver cache information for a domain name accessing a list of client subscribers to an invalidation service for the domain name and issuing an instruction to the client subscribers to invalidate their respective client DNS resolver cache information for the domain name. An exemplary method includes receiving a request to resolve a domain name resolving the domain name and transmitting information for the resolved domain name and additional information for at least one other domain name. Other methods devices and systems are also disclosed.

Various exemplary methods devices system etc. described herein pertain to client side management of domain name information in a Domain Name System DNS . Domain name information may be information as included in a DNS Resource Record RR and or other information associated with a domain name. An exemplary client side mechanism prefetches domain name information as a background process for example at boot during empty or unused cycles. Such a mechanism can enhance a user s experience when the user wants to connect to a host server for a domain name that the user connected to in a previous session. For example the prefetch mechanism can access a persistent record or cache of a user s frequently requested domain names and then resolve at least some of these domain names as a background process during boot. Prefetching ensures that the client resolver cache has fresh information for the domain names and allows the user to connect to one or more appropriate host servers without having to wait for resolution by a DNS server.

Another exemplary mechanism allows for invalidation of client side domain name information. A client side DNS cache typically caches a Resource Record for a domain name for a period of time specified by a value referred to as time to live TTL . When the TTL expires a client side DNS service e.g. a resolver or name resolution service makes a request to re resolve the domain name. As short TTLs can increase network traffic TTLs are typically long e.g. a day . For any of a variety of reasons relatively instantaneous invalidation of client side domain name may be desired. An exemplary invalidation mechanism can invalidate client side domain name information and cause a client DNS service to request fresh information. Alternatively such a mechanism may simultaneously invalidate and refresh client side domain name information.

Yet another exemplary mechanism allows for management of information for groups of domain names. In general a client wants to avoid issuing requests for name resolution as such requests increase network traffic and require action by one or more servers. An exemplary grouping mechanism allows a client to acquire information for more than one domain name when issuing a request for resolution of a single domain name.

An exemplary client architecture optionally includes a failover module that fails over a client application to a new host server. An exemplary client architecture optionally includes an Internet Location Coordinate ILC module that operates in conjunction with an ILC enhanced DNS system with beacons that help provide information to participants about their respective locations in a network space. A participant in an ILC enhanced DNS system can be any resource on the network e.g. a client a server etc. . In various examples transmission of location information e.g. ILCs can occur via DNS and TXT records via Extensions to DNS EDNS and explicit new record types or entirely outside DNS but applied to select an address returned by a DNS query.

According to the method in a boot block a client computing device client starts up and loads old DNS information from a file e.g. written before the client shut down into the client s DNS resolver cache. In the boot block the boot time is designated T and the age of the old DNS information is designated T though the file will likely contain multiple domain names that were fetched at different times. In a request block the client makes a request to resolve a domain name. In an access block the client accesses its DNS resolver cache which contains the old DNS information. A decision block follows that decides if an IP address exists in the cache for the domain name. If the decision block decides that no IP address exists in the cache then the client resolves the domain name via a DNS server per the resolution block see e.g. description for method . However if an IP address exists for the domain name in the client side DNS resolver cache as preloaded then the client connects to the associated host server per the connection block . In this branch the domain information will only be considered fresh and hence usable if T T is less than the TTL for that domain name where the TTL was returned along with the domain name s IP addresses in the DNS response message.

According to the method in a boot block a client computing device client starts up and loads old DNS information from a file into the client s DNS resolver cache. In the boot block the boot time is designated T and the age of the old DNS information is designated T. In the example of it is assumed that the file includes at a minimum one or more domain names. The file may optionally include other information such as in the method . When the file is loaded a background process commences that includes a resolution block that resolves one or more domain names included in the file. In the example of the domain name information acquired for a particular domain name by the resolution block is assigned a time T . As already explained a name resolution process issues a request to a DNS server to for example acquire a Resource Record for a domain name. In turn information received from the DNS server is loaded into the client s DNS resolver cache. The background process may execute during empty or unused cycles during start up of the client computing device or at others times during the use of the computing device. The background process may be limited in terms or execution time and the number of domain names to resolve or it may be limited to increase the total DNS traffic by no more than a constant factor over what the user s actions would have naturally incurred. For example the process may be restricted to the first five minutes after boot and or be limited to about twenty domain names. While such a process may be customized by a user it may be programmed by default to execute automatically without user input or user awareness. The prioritization of domain names to fetch may be based on prior history of domain name requests likely prioritizing those prior name requests that would not be served from the local DNS resolve cache if they recurred.

At some time after boot per a request block the client requests resolution of a domain name. At a time T where T is greater than T the client accesses its DNS resolver cache. A decision block follows that decides if an IP address exists in the resolver cache for the domain name. If the decision block fails to find an IP address then a resolution block resolves the domain name via a DNS server. According to this branch the domain name was not amongst the one or more domain names resolved by the background process . If the decision block finds an IP address for the domain name in the client s DNS resolver cache then it is a fresh IP address possibly acquired at time T . In other words if the domain name specified in the request block is a domain name resolved by the background process then the domain name information is no older than T .

In comparison to the method the method enhances a user s experience as it can provide for quicker connections to network resources for one or more domain names. In comparison to the method the method guarantees freshness of domain name information for one or more domain names.

The kernel space includes various components that operate in conjunction with a TCP IP stack . Such a stack typically operates via a network driver interface specification NDIS to communicate with network resources via frames . The TCP IP stack includes a transport layer a network layer and a framing layer. As shown frame carries an IP datagram and frame carries an IP datagram and Internet Location Coordinate ILC information see e.g. .

The architecture may include the following APIs by which applications services or other system components access the TCP IP stack 

Sockets API used by Sockets based applications and services. The Sockets API operates through an Ancillary Function Driver AFD to perform Socket functions with the TCP IP stack .

Transport Driver Interface TDI used by NetBIOS over TCP IP NetBT clients and other legacy TDI clients. A translation layer exists between TDI and the TCP IP stack .

The TCP IP stack exposes an inspection API which provides a consistent general purpose interface to perform deep inspection or data modification of packet contents. The Inspection API is part of a filtering platform. The TCP IP stack provides access to the packet processing path at the Network and Transport layers.

The architecture includes an exemplary failover module which may be configured in any of a variety of manners. For example the failover module may be configured to directly access information in the TCP IP stack . The module may be configured to use the inspection API . The failover module may also be configured to expose an API for user space applications. The failover module may be part of or function cooperatively with the DNS service . For example the failover module may be a separate OS service that can retrieve information from the resolver cache or resolver file .

The architecture also includes an ILC module which provides for processing Internet Location Coordinate ILC information. Such information is described in more detail with respect to . The ILC module may be configured to operate in conjunction with the failover module . For example failover may occur based at least in part on ILC information. The ILC module may be part of or function cooperatively with the DNS service . For example the ILC module may store ILC information in a cache and or a file associated with the DNS service .

The architecture includes the exemplary prefetch module which may be configured in any of a variety of manners. For example the prefetch module may be configured to directly access information in the TCP IP stack . The module may be configured to use the inspection API . The prefetch module may also be configured to expose an API for user space applications. The prefetch module may be part of or function cooperatively with the DNS service . For example the prefetch module may be a separate OS service that can retrieve information from the resolver cache or resolver file . Alternatively another cache or file may be available that maintains information between boots of a client computing device i.e. a persistent information store .

The prefetch module may be configured to operate in conjunction with the failover module and or the ILC module . For example the prefetch module may fetch information for use by the failover module and the prefetch module may fetch information based at least in part on ILC information.

The system may depend on time distance network traffic machine workload bandwidth etc. To understand better how such a system may be defined consider a vehicle on a major interstate highway en route to an airport. At various locations along the highway the state department of transportation transmits information to displays that provide information to vehicle operators. When the vehicle is at a display location the department of transportation may transmit a travel time message that indicates how many minutes it will take for a vehicle at the display location to reach the airport. Such information is helpful as the vehicle operator may decide to take an alternate route. Further the reasons for the stated travel time may be irrelevant to the vehicle operator. In other words the vehicle operator may not care whether the travel time is lengthy due to road construction holiday traffic an accident etc. While the department of transportation may choose to display a specific reason or reasons such information may not add much value to the information conveyed by a simple travel time in minutes.

As described herein in various examples an Internet Location Coordinate ILC may be a number a set of numbers or a set of numbers where each one is associated with some additional information e.g. a tuple for each beacon . An ILC may indicate a local position to a client where this position is with respect to a network logical space measuring travel time or congestion and not necessarily geographic location. ILCs may be compared to estimate travel time or congestion between participants. Such simplicity is in line with the DNS and such an ILC may be carried according to an existing DNS protocol.

Referring again to the system of the client acquires information associated with three beacons     and  . For example a beacon can act as a reflector where the client can send a packet to the beacon and receive a response packet. The client can then determine the round trip time RTT to and from a beacon e.g. a travel time . As the client performs the same process with multiple beacons i.e. the beacons     and   the client becomes more aware of its surroundings. In particular the client becomes aware of its own condition in the system where its own condition may be represented according to a number or a set of numbers etc.

As mentioned an ILC participant can be any resource on a network. Hence the web servers     and   may be participants that can determine respective ILCs using the beacons . For example the web server   may transmit packets to the beacons     and   and receive corresponding return packets. As the web server   may know a priori information about the beacons     and   it can now determine its position in the system e.g. its ILC . While the example of shows three beacons other numbers of beacons may be used. Generally two or more beacons may be used.

As described herein the exemplary system allows clients to determine their position in a network logical space. Such information can be used for a variety of purposes. For example where the web servers     and   provide essentially identical services such information can be used to allow the client to connect to the best web server e.g. the closest server based on ILCs .

In an entry block a domain name is entered e.g. www.msn.com . In turn a DNS server may identify a plurality of servers associated with the domain name for example web server     and  . As explained each of the servers includes an ILC module to ascertain their respective ILCs. In a receipt block the client receives information about the group of servers along with the ILC for each of the servers in the group. In a determination block the client determines the optimal server based on the ILCs for the servers and its own ILC.

In the example of the client may be a user connected to the Internet and the domain name may be www.msn.com. This domain name has a plurality of associated servers at various geographical locations around the world. Given the exemplary architecture where beacons are scattered throughout the networked world each of the servers for the www.msn.com domain name knows its own ILC. When the DNS communicates with each server each server can respond by sending its ILC to the DNS server which in turn transmits this information to the client . The ILC module can then determine which server is the optimal server based on the client s ILC and those of the servers. In general the optimal server is the server that can provide the most efficient service to the client .

In the example of the prefetch module includes various components . A priority frequency component prioritizes prefetch based on frequency information. A priority last access component prioritizes prefetch based on last access time information. A prefetch based on ILC component prefetches information based at least in part on ILC information. A prefetch based on size component prefetches information based at least in part on amount of information communicated. For example a client may desire quicker access to a host server where the client normally downloads many files or large files from that host server. A prefetch based on TTL component prefetches information based at least in part on one or more TTLs. A custom prefetch component allows a user to customize prefetch which may rely on any of a variety of information. For example a prefetch method may include prioritizing domain names according to their respective likelihood of being invalid on a future domain name resolution request e.g. resolution information invalid or even domain name invalid . The component may also provide an API for a user to enable disable and or adjust other aspects of a prefetch process.

At a later time a boot block boots the computer. Upon booting a load block is initiated that loads information from the file. An analysis block analyzes information in the file for example to determine a prefetch order number of domain names to prefetch etc. A prefetch block prefetches domain name information for one or more domain names e.g. based at least in part on the analysis . For example the prefetch block may simply issue one or more domain name resolution requests to a DNS server and return a Resource Record RR for each domain name. A load block loads the domain name information to a cache such as a client DNS resolver cache see e.g. the cache of .

According to the method in a requirement block notice is received for invalidation of client cache information for a domain name. In response in a call block the server side invalidation module calls for invalidation of caches of client subscribers. For example the call block may force client side TTLs for a particular domain name to be changed to 0 which in turn may cause the client to immediately request new information for the domain name.

In the example of a transmit block transmits new information to the subscribing clients. On the client side per the replacement block the invalidation module may manage invalidation and updating by replacing a DNS cache entry or entries. At some subsequent time per a request block the client DNS service requests resolution of the domain name and relies on the new information stored in the cache to connect to a host server associated with the domain name.

An exemplary method can include bundling invalidation of information with updated information. For example if A sends an invalidation instruction to B for invalidating information for a domain name and A knows that B is going to issue a request to resolve the domain name A can jump ahead in the process by sending its response e.g. providing new or updated resolution information for the domain name along with the invalidation instruction.

The client side invalidation module includes a subscription management component that can subscribe a client or respond to server side subscription management. A subscription list component allows a client to create a list of domain names for use by an invalidation service. A DNS cache access component allows an invalidation service to access a DNS cache for overwriting entries controlling TTL settings etc.

The method commences in a request block where a client requests resolution of a domain name. In a transmit block the client transmits the domain name with cookie information to the DNS server where the cookie information may be managed by the grouping module . The DNS server resolves the domain name and the grouping module analyzes the cookie information to determine if the DN server should transmit information for one or more additional group domain names to the client . Per a construction block the DNS server constructs a packet with domain name information for at least the request domain name. In an update block the client updates its cache with the information received from the DNS server .

The client side grouping module includes a subscription management component that can subscribe a client or respond to server side subscription management. A grouping services component can allow a user to select URLs construct filters or specify filter criteria to group domain names generate cookies hash group information etc. A DNS cache access component allows a grouping service to access a DNS cache for overwriting entries controlling TTL settings etc.

An exemplary method for grouping domain names and receiving group information upon issuing a name resolution request can include polling for changes. For example a client may issue a request for resolution of a domain name and include a poll request for changes associated with a group of domain names. In response a receiving server may determine whether changes have occurred to any members of the group and transmit to the client information for only those members with changes.

An exemplary method optionally operates according to a cookie model where the client and server exchange a cookie. The cookie may be sent from a server to a client upon a request for resolution of a domain name. In turn the grouping module on the client may store and populate the cookie with group information. Alternatively a server may send a series of cookies to a client and the client side grouping module may consolidate the cookies into a group cookie. Upon a request for resolution of a domain name in the group the client may transmit the group cookie to the server. In turn the grouping module on the server checks the change status of the domain name information for members of the group and returns updated information as appropriate.

An exemplary method optionally operates on an application specific basis. For example a client may desire information for an email application and or a messenger application. In such an example a single request can update domain name information for both applications. In instances where a user coordinates communications using both applications the user s experience of both applications can be enhanced.

An exemplary method optionally relies on filtering techniques to define domain name groups. For example a user that access several governmental agencies may use a filter that includes .gov as a criterion. As described herein other filtering techniques e.g. with prefixes suffixes etc. may be used. An exemplary method optionally relies on zone information a SOA record etc. to define group members.

Various exemplary grouping methods include client server protocols to communicate information. An exemplary protocol optionally stores information in a packet according to a DNS protocol where a grouping module extracts the information for purposes of grouping domain names or receiving information about domain names in a group. Alternatively a separate protocol is used where information may be extracted from a DNS packet cache or file.

In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more program modules and may include program data . The operating system include a component based framework that supports components including properties and events objects inheritance polymorphism reflection and provides an object oriented component based application programming interface API such as that of the .NET Framework marketed by Microsoft Corporation Redmond Wash. The device is of a very basic configuration demarcated by a dashed line . Again a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computing device . Any such computer storage media may be part of device . The computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well know in the art and need not be discussed at length here.

The computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. Communication connections are one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules or other data forms. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

