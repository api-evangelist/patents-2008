---

title: Referencing a constant pool in a java virtual machine
abstract: A method, apparatus, and computer instructions for referencing a constant pool. A determination is made as to whether a bytecode references the constant pool. A relative offset to the constant pool is identified for the bytecode, in response to the bytecode referencing the constant pool. The bytecode is then replaced with a new bytecode containing the relative offset. The relative offset is used to reference the constant pool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099723&OS=08099723&RS=08099723
owner: International Business Machines Corporation
number: 08099723
owner_city: Armonk
owner_country: US
publication_date: 20080403
---
This application is a continuation of application Ser. No. 10 886 920 filed Jul. 8 2004 status allowed.

The present invention relates generally to an improved data processing system and in particular to a method and apparatus for processing data. Still more particularly the present invention provides a method apparatus and computer instructions for referencing a constant pool.

Java is an object oriented programming language designed to generate applications that can run on all different types of data processing systems without modification. Developed by Sun Microsystems Inc. Java has been promoted and geared heavily for the Web both for public Web sites and intranets. Java programs can be called from within HTML documents or launched standalone. When a Java program called from a Web page runs on a user s machine this program is called a Java applet. When a Java program is run on a Web server it is called a servlet. A Java program running on a data processing system as a stand alone non Web based program is simply referred to as a Java application. 

Java uses an intermediate language called bytecode. Bytecodes are nonspecific to hardware platforms. The source code of a Java program is compiled into bytecode which can be moved from one hardware platform to another. In order to run the Java program it must be compiled into machine code first. The compilation is done either ahead of time like a C C program a line at a time like an interpreter or as needed using a just in time compiler.

In executing a Java program such as a Java applet the Web browser invokes a Java virtual machine JVM . This component translates bytecodes into machine code for execution. As a result Java programs are not dependent on any specific hardware and will run in any data processing system with a Java virtual machine.

Many Java bytecodes refer to a constant pool. A constant pool is a collection of data that is stored in the class area in the Java virtual machine. The constant pool is an ordered set of constants used by a class or interface including literals and symbolic references to types fields and methods. The constant pool plays a central role in the dynamic linking of Java programs. The data in the constant pool provides information describing how a bytecode is to be executed. For the Java virtual machine to reference the constant pool the Java virtual machine must maintain a reference to the start of the constant pool.

Additionally it is often important for the Java virtual machine to know information about the currently executing Java method. This information may be derived from the program counter but this process can involve a performance penalty. It is desirable to be able to access both the constant pool and the currently executing method in an efficient manner.

One solution to this problem is for the Java virtual machine to maintain a pointer to the constant pool and a pointer to the current method at all times. This solution generates a new problem because two active pointers are maintained. The pointers reduce the number of processor registers available for other uses and increases the amount of state data saved and restored on Java method invocations.

Another solution involves the Java virtual machine maintaining a pointer to the method at all times and deriving a pointer to the constant pool when access to the constant pool is needed. This solution trades a penalty to access the method pointer for a penalty to access the constant pool. Therefore it would be advantageous to have an improved method apparatus and computer instructions for a Java virtual machine to reference a constant pool.

The present invention provides a method apparatus and computer instructions for referencing a constant pool. A determination is made as to whether a bytecode references the constant pool. A relative offset to the constant pool is identified for the bytecode in response to the bytecode referencing the constant pool. The bytecode is then replaced with a new bytecode containing the relative offset. The relative offset is used to reference the constant pool.

With reference now to the figures and in particular with reference to a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer is depicted which includes system unit video display terminal keyboard storage devices which may include floppy drives and other types of permanent and removable storage media and mouse . Additional input devices may be included with personal computer such as for example a joystick touchpad touch screen trackball microphone and the like. Computer can be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a computer other embodiments of the present invention may be implemented in other types of data processing systems such as a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

With reference now to a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system is an example of a computer such as computer in in which code or instructions implementing the processes of the present invention may be located. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Accelerated Graphics Port AGP and Industry Standard Architecture ISA may be used. Processor and main memory are connected to PCI local bus through PCI bridge . PCI bridge also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus may be made through direct component interconnection or through add in connectors. In the depicted example local area network LAN adapter small computer system interface SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add in connectors.

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as Windows XP which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . Java is a trademark of Sun Microsystems Inc. Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash read only memory ROM equivalent nonvolatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

For example data processing system if optionally configured as a network computer may not include SCSI host bus adapter hard disk drive tape drive and CD ROM . In that case the computer to be properly called a client computer includes some type of network communication interface such as LAN adapter modem or the like. As another example data processing system may be a stand alone system configured to be bootable without relying on some type of network communication interface whether or not data processing system comprises some type of network communication interface. As a further example data processing system may be a personal digital assistant PDA which is configured with ROM and or flash ROM to provide non volatile memory for storing operating system files and or user generated data.

The depicted example in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system also may be a kiosk or a Web appliance.

The processes of the present invention are performed by processor using computer implemented instructions which may be located in a memory such as for example main memory memory or in one or more peripheral devices .

With reference now to a block diagram illustrates the relationship of software components operating within a computer system that may be used to implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. JVM is one software application that may execute in conjunction with the operating system. JVM provides a Java run time environment with the ability to execute Java application or applet which is a program servlet or software component written in the Java programming language. The computer system in which JVM operates may be similar to data processing system in or computer in described above. However JVM may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the JVM which supports all aspects of Java s environment including its architecture security features mobility across networks and platform independence.

The JVM is a virtual computer such as a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.

The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating system architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code is executable on many processors given the presence of the Java run time system.

The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native code by a just in time compiler or JIT.

A JVM loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM. The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for compiling a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine also may be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes but JVMs may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are typically stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a JVM method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined. Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap each of which are shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

The present invention provides a mechanism to reference items in a constant pool through a method pointer rather than a constant pool pointer. This mechanism allows for maintaining a pointer to the method at all times and deriving the pointer to the constant pool only when necessary. This mechanism of the present invention does not negatively impact the performance of most Java programs.

Specifically as Java class files are loaded into the Java virtual machine the Java virtual machine analyzes the bytecodes in the class files and rewrites them in accordance with a preferred embodiment of the present invention. In the illustrative examples certain bytecodes which refer to the constant pool are replaced with new bytecodes which are undefined in the Java virtual machine specification. Although all types of bytecodes which include constant pool may be rewritten using the mechanism of the present invention only some types of bytecodes might be rewritten using this mechanism. For example the bytecodes selected for rewriting may be those that are most common or critical for a Java program.

The new versions of the bytecodes are equivalent to the specified versions of the bytecodes except that the constant pool index in the bytecode is an offset relative to the current method pointer rather than an offset relative to the beginning of the constant pool.

To calculate the offset relative to the method pointer method pointers are stored in memory in a location relative to the constant pool in which the offset can be calculated while the class files are being loaded by the class loader. In the illustrative embodiment the method pointers would be placed immediately before the constant pool. Of course in another illustrative embodiment the method pointers and structures may be placed after the constant pool or with other data between the method pointers and the constant pool.

Calculating the offset from a method pointer to an indexed constant pool entry requires knowing the size of each method pointer and the number of method pointers stored between the current method pointer of interest and the beginning of the constant pool. Of course many other layout schemes are also possible depending on the implementation.

In certain unusual instances it may be impossible to replace the original bytecodes with method relative versions. Changing the relative base may cause the constant pool offset to increase. This may result in an offset which is too large to represent within the 8 or 16 bit constant pool index encoded within each bytecode. In this case the bytecode is left unchanged and the slower but still correct and the constant pool relative bytecode is used.

Turning now to a diagram illustrating a class structure overview is depicted in accordance with a preferred embodiment of the present invention. Class structure includes fixed size class data variable size vtable methods constant pool and miscellaneous variable size data . In these examples this information is located in method area within JVM in . Fixed size class data includes class modifiers a pointer to the class name the number of fields in the class a pointer to a structure describing the fields the number of methods in the class a pointer to a structure describing the methods of the class and other fixed size elements which describe the class. Variable size vtable is a virtual dispatch table an array of method pointers used to implement virtual dispatching of methods. Methods contain the methods loaded by the class loader. Constant pool is an ordered set of constants used by the type including literals and symbolic references to types fields and methods. Miscellaneous variable size data consists of variable size data structures which help describe the class. Typically these are referred to by pointers in the fixed size class data section .

Methods in class structure initially have an offset relative to the beginning of constant pool . These bytecodes are replaced with ones that contain an offset relative to the method pointer for the bytecode. As shown methods are located immediately before constant pool . Of course methods may be located after constant pool or before constant pool with some other data structure being located between these two structures. In this illustrative example the mechanism of the present invention is implemented in a class loader such as class loader subsystem in . In other manifestations the mechanism of the present invention could be implemented in a separate executable which preprocesses class files and translates them into an JVM implementation specific data format for faster loading for instance the SmartLinker tool which forms part of Websphere Studio Device Developer .

Turning now to a diagram illustrating a method structure and constant pool in which bytecodes are rewritten is depicted in accordance with a preferred embodiment. In this figure method is located within method structure . Method includes four slots. These slots contain a pointer. Each pointer is a 32 or 64 bit pointer in the illustrative examples. These slots contain constant pool pointer bytecodes native address and method specific information . Constant pool pointer allows access to the class with the current method. Bytecodes includes offsets relative to the beginning of the constant pool. Native address contains a pointer to machine instructions for executing the method. Method specific information contains data used by the native code.

The mechanism of the present invention rewrites bytecodes to contain an offset from the method pointer to an entry within constant pool . Constant pool contains slot which is a slot identifying the beginning of constant pool . Constant pool pointer points to constant pointer pool slot which is a special slot in constant pool used to indicate the beginning of constant pool . In rewriting bytecodes the original bytecode in the slot is invokevirtual 1 . The offset for this bytecode has a value of 1. When rewritten the rewritten bytecode is now as follows invokevirtual method relative x 1 .

The original bytecode contained an offset having a value of 1 relative to the beginning of the constant pool. In this example the offset of the rewritten bytecode is x 1 and points to constant pool slot from the current method pointer rather than from the beginning of constant pool .

In the original bytecode in bytecodes this slot is identified by using constant pool pointer to identify the beginning of constant pool and then using the index of 1 to identify constant pool slot . When the original bytecode in bytecodes is rewritten the index of 1 is added to a value of x to provide an offset relative to the method pointer.

Assuming that each method structure contained four slots and that two method structures are present before method relative to constant pool a value of 12 is identified for x. As a result the offset of x 1 for the rewritten bytecode in bytecodes is 13. This offset is used to provide an offset to identify constant pool slot based on current method pointer which points to the beginning of method in this example.

In this manner only a single method pointer needs to be maintained. By reducing the number of pointers maintained resources such as registers are conserved. Additionally the amount of time needed to derive pointers is reduced.

With reference now to a flowchart of a process for rewriting bytecodes is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a class loader such as class loader subsystem in .

The process begins by fetching the next bytecode step . Next a determination is made as to whether the bytecode refers to the constant pool offset step . If the bytecode does refer to the constant pool then the method relative constant pool offset is calculated step . The calculation may be made in the illustrative examples by first counting the methods present. The size of each method also is determined. The number of methods after the one referred to by the bytecode is identified. This value is multiplied by the size of the methods. The original index is added to this value to generate the offset for the bytecode to be rewritten.

Next a determination is made as to whether this is an ldc bytecode step . An ldc bytecode is a special case taken into account in these illustrative examples. This bytecode uses 8 bits rather than 16 bits. As a result this type of bytecode has a lower value for offsets. If this bytecode is not a ldc bytecode then a determination is made as to whether the new offset is less than or equal to 65535 step . If the new offset is not less than or equal to 65535 then the process returns to step as described above. Otherwise the bytecode is replaced with the new bytecode and the calculated offset that is relative to the method pointer step with the process then returning to step .

Referring back to step if the bytecode does not refer to the constant pool offset then the process proceeds to step as described above. In step if the bytecode is an ldc bytecode then a determination is made as to whether the new offset is less than or equal to 255 step . If the new offset is less than or equal to 255 then the process proceeds to step as described above. If the new offset is not less than or equal to 255 then the process proceeds to step as described above.

With reference now to a flowchart of a process for processing bytecodes during execution of a Java program is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in an execution engine such as execution engine in . More specifically this process may be implemented in interpreter in .

The process begins by fetching the next bytecode for execution step . Next if any bytecode parameters are present they are read step . Then a determination is made as to whether the bytecode references the constant pool step . If the bytecode does reference the constant pool then a determination is made as to whether the bytecode method is relative step .

If the bytecode is method relative then the parameter is added to the current method pointer step . In this case the parameter is an offset. Then a value is fetched from the constant pool step . Next bytecode action is processed using the value from the constant pool step . Then the bytecode successor is determined step with the process then proceeding to step as described above.

Referring back to step if the bytecode does not reference the constant pool then the process proceeds to step as described above. With reference back to step if the bytecode is not method relative then the constant pool pointer is derived from the current method pointer step . Then the parameter is added to the constant pool pointer step with the process then proceeding to step as described above.

Thus the present invention provides an improved method apparatus and computer instructions for referencing a constant pool. The mechanism of the present invention rewrites bytecodes with new ones that use an offset that is relative to a method pointer rather than the beginning of the constant pool. In this manner only one pointer needs to be maintained. Thus the amount of resources and calculations are reduced through the mechanism of the present invention.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

