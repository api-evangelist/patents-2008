---

title: Interface infrastructure for a continuation based runtime
abstract: Namespace for continuation-based runtime. Some embodiments described herein are directed to a framework using continuation based runtime namespaces that pertain to an infrastructure for enabling the creation of a wide variety of continuation-based programs that perform a wide-array of tasks. The infrastructure provides a foundation for building continuation-based, declarative applications of various scale and complexity. In some embodiments, the associated application programming interfaces (APIs) are factored into a hierarchy of namespaces in a manner that balances utility, usability, extensibility, and versionability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09354847&OS=09354847&RS=09354847
owner: Microsoft Technology Licensing, LLC
number: 09354847
owner_city: Redmond
owner_country: US
publication_date: 20081229
---
Computers and computing systems have affected nearly every aspect of modern living. Computers are generally involved in work recreation healthcare transportation entertainment household management etc.

Computer programming can take a number of different forms. For example computer programmers can develop programs using imperative code. Imperative code is code that directly indicates actions that computer hardware should perform. For example machine language code may use commands that directly control what is entered into deleted from moved to and from registers and memory locations. Higher level imperative code can be compiled into machine language or binary code to cause the computer hardware to perform desired actions.

Declarative code in contrast uses declarative statements to declare the structure of a workflow where the workflows make general statements about what results should occur from hardware operations rather than defining the specific hardware operations themselves. For example an XML based language called XAML is commonly used for declaring the structure of a workflow. Workflows can be used in defining continuation based declarative applications. However it can be difficult to build continuation based declarative applications of various scale and complexity.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.

Some embodiments described herein are directed to using a namespace organization to implement a framework for creating and executing continuation based runtimes. In particular some embodiments include a computer readable storage media having stored thereon computer executable instructions for implementing a framework for enabling the creation and or execution of continuation based declarative applications. The computer readable medium includes a first set of APIs. Each of the APIs is for writing continuation based runtimes. Each of the APIs in the first set of APIs are included in a first common namespace for an activity model of a continuation based runtime. Each of the APIs in the first set of continuation based runtime APIs are represented with a first common namespace prefix for logical grouping of the plurality of continuation based runtime APIs.

Other embodiments may organize APIs into other namespaces. For example a second set of APIs may be organized in a second common namespace where the second set of APIs are used to host execute and manage instances of continuation based declarative programs. A third set of APIs may be organized in a third common namespace where the third set of APIs are used to implement a base layer of activities that add functionality to the continuation based runtime and that are used to add concrete behaviors that build on top of a core activity model. A fourth set of APIs may be organized in a fourth common namespace where the fourth set of APIs are used for providing and executing build constraints and policy constraints. Build constraints validate that a given workflow does not violate any runtime or activity assumptions which would most likely cause runtime exceptions. Policy constraints warn of potential issues including one or more of best practice violations design guideline violations or company policy violations. A fifth set of APIs may be organized in a fifth common namespace where the fifth set of APIs are used for defining and consuming tracking events. A sixth set of APIs may be organized in a sixth common namespace where the sixth plurality of APIs are used for modeling communication with other systems by sending and receiving messages in and out of a workflow. This set may also include APIs with functionality for representing a continuation based program as a service.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Additional features and advantages will be set forth in the description which follows and in part will be obvious from the description or may be learned by the practice of the teachings herein. Features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

Some embodiments described herein are directed to a framework using continuation based runtime namespaces that pertain to an infrastructure for enabling the creation of a wide variety of continuation based programs that perform a wide array of tasks. The infrastructure provides a foundation for building continuation based declarative applications of various scale and complexity. In some embodiments the associated application programming interfaces APIs are factored into a hierarchy of namespaces in a manner that balances utility usability extensibility and versionability.

A continuation based runtime executes activities. An activity represents a unit of executable code including multiple pulses of work. One of the ways an activity can execute multiple pulses of work is through the scheduling of child activities. This composition of activities enables custom control flows that can be implemented through the scheduling of child activities 0 1 or n times as determined by the composite activity. An example is illustrated which illustrates a workflow with a number of scheduled activities illustrated generally as and specifically as through where n is the number of activities in a workflow.

An activity can also setup a resumable continuation in its execution that is resumed by a stimulus external to the runtime. The runtime interprets this external stimulus as another pulse of work to be handled by the activity. Pulses of work are represented internally as continuations that the runtime invokes on activities thus continuation based runtime . Activities may also have the following characteristics They have no process affinity i.e. they can be paused and resumed in a different process. They have no thread affinity meaning that different pulses of work can be run on different threads. They can be persisted and rehydrated.

Workflows like traditional imperative programs allow one to coordinate work but have some important differences. Workflows can handle long running work by persisting to a durable store such as a database when idle and loading again once there is work to do. An instance of a workflow can be modified dynamically while running in the event that new conditions require the workflow to behave differently than it did when it was created. Workflows are a declarative way of writing programs by linking together pre defined activities rather than an imperative programming model of writing lines of code. Workflows allow one to declare business rules that are separated from code making it easier for one to modify them in the future. Workflows support different styles of systems with sequential and state machine workflows.

An XML based language called XAML is often used for declaring the structure of a workflow. However the workflow may also be expressed in other code such as using any .NET targeted language VB.NET C C CLI etc. .

Declarative coding provides developers with the ability to separate the logic of an application from the underlying imperative execution components.

Some embodiments are directed to a continuation based runtime namespace infrastructure for enabling the creation of a wide variety of continuation based programs that leverage the aforementioned runtime. The infrastructure provides a foundation for building continuation based declarative applications of various scale and complexity. The infrastructure or framework provides APIs for continuation based execution composite execution passivatable systems reactive execution coordinated sets of inputs and customized vocabularies

Enhancing features of a continuation based runtime namespace include a set of activities to perform continuation based work. Activities come in differing levels of functionality and usability and include but are not limited to rules based activities state machine based activities sequential based activities database activities powershell based activities web Services based activities and Flowchart based activities.

In some embodiments the associated APIs are stored on computer readable media such as those described later herein and factored logically into a hierarchy of namespaces in a manner that balances utility usability extensibility and versionability. In the following examples namespaces and classes have been named with specific selected names. However it should be understood that different namespace names may be selected which implement the same or similar functionality. Notably APIs may be represented with a common namespace prefix for logical grouping of the APIs depending on what namespace the APIs are organized into. illustrates the logical organization of APIs within namespaces in a framework. The APIs may be represented for example as source code and or as compiled code. The APIs may be operatable on the .NET platform. The .NET platform available from Microsoft corporation of Redmond Wash. includes a library of code and a virtual machine that manages the execution of programs written using the code.

Some embodiments include a root namespace for an activity model of the continuation based runtime. In this example this root namespace is named System.Activities . As noted this is the root namespace for the activity model of the continuation based runtime. Specifically it represents the APIs that are utilized to write a scalable continuation based declarative program. This set of APIs is grouped together in part because it represents a logical core layer of the activities model and it is possible to write an application using only those APIs in the root namespace and no other continuation based runtime namespaces. The following illustrates a number of classes with names selected for readability but which may be modified in specific embodiments any or all of which may be organized into the root namespace for an activity model of a continuation based runtime.

One core class of this namespace is illustrated in this example as WorkflowElement. The WorkflowElement class represents continuation based behavior. In particular instances of the WorkflowElement class include the imperative code in their bodies that is executed by a processor to perform certain functions. This class is used for declaring properties and parameters that are polymorphic across authoring styles.

Hierarchically below the WorkflowElement class is an Activity class. An Activity is an abstract WorkflowElement with protected constructor that is used for declaratively composing behavior into new types . The execution logic of an Activity is represented by other WorkflowElements. An Activity object may have declared for example using declarative programming within its body one or more WorflowElements.

Hierarchically below the WorkflowElement class is a DynamicActivity class. In the illustrated example a DynamicActivity is a concrete sealed WorkflowElement with a public constructor that is used for declaratively composing behavior dynamically using an Activity document object model DOM . This activity is used by hosters to load activities without requiring new types.

Hierarchically below the WorkflowElement class is a CodeActivity class. A CodeActivity is an abstract WorkflowElement with a protected constructor that is used for writing imperative behavior through an Execute method that has access to data resolution and extensions. CodeActivity is used for writing simple imperative behavior that is semantically equivalent to using Activity with a single line InvokeMethod body see below . CodeActivity only has an Execute method and in the present example it does not have Cancel or Abort functionality.

Hierarchically below the WorkflowElement class is a NativeActivity class. NativeActivity is an abstract WorkflowElement with a protected constructor that is used for writing imperative behavior through an Execute method that has unfettered access to the full breath of the runtime. This includes support for scheduling children intercepting Cancel and Abort signals creating continuations and interacting with execution properties.

Hierarchically below the WorkflowElement class is a WorkflowElement class. WorkflowElement represents continuation based functional behavior that has a well known elevated return value. It is used for declaring properties and parameters with a return value that are polymorphic across authoring styles.

Hierarchically below the WorkflowElement class is an Activity class. Activity is an abstract WorkflowElement with protected constructor that is used for declaratively composing behavior into new types . The execution logic of an Activity is represented by other WorkflowElements.

Hierarchically below the WorkflowElement class is a DynamicActivity class. DynamicActivity is a concrete sealed WorkflowElement with a public constructor that is used for declaratively composing behavior dynamically using an Activity DOM. The objects can be used by hosters to load activities without requiring new types.

Hierarchically below the WorkflowElement class is a CodeActivity class. CodeActivity is an abstract WorkflowElement with a protected constructor that is used for writing imperative behavior through an Execute method that has access to data resolution and extensions. CodeActivity is used for writing simple imperative behavior that is semantically equivalent to using Activity with a single line InvokeMethod body. In this example CodeActivity only has an Execute method it does not have Cancel or Abort functionality.

Hierarchically below the WorkflowElement class is a NativeActivity class. NativeActivity is an abstract WorkflowElement with a protected constructor that is used for writing imperative behavior through an Execute method that has unfettered access to the full breath of the runtime. This includes support for scheduling children intercepting Cancel and Abort signals creating continuations and interacting with execution properties.

Another base class in the System.Activities namespace is the ActivityContext base class. CodeActivity CodeActivity and NativeActivity NativeActivity have contexts passed to them for interfacing with the continuation based runtime. ActivityContext is the abstract base class for all such contexts. It allows for environment access i.e. argument variable resolution and access to host extensions.

Hierarchically below the ActivityContext class is the CodeActivityContext class. CodeActivityContext is the ActivityContext passed into CodeActivity CodeActivity.Execute . It adds async operation support to ActivityContext.

Hierarchically below the ActivityContext class is the ActivityExecutionContext class. ActivityExecutionContext is the context passed into NativeActivity NativeActivity methods Execute Cancel and Abort . This class adds support for child management scheduling cancelling setting up no persist zones isolation blocks and bookmarks.

The root namespace System.Activities includes a Variable class. Variable represents the storage of data in a continuation based program. It has a Type and an optional Name.

The root namespace System.Activities includes a Variable class. Variable is a concrete Variable class that strongly represents the type of the Variable through a generic parameter.

The root namespace System.Activities includes an Argument class. Argument is a binding terminal that represents the flow of data for an activity. Arguments declared on an activity definition define the activity s signature. Arguments are bound using expressions that may reference variables as part of activity usage. Arguments have a Type and a Direction In Out or InOut .

The root namespace System.Activities includes an InArgument class. InArgument is a concrete Argument class with a Direction In that strongly represents the type of the Argument through a generic parameter.

The root namespace System.Activities includes an OutArgument class. OutArgument is a concrete Argument class with a Direction Out that strongly represents the type of the Argument through a generic parameter.

The root namespace System.Activities includes an InOutArgument class. InOutArgument is a concrete Argument class with a Direction InOut that strongly represents the type of the Argument through a generic parameter.

The root namespace System.Activities includes an ActivityDelegate class. ActivityDelegate is an abstract base class which represents a snippet of workflow with a specific signature. The signature is a set of parameters and the handler is a WorkflowElement. ActivityDelegate allows an activity author to model parameterized callbacks within the continuation based system.

One or more action classes may be implemented hierarchically below the ActivityDelegate class. Some examples of these include ActivityAction ActivityAction ActivityAction etc. classes. ActivityAction and related generic types are concrete ActivityDelegates with packaged signatures of zero or more In parameters.

One or more action classes may be implemented hierarchically below the ActivityDelegate class. These include ActivityFunc ActivityFunc ActivityFunc etc. ActivityFunc and related generic types are concrete ActivityDelegates with packaged signatures of a single out parameter and zero or more in parameters.

Another namespace in the framework is a namespace representing a collection of APIs that are used to host execute and manage instances of continuation based declarative programs. In this example the System.Activities.Hosting namespace is the namespace that holds the APIs that are utilized to host execute and manage instances of continuation based declarative programs. This namespace may also include classes implementing the ability to serialize in flight instances of continuation based programs. This set of APIs is grouped together because it represents a distinct layer of functionality used to address the problems involved in hosting and executing workflows. Some illustrative classes of this namespace any or all of which may be included in this namespace illustrated in this example include the following classes.

The System.Activities.Hosting namespace may include an ActivityRuntime class. ActivityRuntime is a lightweight per instance runtime. It can be constructed to create a new workflow instance or to load an existing instance. The APIs that ActivityRuntime exposes are the minimal set of runtime controls from which higher level operations can be implemented. Additionally this API set represents the entire breadth of functionality of the runtime.

The System.Activities.Hosting namespace may include an ActivityRuntimeContext class. Instances of this class instantiate implementations of the abstract ActivityRuntimeContext and provide the ActivityRuntime access to such host functionality as synchronization persistence tracking and extensions. Additionally this interface allows the runtime to notify the host of important events such as the transition from running to paused and the occurrence of unhandled exceptions.

The System.Activities.Hosting namespace may include a WorkflowInstance class. WorkflowInstance is a locus of control for workflow instance management. It acts as the thread safe proxy to runtime operations on an instance.

The System.Activities.Hosting namespace may include a WorkflowInvoker class. WorkflowInvoker is a model for directly running an activity as if it were a method call. This is a lightweight performant easy to use API for use in scenarios where an activity s execution does not require the control infrastructure provided by WorkflowInstance or ActivityRuntime.

The System.Activities.Hosting namespace may include an ActivityServices class. ActivityServices is the primary entry point for accessing the myriad of hosting services such as Validation Xaml Reflection etc .

The framework may further include a namespace for the base layer of activities that add functionality to the continuation based runtime. Specifically this namespace organizes the APIs that are utilized to add concrete behaviors that build on top of the core activity model. In this example this namespace is represented by System.Activities.Core . As noted this is a namespace for the base layer of activities that add functionality to the continuation based runtime. Classes of this namespace may include one or more classes such as are illustrated below.

The System.Activities.Core namespace may include a Sequence class. Sequence is a control flow activity that is configured with a set of WorkflowElements that it schedules for execution in sequential order when one completes it will schedule the next one . Sequence is also configured with a set of variables that are used to store state across child activity execution boundaries.

The System.Activities.Core namespace may include an If class. If is a control flow Activity that is configured with a WorkflowElement based condition and two WorkflowElements that represent Then and Else actions of If Then Else logic. Depending on the outcome of the condition If schedules for execution either the Then WorkflowElement or the Else WorkflowElement.

The System.Activities.Core namespace may include a ForEach class. ForEach is a control flow Activity that is configured with a WorkflowElement based ActivityAction and an Enumeration to iterate through. ForEach will incrementally go through the enumeration and invoke the configurated Body ActivityAction with the current value of the enumeration. When that Action completes it will get the next value from the enumeration and execute the Action with the new value etc.

The System.Activities.Core namespace may include a ParallelForEach class. ParallelForEach is similar to ForEach except that the branch for each value in the enumeration is executed in parallel. It also has an early completion condition that can be set to break out of the enumeration after a particular condition has been satisfied.

The System.Activities.Core namespace may include a Parallel class. Parallel is a control flow Activity that is configured with a set of WorkflowElements that it schedules for execution all at once. Parallel is also configured with a set of Variables that are used to store state across child Activity execution boundaries as well as an early completion condition that can be set to cancel outstanding branches of execution after a particular condition has been satisfied.

The System.Activities.Core namespace may include a Flowchart class. Flowchart is a control flow Activity that is configured with a set of Nodes that store WorkflowElements for behavior and additional metadata about the next Node that should be scheduled. Flowchart interprets this metadata about nodes into orchestration logic that can follow paths of execution based on steps decisions multi branch switch statements and more. Flowchart is also configured with a set of Variables that are used to store state across child Activity execution boundaries.

The System.Activities.Core namespace may include a StateMachine class. StateMachine is a control flow Activity that is configured with a set of States and Transitions. StateMachine interprets this metadata about nodes into orchestration logic that follows the formal models of state machines in executing a reactive system. Events are modeled as WorkflowElements and Conditions control which transition will be followed to enter the next State of processing. StateMachine is also configured with a set of Variables that are used to store state across child Activity execution boundaries.

The System.Activities.Core namespace may include an InvokeMethod class. InvokeMethod is a workflow element which facilitates method calls. InvokeMethod is used for interfacing with common language runtime CLR methods and allows users the ability to call methods against objects pass in parameters get the return value specify types for generic methods and specify if the method is synchronous or asynchronous.

Another namespace that may be included in the framework is a namespace that holds APIs used for providing and executing build constraints and policy constraints. Build constraints validate that a given workflow does not violate any runtime or activity assumptions which would most likely cause runtime exceptions. Policy constraints on the other hand warn of potential issues including best practice violations design guideline violations company policy violations and miscellaneous common mistakes. Using these two mechanisms the APIs in this namespace are used to provide assurances that a validated workflow will execute as the developer intended. In this example this namespace is referred to as the System.Activities.Validation namespace. The following illustrates a number of classes any or all of which may be included in this namespace.

The System.Activities.Validation namespace may include an ActivityValidationServices class. ActivityValidationServices is the mechanism by which workflows can be validated against a set of constraints. As a result of this validation process a set of violations may be produced.

The System.Activities.Validation namespace may include a Constraint class. The Constraint base class provides the interface between ActivityValidationServices component and the validation constraint that the user wants to implement.

The System.Activities.Validation namespace may include a Constraint class. Constraint provides strongly typed ActivityAction based sugar on the base class to enable a simpler experience for the constraint author. The ToValidate object from the base Constraint is cast to T and provided as the Body s argument allowing the Body to deal in terms of a strongly typed Variable. This makes authoring easy in both XAML and imperative code.

The System.Activities.Validation namespace may include a ConstraintViolation class. A ConstraintViolation contains the message and error level information of a constraint failure. Note that a single constraint can generate zero or more ConstraintViolations in a single execution.

The framework may include a namespace that holds APIs used for defining and consuming tracking events. The Workflow runtime produces a stream of events that follow its execution. Distinct from the definition of the Workflow a user may add consumers of these events. In this example this namespace is referred to as System.Activities.Tracking . This namespace may include a number of classes such as one or more of the following.

The System.Activities.Tracking namespace may include a TrackingRecord class. This is the base class that represents a record containing information about the runtime execution process of a continuation based program. It defines a common set of fields such as TraceLevel and record number.

The System.Activities.Tracking namespace may include an ActivityTrackingRecord class. This is the base class that represents a record associated with an Activity. It contains the state of the Activity when that record was emitted the Id of the activity and values extracted from the running instance at the time the tracking record was emitted.

The System.Activities.Tracking namespace may include a TrackingParticipant class. This is the base class for a consumer of tracking records. A TrackingParticipant can enlist in the Workflow transaction through the PersistenceParticipant mechanism.

The System.Activities.Tracking namespace may include a TrackingProfile class. A TrackingProfile is a declarative definition of filters against event type and the data that should to be queried from the workflow instance e.g. value of a variable for a given event. TrackingProfiles can apply to multiple different Workflows and can be associated with multiple TrackingParticipants. TrackingProfiles their management and their storage are reusable by the authors of TrackingParticipants.

The framework may include a namespace that holds the APIs used for modeling communication with other systems by sending and receiving messages in and out of a workflow. It also includes the APIs with functionality for representing a continuation based program as a service. In this example this namespace is referred to as the System.ServiceModel.Activities namespace. Example classes any or all of which may be included in this namespace are enumerated below.

The System.ServiceModel.Activities namespace may include a SendMessage class. SendMessage allows users to send data out of a workflow in the form of a message.

The System.ServiceModel.Activities namespace may include a ReceiveMessage class. ReceiveMessage allows users to wait for external stimuli in a continuation friendly manner by exposing a web service endpoint to receive Messages.

The System.ServiceModel.Activities namespace may include a Send class. Send provides a friendly programming model for sending data that is either a DataContract based payload XmlSerializable based payload XElement Stream or Message.

The System.ServiceModel.Activities namespace may include a Receive class. Receive provides a friendly programming model for receiving data that is either a DataContract based payload XmlSerializable based payload XElement Stream or Message.

The System.ServiceModel.Activities namespace may include a CorrelationHandle class. In workflows application protocols are decomposed into one way message exchanges that use a handle based model for relating messaging activities regardless of the underlying correlation mechanism. CorrelationHandle is the name given to the type of handles that facilitate correlation.

The System.ServiceModel.Activities namespace may include a CorrelationScope class. CorrelationScope is used to provide an implicit CorrelationHandle that can be used by Send and Receive activities to loosen the requirements for the user on providing correlation bindings at each individual activity.

Embodiments herein may comprise a special purpose or general purpose computer including various computer hardware as discussed in greater detail below.

Embodiments may also include computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to carry or store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a computer readable medium. Thus any such connection is properly termed a computer readable medium. Combinations of the above should also be included within the scope of computer readable media.

Computer executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

