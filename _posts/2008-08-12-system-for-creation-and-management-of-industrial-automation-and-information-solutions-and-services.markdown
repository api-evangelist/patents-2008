---

title: System for creation and management of industrial automation and information solutions and services
abstract: The innovation relates to a system and/or methodology for the creation and management of industrial automation services and design templates. In addition, it allows for users to view processes, applications, protocols, data types, and so forth as semantically intuitive graphical objects that can be dragged, dropped, and tagged to allow for combining functionalities and/or integrating disparate applications or systems through a services model. Additionally, the innovation provides a library for user management of the services and templates.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08832579&OS=08832579&RS=08832579
owner: Rockwell Automation Technologies, Inc.
number: 08832579
owner_city: Mayfield Heights
owner_country: US
publication_date: 20080812
---
The subject innovation relates generally to industrial automation design and more particularly to the creation and management of industrial automation and information solutions and services.

Industrial Automation has revolutionized manufacturing in a rapidly expanding range of applications. As engineers strive to create systems of ever increasing complexity the development of new and innovative information solutions has become more essential. Increases in computer networking capability processing power and storage capacity have made faster smarter and more reliable automation systems possible. However the efficiency at which the systems can be designed programmed and installed has largely lagged behind the pace at which the automation systems themselves are improving.

Currently industrial automation designers programmers and engineers are often required to reengineer identical or similar components repeatedly for different projects. In addition frequently a high degree of redundancy exists between the designs of components for unrelated projects. This redundancy can be caused by industry specific customer specific and or application specific requirements.

The continual reinventing and reengineering of identical or similar components is highly inefficient. Moreover due to the high degree of redundancy the constant rehashing of similar subject matter is wholly unnecessary. Consequently a substantial need exists for an industrial automation and information solution that reduces the necessity for reengineering and increases efficiency.

The following presents a simplified summary of the subject matter in order to provide a basic understanding of some aspects of subject matter embodiments. This summary is not an extensive overview of the subject matter. It is not intended to identify key critical elements of the embodiments or to delineate the scope of the subject matter. Its sole purpose is to present some concepts of the subject matter in a simplified form as a prelude to the more detailed description that is presented later.

The claimed subject matter relates to a system and or method for creation and management of industrial automation and information solutions and services. In accordance with various aspects of the claimed subject matter an interface component facilitates user interaction with the system and allows for users to view processes applications protocols data types etc. as semantically intuitive graphical objects that can be dragged dropped and tagged to allow for combining functionalities and or integrating disparate applications or systems through a services model.

The design tool can generate industrial automation services and or design templates based at least in part on the data obtained by the interface component. Generating industrial automation services is accomplished at least in part by de abstracting and customizing one or more design templates based on the data and or user input. Additionally design templates are created via the design tool by abstracting one or more services by removing class specific layers and or generalizing the services.

The system can be an application programming interface API that enables describing services and templates using a common language or platform. The binding component provides for binding underlying languages in their native languages via translation layers or translation bridges between respective applications. The industrial automation services and design templates generated by the design tool can be maintained in a library wherein the user can manage the library via the interface and design tools.

To the accomplishment of the foregoing and related ends certain illustrative aspects of embodiments are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the subject matter may be employed and the subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the subject matter may become apparent from the following detailed description when considered in conjunction with the drawings.

The subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the subject matter. It may be evident however that subject matter embodiments may be practiced without these specific details. In other instances well known structures and devices are illustrated in block diagram form in order to facilitate describing the embodiments.

As used in this application the terms component system object model policy and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal .

As used herein the term inference refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Furthermore inference can be based upon logical models or rules whereby relationships between components or data are determined by an analysis of the data and drawing conclusions therefrom. For instance by observing that one user interacts with a subset of other users over a network it may be determined or inferred that this subset of users belongs to a desired social network of interest for the one user as opposed to a plurality of other users who are never or rarely interacted with.

Referring initially to an example illustration of a design pattern is shown in accordance with an aspect of the present innovation. The design pattern is an abstracted collection of sub components containing generic design elements. The sub components can include but are not limited to a user requirements component a functional specification component a software design specification component a code component a code testing component a hardware design specification component a hardware component an installation component a factory acceptance and testing component a site acceptance and testing component and a validation component a resource component and a quality component . It is to be appreciated that the terms design pattern and design template are used interchangeably herein.

The user requirements component obtains one or more user requirements. The user requirements can be obtained from a set of inputs including explicit user inputs e.g. configuration selections question answer such as from mouse selections keyboard selections speech scanner and so forth. Additionally or alternatively the user requirements can be obtained via data transfer from a user computer a third party computer an associated computer a data store etc. Typically the user requirements include general information regarding the objectives and goals of the user s project or group of projects. For example the user requirements can state that the goal of a particular project is to manufacture widgets. Additionally the user requirements can include quality specifications such as the rate at which the widgets need to be manufactured the size of the widgets quality tolerances etc.

The functional specification component generates one or more functional specifications based on the user requirements wherein a functional specification is a generic list of equipment required to achieve the described functionality. For example the functional specification component can determine the engineering processes necessary to make the specified number of widgets at the specified rate within said quality tolerances. The functional specifications can include the equipment to be used the sequence of operations process inputs and outputs process parameters process data operator interaction and so forth.

The software design specification component generates one or more software design specifications based on the functional specifications wherein the software design specifications relate the abstract description in the functional specification to concrete instances of modules within the software. The software design specifications are high level e.g. generic representations illustrative of a sequence of events and handling of exceptions that can be translated into computer executable commands. The software design specifications can be illustrated via block diagrams flow charts drawings e.g. S88 batch control process requirements .

The code component generates pre built modules of software designed for the abstract which accept the entity relationship defined by the software design specification component . The high level representations contained in the software design specifications are mapped to functions and or computer executable commands. For example the software design specification may require a motor to be run at a speed X. The code component can generate the software code necessary to run the motor at speed X. Additionally or alternatively the code component can generate the code based at least in part on one or more design patterns. For example if the functional specification requires a type 1 motor to be run at speed X then the code component can obtain a template regarding running a type 1 motor and modify the design pattern to operate the motor at speed X.

The code testing component tests the software code generated by the code component . The code testing component can test the code to ensure it provides each function outlined in the functional specification s . The code testing component may not need to test every instance of code because a given project may require multiple instances of the same code. For instance a functional specification may require a series of flow meters to perform an operation. The software design specification component and code component can handle each instance of a flow meter in a similar manner resulting in multiple instances of similar or identical software code. Consequently the code testing component may only be required to check a single instance of a flow meter to ensure that all related flow meter codes are functioning correctly. Moreover the code testing component can produce one or more testing specifications. The testing specifications detail a testing schema and are based at least in part on the functional specifications and software design specifications. Additionally for each test performed the code testing component can subsequently generate one or more testing reports that detail the results of the tests. The testing reports including but not limited to errors warnings accuracy possible solutions expected results actual results etc.

The hardware design specification component generates one or more hardware design specifications based on the functional specifications and or software design specifications. The hardware design specifications are high level representations of one or more hardware modules and configurations of the modules designed to execute the objectives of the functional specification and or the software design specifications. For example if the functional specifications and software design specifications require a flow meter the hardware design specification component can determine the inputs and outputs I O required for the flow meter the network s that must to be connected to the I O points whether a control cabinet is necessary and so forth. The hardware design specifications can be illustrated as drawings e.g. electrical drawings mechanical drawings etc. flowcharts block diagrams etc.

Additionally the hardware design specification component can add one or more additional specification requirement layers including but not limited to customer specific requirements industry specific requirements application specific requirements and or project specific requirements. For example if the project is for an industry that requires explosion proof materials then the design specification component can add a corresponding industry specific requirements layer to the hardware design specifications. Similarly if a customer has specific requirements then an appropriate customer requirements layer can be added to the hardware design specification.

The hardware component can generate a comprehensive list of the hardware required for the project based on the hardware design specifications. The list can be a bill of materials B.O.M. wherein the B.O.M. can include but is not limited to part names quantities part numbers manufacturers etc.

The installation component can generate one or more installation specifications based on the hardware design specifications and the B.O.M. The installation specifications detail specifications of materials necessary to install the hardware modules including but not limited to runs of wire termination boxes wiring specifications conduit specifications piping definitions etc.

The factory acceptance testing component can qualify a design build prior to installation including any prebuilt software or hardware modules. For example the factory acceptance testing component can test the I O communications controls and so forth of prebuilt software modules and control panels. In addition the site acceptance testing component can test software or hardware modules during or after the installation. For example the site acceptance testing component can test the I O communications controls and so forth once installation of the project is complete.

The validation component validates test results from the factory acceptance testing component and site acceptance testing component . Additionally the validation component can ensure that each element of the software design and hardware design specifications operate as intended. For example the validation component may be particularly useful for life sciences based projects where simply testing the design is insufficient and validation of the test results is required.

The resource component determines a cost amount e.g. money time etc. for a given project or set of projects. The resource component can represent the cost amount as a maximum value a minimum value a target value e.g. set point a percentage value a distribution a state value e.g. low medium or high etc. The resource component can determine the cost amount based on the user requirements and or functional specification. Additionally or alternatively the resource component can infer the cost amount. The cost amount can be used by both the one or more other components in order to generate the engineering specifications. For example the resource component can determine that the maximum amount for a project is 10 000. The software design specification component the hardware design specification component and the hardware component will maintain an aggregate cost of less than or equal to the maximum amount of 10 000.

The quality component determines a quality metric based at least in part on the user requirements. The quality metric can be a real number a target a percentage a distribution a state e.g. low medium or high etc. The quality metric can be determined based on the user requirements and or functional specifications and can be one or more additional sub components. For example the quality component can determine that the quality metric should be high. Subsequently the other sub components will adapt their designs to accommodate the quality metric by using only modules parts etc. designated as high quality. It is appreciated that the quality component and resource component can be related because typically there is a correlation between resources and quality. For example as the cost of the modules increases presumably the quality does as well and vice versa. Therefore it may be desirable to integrate the resource component and quality component .

The user requirements specification includes general information regarding the objectives and goals of the user s project or group of projects. For example the user requirements specifications can state that the goal of a particular project is to manufacture widgets. Additionally the user requirements specifications can include quality specifications such as the rate at which the widgets need to be manufactured the size of the widgets quality tolerances etc.

The functional specifications include the engineering processes necessary to make the specified number of widgets at the specified rate within said quality tolerances. The functional specifications can include the equipment to be used the sequence of operations process inputs and outputs process parameters process data operator interaction and so forth.

The software design specifications relate the abstract description in the functional specification to concrete instances of modules within the software. The software design specifications are high level e.g. generic representations illustrative of a sequence of events and handling of exceptions that can be translated into computer executable commands. The software design specifications can be illustrated via block diagrams flow charts drawings e.g. S88 batch control process requirements .

The hardware design specifications are high level representations of one or more hardware modules and configurations of the modules designed to execute the objectives of the functional specifications and or the software design specifications . For example if the functional specifications and software design specifications require a flow meter the hardware design specifications can include the inputs and outputs I O required for the flow meter the network s that must to be connected to the I O points whether a control cabinet is necessary and so forth. The hardware design specifications can be illustrated as drawings e.g. electrical drawings mechanical drawings etc. flowcharts block diagrams etc.

Additionally the hardware design specifications can be used to generate a comprehensive list of the hardware required for the project based on the hardware design specifications. The list can be a bill of materials B.O.M. wherein the B.O.M. can include but is not limited to part names quantities part numbers manufacturers etc. The installation specifications detail specifications of materials necessary to install the hardware modules including but not limited to runs of wire termination boxes wiring specifications conduit specifications piping definitions etc.

The testing specifications can be used to qualify a design build prior to installation including any prebuilt software or hardware modules. In addition the testing specifications can detail software or hardware modules tests to be executed during or after the installation. For example site acceptance testing can detail test for the I O communications controls and so forth once installation of the project is complete.

Additionally the testing specifications can include code tests for generated software code. Code testing can test the code to ensure it provides each function outlined in the functional specification s . Code testing may not need to test every instance of code because a given project may require multiple instances of the same code. For instance a functional specification may require a series of flow meters to perform an operation. Each instance of a flow meter may be designed in a similar manner resulting in multiple instances of similar or identical software code. Consequently code testing may only be required to check a single instance of a flow meter to ensure that all related flow meter codes are functioning correctly. Moreover the testing specifications can detail a testing schema and are based at least in part on the functional specifications and software design specifications . Additionally for each test performed one or more testing reports that detail the results of the tests can be generated. The testing reports include but are not limited to errors warnings accuracy possible solutions expected results actual results etc.

The Quality Validation specifications validate test results from the factory acceptance testing and site acceptance testing. In addition the validation specifications can be used to ensure that each element of the software design and hardware design specifications operate as intended. For example the validation specifications may be particularly useful for life sciences based projects where simply testing the design is insufficient and validation of the test results is required.

The resource requirements represent the cost amount of the project as a maximum value a minimum value a target value e.g. set point a percentage value a distribution a state value e.g. low medium or high etc. The resource requirements can be based on the user requirements and or functional specification . Additionally the resources requirements can include a quality metric based at least in part on the user requirements . The quality metric can be a real number a target a percentage a distribution a state e.g. low medium or high etc. The quality metric can be determined based on the user requirements and or functional specifications . For example the quality metric for a given project can be set as high. Subsequently the other sub specifications can be adapted to accommodate the quality metric by using only modules parts etc. designated as high quality.

Referring initially to an industrial information services creation and management system is illustrated in accordance with an aspect of the subject innovation. The system allows for describing creating and modifying industrial automation services discussed infra using a common language or platform and includes an interface component a design tool a data store and a set of inputs . The interface component facilitates user interaction with the system and allows for users to view processes applications protocols data types etc. as semantically intuitive graphical objects that can be dragged dropped and tagged to allow for combining functionalities and or integrating disparate applications or systems through a services model. The interface component may be a form on a web site wherein users access the form via a web browser on a personal computer mobile device and so forth. It is also to be appreciated that the interface component may be a standalone application applet or widget executing on a personal computer or mobile device. For example user interaction can be accomplished through a sequence of graphical user interfaces GUI presented on a user terminal or computer.

The interface component can receive data via the inputs . The inputs can include explicit user inputs e.g. configuration selections question answer such as from mouse selections keyboard selections speech and so forth. The inputs can also include data uploads wherein a data upload is the transfer of data from the user or a third party source e.g. computer or a computer readable medium to the system . Additionally or alternatively the data can be collected from the data store . Furthermore the interface component includes any suitable and or necessary adapters connectors channels communication paths etc. to integrate the system into virtually any operating and or database system s . Moreover the interface component can provide various adapters connectors channels communication paths etc. that provide for interaction with the system .

The data can relate to a set of user requirements a functional specification a Piping and Instrumentation drawing P ID drawing an electrical drawing a design template an operation a manufacturing execution systems MES etc. The user requirements can include but are not limited to general information regarding the objectives of an individual project or group of projects. For example the set of user requirements can state that the goal of a particular project is to manufacture widgets. Additionally the user requirements can include quality specifications such as the rate at which the widgets need to be manufactured the size of the widgets quality tolerances etc. The functional specifications can include the equipment to be used the sequence of operations process inputs and outputs process parameters process data operator interaction and so forth.

The interface component communicates the data to the design tool . The design tool facilitates generation of at least one industrial automation service discussed infra based at least in part on the data obtained by the interface component . Generating industrial automation services services is accomplished at least in part by de abstracting one or more design templates based on the data and or user input. The design templates can be obtained from the user or the data store as previously discussed . Additionally or alternatively the services can be dynamically created using the design tool wherein the interface component graphically represents industrial automation services and design elements and the design tool provides for users to develop new services by associating graphically presented services and or design elements with the services. Moreover the design tool can provide for users to easily expose functionalities of underlying chunks of code and combine or execute such code in the form of services. A new service can also be created by clustering a set of other services together serially in parallel or combination thereof .

As noted supra the user can modify or customize the data services and or design process via the interface component . The design tool can track user modifications and translate said modifications to other services components. For example if the user modifies an element of a software design the associated elements and functions can be modified in the related designs such as a hardware design. Additionally at any point the user can save customizations to the services.

The industrial automation services services can relate to one or more design specifications drawings software code testing schemas bills of materials B.O.M installation specifications manufacturing execution systems MES enterprise resource planning ERP etc. The design specifications can include but are not limited to a software design specification or a hardware design specification. The software design specifications can be embodied via high level representations illustrative of a sequence of events and handling of exceptions that can be translated into computer executable commands. The software design specifications can be illustrated via block diagrams flow charts drawings e.g. S88 batch control process requirements . The hardware design specifications can be embodied via high level representations illustrative of one or more hardware modules and configurations of the modules including wiring communications etc. For example if the functional specifications and software design specifications require a flow meter the hardware design specification component can determine the inputs and outputs I O required for the flow meter the network s that must to be connected to the I O points whether a control cabinet is necessary and so forth. The hardware design specifications can be illustrated as drawings e.g. electrical drawings mechanical drawings etc. flowcharts block diagrams etc.

Additionally as part of the design process the design tool provides for translation of services from a first form to any other available form. For example if a design specification is obtained by the system for a project either from the user or generated via the design tool the interface component can expose at least one interface that facilitates translation of the design specification to any of the other services such as software code via the design tool .

Referring to an industrial automation and information services creation and management system is illustrated in accordance with an aspect of the subject innovation. The system allows for describing creating and modifying industrial automation services using a common language or platform and includes an interface component a design tool a data store and a set of inputs . As noted supra the interface component facilitates user interaction with the system and allows for users to view processes applications protocols data types etc. as semantically intuitive graphical objects that can be dragged dropped and tagged to allow for combining functionalities and or integrating disparate applications or systems through a services model. In addition the interface component can receive data via the inputs . The inputs can include explicit user inputs e.g. configuration selections question answer such as from mouse selections keyboard selections speech and so forth. The inputs can also include data uploads wherein the data upload is the transfer of data from the user or a third party source e.g. computer or a computer readable medium to the system . Additionally or alternatively the data can be collected from the data store .

The interface component includes a wizard component that assists users in describing creating and modifying industrial automation services. The wizard component can guide users through starting a new project or modifying an existing project including uploading or creating data. For example the wizard component can acquire data by navigating users through a series of questions wherein the aggregate of the answers to said questions can be used to generate the data. Additionally or alternatively the wizard component can acquire data by exposing an interface that enables users to upload data to the system .

As discussed previously the data can relate to a user requirement a functional specification a Piping and Instrumentation drawing P ID drawing an electrical drawing a design template an operation a manufacturing execution systems MES etc. The user requirements can include but are not limited to general information regarding the objectives of an individual project or group of projects.

The interface component communicates the data to the design tool . The design tool facilitates generation of at least one industrial automation service discussed infra based at least in part on the data obtained by the interface component . Furthermore the design tool includes a transclusion component and an abstraction component . The transclusion component de abstracts the design templates by attaching one or more class specific layers. The design templates e.g. design patterns are in essence abstracted design specifications containing only generic design elements. The design templates can include but are not limited to hardware and software design templates. Hardware design templates are representative of generic configurations of one or more hardware modules. For example if the project requires operation of a flow meter the hardware design template can include the inputs and outputs I O required for the flow meter required network connectivity for the I O points a determination of whether a control cabinet is necessary and any additional generic design elements necessary for the operation of the flow meter. Similarly software design templates are illustrative of generic sequences of events and handling of exceptions that can be translated into computer executable commands. The software design specifications can be graphically represented via block diagrams flow charts drawings e.g. S88 batch control process requirements and so forth.

The class specific layers can include but are not limited to an industry specific layer a customer specific layer an application specific layer and a project specific layer. The class specific layers contain class specific definitions which define one or more class specific requirements. Consequently appending one or more class specific layers to the design templates adds specific requirements to the generic design elements thus de abstracting the design templates. For example a project may require a particular set of process data for the operation of a set of flow meters and said process data can be defined in the project specific layer. The transclusion component can append the project specific layer to the flow meter design template.

As noted supra the user can modify or customize the data services and or design process via the interface component . The design tool can track user modifications and translate said modifications to other services components. For example if the user modifies an element of a software design the associated elements and functions can be modified in the related designs such as a hardware design. Additionally at any point the user can save customizations to the services.

As part of the design process the design tool provides for translation of services from a first form to any other available form. For example if a design specification is obtained by the system for a project either from the user or generated via the design tool the interface component can expose at least one interface that facilitates translation of the design specification to any of the other services such as software code via the design tool .

The abstraction component obtains at least one service and abstracts the services by removing one or more class specific layers. Removing the class specific layers abstracts a service by extracting the associated class specific content wherein the remainder is generic design elements of the services. For example Company Z manufactures widgets. The manufacturing of widgets requires the operation of a conveyor belt. The design specification for the operation of the conveyor belt includes an industry specific layer and a customer specific layer. Industry regulations require the use of explosion resistant equipment during the manufacturing of widgets and Company Z requires that only Allen Bradley parts are used on their lines. Therefore the conveyor belt design specification calls for explosion resistant and Allen Bradley parts where applicable. It may be desirable to use the conveyor belt design specification for other projects requiring a similar operation. The abstraction component can remove the industry specific and customer specific layers thereby abstracting the design specification. The remainder is an abstracted design specification for operating a conveyor belt.

The abstraction component enables the creation of new and or custom design templates. The interface component can expose one or more interfaces that provide users the ability to create modify and maintain design templates via the abstraction component . For example users can collect a service from the data store or the interface component can reveal an interface prompting users to upload an existing service. After obtaining the service users can associate and or disassociate graphically presented services and design elements to modify the abstraction of the services and create a custom design template.

One or more libraries can be maintained in the data store . The libraries can contain but are not limited to the class specific layers the data the design templates and the industrial automation services. The libraries and their contents can be user specific. Additionally the interface component can expose one or more interfaces that enable users to update modify and maintain their specific libraries . For example customer Z may require the use of only Allen Bradley Programmable Logic Controllers PLCs and this requirement can be defined in a Customer Z customer specific layer. The customer specific layer can be maintained in a Customer Z specific library in the data store wherein the layer can be retrieved for any Customer Z project. Additionally Customer Z can modify the customer specific layer or store additional class specific layers in the library .

Referring to an industrial information services creation and management system is illustrated in accordance with an aspect of the subject innovation. The system can be an application programming interface API that facilitates management and creation of industrial automation services services by providing a common language or platform for describing the services. The system includes an interface component a design tool a processing component a binding component a policy component and a data store .

The interface component can receive data via one or more inputs . The inputs can include explicit user inputs e.g. configuration selections question answer such as from mouse selections keyboard selections speech and so forth. The inputs can also include data uploads wherein the data upload is the transfer of data from the user or a third party source e.g. computer or a computer readable medium to the system . Additionally or alternatively the data can be collected from the data store . The interface component may be a form on a web site wherein users access the form via a web browser on a personal computer mobile device and so forth. It is also to be appreciated that the interface component may be a standalone application applet or widget executing on a personal computer or mobile device. Furthermore the interface component includes any suitable and or necessary adapters connectors channels communication paths etc. to integrate the system into virtually any operating and or database system s . Moreover the interface component can provide various adapters connectors channels communication paths etc. that provide for interaction with the system .

The interface component includes a wizard component that assists users in describing creating and modifying industrial automation services. The wizard component can guide users through starting a new project or modifying an existing project including uploading or creating data. For example the wizard component can acquire data by directing users through a series of questions wherein the aggregate of the answers to said questions can be used to generate the data. Additionally or alternatively the wizard component can acquire data by exposing an interface that enables users to upload data to the system .

The data can relate to a user requirement a functional specification a Piping and Instrumentation drawing P ID drawing an electrical drawing a design template an operation a manufacturing execution systems MES etc. The user requirements can include but are not limited to general information regarding the objectives of an individual project or group of projects. For example the set of user requirements can state that the goal of a particular project is to manufacture widgets. Additionally the user requirements can include quality specifications such as the rate at which the widgets need to be manufactured the size of the widgets quality tolerances etc. The functional specifications can include the equipment to be used the sequence of operations process inputs and outputs process parameters process data operator interaction and so forth.

The interface component communicates the data to the design tool . The design tool facilitates generation of at least one industrial automation service discussed infra based at least in part on the data obtained by the interface component . Industrial automation services services can be generated at least in part by de abstracting one or more design templates based on the data and or user input. The design templates can be obtained from the user or the data store as previously discussed . Additionally or alternatively the services can be dynamically created using the design tool wherein the interface component graphically represents industrial automation services and design elements and the design tool provides for users to develop new services by associating graphically presented services and or design elements with the services. Moreover the design tool can provide for users to easily expose functionalities of underlying chunks of code and combine or execute such code in the form of services. A new service can also be created by clustering a set of other services together serially in parallel or combination thereof .

The design tool includes a transclusion component and an abstraction component . The transclusion component de abstracts the design templates by attaching one or more class specific layers. The design templates e.g. design patterns are in essence abstracted design specifications containing only generic design elements. The design templates can be hardware or software design templates. Hardware design templates are representative of generic configurations of one or more hardware modules. For example if the project requires operation of a flow meter the hardware design template can include the inputs and outputs I O required for the flow meter required network connectivity for the I O points a determination of whether a control cabinet is necessary and any additional generic design elements necessary for the operation of the flow meter. Similarly software design templates are illustrative of generic sequences of events and handling of exceptions that can be translated into computer executable commands. The software design specifications can be graphically represented via block diagrams flow charts drawings e.g. S88 batch control process requirements and so forth.

The class specific layers can include but are not limited to an industry specific layer a customer specific layer an application specific layer and a project specific layer. The class specific layers contain class specific definitions which define one or more class specific requirements. Consequently appending one or more class specific layers to the design templates adds specific requirements to its generic design elements thus de abstracting the design templates. For example a project may require a particular set of process data for the operation of a set of flow meters and said process data can be defined in the project specific layer. The transclusion component can append the project specific layer to the flow meter design template.

Additionally as part of the design process the design tool provides for translation of services from a first form to any other available form. For example if a design specification is obtained by the system either from the user or generated via the design tool the interface component can expose at least one interface that facilitates translation of the design specification to any of the other services such as software code via the design tool .

As noted supra the user can modify or customize the data services and or design process via the interface component . The design tool can track user modifications and translate said modifications to other services components. For example if the user modifies an element of a software design the associated elements and functions can be modified in the related designs such as a hardware design. Additionally at any point the user can save customizations to the services.

The abstraction component obtains at least one service and abstracts the services by removing one or more class specific layers. Removing the class specific layers abstracts a service by extracting the associated class specific content wherein the remainder is generic design elements of the services. For example Company Z manufactures widgets. The manufacturing of widgets requires the operation of a conveyor belt. The design specification for the operation of the conveyor belt includes an industry specific layer and a customer specific layer. Industry regulations require the use of explosion resistant equipment during the manufacturing of widgets and Company Z requires that only Allen Bradley parts are used on their lines. Therefore the conveyor belt design specification calls for explosion resistant and Allen Bradley parts where applicable. It may be desirable to use the conveyor belt design specification for other projects requiring a similar operation. The abstraction component can remove the industry specific and customer specific layers thereby abstracting the design specification. The remainder is an abstracted design specification for operating a conveyor belt.

The abstraction component enables the creation of new and or custom design templates. The interface component can reveal one or more interfaces that allow users to create modify and maintain design templates via the abstraction component using the interface component . For example users can collect a service from the data store or the interface component can reveal an interface prompting users to upload an existing service. After obtaining the service the interface component can expose one or more user interfaces that enable users to abstract the service and create a custom design template.

The processing component facilitates the creation and management of services having computer executable commands e.g. code . The processing component can emulate processors found in industrial controllers to simulate execution of the code and ensure proper operation. For instance as previously noted the system can generate services in the form of software code based on data obtained from users or the data store . The design tool can evaluate the software code using the processor component wherein evaluation includes testing and verification. Additionally the processor component can evaluate code for design template abstraction via the abstraction component . For instance the processor component can evaluate code contained in a service for the abstraction component wherein the evaluation can include identifying class specific layers generic design elements etc. and the abstraction component can create a design template based at least in part on the chunk of software code.

As noted supra the system can be an API that provides a common language or platform for describing creating and modifying services. The binding component provides for binding underlying languages in their native languages via translation layers or translation bridges between the respective applications. For example the data obtained to generate one or more services can utilize various native languages which may be distinct from the languages used by the system to create and or store the design templates and or services. Users may require for the final product to be produced in a particular language and the binding component provides for binding underlying languages between the respective applications.

The policy component provides for determination of system policies. Users can define policies regarding the creation and management of services such as default management settings and desired creation preferences. Also the policy component provides for users to define policies regarding design template abstraction such as level of abstraction. Additionally or alternatively the policy component can infer policies based on user interaction with the system . For example the policy component can infer a policy for naming services and preferences regarding management of the services based on users prior naming and management of services. The policies can be communicated to and used by the interface component the design tool the processing component the binding component and the data store .

One or more libraries can be maintained in the data store . The libraries can contain but are not limited to the class specific layers the data the design templates and the industrial automation services. The libraries and their contents can be user specific. Additionally the interface component can expose one or more interfaces that allow users to update modify and maintain their libraries . For example a customer may require the use of only Allen Bradley Programmable Logic Controllers PLCs and this requirement can be defined in the customer specific layer. The customer specific layer can be maintained in library in the data store that is specific to the customer wherein the layer can be retrieved for any project for the customer. Additionally the customer can modify the customer specific layer or store additional class specific layers in the library .

Referring to an example process for design pattern abstraction and creation is shown in accordance with an aspect of the present innovation. The process is illustrated as proceeding along a template creation line from the most specialized application e.g. engineering specification to the most generic application e.g. design pattern . The process commences with an engineering specification . The engineering specification can be abstracted by removing one or more class specific layers thereto. As previously discussed removing one or more class specific layers abstracts the engineering specification by removing class specific definitions from the generic design elements. The class specific layers can include but are not limited to an industry specific layer a customer specific layer an application specific layer and a project specific layer . Additionally the class specific layers can include one or more sub components. For instance the class specific layers can include sub components associated with the sub components contained in the design pattern discussed supra .

The abstracted engineering specifications can be generalized and formatted via a generalization and formatting component . The generalization and formatting component generalizes designations and identifiers contained in the engineering specifications and or any of the sub components contained in the abstracted engineering specifications . In addition the generalization and formatting component formats the abstracted engineering specifications for use as design patterns . The design patterns include the results of the abstracted generalized and or formatted engineering specifications . For instance the initial engineering specification can include a functional specification discussed supra and the abstracted generalized and or formatted functional specification generates a functional specification component discussed supra that is included in the design pattern .

Referring to an example process for design pattern transclusion and customization is shown in accordance with an aspect of the present innovation. The process is illustrated as proceeding along a transclusion indicator from the most generic application e.g. design pattern to the most specialized application e.g. engineering specification . The process commences with a design pattern . The design pattern is a compilation of sub components having abstract design elements discussed supra . The design pattern can be de abstracted by appending one or more class specific layers thereto. As previously discussed attaching one or more class specific layers de abstracts the design pattern by adding class specific definitions to the generic design elements. The class specific layers can include but are not limited to an industry specific layer a customer specific layer an application specific layer and a project specific layer . Additionally the class specific layers can include one or more sub components. For instance the class specific layers can include sub components associated with the sub components contained in the design pattern discussed supra .

The de abstracted design patterns can be customized via a customization component . The customization component enables customization and or modification of any of the sub components contained in the de abstracted design pattern . The customized and or de abstracted design pattern is used to generate a set of engineering specifications . The engineering specifications include the results of the customized and de abstracted design pattern . For instance the initial design pattern can include a functional specification component discussed supra and the de abstracted and customized functional specification component generates a functional specification that is included in the engineering specifications .

In view of the example systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

At the design templates can be de abstracted by appending one or more class specific layers. The class specific layers contain class specific definitions wherein the definitions include various requirements of the classes. The class specific layers can include but are not limited to a customer specific layer an industry specific layer a project specific layer and an application specific layer.

The de abstracted design templates can be customized at . The de abstracted design templates can be customized by tailoring the generic design elements of the design template for the specific project situation user etc.

At one or more engineering specifications are generated based at least in part on the customized and de abstracted design templates. The engineering specifications represent the customized and de abstracted sub components of the design pattern.

It is appreciated that it may not be desirable to completely abstract e.g. remove all class specific layers the services in every situation. It may be desirable to keep one or more class specific layers during the creation of the design templates. For example if an engineering specification is targeted toward machinery or a process that is only used in one industry then it may be advantageous for the industry specific layers to be included in the design template.

The design patterns can be stored in a library discussed supra wherein the library can be associated with a template management and or automated design system. Additionally or alternatively the abstracted engineering specifications can be formatted prior to creation of the design patterns for use with the template management system and or the automated design system.

At a user determination is made to create the service based on a template or create a completely new service. If the user decides to create the service based on a template then one or more design templates are obtained at . As noted supra the design templates can be acquired from a library or uploaded by the user. The design templates e.g. design patterns are in essence abstracted design specifications containing only generic design elements. Hardware design templates are representative of generic configurations of one or more hardware modules. Similarly software design templates are illustrative of generic sequences of events and handling of exceptions that can be translated into computer executable commands.

At the design templates are de abstracted. The design templates can be de abstracted by appending one or more class specific layers. The class specific layers contain class specific definitions wherein the definitions include various requirements of the classes. The class specific layers can include but are not limited to a customer specific layer an industry specific layer a project specific layer and an application specific layer. For example a design can require a customer specific layer wherein the customer specific layer includes a set of customer specific definitions. Appending the customer specific layer to the design template de abstracts the template by adding the customer specific definitions to the generic design elements.

At the user customizes the de abstracted design templates. The de abstracted design templates can be customized by tailoring the generic design elements of the design template for the specific project. The design templates can be customized based at least in part on at least one of a user requirement a functional specification or user input. Additionally or alternatively a customization schema can be determined based at least in part on at least one of a user requirement or a functional specification or user input. The customization schema can determine the generic design elements to be customized and or the manner in which said generic design elements are customized.

If at the user decides to create a new service then at one or more services are dynamically generated. The services can be dynamically created using a design tool wherein an interface component graphically represents industrial automation services and the design tool provides for users to develop new services by associating graphically presented design elements with the services. Moreover the design tool can provide for users to easily expose functionalities of underlying chunks of code and combine or execute such code in the form of services. A new service can also be created by clustering a set of other services together serially in parallel or combination thereof .

At one or more services are generated. The user can expose underlying chunks of code generate drawings B.O.M etc. Subsequently the user can store the services in the library and or otherwise manage the services at .

At the user can dynamically create a new service by associating graphically presented services and or design elements with the service. Moreover users can easily expose functionalities of underlying chunks of code and combine or execute such code in the form of services. In addition new services can be created by clustering a set of other services together serially in parallel or combination thereof . Subsequently the user can store the services in the library and or otherwise manage the services at .

If at the user elects to create a template then at one or more services are obtained. As previously discussed the services can be obtained from a data store or from the user. The services can relate to one or more design specifications drawings software code testing schemas bills of materials B.O.M installation specifications manufacturing execution systems MES enterprise resource planning ERP etc. The design specifications can include but are not limited to a software design specification or a hardware design specification. The software design specifications can be expressed as high level representations illustrative of a sequence of events and handling of exceptions that can be translated into computer executable commands. The hardware design specifications can be expressed as high level representations of one or more hardware modules and configurations of the modules including wiring communications etc.

At the services can be abstracted. The services are abstracted by removing one or more class specific layers wherein removing the class specific layers abstracts the services by extracting the associated class specific content and the remainder is generic design elements of the design specification. The class specific layers can include but are not limited to a customer specific layer an industry specific layer a project specific layer and an application specific layer.

Next the abstracted services can be generalized at wherein generalizing the abstracted services can include formatting identifiers designations tags etc. for use as design templates. At one or more design templates are generated based on the abstracted and generalized services. It is appreciated that the user can modify or control the level of abstraction and or generalization to achieve a desired design template. At the user can manage or store the design templates.

A classifier is a function that maps an input attribute vector x x1 x2 x3 x4 xn to a confidence that the input belongs to a class that is f x confidence class . Such classification can employ a probabilistic and or statistical based analysis e.g. factoring into the analysis utilities and costs to prognose or infer an action that a user desires to be automatically performed.

A support vector machine SVM is an example of a classifier that can be employed. The SVM operates by finding a hypersurface in the space of possible inputs which hypersurface attempts to split the triggering criteria from the non triggering events. Intuitively this makes the classification correct for testing data that is near but not identical to training data. Other directed and undirected model classification approaches include e.g. na ve Bayes Bayesian networks decision trees neural networks fuzzy logic models and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.

As will be readily appreciated from the subject specification the subject innovation can employ classifiers that are explicitly trained e.g. via a generic training data as well as implicitly trained e.g. via observing user behavior receiving extrinsic information . For example SVM s are configured via a learning or training phase within a classifier constructor and feature selection module. Thus the classifier s can be used to automatically learn and perform a number of functions including but not limited to determining according to a predetermined criteria when to update or refine the previously inferred schema tighten the criteria on the inferring algorithm based upon the kind of data being processed e.g. financial versus non financial personal versus non personal . . . and at what time of day to implement tighter criteria controls e.g. in the evening when system performance would be less impacted .

Referring now to there is illustrated a block diagram of a computer operable to execute the disclosed architecture. In order to provide additional context for various aspects of the subject innovation and the following discussion are intended to provide a brief general description of a suitable computing environment in which the various aspects of the innovation can be implemented. While the innovation has been described above in the general context of computer executable instructions that may run on one or more computers those skilled in the art will recognize that the innovation also can be implemented in combination with other program modules and or as a combination of hardware and software.

Generally program modules include routines programs components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like each of which can be operatively coupled to one or more associated devices.

The illustrated aspects of the innovation may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in both local and remote memory storage devices.

A computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital video disk DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer.

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

With reference again to there is illustrated an example environment for implementing various aspects of the innovation that includes a computer the computer including a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various commercially available processors. Dual microprocessors and other multi processor architectures may also be employed as the processing unit .

The system bus can be any of several types of bus structure that may further interconnect to a memory bus with or without a memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS is stored in a non volatile memory such as ROM EPROM EEPROM which BIOS contains the basic routines that help to transfer information between elements within the computer such as during start up. The RAM can also include a high speed RAM such as static RAM for caching data.

The computer further includes an internal hard disk drive HDD e.g. EIDE SATA which internal hard disk drive may also be configured for external use in a suitable chassis not shown a magnetic floppy disk drive FDD e.g. to read from or write to a removable diskette and an optical disk drive e.g. reading a CD ROM disk or to read from or write to other high capacity optical media such as the DVD . The hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The interface for external drive implementations includes at least one or both of Universal Serial Bus USB and IEEE 1394 interface technologies.

The drives and their associated computer readable media provide nonvolatile storage of data data structures computer executable instructions and so forth. For the computer the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer readable media above refers to a HDD a removable magnetic diskette and a removable optical media such as a CD or DVD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as zip drives magnetic cassettes flash memory cards cartridges and the like may also be used in the example operating environment and further that any such media may contain computer executable instructions for performing the methods of the innovation.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . All or portions of the operating system applications modules and or data can also be cached in the RAM . It is appreciated that the innovation can be implemented with various commercially available operating systems or combinations of operating systems.

A user can enter commands and information into the computer through one or more wired wireless input devices e.g. a keyboard and a pointing device such as a mouse . Other input devices not shown may include a microphone an IR remote control a joystick a game pad a stylus pen touch screen or the like. These and other input devices are often connected to the processing unit through an input device interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port an IEEE 1394 serial port a game port a USB port an IR interface etc.

A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor a computer typically includes other peripheral output devices not shown such as speakers printers etc.

The computer may operate in a networked environment using logical connections via wired and or wireless communications to one or more remote computers such as a remote computer s . The remote computer s can be a workstation a server computer a router a personal computer portable computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include wired wireless connectivity to a local area network LAN and or larger networks e.g. a wide area network WAN . Such LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communication network e.g. the Internet.

When used in a LAN networking environment the computer is connected to the local network through a wired and or wireless communication network interface or adapter . The adaptor may facilitate wired or wireless communication to the LAN which may also include a wireless access point disposed thereon for communicating with the wireless adaptor .

When used in a WAN networking environment the computer can include a modem or is connected to a communications server on the WAN or has other means for establishing communications over the WAN such as by way of the Internet. The modem which can be internal or external and a wired or wireless device is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device . It will be appreciated that the network connections shown are example and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with any wireless devices or entities operatively disposed in wireless communication e.g. a printer scanner desktop and or portable computer portable data assistant communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi and Bluetooth wireless technologies. Thus the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.

Wi Fi or Wireless Fidelity allows connection to the Internet from a couch at home a bed in a hotel room or a conference room at work without wires. Wi Fi is a wireless technology similar to that used in a cell phone that enables such devices e.g. computers to send and receive data indoors and out anywhere within the range of a base station. Wi Fi networks use radio technologies called IEEE 802.11 a b g etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wired networks which use IEEE 802.3 or Ethernet . Wi Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands at an 11 Mbps 802.11a or 54 Mbps 802.11b data rate for example or with products that contain both bands dual band so the networks can provide real world performance similar to the basic 10BaseT wired Ethernet networks used in many offices.

Referring now to there is illustrated a schematic block diagram of an example computing environment in accordance with the subject innovation. The system includes one or more client s . The client s can be hardware and or software e.g. threads processes computing devices . The client s can house cookie s and or associated contextual information by employing the innovation for example.

Referring now to there is illustrated a schematic block diagram of an example computing environment in accordance with the subject innovation. The system includes one or more client s . The client s can be hardware and or software e.g. threads processes computing devices . The client s can house cookie s and or associated contextual information by employing the innovation for example.

The system also includes one or more server s . The server s can also be hardware and or software e.g. threads processes computing devices . The servers can house threads to perform transformations by employing the innovation for example. One possible communication between a client and a server can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and or associated contextual information for example. The system includes a communication framework e.g. a global communication network such as the Internet that can be employed to facilitate communications between the client s and the server s .

Communications can be facilitated via a wired including optical fiber and or wireless technology. The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s e.g. cookie s and or associated contextual information . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of the innovation. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the subject innovation but one of ordinary skill in the art may recognize that many further combinations and permutations of the innovation are possible. Accordingly the innovation is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

