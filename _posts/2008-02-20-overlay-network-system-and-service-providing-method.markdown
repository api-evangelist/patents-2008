---

title: Overlay network system and service providing method
abstract: In an overlay network system in which at least one node is mapped in a hash space by distributed hash table techniques, each node having a nods identifier obtained by hashing identification information of the own node, at least one service concerning all the nodes is provided. Each node includes a storage unit and a controller. The storage unit stores a service name and a service body of the service. The controller searches for a current service provider node using a service key obtained by hashing the service name, checks whether the own node is allowed to take over the service if a distance between the node identifier of the own node and the service key is less than a distance between the node identifier of the current service provider node and the service key, and invokes the service body to provide the service if the takeover is permitted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07792900&OS=07792900&RS=07792900
owner: Sony Corporation
number: 07792900
owner_city: Tokyo
owner_country: JP
publication_date: 20080220
---
The present invention contains subject matter related to Japanese Patent Application JP 2007 041499 filed in the Japanese Patent Office on Feb. 21 2007 the entire contents of which are incorporated herein by reference.

The present invention relates to an overlay network system in which at least one node is assigned in a hash space by distributed hash table techniques and to a service providing method used in the overlay network system.

Recently as an alternative to client server systems an increasing interest is being paid to a form of connection called peer to peer hereinafter referred to as P2P in which all the nodes connected to a network can dynamically change their roles. In contrast to a client server system in which data is concentrated at a server in a P2P system data is saved in peer nodes in a distributed manner. That is searching for a location where data is saved is performed by cooperation among the peer nodes.

An example of techniques for searching for a location where data is saved is a distributed hash table hereinafter referred to as DHT . In DHT information indicating a location where a body of data is saved is registered at a node having a hash value that is approximate to a hash value generated from the data. At this time the same hash function is used to generate the hash value of the data and the hash value of the node. At each node where information indicating a location where data is saved is registered pairs of a hash value of the data and the information indicating the location where the body of the data is saved are maintained in the form of a hash table.

Since hash values generated from different data take on entirely different values nodes at which information indicating locations where data is saved are distributed on the network. That is hash tables are stored in the peer nodes in a distributed manner so that the load is distributed among the peer nodes.

When searching for data is performed the data can be found by calculating a hash value of the data and performing searching using the hash value as a key. In DHT every node constituting the network has a routing table describing routes to neighboring nodes. In the routing table the distance between nodes is represented using hash values of the nodes.

In order to refer to data registered at one of the nodes on the network first a hash value of the data is calculated and a searching request is issued to a node having a value that is closest to the hash value of the data with reference to the routing table in the own node. If the node that has received the searching request does not have information indicating a location where the data is saved the node that has received the searching request issues a searching request to a node having a hash value that is most approximate to the hash value of the data with reference to the routing table in the own node. By repeating this operation the range of searching becomes narrower and information indicating the location where the data is saved can be found in the end. When information indicating the location where the data is saved has been obtained it is possible to obtain the data body on the basis of the information. That is in an overlay network constructed using DHT techniques it is possible to access a data body without considering the location of the data body.

As described above in DHT routing is performed on the basis of distances between peer nodes represented using hash values. Thus it is not needed to be aware of segments provided on an IP network. That is it is possible to construct an overlay network using DHT in which routing is performed in a layer above the IP layer.

Services provided on an overlay network can be broadly classified into two types namely local services provided by individual nodes and global services relating to the overlay network as a whole. Examples of local services provided by individual nodes include a Web service and an FTP service. The services provided by the individual nodes are available only during periods in which the nodes are alive on the network and the services become unavailable when the nodes have left the network.

In contrast even when for example a node has newly joined the overlay network or a node has left the overlay network global services are expected to be available as long as the overlay network exists. Examples of global services include an authentication service that is used when a new node joins the overlay network and a node list service and a service list service for management.

When global services are provided some measures are often taken in order to improve the availability of the global services for example a server for providing global services is provided on the network or some nodes are designated in advance as super nodes that act like servers. The scheme in which a server is provided on an overlay network is called hybrid P2P and the scheme in which super nodes are provided on an overlay network is called super node hybrid P2P. On the other hand the scheme in which an overlay network is purely formed of peer nodes alone is called pure P2P.

Japanese Unexamined Patent Application Publication No. 2005 196676 discloses a hybrid P2P system in which a central server is provided in addition to peer nodes.

In a case where a server or super node is provided on an overlay network so that global services can be provided reliably the system becomes less flexible compared with a pure P2P system.

Furthermore in the case of a super node hybrid P2P generally the super nodes are designated on the basis of the abilities of nodes CPU performance memory capacity network bandwidth etc. . However for example in the case of a network formed of terminals used in a video conference system or a network formed of network cameras the abilities of all the nodes are substantially the same so that it is difficult to determine which nodes are to be designated as super nodes.

According to an embodiment of the present invention there is provided an overlay network system in which at least one node is mapped in a hash space by distributed hash table techniques each of the at least one node having a node identifier obtained by hashing identification information of the own node and in which at least one service concerning all the nodes constituting the overlay network system is provided. Each of the at least one node includes a storage unit configured to store a service name representing a name of the service and a service body representing a body of the service and a controller configured to search for a current service provider node using a service key existing in the hash space the service key being obtained by hashing the service name to check whether the own node is allowed to take over the service if a distance between the node identifier of the own node and the service key in the hash space is less than a distance between the node identifier of the current service provider node and the service key in the hash space and to invoke the service body in the own node to provide the service if the takeover is permitted.

Accordingly each service is automatically assigned to a node having a node identifier that is closest in a hash space to a service key of the service.

According to the embodiment of the present invention a node that provides a service is automatically designated so that a global service can be provided autonomously by peer nodes alone.

Now an embodiment of the present invention will be described with reference to the accompanying drawings. In this embodiment a network system according to the present invention is applied to a video conference system constituted by a plurality of video conference terminals. is a diagram showing a plurality of video conference terminals connected to each other via a network . Each of the video conference terminals shown in is a node constituting an overlay network. Thus in six video conference terminals connected to the network are denoted individually as nodes N to N. In the following description when the functions of a video conference terminal as a node are described the video conference terminal will be denoted as a node Nn where n is an integer . The embodiment will be described in the context of an example where DHT is used to construct an overlay network and Chord is used as an algorithm therefor.

First an example of the internal configuration of the video conference terminal will be described. The video conference terminal shown in includes a lens and an imaging unit . The lens is included in a camera unit that is attached externally or provided internally. The imaging unit photoelectrically converts an optical image of an object input through the lens to generate video signals. The lens and the imaging unit capture an image of a user of the video conference terminal video signals obtained by imaging undergo signal processing in a signal processor not shown and the processed video signals are distributed to the other video conference terminals on the network via a communication interface hereinafter abbreviated as I F .

The communication I F is an interface for connection with the network . The communication I F serves to capture data sent from the other video conference terminals on the network into the video conference terminal . The video conference terminal also has a display for displaying images of users of the other video conference terminals obtained via the communication I F . The display is formed of for example a liquid crystal panel.

Furthermore the video conference terminal has a microphone and a speaker and the microphone and the speaker are connected to an audio processor . The audio processor executes audio data processing for transmission on audio signals of the user of the video conference terminal collected by the microphone and sends the resulting audio signals to the communication I F . Furthermore the audio processor executes audio data processing on audio signals of users of the other video conference terminals obtained via the communication I F and outputs the resulting audio signals from the speaker .

The operations of the components described above are executed according to input of user s operations via an operation unit including buttons a keyboard and so forth. The operations of the components are controlled by a controller formed of a central processing unit CPU or the like. The controller is connected to a memory . The memory stores programs need for control and so forth. The controller reads the programs stored in the memory and executes the programs.

The video conference terminal includes a storage unit formed of a memory card hard disk or the like. The storage unit can store data sent from the other users on the network and so forth. Furthermore the storage unit has stored in advance a routing table T and a global service table T.

The routing table T is a table describing location information of nodes neighboring the own node and is composed of for example m rows. On the i th row of the m row table information of nodes within a range of the own node ID 2 i 1 is described. When m 4 each node stores in its routing table T node information of nodes that are 1 2 4 and 8 hops from the own node. The node ID is a hash value obtained by an expression hash X where an IP address identifier or the like of the node is assigned to X in the expression. That is the node ID identifier is a hash value obtained by hashing an IP address identifier or the like of the node.

Since each node has such a routing table T even if each node has only information of nodes that are 1 2 4 and 8 hops from the own node by transferring a searching request from node to node on the basis of information of the routing tables T of the individual nodes the searching range is narrowed and intended data can be found in the end.

The global service table T is a table describing information regarding all global services hereinafter also simply referred to as services provided on the overlay network. Examples of global services include an authentication service for the video conference terminals an address list service that allows viewing a list of the video conference terminals and so forth. The global service table T will be described later in detail.

The service name is a name of a service provided on the overlay network and is represented according to a predetermined naming scheme for example in the form of a URI Uniform Resource Identifier . For example the authentication service is represented as urn abcdabcd dht product service global authentication and the address list service is represented as urn abcdabcd dht product service global nodelist. The service body is an executable program and the program is configured so that the service can be dynamically started or stopped.

The service profile is content in a file format in which endpoint information e.g. IP address or URL or API Application Programming Interface for accessing the service is described. The service profile is a file that can be automatically configured according to the own environment of each node and the content thereof varies among individual nodes. For example if the format of the service profile is Service EndPoint http host port path service the service profile for the same service varies among individual nodes for example http 192.168.0.1 cgi bin service1.cgi in the node N and http 192.168.1.1 8080 service service1.cgi in the node N. The service profile and the service body are stored in the storage unit refer to of each node.

The service record data file is a file in which data that occurs when a service is executed and that is to be recorded and saved is described. The service record data file is dynamically exported or imported by the service body.

Furthermore in this embodiment names for identification are assigned to the individual defined elements and the elements are mapped in the same hash space of the overlay network using hash values of the assigned names. Thus services defined by the elements can be searched for and obtained anywhere on the overlay network.

The global service table T is a list of names for identification and hash values. Every node in the overlay network has the global service table T. The global service table T includes a number of sets of definitions of elements corresponding to the number of services so that the elements are defined for all the services provided on the overlay network. If an authentication service and an address list service are provided on the overlay network the elements described above are defined for each of the authentication service and the address list service.

The index is assigned in accordance with the number of items counted in the row direction of the global service table T and is represented by 1 to n. The number of items counted in the row direction of the global service table T increases or decreases in accordance with the number of global services. The service name has been described earlier so that description thereof will be omitted. The service key is a hash value obtained by hashing the service name i.e. obtained by hash service name . In the service name is urn abcd dht service global servicename1 so that the service key is obtained by hash urn abcd dht service global servicename1 .

The service profile name is defined to be the same as the service name. The service profile key is a hash value obtained by hashing the service profile name. Since the service profile name is the same as the service name the service profile key has the same value as the service key.

The service profile describes a path to the body of the service profile described above. Since the service profile is stored in the storage unit refer to a path in the storage unit is described. In the example shown in the path is described as dht service profile service profile1.xml . The path to the service body described above is also described in the service body. In the example shown in the path is described as www cgi bin service1.cgi .

The service record data file name is a name of the service record data file. Similarly to the service name the service record data file name is represented by a character string such as a URI. In the example shown in the service record data file name is described as urn abcd dht service global servicedata1 . The service record data file key is a hash value obtained by hashing the service record data file name so that the service record data file key is hash urn abcd dht service global servicedata1 . In the service record data file a path to the body of the service record data file is described.

Since the service key the service profile key and the service record data file key can be calculated from the service name the service profile name and the service record data file name the service key the service profile key and the service record data file key may be calculated each time instead of including these items in advance in the global service table T.

Although every node has the same global service table T each service is provided only by a specific node. The specific node refers to a node having a node ID with a smallest distance from the service key. In this embodiment the specific node serves as a service provider. The service provider satisfies the following conditions 

That is although every node on the overlay network has a service body only a node acting as a service provider executes the service body. Thus only the service profile owned by the service provider is effective as a service profile describing a method of access to the service that is being executed.

The determination of the uploading target node and the saving of the file in the target node in step S are executed using an expression put key content . That is by executing the expression put service record data file key service record data file a node that is mapped to the service record data file key and its neighboring nodes is determined and the service record data file a copy or a fragment that allows restoration of the file is saved.

After saving the service record data file the node checks whether the service record data file in the own node has been updated step S . If the service record data file has not been updated no processing is executed. If the service record data file has been updated the process returns to step S in which the updated file is saved in the updating target node. The processing for saving the service record data file in the own node to the updating target node is executed each time the service record data file in the own node is updated.

The service name and the service record data file name are defined to be different names. Since hash values generated from different names data have different values by executing the process described above the node of the service provider and the nodes in which the service record data file is saved are distributed on the overlay network. In the following description the process shown in will be described as a service providing flow .

Next an example of a process executed by a node that uses a service will be described with reference to a flowchart shown in . A node that wishes to use a service first searches for a service provider node using a service profile key in the global service table T of the own node step S . The searching for a service provider node is executed using an expression Node lookup key . A node mapped to the service profile key can be found by assigning the service profile key as key in the expression.

After determining the service provider node the node accesses the service provider node on the basis of the routing table T of the own node and obtains a service profile owned by the service provider node step S . Then the node analyzes the service profile step S and accesses the service by a method described in the service profile to use the service step S . In the following description the process shown in will be referred to as a service using flow .

Next an example of a process executed by a node that fakes over a service from another node will be described with reference to a flowchart shown in . A node that has newly become a service provider first prepares a service profile step S . Then the node obtains a service record data file from the overlay network using a service record data file key in the global service table T step S and reconstructs the service step S . The service record data file is obtained using an expression content get key . By assigning the service record data file key in key in the expression the service record data file can be obtained from a node mapped to the service record data file key.

After obtaining the service record data file the node starts the service body program step S . While the service is being provided the node checks whether the service record data file in the own node has been updated step S . If the service record data file has not been updated no processing is executed. If the service record data file has been updated the updated file is saved in the updating target node step S . The processing for saving the service record data file in the own node to the updating target node is executed each time the service record data file in the own node is updated. In the following description the process shown in will be referred to as a service takeover flow .

Next examples of processes that are executed when a new node joins the overlay network will be described with reference to flowcharts shown in . shows an example where a newly joining node is the first node that constitutes an overlay network. The first node joining the overlay network executes the service providing flow step S for every service described in the global service table of the own node. That is this node acts as a service provider for all the services described in the global service table T.

Then the distance D is compared with the distance step S . If the distance D is greater than or equal to the distance D D D the own node has a greater or the same distance to the service key than the current service provider so that the newly joining node does not take over the service and immediately exits the process. If the distance D is less than the distance D D

Upon receiving the service takeover permission request step S the current service provider node determines whether or not to accept the request step S . If the request is to be rejected the current service provider node sends a response to the newly joining node at the source of the request together with a reason for rejection step S . If the request is to be accepted the current service provider node sends a response to the newly joining node at the source of the request step S .

Upon receiving the response from the current service provider node step S on the basis of the content of the response the newly joining node determines whether the takeover of the service has been permitted step S . If the takeover of the service has been rejected the newly joining node exits the process immediately. If the takeover of the service has been permitted the newly joining node executes the service takeover flow step S and sends a notification of completion to the predecessor service provider node after completion of execution of the service takeover flow step S . Upon receiving the notification of completion step S the predecessor service provider node stops the service being provided step S .

Through the process described above a node having a smallest distance from the service key constantly serves as a service provider of the service.

Next examples of processes that are executed when a node leaves the overlay network will be described with reference to flowcharts shown in . shows an example of a process in which a node normally leaves an overlay network. shows an example of a process in which a node abruptly leaves the overlay network due to a problem or the like. Referring to a node that is going to leave the overlay network first determines whether the own node is a service provider step S . If the own node is not a service provider the node immediately leaves the overlay network step S .

If the leaving node is a service provider the leaving node selects as a service transfer target node a node having a second smallest distance from the service key next to the own node with reference to the routing table T in the own node step S . Then the leaving node sends a service handover request to the service transfer target node step S .

Upon receiving the service handover request from the leaving node step S the service transfer target node unconditionally accepts the service handover request step S and executes the service takeover flow step S . Upon completion of the service takeover flow the service transfer target node sends a notification of completion of service takeover to the leaving node step S . Upon receiving the notification of service takeover from the service transfer target node step S the leaving node stops the service that is being executed step S and leaves the overlay network step S .

Next an example of a process that is executed when a node abruptly leaves the overlay network due to a problem or the like will be described with reference to a flowchart shown in . Each node constituting the overlay network sends ping or keep alive signals periodically to adjacent nodes so that if a certain node abruptly leaves the overlay network adjacent nodes can detect the situation. Thus if a problem occurs at a certain node the node that takes an action first is an adjacent node that has detected the problem.

The node that has detected the problem at the adjacent node searches for nodes mapped to service keys using all the service keys in the global service table T of the own node step S . Then the node sends a query as to the availability of a service whether a service is being executed to all the nodes mapped to the service keys step S .

Each of the nodes that have received the query upon receiving the query step S determines whether a service is being executed at the own node step S . If a service is being executed the node sends a response indicating that a service is being executed to the node that has detected the problem step S and then exits the process. If a service is not being executed the node sends a response indicating that a service is not being executed to the node that has detected the problem step S and executes the service takeover flow step S . Upon receiving the response from the node that has received the query step S the node that has detected the problem immediately exits the process.

Next a specific example of dynamic service assignment that is executed when a node joins or leaves the overlay network as described above will foe described with reference to . show states where nodes are arranged in a hash space. Since this embodiment is being described in the context of an example where the Chord algorithm is used the hash space is represented as a circle and nodes are arranged so that the node IDs become greater in the clockwise direction.

In the Chord algorithm nodes are mapped in a hash space using a function next k . This function defines that regarding a key k a node that is encountered first in the clockwise direction has a smallest distance from the key k. In it is assumed that a service S is being provided on the overlay network and that the service S has a service key .

As shown in if the node N abruptly leaves the overlay network due to a problem or the like the node N and the node N detect the situation and become problem detection nodes and the process described with reference to is executed. The node mapped to the service key in step S shown in is the node N in the case shown in so that the node N executes the service takeover flow step S shown in whereby the service S is handed over to the node N.

As described above a name for identification service name is assigned to each service provided on an overlay network and a node mapped to a hash value obtained by hashing the service name acts as a service provider so that services are dynamically assigned to nodes.

Furthermore different names are assigned as a service name and a service record data file name and the service name and the service record data file name are assigned on the overlay network using a service key obtained by hashing the service name and a service record data file key obtained by hashing the service record data file name. Thus a service provider mapped to the service key and a node mapped to the service record data file key are distributed on the network.

That is the service record data file is recorded at a node that is different from the service provider node. Thus eve if the service provider is changed for example due to a service provider node leaving the overlay network a node that has taken over the service can immediately resume the service using the service record data file stored on the overlay network. That is a global service can be provided stably without discontinuity in the overlay network.

Furthermore since every node constituting the overlay network has a service body even when a node has taken over a service from a predecessor service provider node the node can start the service immediately without transferring the service body.

Furthermore even when a problem or the like occurs at a service provider node so that the service provider node becomes unable to provide the service an adjacent node that has detected the problem searches for a node mapped to the service key using the service key and causes the node to execute a service takeover process. Thus interruption of a global service provided on the overlay network is prevented.

As described above since the overlay network is configured so that a global service can be provided only by peer nodes without interruption it is not necessary to provide a server or a super node. This serves to construct a flexible system.

Furthermore since services are assigned to nodes on the basis of service keys obtained by hashing service names of the services services are assigned fairly and equally to all the nodes constituting the overlay network. Thus concentration of load to a specific node is prevented.

The embodiment has been described in the context of an example where Chord is used as a DHT algorithm without limitation to the example the present invention can be applied to systems in which other algorithms are used such as CAN or Pastry.

Furthermore although the embodiment has been described in the context of an example of application to a video conference system the present invention can also applied to systems in which terminals constituting a network have substantially the same capabilities for example a monitoring system constituted by network cameras. When the present invention is applied to the monitoring system it is possible to provide for example a terminal authentication service a terminal list obtaining service or an event information obtaining service.

It should be understood by those skilled in the art that various modifications combinations sub combinations and alterations may occur depending on design requirements and other factors insofar as they are within the scope of the appended claims or the equivalents thereof.

