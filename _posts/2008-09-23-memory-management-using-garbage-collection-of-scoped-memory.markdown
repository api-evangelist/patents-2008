---

title: Memory management using garbage collection of scoped memory
abstract: Mechanisms for memory management in a scoped memory system are provided. The scoped memory system includes a scoped memory area for the allocation of objects therein for access by one or more software threads in execution. The scoped memory area has an associated thread count for indicating that the scoped memory area is discardable. The mechanisms identify a set of root references for objects allocated in the scoped memory area and recursively traverses and marks objects that are referenced from the set of root references and that are allocated in the scoped memory area. The mechanisms further identify objects in the scoped memory area that are not so marked and discards the identified objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291187&OS=08291187&RS=08291187
owner: International Business Machines Corporation
number: 08291187
owner_city: Armonk
owner_country: US
publication_date: 20080923
---
The present invention relates to memory management in a computer system. More particularly it relates to garbage collection of scoped memory.

Memory management in runtime environments is often devised so as to provide convenience for the software engineer. For this reason runtime environments such as Java Java is a Registered Trademark of Sun Microsystems Inc. include heap memory having a garbage collector. A garbage collector is a runtime facility for automatically identifying and discarding unused data from memory such as objects so as to free up storage.

Garbage collection is a luxury afforded by the efficiencies of modern computer systems that serves to liberate software engineers from the task of programmatically discarding each and every unused object. It does however present some drawbacks. One such drawback is that the process of garbage collection generally requires the suspension of execution of software threads accessing the heap. This is because the process of identifying and discarding unused objects cannot normally be undertaken while software threads actively allocate and access existing or new objects. For the garbage collector to operate effectively the state of the heap is to be preferably static and determinate for the duration of the garbage collection process. The duration of suspension of threads for garbage collection depends on the number and variety of data objects existing in the heap and can range from an imperceptibly short duration to periods long enough to be perceived by a user. Thus the process of garbage collection can lead to delays of indeterminate frequency and duration. These downsides render garbage collected runtime environments inherently unsuitable for software depending on continuity of execution and predictability. Such software includes critical real time applications such as those used in monitoring and control applications and these applications are normally precluded from accessing a garbage collected memory in order to ensure their consistency and stability.

To address these downsides of garbage collected heap memory runtime environments can be adapted to use scoped memory areas. Scoped memory areas are areas of memory suitable for the allocation and de allocation of objects without some of the disadvantages of garbage collected heaps. A software thread can enter a scoped memory area and all object allocations by the thread will then be made within the scoped memory area. The thread can also enter multiple scoped memory areas in a nested fashion. For example the thread can enter a second scoped memory area which becomes the default allocation area. Scoped memory areas are organised in a scope graph with each scoped memory area having a parent being the previously entered scoped memory area. A first scoped memory area has a primordial scoped memory area as its parent.

A thread count is maintained for each scoped memory area of a number of active threads in the area. The thread count coupled with the scope graph indicates when a scoped memory area including any objects allocated in the scoped memory area is discardable. For example a scoped memory area may be discardable when an associated thread count is decremented from one to zero and the scoped memory area is not a parent for any other scoped memory area. In this way scoped memory areas offer alternative allocation spaces for objects in an otherwise garbage collected runtime environment such as Java. The use of such scoped memory areas can address the problem of delays and uncertainty in application execution caused by garbage collection algorithms since all objects in scoped memory areas become discardable at the same time defined in terms of thread usage of the memory area and the organisation of a scope graph.

A first object in a first scoped memory area can reference a second object in a second scoped memory area. However since individual scoped memory areas can become completely discardable it is necessary to enforce strict rules regarding valid and invalid references between objects in different scoped memory areas. These rules are necessary to guarantee that a parent scoped memory area has a lifetime that is at least that of its child scoped memory areas so that objects in descendant memory areas can reliably reference objects in ancestor memory areas. In this way dangling references can be avoided. This is described in Efficient Memory Reference Checks for Real time Java Corsaro and Cytron ACM SIGPLAN Volume 38 Issue 7 July 2003 .

One such rule is that a scoped memory area has at most one parent. This is known as the single parent rule . The single parent rule provides that the order of entry into scoped memory areas by different threads is always the same because the order of entry of threads into scoped memory areas defines the structure of the scoped memory areas in the scope graph. Further a source object allocated in a source scoped memory area can only reference target objects in the same or ancestral scoped memory areas. An ancestral scoped memory area is a memory area which is entered by a thread before the source scoped memory area. The source scoped memory area is said to have inner scope with respect to that of the target object. This criterion ensures that the source object will always be de allocated before the target object. Attempts to create references which do not satisfy the criterion must fail according to the Real Time Specification for Java Bollella et al Addison Wesley 2000 . Thus the criterion must be checked in an efficient manner whenever a new reference to a target object is created.

One way to determine whether this criterion is satisfied for the creation of a reference between objects is to iterate through scoped memory areas in a scope graph. Iteration starts at the source scoped memory area and progresses through each parent scoped memory area checking for the target scoped memory area. If the target scoped memory area is encountered within the scope graph during the iterations then it can be concluded that the criterion is satisfied because the target area is an ancestor of the source area. If the iterations reach the primordial scoped memory area the root of the scope graph then it can be concluded that the criterion is not satisfied because the target scoped memory area is not an ancestor of the source scoped memory area.

An alternative approach is to determine an index of the distance between the scoped memory area of the target object and the primordial scoped memory area. This distance can be considered to be a depth of the target scoped memory area. Additionally an index of the distance between the scoped memory area of the source object and the primordial scoped memory area can be determined as a depth of the source scope. The term depth here is used to indicate that scoped memory areas exist at levels which are some distance from the primordial scoped memory area. Deeper scoped memory areas are located at a level in the scope graph which is further from the primordial scoped memory area. A comparison of these indices of depth will determine whether the target scoped memory area is an ancestor of the source scoped memory area because descendent areas will always be deeper further from the primordial scoped memory area than ancestor areas. Thus if the source scoped memory area is deeper than the target scoped memory area then the criterion is satisfied and a reference can be created.

Scoped memory area is a defined area of memory in storage suitable for the allocation and reference of software objects. Objects can be allocated and accessed in an allocated objects part of the scoped memory area by software threads which execute in the context of the scoped memory area . The scoped memory area further includes a thread count as a count of a number of software threads executing in the context of the scoped memory area . A thread executes in the context of the scoped memory area by explicitly entering the scoped memory area such as by calling of an application programming interface function. Once a thread has entered the scoped memory area allocations of objects will be undertaken within the scoped memory area unless specifically allocated elsewhere by the thread such as in the general heap or another scoped memory area.

Scoped memory area further includes a parent field which includes a reference to a parent scoped memory area. As described above a scoped memory area has at most one parent. An arrangement of scoped memory areas defined by way of a parental relationships there between defines the scope graph . An initial scoped memory area having no particular parent will refer to a primordial scoped memory area as its parent by way of a placeholder.

Critical software depending on continuity of execution and predictability can use scoped memory areas for the allocation of objects. Since scoped memory areas are not garbage collected delays and uncertainty associated with garbage collection processes do not affect scoped memory or software threads using scoped memory. While this provides certainty for critical software threads it presents the disadvantage that individual objects allocated in scoped memory are not discarded until all objects in the scoped memory are discardable. Thus scoped memory can become consumed by numerous unused objects.

It would therefore be advantageous to provide the advantages of garbage collection with the certainty and consistency of scoped memory.

In one illustrative embodiment a method implemented in a data processing system of memory management in a scoped memory system of the data processing system is provided. The scoped memory system includes a scoped memory area for the allocation of objects therein for access by one or more software threads in execution. The method comprises identifying by a scoped memory garbage collector of the data processing system a set of root references for objects allocated in the scoped memory area of the scoped memory system. The method also comprises recursively traversing and marking by the scoped memory garbage collector objects that are referenced from the set of root references and that are allocated in the scoped memory area of the scoped memory system. The method further comprises identifying objects in the scoped memory area that are not so marked and discarding said identified objects.

In another illustrative embodiment an apparatus for memory management in a scoped memory system is provided. The scoped memory system includes a scoped memory area for the allocation of objects therein for access by one or more software threads in execution. The apparatus comprises a processor and a memory coupled to the processor. The memory comprises a computer program which configures the processor to identify a set of root references for objects allocated in the scoped memory area traverse and mark objects that are referenced from the set of root references and that are allocated in the scoped memory area identify objects in the scoped memory area that are not so marked and discard the identified objects.

In yet another illustrative embodiment a computer program product in a computer readable medium is provided. The computer program code when loaded into a computer system and executed thereon causes the computer system to identify a set of root references for objects allocated in a scoped memory area of a scoped memory system of the computer system traverse and mark objects that are referenced from the set of root references and that are allocated in the scoped memory area identify objects in the scoped memory area that are not so marked and discard the identified objects.

In still a further illustrative embodiment a computer system is provided that comprises a processor and a scoped memory system coupled to the processor the scoped memory system including a scoped memory area for the allocation of objects therein for access by one or more software threads in execution on the processor. The computer system further comprises a scoped memory garbage collector coupled to the scoped memory system. The scoped memory garbage collector is implemented in hardware within the computer system. The scoped memory garbage collector operates to identify a set of root references for objects allocated in the scoped memory area traverse and mark objects that are referenced from the set of root references and that are allocated in the scoped memory area identify objects in the scoped memory area that are not so marked and discard the identified objects.

These and other features and advantages of the present invention will be described in or will become apparent to those of ordinary skill in the art in view of the following detailed description of the example embodiments of the present invention.

A garbage collected heap in a runtime environment can be employed by all software threads in execution. The process of garbage collection of the heap can therefore require the suspension of all executing threads using the heap. This imposes an uncertain delay on all such threads. In contrast the application of a garbage collection process to a scoped memory area can only affect the threads accessing the scoped memory area. For this reason the extent of any such uncertain delay is constrained only to those threads accessing the scoped memory area. Further since the number of such threads accessing the scoped memory area is typically small in comparison with all threads in an application the length of any such delay is also constrained. Thus a garbage collection process applied to a scoped memory area will provide the advantages of garbage collection with the certainty of scoped memory by virtue of the limited number of threads accessing the scoped memory. The illustrative embodiments provide mechanisms for performing such a garbage collection process on scoped memory areas.

References to are object references within threads to . For example each such reference can include a memory address base and offset or pointer to a software object. Thread includes a reference to object in the garbage collected heap . Thread further includes a reference to object in the garbage collected heap . Thread includes a reference to object in the garbage collected heap and a reference to object in the scoped memory area . Thread includes references and to objects and respectively in the scoped memory area. Thread includes a reference to object in the scoped memory area. Thus thread includes only references to objects in the garbage collected heap. Threads and include only references to objects in the scoped memory area . Thread includes reference to objects in both the garbage collected heap and the scoped memory area . In execution threads and with references to objects allocated in the garbage collected heap will be affected by the periodic processing of the garbage collector in that heap . On the other hand threads and are not affected by the garbage collector in the garbage collected heap since they have no references to objects in that heap . In contrast threads and employ scoped memory area that is discardable in dependence on the thread count .

In accordance with one illustrative embodiment of the present invention the techniques of garbage collection are further applied to the scoped memory area by way of a scoped memory garbage collector . The scoped memory garbage collector is a software or hardware component of the runtime environment operable to identify and discard unused objects in the scoped memory area . In this way the advantages of garbage collection are provided for the scoped memory area and threads that are restricted to using only scoped memory such as critical real time threads are able to benefit from garbage collection.

At step each reference in the set of root references is traversed recursively to identify objects that are allocated in the scoped memory area . Recursive traversal of a reference involves accessing all references stored at a referenced location in a recursive fashion as is undertaken for example when fully traversing a linked list or tree data structure. The purpose of the traversal is to identify all objects allocated in the scoped memory area that are referenced from a root reference. When such an object is identified it is marked. Marking of objects can be undertaken by any suitable fashion such as by setting a flag within the object itself or by generating or amending an entry corresponding to the object in a separate data structure such as a table. In this way all objects in the scoped memory area referenced by the software application in execution such as via the threads to are marked.

At step the method identifies objects in the scoped memory area that are not marked. The objects identified at step are unused objects that is objects to which there exists no identified reference in the software application. The objects identified at step are discarded. Discarding an object can include inter alia marking the object as discardable marking the memory consumed by an object as free memory or actively deleting the object from memory.

Initially at step a set of root references for all objects allocated in the scoped memory area is identified. This set includes only references in thread since thread is the only thread having references to objects in the scoped memory area . Thus the set of root references comprises references and . At step the method traverses each of the root reference and and marks objects in the scoped memory area . Thus traversing root reference object B is marked since it is allocated in the scoped memory area . The marking of object B is indicated by a tick. Traversing root reference object A is marked since it is allocated in the scoped memory area . The traversal of root reference is recursively performed for reference to object E which is also in the scoped memory area and so is also marked. Further the traversal of reference to object D which is also in the scoped memory area and so is also marked. Thus on completion of step objects B A E and D are marked in the scoped memory area since these objects are referenced directly or indirectly from the root references and . Finally at step the method identifies objects allocated in the scoped memory area that are not marked. Objects C and F are therefore identified and these objects are discarded. In this way a process of garbage collection can be applied to the scoped memory area .

In order to undertake the operations of described above it may be necessary to prevent changes to the references to and objects within a scoped memory in order that the scoped memory garbage collector can operate on the scoped memory area in a static state. To achieve this all threads accessing the scoped memory area are preferably transitioned to a suspended state in which execution of the software threads is stopped.

Correspondingly on completion of the garbage collection process all threads accessing the scoped memory area are preferably transitioned from the suspend state to an active state.

Further on completion of a garbage collection operation it can be preferable to undertake a tidy up operation on the scoped memory area using compaction. Compaction is a process of moving objects within a memory space such that the memory they occupy is substantially contiguous leaving relatively large areas of free memory. In contrast in uncompacted memory many allocated objects can be widely dispersed leaving many small areas of free memory there between. Compaction will involve moving objects allocated in the scoped memory area to contiguous or substantially contiguous memory locations in the scoped memory area . Additionally references to each moved object will need to be updated to correspond to a new memory location for the object. This is known as a process of fixing up or modifying references.

Insofar as embodiments of the invention described are implementable at least in part using a software controlled programmable processing device such as a microprocessor digital signal processor or other processing device data processing apparatus or system it will be appreciated that a computer program for configuring a programmable device apparatus or system to implement the foregoing described methods is envisaged as an aspect of the present invention. The computer program may be embodied as source code or undergo compilation for implementation on a processing device apparatus or system or may be embodied as object code for example.

Suitably the computer program is stored on a carrier medium in machine or device readable form for example in solid state memory magnetic memory such as disk or tape optically or magneto optically readable memory such as compact disk or digital versatile disk etc. and the processing device utilises the program or a part thereof to configure it for operation. The computer program may be supplied from a remote source embodied in a communications medium such as an electronic signal radio frequency carrier wave or optical carrier wave. Such carrier media are also envisaged as aspects of the present invention.

It will be understood by those skilled in the art that although the present invention has been described in relation to the above described example embodiments the invention is not limited thereto and that there are many possible variations and modifications which fall within the scope of the invention.

The scope of the present invention includes any novel features or combination of features disclosed herein. The applicant hereby gives notice that new claims may be formulated to such features or combination of features during prosecution of this application or of any such further applications derived therefrom. In particular with reference to the appended claims features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the claims.

