---

title: Interacting methods of data summarization
abstract: Summarization methods can interact on a common data source using identifiers that correspond to events or other actions. These identifiers can be updated, whenever appropriate, once the corresponding data has been summarized, in order to provide for multiple extraction methods to operate only on the data of interest, and obtain a lock only on the data within the scope of extraction. High water marks, such as identifiers in the sequent, can be used to further designate which data has previously been extracted. Similarly, summarization methods can interact by utilizing corresponding persistent tables in the flows for the methods, but utilizing separate intermediate tables to allow for data transformations and application of various business rules and tuning techniques. The ability to switch between different methods can accommodate business, performance, or other such needs, and can provide for the dynamic extraction and summarization of different volumes of data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958083&OS=07958083&RS=07958083
owner: Oracle International Corporation
number: 07958083
owner_city: Redwood Shores
owner_country: US
publication_date: 20080331
---
This application is related to U.S. patent application Ser. No. 12 059 811 filed on Mar. 31 2008 and entitled INTERACTING METHODS OF DATA EXTRACTION which is hereby incorporated herein by reference.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates generally to extracting and summarizing data and in particular to allowing different extraction summarization or other such methods to interact while operating on the same data source.

Presently many problems are met when extracting and or summarizing data. For example multiple extraction methods currently exist but each extraction method has its own limitations. For instance one extraction method may perform well with a small volume of data but may perform poorly with a large volume of data. Alternatively a second extraction method may perform well with a large volume of data but may perform poorly with a small volume of data. Examples of such extraction solutions are discussed below.

In one previous solution called logging when data in a table is updated or inserted entries to a log are added. Such log entries may then be extracted and reported on as desired. However such a process requires the joining of a potentially large data source with a log table that may also grow large. Therefore the logging solution does not perform well for high volume extractions.

In a solution similar to the logging solution a solution called event based logging may create an entry which has additional information beyond which row has been updated or inserted. This entry may contain functional information that allows the entry to be identified and individually processed. However for similar reasons as the logging solution the event based solution does not perform well for high volume extractions.

In another solution called flagging a flag is used to mark areas of a data source the flag identifies the data that has not been previously extracted. In some cases the flag may take on a value of N if the data has not been extracted and is updated to null when the data is extracted. However because of the limitations of a flag the flag needed to be updated to a value of null immediately or else the incremental context was lost. Furthermore when only a small portion of the data is functionally required for extraction using information other than the flag may be required since the flag could be set to N for a much larger data set than required.

In yet another solution rather than actually extracting the data a view is defined that takes the place of a summarization program. However such a view may quickly become intractable in a summarization solution. Further this solution does not perform well with larger amounts of data since it forces all of the data to be summarized on every extraction. Moreover using a view precludes other beneficial aspects of a summarization program such as the recoverability of extraction work that has already been completed.

In a solution similar to the viewing solution a solution without incremental logic makes it possible to extract all the data every time the summarization program is run. However in addition to the problems that the first viewing solution has this second viewing solution has the added overhead of clearing the data from wherever the summarization program finally leaves the summarized data.

Previously different solutions such as the ones described above could not operate on the same source of data reliably. Attempting to utilize multiple solutions on the same source of data risked the corruption of the data. As such developers were forced to design custom solutions targeted to specific scenarios with little flexibility or scalability. Developers resources were consumed as they developed these custom solutions while customers costs increased. Customers were forced to use only one solution and such a single solution was not always the most efficient solution for all of their possible scenarios.

In another previous solution employing hybrid flow with persistent incremental tables there is typically a single summarization flow that diverges in locations that require different types of tuning to optimize for bulk and incremental summarization methods. This approach tends to be implemented after a summarization flow is designed and during advanced coding stages and even implementation when various portions of the flow need to be tuned differently for bulk and incremental data volumes. Without a meaningful separation of the bulk and incremental methods and an architectural way of fixing the data to ensure better performance this approach can cause the data in the persistent tables to become fragmented over time.

In another solution using index organized tables index organized tables automatically maintain the physical placement of data in the table to minimize fragmentation. However persisting data in these tables with frequent high volume updates results in undesirable end user overhead due to the automatic maintenance of the data in the tables.

In yet another solution it is necessary to periodically execute data maintenance manually in order to improve the summarization methods performance. This typically requires more support from a development team than if a deferring and scheduling method were to exist.

In still another solution it is possible to use a single code path for all methods of summarization. However this architecture does not have the flexibility to be optimized for both bulk and incremental methods when the tuning techniques differ between the two data volumes and therefore the solution does not scale well.

Previously different solutions such as the ones described above could not operate on the same source of data reliably. Attempting to utilize multiple solutions on the same source of data risked corruption of the data. As such users are forced to use only one solution and this single solution was not always the most efficient solution for certain scenarios. Further developers and customers are increasingly seeking solutions that are more cost effective customizable maintainable and robust while data sources and customers needs continue to become more complicated. Therefore an improved data extraction approach and an improved data summarization approach are desirable.

Systems and methods in accordance with various embodiments of the present disclosure can overcome these and other deficiencies in existing approaches to extracting and or summarizing data.

In various embodiments a method of summarizing data from a source table includes providing a first and a second summarization process where the first summarization process is programmed to operate on substantially all data existing in the source table during execution of the first summarization process and the second summarization process is programmed to operate on a first subset of data existing in the source table during execution of the second summarization process. An order of execution of the processes is permutable. The method further includes determining a scope of summarization in response to receiving a request to summarize data from the source table where each record of data in the source table includes a summary identifier corresponding to a data event. The scope of summarization includes at least one of a set of the summary identifiers in the source table and an operation to filter the summary identifiers. The method further includes obtaining a lock on data in the source table within the scope of summarization selecting one of the summarization processes to summarize the data based at least in part upon the scope of summarization and extracting the data from the source table within the scope of summarization and summarizing the extracted data using the selected summarization process. The summarization processes utilize separate but corresponding persistent storage approaches such that the summarization processes are able to operate concurrently on the source table without negatively impacting each other.

In some embodiments such a method may further include providing a third summarization process programmed to operate on a second subset of data smaller than the first subset existing in the source table during execution of the third summarization process. The method may further include for the second summarization process setting when appropriate the summary identifier for each record of extracted and summarized data to a predetermined value indicating that the record has been extracted and summarized. The predetermined value may be a null value. The method may further include executing a data maintenance method operable to manipulate data in order to asynchronously improve performance of the summarization processes. The method may further include determining a summarization method based at least in part upon the scope of summarization. The summarization method may be selected from a group including bulk methods incremental methods and online methods. The method may further include inserting a high water mark into the source table indicating which records of data have previously been extracted. The summary identifier for each record may be an integer or a null value and the high water mark may be a next integer value in sequence from a last extracted summary identifier. The method may further include storing information for each data event in an event table. The method may further include deleting an event from the event table when data in the source table that corresponds to the event is summarized. The method may further include marking an event in the event table when data in the source table that corresponds to the event is summarized. The method may further include allowing at least one additional summarization method to obtain a lock on data in the source table within a separate non overlapping scope of extraction.

A further understanding of the nature and the advantages of the inventions disclosed herein may be realized by reference of the remaining portions of the specification and the attached drawings.

Systems and methods in accordance with various embodiments overcome the aforementioned and other deficiencies in existing approaches to data management and or analysis. Embodiments of the present invention allow for bulk incremental and or events based extraction and or summarization of a common data source for example which can allow for switching between different methods to accommodate business performance or other such needs and can provide for the dynamic extraction of different volumes of data among various other advantages. Embodiments also can allow developers to present a scalable extraction and or summarization solution with an efficient configurable extraction mechanism.

A SUMMARY ID thus can be used to identify data for a particular event to determine the extraction history of specific data which should be extracted for a given method determine how the data should be extracted etc. For example a SUMMARY ID for certain data may be set to a value of null after the data has been extracted while a second SUMMARY ID for a different set of data which has not been extracted may be set to a specific positive integer value. The data also may be identified in different manners. In some embodiments the SUMMARY ID may be in a table that actually contains the data to be extracted and in some cases the SUMMARY ID may be in a table that defines a context for the data to be extracted.

Different extraction methods are able to operate in conjunction with one another and can utilize the SUMMARY IDs in different ways. For example a bulk extraction method can be used in which a large volume of data is extracted which can include previously extracted data. An incremental extraction method on the other hand might extract only data created since the last extraction. As discussed above this can be indicated by any non null SUMMARY ID for example. Incremental context thus can be maintained such that any data needing to be summarized is identified by a non null ID. Further a method such as an online extraction method can be used in which data for a specific SUMMARY ID or multiple specific IDs is extracted using an event model as discussed elsewhere herein.

Utilizing SUMMARY IDs in such a way allows the various methods to work on the same source or interact so that each method can be run on the data without causing corruption of the data or problems for the other methods. After a summarization the IDs for the summarized data can be set to null and the IDs can start over or continue from the previous count . The various methods can all run on the same system in one embodiment with rules being defined that allow the methods to interact with each other accordingly.

Additional extraction methods may be implemented in a similar fashion. For instance a re extraction method might extract only data that has previously been extracted as might be indicated by null SUMMARY IDs. Such a method might be useful for example in the case of data corruption of a source or in the case of various bug fixing scenarios. Other extraction methods may also be implemented. Further such additional extraction methods may be implemented in concert with the bulk incremental and or online extraction methods .

Typically factors that may dictate the extraction method used for data extraction include system resources and or business needs. Limited system resources could cause a restriction on the volume of data that can be summarized. Such a restriction could result in the use of an online extraction method or the use of frequent incremental summarization runs. In contrast a business need may require minimal usage of resources at certain times for example when users are on the system and then to summarize all data during off hours. Such a business need would likely cause a need for a bulk summarization extraction method or at least an incremental extraction method and less frequent or periodic incremental summarization runs. Many other business needs exist that would require various configurations of data extraction.

For the various extraction methods to work in conjunction with one another an approach in accordance with one embodiment guarantees that the methods can extract data in their own way without interfering with the other methods. For example the bulk extraction method can guarantee that the method is able to extract data where SUMMARY ID is null and or in a particular set of values the incremental extraction method is able to guarantee that it may extract data where SUMMARY ID is not null and or in a particular set of values the online extraction method is able to guarantee that it may extract data where SUMMARY ID is in a particular set of values and the re extract extraction method is able to guarantee that it can extract data by any of a number of appropriate summarization parameters. A summarization parameter in one embodiment is a parameter submitted to a summarization program either by a call from an OLTP flow a process that populates data that will be extracted and summarized by the summarization program or by a user submitted or user scheduled call to the summarization program. Summarization parameters can also define a particular set of SUMMARY ID values for use by the summarization methods. Additional extraction methods could similarly guarantee the ability to extract data in their own way.

Various embodiments can take advantage of a high water mark. When data is extracted according to any appropriate method a high water mark can be stored which indicates the most recent extraction point in the data source. Subsequently when new data is added to the source this newly added data will be beyond the high water mark. Hence an extraction method may utilize the high water mark to determine what data has been and or has not been previously extracted. Such an approach includes the ability to determine data that has been previously summarized while also indicating which data has been previously extracted for any appropriate purpose. In a situation in which a SUMMARY ID is acquired but the SUMMARY ID s corresponding data was not added to the source before the high water mark was taken and processed various embodiments will ensure that the data is not corrupted.

In determining a high water mark a sequence or autonomous object can be used that returns the next largest integer each time the object is accessed. For example a summarization sequence such as SUMMARY ID S can be used that obtains the maximum possible value for all events that have been submitted as of the time the high water mark is determined. Simply getting the next value in the sequence may accomplish this task. As can be seen then a bulk method can summarize all data up to the high water mark for example see . In the high water mark is designated by the variable n. In this case the next SUMMARY ID would then be n 1 or the next incremental integer.

As another part of the interacting methods where high water marks may be used a determination is made as to whether the scope of summarization or data volume is sufficiently large and if so a high water mark is obtained as discussed above. The SUMMARY IDs can be updated to null in the source for old events and new events less than the high water mark can be marked as having been summarized . The events are not deleted nor the SUMMARY IDs in the source for the new events marked as this is deferred . The incremental method code path is used to summarize the data or the bulk method code path is used if the data volume is sufficiently large . A determination is made as to whether the project data was created before the SUMMARY ID started being populated as well as whether the project has been summarized before . Based on the determination either the data is extracted for SUMMARY IDs that are not null and are less than the high water mark or for data where the SUMMARY ID is null as well as less than the high water mark . In one embodiment the new events may be used to identify SUMMARY IDs to extract so that the update of the SUMMARY IDs corresponding to the old events does not need to take place and can continue to be deferred.

Events can be logged by the source system using the above APIs and may be assigned priority. Events may be combined and be processed together. The priority may affect when and by which extraction method an event may be processed as well as whether the event may be combined with other events or runs of the summarization program. Any efficient queuing system known in the art may fill this role.

In order to preserve the incremental context in the source system the SUMMARY ID may be updated to null. However the SUMMARY ID in the source system may be updated when appropriate such as immediately at a deferred time or some point in the future so that summarization runs do not need to wait for its completion. The caller of the summarization program whether a user or a user defined schedule will not need to wait as long for the process to finish since the update is deferred. The events may be marked as they are summarized and the deletion of these events may also be deferred to reduce the wait time for the user.

This update of SUMMARY ID and deletion of summarized events may be performed by a user submitted or user scheduled data maintenance program which among other tasks may perform these updates and deletions. This data maintenance program may also make available the data maintenance APIs. As indicated herein the data maintenance program and the extraction methods are designed in such a way that they may be out of synchronization and will still not interfere with the integrity of the extraction methods.

Since the data extraction methods work in conjunction with one another the implementer of the summarization program is free to configure the extraction methods to suit individual business needs. Configurability can be controlled in the flows that spawn the summarization process. A user may choose which flows should spawn the online extraction method of summarization. Since the bulk and incremental flows are user or schedule submitted full configurability between the extraction methods is possible.

Various embodiments also allow bulk and multiple incremental summarization methods to run in parallel and allow for switching between the different methods of summarization to accommodate different volumes of data. Embodiments also can allow for an ordering of data in persistent tables to minimize fragmentation as well as periodic re ordering the additional time for which is not seen by the end user. Embodiments also can allow unique bulk and incremental performance tuning techniques to be applied to all parts of the summarization methods and allow for portions of the summarization flow to be deferred such that the wait time for the end user is reduced. Embodiments also can allow a developer to present a scalable solution with a versatile summarization mechanism.

The different summarization methods may include for example a bulk summarization method in which a sufficiently large volume of the data is summarized an incremental summarization method in which a sufficiently small volume of the data is summarized an online method in which a sufficiently smaller volume of the data is summarized and a data maintenance method in which a process out of synchronization with the end user helps improve performance of the other methods. A bulk summarization method may be designed to maximize the use of system resources in order to tune the performance of the summarization process to handle large volumes of data. Similarly an incremental method may be designed to minimize the use of system resources. Since the incremental method can seek to minimize the use of system resources many different instances of the incremental method may run in parallel. Furthermore an online method may be designed to use session specific tables such that as many sessions as resources allow may run in parallel. By formally separating the bulk incremental and online methods in a meaningful way the architecture can provide for additional critical benefits such as data maintenance and reduced downtime. The formal separation of the bulk incremental and online methods may also remove the need for ad hoc code path splitting for bulk incremental and online data volumes. Any work that needs to be performed but for which the end user does not need to wait may be performed by the data maintenance method of the summarization program when appropriate such as immediately at a deferred time or some point in the future.

By formally separating the high volume flow the low volume flow and the lower volume flow portions for bulk incremental and online methods respectively the summarization methods are free to take advantage of various performance tuning techniques and architectures. Bulk operations may be performed on bulk tables multiple parallel incremental operations may be performed on incremental tables and as many parallel online operations as resources allow may be performed on session specific tables.

Similar to extraction methods business needs and system resources dictate the method s used for summarization. Limited system resources could cause a restriction on the volume of data that may be summarized which would result in the use of frequent incremental summarization runs. In contrast a business need may require minimal usage of resources at certain times for example when users are on the system and then to summarize all data during off hours which would cause a need for a bulk summarization approach and periodic incremental summarization runs. Many other business needs exist that would require various configurations of summarization.

For the different summarization methods to work together the methods in one embodiment are able to guarantee that the methods can summarize data in their own way without interfering with the other methods of summarization. For example the bulk method is able to guarantee that no other summarization programs using the bulk method are running and that locking persistent tables in order to append data does not cause any other summarization method to fail. An incremental method or an online method is able to guarantee that operations that lock entire persistent tables do not cause any operations or methods to fail. A data maintenance method besides the end user controlled notion of being run or scheduled at specific times in order to minimize the affects on other end users is able to guarantee that locking persistent tables in order to append data does not cause any other summarization method to fail. Additional methods of summarization could similarly guarantee that they could summarize data in their own way.

If it was determined that the data is not being appended to persistent bulk tables a decision is made as to whether the data is being appended to persistent incremental tables . If so the data from the corresponding persistent bulk table is appended into the persistent incremental table with the data being ordered by its appropriate index while selecting for the append . If the currently running process will not continue after the persistent incremental tables are populated then the corresponding persistent bulk tables are truncated . If data is not being appended to either then if the method is not selecting from persistent tables then data from sets of intermediate bulk tables are moved to sets of intermediate bulk tables using data transformations required by business needs until the data is ready to be in a persistent table . If the method is instead selecting from persistent tables then if the currently running process did not populate the persistent bulk tables data corresponding to the scope of summarization is copied from the persistent incremental tables to a set of intermediate bulk tables using a data transformation required by business needs . If the current process populated the persistent bulk tables data from the persistent bulk tables is moved to a set of intermediate bulk tables using a data transformation required by business needs and the persistent bulk tables are truncated .

Due to the complexity of a summarization implementation it may become necessary to truncate all summarization data and to start from scratch. In this case end users may be subjected to a protracted downtime. However because of the architecture described herein the bulk summarization process may be run without immediately affecting data in the incremental fact thereby bringing the system downtime close to the time it takes to truncate the persistent incremental tables and reinsert the data from the corresponding persistent bulk tables.

In most embodiments the system includes some type of network . The network may can be any type of network familiar to those skilled in the art that can support data communications using any of a variety of commercially available protocols including without limitation TCP IP SNA IPX AppleTalk and the like. Merely by way of example the network can be a local area network LAN such as an Ethernet network a Token Ring network and or the like a wide area network a virtual network including without limitation a virtual private network VPN the Internet an intranet an extranet a public switched telephone network PSTN an infra red network a wireless network e.g. a network operating under any of the IEEE 802.11 suite of protocols GRPS GSM UMTS EDGE 2G 2.5G 3G 4G Wimax WiFi CDMA 2000 WCDMA the Bluetooth protocol known in the art and or any other wireless protocol and or any combination of these and or other networks.

The system may also include one or more server computers which can be general purpose computers specialized server computers including merely by way of example PC servers UNIX servers mid range servers mainframe computers rack mounted servers etc. server farms server clusters or any other appropriate arrangement and or combination. One or more of the servers e.g. may be dedicated to running applications such as a business application a Web server application server etc. Such servers may be used to process requests from user computers . The applications can also include any number of applications for controlling access to resources of the servers .

The Web server can be running an operating system including any of those discussed above as well as any commercially available server operating systems. The Web server can also run any of a variety of server applications and or mid tier applications including HTTP servers FTP servers CGI servers database servers Java servers business applications and the like. The server s also may be one or more computers which can be capable of executing programs or scripts in response to the user computers . As one example a server may execute one or more Web applications. The Web application may be implemented as one or more scripts or programs written in any programming language such as Java C C or C and or any scripting language such as Perl Python or TCL as well as combinations of any programming scripting languages. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase IBM and the like which can process requests from database clients running on a user computer .

The system may also include one or more databases . The database s may reside in a variety of locations. By way of example a database may reside on a storage medium local to and or resident in one or more of the computers . Alternatively it may be remote from any or all of the computers and or in communication e.g. via the network with one or more of these. In a particular set of embodiments the database may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers may be stored locally on the respective computer and or remotely as appropriate. In one set of embodiments the database may be a relational database such as Oracle 10g that is adapted to store update and retrieve data in response to SQL formatted commands.

The computer system may additionally include a computer readable storage media reader a communications system e.g. a modem a network card wireless or wired an infra red communication device etc. and working memory which may include RAM and ROM devices as described above. In some embodiments the computer system may also include a processing acceleration unit which can include a digital signal processor DSP a special purpose processor and or the like.

The computer readable storage media reader can further be connected to a computer readable storage medium together and optionally in combination with storage device s comprehensively representing remote local fixed and or removable storage devices plus storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The communications system may permit data to be exchanged with the network and or any other computer described above with respect to the system .

The computer system may also comprise software elements shown as being currently located within a working memory including an operating system and or other code such as an application program which may be a client application Web browser mid tier application RDBMS etc. . It should be appreciated that alternate embodiments of a computer system may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices data signals data transmissions or any other medium which can be used to store or transmit the desired information and which can be accessed by the computer. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

