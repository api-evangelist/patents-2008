---

title: System and method for transmitting data from a server application to more than one client node
abstract: A system and method for transmitting the same data to more than one client node or from an application to at least two client nodes. The method includes connecting a first client node and a first client protocol stack and connecting the application and the first client protocol stack; associating a first minimal communications protocol stack with the first client protocol stack; providing a connection between the application and the first minimal communications protocol stack and between a second client node and a second client protocol stack; associating a second minimal communications protocol stack with the second client protocol stack; providing a connection between the first minimal protocol stack and the second minimal protocol stack; and between the second minimal protocol stack and said the client protocol stack. Data is then transmitted from the application program to the first client protocol stack and the first minimal protocol stack substantially simultaneously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08296446&OS=08296446&RS=08296446
owner: Citrix Systems, Inc.
number: 08296446
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20081218
---
The present invention relates generally to a system and method for communicating between a server application and multiple client nodes and more specifically to a system and method for transmitting the same data to more than one client node substantially simultaneously.

Shadowing transmitting data destined for one client node substantially simultaneously to a second client node and broadcasting transmitting the same data substantially simultaneously to more than one client node typically has been performed using a specialized transmitting application on a server node and specialized receiver applications on each of the client nodes. Shadowing is useful in monitoring data traffic and for creating a redundant copy of information being transmitted for data integrity and system security purposes. Broadcasting is useful in providing the same information to many users when such information is real time or when the information does not have a per se beginning or ending. For example a stock price quotation program simply transmits the current prices of various stocks on a given exchange and the list repeats with the latest prices once the list of stocks is exhausted. Thus it is irrelevant to a user that he or she does not specify to the quotation program where to begin the list.

Such programs typically are written with a broadcast program in mind and require specialized receiver programs to receive the data transmitted. If an application has not been written as a broadcast program the data transmitted by such an application can not typically be broadcast to multiple client nodes.

The present invention attempts to overcome this problem by permitting programs not written for broadcast functionality to be used to broadcast data over a network.

The invention relates to a system and method for transmitting the same data to more than one client node substantially simultaneously. In one embodiment the invention relates to a method for transmitting the same data substantially simultaneously from an application executing on a server node to at least two client nodes executing a generalized receiver program. The method includes the steps of establishing a connection between a first client node and a first client protocol stack on the server node establishing a connection between the application executing on the server node and the first client protocol stack associating a first minimal communications protocol stack with the first client protocol stack establishing a connection between the application executing on the server node and the first minimal communications protocol stack establishing a connection between a second client node and a second client protocol stack on the server node associating a second minimal communications protocol stack with the second client protocol stack providing a connection between the first minimal protocol stack and the second minimal protocol stack providing a connection between the second minimal protocol stack and said the second client protocol stack and transmitting data from the application program to the first client protocol stack and the first minimal protocol stack substantially simultaneously.

The invention also relates to a communication system including a server and two or more client nodes. In one embodiment the server node comprises an application program a first client protocol stack in electrical communication with the application program a first minimal protocol stack in electrical communication with the application program a second minimal protocol stack in electrical communication with the first minimal protocol stack and a second client protocol stack in electrical communication with the second minimal protocol stack. In addition the system includes a first client node in electrical communication with the first client protocol stack and a second client node in electrical communication with the second client protocol stack. Data from the application program is transmitted to the client protocol stack and the first minimal protocol stack substantially simultaneously.

Referring now to in brief overview a typical network includes at least one client node at least one server node and a master network information node connected together by a communications link . The embodiment shown in depicts the communications link as a local area network ring or LAN ring but any communication topology may be used. For the purpose of explanation the server node is assumed to have the application requested by the client node . Also for the purpose of explanation the master network information node is assumed to be a distinct server node but in actuality the master network information node may be an application execution server node . It should be noted that on a given LAN several nodes may be capable of acting as a network information node but at any one time only one of such nodes is designated the master network information node for the system and it is to this node that client requests for server information are directed.

The master network information node maintains a table of addresses for the application execution server nodes . In addition the master network information node receives messages from each application execution server node indicating its level of activity. The level of activity of the application execution server nodes is maintained in a table along with the address of each of the application execution server nodes and is used by the communications system for load leveling.

When the client wishes to have an application executed on an application execution server node the client node sends a request to the general communications port previously defined by the communications protocol or to the well known communications port on the master network information node . In one embodiment the communication takes place by way of a datagram service. The master network information node accesses the table of server addresses and returns a message containing the address of the application execution server or lo application server which has the requested application and also which has the least load. Subsequent communications are automatically addressed by the client also to a well known or predefined general communications port on the server node . In one embodiment the type of protocol with which the initial query was made to the master network information node determines the protocol of the information returned by the master network information node to the client node . Thus if the request were made using a TCP IP datagram the master network information node would return the TCP IP address of the server to the client node and the client node would subsequently establish contact with the server node using that protocol. In another embodiment the datagram requesting an application address by a client includes a request for a different type of protocol than the one used to send the request to the master network information node . For example the client may make a request to the master network information node using the IPX protocol and request the address of the application server as a TCP IP protocol address.

When a client node actually a client process on a client node desires to communicate with an application on a server node the client node begins by issuing a network request to determine the location of the server having the desired application. This request is received by the master network information node also referred to as a network browser residing somewhere on the network. In this the network browser is shown for simplicity as residing on a different server from the server which has the application but such may generally not be the case.

The master network information node returns the network address of the server node having the desired application to the client node . The client node then uses the information received from the master network information node to request connection to the application executing on the specified server . As is described above such a connection is first established to a well known communications port and is later transferred to a specific communications port under control of a connection manager. The specific communications port is associated with the application executing on the server node which then communicates with the client node through the specific communications port.

In more detail and referring to the client process on client node makes a request to the master network information node to obtain the address of a server node which includes the desired application . The master network information node returns to the client node a message containing the address of the server node which includes the server application . In one embodiment the protocol used at this point of the connection is a datagram service.

The client node uses the returned address to establish a communication channel with the server . The port number used by the client corresponds to the well known port in the server which has been defined by the network protocol as the port by which the server establishes communication connections with clients . The well known port has a rudimentary protocol stack which includes primarily an end point data structure .

The end point data structure points to the communication protocol stack and client connection thereby establishing a unique representation or handle for the client . The end point data structure permits the connection between the server and the client to be moved at will between the connection manager and the various applications on the server . The end point data structure in one embodiment not only contains the handle to the client but may also contain other information relating to the client connection. In the embodiment shown the application server monitors activity on a specific communications system e.g. LAN or WAN and has initialized this minimum protocol stack with only the necessary protocol modules needed to support a TTY communication mode. The TTY communication mode is a simple ASCII stream with no protocol assumptions above the transport layer. That is there are no protocol layers for compression encryption reliability framing or presentation of transmitted data. Thus a client node seeking an application running on the server establishes a connection to the well known communications port with the minimum protocol set needed to support a TTY communication mode.

A connection manager executing on the server node is listening to the well known communications port for a connection request . When a connection request is received from the client node the connection manager is notified . The connection manager knows which protocol is being used based on the notification .

With this information the connection manager creates a new minimum protocol communications stack starts the execution environment and binds the new minimum protocol stack to the execution environment . In one embodiment the server includes a number of execution environments which have been previously been started but which have not been associated with a communications port. In this embodiment the pre connection starting of the execution environments permits a faster response time than if each execution environment is started when the connection request is received from the client . When the execution environment is started the server application requested by the client is also started. In another embodiment if the client does not specify an application either a default application is started or simply the execution environment with no application is started.

The connection manager then moves the client connection including the unique client identifier or handle from the well known port to the new minimum protocol stack . The connection manager using the minimum protocol stack sends a TTY data stream that indicates service is available. Thus this method for detecting a client connection is independent of the port to which the connection is first established. If the client node does not respond within a prescribed time period e.g. 5 seconds to the service available message a resends of the service available message is performed by the server .

If the client receives the message the client sends a TTY string indicating that the service available message was detected. The client waits for the server to respond and if the response is not within a prescribed time interval e.g. 5 seconds the client resends the message. The connection manager then queries the client asking for the client s default communication parameters. This query takes the form of a message which is passed back to the client and which indicates that the client should respond with details regarding what protocols the client would like to use in the connection.

In response the client sends a set of protocol packets each packet of which is used to specify a required or optional protocol module that is being requested from the server . In one embodiment the number of packets in the set is variable with one packet being sent for each protocol requested. In another embodiment the number of packets that is being sent is included in the header of the first packet. In a third embodiment the remaining number of packets being sent is included in the header of each packet and is decremented with each succeeding packet sent. Thus the client may respond to the query by indicating that for example encryption and data compression will be used. In such a case two protocol packets will be sent from the client to the server and in one embodiment the header of the first packet will indicate the number of packets as two.

Once the responses to the query have been received the connection manager builds a protocol stack using protocol drivers which correspond to the protocols requested by the client node . In one embodiment the connection manager places each of the required protocol drivers corresponding to the requested client protocols e.g. an encryption driver if encryption is desired by the client into the protocol stack container and links them together. This dynamic process allows a client node to specify the contents of a protocol stack dynamically without requiring that the server have a prior protocol stack description for a particular client node . Using this method multiple clients may be served by a single server even if the separate clients have vastly differing requirements for the associated communications channel. In the embodiment shown each client is associated with a respective communications protocol stack and . Such dynamically extensible protocol stacks are described in more detail below and in U.S. patent application Ser. No. 08 540 891 filed on Oct. 11 1995 and incorporated herein by reference.

In the embodiment just discussed the container is a user level or kernel level device driver such as an NT device driver. This container driver provides ancillary support for the inner protocol modules or drivers generally which correspond to the protocol requirements of the client node . This ancillary support is in the form of helper routines that for example aid one protocol driver to transfer data to the next driver. Alternatively in another embodiment each protocol driver is a complete user level or kernel level driver in itself.

Referring now to the embodiment depicted in the connection manager includes two main software modules ICASRV.EXE and ICAAPI.DLL . In the embodiment shown ICASRV.EXE is the server side of a client server interface. ICASRV.EXE manages all communications states and is in one embodiment implemented as a WINDOWS NT service. A second part of the connection manager is ICAAPI.DLL . ICAAPI.DLL establishes the connection with the client establishes the protocols to be used and notifies ICASRV.EXE of the completion of the protocol stack. In one embodiment a third module CDMODEM.DLL is linked to ICAAPI.DLL . CDMODEM.DLL is a module which ICAAPI.DLL uses to communicate with modem devices.

The connection methodology described above can be used for a client running a Web browser program. For the purposes of this specification the user running the Web browser program will be referred to as the viewing user. The terms server or server node will be used to refer to machines hosting HTML files or applications that may be executed. For example a viewing user runs a Web browser on a client node and makes file requests via the HTTP protocol to servers. The servers respond by transmitting file data to the client via the HTTP protocol. The Web browser run on the client receives the transmitted data and displays the data as an HTML page to the viewing user.

In brief overview and referring to an HTML file located on a server and constructed in accordance with an embodiment of the invention includes a generic embedded window tag . The generic embedded window tag is any data construct which indicates to a browser displaying the HTML file that a generic embedded window should be displayed at a particular location in the HTML page described by the HTML file . The generic embedded window tag may include additional information such as height of the window width of the window border style of the window background color or pattern in the window which applications may be displayed in the window how often the output display should be updated or any other additional information that is useful to enhance display of the application output.

In each case above the tag indicates that a window having a height of 295 pixels and a width of 436 pixels should be drawn to receive application output. Each tag also specifies that the application should automatically start execution and that the window in which the application output is displayed should be drawn with a border. The ActiveX and Netscape Plugin tags have the remote application parameters specified in the file direct.ica located in the directory ica. The JAVA tag specifies the remote application parameters directly. In the example above the address of the server hosting the application is specified as well as the name of the application to be executed.

The browser application accesses the HTML file by issuing a request to a specific Uniform Resource Locator URL address. The server hosting the HTML file transmits the HTML file data to the browser application which displays text and translates any tags that are included in the HTML file . The browser application displays the HTML file data as an HTML page . If a generic embedded window tag is present in the HTML file such as one of the tags described above the browser draws a blank window in the displayed HTML page .

Execution of the desired application may commence immediately upon display of the HTML page or execution may await some signal e.g. a specified user input which indicates execution of the application should begin. Once execution of the application is commenced the browser application instantiates a parameter handler associated with the application window . The parameter handler instance may be spawned as a child process of the browser application as a peer process of the browser application or as a Dynamically Linked Library DLL associated with the browser application .

The browser application passes any specific parameters associated with the application window that were provided by the generic embedded window tag to the parameter handler instance. Additionally the browser application may pass the handle for the application window to the parameter handler instance or the parameter handler instance may query the browser application to retrieve the handle for the application window . The parameter handler instance also spawns a network executive . The network executive may be spawned as a child process of the parameter handler instance or as a peer process of the parameter handler instance.

The parameter handler instance forwards any specified application window parameters to the network executive . Parameters which are not specified by the parameter handler instance or the embedded generic window tag may be set to default values. The network executive may have certain parameter defaults hard coded or the network executive may access a file which contains parameter defaults.

The network executive creates its own application output window . The network executive creates its application output window as a child of the displayed application window and displays its application output window directly over the parent window drawn by the browser application . Since the application output window drawn by the network executive is a child of the application window drawn by the browser application the application output window inherits various properties of its parent including position information. Accordingly the application output window will follow the application window as the viewing user scrolls the screen of the browser application or performs other actions which vary the position of the application window .

The network executive also establishes a communications channel with the server and invokes execution of the desired application by the server using the connection methodology described above. The network executive which acts as the client in the above description passes any parameters it received from the parameter handler instantiation to the server along with any necessary default values. If a parameter is not passed to the server the server may request the parameter if it is a necessary parameter which has no default value e.g. user id or it may provide a default value for the parameter e.g. execution priority. The server begins execution of the desired application program and directs the output to the network executive . The network executive receives data from the application program and displays the output data in its application output window . Since the application output window is drawn on top of the application window drawn by the browser application the application output data is displayed in the HTML page . As noted above the application output window drawn by the network executive is a child of the application window drawn by the browser application . This allows the application output window to scroll as the HTML page is scrolled.

The application output window also receives input from the viewing user. Raw input data e.g. a mouse click is received into the application output window by the network executive . The network executive forwards the raw input data to the application executing on the server . In this manner the viewing user is able to interact with the application via the HTML page .

Referring now to the viewing user uses a so called browser program to display an HTML page having an application window on the screen of the user s computer . The viewing user may invoke execution of an application program . Typically this is done by the user utilizing a point and click interface i.e. the viewing user uses a mouse to manipulate a cursor that is also displayed on the screen of the viewing user s computer . Once the cursor is over a particular portion of the HTML page the viewing user signals by clicking a button on the mouse . Alternatively the viewing user may also signal by pressing a key on an associated keyboard such as the return key. In other embodiments the viewing user may not use a mouse at all but may instead use a touchpad a trackball a pressure sensitive tablet and pen or some other input mechanism for manipulating the cursor .

In another embodiment the application window or another portion of the HTML page may define a hot zone. When the viewing user moves the cursor into the hot zone execution of the application on the server is started.

Once the viewing user has indicated that execution of the application should commence the browser application instantiates a parameter handler and passes the instantiation parameters associated with the applications window by the generic embedded window tag . The parameter handler instance spawns a network executive and passes to it the parameters of the application window . The network executive determines which application is to be invoked and on what server that application resides. Generally this information is passed to it by the parameter handler instance which gets it from the browser application in the form of the generic embedded window tag but the network executive may need to query a master network information node or other various servers in order to determine which servers if any host the desired application . The network executive then begins execution of the application and displays the output of the application program in the applications window as described in detail above.

The network executive continues to directly display application output in the applications output window until the viewing user indicates that execution of the application should stop e.g. by closing the application window or until the viewing user clicks on a tag indicating that a different HTML page should be displayed. When this occurs execution of the application can be terminated. It is preferred however is to cache the connection. In effect the first parameter handler instance is not immediately terminated. However the application continues executing with a reduced priority level i.e. in background mode because the first parameter handles no longer has focus .

In general it is desirable to accomplish connection caching by providing the parameter handler source code with a globally accessible data structure for registering instances. For example the parameter handler may be provided with a globally accessible linked list data structure data array data table or other data structure. Because the data structure is globally available each instance of the parameter handler is able to read and write the data structure. This allows each instance of the parameter handler to register with every other instance by writing to the data structure to signal its existence.

For embodiments in which no other connection information is stored a predetermined limit on the number of connections that may be cached at any one time can be set. In these embodiments if registration of an instance would result in an excess number of cached connections one of the cached connections is removed i.e. the parameter handler instantiation associated with that connection is notified that it should terminate. Before termination the parameter handler notifies its associated network executive that it should terminate. In turn the network executive closes its session with the server hosting the application program and then terminates.

In embodiments in which other information is stored the additional information may be used to more effectively manage the cached connections. For example if a user has not actively viewed an HTML page in a predetermined number of minutes e.g. ten minutes the parameter handler instantiation is instructed to terminate the session with the hosting server is terminated and the parameter handler instance removes its entry in the registry.

Cached connection information may be managed using any known cache management scheme. Connection entries may be discarded on a first in first out basis i.e. the oldest entry is discarded each time a new entry must be added. Alternatively cached connection information entries may be discarded on a least recently used basis which discards information relating to connections which have been used the least amount by the user. Other cache management techniques such as random replacement may also be used.

If the viewing user returns to a previous HTML page having a cached connection the network executive associated with the HTML page is returned to the foreground i.e. it regains focus and processing of the associated application resumes at a normal priority level. If necessary the network executive re establishes the connection with the application . Although no output data is stored by the network executive for cached connections as soon as a connection is re established for an applications window the connection to the application is re established and the application again writes directly to the applications window .

Referring to it should be noted that any client or in fact all the clients generally attached to server with the application may be another server . In this manner data transmitted by the application is sent to other servers prior to being sent to client nodes . In this manner data transmitted by the application is transmitted to an ever increasing number of client nodes as this network fans out.

When each client terminates its connection with the server each client protocol stack generally and its associated minimal stack generally is destroyed. Similarly the minimal protocol stack generally associated with the first client protocol stack is also destroyed. When the last of the minimal and second and subsequent client protocol stacks has terminated the configuration is as it was initially with only a first client communications protocol stack associated with the execution environment . Note that until all the second and subsequent client protocol stacks are terminated the first client protocol stack may not be destroyed even if the first client is no longer present.

In such a case the first client causes the specialized application to execute and transmit its data to the client as discussed previously. When a second client requests access to the broadcast application the connection manager begins to construct the protocol stack for the second client as previously discussed with regard to the first client . However because the application is a broadcast application the connection manager recognizes that it need not start an additional execution environment and instead takes the steps necessary to send the data from the broadcast application to the second client and any additional clients .

First the connection manager creates a first minimal communications protocol stack which it associates with a communications protocol stack of the first client . The connection manager next creates a second minimal protocol stack and associates it with the communications protocol stack of the second client . As each additional client requests access to the broadcast application another minimal protocol stack is created and associated with the first client protocol stack and another minimal protocol stack and client protocol stack is created for each new client . The first client protocol stack and all the minimal protocol stacks associated with the first client protocol stack and each pair of client protocol stacks and minimal protocol stacks associated with each additional client are in communication by way of a multiplexer .

When multiplexer is directing data to or receiving data from only one client the multiplexer is acting as a simple pass through device. However when there is more than one client receiving data from or transmitting data to a single application each multiplexer generally takes on two additional configurations. In one configuration the multiplexer is configured to send application data to or receive data from both the first client protocol stack and each of the minimal communications protocol stacks associated with it. In the second configuration the multiplexer is configured to send data received by the minimal protocol stack to the client protocol stack respectively associated with it. In this embodiment the mux may receive input data directly from each client protocol stack .

The connection manager connects the minimal protocol stacks associated with the first client with the minimal protocol stacks respectively of the second and subsequent clients and instructs the multiplexer to direct output from the application to the communications protocol stack of the first client and its associated minimal protocol stacks . The multiplexer is also instructed by the connection manager to connect each second and subsequent client minimal protocol stack to its associated client protocol stack respectively. Data transmitted to the first client by way of the first client protocol stack is therefore also transmitted to the minimal protocol stacks associated with the first client and hence to the second and subsequent clients by way of their associated protocol stacks respectively and associated minimal protocol stacks respectively. In one embodiment the protocol stack container includes a data structure to keep track of the number and type of protocols associated with a given application .

Referring to as discussed above it is possible that the clients of one server be other servers and only two being shown for simplicity . The second servers and then transmit the data to clients generally or to additional servers. In this embodiment the output of the server protocol stack generally is connected to the protocol stacks of the secondary servers . Then as described previously the data is transmitted between the protocol stacks and out to the clients generally . In this manner the data may fan out and be distributed to many more clients than may reasonably be supported by one server.

While the invention has been particularly shown and described with reference to specific preferred embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein departing from the spirit and scope of the invention as defined by the appended claims.

