---

title: System and method for proactive computer virus protection
abstract: A system, method, and computer readable medium for the proactive detection of malware in operating systems that receive application programming interface (API) calls is provided. A virtual operating environment for simulating the execution of programs and determining if the programs are malware is created. The virtual operating environment confines potential malware so that the systems of the host operating environment will not be adversely effected. During simulation, a behavior signature is generated based on the API calls issued by potential malware. The behavior signature is suitable for analysis to determine whether the simulated executable is malware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07877802&OS=07877802&RS=07877802
owner: Microsoft Corporation
number: 07877802
owner_city: Redmond
owner_country: US
publication_date: 20080124
---
The present invention relates to computing devices and more particularly to virus protection of computing devices.

As more and more computing devices such as personal computers personal digital assistants cellular telephones etc. are interconnected through various networks such as the Internet computing device security has become increasingly more important. In particular security against computing device external attacks from malware has become increasingly more important. Malware for purposes of the present discussion is defined as a software source of an unwanted computer attack. As such those skilled in the art will appreciate that malware includes but is not limited to computer viruses Trojan horses worms denial of service attacks abuse misuse of legitimate computer system functions and the like. The primary defense against malware is anti virus software.

Anti virus software scans computing device data looking for malware. The computing device data may be incoming data or data stored in the computing device or a hard drive for example. Previously developed anti virus software scans the data for identifiable patterns associated with known malware. Thus unfortunately current anti virus software identifies only known malware. New unknown malware is not detected by current anti virus software. Consequently current anti virus software is considered to be reactionary operating on malware after it has been released and identified.

The typical manner in which current anti virus software operates to protect computing devices from new malware is as follows. First unknown malware is usually released via network messages infecting unprotected computing devices. Infected computing devices include computers that have anti virus software but not up to date anti virus software because the malware is unknown. Upon detecting that unknown malware has been released an anti virus software provider examines analyzes the unknown malware in order to identify at least one recognizable pattern by which the malware can be detected in transit. Once a pattern is identified the anti virus software provider creates and publishes an update for its anti virus software. This update uses the identified pattern to enable anti virus software installations to recognize the now identified malware as it arrives. However this update only protects a computing device after the computing device has received and installed the updated anti virus software. Unfortunately the period of time that it takes to update a particular computing device may range anywhere from a matter of minutes to several days depending on individual circumstances.

As already mentioned the current anti virus software protection paradigm is a reactionary system i.e. the anti virus software is updated to protect a computer from malware only after the malware is released. Unfortunately this means that at least some computers will be infected before anti virus software is updated. Furthermore the anti virus update cycle is an extremely costly process for anti virus providers and ultimately for the consumers that purchase anti virus software.

A substantial portion if not almost all unknown malware that exploits computer vulnerabilities are rewrites of previously released malware. Indeed encountering absolutely novel malware is relatively rare. However due to the pattern matching system employed by current anti virus systems it is not difficult to rehash rewrite known malware such that the malware will get past the protection provided by anti virus software. For example malware code is readily accessible and it is a simple task to change variable names reorder lines of code or slightly modify the behavior of the malware such that the rewritten malware will not be recognized by anti virus software. In order to provide an update anti virus software providers must locate an identifying pattern in the rewritten malware and create an update for the anti virus software even though the malware has previously been dealt with.

Certain malware specifically targets operating systems that make Application Programming Interface API calls such as the Microsoft 32 bit operating systems hereinafter Win 32 operating systems . APIs form a layer of software that defines a set of services offered by an operating system to an executable. An executable written for Win 32 APIs for example will run on all Win 32 operating systems. These systems are often targets of malware designers because their popularity offers a better opportunity for widespread dissemination of malware. For example macro viruses specifically target Win 32 operating systems by embedding themselves in files created with applications that support macro languages. Applications that support macro languages available to run on the Win 32 operating systems include Microsoft Word and Microsoft Excel .

In light of the above identified problems it would be beneficial to computer users both in terms of computer security and in terms of cost effectiveness to have anti virus software that proactively protects a computer against rewritten or reorganized malware designed for operating systems that make API calls. The present invention is directed to providing such software.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In accordance with this invention a system method and computer readable medium for simulating the execution of potentially malicious software hereinafter malware in an operating system that receives API calls such as the Microsoft 32 bit operating systems hereinafter Win 32 operating systems is provided. In accordance with the invention a virtual operating environment for simulating the execution of programs to determine if the programs are malware is created. The virtual operating environment confines potential malware so that the systems of the host operating environment will not be adversely effected during simulation. As a program is being simulated a set of behavior signatures is generated. The collected behavior signatures are suitable for analysis to determine if the program is malware.

In accordance with one aspect of the present invention a method that simulates a sequence of API calls made in an executable is provided. Potential malware i.e. an executable is received and interesting API calls are parsed from the executable s machine code. These interesting API calls are those that have been previously identified as potentially indicative of malware. Then the parsed API calls are executed in the virtual operating environment of the present invention using stub Dynamically Linked Libraries hereinafter stub DLLs . During execution the stub DLLs generate a behavior signature for each of the API calls that is stored for analysis by virus scanning software.

In accordance with another aspect of the present invention a virtual operating environment that simulates the components of an operating system that receives API calls is provided. Components of the virtual operating environment include an interface a virtual processing unit API handling routines an Input Output emulator a loader a stack data structure and a memory management unit that manages a virtual address space. These components perform operations similar to a real operating system that receives API calls including but not limited to 1 generating events so that stub DLLs may be loaded into memory 2 employing a memory management unit to map physical locations in memory to a virtual address space and 3 allowing potential malware to generate Input Output hereinafter I O when making API calls. The present invention generates computer executable instructions that are only capable of being filtered by the provided virtual operating environment.

In accordance with other aspects of the present invention a plurality of stub DLLs that mirror a set of full operating system DLLs is provided. DLLs provided by an operating system are collections of compiled machine code i.e. executables composed of API handling routines that perform behaviors requested by a calling executable. The stub DLLs have the same interface as the fully implemented DLLs that they mirror. However the stub DLLs execute API calls only using components of a virtual operating environment and do not directly access the host operating environment. Put differently the stub DLLs are designed to operate with the minimalist components available in the virtual operating environment. These components of the virtual operating environment and the stub DLLs that are executed in that environment are optimized with the minimal set of instructions needed to simulate potential malware.

While illustrative embodiments have been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

The present invention is generally directed to a system and method for the proactive detection of malware in computing devices that include an operating system that makes Application Programming Interface API calls. More specifically the present invention provides a system and method for simulating a program that may be malware in a virtual operating environment. During such simulation a behavior signature is generated based on the API calls issued by potential malware. The behavior signature is suitable for analysis to determine whether the simulated executable is malware.

Although the present invention will be described in the context of a particular operating system namely the Win 32 operating systems those skilled in the relevant art and others will appreciate that the present invention is also applicable to other operating systems that make API calls. Accordingly the described embodiments of the present invention should be construed as illustrative in nature and not as limiting.

The computing device illustrated in includes a hardware platform a host operating system a virtual operating environment and an executable i.e. a program representative of potential malware. As signified by the dashed line hardware platform and host operating system collectively form a host operating environment . For ease of illustration and because they are not important to an understanding of the present invention does not show the components of hardware platform such as a central processing unit memory hard drive etc. Also for similar reasons does not show any components of host operating system the virtual operating environment or executable .

As shown in the components of computing device are layered with the hardware platform on the bottom layer and executable on the top layer. The layering of illustrates that preferably the present invention is embodied in a hierarchical environment. Each layer of computing device is dependent on systems in lower layers. More specifically executable runs on top of virtual operating environment which forms part of the present invention and is not able to directly access components of the host operating environment .

As will be better understood from the following description embodiments of the present invention provide a set of software implemented resources in the virtual operating environment for use in executing selected executables of potential malware herein sometimes referred to as simulating potential malware. As illustrated in components of the virtual operating environment include an interface virtual processing unit API handling routines an Input Output emulator a loader a stack data structure and a memory management unit that manages a virtual address space . As also illustrated in the components of virtual operating environment are interconnected and able to communicate with other components using software engineering techniques generally known in the art. Component functions and the methods of simulating potential malware in virtual operating environment will be described in detail with reference to and .

In some operating systems such as the Win 32 operating system compiled code that handle API calls are linked to the calling executable by DLLs. If an API call is made the corresponding DLL is loaded from a storage device i.e. a hard drive into either an address space used solely by the calling executable or a shared address space. The address space available to an executable is the actual memory store used when the executable is running. The address space may be mapped to a volatile memory location i.e. a random access memory location or a storage device location i.e. a virtual memory location or a combination of both. Typically an operating system initializes the executable s address space just prior to execution. Then the operating system s loader copies required data from a storage media into the initialized address space.

In executable contains three API calls API CALL A API CALL B and API CALL C . API CALL A requires executable code in a DLL identified as KERNEL.DLL that must be linked to executable for API CALL A to be satisfied. Similarly API CALLS B and C reference executable code identified as MSNET32.DLL and OLETHK32.DLL respectively. Both MSNET32.DLL and OLETHK32.DLL must be linked to executable for API CALLS B and C to be satisfied. KERNEL.DLL MSNET32.DLL and OLETHK32.DLL are stored on a storage media along with other DLLs such as TAPI32.DLL which does not satisfy any API calls. When executable is selected for execution and an event is generated the operating system initializes an executable s address space and assigns the address space to a series of memory locations four of which and are shown in . An event is defined as a mechanism that transfers control of the hardware platform to the operating system so that the operating system may provide a service i.e. initializing an executable s address space.

In the executable shown in is selected for execution in the virtual operating environment . As described above with reference to the executable contains API CALL A API CALL B and API CALL C . In the virtual operating environment API CALL A is satisfied by executable code in a stub DLL identified as KERNEL.STUBDLL . Similarly API CALL B and API CALL C are satisfied by stub DLLs identified as executable code in MSNET32.STUBDLL and OLETHK32.STUBDLL respectively. All of the stub DLLs need to be linked to the executable . The stub DLLs i.e. the KERNEL.STUBDLL MSNET32.STUBDLL and OLETHK32.STUBDLL are stored in the storage media along with other stub DLLs like TAPI32.STUBDLL . When executable is selected for execution an event is generated the virtual operating environment initializes the virtual address space and assigns a suitable number of memory locations four of which and are shown in .

Stub DLLs are collections of executable code that have the same interface as fully implemented DLLs but only simulate API calls using components of the virtual operating environment . In many operating systems such as the Win 32 operating system fully implemented DLLs may issue millions of instructions to a central processing unit when handling individual API calls. Conversely the stub DLLs employed in embodiments of the present invention are highly abbreviated when compared to the DLLs that they mirror. As a result simulating a set of API calls in accordance with the present invention is faster than executing the same API calls with fully implemented DLLs. Also the virtual operating environment of the present invention does not simulate all API calls supported in the related operating systems. API calls that are not indicative of malware and as a result are not considered interesting by the present invention are not simulated.

At block the executable passed to the virtual operating environment is obtained and its API calls including calling parameters are identified and stored in a list. The APIs define parameters of data that are required from an executable when an API call is made. Since parameters passed to the APIs may be indicative of malware API calls with their calling parameters are stored in the list.

At block API calls that may be indicative of malware are identified. As described above the present invention does not simulate all APIs supported by operating systems. The present invention identifies interesting API calls that may be indicative of malware. API handling routines corresponding to the interesting API calls are included in the virtual operating environment . On the other hand the virtual operating environment does not include API handling routines that do not correspond to interesting API calls. Uninteresting API calls are not simulated in the virtual operating environment . APIs that are interesting are determined by comparing a list of API handling routines with the list of API calls identified at block . Those skilled in the art and others will recognize that identifying API calls indicative of malware i.e. interesting API calls may be implemented using different methods and that the embodiment described herein should be construed as exemplary and not limiting.

At block an output store is created to store a behavior signature for each API call executed in the virtual operating environment . During execution the behavior signatures are stored by the related stub DLL. When simulation is complete the output store is available for analysis by the anti virus software that instantiated the virtual operating environment .

At block an API call that is interesting is selected for execution in the virtual operating environment . Since dependencies between API calls frequently exist selection of API calls happens in the same order as they occur in the selected executable.

At block the selected API call is placed in a stack data structure which serves as an area of storage in the virtual operating environment . Those skilled in the art and others will recognize that an API call and its calling parameters may be stored in any one of many data structures known in the art and that the use of a stack data structure should be construed as exemplary and not limiting.

At decision block a test is conducted to determine whether the selected API call requires a stub DLL for execution. As described above dependencies exist between API calls that require simulation of expected behavior. For example some APIs support operations on files i.e. conducting I O with a storage media . Creating a file and conducting I O with the same file requires a series of API calls an example being 1 a first API call to create the file and receive a file identifier 2 a second API call to write to the file by using the file identifier 3 a third API call to read previously written data from the file using the file identifier and 4 a fourth API call to write the data to the master boot record of the operating system using the file identifier of the master boot record. Obviously the effects of the second third and fourth API calls are not capable of being executed without a legitimate file identifier being returned from the first API call. Also the effects of the fourth API call are dependent on the data being written and read by the second and third API calls. In this example the data written to the master boot record in the fourth API call is not known unless all I O with the newly created file is accurately simulated. The API handling routines of the virtual operating environment determine whether the selected API call requires a stub DLL for simulated execution. Typically stub DLLs are necessary when an API call will generate dependencies or require the input output emulator for storage of data.

If the selected API call does not require a stub DLL at block an API handling routine performs any expected behavior so that subsequent API calls can be executed. For example audio may be played on a computing device using APIs. Typically an API call that generates audio expects a non zero return value that indicates the API call was successful. On the other hand the return of a zero value indicates that an error occurred and stops execution. A stub DLL is not necessary for APIs calls that play audio because subsequent API calls will not depend on this behavior. However continued simulation of the potential malware does depend on a non zero value being returned to the calling executable. Therefore an API handling routine returns a non zero value to the calling executable which allows additional API calls to execute. Then the routine proceeds to decision block which is described below.

If an API call requires a stub DLL for simulation at block the stack data structure is queried for the reference information of the selected API. The reference information obtained from the stack data structure permits identification of the correct stub DLL to load into the virtual address space .

As illustrated in at block an event is generated initiating the process of loading a stub DLL into the virtual address space . In some operating systems such as the Win 32 operating systems interactions between executables and computer hardware are coordinated by the operating system. For example when an executable issues an API call requiring input an event is generated and control of the hardware platform is transferred to the operating system. The operating system obtains data from the hardware platform and makes it available to the calling executable. and the accompanying text describe one example of when an operating system coordinates I O after an event is generated with the loading of DLLs from a storage media i.e. input into an executable s address space . Similarly the present invention generates an event when a stub DLL needs to be loaded to a location in memory available to the virtual operating environment i.e. the virtual address space . and the accompanying text describe the process of loading a stub DLL from a storage media into the virtual address space after an event is generated.

At decision block depicted in a test is conducted to determine whether the stub DLL that will simulate the selected API call is already loaded in the virtual address space . Since the virtual operating environment simulates a sequence of API calls the correct stub DLL may already be loaded into virtual address space . Stub DLLs that are already loaded in the virtual address space are not loaded again.

If the stub DLL is already loaded in the virtual address space the routine proceeds to block . If the stub DLL is not already loaded in the virtual address space the routine proceeds to block where the stub DLL is loaded into the virtual address space . and the accompanying text describe the process of loading stub DLLs from storage media into the virtual address space .

At block the selected API call is executed using the stub DLL previously loaded into the virtual address space . Execution of an API call using a stub DLL involves methods known in the art of generating machine instructions that are handled by a virtual processing unit . The virtual processing unit accepts machine instruction and simulates the API call using the components of the virtual operating environment .

During execution at block the stub DLL generates a behavior signature for the API call that is written to the output store created at block . Each behavior signature includes three elements a behavior token a first parameter value and a second parameter value. It should be understood that the described behavior signatures are for illustration purposes only and should be construed as exemplary and not limiting. The actual nature and organization of a behavior signature may vary substantially from the three elements described herein.

The behavior token is used to identify the particular behavior represented by the selected API call. The parameter values may include almost any type of value. For example a parameter value may be a numeric value or may be a string that is passed to an API call. Alternatively a parameter value may not be necessary or desirable. In such cases a parameter value of null may be included to indicate that there is no parameter present.

Returning to at decision block a test is conducted to determine whether there are additional API calls that are potentially indicative of malware. As described above API calls identified for execution are stored in a list. Contents of the list are sequentially traversed until all API calls have been executed in the virtual operating environment . If all API calls have been executed at block the output store is closed and at block the routine terminates. If some API calls have not been executed the routine cycles back to block and blocks through are repeated until all required API calls have been executed.

As illustrated in the virtual operating environment of the present invention includes an interface virtual processing unit API handling routines an input output emulator a loader a stack data structure and a memory management unit that manages a virtual address space . With reference to the virtual operating environment also obtains input and produces output when simulating an operating system in accordance with the present invention. As described above input into the virtual operating environment is an executable representative of potential malware. Also to facilitate simulation a set of stub DLLs like KERNEL.STUBDLL MSNET32.STUBDLL and OLETHK32.STUBDLL of are obtained and loaded into the virtual address space . During simulation an output store is generated that contains an entry for each API call in executable that was executed.

The interface of the virtual operating environment allows virus scanning software to instantiate the virtual operating environment and pass executables such as executable to the virtual operating environment for execution. When executable is passed to the interface the executable s API calls are parsed and stored in a list. As described below the interface identifies API calls in the executable that are interesting i.e. identifies API calls that may be indicative of malware. As described above with reference to block identification of API calls that are interesting is implemented by comparing the list of API calls identified in executable with the list of API handling routines .

The virtual processing unit accepts machine instructions and simulates API calls using components of the virtual operating environment . Since a virtual processing unit that accepts machine instructions is generally known in the art further description of the virtual processing unit is not provided herein.

The API handling routines determine how the execution of each API call will be simulated in virtual operating environment . One method of simulation uses a stub DLL to execute an API call. If a stub DLL is required an API handling routine stores the reference information of an API call on the stack data structure and issues an event. As described above with reference to block an event transfers control of the hardware platform to the host operating system so the corresponding stub DLL may be loaded into the virtual address space . Then the reference information of the API call is obtained from the stack data structure and the corresponding stub DLL is loaded into the virtual address space . and the accompanying text describe the process of loading stub DLLs into the virtual address space after an event is generated. In another method of simulation where a stub DLL is not required the API handling routine performs any expected behavior necessary for execution to continue i.e. returns a non zero value to an audio based API call.

The input output emulator is responsible for simulating components of computing device that perform I O. Executable may issue API calls that write data to an output device or expect data from an input device. As described with reference to at block dependencies exist between API calls that require simulation of expected behavior. With the input output emulator API calls that generate I O have a designated location in memory where data may be stored and recalled.

The memory management unit handles the memory requirements of the virtual operating environment . All data used in the virtual operating environment including stub DLLs and executables are stored in memory. The memory management unit maps data from memory to the virtual address space . During simulation references to the virtual address space are translated by the memory management unit using methods known in the art.

While the presently preferred embodiment of the invention has been illustrated and described it will be readily appreciated by those skilled in the art and others that within the scope of the appended claims various changes can be made therein without departing from the spirit and scope of the invention.

