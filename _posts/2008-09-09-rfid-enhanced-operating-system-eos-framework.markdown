---

title: RFID enhanced operating system (EOS) framework
abstract: A radio frequency identification (“RFID”) reader includes a hardware platform having a transceiver, an input/output interface, a controller, and a memory. The transceiver receives communication signals from at least one RFID tag. The controller is communicatively coupled to the transceiver and the input/output interface and controls the operation of the RFID reader. The memory is communicatively coupled to the controller and contains a software development framework for developing a software application. The framework includes a plurality of predefined encapsulated functional components that interact with at least one of the transceiver and the input/output interface, to allow the software application to operate in a manner that is independent of a specific embodiment of the RFID reader hardware platform.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266577&OS=08266577&RS=08266577
owner: Sensormatic Electronics, LLC
number: 08266577
owner_city: Boca Raton
owner_country: US
publication_date: 20080909
---
The present invention relates generally to a method and system for developing software applications and more specifically for a method and system for developing software applications executed on a radio frequency identification RFID reader.

Radio frequency identification RFID systems provide a method for automatic identification that uses devices called RFID tags to remotely store and retrieve data. An RFID tag may be attached to or incorporated into a product and identifies the product through radio frequency RF waves. Most RFID tags contain an integrated circuit IC and an antenna. The IC stores and processes information and modulates and demodulates an RF signal. The antenna receives and transmits the RF signal. RFID readers communicate with the IC of the RFID tag to relay information between the tag and the reader concerning the product. Today there is a widespread use of RFID systems in enterprise supply chain management for improving the efficiency of inventory tracking and management.

RFID readers generally report all tag data that is read. Duplicate tag reads and redundant data are reported without filtering. Third party middleware software receiving the tag data typically provides a layer of filtering so that the data set reported to the customer is a meaningful representation of the number of tagged cartons or individual tagged products that have passed through an antenna field.

A software solution that provides advanced capabilities for processing and reporting tag data based on customizable tag events and resides on the RFID reader is very desirable for customers. This allows a customer to have control over the type and amount of data received from the RFID reader and use the data in any number of custom applications. One prior solution provided an interface between the RFID reader and the user. However in this product all features were hard coded into the application rendering development of new applications slow and inflexible. Adding features required modifying and recompiling the existing application code. Third party users often needed to customize a comprehensive configuration file typically very specific to their particular site enabling and disabling features that were configurable.

The difficulty presented in creating a software solution for multiple RFID readers and reporting tag data to various middleware packages has highlighted the need for a faster development environment. Consideration of the need for customizable feature sets and ongoing enhancements to support additional readers and middleware packages has underlined the need for the creation of a predefined development framework to serve as a basis from which applications may be rapidly developed.

Therefore what is needed is a system and method for rapidly developing software applications that reside on an RFID reader using a predefined development framework.

The present invention advantageously provides a method system and radio frequency identification RFID reader for rapidly developing software applications that reside on an RFID reader using a predefined development framework. The development framework allows the software application to operate in a manner that is independent of a specific embodiment of the RFID reader hardware platform.

In accordance with one aspect of the present invention an RFID reader includes a hardware platform including a transceiver an input output interface a controller and a memory. The transceiver is arranged to receive communication signals from at least one RFID tag. The controller is communicatively coupled to the transceiver the input output interface and the memory. The controller controls the operation of the RFID reader. The memory contains a software development framework for developing a software application that is executable on the hardware platform. The framework includes a plurality of predefined encapsulated functional components that interact with at least one of the transceiver and the input output interface to allow the software application to operate in a manner that is independent of a specific embodiment of the RFID reader hardware platform.

In accordance with another aspect of the present invention a method is provided for developing software applications residing on an RFID reader. The RFID reader includes a memory. A software development framework is stored in the memory of the RFID reader. The software development framework includes a plurality of predefined functional components that interact with the RFID reader in a manner that is independent of RFID reader hardware.

In accordance with yet another aspect of the present invention a system for developing RFID reader resident applications includes an RFID reader and a host computer. The RFID reader has a hardware platform which includes a memory for storing at least one software application. The host computer is communicatively coupled to the RFID reader. The host computer includes a software development framework for developing the at least one software application. The framework includes predefined encapsulated functional components that interact with the RFID reader hardware platform to allow the at least one software application to operate in a manner that is independent of a specific embodiment of the RFID reader hardware platform.

Before describing in detail exemplary embodiments that are in accordance with the present invention it should be observed that the embodiments reside primarily in combinations of apparatus components and processing steps related to implementing a system and method for developing radio frequency identification RFID reader resident applications which process filter and report tag data based on customizable tag events. Accordingly the apparatus and method components have been represented where appropriate by conventional symbols in the drawings showing only those specific details that are pertinent to understanding the embodiments of the present invention so as not to obscure the disclosure with details that will be readily apparent to those of ordinary skill in the art having the benefit of the description herein.

In this document relational terms such as first and second top and bottom and the like may be used solely to distinguish one entity or element from another entity or element without necessarily requiring or implying any physical or logical relationship or order between such entities or elements.

One embodiment of the present invention advantageously provides a method and framework for developing resident RFID reader applications using a set of predefined building blocks called Enhanced Operating System EOS functional components. The EOS application framework provides users with the ability to develop RFID reader resident applications in a fast and efficient manner. The framework allows application developers to focus on the application itself and not the details of I O interfaces and third party application programming interface API calls. The framework enables application programmers to create customized systems that provide minimal to fully featured EOS functionality.

Referring now to the drawing figures in which like reference designators refer to like elements there is shown in an exemplary RFID reader constructed in accordance with the principles of the present invention and designated generally as . RFID reader includes an antenna coupled to an RF transceiver which transmits RF signals to and receives RF signals from an RFID tag not shown in a well known manner. The RF transceiver is coupled to a controller which generally controls the operation of RFID reader .

The controller is also coupled to a communication interface and an input output I O interface . The I O interface interacts with any of a number of peripheral input output devices to present information to and collect information from a user including but not limited to a display screen a keyboard a keypad a mouse etc. The I O interface may include any number of I O ports including but not limited to serial parallel Universal Serial Bus USB Firewire VGA HDMI and other audio video ports.

The communication interface enables communication between the RFID reader and a communication network including but not limited to a local area network LAN a wide area network WAN such as the Internet or other intranet a personal area network PAN a campus area network CAN a metropolitan area network MAN etc. The communication interface may be wired or wireless and may communicate using a variety of communication protocols including but not limited to high level wireless communication protocols as defined by the Institute of Electrical and Electronics Engineers IEEE standard 802.15.4 Zigbee the communications standard defined by IEEE 802.11 Wi Fi the communication protocols defined under IEEE 802.16 Wi MAX the industrial specification for wireless personal area network PAN communication developed by the Bluetooth Special Interest Group Bluetooth the communication protocols standardized under IEEE 802.3 Ethernet etc.

The controller is also coupled to a non volatile memory which contains instruction modules for controlling the operation of the RFID reader . Instruction modules include an operating system such as the Linux operating system and libraries associated with writing compiling and running software applications using the Linux operating system . The non volatile memory also includes an Enhanced Operating System EOS application framework which provides predefined building blocks for creating applications resident to the RFID reader . The EOS Framework is discussed in more detail below. It should be noted that although the exemplary EOS Framework and RFID reader are shown to operate using the Linux OS the concepts and principles of the present invention may be equally applied to other equivalent operating systems such as the Microsoft Windows OS family Macintosh OS family Solaris and Unix.

Referring now to an EOS application framework according to one embodiment of the present invention provides a portable platform for RFID reader application development. An application that is developed using the EOS Framework does not need to depend upon the actual reader hardware platform or any vendor API. Reader platform dependency is abstracted from the application by the EOS Framework .

The EOS application framework is an object oriented framework that maintains the object oriented concept of encapsulation and has a well defined public interface. The framework provides an API for developers which allows customization of configuration by publishing interface methods to programmatically modify values independent of a configuration flat file.

The EOS application framework is an architecture in which basic building blocks called EOS functional components are composed in order to develop RFID reader resident applications . Each component provides an interface that allows access to its functionality. The framework consists of core components and auxiliary components . The core components represent basic EOS functional components and the relationships between them. Core components should be included in every application and provide a minimal EOS functionality. Core components may include a reader interface a tag state handler a version manager a license support manager and Operating System utilities . The core components define a semi complete core EOS application .

The reader interface provides an object oriented interface to the reader vendor API as well as interfaces required to completely operate and manage the reader . The tag state handler filters out RFID tag responses according to their current state thus reducing the number of tag reads queued for transmission to the host. The version manager maintains and reports reader software version information. The license support component is responsible for licensing the reader and monitoring the EOS Framework license. The OS utilities are a set of wrappers for OS facilities that simplify the usage of the OS system functions. The OS utilities implement a consistent usage policy for these functions as well as allow for easy migration from one operating system to another as only these wrappers need to be modified in order to use the EOS Framework with a new OS. Each core component is discussed in more detail below.

Auxiliary components include those areas where a developer uses the framework to add custom software to increase functionality of the EOS Framework to address individual project needs. An application developer may extend the core functionality by incorporating auxiliary framework components . In other words when the application developer composes an application with the framework he she may ignore the inner workings of the framework and add only those auxiliary components necessary to address the particular application requirements without having to modify existing application code. Auxiliary components customize the framework by being combined with the core components during the instantiation process. Auxiliary components include an RF control component a trigger control component a notification channels manager a general purpose GP output controller a command handler a configuration manager a network management component a message display component and application utilities .

The RF control component processes RF Schedule and RF Search Actions and schedules tag searches. The trigger control component processes triggers which include an input trigger and a set of actions to perform. The notification channels manager creates and deletes notification channels used to deliver tag events data to host computers. The GP output controller controls the states of General Purpose outputs. The command handler processes incoming commands from the managing host computer. The configuration manager extracts component configuration parameters from EOS Configuration files. The network management component has two separate subcomponents an outage report and a SNMP network management each of which are discussed in more detail below. The message display component displays application text messages on an LED LCD display connected to the reader I O interface . Application utilities are used by the framework components as well as framework applications to facilitate faster feature and application development. Each auxiliary component is discussed in greater detail below.

Core components represent a basic set of instructions that allow a user to create a working application. In one embodiment of the present invention the following core components are usable for each application.

EOS Framework components needing access to reader resources use the reader interface to perform their tasks. Once the reader interface component is initialized it attempts to connect to reader firmware using the reader native API i.e. vendor API. If the connection is successful other components and the application may instantiate and initialize. Otherwise the EOS process exits.

In order to receive tag data collected by the reader the user via an application registers with the reader interface using a pointer. The reader interface sends at least one tag message to the user via the application s process method. Each tag message may contain information such as the antenna on which the tag is read the air protocol used to read the tag e.g. GEN2 the number of bits in a tag ID the tag ID the tag ID CRC the number of times a tag is read the tag detection time stamp the port to which the antenna is attached etc.

The application process method can be designed to be very efficient as the application process method executes in the context of the reader interface thread. Inefficient implementation of this method may have negative effects on the performance of the reader . Generally the application process should only deposit the tag message in some application queue and return. The user application may then remove the tag message from the queue and take time processing the message.

A block diagram of the tag state handler is shown in . The tag state handler component is used to filter out tags according to their current state thereby reducing the number of tag reads queued for transmission to the host. When the reader is searching for tags it may encounter the same tag multiple times during the same search cycle. To prevent reporting the same tag multiple times a Finite State Machine for a tag Tag FSM can be defined. The tag state handler implements this Tag FSM.

The configuration parameters for the tag state handler include a container of RF sources . RF sources is a named grouping of antennas located in a specific area. The RF sources are discussed in greater detail below in relation to auxiliary component RF control . Each RF source contains information about which tag states the user is interested in and what the state transition parameters are. Possible tag states that the tag state handler may generate include new glimpsed observed lost purged and unknown. State transition parameters may include an observed threshold an observed timeout a glimpsed timeout and a lost timeout.

Another configuration parameter used by the tag state handler is the state eval cycle time parameter in milliseconds . Every single tag read is queued into a tag state table represents the state of tags currently in the field for state transition evaluation purposes. The evaluation cycle is the cycle at which tags in the tag state table are evaluated for state transitions. When a tag reaches the Unknown state it is discarded from the state table .

The tag state handler interface allows user to query configuration parameters register and or deregister for notification of tag state transitions i.e. tag events and request a tag state table resynchronization. To promote loose coupling between components in one embodiment the tag state handler does not deliver tag events directly to a notification channel queue. Instead the notification channels manager registers for notifications of tag events from specific sources. The tag state table resynchronization request causes the tag state handler to generate tag events based on the current states of all tags in its tag state table . This method is generally used to determine the state of the tags that are in an RF field accessible to the RFID reader .

The version manager component is used for maintaining and reporting reader software version information. The version manager interface provides the user with ability to set application version attributes as well as query the version of any one of the following exemplary software components EOS Framework version reader vendor reader type reader firmware version application name application company name application version and application Globally Unique Identifier GUID . In one embodiment the version manager may not require any configuration parameters to start executing. During its initialization the version manager may query an application for its application version attributes. If the application fails to provide these attributes the version manager will cause the EOS process to exit.

The license support manager is responsible for licensing the reader and monitoring the EOS Framework license. In one embodiment the EOS Framework is arranged such that it must be licensed in order to operate. The license manager interface provides the following methods 

The license manager may support monitoring of the EOS Framework license only or monitoring of the actual application license.

In order to make EOS Framework portable one embodiment of the EOS Framework does not use Linux operating system threads library directly. Instead the EOS Framework may include Operating System utilities consisting of a set of wrappers for OS facilities such as threads semaphores mutexes reader writer locks and conditional variables. These wrappers simplify the usage of the OS system functions and implement a consistent usage policy for these functions. The OS utilities allow for easy migration from one operating system to another as only these wrappers need to be modified to implement a new OS.

Referring now to a block diagram of an RF control component constructed in accordance with the principles of the present invention is shown. In one embodiment the RF control component is responsible for processing RF schedule and RF search actions and scheduling tag searches. Additionally RF control provides interfaces to initialize RF control and start its execution start searching on a set of RF sources for a specific duration stop searching on a set of RF sources suspend and resume RF control execution report whether RF control is active or suspended i.e. idle and register deregister from receiving search started and search completed messages.

Configuration parameters for RF control include RF search schedule RF sources RF port topology and minimum search interval . RF search schedule is a schedule for searching on specified sources. The RF sources parameter includes a named grouping of antennas located in a specific area. RF port topology specifies reader ports that are connected to antennas. Minimum Search Interval sets the minimum number of milliseconds that a reader is allowed to continue with a tag search prior to being stopped in order to resume with the next search. Each of these configuration parameters is described in more detail below.

In one embodiment the initialization of RF control is tightly coupled with the initialization of trigger control . Both the RF control and the trigger control components should be instantiated prior to initializing either one. Instantiate involves creating an object and all of its elements in computer memory so the object is accessible by other program elements. In other words once both are instantiated they can both be initialized. In one embodiment of the EOS Framework RF control initialization depends upon trigger control having been instantiated in order to register for the processing of search and stop search actions. On the other hand trigger control initialization depends upon RF control having been instantiated in order to register for the processing of search started and search completed messages.

RF control may run immediately upon initialization as long as a search schedule is available. RF control processes the first scheduled search entry by issuing an appropriate search request then processes the next scheduled search entry and continues in a round robin fashion until stopped. The search duration for each entry is the minimum amount of time that the reader will search on the entry s sources.

If the RF search schedule is not present RF control waits for a search action emanating from a trigger firing or an application request to perform the next tag search. A search action is described in more detail below in reference to the trigger control . Upon receiving a search action RF control issues a search request to the reader device interface . If multiple search actions are received RF control combines sources from active search actions and re issues a search request for new set of active sources. RF control monitors durations to determine when a search action has completed.

The RF search schedule is used to search based on a time schedule. The schedule consists of a number of schedule entries which may be either a search entry or a delay entry. The search entry consists of a duration e.g. in milliseconds and a set of sources to search on. When RF control encounters the search entry it issues a search request to the reader device interface . Once the search duration expires RF control issues a stop search to the reader device interface . The delay entry consists of a delay duration element e.g. in milliseconds. During the delay period RF control does not issue any scheduled search requests. However if a search action becomes active during a delay period a corresponding search request may be issued.

RF sources may be used for several purposes. For example RF sources allow an application developer to group antennas based on location such as shelf or dock door etc. RF sources also provide configuration data for the tag state handler . Each RF source entry may contain the name of the location port IDs of antennas belonging to this source a list of tag states to report and state transition parameters . RF source entries are combined into a container namely RF source container . The RF source container allows the user to search for a source based on a source name or port that the source contains.

The RF port topology contains a list of all the RF ports that are defined in the system. RF port topology allows the user to convert an antenna number to an RF port data structure which is used by the reader device interface . The RF port topology provides the following functions add remove RF port get set port address and get set power level. Each port contains a port address e.g. reader port number and a port power level.

The trigger control component processes trigger actions i.e. performs a set of actions based on a trigger event. The trigger control interface allows the user to add triggers remove triggers clear all triggers register deregister for processing actions and process application event messages. The trigger control does not require parameters in order to be initialized. Trigger control is thread safe therefore triggers can be added and removed at any point during run time. Note that the trigger control component is coupled with RF control and its instantiation and initialization should follow the rules specified above for the RF control .

Trigger control processes triggers. Triggers include an input trigger and a corresponding set of actions to perform. An input trigger specifies triggering events which cause activation of the trigger. Specific triggers may include for example a GP input trigger a sequenced GP input trigger a tag search successful input trigger a tag search timeout input trigger and an application input trigger. A GP input trigger is activated when a specified GP input transitions to a specified state. For example if input A transitions to high then activate this trigger. A sequenced GP input trigger may be activated when a specified GP input transitions to a specified state and then another GP input transitions to a specified state within a specified time duration. For example if input A transitions to high and then input B transitions to high within 300 ms of input A then activate an action. A tag search successful input trigger may be activated when RF control completes a search request and one or more tags were detected during that search request on specific sources. Trigger control automatically registers with RF control to receive a search completed message i.e. search completed means at least one tag is read during the search. A tag search timeout input trigger may be activated when RF control completes a search on specified sources and no tags are detected during that search. Trigger control automatically registers with RF control to receive search timeout messages.

An application input trigger is a trigger that is named and called by an application . When the application specified condition occurs the application can execute a process application event message method. The application event message contains a string with the event name. When the application invokes trigger control s process method passing in the event message trigger control executes the trigger action associated with that trigger. Trigger actions such as search action stop search action set GP output action display message action and notify application event action are contemplated. Search action is used by RF control to start a search request. Search action includes a list of source names to search for as well as a search duration. Stop search action is used by the RF control to terminate a search on a set of sources. Stop search action includes a list of source names that require search termination. Set GP output action is used by the GP output controller to set a specific output to a specific state for a specific duration. Set GP output action includes an output number a desired state and a specific duration. Display message action is used by the message display to display a named message on an optional LCD display attached to the reader s I O port. Display message action contains the name of the message to display. Notify application event action is used to notify an application to execute a named action and contains the name of the action to be executed.

To promote loose coupling between different components in the framework trigger control does not call action processing methods of other components directly. Other components as well as applications register with the trigger control for processing the above actions. Trigger control uses the notification mechanism to inform other components to execute the action. For example RF control component registers for search action and stop search action output controller component registers for set GP output action message display component registers for processing display message action and the user application registers for application event action.

The notification channels manager component is used to create and delete notification channels used to deliver tag events data to host computers. Notification channels manager may be initialized from configuration using a notification channel parameters data structure shown in . The exemplary notification channel parameters data structure contains the following fields channel name source names maximum report size in bytes reporting interval state resync cycle retry if connect fail flag lease max duration output buffer max and primary secondary URIs .

Channel name includes a name used to identify the notification channel. Source names contain a list of source names that this channel registers with to receive tag events. Maximum report size contains the maximum length of reports from this channel in bytes. Reporting interval establishes how often to send reports. State resync cycle determines how often to send a request to the tag state handler to resynchronize with the tag state table . The retry if connect fail flag determines whether the channel should continuously retry to send data if the TCP IP connection fails. Lease max duration specifies the amount of time a channel is to remain active prior to its automatic deletion. Lease max duration may be used as a service channel to diagnose tag reads in case of antenna or reader malfunction. The channel is automatically deleted once the lease duration expires. Output buffer max specifies the size of the channel tag events output buffer in bytes. Primary Secondary Uniform Resource Identifiers URIs include TCP IP addresses and ports of data target host computers. The channel will attempt to connect to the primary URI first and if the connection attempt fails automatically switches to the secondary URI.

The notification channels manager reports tag event data in the form of Event Reports. In addition to tag events other significant events are reported including but not limited to reader reset event buffer full event buffer reset event resynch start event resynch complete event input trigger event and a good bye or channel termination event.

An exemplary tag event data structure is shown in . The tag event data structure contains the following fields event type tag state tag source name tag id air protocol trigger and tag detection time . The event type field describes the type of notification message for example tag event or reader reset event. The tag state filed indicates whether or not the tag was seen in the previous read cycle. The tag source name field identifies the antenna or grouping of antennas that detected the tag. The tag id field is the EPC global tag identifier. The air protocol field refers to the type of protocol used to communicate with the tag. The trigger field applies to an input trigger event that is reported if an input port signal transitions from Low to High or vice versa. Tag detection time is the time stamp at which the tag was read. An exemplary input trigger event data structure is shown in . The input tag event data structure is similar to the tag event data structure but typically only contains fields for the event type an input number input state and an event occurrence time. The input number is the number of the physical input port. The input state is Low or High reflecting the type of transition. Event occurrence time is the time the transition is detected at the input port. Other events may contain event type and occurrence time.

All channels may monitor their own state and data buffers. The user can set up a percentage full threshold and be notified when the buffer reaches that threshold. To do so the user sets the threshold and registers for notification of the tag event buffer threshold message. The notification channels manager interface may perform several functions. For example using the notification channels manager a user may create a new channel with new input parameters remove an existing channel along with its output buffer alter the parameters of a channel set up buffer bull thresholds for all channels request tag state resynchronization be performed and register and or deregister for notifications of messages such as failed to connect to target message buffer threshold reached message and buffer full message.

The GP output control component is responsible for controlling states of any general purpose output of the RFID reader . Output states are typically high and low. The output control component does not require any configuration parameters. During initialization this component registers with the trigger control for processing set GP output actions. As a result output control is instantiated after instantiating trigger control . Currently this instantiation is controlled at the framework initialization.

As described above in relation to the Trigger Control section the set GP output action contains three parameters output number output state and duration. Trigger control searches through all configured triggers to find their respective set GP output actions. Trigger control then initializes all output states using the reader device interface to states opposite the action states. For example if there is an action to set output to closed state trigger control initializes the output to open state.

When output control receives a set GP output action it uses the reader device interface to set the requested output to the requested state. Output control then starts a timer for the length of the duration specified. When the timer expires the state of the output is reset to its previous state.

The command handler component processes incoming commands from the managing host computer. Command handler creates two command channels namely a secured and an unsecured channel. The secured channel accepts encrypted commands such as Secure Socket Layer SSL encrypted commands over TCP IP sockets. The unsecured channel accepts unencrypted commands over TCP IP sockets. All the supported commands may be sent over the secured channel. To disallow certain commands on the unsecured channel the user specifies in a configuration file the names of the commands which are allowed on the unsecured channel. This list can also be passed as a parameter to the configuration manager when it is instantiated. Note that by default if no commands are specified as unsecured accessible in the configuration file the command handler will allow any supported command to be processed as unsecured accessible.

Supported commands may include but are not limited to get firmware version reboot get configuration time stamp update firmware stop RF resume RF request state resynch set IP address get reader state set output get license key seed set license key get firmware update status enable DHCP set hostname get hostname set DNS servers request file transfer add notification channel remove notification channel get configuration file information get license state get software info restart EOS set configuration set reader name get reader name set NTP server get NTP server set EPC filter list and remove EPC filter list.

The configuration manager component is responsible for extracting component configuration parameters from configuration files. An application may use the configuration manager to retrieve its own configuration parameters from the application portion of a configuration file.

Referring now to the network management component in one embodiment consists of two separate subcomponents an outage report and a Simple Network Management Protocol SNMP system component .

The outage report reports reader outage events to the host computer. Supported outage events may include reader reset tag read below threshold and dense reader environment DRE lockout. DRE lockout is the disabling of a reader s RF operations if it is determined that the reader s RF operations is interfering with the RF operations of another reader. Outage reports are formatted similarly to tag event reports but they are sent out via a separate channel. The outage report interface is initialized using outage report parameters outage channel parameters and reader settings . Outage report parameters may include an enable disable DRE lockout outage an enable disable tag read below threshold outage a tag read below threshold outage count and a tag read below threshold outage interval .

Outage reports are messages from the reader that indicate outages have occurred. For any of the outage report parameters set to enabled if that condition occurs a report of that occurrence will be issued. For example in the case of a DRE lockout outage if the reader goes into lockout state because conditions indicate dense reader environment and the outage report parameter for DRE lockout is enabled an outage report will be issued. For the tag read below threshold outage if the number of tags read in a read cycle is less than the threshold count and the below threshold outage parameter is enabled a below threshold outage report will be issued. For outage count the number of tags read is compared to the value set in outage count to determine whether the count has been reached or is below threshold. For outage interval the interval value tells at what time interval the tags are counted. If the number of tags counted is below the threshold a notification is issued.

Outage channel parameters may include an outage report maximum size e.g. in number of events a report interval and primary and secondary host URI specifications . The reader settings contain the reader name which is included in the outage report .

The SNMP system component delivers alerts and performance statistics to the network management station via Simple Network Management Protocol SNMP . In one embodiment the SNMP system has a master agent a sub agent an alert agent and a statistics agent . The master agent includes a template for creating a SNMP sub agent library which is statically linked in with the application executable. The statistics agent and the alert agent are grouped together under the EOS Framework network management component as a single library. The sub agent acts as an interface between the application and the master agent as shown in . The alert agent monitors alert messages and dispatches SNMP alerts when the alerting conditions are met. The statistics agent is responsible for reporting operational statistics via SNMP. The SNMP system interface may provide the following methods enable alerts disable alerts get tag read rate and get input trigger rate.

The network management component is not instantiated by the framework initialization code. EOS Framework does not require this component to run however in order to include the SNMP system the application should instantiate this component separately.

The message display component is responsible for displaying application text messages on an LED LCD display connected to the reader I O interface . The message display component is initialized with the display parameters data structure as shown in . These parameters include but are not limited to the number of lines available on the display characters per line i.e. the number of characters that fit on a line a display initialization command string a display clear display command string a display goto new line command string and a display hide cursor command string. Because the displayed messages are dynamic and may be updated during run time the application registers as a message builder with the message display agent as shown in . This drawing represents a sequence diagram depicting the steps involved for the application to register as a message builder with the Message Display Agent and display the message.

The message display interface in an exemplary embodiment provides the user with the following methods 

The message data structure as shown in is passed as a parameter to the message display agent . The message data structure may include but is not limited to a message name message display duration message priority and message lines container . Each message has a display priority and display duration . Higher priority messages overwrite lower priority messages. In addition an overwritten lower priority message may complete its remaining duration once the higher priority message has completed its display duration. For example referring to suppose there are two messages M having a duration of 360 seconds and priority and M having a duration of 60 seconds and priority . Message display agent is requested to display M 100 seconds after M has begun displaying. shows an example of in what order and for how long the messages are displayed.

In order to facilitate faster feature and application development the EOS Framework provides a set of application utilities as shown in . These utilities are used by the framework components as well as framework applications . Application utilities may include but are not limited to base agents including passive agents and active agents deliverer classes a log utility an MD5 hash utility a notifier observer utility queue classes TCP socket utilities time conversion utilities and type conversion utilities . Each utility is described in detail below.

In accordance with one embodiment of the present invention the EOS Framework provides two types of base agents a passive agent and an active agent . A passive agent is an abstract class that implements the following features 

An active agent contains passive agent features as well as a thread and a semaphore which are used to control execution of the agent . An active agent runs in the context of its thread. Initialization parameters for the active agent may include RunMode thread priority thread stack size sleep duration and block timeout.

An active agent may run in four different modes run with sleep run blocked run blocked with timeout and run once. In the run with sleep mode Run method is executed followed by the thread sleeping for a specified duration. When the thread wakes up it executes Run again and goes back to sleep. This is done until a request to terminate is received by the agent . In the run blocked mode the Run method is executed and then the thread is blocked. The thread is manually restarted before it is able to run again. In the run blocked with timeout mode the agent operates in the same manner as the run blocked mode however the thread is resumed when the timeout expires. In the run once mode the thread executes the Run method once and exits. Note that unlike threads there is no need to implement an infinite thread loop. Also the thread safe destruction of an agent is handled automatically for the user as long he she follows the agent pattern.

The deliverer classes deliver data to the target host. One example of a deliverer that may be implemented by the EOS Framework is a Socket Connection Manager SCM . This class uses TCP IP sockets to connect and send data to the host computer. This class may also provide a user with the ability to set up two target hosts a primary and a secondary fail over . SCM attempts to send data to the primary host first but if unsuccessful then attempts to send to the secondary. If both fail SCM continues to bounce back and forth between the primary and the secondary until it establishes a successful connection. A user may configure SCM to enable or disable a handshake between the reader and the target host. When processing XML messages SCM provides a method to receive an entire XML document using a document end XML tag to determine the end. The notification channel component uses SCM to deliver tag events to the host.

The log utility allows the user to log events and traces into a log file for debugging purposes. Each component has its own log object where it logs its events and traces. One embodiment of the log utility uses two files for logging information. Initially a first log file is written to until it reaches its maximum size. A second log file is then written to until it is also full. When both log files have reached their maximum capacity the content of the first log file is erased and is replaced with new log messages. The log files may be stored in the reader s RAM file system thereby preventing these files from surviving a reader reboot. Thus if a user needed to save these files they should be transferred to a non volatile memory storage system e.g. floppy disk hard drive EEPROM compact disc memory stick etc. prior to reboot.

The log utility allows the user to classify logs based on the several severity levels. In one embodiment logs may be classified as critical error info trace and debug. A critical log may contain information concerning some critical error which causes the system to stop performing some or all of its functions. An error log may contain information relating to a recoverable error. A info log may contain one or more informational messages. A trace log may include function trace messages which indicate the application has entered or exited a function. A debug log includes debug messages. Each message in the log file may be time stamped. Additionally closing a log file then reopening it may erase its previous content.

The MD5 hash utility allows a user to calculate the file s MD5 digest which is used to authenticate files when transferring them to the reader . A managing host via command channel command or an EOS Framework application invoking a configuration manager method may retrieve the MD5 digest of a configuration file in order to ascertain the integrity of the file. In addition the MD5 Hash interface provides the ability to imbed the digest into the file itself so that it may be transmitted with the file. The Notifier Observer utility is used to implement a Publisher Subscriber design pattern. shows how this design pattern is used in the framework. A Publisher class contains one or more Notifiers each used for specific message. This pattern promotes low coupling between system components thus reducing component dependencies and increasing flexibility. A publisher class may contain one or more notifiers each used for specific message. Components wishing to receive notifications subscribe by registering as Observers with the sender of the message. The Notifier broadcasts the notifications to all registered components. Subscribers who inherit from the observer class register themselves with the notifier . Subscribers implement the process method which is pure virtual in the Observer class. When the publisher dispatches a message to the subscribers it calls a Notifier Dispatch method which in turn calls the subscribers process methods.

In one embodiment the EOS Framework also provides four types of queue classes to the application developer. These are parameterized classes and thus can be queues of any data type. The queue classes may include Queue LockQueue WaitQueue and WaitPriorityQueue . Queue is a basic first in first out FIFO queue. It may be set to any size. In addition to add and remove methods Queue also provides information about percentage of occupancy and availability. This queue is not strictly thread safe but may operate safely in a single producer single consumer environment. Queue is a non blocking queue i.e. the consumer thread will not be blocked if the queue is empty.

LockQueue adds a lock to the queue making it safe to use in multiple producer multiple consumer environments. WaitQueue supports all the features of the Queue class in addition to blocking the consumer thread when the queue is empty. When an item is added to the queue the consumer thread is unblocked. The WaitPriorityQueue provides the user with the ability to add items and prioritize them inside the queue. WaitPriorityQueue is also a blocking queue i.e. the consumer is blocked when the queue is empty.

In order to improve EOS Framework portability to other reader platforms as well as simplify communications over TCP IP network EOS Framework implements TCP socket utilities for Linux Socket interface. These wrappers include listen port and TCP IP socket wrappers . Listen port allows the user to listen on a specific TCP IP port for commands and incoming messages. TCP IP socket wrappers allow the user to poll send and receive data. The TCP socket utilities are used by the command handler component .

It is contemplated that at least some of the components in the EOS Framework and applications may need to manipulate time objects. To simplify these tasks a set of time conversion utilities are provided by the framework . For example Generate Time Stamp generates a time stamp from an input time value in the form YYYY MM DDTHH MM SS. The input time value includes number of seconds and microseconds from beginning of UNIX EPOCH 00 00 00 UTC Jan. 1 1970 . Generate Current Time Stamp generates a time stamp given current system time. TimeDiff TimeAdd and TimeClear are wrappers for standard Linux struct timeval handling macros. IsTimeInBetween IsGreaterThanOrEqual and IsLessThanOrEqual are struct timeval comparison functions. Additional time conversion functions convert milliseconds to struct timeval and convert struct timeval to milliseconds since beginning of UNIX Epoch and struct timeval. Convert String To Time includes a time stamp to struct timeval. Get Current Time gets current system time and Get Uptime gets the reader uptime since the last reboot.

The EOS Framework also provides conversion utilities . These include for example convert string to unsigned integer convert string to signed integer convert string to Boolean convert Boolean to string convert hex string to array of bytes and convert an unsigned integer to string. These utilities simplify type conversions.

The component interfaces of the present invention define a set of interaction points between the interface and the external world. The interface specifies the services messages operations and variables a component provides defines the computational commitments that a component may make and places constraints on its usage. Additionally design patterns as shown in or templates may be utilized to ensure optimized solutions to recurring design problems. A fa ade pattern for example may be used in all component interface objects to provide a consistent layer between the developer and the core and auxiliary components.

Additional design patterns incorporated into the framework may include Strategy Singleton and Factory. The Strategy Design Pattern basically consists of decoupling an algorithm from its host and encapsulating the algorithm into a separate class. More simply put an object and its behavior are separated and put into two different classes. This allows the application designer to switch the algorithm that he she is using at any time. The Singleton Design Pattern ensures that a class has only one instance and provides a global point of access to that instance. The Factory Design Pattern specifies various ways to separate the construction of a complex object from its representation letting the application designer use the same construction process to create different representations. The framework may be available as a set of libraries in the form of library archives .a files . The libraries are accompanied by a set of header files which provide external interfaces to the framework s functionality. In addition a version of the framework may be available to run on a Linux personal computer PC or other development platform as well as a set of device simulation libraries which allows a developer to write and test the application code on the PC prior to embedding in the reader .

The present invention can be realized in hardware software or a combination of hardware and software. Any kind of computing system or other apparatus adapted for carrying out the methods described herein is suited to perform the functions described herein.

A typical combination of hardware and software could be a specialized or general purpose computer system having one or more processing elements and a computer program stored on a storage medium that when loaded and executed controls the computer system such that it carries out the methods described herein. The present invention can also be embedded in a computer program product which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computing system is able to carry out these methods. Storage medium refers to any volatile or non volatile storage device.

Computer program or application in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

In addition unless mention was made above to the contrary it should be noted that all of the accompanying drawings are not to scale. Significantly this invention can be embodied in other specific forms without departing from the spirit or essential attributes thereof and accordingly reference should be had to the following claims rather than to the foregoing specification as indicating the scope of the invention.

