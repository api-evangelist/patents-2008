---

title: Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques
abstract: Systems and methods for downloading algorithmic elements to a coprocessor and corresponding processing and communication techniques are provided. For an improved graphics pipeline, the invention provides a class of co-processing device, such as a graphics processor unit (GPU), providing improved capabilities for an abstract or virtual machine for performing graphics calculations and rendering. The invention allows for runtime-predicated flow control of programs downloaded to coprocessors, enables coprocessors to include indexable arrays of on-chip storage elements that are readable and writable during execution of programs, provides native support for textures and texture maps and corresponding operations in a vertex shader, provides frequency division of vertex streams input to a vertex shader with optional support for a stream modulo value, provides a register storage element on a pixel shader and associated interfaces for storage associated with representing the “face” of a pixel, provides vertex shaders and pixel shaders with more on-chip register storage and the ability to receive larger programs than any existing vertex or pixel shaders and provides 32 bit float number support in both vertex and pixel shaders.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08305381&OS=08305381&RS=08305381
owner: Microsoft Corporation
number: 08305381
owner_city: Redmond
owner_country: US
publication_date: 20080430
---
This application is a divisional of U.S. patent application Ser. No. 10 987 686 filed Nov. 12 2004 which claims the benefit of U.S. Provisional Application No. 60 520 253 filed Nov. 14 2003 the entire contents of which are hereby incorporated by reference in their entireties.

A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document Copyright 2001 2003 Microsoft Corp.

The present invention provides systems and methods relating to graphics interface s as a layer between applications application developers and a more flexible graphics pipeline that renders and processes graphics data and to corresponding hardware improvements.

For the vast majority of applications application programmers rely on or utilize some form of software interface for interactions between a host system such as the host system of a computer and its associated subsystems such as a computer s graphics subsystem. For graphics applications developers or programmers typically utilize a graphics software interface such as a 3D graphics application programming interface API to facilitate the interaction with constituent parts of a graphics system. For instance a developer might develop a graphics application that makes and receives calls to and from the graphics API in order to achieve some result pertaining to a graphics effect applied to graphics data. Programmers typically rely on software interfaces to graphics processing units GPUs peripherals and other specialized devices so that they can focus on the operational specifics of their application and the artistry of the graphics content rather than on the specifics of controlling a particular device or the algorithmic details associated with generating certain graphics objects or transforming those objects according to a particular effect. Programmers also rely on software interfaces so that their efforts are not duplicated from application to application i.e. so that function calls or interfaces which are likely to be useful to multiple developers or likely to be applicable to various graphics scenarios such as Create Triangle Fill in Object with a Specified Solid Color Stretch Scale Rectangle etc. can re used. However even after generations of software interfaces there are certain aspects of today s software interfaces that can be improved.

Historically graphics peripherals integrated circuits ICs and other specialized graphics hardware designed for specific tasks e.g. special purpose co processing chips such as GPUs have been better than the host processor of a host computing system at performing certain types of functions. For instance video cards generally include special purpose hardware for copying and processing pixels and vertices faster than the central processing unit CPU . So historically for a PC having a host system with a CPU and a graphics subsystem having a GPU when any sort of graphics thinking was involved the CPU handled the processing and when repetitive number crunching of large arrays of data was implicated the GPU was called upon for processing. However changes in graphics technology have occurred that have transformed the traditionally fixed function graphics pipeline into a more flexible entity.

For instance hereby incorporated by reference commonly assigned copending U.S. patent application Ser. No. 09 796 577 filed Mar. 1 2001 entitled Method and System for Defining and Controlling Algorithmic Elements in a Graphics Display System relates to systems and methods for enabling programmability of a 3D graphics chip wherein programming or algorithmic elements written by the developer can be downloaded to the chip thereby programming the chip to perform those algorithms. As described a developer writes a routine representing algorithmic element s wherein the routine is downloadable to the 3D graphics chip and then downloads the algorithmic element s to the programmable chip. Alternatively the developer chooses from a pre existing set of algorithmic elements that are provided in connection with the API itself or specifies the location of an otherwise existing routine. The routine adheres to a specific format for packing up the algorithmic element s or instructions for implementation by the 3D graphics chip. In one embodiment the developer packs the instruction set into an array of numbers by referring to a list of tokens understood by the 3D graphics chip. This array of numbers in turn is mapped correctly to the 3D graphics chip for implementation of the algorithmic element s by the 3D graphics chip. The architecture of the 577 application enables the developer to be flexible when defining the computation to be performed by the chip while simultaneously allowing the developer to leverage the power and performance advantages provided by the 3D graphics chip.

Vertex and pixel shaders which may be implemented with software or hardware or with a combination of both are specialized components of a graphics subsystem that include specialized functionality for the processing of pixels vertices or other graphics data so as to perform specialized operations such as lighting and shading and other transformations upon graphics data. In this regard vertex and pixel shaders are two types of procedural shaders that have evolved to possess programmable functionality e.g. as described in the 577 application.

Additional background relating to vertex and pixel shaders can be found in commonly assigned copending U.S. patent application Ser. No. 09 801 079 filed Mar. 6 2001 entitled API Communications for Vertex and Pixel Shaders hereby incorporated into the present disclosure by reference. Briefly the 079 application is directed to a three dimensional 3 D graphics application programming interface API that provides improved communications between application developers and hardware rendering devices such as procedural shaders. In particular the 079 application is directed to improved API communications for host interaction with procedural shaders such as vertex and pixel shaders having local registers. The API communications of the 079 application advantageously expose various on chip graphical algorithmic elements while hiding the details of the operation of vertex shaders and pixel shaders from the developer. Advantageously the procedural shaders and corresponding communications do not access the main memory or stack on the host system but rather perform their operations efficiently with respect to a set of local registers. For the particular graphical algorithmic elements exposed the graphics subsystem and corresponding interfaces of the 079 application allow for an efficient instruction set with numerous performance advantages including faster accessing and processing of data as a result of bypassing the host system memory or stack.

As is apparent from the above advances in hardware such as procedural shaders and graphics interfaces and algorithms have been revolutionizing the way graphics platforms operate. Generally speaking however current 3D graphics chips on the market can still be made more flexible and efficient i.e. room for improvement still exists both with respect to vertex shaders and pixel shaders.

For instance on the vertex shader side of the graphics pipeline while programs i.e. algorithmic element s packaged as tokenized set s of instructions currently can be downloaded to a graphics chip the flow represented by a program performed by the graphics chip must be static. While such static flow may include branches the branches themselves are fixed and may not be predicated upon a characteristic only known at runtime i.e. any branches that may currently exist in a program downloaded to a vertex shader are predicated upon pre set constants such that all data fed to the vertex shader is processed in exactly the same way until the corresponding program is unloaded.

For instance as illustrated in a developer D or a software application A can specify a program P having exemplary instructions I to I to a graphics API GAPI for download to the graphics chip such as vertex shader VS in order to program the graphics chip to perform the algorithms represented by the program P. Once the program P is downloaded to vertex shader VS however i.e. once vertex shader VS is programmed with program P graphics data processed by vertex shader VS must be processed according to the algorithms I to I represented by or corresponding to instructions I to I. In this simple example the goal of the illustrated program P is to process black pixels in one way I I and I and white pixels in another way I and I . However once the program is loaded into vertex shader VS there can be no branching taking place upon a characteristic or variable of the runtime system which can be limiting.

While the ability to define a static process flow for all graphics data to be processed according to algorithms I to I on the graphics chip is beneficial currently the static definition must remain for the duration of processing according to program P i.e. until the processing is stopped and another program providing a different static computational flow is downloaded to the vertex shader VS for further processing of graphics data.

As illustrated in represented by the arrows illustrating the computational flow process performed on the graphics data the processing that occurs for each data point of the graphics data streamed through the graphics chip s execution engine is limited to the static flow of the following if a constant C is 0 vertex shader VS processes according to algorithm instruction or function I followed by algorithm I and followed by algorithm I before being output and if a constant C is 1 vertex shader VS processes according to algorithm I and algorithm I before being output. In this regard all of the graphics data must be processed in these static rules of process flow i.e. some of the data cannot be processed according to different rules of process flow. More particularly the graphics data cannot currently be processed according to dynamic branches of program P determined at runtime e.g. an If Then or If Then Else command or structure based upon a runtime condition cannot be deployed in a program. Accordingly it would be desirable to provide dynamic flow control for programs that are downloaded to a vertex shader VS whereby a coprocessor can receive a program which thereby programs the coprocessor to dynamically process data in a particular way defined by the program and wherein the coprocessor can process data differently according to different branches defined by the program. For instance according to criteria specified in the program it would be desirable to process some of the data streaming through the coprocessor according to a first algorithm depending upon a first condition that is set or discovered at runtime and some of the data according to a second algorithm depending upon a second runtime condition or setting without recourse to downloading another program. It would be further desirable to enable branching to occur dynamically during the execution of a program that has been downloaded to a graphics chip to predicate control of the processing of graphics data on runtime characteristics or variables.

It is to be noted that the dichotomy of symbolic representation e.g. I v. I is used above when describing a program instruction versus its functional representation as a part of a program that has been downloaded to a graphics chip respectively however one can appreciate that a program may be parsed and or partially quasi or fully tokenized or compiled en route to the graphics chip as part of the download process to format the program for reception and use by the graphics chip. As a consequence the process of tracing or finding definitive correspondence between a representation I in the graphics chip and a source code instruction I may be amorphous. Moreover where one instruction ends and another begins is not necessarily definitive atomicity of operation may be defined in different ways programs operate according to functional objectives which can be divided into subsets of functional objectives which can be divided into even smaller subsets of functional objectives and so on. Thus such symbolism for instructions has been used herein for conceptual or illustrative purposes.

Graphics API GAPI also includes however many other objects and interfaces such as external object s or interface s EO which may be used in connection with inter alia initializing setting or changing various storage elements such as registers located in the graphics coprocessing subsystem e.g. in the vertex shader VS. Thus as illustrated in an exemplary vertex shader VS includes at least 1 a storage bank for n constants C to C n 1 which are immutable read only during operation of the vertex shader VS 2 a plurality of readable writable input register storage elements I to Ik e.g. for vertices intermediate programming results etc. and 3 a plurality of readable writable output register storage elements O to Om. Exemplary vertex shader VS may include other register storage elements for storing other kinds of variables and constants as well whether readable and or writable.

Because of how quickly the above described storage elements can be accessed by the execution engine EE of the vertex shader VS a program loaded into vertex shader VS via download object s DO can also execute upon large quantities of data streamed through the execution engine EE very quickly. Constants C to C n 1 may be first set by the external objects EO in order to define the context into which program s are to be downloaded and constants C to C n 1 can also be declared globally at the loading or instantiation of a program in the vertex shader VS for reference during operation of the program although constants may not be altered or reset during operation of the program e.g. while the execution engine EE processes a stream or container of graphics data. In this regard as implied by the notation C to C n 1 constants are capable of being referenced by index with programming commands. An exemplary command that indexes a constant is the command mov r C which when executed moves the value rinto constant storage location C . However presently no readable and writable storage element in vertex shader VS may be referenced by index i.e. a mov r I2 or a mov r O7 command can be executed but the equivalent mov r I 1 or mov r O 6 commands using an index into the array of input and output registers can not be performed. The registers I to Ik and O to Om are individually and independently addressable only. Thus a program cannot currently index readable writable input and output registers of a vertex shader VS. This would be particularly desirable and provide more vertex shader flexibility for a variety of reasons including but not limited to achieving looping or recursive behavior within a program downloaded to the vertex shader VS.

After texture sampling additional transformations optionally can be applied to the textured surface prior to rendering the image with picture elements pixels of a display device. Images in computer graphics are represented as a 2 D array of discrete values grey scale or as three 2 D arrays of discrete values color . Using a standard x y z rectangular coordinate system a surface can be specified as a mesh e.g. triangle mesh with an x y z coordinate per mesh vertex or as a geometry map in which the x y z coordinates are specified as a rectilinear image over a 2D u v coordinate system sometimes called the surface parameterization domain. Texture map s can also be specified with the u v coordinate system.

Point samples in the surface parametrization domain where signals have been attached to the surface including its geometry can be generated from textured meshes or geometry maps. These samples can be transformed and shaded using a variety of computations. At the end of this transformation and shading processing a point sample includes a positional information i.e. an image address indicating where in the image plane the point maps to and b textured color or grey scale information that indicates the color of the sample at the position indicated by the positional information. Other data such as depth information of the point sample to allow hidden surface elimination can also be included. The transformed textured surface is placed in a frame buffer prior to being rendered by a display in 2 D pixel image space x y . At this point in the case of a black and white display device each x y pixel location in 2 D image space is assigned a grey value in accordance with some function of the surface in the frame buffer. In the case of a typical color display device each x y pixel location in 2 D image space is assigned red green and blue RGB values. It is noted that a variety of color formats other than RGB exist as well.

In order to render the surface on the display device itself conventionally the textured surface is sampled at positions that reflect the centers of the pixels of the device on which the image is to be displayed. This sampling may be performed by evaluating a function of the transformed textured surface at points that correspond to the center of each pixel by mapping the centers of the pixels back into texture space to determine the point sample that corresponds to the pixel center.

Having described an exemplary texture mapping process illustrates that present graphics coprocessing subsystem architectures do not accommodate the storage and manipulation of texture maps in video memory by a vertex shader VS. Presently vertex buffer VB the video memory allocated for use with the vertex shader VS can store whole sets of integers which is suitable for processing of vertex or positional information. Vertex buffer VB is thus well suited for storing positional information associated with vertices of a geometry map but vertex buffer VB cannot presently store or output float data precise enough to represent a texture map meeting the requirements for today s graphics pipelines and output devices. Since vertex shader VS generally operates with respect to vertex data i.e. positional information sufficient precision to handle the colorization requirements of a texture map has generally not been a concern at the vertex shading stage. Thus vertex buffer VB does not presently support float data inputs or outputs. However there are a variety of operations and transformations that can be applied at the vertex shading stage for which float precision would be desirable. More particularly 32 bit float precision would be desirable for supporting texture storage and processing by vertex shader VS in keeping with the evolution of the graphics pipeline including the appearance of high precision monitors that have support for 10 bit rasterization as opposed to a conventional 8 bit rasterization processes.

It would be further desirable to increase the number of registers available on a vertex shader for use by a vertex shader during operation as input output intermediate and other special purpose storage. For instance a program downloaded to the vertex shader could benefit from increased amount of register storage available on the vertex shader for more variables temporary storage outputs etc. Presently the number of register storage elements in a vertex shader VS is limited to 12.

It would be further desirable to increase the number of instructions that can be accommodated in a program to be downloaded to a vertex shader. Presently the number of instructions that can be downloaded as a program to a vertex shader via the 3D graphics API is 96. One of ordinary skill can appreciate that the complexity of algorithms to be performed by the vertex shader VS is limited by this limit of instructions. Thus it would be desirable to raise the bar from the current maximum number of instructions that can be packaged for execution by a vertex shader VS.

With respect to the processing of multiple vertex streams simultaneously prior art vertex shaders are invoked once per vertex i.e. with every invocation of the vertex shader the input registers are initialized with unique vertex elements from the incoming vertex streams. Thus as illustrated in with older shader models a vertex data point is input from each of vertex data streams VDS and VDS to load the input registers I to Ik for each cycle of the vertex shader VS. While the processing of multiple vertex data streams or containers simultaneously in parallel is advantageous in its own right not all algorithms are well suited to processing parallel data streams by processing a data point from each data stream upon each operational cycle of the vertex shader VS. For instance at the cycle designated by start time t vertex data point V and W are input to the appropriate input registers of vertex shader VS for processing and corresponding output. At the start of the next cycle at time t vertex data point V and W are input to the appropriate input registers of vertex shader VS for processing and corresponding output and so on. However currently a program downloaded to vertex shader VS can not process two vertex data points from vertex data stream VDS then process one vertex data point from vertex data stream VDS then two from VDS then one from VDS and so on repetitively. Thus it would be desirable to provide support for division of inputs from multiply specified data streams for processing by the vertex shader VS. More particularly when multiple data streams are input to a vertex shader VS it would be desirable to specify frequencies for each data stream input which determine how often data from each respective stream is input to the vertex shader VS.

On the pixel shader side of the graphics pipeline there are also several ways in which improvement may be achieved. Similar to vertex shaders for instance a program can be downloaded to current pixel shaders via a graphics API for execution by the pixel shader generally for specialized operations on pixels. In this regard the number of local registers provided for use with the pixel shader and the maximum number of instructions that may be provided for a program downloaded to the pixel shader currently limit the complexity and sophistication of operation that can be achieved with a downloaded program. The number of local registers currently available for use in connection with operation of a pixel shader is 6 12 and the maximum number of instructions that a program may include if it is to be downloaded to a pixel shader is 256. Thus it would be desirable to increase the number of local registers provided on a pixel shader. It would also be desirable to increase the maximum number of instructions that may be associated with a program to be downloaded to a pixel shader.

Additionally the pixel shader side of the graphics pipeline is even more limited than the vertex shader side with respect to branching i.e. flow control in programs. While programs i.e. algorithmic element s packaged as tokenized set s of instructions currently can be downloaded to a pixel shader the flow represented by a program performed by the pixel shader PS must be static non branched and not predicated upon characteristics that become known at runtime. Thus for instance as illustrated in a developer D or a software application A can specify a program P having exemplary instructions I to I to a graphics API GAPI for download to the graphics chip such as pixel shader PS in order to program the graphics chip to perform the algorithms represented by the program P. Once the program P is downloaded to pixel shader PS i.e. once pixel shader PS is programmed with program P graphics data processed by pixel shader PS must be processed according to the algorithms I to I represented by or corresponding to instructions I to I. However presently there can be no branching taking place whether based upon a characteristic or variable set or generated during operation of the runtime system or not.

While the ability to define a static non branched process flow for all graphics data to be processed according to algorithms I to I on the pixel shader is beneficial branching behavior is an important and powerful programming tool and thus it would be desirable to provide both static branching behavior based upon pre set characteristics of the system as well as dynamic branching behavior based upon runtime characteristics for programs downloaded to pixel shaders.

As illustrated in represented by the arrows illustrating the computational flow process performed on the graphics data the processing that occurs for each data point of the graphics data streamed through the pixel shader s execution engine is limited to being processed according to algorithm or function I followed by being processed according to algorithm I followed by being processed according to algorithm I followed by being processed according to algorithm or function I and lastly by being processed according to algorithm I before being output. In this regard all of the graphics data must be processed in this exact static sequence i.e. some of the data cannot be processed according to a different sequence or branch. More particularly the graphics data cannot currently be processed according to different branches of program P e.g. an If Then or If Then Else command or structure cannot be deployed and no different branches can be staticly defined prior to downloading the program either.

Accordingly it would be desirable to provide both static and dynamic flow control for programs that are downloaded to a pixel shader whereby a coprocessor can receive a program which thereby programs the coprocessor to process data according to branches and conditions defined by the program and wherein the coprocessor can process data differently according to the different branches defined by the program. For instance according to criteria specified in the program it would be desirable to process some of the data streaming through the coprocessor according to a first algorithm dependent upon the presence of a pre set constant or variable set or generated at runtime and some of the data according to a second algorithm without recourse to downloading another program. In short it would be desirable to enable branching to occur during the execution of a program once downloaded to the pixel shader to predicate control of the processing of graphics data on preset or runtime characteristics or variables.

In view of the foregoing the present invention provides systems and methods for downloading algorithmic elements to a coprocessor and corresponding processing and communication techniques. For an improved graphics pipeline the invention provides a class of co processing device such as a graphics processor unit GPU providing improved capabilities for an abstract or virtual machine for performing graphics calculations and rendering. The invention allows for runtime predicated flow control of programs downloaded to coprocessors allowing significantly more sophisticated effects and algorithms to be implemented. The invention enables coprocessors to include indexable arrays of on chip storage elements that are readable and writable during execution of programs. By providing for float storage in vertex buffer storage associated with a vertex shader the invention provides native support for textures and texture maps and corresponding operations. The invention further provides frequency division of vertex streams so that multiple vertex data streams may be input to a vertex shader in parallel but the respective data of the respective data streams need not be consumed by the execution engine of the vertex shader VS at the same frequency or rate. Each stream may have an associated stream modulo value too. For pixel shaders the invention provides a register storage element on a pixel shader and associated interfaces for storage associated with representing the face of a pixel i.e. whether it is a frontward facing pixel or a backward facing pixel. The invention further provides vertex shaders and pixel shaders with more on chip register storage and the ability to receive larger programs than any existing vertex or pixel shaders providing increased programming flexibility. The invention still further provides bit float number support in both vertex and pixel shaders.

As mentioned in the background current 3D graphics chips on the market can be made more flexible and efficient with respect to both vertex shaders and pixel shaders.

For programs downloaded to vertex shaders the invention enables branching to occur dynamically during the execution of the programs predicating control of the processing of graphics data characteristics or variables that are set or generated at runtime. The invention further enables programs downloaded to a vertex shader to index readable writable input and output registers of the vertex shader which in turn enables looping or recursive behavior to be specified in programs. The invention further provides vertex buffers associated with vertex shaders with support for float data inputs or outputs including 32 bit float precision and storage support for texture maps in the vertex buffer. The invention still further provides 96 registers for vertex shaders and a max instruction count of 512 for a program downloaded to a vertex shader representing increased flexibility over more constrictive prior art systems. The invention still further provides for controlled division of inputs from multiply specified data streams for processing by a vertex shader by enabling the specification of frequencies for each data stream input that determine how often data from each respective stream is input to the vertex shader.

For pixel shaders the invention provides 6 12 temporary registers for pixel shaders and a max instruction count of 512 for a program downloaded to a pixel shader representing increased flexibility over more constrictive prior art systems. The invention also provides a register storage element on a pixel shader and corresponding interfaces for specifying to the execution engine of the pixel shader that an incoming pixel data point is a frontward facing pixel or a backward facing pixel e.g. to achieve different effects for the front face of a triangle as opposed to the back face of a triangle. The invention also enables static and dynamic flow control for programs that are downloaded to a pixel shader whereby a coprocessor can receive a program which thereby programs the coprocessor to process data according to branches and conditions defined by the program and wherein the coprocessor can process data differently according to the different branches defined by the program. For instance according to criteria specified in the program the invention enables some of the data streaming through the pixel shader to be processed according to a first algorithm dependent upon the presence of a pre set constant or variable set or generated at runtime and some of the data according to a second algorithm without recourse to downloading another program.

As mentioned in the background existing vertex shaders do not support runtime predicated dynamic flow control of programs. Thus as illustrated in the invention enables a program to be defined with branches according to variables or context e.g. conditions a or b that will be known at runtime. In the exemplary program P depicted in after instruction the program specifies that if runtime behavior a is present instruction will be processed next followed by instruction and so on. After instruction the program specifies that if runtime behavior b is present instead instruction will be processed next followed by instruction etc. The representational flow of this branching behavior of program P loaded into vertex shader VS is depicted in . The graphics data is processed according to either runtime behavior a corresponding to condition a in program P or behavior b corresponding to condition b in program P and a programmer looking ahead to the runtime environment can dynamically control the flow or branching behavior associated with a program P for processing graphics data input to vertex shader VS. Providing more flexibility in program definition the invention thus enables each graphics data point input to vertex shader VS to be processed uniquely according to the dynamic flow.

Exemplary non limiting syntax for achieving existing static flow and dynamic flow in accordance with the invention for vertex shaders is as follows 

Calls can be nested 4 times 4 deep . CALLNZ predicated and the non predicated varieties count to this limit.

Calls can be nested 4 deep. CALLNZ predicated and CALL count to this limit. The BOOL register accepts only the NOT modifier.

For dynamic flow control the following exemplary instructions and corresponding exemplary non limiting restrictions may be used 

The IFC instruction is used to skip a block of code based on a condition. IFC block must end with ELSE or ENDIF instruction. IFC takes 2 slots. ifc else endifs along with the predicated if blocks can be nested up to 24 times 24 deep . SRC and SRC utilize a replicate swizzle. IFC blocks do not straddle a loop block an IFC block should be either completely inside the loop block or surrounding the loop block.

The IF instruction is used to skip a block of code based on a channel of the predicate register. An IF block ends with an ELSE or ENDIF instruction. IF blocks can be nested. This counts to the total dynamic nesting depth along with IFC blocks. An IF block does not straddle a loop block i.e. an IF block should be either completely inside a loop block or surrounding the loop block. Not modifiers are allowed on the predicate channel.

The CALLNZ instruction performs a conditional call based on the predicate channel. A NOT modifier can be applied. The instruction consumes one instruction slot. CALLNZ Calls can be nested 4 deep. This counts to the total CALL CALLNZ depth. The predicate register accepts the NOT modifier.

As mentioned with respect to vertex shaders VS also lack readable and writable register storage that is indexable by commands of a program downloaded to vertex shader VS. As illustrated in vertex shader VS of the invention includes indexable input registers I to I k 1 and output registers O to O m 1 . Thus as illustrated in a developer can write a program P that specifies operations for an entire bank of register storage by index. Previously a separate instruction would be required for each register to be affected by the indexed command whereas the indexing enables an operation to be performed across an array of non constant storage elements. Thus for the exemplary program P shown three operations are performed wherein an index value i increments from 0 to 2 simultaneously expressing multiple operations to be performed with the simple indexed command O i 2 I i .

As mentioned with earlier shader models only the constant register bank could be indexed. In one non limiting embodiment the shader model of the invention additionally enables the following register banks to be indexed using a loop counter register aL Input registers I k and Output registers O m . Since O k registers can be declared to have various semantics care is taken indexing them. If indexing of output registers is present in the shader for instance the position and psize semantics are declared in O and O respectively. Thus it may be undefined to index through O i registers that have been declared to have semantics position and or psize.

As implied output declarations are introduced whereby semantics are assigned to each register. Old oPos and oPts are replaced by declaring an o register with a position or pointsize semantic further described below.

In one embodiment there are 12 out registers. 10 of them any 10 not necessarily o o have 4 components x y z w another one is declared as position all 4 components and optionally one more can be a scalar pointsize.

In one non limiting embodiment the syntax for declaring outputs O registers is similar to declarations for the inputs as follows 

A similar set of semantics as for the input declaration can be used. Semantic names come from the enum D3DDECLUSAGE and are paired with an index e.g. position . As mentioned there is one O register with  position declaration when not used for processing vertices. The position semantic and the pointsize semantic are have meaning to the graphics API GAPI beyond simply enabling linkage from vertex to pixel shaders. For instance for shaders with flow control it is assumed that the worst case output is declared dcl d because there are no defaults if a shader does not actually output what it declares it should due to flow control.

The same out register may be dcl d multiple times so that different semantics can be applied to individual components each time with a unique write mask. However the same semantic may not be used multiple times in a declaration. Thus vectors are 4 components or less and do not transcend 4 component register boundaries individual out registers . When the  pointsize semantic is used it includes full write mask since it is considered a scalar. When the  position semantic is used it includes full write mask since all 4 components are written.

Since dynamic branching can take place as described above there is a potential for varying outputs per vertex. The output of the shader can also vary with static flow control.

With the increased precision of float representation of textures for look up by a vertex shader VS the invention enables displacement maps to be applied to data. Displacement maps represent perturbations in positional information with a high degree of precision. While a texture map can create a rough appearance of a surface the geometry itself may appear undesirably smooth at the edges. Accordingly a displacement map can perturb the geometry itself to create a more realistic rough effect. Previously vertex shaders did not include storage support for the float precision required of a displacement map and thus displacement maps are an example of the kind of increased flexibility that the graphics API of the present invention provides developers.

Also a new register has been introduced in vertex shader VS the sampler register that represents the vertex texture sampler. This register is defined in the shader before using it via graphics API GAPI. An application can query if a format is supported as a vertex texture by calling CheckDeviceFormat with the D3DUSAGE QUERY VERTEXTEXTURE flag. A vertex texture created in POOL DEFAULT can be set as a pixel texture and vice versa. In one embodiment to use the software vertex processing the vertex texture is created in the POOL SCRATCH regardless of whether it is a mixed mode device or a software vertex processing device .

In one non limiting embodiment the functionality is similar to the functionality of pixel textures except for the following A Anisotropic texture filtering is not supported. Hence D3DSAMP MAXANISOTROPY is ignored and D3DTEXF ANISOTROPIC cannot be set for neither MAGFILTER nor MINFILTER for these stages and B Rate of change information is not available and hence the application computes the level of detail LOD and provides that information as a parameter to the TEXLDL instruction.

In various non limiting alternate embodiments similar to pixel textures if MET textures are supported for vertex textures D3DSAMP ELEMENTINDEX is used to figure out from which element to sample. The state D3DSAMP DMAPOFFSET is ignored for these stages. Not all texture formats may be supported as vertex textures. Formats that support D3DUSAGE QUERY VERTEXTEXTURE can be used as vertex textures. The application can query whether support exists for a particular texture format with the CheckDeviceFormat API.

In various other non limiting alternate embodiments a caps field D3DCAPS9.VertexTextureFilterCaps indicates what kinds of filters are legal at the vertex texture samplers. D3DPTFILTERCAPS MINFANISOTROPIC and D3DPTFILTERCAPS MAGFANISOTROPIC are disallowed. Applications should also query if a format is supported as cube volume at a vertex texture sampler. Also there are no wrap modes for vertex texture coordinates since there is no connectivity information available inside a vertex shader.

A sampling stage register S identifies a sampling unit that can be used in texture load statements. A sampling unit corresponds to the texture sampling stage encapsulating the sampling specific state provided in the SetSamplerState API. In one embodiment there are 4 vertex samplers.

Each sampler uniquely identifies a single texture surface which is set to the corresponding sampler using the IDirect3DDevice9 SetTexture I IpTexture method. However the same texture surface can be set at multiple samplers.

At draw time a texture is not simultaneously set as a RenderTarget and a texture at a stage. In the embodiment wherein there are 4 samplers supported up to 4 texture surfaces may be read from in a single shader pass. A sampler register may appear as an argument in the texture load statement TEXLDL. In a preferred non limiting embodiment of the invention if a sampler is used it is declared at the beginning of the shader program using a DCL statement.

The ability to perform texture look ups with vertex shaders VS in accordance with the invention also supports software transformation and lighting T L . The software T L filter types supported can be checked by looking at the D3DCAPS9.VertexTextureFilterCaps field in the caps structure obtained by a call to the IDirect3DDevice9 GetDeviceCaps API in the software mode. Published texture formats are supported as vertex textures in software vertex processing.

An application can check if a particular texture format is supported in the software vertex processing mode by calling CheckDeviceFormat and providing D3DUSAGE QUERY VERTEXTEXTURE D3DUSAGE SOFTWAREPROCESSING as usage. All formats are supported for software vertex processing. POOL SCRATCH may be used for software vertex processing.

Exemplary non limiting API calls and syntax for achieving the above described texture operations with vertex shaders VS include 

Also in addition to the changes to the device driver interface DDI described below a new D3DFORMAT OP  has been added to DDI such that the drivers use to mark formats that the vertex texture sampler understands. These formats are then allowed to be used as vertex textures e.g. an application calls CheckDeviceFormat with the usage flag D3DUSAGE QUERY VERTEXTEXTURE . In a non limiting embodiment the usage flag is defined as follows 

With respect to output registers in one embodiment the various types of output registers are collapsed into 12 output registers O 2 for color 8 for texture 1 for position and 1 for fog and pointsize . These can be used for anything the user wishes to interpolate for the pixel shader texture coordinates colors fog etc.

As mentioned the invention improves upon the number of instruction slots that may be occupied by a program P for download to a vertex shader. In this regard devices that support the invention support at least 512 instruction slots. The maximum count of slots that is supported is indicated by the cap D3DCAPS9.MaxVertexShader30InstructionSlots. The maximum value that can be set on this cap is 32768. The number of instructions executed can be higher because of the looping support. The 3DCAPS9.MaxVShaderInstructionsExecuted cap applies as well and should be at least 2 16.

The total number of instructions executed can be clamped to the DDI only render state D3DRS MAXVERTEXSHADERINST. The legal values for this render state are numbers that are powers of 2 if any other integer is set the next nearest power of 2 number is assumed. In one embodiment this defaults to D3DINFINITEINSTRUCTIONS.

Table I below illustrates an exemplary non limiting implementation of registers for a vertex shader in accordance with the class of virtual machine defined by the invention.

Table I below illustrates an exemplary non limiting implementation of registers for a vertex shader in accordance with the class of virtual machine defined by the invention.

In Table I r corresponds to Read w corresponds to Write and u corresponds to Use. For a partial x y z w if only a subset of channels are updated in the register in one embodiment the remaining channels default to specified values x y z w . aL only register banks can be addressed using the aL register.

In Table I r corresponds to Read w corresponds to Write and u corresponds to Use. For a partial x y z w if only a subset of channels are updated in the register in one embodiment the remaining channels default to specified values x y z w . aL only register banks can be addressed using the aL register.

With respect to exemplary register defaults for a vertex shader use of uninitialized temporary address registers may be made illegal the result being undefined. A runtime debug component may attempt to detect such usage if there is no dynamic flow control and return a failure at Draw time. Other defaults are specified in the table above.

In one embodiment the DCL instruction occupies 0 instruction slots appears before the first arithmetic or addressing instruction in the shader program P and can be intermixed with def instructions which are the other type of instruction that resides at the beginning of a shader . dst is s for this type of dcl and a given s register can only be dcl d once. The component mask is not specified same as full mask and  textureType is one of 2d  cube and  volume. TEXLDL Texture lookup with a provided LOD see description herein relating to texture look ups in vertex shader 

Further input vertex element data is copied to the specified components if a corresponding stream declaration is found. The un declared components are not set to default values. Components that are specified in the input declaration are referenced in the vertex shader. If a component is declared but is not provided via the vertex declaration then it assumes the usual default value x y z default to 0 and w to 1 . Thus for the following exemplary input vertex declaration 

For SINCOS for an implementation that does not implement sincos natively taylor coefficients are set up in constants behind the scenes the 2 extra parameters to sincos are removed and the user does not need to provide them . Also components in dest writemask .x .y or .xy are the ones that are touched. Predication of this instruction may be orthogonal. SLT computes sign if less

With respect to DDI changes to vertex shaders in accordance with the invention a new DDI only Renderstate is provided 

The legal values for this renderstate are integers that are powers of 2 and if any other integer is set the next nearest power of 2 number is assumed. The new DDI only Renderstate Defaults to D3DINFINITEINSTRUCTIONS. Support for this feature involves an additional register instruction modifier and a new instruction.

With respect to the register an additional predicate register is supported. This is a boolean vector register that is modified via the Setup instruction defined below in Table II. IN one embodiment there are no defaults for this register so an application sets it prior to use.

For each channel that can be written according to the destination write mask the boolean result of the comparison operation between the corresponding channels of src and src is saved after the source modifier swizzles have been resolved . Source swizzles and destination write masks are heeded. In one embodiment the p register is the Dest token.

An instruction modifier with the predicate is also supported. This instruction modifier costs an additional instruction slot and exemplary non limiting syntax is as follows 

The destination write mask may be and ed joined with the per channel predicate boolean value and the data written back into the destination after the usual application of the instruction modifiers without side effects i.e. this update does not change the predicate register. Swizzles allowed inside the instruction modifier include full .xyzw or replicate .x .y .z .w . The presence of a inside the modifier reverses the meaning of the predicate bits.

In one non limiting embodiment the instruction modifier is syntactically present before the opcode but in the binary format it is the tailing token.

In one embodiment all instructions except the following can be predicated SETP IF ELSE ENDIF DCL DEF DEFI DEFB END CALL CALLNZ RET LOOP ENDLOOP REP ENDREP IFC BREAKC and BREAK.

With respect to predication s interaction with flow control predication can be used orthogonally with the dynamic and static flow control described above. IF CALLNZ and BREAKP accept the predicate register as a parameter also.

As mentioned in the background with respect to the state of the art currently does not support vertex stream frequency division. Thus as illustrated in the invention advantageously supports the ability to specify how often data is input for processing from respective vertex data streams VDS to VDSN i.e. to specify how many cycles of the execution engine of vertex shader VS are completed before receiving another data point from a designated vertex stream. For instance as specified via graphics API GAPI the data of vertex data stream VDS is processed one vertex every cycle whereas the data of vertex of vertex data stream VDSN is processed one vertex every three cycles. This might be useful for instance for processing triangles which have 3 vertices such that after processing every triangle a different data point from vertex data stream VDSN is input to the process.

In the older shader models including the fixed function the vertex shader was invoked once per vertex with every invocation the input registers were initialized with unique vertex elements from the vertex streams. The frequency division feature of the invention advantageously allows a subset of the input registers to be initialized at a less frequent rate.

Two exemplary non limiting APIs are introduced for the frequency division of vertex streams in accordance with the invention SetStreamSourceFrequency UINT StreamIndex UINT Frequency and a corresponding Get method. In one embodiment the Frequency is a value greater than zero and can be at most 2 16 1 WORD .

The application sets a frequency for a given stream and the elements in that stream are affected by this value. Frequency is after how many vertices is the data from that stream fetched into the vertex processing machine i.e. if it is 2 then the data from that stream is fetched into the Vn registers every 2 vertices of processing. In an exemplary embodiment the vertex offset in the VB is computed using the following formula VertexOffset StartVertex Divider StreamStride VertexIndex Divider StreamStride StreamOffset

It is noted that the division is an integer division that StartVertex which is provided in DrawPrimitive calls is also divided by the frequency divider and the state is recorded in state blocks as vertex state. Stream frequency may be ignored for indexed primitives.

As mentioned above the invention includes a method of using a vertex stream frequency divider via a graphics instancing API. The present invention provides an alternate improved method of frequency dividing by adding a stream modulo value. Instead of the frequency divider only applying to non indexed primitives as described below in exemplary non limiting detail the frequency divider and the modulo are extended to indexed primitives.

The goal of the instancing API is to allow drawing of multiple instances of the same object with different per instance data in one API call. The following changes have been made to the API to achieve this 

When using the instancing API the primitive count is usually equal to the number of instances multiplied to the number of primitives per instance. There is no reset of the primitive during a drawing call.

The stream divider modulo is ignored when the fixed function vertex pipeline or a vertex shader prior to the invention is used.

When the D3DSTREAMSOURCEMODULO bit is set in the Value then it represent a modulo value instead of a divider.

For indexed primitives any number of streams can have a modulo assigned to them and these values can be different.

For indexed primitives all modulo values assigned to streams are the same. The stream dividers is a multiple of the modulo value.

It is noted that the stream is indexed because the divider value is equal to one. The stream is not indexed.

Table III shows how slot counts for vertex shaders have evolved to the point of the present invention wherein model and model refer to previous shader models for comparison as follows 

As mentioned in the background in connection with a face register is not currently available for use in connection with a pixel shader. Thus as illustrated in a pixel shader PS in accordance with the invention in addition to including constants input and output registers etc. also includes a face register FR. As illustrated in this enables a program P downloaded to pixel shader PS to operate upon pixels in a way that takes its face whether forward or backward into account. This enables a shader program P for instance to perform one sided or double sided lighting effects. In one embodiment the face register is a floating point scalar register that may contain the primitive area or appropriate sign. Using the appropriate sign if the value is less than zero sign bit is set negative the primitive is the back face the area is negative CounterClockwise . Hence inside the pixel shader the application can make a decision as to which lighting technique to use. Two sided lighting can be achieved this way. In one embodiment this register requires a declaration e.g. by the setup engine SE or graphics API GAPI. The register FR may be undefined for lines and point primitives. The face register FR can be used with the setp and ifc instructions as one half of a comparison . In embodiments relying on the sign of the bit it makes sense to compare this register against 0 0 or 

A position register is also provided for pixel shaders in accordance with the invention including the current pixels x y in the corresponding channels. The z w channels are undefined. This register is declared. When multisampling the x y contain the pixel coordinates and not the sample coordinate multisampling happens once per pixel . When the driver performs super sampling and the pixel shader is run multiple times per pixel the x y should contain the resolved coordinate that is normalized by the render target bloat factor.

The Boolean and integer constants for pixel shaders in accordance with the invention can be set using an API defined in accordance with the invention and described in more detail below.

With respect to pixel shader input registers The input registers for pixel shaders in accordance with the invention fully support floating point and the t registers have been consolidated into the input registers. The DCL at the top of the shader is used to describe what is contained in a particular input register and a semantic for the pixel types is introduced. No clamping is performed when the input registers are defined as colors like texture coordinates . The evaluation of the registers defined as color differs from the texture coordinates when multisampling. These registers can be indexed using the aL register.

The same set of semantics as for the vertex shader output declaration can be used. Semantic names come from the enum D3DDECLUSAGE and are paired with an index i.e. position . The position semantic position and the pointsize semantic are not available for pixel shaders. For pixel shaders with flow control it is assumed that the worst case input is dcl d and that there are no defaults if a VS does not actually output what it declares in the input of the pixel shader.

Write masks allow packing of attributes. However the packing should match the vertex shader output declaration. Multiple semantics may be defined for individual input registers as long as the component masks are non overlapping. In one embodiment there are no defaults for missing components and it is validated that vertex shaders output at least enough data for what is requested by the corresponding pixel shader.

An optional instruction modifier that can be applied to the DCL instruction is  centroid. Exemplary use of the  centroid modifier is as follows 

To achieve flat shading when D3DRS SHADEMODE is D3DSHADE FLAT during clipping and triangle rasterization attributes with D3DDECLUSAGE COLOR are interpolated as flat shaded. If any components of a register are declared with the semantic name color but other components of the same register are given different semantics then turning on flat shading may result in undefined interpolation linear vs. flat on the components in that register with associated semantics other than color.

With respect to pixel shader output registers in accordance with the invention exemplary non limiting behavior is as described as follows. Output registers oC and oDepth can be written any number of times in accordance with the invention. The output of the pixel shader comes from the contents of the output registers at the end of shader execution. If a write to an output register does not happen perhaps due to flow control or if the shader did not write it the corresponding rendertarget is also not updated. If a subset of the channels in an output register are written then undefined values are written to the remaining channels.

Additionally the oC registers can be written with any writemasks in accordance with the invention. The renderstates D3DRS COLORWRITEENABLE D3DRS COLORWRITEENABLE1 D3DRS COLORWRITEENABLE2 and D3DRS COLORWRITEENABLE3 determine which components of oC ultimately get written to the rendertarget after blend if applicable . If the shader writes some but not all of the components defined by the D3DRS COLORWRITEENABLE renderstates for a given oC register then the defined but unwritten channels produce undefined values in the corresponding rendertarget. If NONE of the components of an oC are written the corresponding rendertarget is not updated as stated above so the D3DRS COLORWRITEENABLE renderstates do not apply in such case.

Table IV below illustrates an exemplary non limiting implementation of registers for a pixel shader in accordance with the class of virtual machine defined by the invention.

In Table IV r corresponds to Read w corresponds to Write and u corresponds to Use. For a partial x y z w if only a subset of channels are updated in the register in one embodiment the remaining channels default to specified values x y z w . aL only register banks can be addressed using the aL register.

With respect to pixel shader instruction count the invention supports at least 512 instruction slots. In one embodiment the maximum number of slot count that is supported is indicated by the cap D3DCAPS9.MaxPixelShader30InstructionSlots. The maximum value that can be set on this cap is 32768. The maximum number of instructions executed is indicated by the cap D3DCAPS9.MaxPShaderInstructionsExecuted which is at least 0xffff in accordance with a preferred embodiment. This cap can be set to D3DINFINITEINSTRUCTIONS indicating that the actual number of instructions executed is unlimited.

The total number of instructions executed can be clamped to the DDI only renderstate D3DRS MAXPIXELSHADERINST. The legal values for this renderstate are numbers that are powers of 2 if any other integer is set the next nearest pow2 number is assumed. This renderstate defaults to D3DINFINITEINSTRUCTIONS and there are no additional dependent read limits. In one embodiment there is no distinction between texture operations and arithmetic operations.

Swizzles on Samplers The sampler registers in the texture operations also accept swizzles. This is a way to indicate swizzling of the color channels looked up from the texture by the sampler.

When set on an input register declaration that is not a color diffuse or specular semantic the attribute evaluation is altered when multisampling. The attribute evaluation defines that the attribute is to be interpolated clamped in some fashion to the gamut of the attribute across the primitive when the multisample pixel center is not covered by the primitive. Care should be taken when an attribute marked with  centroid is used for texture sampling since normally the evaluation is performed at the pixel center. This has no effect on input registers with semantic color diffuse or specular i.e. these attributes are always evaluated as if the  centroid modifier is set.

The  centroid modifier can be also set on the texld instructions and dsx dsy instructions. When a texture coordinate is evaluated at the centroid the gradient information computed may not be accurate. When this hint is provided implementations can adjust this gradient computation to be more accurate.

In various embodiments abs and negate or both r.abs are supported on reads. If both are present the abs happens first.

As described in connection with in the background current pixel shaders cannot support programs that have either staticly defined branching or dynamically defined branching predicated on runtime behavior. Thus with respect to the instruction set included in a shader program to be downloaded to a pixel shader in accordance with the invention the shader program may achieve static flow control and dynamic flow control as illustrated in .

With respect to static flow control the functionality is the same as applies to static flow control for vertex shaders. In one embodiment the exception to this is that if else endif with boolean can be nested up to 24 deep.

With respect to dynamic flow control the functionality is the same as applies to dynamic flow control for vertex shaders. However in one non limiting implementation the output registers oDepth and oC of the pixel shader are not written within dynamic flow control and cannot be written using predication though writing to the outputs within static flow control is still alright in this implementation.

The DSX instruction computes the rate of change of a given src register in the x direction. In one embodiment the DSX instruction computes gradients on the current contents of registers in pixels regardless of whether pixels in gradient computation are active either due to flow control or due to being off the edge of a primitive. This implies that the pixels that are utilized for this instruction are executed in lockstep. Dest Token accepts all write masks. Src Token accepts all swizzles. Src modifiers negate abs abs neg are not allowed although the saturate instruction modifier is permitted.

The DSY instruction computes the rate of change of a given src register in the y direction. The DSY instruction computes gradients on the current contents of registers in pixels regardless of whether pixels in gradient computation are active either due to flow control or due to being off the edge of a primitive. This implies that the pixels that are required for this instruction are executed in lockstep. Dest Token accepts all write masks. Src token accepts all swizzles. Src modifiers negate abs absneg are not allowed although the saturate instruction modifier is permitted.

The TEXLDD instruction samples a texture using the texture coordinates at SRC the sampler specified by Src and the gradients DSX and DSY coming from SRC and Src. In various embodiments all sources support arbitrary swizzles and all write masks are valid on the destination. D3DSAMP MAXMIPLEVEL and D3DSAMP MIPMAPLODBIAS are honored. SRC can only be a sampler register.

For the texture load statement all sources support arbitrary swizzles. All write masks are valid on the destination. In one embodiment the bias value in the TEXLDB instruction can range between 16.0 15.0 and bias values outside this range produce undefined results.

Using provided texture coordinates the TEXTDL instruction for pixel shaders samples a texture at a particular sampler. The particular LOD being sampled is specified as the 4th component of the texture coordinate. src provides the texture coordinates for the texture sample. src identifies the sampler s where specifies which texture sampler number to sample. Associated with a sampler are 1 a texture and 2 control state defined by the D3DSAMPLERSTATETYPE enumerant e.g. D3DSAMP MINFILTER .

TEXTDL looks up the texture set at the sampler stage referenced by src. The LOD is not computed simply src.w is the LOD that is selected. This value can be negative in which case the LOD selected is the zero th one biggest map with the MAGFILTER. Since src.w is a floating point value the fractional value is used to interpolate if MIPFILTER is LINEAR between two mip levels. Sampler states MIPMAPLODBIAS and MAXMIPLEVEL are honored.

In one embodiment if a shader program samples from a sampler that does not have a texture set then 0001 is obtained in the destination register.

The following exemplary algorithm that the reference rasterizer refract follows is provided for reference 

In general the texture coordinates should not be scaled by texture size. dst is r and can accept a writemask. In various non limiting embodiments defaults for missing components are either 0 or 1 and depend on the texture format. Refrast source lists the defaults. srcl is s with no negate but it can support swizzle. The s is dcl d at the beginning of the shader program.

The number of coordinates required to perform the texture sample depends on how the s was dcl d. If it was dcl d as a cube a 3 component texture coordinate is used .rgb . Sampling a texture with lower dimensions than are present in the texture coordinate is allowed and it is assumed to ignore the extra texture coordinate components. Conversely sampling a texture with higher dimensions than are present in the texture coordinate cannot be performed.

In various non limiting embodiments the following conditions apply. If src texture coordinate is r the components required for the lookup described above must have been previously written. Sampling unsigned RGB textures results in float values between 0.0 and 1.0. Sampling signed textures results in float values between 1.0 to 1.0. For sampling floating point textures Float16 MAX FLOAT16 range preserved and Float32 Max range of pipeline preserved. There is no dependent read limit. Additional instructions for pixel shaders include 

An implementation that does not support SINCOS natively sets up taylor coefficients in constants behind the scenes. Only components in dest writemask .x .y or .xy are touched and predication of SINCOS is orthogonal.

Software implementations runtime and ref for VS and ref for PS of shaders have some validation relaxed in accordance with the invention which can be useful for debugging and prototyping purposes.

With respect to pixel shader core precision requirements the invention supports a mechanism that applications use to choose between full precision and partial precision hardware processing capabilities on hardware that supports this choice.

The pixel shader virtual machine of the invention provides support for 2 levels of precision Full precision fp32 or higher this precision level is required and must be supported by the implementation and Partial precision  pp fp16 s10e5 this precision level is optional and need not be supported by the implementation.

By default all operations occur at the full precision level the mechanism for overriding this default is the  pp modifier which may be used by shader code to indicate areas where the application deems partial precision acceptable provided that the underlying implementation supports it. Implementations are always free to ignore the modifier and perform the affected operations in full precision.

The  pp modifier can occur in two contexts 1 On a texture coord decl to enable texture coordinates to be passed to the pixel shader in partial precision form. This allows for example the use of texture coordinates to relay color data to the pixel shader which may be faster with partial precision than with full precision in some implementations. In the absence of this modifier texture coordinates must be passed in full precision and 2 On any instruction to request the use of partial precision including texture load instructions. This indicates that the implementation is allowed to execute the instruction with partial precision and store a partial precision result. In the absence of an explicit modifier the instruction is performed at full precision regardless of the precisions of the input operands .

In addition to scenarios where an application might deliberately choose to trade off precision for performance there are several kinds of shader input data which present themselves with less precision and which are natural candidates for partial precision processing. For instance color iterators are accurately represented by partial precision values or less though no less than 8 bit . Texture values from most formats also can be accurately represented by partial precision values values sampled from 32 bit floating point format textures are an obvious exception . Constants may be represented by partial precision representation as desired.

In all these cases the developer may choose to use  pp instructions to process the data knowing that no input data precision is lost with the caveat that in some situations numerical considerations may require that some internal steps of a calculation be performed at full precision even when input and final output values do not have more than partial precision. 

Table V shows how slot counts for pixel shaders have evolved to the point of the present invention wherein model and model refer to previous shader models for comparison as follows 

One of ordinary skill in the art can appreciate that the invention can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment. In this regard the present invention pertains to any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes which may be used in connection with processes for downloading algorithmic elements to a coprocessor in accordance with the present invention. The present invention may apply to an environment with server computers and client computers deployed in a network environment or distributed computing environment having remote or local storage. The present invention may also be applied to standalone computing devices having programming language functionality interpretation and execution capabilities for generating receiving and transmitting information in connection with remote or local services and processes. Graphics data such as images e.g. photos and video e.g. movies advertisements etc. continue to proliferate on networks and may be particularly relevant to those computing devices operating in a network or distributed computing environment and thus the techniques for downloading algorithmic elements to a coprocessor in accordance with the present invention can be applied with great efficacy in those environments.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may implicate the systems and methods for downloading algorithmic elements to a coprocessor of the invention.

It can also be appreciated that an object such as may be hosted on another computing device etc. or etc. Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many of the networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures may be used for exemplary communications made incident to downloading algorithmic elements to a coprocessor according to the present invention.

In home networking environments there are at least four disparate network transport media that may each support a unique protocol such as Power line data both wireless and wired voice e.g. telephone and entertainment media. Most home control devices such as light switches and appliances may use power lines for connectivity. Data Services may enter the home as broadband e.g. either DSL or Cable modem and are accessible within the home using either wireless e.g. HomeRF or 802.11B or wired e.g. Home PNA Cat 5 Ethernet even power line connectivity. Voice traffic may enter the home either as wired e.g. Cat 3 or wireless e.g. cell phones and may be distributed within the home using Cat 3 wiring. Entertainment media or other graphical data may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that may emerge as protocol standards may be interconnected to form a network such as an intranet that may be connected to the outside world by way of the Internet. In short a variety of disparate sources exist for the storage and transmission of graphics data and consequently moving forward computing devices will require ways of sharing data such as data accessed or utilized incident to program objects which may be downloaded to a coprocessor in accordance with the present invention.

The Internet commonly refers to the collection of networks and gateways that utilize the TCP IP suite of protocols which are well known in the art of computer networking. TCP IP is an acronym for Transmission Control Protocol Internet Protocol. The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the network s . Because of such wide spread information sharing remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services essentially without restriction.

Thus the network infrastructure enables a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. Thus in computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of computers etc. can be thought of as clients and computers etc. can be thought of as the server where server etc. maintains the data that is then replicated in the client computers etc. although any computer can be considered a client a server or both depending on the circumstances. Any of these computing devices may be processing data or requesting services or tasks that may implicate the interfaces associated with downloading programs to coprocessors in accordance with the invention.

A server is typically a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects utilized pursuant to the techniques for downloading algorithmic elements to a coprocessor of the invention may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

Thus illustrates an exemplary networked or distributed environment with a server in communication with client computers via a network bus in which the present invention may be employed. In more detail a number of servers etc. are interconnected via a communications network bus which may be a LAN WAN intranet the Internet etc. with a number of client or remote computing devices etc. such as a portable computer handheld computer thin client networked appliance or other device such as a VCR TV oven light heater and the like in accordance with the present invention. It is thus contemplated that the present invention may apply to any computing device in connection with which it is desirable to download algorithmic elements to a coprocessor.

In a network environment in which the communications network bus is the Internet for example the servers etc. can be Web servers with which the clients etc. communicate via any of a number of known protocols such as HTTP. Servers etc. may also serve as clients etc. as may be characteristic of a distributed computing environment.

Communications may be wired or wireless where appropriate. Client devices etc. may or may not communicate via communications network bus and may have independent communications associated therewith. For example in the case of a TV or VCR there may or may not be a networked aspect to the control thereof. Each client computer etc. and server computer etc. may be equipped with various application program modules or objects and with connections or access to various types of storage elements or objects across which files or data streams may be stored or to which portion s of files or data streams may be downloaded transmitted or migrated. Any one or more of computers etc. may be responsible for the maintenance and updating of a database or other storage element such as a database or memory for storing data processed according to the invention. Thus the present invention can be utilized in a computer network environment having client computers etc. that can access and interact with a computer network bus and server computers etc. that may interact with client computers etc. and other like devices and databases .

Although not required the invention can be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates in connection with methods for downloading algorithmic elements to a coprocessor of the invention. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations and protocols. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more coprocessors such as graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory wherein the methods for downloading algorithmic elements to a coprocessor of the invention have particular impact. GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer and may include a variety of procedural shaders such as pixel and vertex shaders. A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s managed code platform i.e. .NET includes servers building block services such as Web based data storage and downloadable device software. Generally speaking the .NET platform provides 1 the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them 2 increased interactive capability for Web pages enabled by greater use of XML rather than HTML 3 online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications such as e mail for example or software such as Office .NET 4 centralized data storage which increases efficiency and ease of access to information as well as synchronization of information among users and devices 5 the ability to integrate various communications media such as e mail faxes and telephones 6 for developers the ability to create reusable modules thereby increasing productivity and reducing the number of programming errors and 7 many other cross platform and language integration features as well.

While some exemplary embodiments herein are described in connection with software such as an application programming interface API residing on a computing device one or more portions of the invention may also be implemented via an operating system or a middle man object a control object hardware firmware intermediate language instructions or objects etc. such that the methods for downloading algorithmic elements to a coprocessor in accordance with the invention may be included in supported in or accessed via all of the languages and services enabled by managed code such as .NET code and in other distributed computing frameworks as well.

A programming interface or more simply interface may be viewed as any mechanism process protocol for enabling one or more segment s of code to communicate with or access the functionality provided by one or more other segment s of code. Alternatively a programming interface may be viewed as one or more mechanism s method s function call s module s object s etc. of a component of a system capable of communicative coupling to one or more mechanism s method s function call s module s etc. of other component s . The term segment of code in the preceding sentence is intended to include one or more instructions or lines of code and includes e.g. code modules objects subroutines functions and so on regardless of the terminology applied or whether the code segments are separately compiled or whether the code segments are provided as source intermediate or object code whether the code segments are utilized in a runtime system or process or whether they are located on the same or different machines or distributed across multiple machines or whether the functionality represented by the segments of code are implemented wholly in software wholly in hardware or a combination of hardware and software.

Notionally a programming interface may be viewed generically as shown in or . illustrates an interface InterfacA as a conduit through which first and second code segments communicate. illustrates an interface as comprising interface objects I and I which may or may not be part of the first and second code segments which enable first and second code segments of a system to communicate via medium M. In the view of one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although show bi directional flow and interfaces on each side of the flow certain implementations may only have information flow in one direction or no information flow as described below or may only have an interface object on one side. By way of example and not limitation terms such as application programming interface API entry point method function subroutine remote procedure call and component object model COM interface are encompassed within the definition of programming interface.

Aspects of such a programming interface may include the method whereby the first code segment transmits information where information is used in its broadest sense and includes data commands requests etc. to the second code segment the method whereby the second code segment receives the information and the structure sequence syntax organization schema timing and content of the information. In this regard the underlying transport medium itself may be unimportant to the operation of the interface whether the medium be wired or wireless or a combination of both as long as the information is transported in the manner defined by the interface. In certain situations information may not be passed in one or both directions in the conventional sense as the information transfer may be either via another mechanism e.g. information placed in a buffer file etc. separate from information flow between the code segments or non existent as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation e.g. depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration and so this list should be considered illustrative and non limiting.

This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are however other ways to implement a programming interface and unless expressly excluded these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown some interfaces can be described in terms of divisible sets of functionality. Thus the interface functionality of may be factored to achieve the same result just as one may mathematically provide 24 or 2 times 2 time 3 times 2. Accordingly as illustrated in the function provided by interface InterfacA may be subdivided to convert the communications of the interface into multiple interfaces InterfacAA Interface B Interface C etc. while achieving the same result. As illustrated in the function provided by interface I may be subdivided into multiple interfaces II I etc. while achieving the same result. Similarly interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I I I etc. When factoring the number of interfaces included with the 1code segment need not match the number of interfaces included with the 2code segment. In either of the cases of the functional spirit of interfaces InterfacA and I remain the same as with respectively. The factoring of interfaces may also follow associative commutative and other mathematical properties such that the factoring may be difficult to recognize. For instance ordering of operations may be unimportant and consequently a function carried out by an interface may be carried out well in advance of reaching the interface by another piece of code or interface or performed by a separate component of the system. Moreover one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.

In some cases it may be possible to ignore add or redefine certain aspects e.g. parameters of a programming interface while still accomplishing the intended result. This is illustrated in . For example assume interface InterfacA of includes a function call Square input precision output a call that includes three parameters input precision and output and which is issued from the 1Code Segment to the 2Code Segment. If the middle parameter precision is of no concern in a given scenario as shown in it could just as well be ignored or even replaced with a meaningless in this situation parameter. One may also add an additional parameter of no concern. In either event the functionality of square can be achieved so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system however once it is recognized that precision is not necessary for the narrow purpose of calculating the square it may be replaced or ignored. For example instead of passing a valid precision value a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly as shown in interface I is replaced by interface I redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I redefined to ignore unnecessary parameters or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects such as parameters that are not needed for some purpose and so they may be ignored or redefined or processed elsewhere for other purposes.

It may also be feasible to merge some or all of the functionality of two separate code modules such that the interface between them changes form. For example the functionality of may be converted to the functionality of respectively. In the previous 1and 2Code Segments of are merged into a module containing both of them. In this case the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus for example formal Call and Return statements may no longer be necessary but similar processing or response s pursuant to interface InterfacA may still be in effect. Similarly shown in part or all of interface I from may be written inline into interface I to form interface I . As illustrated interface is divided into Iand I and interface portion Ihas been coded in line with interface I to form interface I . For a concrete example consider that the interface I from performs a function call square input output which is received by interface I which after processing the value passed with input to square it by the second code segment passes back the squared result with output. In such a case the processing performed by the second code segment squaring input can be performed by the first code segment without a call to the interface.

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in one or more piece s of middleware Divorce Interface s since they divorce functionality and or interface functions from the original interface are provided to convert the communications on the first interface InterfacA to conform them to a different interface in this case interfaces InterfacBA InterfacBB and InterfacBC. This might be done e.g. where there is an installed base of applications designed to communicate with say an operating system in accordance with an InterfacA protocol but then the operating system is changed to use a different interface in this case interfaces InterfacBA InterfacBB and InterfacBC. The point is that the original interface used by the 2Code Segment is changed such that it is no longer compatible with the interface used by the 1Code Segment and so an intermediary is used to make the old and new interfaces compatible. Similarly as shown in a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to for example interfaces Iand I redesigned to work with DI but to provide the same functional result. Similarly DI and DI may work together to translate the functionality of interfaces I and I of to a new operating system while providing the same or similar functional result.

Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example there may be a system in which a code segment presented in an intermediate language e.g. Microsoft IL Java ByteCode etc. is provided to a Just in Time JIT compiler or interpreter in an execution environment such as that provided by the .Net framework the Java runtime environment or other similar runtime type environments . The JIT compiler may be written so as to dynamically convert the communications from the 1Code Segment to the 2Code Segment i.e. to conform them to a different interface as may be required by the 2Code Segment either the original or a different 2Code Segment . This is depicted in . As can be seen in this approach is similar to the Divorce scenario described above. It might be done e.g. where an installed base of applications are designed to communicate with an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed base applications to the new interface of the operating system. As depicted in this approach of dynamically rewriting the interface s may be applied to dynamically factor or otherwise alter the interface s as well.

It is also noted that the above described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways serially and or in parallel or with other intervening code. Thus the alternative embodiments presented above are not mutually exclusive and may be mixed matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that as with most programming constructs there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein but nonetheless are represented by the spirit and scope of the invention i.e. it is noted that it is at least partly the functionality represented by and the advantageous results enabled by an interface that underlie the value of an interface.

There are multiple ways of implementing the present invention e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to use the systems and methods for downloading algorithmic elements to a coprocessor of the invention. The invention contemplates the use of the invention from the standpoint of an API or other software object as well as from a software or hardware object that receives a downloaded program in accordance with the invention. Thus various implementations of the invention described herein may have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

As mentioned above while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to download algorithmic elements to a coprocessor. For instance the algorithm s and hardware implementations of the invention may be applied to the operating system of a computing device provided as a separate object on the device as part of another object as a reusable control as a downloadable object from a server as a middle man between a device or object and the network as a distributed object as hardware in memory a combination of any of the foregoing etc. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code and nomenclature that achieves the same similar or equivalent functionality achieved by the various embodiments of the invention.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the graphics API GAPI of the present invention e.g. through the use of a data processing API reusable controls or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer etc. the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example while exemplary network environments of the invention are described in the context of a networked environment such as a peer to peer networked environment one skilled in the art will recognize that the present invention is not limited thereto and that the methods as described in the present application may apply to any computing device or environment such as a gaming console handheld computer portable computer etc. whether wired or wireless and may be applied to any number of such computing devices connected via a communications network and interacting across the network. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Gaming consoles for instance ever on the cutting edge of graphics rendering are particularly relevant to the flexible and fast coprocessing enabled by the invention.

While exemplary embodiments refer to utilizing the present invention in the context of particular programming language constructs the invention is not so limited but rather may be implemented in any language to provide methods for downloading algorithmic elements to a coprocessor. It will be appreciated that while generally vertex shaders have been described herein as operating upon vertex data and while generally pixel shaders have been described herein as operating upon pixel data procedural shaders may also be used to process graphics data in other ways where the processing task and associated data can leverage the processing and memory access speed enabled by today s GPUs. Still further the present invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

