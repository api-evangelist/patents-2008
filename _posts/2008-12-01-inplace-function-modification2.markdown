---

title: In-place function modification
abstract: Modifying computer program code can be performed at or immediately prior to runtime of the computer code in a runtime environment of a common language infrastructure of a language-neutral framework for developing and executing computer applications. A function in a computer program can be modified at runtime by injecting arbitrary code, while mitigating an alteration of a program's call stack. A just-in-time compilation service is used to compile and execute intermediate language code of the program, and the runtime environment sends callback functions to an event-based profiling agent (profiler) attached to the runtime environment. The profiler can trap desired functions, as determined by configuration data, and inject modification code from stub methods in a stub assembly file. The modified code can be sent back to the runtime environment to be executed by the just-in-time compilation service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09645912&OS=09645912&RS=09645912
owner: Microsoft Technology Licensing, LLC
number: 09645912
owner_city: Redmond
owner_country: US
publication_date: 20081201
---
In a computing environment a language neutral computing framework can be created by a software technology that manages execution of programs developed within the framework. Within this type of framework high level computer code can be compiled to an intermediate language such as an object oriented assembly language which is common to the framework regardless from which high level programming language it was compiled. This type of environment is often called a common language infrastructure which can provide a language neutral platform for application development and execution. The language neutral platform can support a runtime environment for executing programs developed within the framework that can provide a sort of application virtual machine for running applications.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

When a computer program debugger or tester wishes to diagnose performance of functions in the program they can modify code in the program code. Modifying code can be used among other things to test faults change an operation in the program or perform code coverage testing. Typically modifying code can be injected into an existing program before compiling the computer code to a machine level language and code coverage of the programs functions can be determined at runtime for example. However code modification may also cause some unintentional side affects to the operation of the program such as creating additional calls and adding parameters that add to the overhead of running a program. Further adding or modifying code may alter code stacks for the program changing stepping and breakpoints.

Modifying code can also be performed at or immediately prior to runtime of the computer code. Several variations currently exist where modifying code can be injected during compilation from a high level language to either an intermediate language or machine language. Further where a just in time JIT compilation service is utilized e.g. where intermediate code is compiled to machine code during program runtime modifying code can be injected to change functions chosen by a user immediately prior during the JIT service operation. However current techniques for runtime code modification typically utilize modules of intermediate language code that have been pre defined for a specified platform or the modifications are created by a user in intermediate language on the fly when a desired function is identified in the program. Further current techniques for runtime code modification may also require creating modules in native code for the execution platform.

Techniques and systems are provided herein for accessing and modifying functions of a program at runtime by injecting arbitrary code from a separate file while mitigating altering a call stack of the code by running the injected code in a same stack frame as original code. In one embodiment one can modify a function in a computer code which is being executed by a computer system while mitigating a change to functionality of the computer code. Although some of the discussion herein relates to diagnostic applications it will be appreciated that other applications are contemplated and that diagnostics is merely one example.

In this embodiment a just in time JIT compilation service can be used which can convert intermediate language IL code at runtime prior to executing it natively. The JIT service can be used in a runtime environment of a common language infrastructure for executing a computer program that was compiled to the IL. Further in this embodiment an event based profiling agent profiler can be attached to the runtime environment of the common language infrastructure and used to detect and modify for example user selected functions in the IL of the computer code prior to compilation to machine code.

In this embodiment detecting the selected functions being compiled by the JIT service for example can be performed by comparing function callbacks from the profiler to user defined configuration data that identifies the functions. In this example the configuration data can be located in a file separate from the computer program being executed. Further modifying the detected function can be performed by injecting modifying IL code from for example user generated stub methods located in a stub assembly. In this example the stub assembly may be located in a file separate from the computer program. Additionally the modifying code may comprise prologue code injected prior to the desired function code and or epilogue code injected after the desired function code.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

In this example computing environment the CLI comprises a high level language compiler which can be used to compile high level language code to intermediate language IL code that is common for the CLI . For example any high level language used within the computing framework can be assembled into a common bytecode that can be executed within the CLI regardless of which high level language the IL was compiled from.

In the example computing environment the IL code can be sent to a runtime environment of the CLI which can execute the IL code . The runtime environment can act as a type of virtual machine within the CLI to compile the IL code to native code for the operating system running on a computer system for example and execute the code to run the application. The runtime environment can comprise a just in time JIT compilation service e.g. also known as a dynamic translator that is designed to convert IL code to native machine code at runtime of a program. Essentially for example when the program is initiated within the runtime environment its code is compiled to machine code and the machine code is executed by the JIT service while the program is running . This type of JIT compilation typically allows for an improved runtime performance of a computer program.

One embodiment of the computing environment described above is Microsoft .NET framework. .NET utilizes a CLI that comprises one or more high level language compilers for compiling computer programs written in a high level language to the CLI s common intermediate language CIL . The .NET CLI also comprise a Common Language Runtime CLR which is the virtual machine component of the .NET framework for executing the computer program. In this embodiment the CLR utilizes a JIT compilation service for compiling the CIL to native code and executing the native code at runtime of the computer program.

In another embodiment Sun Microsystem Java framework utilizes a similar environment whereby high level programming is compiled to a Java specific intermediate language. In this embodiment a Java Runtime Environment JRE comprises a Java Virtual Machine JVM that can compile and execute the intermediate language at runtime of a computer program.

In one aspect a user may wish to modify a function in a computer program for example at runtime of the program within a common language infrastructure CLI without changing key operations of the program. In one embodiment an event based profiling agent profiler can be attached e.g. as a COM server to the runtime environment of the CLI. In this embodiment the runtime can then provide method callbacks into the profiler which can trap events such as functions going through JIT compilation.

As an example a language neutral platform such as a CLI typically provides a large library of pre coded solutions to common programming issues. In this example a computer program may include code that calls to a function in the software library of the CLI and when executed that function can be called back from the library to the program. In this way by retrieving callbacks of functions that are proceeding through the JIT compilation from intermediate language IL code to native code one may be able to identify functions that they wish to modify prior to execution.

At an event based profiling agent profiler can be used in the runtime environment e.g. attached to the runtime environment of the CLI to trap and modify a desired function in the IL of the computer code prior to compilation to machine code. For example during runtime of the computer program the profiler can be used to identify a function that a user wishes to modify trap the function and then modify the function prior to it being compiled and executed by the computer system.

At in order to identify the desired function to be trapped prior to compiled by the JIT configuration data from a configuration file can be applied to the event based profiling agent which identifies one or more functions desired for modification in the IL of the computer code. As an example a user may wish to modify one or more desired functions in a computer program prior to JIT compilation. In this example the user can create a configuration file that comprises profiler configuration data identifying the desired functions. Further in this example while the profiler may operate independently from a user created configuration file the configuration data can be used by the profiler to identify merely those functions desired to be trapped and modified by the user.

At a desired function that is to be compiled by the JIT service can be trapped by the event based profiling agent by comparing callbacks of functions from the runtime environment of the CLI with event based profiling agent configuration data. As an example code in the program being executed in the runtime environment may call to functions in the CLI software library as described above. In this example the runtime environment can provide the callbacks of the functions to the profiler which can compare them with the configuration data provided from a user created configuration file. In this way in this example the profiler can trap merely those functions that are identified by the configuration data.

At in the exemplary method modifying intermediate language code from one or more stub methods from a stub assembly file can be injected into the trapped desired function s intermediate language code prior to machine code compilation of the desired function. For example a user may be utilizing a language neutral computing platform such as the .NET CLI to develop a computer program in a particular high level language e.g. C . In this example the user can also write a set of stub methods as a separate stub assembly file in a high level language that compiles to the IL e.g. could be a same or different language than that of a base computer program . The CLI can compile the computer program and the stub assembly file to an IL e.g. .NET CIL . Further in this example the sub method code now in IL can be injected into the computer program s code at the desired function which is also in IL.

The stub method code injected can comprise at least one of prologue code injected directly preceding the desired function at epilogue code injected directly after the desired function at and arbitrary code injected at an arbitrary offset inside the desired function at . For example the user may create a stub module that comprises a cutline that calls to the desired function with prologue code prior to the cutline and or epilogue code after the cutline. In this way in this example if present the prologue code can be injected e.g. merged into the code for the desired function in the stub method and the epilogue code can be injected after the code for the desired function. Additionally in another example code may be inserted within a body of the desired function to intercept a return value e.g. and or change the return value after a call to the library function. A user may wish to use epilogue code for example to determine what happens when the desired function code is run unaltered then the epilogue code is run. Further the user may wish to determine what happens when the desired function is altered by the prologue code or a combination of both.

In one embodiment for example a user may wish to inject prologue and or arbitrary code to inspect a desired function s argument and or to alter the arguments in a desired manner. Further in this example prologue code may be use to report out e.g. to a database designed by the user when the desired function has been executed and mark a time of execution. Additionally in another embodiment epilogue code can be used to inspect return values from the desired function report other code execution and a variety of other purposes. It will be appreciated that a desired function modification code e.g. prologue epilogue and arbitrary code can be used for a variety of function inspection alteration and inspection purposes and the techniques and systems described herein are not limited to the embodiments described above. Those skilled in the art may devise alternate modification code purposes.

In order to execute the computer program code the IL is sent into the runtime environment of the CLI which comprises a just in time compilation service JIT . As described above the JIT compiles the IL code to machine code native code at runtime of the program. However in this exemplary environment when the computer program calls to predefined functions e.g. or any function about to be compiled from IL to machine code in the library of the runtime environment the function callbacks are sent to a profiler that is attached to the runtime environment instead of immediately back to the JIT . Further the profiler has been updated with configuration data e.g. from a separate file created by the user that comprises information to identify those functions called by the program that a user may be interested in modifying.

In this example the profiler can compare the function callbacks sent from the runtime environment with the configuration data to identify a user desired function. Once a desired function has been identified the profiler can trap the function callback and retrieve a corresponding stub method from a stub assembly file e.g. that has been created by the user and compiled from a high level language to the IL . In one embodiment a user e.g. a third party user or framework provider may create a stub module that can be injected into one or more of the desired functions. In another embodiment the user may create stub modules for respective desired functions.

The profiler can then merge the stub module code from the stub assembly with the trapped desired function callback to create merged code . In this embodiment the merged code comprises the original function from the runtime environment library and prologue and or epilogue code. The merged code is then sent back to the runtime environment by the profiler to be compiled and executed by the JIT . Further function callbacks that are not desired by the user to be modified would be released back to the JIT without modification e.g. not trapped by the profiler . In this way in this embodiment the profiler can modify the computer code at runtime for example. By injecting the modification code in place in this example the modified code can be run in a same stack frame as the original code without altering the program s call stack.

In one aspect functions that a user desires to modify prior to JIT compilation for example may comprise branches and or exception handling blocks. Further the modifying stub methods may also comprise branches and or exception handling blocks. In this aspect the modified function code should include respective branches and or exception handling blocks if present along with any instructions to which they may point. In one embodiment in order to identify potential branches and or exception handling blocks in the code for the desired function and stub method the respective code can be represented as a directed graph.

In this embodiment for example intermediate language IL code for both the function to be modified and the modifying stub method can be parsed by the event based profiling agent profiler attached to the runtime environment of the common language infrastructure CLI . Further in this example once parsed a directed graph of the code can be represented internally by the profiler. In this way instructions to which the branches and or exception handling blocks if present point to can be identified and moved into a rewritten modified function along with the branches and or exception handling blocks for example. In this embodiment allowing for this type of code parsing and identification of appropriate code can facilitate easier and more efficient code rewriting for directing a change of a binary IL stream e.g. JIT compilation and execution of modified functions .

In another aspect a high level language compiler in a CLI of a language neutral framework typically generates metadata that refers to particular data structures that may be embedded in the code of the intermediate language IL when it is compiled from a high level language. In this aspect this metadata can describe a method classes and class members e.g. the high level structure of the code defined in the assembly of the IL along with those called from other assemblies within the CLI. The metadata generated by the high level language compiler is typically stored in an assembly that comprises the IL for a compiled program. When the JIT executes the IL the runtime environment can utilize a metadata inspection application programming interface API to check metadata tokens signatures of a called method to determine whether they match the metadata stored in the IL of the method that is doing the calling.

In this aspect in one embodiment when code from a modifying stub method is injected e.g. merged with into code from a function that is desired to be modified the profiler can utilize the metadata inspection API to resolve information from assembly metadata tokens e.g. signatures from the stub method code in order to create appropriate IL code for the merged modified function. In this embodiment for example resolving appropriate information for the metadata tokens from the stub method code can result in IL code for the modified function that is semantically equivalent to the desired function thereby enabling a called modified e.g. including the stub method code method to execute as described above.

Further in one embodiment a profiler used to modify a desired function can utilize a metadata token emission API which is compatible with that portion of the framework s high level language compiler to generate metadata tokens at compilation for example. In this way in this example after the appropriate metadata token information is resolved for the stub method code compatible and appropriate metadata tokens can be created for the modified functions and copied to the merged code which can allow the modified code to execute at runtime.

At intermediate language IL code for both the desired function and modifying stub method are parsed. For example the IL code can be broken down into respective elements and represented internally e.g. within the profiler as a directed graph which may allow the profiler to identify branches and or exception handling blocks in the code. At if branches and or exception handling blocks are present in the IL code instructions to which they point can be copied by the profiler to the modified code. For example when branches are executed and or exceptions are thrown they typically lead to a set of code instructions that may lead away from a main body of the code. In this example one may wish to copy into the merged code.

At if instructions have been copied for branches and or exception handling blocks that may be present connections between the instructions can be identified in order to preserve branch and exception handling structure in the code for the modified function e.g. along with respective instruction for the stub method . At information that resolves framework appropriate metadata tokens e.g. signatures for the stub method code is identified using a metadata inspection API. For example the created metadata tokens should be able to match tokens from a method calling to the stub method code. At appropriate assembly metadata tokens for the stub method code are created by a metadata token emission API based on the information from the metadata inspection API and copied to the rewritten merged code for the modified function.

At callbacks of functions that are called by the code being executed by the JIT are sent to a profiler attached to the runtime environment. For example the CLR of .NET comprises a library of pre coded functions that can be called by a program being executed by the JIT. When the program calls to one of these functions in the library for example the CLR can send the function callback to the attached profiler. At the function callback can be compared to configuration data that was used to configure the profiler which identifies those functions that are desired to be modified prior to execution. In one example the configuration data can be loaded to the profiler from a separate configuration file created by a third party e.g. user .

If the called function is not a desired function at it is sent back to the JIT where is the function is compiled to machine code and executed at runtime at . If the called function is a function that has been targeted for modification at it is trapped by the profiler for modification at . A stub method that corresponds to the trapped function is retrieved from a stub assembly at . In one embodiment a user can create a stub assembly file that can comprise one or more stub methods used to modify a corresponding target function. In this embodiment the profiler can retrieve the stub method from the assembly that the user has designated for the trapped function. In another embodiment the assembly may comprise one stub method that can be used for respective trapped functions.

At the IL code from the stub method and trapped function are merged to create modified function IL code. Merging the stub method and desired function comprises inserting prologue code if present in the stub method prior to the desired function at which may further comprise merging branches and or exception handling blocks and the instructions to which they point if present in the prologue code at . Further merging the stub method and desired function comprises inserting epilogue code if present in the stub method after the desired function at which may further comprise merging branches and or exception handling blocks and the instructions to which they point if present in the epilogue code at . Additionally at appropriate assembly metadata tokens information is resolved for the stub method code and appropriate IL code is created for the merged function and copied to the modified code for the desired function.

In this embodiment after modifying stub method code has been injected into a targeted desired function s code including appropriate instructions and metadata tokens the modified code can be sent back to the JIT in the runtime environment where is can be compiled to machine code and executed at . In this way in this embodiment a desired function s code can be modified and the modified code can run in a same stack frame as the original function s code. Thereby allowing a user for example to create separate function modification files e.g. stub assemblies and configuration files that can be used to modify a program without having to create IL code specific to respective target functions.

An application programming interface API can be devised that utilizes function modifying code compiled from a high level programming language for example from a user created stub assembly file of stub methods to modify a computer program functions compiled during runtime by a just in time compilation service JIT . is a block diagram of an embodiment of an exemplary API which when executed by a computer system modifies a desired function from a computer program being executed by a JIT. In one embodiment the API can be an even based profiling agent attached to a runtime environment of a common language infrastructure of a language neutral computer program development and execution framework e.g. a .NET profiler API attached to the common language runtime CLR of .NET framework s common language infrastructure CLI .

In the exemplary embodiment the API comprises a callback receiving component which can be configured to receive function callbacks from a runtime environment of a common language infrastructure. In one embodiment a computer program can call to a function that is located in a library of the common language infrastructure e.g. the program does not include the called function s code but has code that calls out to the CLI s library in order to utilize the called function during the program s execution . In this embodiment the runtime environment can detect the call and instead of sending the function as a callback to the JIT for compilation and execution send it to the callback receiving component of the API .

The API further comprises a desired function detection component which can be configured to detect a desired function from amongst the function callbacks the desired function comprising a function designated by API configuration data from an API configuration file. For example a user can create a configuration file that configures the API to select functions that the user wishes to modify. In this example the desired function detection component can compare function callbacks received by the callback receiving component with configuration data to detect a user desired function.

In the exemplary embodiment the API further comprises a desired function trapping component which can be operably coupled to the desired function detector and configured to trap desired functions for subsequent code modification. As an example if a desired function is detected by the desired function detector the desired function trapping component can trap the desired function e.g. prevent it from being sent back to the JIT for execution so that it may be modified. In the API an intermediate language IL code modification component can be configured to rewrite IL code of the trapped desired function.

The IL code modification component comprises a stub method code identification component which can be configured to identify stub method code from a stub assembly for merging with the desired function code where the stub method code is selected from a stub assembly in accordance with configuration data for the desired function. For example as described above a user can create configuration data that identifies desired functions and associated stub methods in a stub assembly that comprises code for modifying the desired functions. In this example the stub method code identification component can find a stub method in the stub assembly that corresponds to the desired trapped function and identify a location in the stub method code where the desired function and stub method code can be merged e.g. where the stub method code can be injected into the desired function code .

The IL code modification component further comprises a code merging component which can be configured to merge the desired function code with the stub method code at the desired location. In this embodiment of the API the code merging by the code merging component can comprise at least one of injecting prologue code directly preceding the intermediate language code of the desired function and injecting epilogue code directly after the intermediate language code of the desired function. For example the stub method code may include prologue modification code a cutline identifying where the desired function should be located and epilogue modification code. In this example the prologue code can be injected before the desired function code and the epilogue code can be injected after the desired function code.

The API further comprises a modified code transmitting component which can be configured to pass the modified intermediate language code of the desired function to the runtime environment of the common language infrastructure. For example after the function that the user desired to modify has been modified with the stub method code it can be sent to the JIT in the runtime environment to be compiled and executed. In this way in this example the modifying code can be executed in a same stack frame as the original function code that was trapped by the API thereby allowing modifying code to be injected that has been compiled from a separate high level language file created by a user without modifying a stack call of the original program.

The code merging component further comprises a code instruction identification component which can be configured to identify instructions to which branches in the parsed code are pointing and instructions to which branches in the parsed code are pointing. For example if a branch and or an exception handling block are present in parsed code from the stub methods the code instruction identification component can identify respective instructions to which they lead. The identified instructions can be passed to an instruction merging component in the code merging component which can be configured to move the identified instructions into the modified intermediate language code for the desired function. In this way for example the branches and exception handling blocks can be moved into the merged code along with the instructions they point to allowing for easier and more efficient code rewriting for the modified function.

In the exemplary embodiment the code merging component further comprises a metadata token creation component which is compatible with the runtime environment of the common language infrastructure and configured to create appropriate metadata tokens for passing to a metadata inspection API in the runtime environment of the common language infrastructure. For example the metadata token creation component can create metadata tokens for the stub methods found in a stub assembly created by a user that match the metadata tokens in the method calling the desired function.

The code merging component further comprises metadata token copying component which can be configured to copy assembly metadata tokens from the stub method to the modified intermediate language code for the desired function. In this way for example resulting modified function code can be semantically equivalent to the stub method code. It will be appreciated that in some embodiments one may combine the metadata token creation component and the metadata token copying component .

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to one or more of the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method such as the exemplary method of for example. In another such embodiment the processor executable instructions may be configured to execute an API such as the exemplary API of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

