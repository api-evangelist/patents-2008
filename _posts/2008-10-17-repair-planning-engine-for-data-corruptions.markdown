---

title: Repair planning engine for data corruptions
abstract: A computer is programmed to automatically generate repairs to fix failure(s) while taking into account dependencies between repairs relative to one another, by grouping failures. In some embodiments, the computer uses a map that associates each failure type with repair types that are alternatives to one another, and uses another map that associates each repair type with a template that creates the repair when instantiated. In certain embodiments, repairs within a repair plan are consolidated, to avoid duplicates and redundancies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07904756&OS=07904756&RS=07904756
owner: Oracle International Corporation
number: 07904756
owner_city: Redwood Shores
owner_country: US
publication_date: 20081017
---
This application claims priority under 35 USC 119 e from a provisional application No. 60 981 469 filed on Oct. 19 2007 having the title Recognizing And Repairing Data Failures filed by Mark Dilman et al which is incorporated by reference herein in its entirety.

This application is related to and incorporates by reference herein in their entirety each of the following two commonly owned and concurrently filed applications both having Mark Dilman as the first named inventor 

It is well known in the art for computers to encounter faulty hardware and or software during storage and retrieval of data. For example an error may arise when the computer unexpectedly encounters a breakdown in hardware e.g. in magnetic media such as a hard disk where the data is stored. In addition to faulty hardware errors can also arise due to bugs in software e.g. an application program may overwrite data of another application program or an application program may improperly use an interface API of the underlying operating system to cause wrong data to be stored and or retrieved. These faults are called data corruptions. Therefore a fault can arise during normal operation in any component of a system. Examples of components are network interface circuitry disks operating system application programs cache device driver storage controller etc.

Some application programs such as database management systems DBMS may generate errors when data corruptions are detected e.g. if a previously stored checksum does not match a newly calculated checksum. A single fault also called root cause can result in multiple failures with different symptoms moreover a single symptom can correspond to multiple failures. Knowing a symptom or a root cause of a failure is sometimes not enough for a human to formulate one or more recommendations to repair the failed hardware software or data.

Manually reviewing such errors by a system administrator and identifying one or more faults which caused them to be generated can become a complex and time consuming task depending on the type and number of errors and faults. Specifically the task is complicated by the fact that some errors are not generated immediately when a fault occurs e.g. a fault may cause corrupted data to be stored to disk and even backed up with errors due to the fault being generated a long time later when the data is read back from disk. Furthermore errors due to a single fault do not necessarily appear successively one after another. Sometimes errors due to multiple faults that occur concurrently are interspersed among one another which increases the task s complexity. Also information about some faults is interspersed among different types of information such as error messages alarms trace files and dumps failed health checks etc. Evaluating such information and correlating them is a difficult task that is commonly done manually in prior art which is error prone and time consuming. Error correlation can be done automatically instead of manually. Systems for automatic error correlation are commonly referred to as event correlation systems see an article entitled A Survey of Event Correlation Techniques and Related Topics by Michael Tiffany published on 3 May 2002 . However such systems require a user to manually specify correlation rules that capture relationships between errors. Such rules applied to data storage systems that generate many types of errors under many different failure scenarios can be very complex. They are also often based on a temporal ordering of errors that might not be correctly reported by a data storage system. This makes such systems prone to generating wrong results false positives and false negatives. Moreover any new error type added to the system or any new failure scenario require reconsideration of the correlation rules that makes them difficult to maintain and therefore even less reliable. Finally an error correlation system is intended to find a root cause fault that could be different from the data failure because it does not indicate which data is corrupted and to which extent.

Moreover even after a fault has been identified correctly by a system administrator repairing and or recovering data manually requires a high degree of training and experience in using various complex tools that are specific to the application program. For example a tool called recovery manager RMAN can be used by a database administrator to perform backup and recovery operations for the database management system Oracle 10g. Even though such tools are available human users do not have sufficient experience in using the tools because data faults do not occur often. Moreover user manuals and training materials for such tools usually focus on one at a time repair of each specific problem although the user is typically faced with a number of such problems. Also there is often a high penalty paid by the user for making poor decisions as to which problem to address first and which tool to use in terms of increased downtime of the application program s availability and data loss. To sum up fault identification and repair of data in the prior art can be one of the most daunting stressful and error prone tasks when performed manually.

A computer is programmed in accordance with the invention to use a software tool called repair planning engine to automatically generate repairs to fix failure s while taking into account dependencies between repairs relative to one another e.g. by grouping failures. In several embodiments the computer uses a map that associates each failure type with repair types that are alternatives to one another and uses another map that associates each repair type with a template that creates the repair when instantiated.

Specifically in many embodiments the type of each specific failure is used to look up a predetermined map in the computer to identify one or more repairs that can fix that specific failure. For certain failures multiple repairs are identified for each specific failure as alternatives to one another any of which can be used to fix the specific failure. For example one repair among multiple repairs requires shutdown of any software program that uses the data and may further require manual assistance to obtain a file from backup but results in no data loss while another repair among the multiple repairs results in data loss but can be performed automatically without manual intervention and while the software program is still running. In some embodiments multiple alternative types of repair for selected failure s to be fixed are displayed to the human followed by receiving from the human identification of one or more repair s that are selected to be performed. In several embodiments the computer is programmed to automatically select one type of repair from among multiple repairs e.g. always select a no data loss repair if such a repair is included among the multiple repairs. After repair selection the computer automatically executes the selected repair s to generate corrected data to fix the selected failure s in said data storage system followed by storing the corrected data in non volatile memory of the data storage system.

In many embodiments a data storage system is implemented within a computer system illustrated in and programmed in accordance with the invention to use a software tool also herein called data recovery advisor or abbreviated as DRA. In certain embodiments the data recovery advisor automatically responds to errors occurring within data storage system by running diagnostic procedures that check integrity of one or more components within data storage system . More specifically in view of one or more reasons described in the Background Section above a data recovery advisor DRA of some embodiments does not rely on correlating errors. Instead the DRA of these embodiments uses errors as a hint to start or trigger comprehensive integrity checks of system component s associated with the error. Such checks e.g. a data block integrity check in data storage systems usually can be fast relative to error correlation and their execution does not consume a lot of system resources. A medical analogy to certain DRA s integrity checking is as follows if a CT Scan were cheap doctors would prefer to always use it to diagnose a disease and patient s symptoms would just be used to determine which body part s to scan.

Examples of data storage system for which a DRA of the type described herein can be used include file systems storage arrays file servers and database management systems. Data storage system includes a software program that stores data persistently in storage device implemented by storage device in which may be for example a hard disk a flash memory or a tape. While storing data to storage device and or during retrieval of data from storage device software program may encounter one or more error s such as not being able to access a file normally used by software program .

Note that software program of may implement any functionality when programmed into computer system such as an operating system and or any application program. Accordingly a data recovery advisor of the type illustrated in is prepared and used in some embodiments to repair errors in data accessed by i.e. read by and or written by an operating system which is the software program of these embodiments . In other embodiments data recovery advisor is prepared and used in some embodiments to repair errors in data accessed by an application program such as video game software which is therefore the software program of these embodiments .

In some embodiments errors are persistently stored by software program in a repository not shown in see storage device in and the stored errors are later used to identify and fix failures and or to recover data that has become corrupted and or not available for some reason. In certain embodiments errors are stored only temporarily for a short period of time e.g. less than a minute in volatile memory of computer system such as main memory . Note that computer system may include one or more computers illustrated by dashed boxes depending on the embodiment. The just described temporarily stored errors may constitute transient errors of the type likely to be unavailable in future and for this reason in some embodiments an act is performed in response to occurrence of one or more errors although in other embodiments act can be performed in response to a command from a human user and alternatively act can be performed on a pre set schedule.

In act data recovery advisor checks integrity of certain structure s which are used to store data in storage device and if any failures are found by integrity checking then data recovery advisor persistently stores the failure s along with one or more attributes and parameters that uniquely define the failure s in a record or other such data structure in a repository in a storage device of computer system such as a hard disk. Attributes are certain properties which happen to be common to all failures whereas parameters are other properties which depend on the specific type of failure with some types of failures having no parameters and other types of failures having any number of parameters e.g. 1 3 5 parameters . Attributes can be for example time of occurrence failure type failure status e.g. open closed and failure priority e.g. critical high low . Parameters depend on each failure s type for example a file missing failure may have a single parameter which is a unique identifier of the file such as file name and location e.g URL . Similarly a block corrupt failure may have as its two parameters a a unique identifier of the block within a file and b a unique identifier of the file containing the block.

In some embodiments act uses a reverse object name lookup table which is prepared ahead of time to associate data blocks back to the objects to which the blocks belong. The reverse object name lookup table is referred to as metadata since it stores information about the data in the storage system. This allows you to tell that block on device is really the jpeg file Spain bell tower 2007.jpg . In some databases this reverse object lookup table might be part of the metadata that is stored in the data dictionary. Reverse object name lookup table is pre created by software program so that it is usable off line so that the metadata is available to act for use in interpreting errors and or generating failures based on data even when software program is not running.

Specifically after logging one or more of errors software program may crash and stop running or if running may become otherwise inoperable e.g. hang . Accordingly an off line dictionary is used by some embodiments of act to lookup metadata that may be required to diagnose errors . In other embodiments the off line dictionary is not used to diagnose errors and instead it is used to determine impact of known failures. Off line dictionary may be kept in a storage device that is different from storage device in which data is kept as shown in or alternatively a single storage device may be used to store both data and off line dictionary . Off line dictionary is also used in some embodiments to formulate repairs to be performed and or to perform repairs. In some embodiments dictionary forms a portion of data although inaccessibility of data causes inability to diagnose some errors .

Note that failures are not necessarily found after performance of act by the programmed computer e.g. there may be no failure if an error that triggered act arose from an underlying fault that becomes fixed when act is performed fixed either automatically or by human intervention . Alternatively in some situations an error that triggered act may have been a false positive i.e. there may be no underlying fault. Accordingly performing act in response to an error has the benefit of screening out the error if it happens to be a false positive. In act of some embodiments data recovery advisor examines one or more structure s used to access media to see if all of them are well formed as per information such as each structure s field definition that is known to data recovery advisor . The structures that are used to access data in i.e. store data to and retrieve data from storage device are also called storage structures as further discussed next.

Storage structures used by data storage system to access storage device can have different formats and field definitions depending on the embodiment. For example in cases where data storage system implements a file system 5819292 for an application such as a browser or an accounting package that is implemented by software program examples of storage structures include a the inode and b the file allocation table or FAT c directories d file system journal and e superblocks. Moreover in cases where data storage system implements a database management system such as ORACLE 10gR1 available from ORACLE CORPORATION examples of storage structures include a control file b data file and c log file such as a redo log . For further details on storage structures in file systems see U.S. Pat. No. 5 819 292 which is incorporated by reference herein in its entirety.

In some embodiments an objective of act is to identify a type of failure in media which failure is mapped to a type of repair and the repair type in turn identifies one or more repairs to be performed manually or automatically that can fix data corruption or data unavailability and restore health and availability of software program . Specifically as per each of failures is of a specific type that is associated with one or more repair types by a map in data recovery advisor . Most failures are caused by hardware faults operating system faults user errors and or bugs errors in programming logic of the software program . However not all bugs result in one of failures . A software bug by itself is not a failure unless the bug s symptoms are known data failures with well defined repairs. Accordingly only known problems which have known repairs are identified by data recovery advisor of some embodiments as failures in data storage system .

Failures identified by data recovery advisor are distinguished from errors that occur in data storage system as follows. Each failure unambiguously describes a specific problem which is one of several problems that are known to occur . Determining a root cause of a failure e.g. faulty disk controller user error or a software bug is not performed in act of most embodiments. Instead each failure identified by act is pre selected to be of a type that has one or more known repair s which can be used to repair data that is inaccessible or corrupted due to the failure. To better understand the difference between a failure and an error the inventors of the current patent application recommend the reader to analogize the term failure to the term disease commonly used in the medical field. In accordance with the just described medical analogy errors e.g. file open error of a failure e.g. missing file are analogous to symptoms e.g. sneezing coughing of a disease allergy cold flu . Accordingly each of failures represents a specific conclusion of an analysis about a problem of data storage system .

Note that any one of failures A . . . I . . . M together referred to as failures may manifest itself in a number of observable symptoms such as error messages alarms failed health checks etc. However conceptually each failure I is different from a symptom itself because each failure I represents a diagnosed problem conclusion as to the source of the symptom and because each failure must be associated with one or more repairs. Examples of failure s detected by act include a inaccessible data file b corrupted data block and so on. Not every fault in computer system is one of failures because a failure I only represents a fault that is known. In addition as noted above each failure I is deterministically identifiable by performing in act one or more procedure s specifically designed for finding the fault and as noted above the fault must be fixable by performing a deterministic repair involving a manual or automatic action s . Note that relationships between symptoms failures and underlying faults can be non trivial and as noted above they are determined ahead of time and appropriately programmed into data recovery advisor .

A single fault which may be a root cause can result in multiple failures with different symptoms moreover a single symptom can correspond to multiple failures. Knowing a symptom or a root cause of a failure might not be enough for a human to formulate a specific sequence of acts e.g. a repair to be performed manually or automatically to repair a failed component of data storage system which component can be any of hardware software or data. Accordingly only a fault that indicates the nature of the problem is formulated into a failure of a particular type and is associated with a repair type. Specifically as noted above in reference to map of a failure type may be associated with more than one repair type if multiple repairs are possible to address a given failure. Despite the fact that in some cases a failure its symptom and its root cause can be the same or can be confusingly similar each of them represents a different concept and conceptual differences between them are supported by their different treatment within the software used to program computer system to function as a data recovery advisor of several embodiments.

In performing act data recovery advisor of some embodiments verifies the integrity of storage structure s that are used to store the data in storage device by implementing physical check s and or logical check s and or both. Physical checks include checking of one or more attributes of items that are physical entities such as a file or a block. These attributes also called physical attributes are independent of the data that is contained within the file or block. One example of a physical check is whether a given file exists which is implemented by making a call to the operating system of computer system . Physical checks can be specific to the type of file or type of block. For example files and directories have different block formats and therefore have different checks. Accordingly in act a computer included within computer system is programmed in some embodiments to compute and verify a checksum and verify presence of one or more known fields such as a predetermined number i.e. a constant . In another such check depending on the type of file e.g. as indicated by file name and or an index computer checks if a header within a first block of the file has a field whose value indicates the same type.

In addition to or instead of checking physical attributes as discussed in the previous paragraph in some embodiments the computer within system is programmed to perform logical checks. Logical checks may include performing range checking. An example of a logical attribute is the list of file names specified in a directory block. A directory block might be correctly formatted but have an incorrect file name entry. Such a block would pass the physical checks but would fail the logical check. Additional examples of logical checking include date is valid size is valid e.g. does the size stored in the block match the physical size of the block that has been retrieved and field is within a valid set of values e.g. if there is a filetype field in the storage structure being verified make sure the value is one of the valid ones . Logical checks may also check relationships between blocks. For example if there are references pointers or offsets from one block to another as might exist in a file allocation table or database index the computer makes sure that the referenced blocks do exist. In some embodiments of the just described example the computer reads the actual referenced block to see if that block is correct. For a directory the computer checks to make sure that the file entries in that directory exist. Depending on the content the computer can also be programmed to perform checks on the content of the file or block. For example XML documents have a well defined structure that is validated in some embodiments. Some embodiments of the computer also do range checking on application specific fields.

After verifying the integrity of storage structure s as described above in reference to act the programmed computer automatically identifies zero one or more failures. For example at the end of act a failure I that caused one or more errors to occur is identified. As noted above a failure I which is identified by act is of a type that is known ahead of time to act i.e. it is one of a predetermined set of known types of failures. The identified failures are initially stored by computer system in a volatile memory see and eventually followed by transfer to a storage device that stores data persistently such as a hard disk. In some embodiments performance of act includes execution of any diagnostic software that tests the integrity of an item such as data hardware or software in data storage system to ensure that the item being tested has its structure and function as expected by software program .

Note that the above described integrity checking in act is performed after startup and initialization of software program i.e. during normal operation of data storage system . The checking of integrity in act may be initiated and or repeated as per act asynchronously in response to an event in data storage system such as a command from the user or an error encountered by software program in reading or writing data to media depending on the embodiment. Performance of acts and or is scheduled in some embodiments to be periodic at predetermined time intervals such as once an hour or alternatively aperiodic based on user input e.g. user specifically schedules act to be performed at certain times of the day when data storage system is expected to be underutilized.

As illustrated in acts and together form an operation that decouples a human user s interaction and therefore their experience from the work performed by computer system in act of several embodiments. Such decoupling has several advantages as follows. Act is performed automatically asynchronously in the background so it does not interfere with operation of software program that triggered performance of act i.e. software program can continue to operate after logging an error . Moreover performance of operation in response to a user command is also not adversely impacted as would happen if performance of act is started only in response to and subsequent to act i.e. user does not have to wait while act is being performed . In some embodiments failures resulting from act are stored in a persistent storage device such as a hard disk and arise from an automated response by act to an error being detected.

Note that a storage device to persistently store failures is not used in certain alternative embodiments which simply store failures in main memory of computer system . Moreover some alternative embodiments perform act only in response to human input shown by dashed arrow . Note that act is performed in the reverse order shown in relative to act in some embodiments i.e. act is performed initially and supplies user data to act . Also in the some embodiments of the data recovery advisor act is performed only in response to a command from the user in act . However in alternative embodiments one or more such acts may be performed automatically as discussed below in reference to .

In one embodiment acts that are performed by computer system after act depend on the human user. For example in several embodiments computer system is programmed to receive from the human user as per act a selection from among displayed failures which selection identifies a specific failure to be corrected. In response to user s identification of a specific failure computer system automatically identifies as per act one or more predetermined repairs for corrupted data in storage media .

As noted above any failure to be recognized by data recovery advisor must be associated with repair for fixing the failure. One or more types of repairs are automatically identified in act e.g. by use of map which is implemented in some embodiments as a lookup table. The table which implements map is static and it is set up ahead of time in a memory of computer system during initialization and startup of data recovery advisor . Among the identified types of repairs each type of repair is alternative to another type of repair and consequently the corresponding repairs themselves constitute a group of alternative repairs each of which can fix the specific failure selected by the user. Accordingly in act computer system displays to the user multiple alternative repairs for repairing a user selected failure.

As illustrated in acts and together constitute another operation . Operation is shown in as being coupled by a dashed arrow to operation based on the human user s input to computer system in some embodiments. Coupling of operations and via input from a human user has several advantages as follows. Firstly a human user may review failures displayed by act and decide to not take any further action to correct any of them at this time although eventually the user will probably want to fix all data failures e.g. if the failures are less important than continuing current operation of software program . Therefore performance of operation is entirely under human control in these embodiments. Secondly awaiting user input by such coupling allows computer to only perform operation on those failures that are selected by the user. Performing operation on selected failures instead of doing so on all failures saves computing resources in the form of processor time and memory. An experienced user may know how to fix a failure just from the detailed description of a failure provided by act and may then fix the failure manually. After such manual repair the user can simply issue a command to list failures which is received in act discussed above and a record in the repository for the failure which was manually fixed is automatically marked as closed during revalidation in act i.e. in response command received in act .

The acts that are performed by computer system after act in some embodiments depend on the human user. In several embodiments computer system is programmed to receive from the human user as per act identification of a selected repair to fix a corresponding failure. In response to receipt of the user s input in act computer system automatically performs the repair identified by the user as per act . Accordingly corrected data that is obtained from repair is stored in memory as per act e.g. for later use by software program and or by other software tools and or by human users. For example in some embodiments of act computer system is programmed to use the corrected data from act to overwrite the corresponding corrupted data in media .

In the embodiment illustrated in manual selection is made in a real time dialogue between a human user and a computer that implements a data recovery advisor of the type described above. However in other embodiments illustrated in a selection is made ahead of time by a user it s the customer who decides if they want this behavior who pre configures the software of a data recovery advisor A. Specifically a data recovery advisor A described below is pre configured in certain embodiments to automatically execute a repair that has no data loss if such a repair is present in the group of alternative repairs for the failure.

Accordingly certain alternative embodiments implement a data recovery advisor A that automatically performs one or more acts which otherwise require human input for example as stated above. Note that certain acts performed by data recovery advisor A are in some respects similar or identical to corresponding acts performed by data recovery advisor unless described below. For this reason identical reference numerals are used in to identify corresponding acts in the two figures.

Referring to human input is not required by data recovery advisor A prior to operation in some embodiments which are programmed to directly perform an operation A automatically without performing operation . Such embodiments are also referred to herein as automated embodiments of data recovery advisor. In operation A data recovery advisor A automatically selects one or more failures in repository e.g. at random in act A. In certain embodiments data recovery advisor A is programmed to use one or more predetermined criteria and or predetermined logic for failure selection to automatically select one or more of failures from repository .

In some embodiments failures are selected either automatically or with manual input as illustrated in respectively based on priority with the highest priority failures being always selected. Specifically each of failures is assigned a priority e.g. critical high and low when created. For example a predetermined criterion used in act A is to select all failures that are of highest priority. Note that priority levels are assigned to failures in act by use of a table not shown that maps each failure type to a corresponding failure priority. In the certain embodiments if any failures in repository are of priority critical then these failures are automatically selected in the automated embodiment of or forced to be selected in the manual input embodiment of .

Failures with critical priority require immediate attention because they make software program unavailable. Moreover failures with high priority make software program partly unavailable or make data partly unrecoverable and usually have to be repaired in a reasonably short time e.g. within a day . Examples of low priority failures include data block corruptions in files that are not needed for operation of software program as well as non fatal I O errors. Repair of failures that are of low priority failures can be delayed until other failures are fixed delayed either automatically or by the user . Moreover some embodiments provide support for a human user to review and change priorities of failures stored in repository . Certain embodiments limit such support e.g. do not allow lowering of priorities or do not allow lowering the priority of any critical failures.

Referring to the automated embodiment of a data repair advisor illustrated if there are no critical failures in repository then act A selects all failures of priority level high. In some embodiments act A additionally selects one or more failures that do not have as a prerequisite fixing of any other failure in repository that has not yet been selected. To perform such additional selection information about one or more dependencies between each failure and any other failure is included in data recovery advisor A of some embodiments e.g. in a two dimensional table not shown in .

In the automated embodiment of in addition to operation A operation A is also performed automatically i.e. all acts of the data recovery advisor A see acts A A and in are performed automatically without any human input whatsoever. As will be apparent to the skilled artisan other embodiments may mix and match acts of with acts of for example as follows. In several embodiments after acts A and of are performed an act is then performed to display various alternative repairs to a human as illustrated by the embodiment shown in followed by acts and as described above which is then followed by act described below . Accordingly in the just described embodiment illustrated in human input is sought only for selection of a repair by performance of acts and of and otherwise performing the acts shown in . As will be apparent other embodiments may perform acts and of to obtain human input on the failures to be fixed and then perform acts A and automatically. Hence numerous such combinations will be apparent to the skilled artisan in view of this disclosure.

After acts A and are performed by an automatic data recovery advisor A as discussed above in reference to and furthermore in some embodiments acts A and are also performed automatically as follows. Specifically in act A a repair is automatically selected by data recovery advisor A based on one or more predetermined criteria and or predetermined logic for repair selection. For example in some embodiments any repairs that do not result in data loss by performing repair on the data in storage device are selected automatically in act A. Thereafter acts and are performed in the above described manner followed by an act as follows.

In act automatic data recovery advisor A checks if there are any failures in repository that need to be fixed e.g. identified by status of open . If the answer is yes then automatic data recovery advisor A returns to act A described above . If the answer is no then automatic data recovery advisor A waits and then returns to act . The waiting by automatic data recovery advisor A is set by a database administrator in some embodiments although in other embodiments the duration is of a fixed amount e.g. 1 second built into the software of automatic data recovery advisor A e.g. hard coded therein .

The specific programming of software within data recovery advisor and or A will be apparent to the skilled artisan in view of this disclosure. However for illustrative purposes additional details of such programming are discussed below in the context of a database management system DBMS although it should be readily apparent that DBMS is merely an illustrative example of a data storage system and other data storage systems such as file systems are also implemented in the manner described herein.

In several embodiments a computer is programmed to check integrity of data in a storage structure from which an error arises in response at least partially to occurrence of the error during access of the data. Specifically on occurrence of each error a method of the type illustrated in is performed by computer system to implement flood control at two levels to account for duplicate errors within a time period and for duplicate performance within another time period of act . As noted above in reference to act performs one or more physical and or logical checks on data . One or more acts of method may be performed within software program that uses storage structures to access data or alternatively one or more of these acts may be performed by data recovery advisor A B depending on the embodiment.

Specifically in some embodiments after an error arises in data storage system hereinafter current error the computer automatically performs act to record occurrence of the current error with a time and date stamp in a log also called first log . The first log is used in act as discussed below and the log is purged on a periodic basis. After act the computer checks a predetermined set of errors to see if the current error is of interest as per act and if not of interest then returns from method .

If in act the computer determines that the current error is of interest then it goes to act . In act the computer checks in the first log whether any prior error recorded therein as per act is identical to the current error e.g. same type and same parameter values and if so whether that prior error satisfies a predetermined condition relative to the current error. For example the computer checks if the prior error occurred at least within a first time period of occurrence of the current error with the first time period being set at for example 5 minutes.

If the answer in act is yes then the current error is flood controlled i.e. it does not perform act . If the answer in act is no the computer goes to act to implement the performance of act . In some embodiments act is performed by execution of a procedure called diagnostic procedure in a process that is separate and distinct from the process in which the error arose. Note that in other embodiments the computer does not execute a diagnostic procedure and instead the integrity checking is done in an in line manner by performance of act by the same process that identifies the error. However decoupling a first process that detects an error from a second process that uses the error to diagnose a failure is advantageous because the first process can continue execution without waiting for the second process to finish execution.

Accordingly in act some embodiments use a type of the error that arose to look up a predetermined table and find the identity of a diagnostic procedure to be executed. Note that in act instead of or in addition to flood controlling of an error based on a single occurrence with a given time period other embodiments perform flood control based on the number of occurrences of the error within a first window of time e.g. 2 times in 10 minutes. Next in act the diagnostic procedure is instantiated. Specifically various parameters related to the current error are automatically matched by the computer performing act to parameters of the diagnostic procedure.

Then in act the computer checks to see if the diagnostic procedure identified in act has been previously performed within a second time period e.g. 1 minute and also checks if the diagnostic procedure is currently executing. Whether the diagnostic procedure is currently executing is determined from the value of a flag which flag is set at the beginning of execution of the diagnostic procedure as per act in described below . Note that in performing act in a manner similar to act instead of or in addition to flood controlling execution of a diagnostic procedure based on its single performance in a given time period other embodiments perform flood control based on the number of performances of the diagnostic procedure within a second window of time e.g. two times within 2 minutes.

If the result in act is no then the computer automatically goes to act and records in a second log an identity of the diagnostic procedure being invoked and the time and date of invocation. This second log is used in act described above in a manner similar to the above described use of the first log in act . After act the computer performs act to initiate execution of the diagnostic procedure e.g. by sending to a background process a message containing the diagnostic procedure s identity and its parameters.

Accordingly a diagnostic procedure is run in some embodiments of operation to find out what if any problems may be present in certain data components of computer system that may cause an error within software program . As noted above the diagnostic procedure typically uses technical information about specific data hardware or software whose integrity is being checked. For example a diagnostic procedure for data in storage device may contain one or more data structures which define data types of one or more fields used by software program to access data . In this example the diagnostic procedure type checks and or limit checks data by use of predefined storage structure s to determine whether a particular field therein has an error.

Also depending on the embodiment a diagnostic procedure that is executed in operation can be configured to diagnose just one failure e.g. one procedure per failure or configured to diagnose multiple failures e.g. a single procedure for certain failures of a particular type or particular layer of software or even a single procedure for all failures . Moreover in embodiments that use multiple diagnostic procedures the same failure can be diagnosed by several different diagnostic procedures any one or more of which may be performed in operation . Note that in some embodiments each failure is diagnosed by only one diagnostic procedure although that one diagnostic procedure itself diagnoses multiple failures.

Further depending on the embodiment a diagnostic procedure can be explicitly invoked either by the user or by computer system as part of a scheduled evaluation of data in storage device . In certain embodiments execution of a diagnostic procedure in operation is automatically started based on occurrence of a corresponding error in software program e.g. by computer system using an activation table not shown in that associates errors with corresponding diagnostic procedures. Moreover execution of a diagnostic procedure can be triggered by the output of another diagnostic procedure in operation e.g. by indication of an error.

The specific diagnostic procedures that are used by a DRA of the type described herein will be readily apparent to the skilled artisan. In particular the skilled artisan will be able to use utilities commonly available in the industry to check file systems and databases for consistency. Moreover specific repairs depend on the specific data storage system and may include getting data backups log of changes etc. from external sources such as a backup server or storage filesystem database replica. Accordingly a DRA for file systems in accordance with this invention is superior to a prior art utility called fsck . Without the ability to access external sources such a prior art utility experiences data loss which can be avoided by a file system DRA of the type described herein. One or more of the integrity checking techniques used by a file system DRA of the type described herein for UNIX can be implemented in a manner similar or identical to fsck as described in for example an article entitled Fsck The UNIX File System Check Program by Marshall Kirk McKusick and T. J. Kowalski published Oct. 7 1996 that is incorporated by reference herein in its entirety. Also integrity checking techniques used by the file system DRA for Windows XP available from Microsoft Corporation can be to invoke the operating system utility Chkdsk . Moreover a database DRA may invoke the checks supported by a database management system such as DBCC CheckDB.

In some embodiments a framework within the computer receives the request generated in act described above and performs the method illustrated in . Specifically in act the computer uses a failure type identified in the request to look up a table not shown and identify all parameters of the failure. Next in act the computer verifies the parameters e.g. by checking if the value received with the request of each parameter is between predetermined limits max min on legal values for that parameter. Next in act the computer instantiates a failure by storing in failure repository a record for the failure identified by a unique identifier which is a sequence number that is monotonically changing e.g. an integer count that is incremented by 1 for each failure . An illustrative record for a failure in storage device is illustrated in as discussed next.

In some embodiments the computer stores for each failure values of several attributes such as identifier a unique number a failure type a value that is one of several predefined values creation time current time and date when failure is stored status open initially and when failure is fixed changed to closed priority for example critical high low text description a detailed statement of the failure to specifically describe the nature of the problem encountered by software program to enable manual selection of one of several repairs for fixing the failure parent identifier to identify a parent failure into which the current failure can be aggregated and revalidation software s identification . Identification is used whenever the computer needs to check if the current failure is still valid i.e. data storage system still has the current failure .

Although certain failure attributes have been described and illustrated in as being stored for each failure fewer attributes or even more attributes may be stored depending on the embodiment. For example the revalidation software s identification is not stored in some embodiments with each failure. Instead the revalidation software s identification is stored associated with one or more failure types and accordingly each failure s type is used to look up the revalidation software s identification .

In addition to the just described attributes a failure may also have one or more parameters as discussed above . Failure attributes parameters and their values can differ in different systems.

After performing act the computer flags in act a current failure as a duplicate if the same failure was previously recorded in failure repository . Specifically in some embodiments of act the computer searches the repository for the failure and if a duplicate failure exists e.g. same type and same parameter values and if its status is open then the current failure is marked as a duplicate. For example if a diagnostic procedure C is executed by act at time M and detected Failure B. Then some time later at time N N M diagnostic procedure C is executed by act again and detected Failure B again. Adding Failure B the second time around creates duplicates which are marked in repository by some embodiments as being duplicates. However certain embodiments do not create duplicate failures in repository . For example a current failure is simply discarded if a duplicate is found in repository . As another example when a diagnostic procedure C starts execution procedure C automatically closes any failures in repository that were previously detected by itself i.e. by procedure C so that only newly found failures are recorded which are unique as any previously recorded duplicates have been closed .

In certain embodiments the computer is further programmed to aggregate two or more failures into a single aggregated failure also called parent failure . Hence when multiple files or alternatively blocks used by software program are corrupted then the user initially receives a display of only a parent failure that summarizes multiple file corruptions or alternatively multiple block corruptions . In some embodiments a human user obtains a display of individual failures that have been aggregated by making a further request to display each failure that has been aggregated also called child failure individually.

Accordingly in act of some embodiments two or more failures of the same type but different parameter values are used to formulate a parent failure that is added to repository if the parent failure didn t already exist therein. If the parent failure already exists then it is updated with parameter values from the two or more failures being aggregated by act . A parent failure s parameter values are derived from its child failures. For example if block is identified as corrupt by one child and block is identified as corrupt by another child the parent failure identifies blocks as being corrupt. Alternatively if the two blocks are both in the same file X the parent failure may simply state that file X contains one or more block corruptions. 

After one or more failures are recorded in repository by act they may be displayed to a human user e.g. in response to a user command to list failures. Specifically in act the computer of some embodiments retrieves all failures in repository and for each failure retrieved automatically checks if a failure s status is open and further confirms that the failure is not duplicated and that the failure is not a child of another failure and if these conditions are satisfied displays the failure. Note that in some embodiments each child failure has as an attribute thereof a pointer to the parent failure and vice versa. Accordingly if the user command is to list failure details in certain embodiments the parent failure is displayed simultaneously with a display of that parent s child failures. In some embodiments the failures are displayed in priority order with highest priority failure being displayed at the top of display followed by the next highest priority failure and so on.

In some embodiments failures identified in act for display to a human are revalidated prior to display. During revalidation in act computer system invokes the software identified by use of the failure type to look up a revalidation software identifier for a given failure in a map to verify that the failure still exists in data storage system and marks as closed any failure that no longer exists. The software identified by revalidation software identifier in certain embodiments is a portion of the software that originally diagnosed the failure. For example a portion of a given diagnostic procedure that is triggered in response to an error is re executed during revalidation to ensure that the failure still exists. Certain alternative embodiments do not perform a lookup in a map to find the diagnostic procedure for a failure based on failure type and instead the diagnostic procedure of the alternative embodiments initializes as per act in in attribute see an identifier of a software portion within the diagnostic procedure for use in revalidation of the failure in act . Some embodiments support performing revalidation in response to a user s command while other embodiments perform revalidation automatically at certain times e.g. after repair of data in storage device .

One of the functionalities provided by DRA is automatic generation of a consolidated repair plan for multiple failures. Specifically there is often a need to repair multiple failures at the same time for the following reasons a a single fault a hardware problem or a user error can cause multiple data failures b system administrators usually postpone fixing of non critical failures until a maintenance window or more appropriate time and by doing this accumulate multiple failures that require repair c often failures are latent and do not manifest themselves until the user tries to use the affected component but they might be detected by a diagnostic check started because of a different reason.

Devising a successful and efficient repair strategy for multiple failures can be much more complicated than fixing a single failure. There are two reasons for the complexity. The first one is dependencies in between repairs and failures that should be taken into account when determining the order of failure repairs. These dependencies are specific to the application. The following types of dependencies can exist for a database 

Another reason for the complexity of a consolidated repair generation is that usually there are many alternative ways to repair a set of failures and determining the best alternative can be non trivial. For example if failure F can be fixed by repairs R R or R failure F by R R or R and F by R or R there might be multiple ways to fix all the failures together 1 R R R 2 R R 3 R. The more failures are in the set the more alternatives should be considered and analyzed.

Therefore in general generation of a consolidated repair for multiple failures consists of the following steps 

To execute these steps all dependencies between failures and repairs as well as guidelines for choosing optimal repairs are specified in advance in some embodiments by designers of the DRA. Such specification in general may consist of a significant number of complicated rules and needs to be reconsidered every time a new failure of repair type is added to the system. This might not be feasible for some data storage systems.

The process of repair generation for multiple failures is simplified in some embodiments by dividing up all possible failure types into a number of groups separately generating consolidated repair for each group and possibly merging generated consolidated repairs into a single repair. The just described divide and conquer approach is built into a DRA of many data storage systems by dividing up failures into the following three groups first group is an access group for failures related to accessing an input output component such as file resides in an inaccessible file system file system not mounted file does not have right access permissions file is locked or operating system OS limit on number of open files reached or OS out of resources needed to access file etc. Second group is a physical group for failures related to physical data consistency such as missing and or corrupt and or mutually inconsistent physical components like files or blocks. Third group is a logical group for failures related to data consistency such as missing corrupt inconsistent logical objects like directories file extent information tables rows indexes etc.

If software program uses only one storage device then access group is at a higher level in the relative priority relative to all other groups because no other failures can be fixed until software program can access storage device . Specifically failures in any group including physical group can be fixed only after failures in access group are fixed. Hence physical group may be set by the human designer at a lower level in the priority relative to access group .

Note however that although three groups have been described as being illustrative for an example of a map this does not mean that these three groups have to be present in any given system in order to practice this invention. Instead other embodiments group failures differently because failure grouping is an optimization that depends on the configuration and components of the data storage system and does not have to be part of DRA. Accordingly the number of groups contents of the groups and the ordering of groups relative to one another can be different in different embodiments. For example some embodiments have only two groups e.g. an access group and a physical group while other embodiments have four groups five groups or even ten groups.

Some failure groups called floating do not have strict ordering constraints. The only requirement for the floating groups is that they have to be processed after a certain failure group but there is no before constraint e.g. no requirement to process before any group . In a database example log group members can be repaired any time after a database is mounted. Hence log group members must be repaired after any repairs that are needed to mount the database but can be repaired simultaneously with other repairs that are possible when the database is mounted.

Finally there could be failures for which repair generation is not constrained by any other failures or repairs and can be done at any time. Such failures are combined into the independent failure group . A bad block in a user file is an example of an independent failure in a file system. Depending on the embodiment not all failures must be grouped into one of the groups of the relative priority e.g. some failures may be kept ungrouped or may be grouped into another group that is processed independently of the predetermined order.

In the above described example illustrated in map in addition to groups may also contain a group not shown on the figure namely a transaction group which is specific to transactional data storage systems e.g. databases. Transaction group contains one or more failure types related to inability to process data during otherwise normal functioning of software program . An example in this group is a failure in performing a transaction on a database due to inability to secure a lock on an object. As noted above failures in any group including transaction group can be fixed only after failures in access group are fixed. Moreover a transaction group failure cannot be fixed in some cases unless software program is initialized and running. Furthermore in some embodiments a single fault can result in failures in multiple groups e.g. in all three groups and and fixing a failure in a higher level group also fixes one or more failure s in other group s that are lower than the higher level group in the relative priority .

In some embodiments a data recovery advisor performs method to create a repair plan. Specifically in act the computer uses the failure type of each failure in a set of failures that are to be fixed with map to identify the group to which each failure in repository belongs. Also in act the computer stores each identified group in memory in an associate with the corresponding failure. Next in act the computer selects the highest level group from among the identified groups that are associated with the failures to be fixed. For example if there are only two failures to be fixed and one failure is in the logical group and another failure is in the transaction group then the open group is selected in act .

Thereafter in act some embodiments automatically prepare at least one repair plan for the failures associated with the selected highest level group by use of one or more additional map s . Specifically in several embodiments of act computer uses a mapping of failure types to repair types see map in to identify the repair types applicable to each specific failure in the selected highest level group. Next computer uses the identified repair type s with another mapping of repair types to repair templates see map in to identify at least one repair template in memory for each specific failure. Computer then instantiates an identified repair template using one or more parameters to create the specific repair for each specific failure.

In some embodiments each failure type is associated with multiple repair types and the multiple repair types are pre arranged in a relative priority with respect to one another which priority is used to select a repair from among repairs that are feasible for a given failure . The priorities are set so that no data loss repairs have a higher priority than data loss repairs and faster repairs have a higher priority than slower repairs. In one illustrative example if a repair results in no data loss for fixing a given failure that repair s repair type is prioritized ahead of other repairs that result in loss of data. In several embodiments one of the repair types is automatically selected in act for each failure type and the selected repair type is used to prepare a repair plan. Depending on the embodiment selection of a repair type and consequently the repair may be based on feasibility of each of the multiple repairs and or impact on data . In the above described illustrative example of this paragraph if a no data loss repair is feasible it is automatically selected for fixing the given failure but if it is not feasible then a data loss repair is selected if feasible . Hence if a no data loss repair for each failure is feasible then all such repairs are selected and used to prepare a repair plan which as a whole results in no data loss . At least one repair plan which includes repairs to fix all failures in the selected highest level group is therefore created and stored in memory of computer system at the end of act .

In some embodiments in addition to the above described repair plan an additional repair plan is also prepared and stored in memory in a similar manner although the additional repair plan contains repairs that are alternatives to corresponding repairs for the same failures in the above described repair plan. Hence there are at least two alternative repair plans in memory in these embodiments for failures in the selected highest level group. Repairs for the two alternative repair plans of such embodiments may be deliberately selected based on whether or not they require assistance from a human i.e. one repair plan may consist of only repairs that can be executed automatically whereas the other repair plan may consist of repairs that require human assistance. In such embodiments each repair type is also marked e.g. in map with a flag which explicitly indicates whether or not the corresponding repair requires human assistance which flag is used in preparing the two types of repair plans.

In some embodiments the repair plans are limited to failures in the selected highest level group although in other embodiments the repair plans may include one or more failures from other groups e.g. failures whose repairs are not dependent on repair of failures in any other group. Also some embodiments prepare repair plans to fix failures in two or more successive groups e.g. a highest level group a second group that is immediately below the highest level group and a third group immediately below the second group. As noted elsewhere herein the just described groups are certain of those groups from among groups which have been identified as containing failures currently logged in repository .

In some embodiments map in main memory associates each failure type with multiple repair types that are used to generate multiple repair plans. As illustrated in a failure type is associated in map with two repair types A and M that are alternatives to one another. Specifically repair type A requires no human involvement to execute steps for repair identified in a corresponding template A. On the other hand repair type M requires human assistance e.g. to load a backup tape to execute the repair steps identified in the corresponding template M. During repair creation in act of method shown in each of repair templates A A and A is customized with parameters of the corresponding failures being fixed to create the corresponding repairs A A and A.

After repairs are identified each repair s feasibility is checked and on being found feasible the repairs are added to a repair plan A in main memory . Each repair A A and A consists of one or more steps not labeled in which steps are to be performed in the specified sequence by computer system with the sequence being identified in repair templates A A and A. Note that the sequence is inherently identified in some embodiments by the order in which steps are specified in a repair template. In some embodiments a repair A also includes a detailed description of the actions to be done for display to a human user e.g. in act . Act of some embodiments chooses a repair description to include in each repair from a set of predefined descriptions which are associated with the corresponding repair templates. Similarly another repair plan M is also created in act by use of the repair types M M and M to identify the corresponding templates M M and M and customize them with failure parameters of the failures being fixed to create the respective repairs not individually shown .

Accordingly repair plan M and repair plan A are alternatives to one another and although only two repair plans are illustrated in any number of such repair plans may be prepared as described herein. Such alternative repair plans are consolidated in some embodiments to remove any duplicates and or redundancies in their repair steps. Thereafter the repair plans are presented to a human user by manual input embodiments of data repair advisor see which then awaits the human s input on selecting one of the plans. Other embodiments of data repair advisor automatically select one of the repair plans based on one or more predetermined criteria e.g. whether all repairs in a plan can be done automatically. Although feasibility and impact are used in some embodiments to select one of multiple repair plans other embodiments may use other factors to select repairs to be performed.

In certain embodiments processor implements method by performing a number of additional acts such as acts see method in prior to above described act and subsequent to above described act performing acts to implement act . Method also includes several additional acts subsequent to above described act . Referring to in act processor receives a set of failures that are selected for repair followed by act . In act the computer creates in main memory a set of repairs that are possible for each failure. Specifically for a current failure the computer identifies multiple repairs that are associated with the current failure s type by looking up a map described above and saves the multiple repairs to memory in a temporary structure such as a list for the current failure.

Next in act the computer performs a feasibility check on every repair in the temporary structure e.g. list for each failure in the set of to be fixed failures and sets a flag for each repair indicating if the repair is feasible or not. To check feasibility of a repair the computer checks for example if the repair involves copying a file that the file to be copied exists in storage device . Certain repairs are not feasible at certain times or may become infeasible due to certain conditions e.g. at the time of act automatic repair of a file may be not feasible if the entire file itself is missing in the computer and no backups are available e.g. due to its deletion by a virus and accordingly an automatic repair for this failure is marked as being not feasible. On the other hand a repair plan may be prepared to include a manual repair which may be feasible. The manual repair may require for example restoration of the missing file from an offsite backup which commands may be identified in a template for the repair. After act acts and are performed in the manner described above in reference to .

After completion of act the computer of some embodiments performs act by using a relative priority of groups of failures illustrated in map in to identify a sequence in which certain failures are to be fixed in a current iteration and remaining failures are left unfixed until a future iteration. Briefly in act computer identifies failures of highest level group that is selected to be fixed in a current iteration followed by failures of a next highest level group in a future iteration . Specifically to identify failures to be fixed in the current iteration the computer performs acts in a loop followed by acts and in another loop as follows. In act the computer checks the received set of failures as per act to see if all failures have been processed in the loop and if not goes to act . In act the computer checks if the failure belongs to a highest level group and if not returns to act described above . If the result in act is yes then the computer goes to act to mark the current failure as being selected for repair and thereafter returns to act . In act if the result is yes then the computer exits the loop and in several embodiments enters a loop around acts and described next .

In some embodiments the computer is programmed to determine in act multiple repairs for every marked failure selected based on its grouping by use of map described above in reference to . Thereafter the computer in act checks a feasibility flag set in act for each of the multiple repairs and infeasible repairs are dropped from further consideration. From among feasible repairs the computer is programmed to select for a given repair plan one of several alternative repairs for each failure based on impact of each repair. For example some embodiments prepare a repair plan in which all repairs have no data loss as their impact. A repair s impact on loss of data is identified by for example performing a lookup of a map using the repair type of each repair.

Additionally each repair s impact on the duration of down time i.e. unavailability of software program or a specified component therein is automatically computed in some embodiments based on estimates of the size of data in a backup file and speed of input output peripherals of computer system and or speed in processing of the backup file. For example the time required to read an off line backup file is computed by dividing file size by speed of input output peripheral e.g. a tape drive . Some embodiments prepare estimates of repair duration using heuristics that are based on statistics from a previous repair e.g. of the same repair type. Certain embodiments also take into account parallelism such as the number of threads currently available number of I O channels. Several embodiments further account for the bandwidth of the storage device and or I O peripheral that contains the backup file. The just described estimate of repair duration is displayed to the user merely to provide a rough indication of the order of magnitude of the down time to enable the user to make a selection from among multiple repair plans. Accordingly the estimate of down time duration is adequate if accurate to within a single order of magnitude of actual time required to execute the repair.

Some repairs may have minimal impact or no impact on data e.g. the repairs may cause no data loss and such repairs are selected automatically in some embodiments to be included in a repair plan . Alternatively in certain embodiments repairs having one type of impact e.g. no data loss are added to one repair plan while repairs having another type of impact e.g. no down time for software program are added to another repair plan. As noted above the repair plan s are stored in main memory and may be saved to storage device at an appropriate time e.g. when completed .

A computer is further programmed as per act of method to consolidate repairs in a repair plan to avoid duplicate repairs and or redundant repairs. Map which maps failure types to repair types is used in act to determine if any repairs in the repair plan s are redundant relative to one another and if so only one copy of the repair is kept in the repair plan s and duplicate copies of that repair are deleted. Moreover a repair plan may contain repairs of different types for a given impact e.g. loss less repair or data loss repair . A data loss repair for a failure may also fix one or more other failures thus making other repairs for these other failures redundant. For example if a file is inaccessible and will be replaced to fix one failure any repairs to fix corruption failure s within that file are made redundant. Hence in act any redundant repairs are also eliminated. As noted above acts and are repeated in a loop until all known duplicates and redundancies are eliminated. After repairs for all failures of the highest level group have been added to the repair plan s implementation of act is completed and the computer proceeds to acts as discussed next.

In some embodiments of method computer uses the repair steps identified in a repair plan to generate a repair script for executing the repairs and store the script as per act in a repository on disk. Computer of some embodiments additionally writes the repair to the repository including the repair s description and a pointer to the repair script. Computer also writes to the repository a consolidated list of suggestions of manual steps to be performed by a user and the list of failures actually fixed by the repair.

Computer is further programmed in some embodiments to display as per act the repair plan s resulting from act described above . Display of multiple repair plans enables computer to obtain from a human a selection of one of the repair plans followed by performing act to execute the selected plan. Alternatively act is not performed in some embodiments that automatically select the repair plan e.g. to contain repairs that cause no data loss. In the alternative embodiments control passes from act directly to act . Computer is further programmed to perform act after act wherein the data recovery advisor verifies successful completion of the repairs in the repair plan and automatically updates the status to closed for any failures that have been fixed by the repair. Hence failures that are closed by being fixed are removed from a current display of open failures as per act .

In one illustrative embodiment a data recovery advisor is included as one component of certain software called recovery manager within a database management system DBMS which is included in a software program of this embodiment. This embodiment also called database embodiment is illustrated in by data recovery advisor which is included as a portion of a DBMS implemented in whole or in part by software in computer system . Accordingly the human user in this database embodiment is a database administrator DBA . Data recovery advisor automatically diagnoses failures in database and generates a repair plan for fixing as many of the failures as possible taking into account dependencies of repairs on one another and determining an order for repairs that are included in the repair plan. If not all failures of database can be addressed by the repair plan data recovery advisor recommends performing the repairs in the repair plan in one iteration followed by another iteration by returning to act . DBMS of some embodiments is a relational database management system which responds to queries from the DBA expressed in the structured query language SQL such as ORACLE 11g Release 1 11.1 available from ORACLE CORPORATION Redwood Shores Calif. hereinafter simply ORACLE . Note that the just described DBMS is referred to below as ORACLE 11gR1 .

Although the description below refers to databases and DBMS several of the concepts described below either individually or in combination with one another are used in other embodiments for repairing the data of any software programs which are not DBMSs such as software program which has been described above in reference to . Data recovery advisor of an illustrative database embodiment which is shown in automatically diagnoses data failures in database determines and displays to the database administrator DBA appropriate repairs and then executes a DBA selected repair. Use of data recovery advisor eliminates the need for the DBA to manually correlate various symptoms such as errors in database in order to diagnose a failure. Note that certain acts performed by data recovery advisor are in some respects similar or identical to corresponding acts performed by data recovery advisor . Hence reference numerals in are derived from corresponding reference numerals in by adding .

Referring to acts are performed by data recovery advisor in a manner similar or identical to the corresponding acts described above . As a repair of a failure might potentially have an impact on the availability integrity and performance of database some embodiments of DRA are deliberately designed to require human input by someone with DBA privileges to decide on which failures to repair in a current iteration and which specific repair mechanisms to use during the repair. Accordingly DRA includes acts and which are described below for some embodiments in the context of a LIST command a ADVISE command and a REPAIR command respectively. Data repair advisor can be used either through a graphical user interface called Enterprise Manager in ORACLE 11gR1 or through a command line interface in recovery manager software called RMAN in ORACLE 11gR1 of a database management system DBMS .

In the embodiment of one or more errors that are encountered by DBMS in using database are used as triggers by data recovery advisor to automatically initiate in act the execution of one or more diagnostic procedures whose executable software is available in a storage device included within a computer system . More specifically in the embodiment illustrated in data recovery advisor uses a first map stored in memory of computer system with an error s identifier as index to look up a corresponding diagnostic procedure s identifier. Thereafter data recovery advisor uses the diagnostic procedure s identifier to initiate execution of diagnostic procedure S. When diagnostic procedure S completes it stores one or more failures in a repository in a storage device of computer system .

Many embodiments of the data recovery advisor include a number of diagnostic procedures A N to check for the integrity of the various storage structures of database . Functions performed by each of diagnostic procedures A N depend on specific details of how DBMS is implemented e.g. specific memory management techniques and or storage structures. Note that details of implementation of data recovery advisor for a specific DBMS are not critical to practicing the invention. Nonetheless certain descriptions herein refer to examples that are implemented for a DBMS available from ORACLE CORPORATION such as ORACLE 11gR1 which are intended to be illustrative and instructive examples and are not necessary to practice the invention.

Certain embodiments of data recovery advisor include a diagnostic procedure A that verifies the integrity of database files and reports failures if these files are inaccessible corrupt or inconsistent. An example of diagnostic procedure A is a database integrity check procedure for a database management system available from ORACLE . Such a database integrity check procedure may check if a control file exists for database and if so open the control file and check for physical level corruption e.g. whether or not a newly computed checksum matches a checksum retrieved from storage. The database integrity check procedure also checks the relationship of the control file with other files e.g. when other files were last updated relative to the control file.

In one illustrative example a sequence number associated with the control file is checked against a corresponding sequence number of a data file to ensure both files have the same sequence number. If the two sequence numbers from the control file and the data file are different then an appropriate failure is generated e.g. control file too old or data file too old. An example of a sequence number is a system change number or SCN in a database accessed with the database management system ORACLE 11gR1. Some embodiments also check for version compatibility e.g. that the current version number as identified by database is same as or greater than a version number within a header in the file being checked at a predetermined location therein .

A database integrity check procedure may also perform additional checks similar to the just discussed checks for the control file on each file that is identified within control file. For example DRA may check for the existence of every datafile that is identified in the control file. Moreover DRA may verify that the header information recorded in the datafiles match the corresponding information recorded for those files within the control file.

Several embodiments of the data recovery advisor include another diagnostic procedure B to check for integrity of data blocks. In an example diagnostic procedure B detects corruptions in the disk image of a block such as checksum failures checks for the presence of predetermined numbers constants and whether block number matches that block s actual offset from the beginning of the file. Most corruptions in the example can be repaired using a Block Media Recovery BMR function of the type supported by a DBMS from ORACLE . In the just described example corrupted block information is also captured in a database view. Note that diagnostic procedure B of some embodiments responds to the finding of a failure by checking if other related failures exist. For example in some embodiments diagnostic procedure B on finding one block corruption in a file proceeds to check if there are additional block corruptions in the same file within a predetermined address range around the corrupted block e.g. within 10 MB on either side of the corrupted block . Diagnostic procedure B may also be programmed to similarly sample a few blocks in other files on the same disk to further check for block corruption.

Certain embodiments of the data recovery advisor include yet another diagnostic procedure C to check for integrity of a file that holds information needed for recovery from a problem in database . This diagnostic procedure C looks for the file s accessibility and corruption and reports any issues. In an illustrative example diagnostic procedure C checks files for redo logs maintained by a DBMS from ORACLE as well as the files for archive logs if available. In the just described example diagnostic procedure C reports failures in for example archive log and or redo log.

Furthermore in some embodiments when a diagnostic procedure completes execution failures that are newly identified are aggregated if appropriate with one or more failures that are preexisting in failure repository by a diagnostic framework . Prior to aggregation a preexisting failure in repository that is to be aggregated is revalidated taking into account any dependencies of the failure. For example for a database that is maintained by a DBMS from ORACLE corruption of a data file is only relevant if that data file is a part of the database. Hence revalidation checks that the data file s entry is present in a control file of database but if it s not then the failure about this data file is closed.

After a diagnostic procedure completes execution diagnostic framework performs an impact analysis for example to identify one or more objects in database that are unavailable due to the newly identified failure s . Specifically in some embodiments impact of failures is assessed to identify what if any user defined objects are affected e.g. to identify in database a table to which a corrupted data block belongs. The table may be identified from lookup table or an off line dictionary in B which is deliberately stored outside of database to ensure that the dictionary is available in the event that database is unavailable. In some embodiments a diagnostic procedure A rather than framework includes functionality to perform impact analysis for the failures that it diagnoses and information about impact is stored in the failure repository in association with the failure being stored therein.

Also in the embodiment of data recovery advisor uses a second map also stored in memory of computer system with a failure s type in act to identify multiple repair types. As noted above the multiple repair types are alternatives to one another. Each repair type has a static association in map with multiple templates and one of the templates is selected and instantiated to create a repair if feasible in a given repair plan. Hence the second map is used in act A of certain embodiments to create multiple repair plans that are alternatives to one another. Accordingly the same failures are fixed by each of plans and which plans are alternatives to one another. After display of repair plans and in act to the user who s a DBA a selected repair plan e.g. plan is received in act followed by execution of the selected repair plan in act . Corrected data resulting from execution of such repairs is stored in memory in act followed by updating the database thereby to eliminate the errors that triggered act diagnosis of failures .

In a DRA for a database the failure groups are ordered sequentially according to the sequence of state transitions that the database makes e.g. from a mounted state to a recovery state to an open state. Correspondingly in such embodiments failures that prevent mounting the database and belong to the mount group are repaired before failures that belong to the open group and prevent opening of the database. See . However the database can be neither mounted nor open if the database s files are not accessible from a non volatile storage medium on which they are persistently stored. Therefore failures that prevent file access e.g. network or disk problems are fixed before any other failures. Thus these three failure groups are processed in a relative priority Access Mount Recovery Open.

As described earlier there are many dependencies. In view of the above described dependencies data recovery advisor of several database embodiments uses five groups of failure types as illustrated in . Examples of database failures in mount group are that control information is a missing or b corrupt or c old relative to another file of database such as a data file used by the DBMS for system data . Group is arranged within a relative priority immediately below group Group has higher priority than Group . Fixing failures in Group requires certain information including unique identifiers such as a file name and path name within the computer or alternatively a uniform resource locator URL of files of database . Without the information from storage structures accessible through such as a control file for a DBMS from ORACLE it may not be possible to even identify which files belong to database as needed to fix failures in Group . Identity of files in database is needed for example to revalidate certain failures e.g. if a data file is missing. Hence failures related to control information in group need to be fixed before any other failures of database are fixed but after group failures outside of database are fixed.

Note that the number of groups and what is within each group is very specific to the system that is to be repaired. The following sections give some examples of the failure groups used by a DRA for the Oracle database. There is no significance to the naming of the groups. The names are selected for easy reference to the DRA implementation for the Oracle database.

Referring to group is for database failures related to recovery information for database such as a redo log for a DBMS from ORACLE . Examples of database failures in group are that recovery information is a missing or b corrupt or c old relative to another file of database . Recovery group is arranged within relative priority above open group because recovery information is necessary in order to perform repairs of certain failures that prevent opening the database .

Also map for a database embodiment further includes a floating group for failures whose repairs depend only on Access group and for this reason data recovery advisor is programmed to include as many of these repairs as can be added to any repair plan for groups e.g. during consolidation in act A. Examples of failures in floating group for a database embodiment include a failure in a file which has an identical copy immediately available in computer system such as a file that is a log member e.g. redo logs for a DBMS from ORACLE . The missing file can be restored at any time assuming it is accessible because the DBMS can continue to operate using the identical copy which is available.

In some embodiments map associates each failure type with multiple repairs as per act in based on repair types that are mapped to the failure type in a predetermined map. In one example a failure is that a block is corrupt then the following three repairs are possible in a database accessible through a DBMS from ORACLE as follows a block media recovery BMR which recovers that particular block from backup b data file restore and recover which replaces the entire data file which contains the corrupted block and c database restore and recover which replaces all files of database . Accordingly these three repairs are associated with the block corrupt failure type in the following specific order a b and c to minimize the amount of work to be done if each of them is feasible for example. The next step that is done in such embodiments is simple consolidation for all repairs of failures within a group as per act in wherein for each failure the very first repair which is feasible is selected as per act . Accordingly multiple repairs of a number of objects such as blocks of a file or files of a database can be replaced with a single repair of a higher level object such as the file or the database respectively within which the number of objects are contained if the single repair is faster.

Simple consolidation as per act assists data recovery advisor of some embodiments to rapidly determine as per act whether there are loss less repairs for the failures to be fixed or if a data loss repair needs to be done to fix one of them even though loss less repair is the goal . Further to the above described example in the previous paragraph if another failure is that a redo log group is unavailable then the following two repairs are possible in a database accessible through a DBMS from ORACLE as follows a restore the redo log from somewhere else b database restore and recover up until the missing redo which loses some data. Accordingly these two repairs are associated with the redo log group unavailable failure type in the following specific order a and b so that the loss less repair a has higher priority than the data loss repair b if each is feasible. Hence if a selected repair is a data loss repair then it means that there exists no loss less repair that is feasible for the given failure type.

Accordingly in some embodiments a failure may require a feasible repair that may render redundant other repairs for other failures. As another example block corruption repairs are made redundant 1 by a full database restore and recover repair and also 2 by a full database restore and recover to a previous point in time i.e. database point in time recovery . Accordingly as per act data recovery advisor of some embodiments eliminates redundant repairs and returns to act to check if all repairs have been processed. If the result of act is yes then the repair plan is output e.g. written to a repository and eventually displayed to a database administrator via a graphical user interface GUI on display .

Note that in some embodiments simple consolidation of the type described above is performed in creating a repair plan for only certain groups i.e. not all groups. For example for a database accessible through a DBMS from ORACLE simple consolidation is not used to generate a repair plan for repairs of failures in access group and in control group see . The repairs are arranged in the repair plan in an appropriate sequence which in some cases may be based on a temporal order in which the failures were created in repository while in other cases the repairs are automatically re arranged relative to one another to make the repair plan as a whole comply with a predetermined set of rules on the sequence.

In certain embodiments when more than a predetermined number e.g. 1000 of block media repairs need to be done for a single file they are consolidated into the single data file s restore and recover. Moreover in the just described embodiments since the final outcome of this consolidation is a data file restore and recover this consolidation is performed prior to the data file consolidation described in the previous paragraph.

Referring to data recovery advisor of some embodiments consolidates repairs see act A based on impact. For example repairs whose impact creates no data loss are all consolidated into a single repair plan. Also in act A data recovery advisor identifies specific user objects that are impacted by repair and such impacts are displayed to the human user who s a DBA in act . An example of identifying a specific object in displaying impact in act is The Employee table will be offlined .

Although in some embodiments groupings of failures are used to create repairs that are included in a repair plan in other embodiments such groups are not used. For example a repair template is associated in certain embodiments with a specific failure type only and with none others in which case a repair is created by instantiating the template at the same time as the failure to which it corresponds. Therefore in some embodiments repairs are uniquely associated with specific failures for which they were created without reference to groups of the type illustrated in .

Data repair advisor of some embodiments is implemented in multiple computers in some embodiments according to a client server model. In such embodiments data repair advisor includes at least two portions namely client side software C and server side software S see . Client side software C also called client side DRA which interfaces with a human i.e. a DBA to provide a display of detailed information on failures and alternative repairs for use by the human in making informed decisions. Specifically client side DRA C responds to commands received from a DBA either through a command line prompt see or via a graphical user interface see . For example the database management system ORACLE 11gR1 supports a command line prompt via a Recovery Manager RMAN and a graphical user interface via an Enterprise Manager EM both of which are used to implement a client side DRA.

Client side DRA C of some embodiments also manages the generation feasibility checking and execution of certain repairs. In several embodiments client side DRA C interfaces to a catalog which contains information on which portions of database have been backed up into which backup files and information about a storage medium e.g. tape that contains the backup files. Note that catalog is physically included in a computer see that executes client side software C. In addition another computer executes server side software S that works with client side DRA C to recognize and repair data failures in database .

Server side software S also called server side DRA includes software called diagnostic framework which receives errors that are generated by a database management system DBMS in computer while accessing database and responds by running one or more diagnostic procedures as necessary. Diagnostic framework stores any failure that is identified by the diagnostic procedures it executes into repository and in doing so aggregates failures if appropriate by creating or updating a parent failure. Diagnostic framework may also not store a failure into repository if that failure has already previously been stored therein.

Accordingly diagnostic framework avoids storing duplicate failures in some embodiments of repository whereas other embodiments do store duplicate failures which are marked as such in repository . In some embodiments a portion of a diagnostic procedure is re executed by diagnostic framework to revalidate stored failures prior to usage e.g. to display them to the DBA and or use them to generate repairs . Hence server side DRA C also includes a failure revalidation module that triggers execution of the revalidation software by diagnostic framework appropriately as described herein. One example of repository is an automatic diagnostic repository ADR which is supported by the database management system ORACLE 11gR1 .

Client side DRA C of some embodiments includes a parser not labeled that parses a user s input and invokes one of several functional components which are implemented as individual drivers for each of the following commands LIST command CHANGE command ADVISE command REPAIR command and VALIDATE command . Specifically the driver for LIST command interacts with software called failure repair data manager which is included in server side DRA S and provides an interface to repository that holds failures. Accordingly the driver for LIST command is able to instruct server side DRA S to prepare a list of one or more failures that are currently present in repository . The list of failures which is generated by server side DRA may be limited based on information supplied by LIST command e.g. to only critical failures or only to failures related to a specific component of database .

Similarly other above described commands are also supported by failure repair data manager . For example arrow A illustrates support to the ADVISE command provided by failure repair data manager in response to one or more failures selected to be fixed e.g. by the DBA . Failure repair data manager responds with repairs including steps and descriptions to fix the identified failure s which are then displayed by client side DRA C to the DBA. Thereafter for each repair the driver for ADVISE command invokes as shown by arrow B certain software called repair and feasibility manager that is included in client side DRA C to check feasibility of the proposed repair.

Note that in some embodiments repair and feasibility manager optimizes performance of multiple feasibility checks that involve the same database object by performing one feasibility check for that database object and then copying the result for the remaining feasibility checks. For example if one repair is BMR on datafile block wherein BMR is an abbreviation for block media recovery which is a command supported by a DBMS from ORACLE and another repair is BMR on datafile block then repair and feasibility manager performs a single check for feasibility of BMR on datafile and then marks both repairs with the same result.

When a repair is found to be feasible the driver for ADVISE command invokes software in server side DRA S called repair consolidation module as shown by arrow C. Repair consolidation module in turn consolidates repairs that are to be included in a repair plan and stores them in repository which thereafter supplies the repairs back to client computer for display to the DBA e.g. via the graphical user interface. Repairs selected by the DBA are processed by the driver for the REPAIR command which supplies the repair for execution to repair and feasibility manager .

Repair and feasibility manager is responsive to repairs and if invoked by the driver for the ADVISE command performs feasibility checks that can be performed locally within client computer to confirm that the repair is feasible e.g. checks if the file needed for repair is present in catalog . Specifically repair and feasibility manager checks if any backup files needed for the repair are identified in catalog . Repairs may also be supplied to repair and feasibility manager by a driver for REPAIR command in which case the corresponding repair steps are executed either locally in computer or remotely in server computer . For any repairs whose feasibility cannot be checked or which cannot be executed locally within client computer repair and feasibility manager supplies the repairs to certain software within server side DRA S called execution engine S.

Execution engine S initiates feasibility checks with server computer to see if a repair specified by repair ID is feasible. Execution engine S supplies the results of feasibility checking to software called failure repair data manager and in certain embodiments the results are stored in volatile memory while other embodiments store the results in repository . Note that execution engine S also executes repair steps by performing various transactions on database . Additionally server side DRA S also includes software called repair consolidation module that retrieves all feasible repairs from memory or from repository as appropriate depending on the embodiment to consolidate them to create one or more repair plans as per acts and A described above in reference to respectively . In creating repair plans repair consolidation module implements use of groups of failures as per to identify the failures to be fixed in a current iteration.

Diagnostic framework is implemented in a modular manner in some embodiments of the invention to enable a human developer of server side DRA S to specify an error and its corresponding diagnostic procedure in a set of source code files that is compiled into maps and data structures that are accessible by DRA at runtime. This simplifies the process of preparing and maintaining server side software S. Note that multiple errors can be specified for diagnosis using the same diagnostic procedure.

The specific manner in which data repair advisor is compiled into an executable software and data separated into individual files or data hardcoded into and interspersed within software relates to implementation details that change depending on the embodiment and are not important to practicing the invention. Also not important to practicing the invention are details about the language in which data repair advisor is written e.g. as macro calls or as C language function calls .

In some embodiments a repair plan that is created by repair consolidation module is modified by client side DRA C as may be necessary prior to execution. For example if a data file is to be restored or recovered from backup a repair manager RMAN in a database management system available from ORACLE may be designed to automatically include an initial command to offline the data file prior to the repair a command to perform the repair followed by a final command to online the data file.

Use of a data repair advisor to fix a failure is now described in reference to which illustrate screens that are displayed to a DBA in some embodiments whereby the screens are generated by Enterprise Manager in a database management system available from ORACLE . Specifically in these embodiments after an error occurs the DBA may view the screen of which shows the error message The operation for starting up the database has failed. Click View Details to see the error. You may have to perform a recovery. In response the DBA may click on the View Details hyperlink as shown in which results in display of the screen illustrated in . After reviewing status details and error messages such as . . . cannot identify lock data file . . . the user clicks the OK button at the bottom right corner of this screen. In response the DBA is shown the screen illustrated in wherein the DBA may click on the Perform Recovery hyper link. After doing so the DBA is shown the screen of wherein they must enter their user name and password.

Thereafter the screen of is displayed showing that a high priority failure has been diagnosed by data repair advisor . The DBA is prompted to click on the Advise and Recover button and on doing so the screen of is displayed. Note that the failure is described as One or more non system data files are missing. This is an aggregate failure and accordingly the DBA may click on a icon under the Failure Description to request a detailed display of the individual failures. On doing so the screen of is displayed wherein three failures are all identified as being of high priority. To view the repair strategy recommended by data repair advisor the DBA must click on the Advise button.

On clicking the Advise button the data repair advisor displays as per two recommendations for repair both of which ask the DBA to consider manual repairs. Specifically two files are to be renamed as specified in . In this example assume the DBA does the requested changes manually and returns to the screen display as per . At this stage the DBA may click on the Re assess Failures button to see if the manual operations were sufficient. On doing so data repair advisor revalidates all failures and closes any failure that has been repaired. Thereafter the screen of is displayed and the DBA may once again click on the icon to view details of the aggregated failure which are shown in .

In the screen of the DBA may one again click on the Advise button and on doing so the screen shown in is displayed. Another file needs to be renamed or moved manually as per . Here assume the user does not wish to do this task manually then they may click on the Continue with Advise button in which case the screen of is displayed. As shown in data repair advisor has generated an RMAN script. The DBA may click on the Continue button in which causes the screen of to be displayed.

As shown in the user may review the script to be executed and its impact and if acceptable click on the Submit Recovery job button. On doing so data repair advisor waits for repair script to execute and then displays the results as per . At this stage as the repair was successful the database has been opened. The DBA may next click the OK button in the screen of and on doing so they are prompted to log into the Enterprise Manager. The DBA may then proceed with use of the Enterprise Manager in the normal manner because the database has started operating with no errors at this stage.

Data recovery advisor may be implemented in some embodiments by use of a computer e.g. an IBM PC or workstation e.g. Sun Ultra 20 that is programmed with an application server of the type available from Oracle Corporation of Redwood Shores Calif. One or more such computer s can be implemented by use of hardware that forms a computer system as illustrated in . Specifically computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information. Each of computers includes a processor e.g. computer includes processor while computer includes another processor not shown . Moreover computers and are coupled to one another by any transmission medium that transfers information therebetween such as a local area network or a wide area network.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

As described elsewhere herein incrementing of multi session counters shared compilation for multiple sessions and execution of compiled code from shared memory are performed by computer system in response to processor executing instructions programmed to perform the above described acts and contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement an embodiment of the type illustrated in any of described above . Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a computer readable medium may take many forms including but not limited to at least two kinds of storage media non volatile storage media and volatile storage media . Non volatile storage media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a flash memory a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other medium of storage from which a computer can read.

Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications. Transmission media includes a carrier wave that is computer readable.

Various forms of computer readable media such as a storage device may be involved in supplying the above described instructions to processor to implement an embodiment of the type illustrated in . For example such instructions may initially be stored on a magnetic disk of a remote computer. The remote computer can load such instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem that is local to computer system can receive such instructions on the telephone line and use an infra red transmitter to convert the received instructions to an infra red signal. An infra red detector can receive the instructions carried in the infra red signal and appropriate circuitry can place the instructions on bus . Bus carries the instructions to main memory in which processor executes the instructions contained therein. The instructions held in main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . Local network may interconnect multiple computers as described above . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a code bundle through Internet ISP local network and communication interface . In accordance with the invention one such downloaded set of instructions implements an embodiment of the type illustrated in . The received set of instructions may be executed by processor as received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain the instructions in the form of a carrier wave.

Numerous modifications and adaptations of the embodiments described herein will be apparent to the skilled artisan in view of the disclosure.

Referring to repositories and may be located outside of database in some embodiments to ensure their availability even when a control file of database becomes corrupted. Also one or more of repositories and may be combined with one another and or co located depending on the embodiment. For example all repositories and may be located on a disk that is separate and distinct from the disk on which database is located. As another example all of repositories and may be located in a file that is separate and distinct from files of database although all these files may be located on the same disk. In the just described example the underlying file system ensures that a corruption in a database file does not affect the file containing repositories and . Also each of repositories and may itself be located in a separate file depending on the embodiment. Furthermore repositories and that contain software code may be maintained in a different media relative to repositories and that contain data.

Following Subsections A D are integral portions of the current patent application and are incorporated by reference herein in their entirety. Subsections A D describe new commands that implement a data repair advisor of the type illustrated in within a recovery manager in one illustrative embodiment of a database management system in accordance with the invention. Note that the word you in the following attachments refers to a database administrator DBA .

Use the ADVISE FAILURE command to display repair options for the specified failures. This command prints a summary of the failures identified by the Data Recovery Advisor and implicitly closes all open failures that are already fixed.

The recommended workflow is to run the following commands in an RMAN session LIST FAILURE to display failures ADVISE FAILURE to display repair options and REPAIR FAILURE to fix the failures.

RMAN must be connected to a target database. See the CONNECT and RMAN commands to learn how to connect to a database as TARGET.

The target database instance must be started. The target database must be a single instance database and must not be a physical standby database although it can be a logical standby database.

In the current release Data Recovery Advisor only supports single instance databases. Oracle Real Application Clusters Oracle RAC databases are not supported.

Data Recovery Advisor verifies repair feasibility before proposing a repair strategy. For example Data Recovery Advisor checks that all backups and archived redo log files needed for media recovery are available. The ADVISE FAILURE output indicates the repair strategy that Data Recovery Advisor considers optimal for a given set of failures.

Manual repair options are either mandatory or repair optional. The repair optional actions may fix the failures more quickly or easily than automated repairs. In other cases the only repair options are manual because automated repairs are not feasible. For example I O failures often cannot be repaired automatically. Also it is sometimes impossible to diagnose a failure because insufficient data is returned by the operating system or the disk subsystem.

Each automated repair option is either a single repair or a set of repair steps. When a repair option has a script that contains multiple repair steps ADVISE FAILURE generates the script so that the repair steps are in the correct order. A single repair always fixes critical failures together. You must repair critical failures but you can also repair noncritical failures at the same time. You can repair noncritical failures in a random order one by one or in groups.

If a data failure brings down all instances of an Oracle RAC database then you can mount the database in single instance mode and use Data Recovery Advisor to detect and repair control file SYSTEM datafile and dictionary failures. You can also initiate health checks to test other database components for data failures. This approach will not detect data failures that are local to other cluster instances for example an inaccessible datafile.

ADVISE FAILURE ALL CRITICAL HIGH LOW failureNumber failureNumber . . . . . . EXCLUDE FAILURE failureNumber failureNumber . . . 

The ADVISE FAILURE output includes the LIST FAILURE output which is described in ATTACHMENT B below. RMAN presents mandatory and repair optional manual actions in an unordered list. If manual repair options exist then they appear before automated repair options. Following table describes the output for automated repair options.

This example shows repair options for all failures known to the Recovery Data Advisor based on use of the Recovery Manager which provides the command prompt RMAN . The example indicates two failures missing datafiles and a datafile with corrupt blocks.

Use the generic LIST command to display backups and information about other objects recorded in the Recovery Manager RMAN repository.

Execute LIST only at the RMAN prompt. Either of the following two conditions must be met 1 RMAN must be connected to a target database. If RMAN is not connected to a recovery catalog and if you are not executing the LIST FAILURE command then the target database must be mounted or open. If RMAN is connected to a recovery catalog then the target database instance must be started. 2 RMAN must be connected to a recovery catalog and SET DBID must have been run.

With the exception of the LIST FAILURE command the generic LIST command displays the backups and copies against which you can run CROSSCHECK and DELETE commands.

The LIST FAILURE command displays failures against which you can run the ADVISE FAILURE and REPAIR FAILURE commands.

RMAN prints the LIST command s output to either standard output or the message log but not to both at the same time.

LISTDB UNIQUE NAME ALL OF DATABASE database name EXPIRED listObjectSpec maintQualifier recoverableClause . . . recordSpec forDbUniqueNameRepair option FAILURE ALL CRITICAL HIGH LOW failureNumber failureNumber . . . CLOSED . . . EXCLUDE FAILURE failureNumber failureNumber . . . DETAIL INCARNATION OF DATABASE database name listObjectSpec maintQualifier recoverableClause . . . recordSpec RESTORE POINT restore point name RESTORE POINT ALL forDbUniqueNameRepair option ALL GLOBAL SCRIPT NAMES

This example lists all failures regardless of their priority. If you do not specify ALL then LIST FAILURE output does not include failures with LOW priority.

This command enables you to change the status of failures. Use the LIST FAILURE command to show the list of failures.

In the following example the LIST FAILURE command shows that a datafile has corrupt blocks. The failure number is 5 and has a priority of HIGH. You decide to change the priority of this failure to low.

The recommended workflow is to run LIST FAILURE to display failures ADVISE FAILURE to display repair options and REPAIR FAILURE to fix the failures.

The target database instance must be started. The database must be a single instance database and must not be a physical standby database.

Make sure that at most one RMAN session is running the REPAIR FAILURE command. The only exception is REPAIR FAILURE . . . PREVIEW which is permitted in concurrent RMAN sessions.

To perform an automated repair the Data Recovery Advisor may require specific backups and archived redo logs. If the files needed for recovery are not available then the recovery will not be possible.

Repairs are consolidated when possible so that a single repair can fix multiple failures. The command performs an implicit ADVISE FAILURE if this command has not yet been executed in the current session.

RMAN always verifies that failures are still relevant and automatically closes fixed failures. RMAN does not attempt to repair a failure that has already been fixed nor does it repair a failure that is obsolete because new failures have been introduced since ADVISE FAILURE was run.

By default REPAIR FAILURE prompts for confirmation before it begins executing. After executing a repair RMAN reevaluates all existing failures on the chance that they may also have been fixed.

If a data failure brings down all instances of an Oracle RAC database then you can mount the database in single instance mode and use Data Recovery Advisor to detect and repair control file SYSTEM datafile and dictionary failures. You can also initiate health checks to test other database components for data failures. This approach will not detect data failures that are local to other cluster instances for example an inaccessible datafile.

This example repairs all failures known to the Recovery Data Advisor. The example repairs two failures missing datafiles and a datafile with corrupt blocks. After the recovery RMAN asks whether it should open the database.

The following example previews a repair of the first repair option of the most recent ADVISE FAILURE command in the current session. Note that the sample output for the LIST FAILURE and ADVISE FAILURE commands is not shown in the example.

You can use SPOOL in conjunction with REPAIR FAILURE . . . PREVIEW to write a repair script to a file. You can then edit this script and execute it manually. The following example spools a log a repair preview to tmp repaircmd.dat.

