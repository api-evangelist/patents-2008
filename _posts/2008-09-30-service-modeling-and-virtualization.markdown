---

title: Service modeling and virtualization
abstract: The systems and methods described herein can be used to provide virtual service environments. In one embodiment, a virtual service model is generated by detecting one or more transactions, each of which includes a request sent from a requester to a software service and a response sent from the software service to the requester; storing information describing the detected transactions in a virtual service model, where the information describing each transaction includes information identifying a command included in the request and information identifying a response attribute included in the response; and generating information describing an unknown transaction, where the information describing the unknown transaction includes information identifying a first command and information identifying a first response attribute. The first command and the first response attribute are copies of a corresponding command and a corresponding response attribute associated with a corresponding one of the detected transactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08112262&OS=08112262&RS=08112262
owner: Interactive TKO, Inc.
number: 08112262
owner_city: Plano
owner_country: US
publication_date: 20080930
---
This invention relates to testing and more particularly to systems for testing software that depends on and or interacts with a constrained service that may not always be available for use during testing.

As software becomes more sophisticated it becomes more difficult to quickly and easily perform thorough software testing. One such difficulty arises when software testing involves testing the ability of a program or application under test to interact with a constrained software resource such as a database metered partner service or the like. For example an airline may be reluctant to test a new reservation application against the airline s live production database in order to avoid negatively impacting e.g. in terms of database response time actual consumer transactions that will be taking place at the same time as testing. Similarly in order to reduce costs a financial institution may wish to minimize interactions between a new credit card application system and a partner service due to per transaction fees such as those that are charged for each credit check charged by the partner service. In yet another example the constrained service may still be in development and thus not yet available to interact with the application under test. As the above examples show it is desirable to be able to test the application under test in a manner that avoids interacting with the actual constrained service while also obtaining test results that indicate whether the application under test will ultimately be able to properly interact with the constrained service.

While the invention is susceptible to various modifications and alternative forms specific embodiments of the invention are provided as examples in the drawings and detailed description. It should be understood that the drawings and detailed description are not intended to limit the invention to the particular form disclosed. Instead the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

Various embodiments of the systems and methods described herein can be used to provide virtual service environments. These virtual service environments can be used for various purposes including development testing load testing integration testing and training. In many situations the services to virtualize within virtual service environments can be identified during the software design phase and then the identified services can be virtualized and implemented within virtual service environments during the development phase. The virtual service environments can then be used throughout the development and testing phases.

The virtual service environments operate to present one or more virtual services. Each virtual service responds to requests in a manner that is structurally consistent with the service being virtualized. Providing virtual services allows an application e.g. an application under test or an application being used for training purposes to interact with a virtualized representation of a software service that might not otherwise be readily available e.g. due to constraints associated with that software service for testing or training purposes.

Service can be any of a variety of different services and can be implemented as any one or more of a variety of software components. For example service can be a database server that is configured to respond to requests to access information stored in a database. Alternatively service can be a web service e.g. having an interface defined by a web service definition language WSDL file a web site e.g. as implemented by one or more web pages provided by a web server a legacy application operating on a mainframe a data service an order manager a transactional data store an enterprise resource planning ERP system an enterprise application integration EAI system or the like. Service can be implemented as an object or other component e.g. an enterprise service bus ESB construct an Enterprise JavaBean EJB a web component such as a JavaServer Pages JSP page or Java servlet component other standalone Java component or Java applet as an application that includes any of the previously mentioned components or the like.

Requester can similarly be implemented as any of a variety of different software components or a combination of such components . In some embodiments there may be multiple independent requesters present and generating requests at substantially the same time. In such embodiments service model generator can detect requests being generated by more than one requester as well as the responses provided in response to those different requesters requests.

As shown in requester generates a request which is sent to service . In response to receiving the request service generates a response and returns the response to requester . Service model generator is coupled e.g. logically and or physically between requester and service such that service model generator can effectively observe and record the traffic i.e. the requests and responses being exchanged between requester and service . For recording purposes each request and its corresponding response are grouped together and a group containing a request and its corresponding response is referred to herein as a transaction. The recorded transactions are stored as a service model which will be used to implement a virtual service environment that virtualizes service as will be described in more detail below with respect to . An example of the information that can be stored as part of a service model is provided in .

A user can also provide information describing transactions to service model generator for inclusion in service model . Such transactions are referred to as user supplied transactions in contrast to the observed transactions that are recorded in response to service model generator actually observing traffic being exchanged between requester and service .

Service model generator can also generate and store information identifying one or more characteristics of the transactions. Such information can include timing information identifying times at which particular requests and or responses are detected or sent e.g. in order to identify the delay between when the request was detected and or sent and when the associated response was detected and or sent information identifying current bandwidth usage of a network on which the traffic is being conveyed information identifying current processor and or memory usage on one or both of the computing devices implementing requester and service and the like. Service model generator can store such information as part of service model .

Service model generator is configured to detect and record traffic at the network and or communication protocol level. The particular communication protocol can vary according to the type of service provided by service . Service model generator can be configured to identify requests and responses in each of a variety of different protocols and to extract and record the pertinent information from each. Thus service model generator can include configuration information identifying the basic structure of requests and responses for each of several supported communication protocols. When generating service model service model generator can access the appropriate configuration information in order to process the observed traffic. Depending upon the protocol in use requests can take the form of method calls to an object queue and topic type messages e.g. such as those used in Java messaging service JMS requests to access one or more web pages or web services database queries e.g. to a structured query language SQL or Java database connectivity JDBC application programming interface API packets or other communications being sent to a network socket and the like. Similarly responses can include values generated by invoking a method of an object responsive messages web pages data state values e.g. true or false and the like.

In order to be able to detect and record traffic service model generator is configured to logically insert itself into the communication pathway between requester and service . In some embodiments inserting service model generator into the communication pathway can also involve modifying requester and or software e.g. such as a driver with which requester interacts. For example if service is a web site or web service service model generator can be configured as a web proxy or gateway and requester can be modified to communicate with service via the proxy or gateway implemented by service model generator . In such a situation when service model generator receives a request being sent to the proxy service model generator can generate and store information identifying the request and or any desired request characteristics and then service model generator can send the request to service . If needed service model generator can modify the request before sending the request to service so that the response generated by service will be returned to service model generator .

Various other configurations of service model generator are possible. For example if requester and service communicate via messaging service model generator can be configured to monitor the appropriate queue s and topics for new messages being exchanged between requester and service . If service is a database the driver manager used by requester can be modified to indicate that service model generator is the driver for the database such that requests sent to the database will be provided to service model generator and such that responses provided by the database will be returned to the requester via service model generator . If service is an object service model generator can be configured to intercept method calls to the object generate information identifying those method calls to be stored as part of service model and then to pass the method call to the object being called. Similarly service model generator can intercept responses from the object being called store information identifying those responses as part of service model and then provide those responses to requester .

In some embodiments the functionality provided by service model generator is distributed throughout a networked system. For example a component of service model generator that is configured to monitor requests and responses sent according to a particular transport and or data communication protocol can be deployed on each client system that includes a requester and or each system that implements service . This component can be configured to communicate requests and responses to another component of service model generator that is configured to manipulate such information and or to store such information with a service model .

Each request includes a command. The command can be the operation included in a SOAP message the method being invoked on an object a database command a particular command or operation specified by a communication protocol or the like. Whenever service model generator detects a request service model generator can identify the command contained within that request e.g. using configuration information associated with the type of protocol in use in order to identify which portion of the request contains command information and store information identifying that command as part of service model .

Requests may also include attributes. For example the request can include a command to perform a login operation as well as attributes that include the user name and password to be used in the login operation. Accordingly service model generator can also parse requests in order to identify whether any attributes are present and if so to extract and store information identifying those attributes. Thus information identifying a request in service model can include information identifying a command as well as information identifying any attributes present within the request.

Responses can include one or more attributes. Whenever service model generator detects a response service model generator parses that response e.g. using protocol specific configuration information in order to determine how to locate the attributes within the response . Service model generator can then store each attribute detected within the response as part of the information identifying the response within service model .

When service model is used to virtualize service as will be explained in greater detail below the virtualization process will involve comparing new requests generated by a requester to the request information stored in service model . For example if a new request containing a particular command and attribute is received service model can be searched for a matching request that contains the same command and attribute. If a matching request is found the virtualization process returns the response as identified by information stored in service model associated with the matching request to the requester.

In many situations the requests provided to the virtualized service will not be exactly the same i.e. containing the same request as well as the same attribute s as the requests identified in service model . For example a request provided to the virtualized service may contain the same request but a different attribute or set of attributes. Accordingly service model generator is also configured to generate information usable to handle these requests and to store that information as part of service model .

In order to generate this additional information service model generator can identify each unique type of transaction that has been observed or specified by a user. For example in some embodiments service model generator can be configured to identify all transactions containing requests that specify the same command as being of the same transaction type. Alternatively service model generator can be configured to identify a set of transactions as being of the same type if all of those transactions have requests that include the same command as well as the same number and type of attributes. The particular technique used to identify whether two or more transactions are of the same type can be protocol specific in some embodiments e.g. service model generator can use different techniques to classify transactions depending upon the particular communication protocol being used between the requester and the service .

For each unique type of transaction included in service model e.g. obtained either via observation of communication or via user specification service model generator can generate additional information that can be used to model service s response to a similar transaction of that type that contains an unknown attribute i.e. an unknown attribute in this context is an attribute that was not observed as part of the monitored traffic or specified by a user during the model building process . For example service model generator can observe and record three different simple object access protocol SOAP requests that include the getUser command and a user can specify a fourth getUser transaction for inclusion in service model . In response to identifying that these transactions are the same type of transaction service model generator generates information describing a fifth getUser transaction that will be used to handle transactions of that type that specify unknown attributes. This information for the fifth transaction can include information identifying the request by the getUser command as well as information identifying the appropriate structure if any of the request e.g. by identifying the number and or type of attributes that can be included in the request as determined from the other four transactions of that type . The information describing the attributes of the request of this transaction can be wildcard information or otherwise indicate that any unknown attribute s i.e. attributes that are not the same as the attribute s in the observed and user specified transactions should match this request s attribute information.

The information describing the fifth transaction also includes information identifying an appropriate response. In one embodiment service model generator generates this response information by simply copying the response portion of the information describing one of the other four getUser transactions into the information describing the response portion of the fifth transaction. Service model generator can also or alternatively prompt a user to select the particular transaction from which this response information should be copied.

Similarly service model generator can also generate information describing a transaction that is used to model service s response to an unknown request i.e. an unknown request in this context is a request that contains a command that was not observed as part of the monitored traffic or specified by a user during the model building process . The request portion of this generated information can indicate e.g. through the use of a wildcard command identifier that all unknown types of requests that are not otherwise identified in service model should match this request. The response portion of the generated information can include an appropriate response. In some embodiments the response is protocol specific and can be obtained for example from protocol specific configuration information accessed by service model generator . Alternatively service model generator can prompt a user for the appropriate response to include in this transaction.

In some embodiments service model generator can provide or otherwise be configured via a user interface e.g. such as user interface of that allows a user to configure service model generator to generate a particular service model. Such a user interface can be a graphical user interface command line interface or the like.

The configuration process for service model generator can involve the user selecting via the user interface the particular service to be modeled. As part of the configuration process the user can be prompted to enter information identifying a specific service to be modeled e.g. service as well as information identifying or indicating the protocol s used to communicate with the identified service. For example the user can identify a specific service by indicating the network port used to communicate with that service as well as that hyper text transfer protocol HTTP and SOAP are used to communicate with that service. In response to this information being provided service model generator can insert itself in between the requester and the service to be modeled. For example an instance of an observation module not shown that is configured to obtain request and response information for the specified transport and or data communication protocols can be instantiated. This observation module is part of service model generator and performs the functions needed to obtain information describing the requests generated by the requester and the corresponding responses generated by the service.

Service model generator can also provide a user interface that includes one or more controls that allow a user to configure start and stop the model building process. Another control can allow a user to save a model generated by service model generator . Yet another control can allow a user to modify a model generated by service model generator e.g. a user can be allowed to modify or delete all or some of the information generated by service model generator . Similarly a user can be allowed to modify a model by adding additional information e.g. identifying new types of requests and associated responses identifying new attributes for a particular type of requests and associated responses and or identifying responses to be used for unknown requests .

Thus service model generator can begin and end the model building process in response to user input provided at the time that modeling should begin and end. Alternatively instead of selecting a start or stop option the user can specify a time and or conditions under which model building should begin as well as a time and or conditions under which model building should end. For example a user can specify that model building should begin at 1 00 AM on a particular date and continue until 3000 transactions have been recorded. Similarly a user can specify that model building should begin when a particular type of request is detected and continue until the user selects to end the model building process.

Furthermore the model building process can be restarted. For example a user can cause service model generator to generate a model of a particular service. At a future point in time the user can restart the model building process for the same service causing service model generator to generate additional information to include in the service model for that service. Similarly a user may select to edit an existing service model in order to add additional virtual functionality e.g. in the form of new types of transactions and or additional transactions of an existing type to the model.

In some situations instead of creating at least a portion of a model based upon actual observed traffic service model generator can create a model based only upon user input specifying particular transactions information describing additional observed transactions could be added at a later time . For example if such information is not already available service model generator can prompt a user for information identifying the service to be modeled as well as information indicating the protocol used to communicate with the service to be modeled. Service model generator can then prompt the user for appropriate information e.g. given the type of service being modeled and the communication protocol s used to communicate with that service identifying one or more transactions. This information can include information identifying a request e.g. by identifying the command contained within that request as well as any attributes provided as part of that request and a corresponding response e.g. by identifying one or more attributes contained within the response as well as information identifying a characteristic of that request and or response. In situations in which service is not available e.g. because service is still being developed all of the transactions identified in service model can be obtained via user input instead of via traffic observation.

In one embodiment a user can specify multiple transactions at once. For example when prompted a user can select a file e.g. a spreadsheet file that contains information describing many different transactions. Such a file can be for example a production log that describes the activity taking place in a production system during a normal period of operation. In response to the user specifying the file service model generator can access the file extract the relevant information and store the extracted information in the model. In some embodiments service model generator can access an appropriate configuration file that indicates how particular fields in the production log or other file specified by the user map to the different types of information maintained in the service model e.g. the particular configuration file to access can be specific to the service the protocol s used to communicate with the service or the like .

As noted above a user can also modify the information describing one or more observed transactions. In some embodiments a user can relax the matching criteria associated with a transaction. For example an observed request can include a command requesting for flight information from a particular origination city to a particular destination city and the virtual service model may default to matching only requests that include the same command and attributes. A user can select to modify the information describing this command and can replace one or more of the request attributes with special values e.g. wildcard values and or select a matching setting e.g. specifying exact matching regular expressions starts with matching contains matching or the like for one or more particular request attributes. Thus the user could modify the transaction requesting flight information to indicate that all requests for flight information that include the same destination city attribute as the observed transaction should match the observed transaction regardless of whether such requests also specify the same origination city as the observed transaction. Users can also modify information describing observed transactions in order to replace observed attributes with user specified attributes and the like.

In many situations transactions are stateless such that each transaction is independent of any transactions that have taken place beforehand. In other words for a stateless transaction service will generate the same response to a given request regardless of whether any other transactions have already been performed. In such situations service model generator generates information identifying each observed transaction in the same manner regardless of whether any other prior transactions have been observed and regardless of the attributes and commands contained within such prior transactions.

In other situations transactions are stateful such that the response included in a given transaction may differ depending upon what transaction or transactions have already been performed. In these situations service model generator is configured to generate additional state information for each transaction. This additional state information identifies the preceding transaction the state information for the preceding transaction can also be modified to identify the subsequent transaction . More information regarding stateful transactions is provided in the discussion of .

In this example transaction A is an observed transaction. In other words transaction A is a transaction that actually occurred between a requester and the service being modeled as detected by a service model generator. The information describing transaction A includes request information which includes command and zero or more observed attributes . The information describing transaction A also includes response information describing the observed response that corresponds to the observed request. This response information can also include one or more attributes. Observed characteristics can include zero of more observed characteristics of transaction A . These observed characteristics can include timing information describing when the request and or response were observed or the like as described above.

Like transaction A transaction B is a transaction that actually occurred i.e. an observed transaction . Transaction B is of the same transaction type as transaction A since both transactions included a request that contained command . Transaction B is described by observed attributes which can have values that differ from those attributes observed in the request of transaction A observed characteristics which can again differ from those observed for transaction A and observed response which can also have a value that differs from the response observed for transaction A .

In this example information describing n an integer number known transactions of the same type as transactions A and B is stored in service model . These known transactions are transactions that were either observed or specified by a user. As part of the model building process information describing an n 1th transaction of the same type has been added to service model by the service model generator. This n 1th transaction labeled transaction 1 describes an unknown transaction of a known type of transaction. Such an unknown transactions is of a known type because it has the same command command as the other transactions of this type. However unlike the other known transactions of this type unknown transaction 1 can be used to respond to requests containing command and unknown attributes that do not match those known i.e. either observed or user specified attributes stored for transactions A not shown . The information describing transaction 1 thus includes information e.g. wildcard information identifying unknown attributes 1 such that any request that includes command and an attribute that does not match the observed attributes stored for the actual transactions e.g. such as transactions A and B will match the request information for transaction 1 .

The information describing transaction 1 also includes default characteristics 1 and default response 1 . These default values can be copied from the corresponding fields of an actual response of the same type. In some embodiments the service model generator prompts a user to select the actual transaction from which these values should be copied. Alternatively a user can be prompted to enter these values directly.

Information describing another set of transactions of a different type is also stored within service model . As shown m 1 transactions including transaction A B and 1 of a type of transaction in which the request includes command are stored in service model . Like transactions A and B transaction A is an observed transaction and thus the information describing this transaction includes the observed command observed attributes if any observed characteristics if any and observed response .

In contrast transaction B is a user specified transaction. This transaction was thus not observed and did not necessarily ever even occur. Instead a user entered the information describing this transaction via a user interface. The information describing transaction B includes command zero or more user specified attributes zero or more user specified characteristics and a user specified response . In some embodiments the user is prompted for entirely new information for each of these user specified fields. In other embodiments the user can be allowed to select an existing field e.g. of another user specified transaction or of an observed transaction to copy into one or more of these fields. It is noted that a user can also create a user specified transaction by modifying information describing an actual transaction. As shows user supplied transaction information can be stored in the same model as transaction information captured by observing actual traffic exchanged between a requester and the service being modeled.

A final transaction 1 is an unknown transaction. The information describing transaction 1 was added to service model after m an integer number which does not necessarily have the same value as n known transactions were described by the model. The information describing this unknown transaction 1 can be used to handle requests of the same type e.g. containing command that specify unknown attributes. Accordingly the information describing transaction 1 includes command unknown attributes 1 i.e. attribute information that will match any attributes not identified in the known attributes stored for the other m transactions of this type default characteristics 1 and default response 1 .

A final transaction is also described in service model . Transaction is an unknown transaction of unknown type. In other words the information describing this transaction can be used to respond to any request of a type not already described by another row of service model . Accordingly a request containing a command other than commands and could be responded to using the information describing transaction .

As shown the information describing transaction includes unknown command information which is configured to match any command not already specified in service model unknown attribute information which is configured to match all attributes if any associated with unknown commands default characteristics and a default response . As with the default characteristics and responses associated with unknown transactions of known type transaction s default characteristics and response can be user specified.

The method begins at where a service model generator determines whether a request has been detected. As noted above detection of a request can vary depending upon the particular transport and or data protocols in use between the requester s and the service being modeled. For example detection of a request can involve monitoring a queue intercepting method calls to an object intercepting requests being sent to a web server or database application or the like.

If a request is detected information identifying the observed request e.g. information describing the command included in the request the attribute s included in the request if any and information describing one or more characteristics of and or associated with the request if desired and the associated response e.g. information describing the attribute s included in the response as well as information describing one or more characteristics of and or associated with the response if desired is stored as part of the service model as indicated at .

Operations and can repeat indefinitely until a user selects to end the model building process or at least the portion thereof that generates information describing observed transactions or until prespecified ending conditions are met.

At a determination is made as to whether user input specifying a request has been received. This determination can be made for example by detecting whether a user has selected an option in a user interface to add additional transactions to and or modify existing transactions in the service model.

If user input specifying a request has been received information identifying the user specified request e.g. information describing a command and or the attribute s included in the request if any and information describing one or more characteristics of and or associated with the request if desired and the associated user specified response e.g. information describing the attribute s included in the response as well as information describing one or more characteristics of and or associated with the response if desired is stored as part of the service model as indicated at .

While operations and are shown as taking place serially these operations may be performed in parallel or in the opposite order shown in other situations and or embodiments. For example a user can initially enter information describing several user specified transactions e.g. by selecting a production log file before enabling the service model generator to begin observing and recording actual transactions taking place. Similarly in some embodiments a user can select to enter information specifying a user specified transaction while the service model generator is observing and recording actual transactions. In other embodiments a user may not be allowed to enter user specified transactions into the service model while transaction observation and recording is taking place. In still other situations operation may be performed and operation may not or vice versa.

At a determination as to whether the model building process is complete is made. This determination can involve detecting whether the service model generator has stopped observing and recording actual transactions and or whether a user has finished entering information describing user specified transactions e.g. as determined by the user selecting a finish option or other appropriate option from a user interface . Such a determination can also be made using other stimuli. For example in one embodiment this determination can be based upon whether a user has selected to save a service model e.g. when the user saves a service model that service model is assumed to be complete .

If the model building process has finished the service model generator can perform additional processing. For example the service model generator can store information identifying an unknown transaction of a known type as shown in . This information includes information identifying a known type of request that includes one or more unknown attributes as well as an associated response. Similarly the service model generator can store information identifying an unknown transaction of an unknown type as shown at . The information identifying the unknown transaction of unknown type can include information identifying an unknown command information identifying unknown attributes as well as information identifying default characteristics and a default response.

In addition to adding information describing unknown transactions of known and unknown types other processing can also take place after the basic model building process completes. For example in some embodiments the service model supports time sensitive responses. In these embodiments the service model generator processes the response information in the model in order to substitute time sensitive attributes for actual observed attributes as shown at . Thus an actual attribute 10 59 PM Oct. 1 2009 can be replaced with a time sensitive value such as SYSTEM CLOCK 11 HOURS . When the model is used to generate responses for the virtualized service the time sensitive value is used to calculate the appropriate attribute to include in each response. Thus if the model is being used to virtualize a service and the response attribute includes the time sensitive value SYSTEM CLOCK 11 HOURS the response generated based upon the model will include the value generated by adding 11 hours to the system clock value at the time the request was received. In general time sensitive values specify an observable time such as a time value included in a request or the current system clock time and a delta such as an amount of time to add or subtract from the specified observable time. Time sensitive values can be included in the response information for all types known and unknown of transactions.

To generate the appropriate time sensitive response values the service model generator can as part of observation and recording of actual transactions record information in the service model indicating the current system clock value e.g. a time and or date at each time that a response is received by the service being modeled. Thus for a given transaction the characteristics for that transaction can include the system clock value at the service being modeled at the time that the request was received by the service being modeled.

After the model building process completes the service model generator identifies which responses in the model if any should be modified to include time sensitive values. If there is no time value in the observed response there is no need to modify the information describing the observed response to include a time sensitive value.

If instead there is a time value included in the observed response the service model generator can then determine whether the corresponding request includes a time value as one of its attributes. If the corresponding request does include a time value the service model generator can calculate the difference between the time value in the request and the time value in the response. This difference is then used to generate the time sensitive value and the time value in the response is replaced with the time sensitive value. Thus if the request includes the time value Sep. 1 2000 and the response includes the time value Sep. 14 2000 the response s time value can be replaced with the time sensitive value REQUEST DATE 13 DAYS .

If the corresponding request does not include a time value the service model generator compares the time value in the response to the recorded system clock time in the transaction s characteristics. This difference is then used to generate the time sensitive value and the time value in the response is replaced with the time sensitive value. For example if the response includes the value 6 01 AM and the characteristics indicate that the service received the corresponding request at a system clock time of 5 59 AM the time sensitive value is SYSTEM CLOCK 2 MINUTES .

If there are multiple time values in the same response the above procedure can be repeated for each different time value. Thus if there are three time values in a response three different time sensitive values can be calculated and the existing time values can each be replaced by a corresponding time sensitive value.

In some embodiments a user can modify an observed response to include a time sensitive value e.g. by selecting to add a time sensitive value via a pull down menu or add a user specified response that includes a time sensitive value. In such embodiments the user can specify whether the time sensitive value depends upon a time value in the request or the system clock value as well as how the observable time i.e. the system clock value or time value in the request should be modified e.g. by specifying an amount of time to be added to the observable time .

Another type of post model building processing that the service model generator can perform involves replacing attribute values e.g. strings in the response information associated with unknown transactions of known type with request sensitive values as shown at . The request sensitive values link an attribute included in the request to a value included in the response. For example the information describing an unknown transaction of known type can specify that there are three attributes included in requests of that known transaction type. The response information for that unknown transaction can be modified to include a request sensitive value that indicates that the value of the third attribute of the request should be used as the value of the first attribute of the response instead of an actual observed or user specified value.

When the model is used the response generated by the virtualized service will include the value indicated by the request sensitive value. For example the model can include three known transactions of a given transaction type as well as one unknown transaction of that type. The information describing the unknown transaction can indicate that the single response attribute is a request sensitive attribute that should be the same as the first attribute of the request. A request of that type that contains an unknown first attribute i.e. an attribute that does not match the attribute s stored for the three known transactions of that type in the model can be sent to the virtualized service. In response to receiving this request and accessing the request sensitive value specified in the response information for the unknown transaction the virtualized service returns a response that includes the value of the first attribute that was contained in the received response.

To generate request sensitive values the service model generator compares each request attribute in each known transaction with the response attribute s for the same transaction. If a match or other dependency is found the service model generator can create a request sensitive value that identifies an attribute in the request and a dependency if the dependency is one other than identity . For example if the information describing a known transaction of type A indicates that the request includes the string UserID as the first request attribute and that the corresponding response includes the string UserID as its second response attribute a request sensitive value specifying REQUEST ATT first request attribute can be generated. The service model generator then replaces the second response attribute for the unknown transaction of transaction type A with the request sensitive value.

In some embodiments all known transactions of a given type are processed before the corresponding unknown transaction s response information is modified. The request sensitive value is used to replace one of the unknown transaction s response attributes only if all of the known transactions of that type exhibit the same dependency. In other embodiments less stringent requirements are imposed e.g. a replacement may be made if some but not all of the known transactions exhibit the same dependency .

A service model generator can perform other types of processing in addition to those described above. For example service model generator can process information stored as part of the characteristics of each transaction in order to identify availability windows for the service load patterns for the service and the like. If patterns are identified the service model generator can update the service model to include information identifying such patterns. For example if an access window is identified for a particular type of transaction the service model generator can modify the unknown transaction of that type to include a characteristic indicating that a response or a particular type of response will only be generated if the request is received during the identified access window.

Additionally if the service model generator is recording stateful transactions the processing performed after transactions are recorded can involve identifying and merging transactions into conversations as is described in more detail below with respect to .

It is noted that a user can restart the model building process for a particular model subsequent to performance of processing operations like operations e.g. by restarting the observation and recording operations or by selecting to edit an existing model . In such situations the processing operations such as processing operations may be repeated if needed after the restarted model building process completes e.g. if a transaction of a new type is added to the model a corresponding unknown transaction of that type can be added to the model by repeating operation .

As shown the system of includes an application under test a device manager a testing driver a database driver a database a testing module virtual database service service model generator user interface and database model . These components can be implemented on the same computing device in some embodiments. However in many embodiments various components can be implemented on different computing devices. For example application under test device manager and testing driver can be implemented on one computing device while database driver is implemented on another and testing module is implemented on yet another. Thus the various components can be configured to communicate via a network.

In this example testing module includes both a service model generator to generate database model of database and a virtual database service that uses database model to virtualize database . User interface can be used to configure and control the model building process performed by service model generator as described above as well as to deploy the virtual database service .

In order to deploy virtual database service a user selects database for virtualization and causes database model to be generated. The user then selects to deploy the virtual database service. Deployment involves starting a request processing module that is configured to use the appropriate service model to process requests. The request processing module can be deployed within a software container e.g. a Java 2 Platform Enterprise Edition J2EE or JavaEE container devoted to providing virtual service environments. If desired several instances of the request processing module each of which uses the same service model can be deployed at the same time. The executing request processing module accesses database model in order to present virtual database service .

A related testing driver or other testing module can also be deployed e.g. if application under test is not executing in the same container as the request processing module on the client system i.e. the system that includes the application under test as part of the deployment process. This testing driver can be configured to provide requests generated by the application under test to virtual database service as well as to provide responses generated by virtual database service to the application under test. A similar driver or even the same testing driver can also operate as part of service model generator during the model building process described above.

In the illustrated embodiment testing driver causes database requests generated by application under test to be provided to virtual database service instead of database . Testing driver first communicates with the driver manager on the same system as application under test . Testing driver has the driver manager update the driver management information for that system to indicate that requests being sent to database driver should actually be sent to testing driver . Testing driver can then provide those requests to virtual database service .

As requests are received from application under test virtual database service can use database model to select responses to return to application . provides an example of how a service model such as database model can be used to select responses.

During the deployment process or during ongoing use of the virtual database service the user can interact with testing module via user interface in order to control how virtual database service operates. For example in one embodiment the database service model includes characteristic information for each transaction that controls how quickly responses are sent after requests are received. The user can use a slider bar or other input mechanism within user interface to specify at what percentage speed the virtual database service should operate relative to the observed speed of database . For example a user can select to have virtual database service operate at 110 of observed speed in order to identify the effect of speeding up database on application under test .

At the request processing module waits for a request. If a request is detected the request processing module then determines whether the virtual service is operating in pass through mode as shown at . In pass through mode the virtual service is not actually responding to requests. Instead the virtual service is simply receiving requests and then forwarding those requests to the actual service being virtualized. In some embodiments while the virtual service operates in pass through mode a service model generator can observe and record such requests by adding information describing those requests and their corresponding responses to the existing model of the service. A user can select whether to operate a virtual service is pass through mode by selecting an option in a user interface. In some embodiments the user can dynamically change the mode pass through or non pass through in which the virtual service is operating while operation of the virtual service is ongoing e.g. without having to stop and restart or undeploy and redeploy the virtual service .

If the virtual service is currently operating in pass through mode the request detected at is provided to the actual service being virtualized as shown at . A response can then be received from the actual service as shown at . The received response can then be provided to the requester as indicated at . In many embodiments the same mechanisms used to send and receive requests and responses while generating a service model are also used to operate the virtual service in pass through mode.

If the virtual service is not operating in pass through mode the request processing module determines whether the request is part of a transaction of a known type. In this example this determination is made by determining whether the request contains a known command as shown at . A known command is a command that was included in an actual observed or user specified transaction that is part of the service model for the service being virtualized. If the request does not contain a known command or is otherwise not part of a transaction of a known type e.g. if the request does not contain the appropriate attributes a response associated with an unknown transaction of unknown type is selected as indicated at and .

If instead the request is part of a transaction of a known type a determination is made as to whether the request is part of a known transaction. This determination can involve detecting whether any of the attributes included in the request are unknown attributes i.e. attributes having values that were not included in the actual observed and or user specified requests included in the service model as shown at . If the request includes one or more unknown attributes the request processing module selects a default response associated with the appropriate unknown transaction of known type in the model as shown at . Otherwise the request processing module selects the appropriate actual observed or user specified response from a known transaction of known type from the model.

In some embodiments determination of whether the attributes of the new request match the known attributes identified in the model is performed using an exact matching process. For example regular expressions can be used to match a received request to the requests identified in the service model. Alternatively less precise matching can be performed. For example starts with or contains type matching can be performed as part of operation . These types of matching can thus identify that the new request matches an actual known transaction even if the new request s attributes differ somewhat from those in the actual known transaction.

The request processing module can optionally manipulate the selected response in a manner indicated by the model as shown at . For example if the selected request includes a time sensitive value the request processing module can use that time sensitive value to calculate an actual time value. The request processing module can then replace the time sensitive value in the response with the calculated time value. Similarly if the selected response includes a request sensitive value the request processing module can calculate the appropriate response attribute as indicated by the request sensitive value and then replace the request sensitive value with the calculated response attribute Likewise if the selected response is associated with a characteristic specifying an access window and if the request was received outside of the specified access window additional manipulation e.g. to replace the stored response with an appropriate error message can be performed. Many other types of manipulation can also be performed in response to information contained in the service model. Once the response has been manipulated if needed the final response can be returned to the requester as shown at .

Traffic pattern can be used to store information identifying a particular service and the transactions that have been observed or otherwise added to the model of the identified service. Each service model can include a single instance of traffic pattern . As shown traffic pattern includes created field which stores date information identifying when the service model of that particular service was initially created. Traffic pattern also includes lastModified field which stores date information identifying the most recent time at which any of the information in the service model of the particular service was modified.

Traffic pattern also includes an unknownResponse field . UnknownResponse field stores information identifying the particular instance of the response pattern that stores information identifying the response to use for unknown transactions of unknown types. Accordingly in embodiments employing the data pattern of if an unknown transaction of unknown type is detected by a request processing module the request processing module will use the response pattern instance identified in unknownResponse field to generate a response.

Traffic pattern includes conversations field . Conversations field can identify one or more instances of conversation pattern . Conversation pattern stores information representing a set of two or more stateful transactions. Such a set of stateful transactions is referred to herein as a conversation. The instance s of conversation pattern identified in conversations field identify all of the observed and or user specified conversations for the service being modeled. If the particular service being modeled does not include any stateful transactions e.g. if a user has specified that the service only performs stateless transactions or if no stateful transactions have been observed or specified by a user conversations field will not identify any instances of conversation pattern .

Traffic pattern additionally includes statelessConversation field . This field can identify one or more instances of transaction pattern . Transaction pattern stores information representing a transaction. Each instance of transaction pattern identified in statelessConversation field stores information identifying a stateless transaction that was either observed or specified by a user. StatelessConversation field can identify instances of transaction pattern associated with both known and unknown transactions of known types. If the particular service being modeled does not include any stateless transactions statelessConversation field will not identify any instances of transaction pattern .

Type field can store one of two values INSTANCE or TOKEN that identifies the type of stateful transactions if any provided by the service being modeled. Instance statefulness occurs when the communication protocol used by the service is itself stateful. When instance statefulness is used each interaction between the service and a particular requester is handled by a separate instance of the service executing in its own memory space such that interactions involving different requesters are handled by different instances of the service executing in different independent memory space. Token statefulness occurs when the communication protocol used by the service is not itself stateful. When token statefulness is implemented a single instance of the service interacts with all requesters. In token statefulness scenarios each request and response can include tokens e.g. such as cookies used in HTTP that identify the particular requester that sent the request or should receive the response. In some embodiments the value of this field is set automatically e.g. by a service model generator when a user selects the communication protocol s used to communicate with the service to be modeled.

As noted above conversation pattern stores information identifying a set of stateful transactions. A given service model can include n instances of conversation pattern where n is an integer that is greater than or equal to zero.

Conversation pattern includes a starter field . This field stores information identifying an instance of transaction pattern associated with a starter transaction. The starter transaction is a transaction that acts as the first transaction in a stateful series of transactions e.g. a login transaction . In at least some embodiments all starter transactions are unknown transactions of known type as will be described in more detail below. The particular transaction type to use as a starter transaction can be specified by a user during the service model configuration process.

Conversation pattern also includes reset field . Reset field stores information identifying one or more instances of transaction pattern each of which is associated with a reset transaction such a reset transaction can be a known or unknown transaction . The value of reset field can be provided by a user e.g. the user can be prompted to identify the reset transaction s for each conversation . A reset transaction is a transaction that if detected causes the flow of the conversation to return to the point just after performance of the starter transaction. For example if a conversation includes four sequential transactions where the starter transaction is the first of the four sequential transactions and the reset transaction is detected just after performance of the third transaction in the conversation the state of the conversation will return to the state that exists just after performance of the first transaction.

Conversation pattern also includes a goodbye field . This field stores information identifying an instance of transaction pattern associated with one or more goodbye transactions of known or unknown type for the conversation. A goodbye transaction is a transaction that causes the conversation to end. To reenter the conversation after a goodbye transaction is performed the starter transaction for that conversation would need to be reperformed.

Transaction pattern stores information identifying a transaction. Transaction pattern includes request field responses field parent field children field and matchTolerance field . Transaction pattern can be used to store stateful and stateless transactions in some instances the same transaction can occur both within a conversation and in a stateless situation where no conversation is currently ongoing . Transactions that are always stateless will not include values of parent field children field or matchTolerance field .

Request field identifies the instance of request pattern that stores information identifying the request e.g. by command and attributes portion of the transaction. Similarly responses field identifies one or more instances of response pattern that store information identifying the response s that are part of that transaction. Each instance of response pattern stores one response attribute e.g. like those shown in and thus if responses field identifies multiple response patterns it indicates that each of the identified response patterns should be used to generate a response when the corresponding request is received.

Parent field stores a value identifying the instance of transaction pattern associated with the transaction that occurs immediately before the current transaction in a conversation. Thus if transaction pattern stores information identifying the second transaction in a conversation where the starter transaction is the first transaction in the conversation parent field can identify the instance of transaction pattern associated with the starter transaction.

Similarly children field can store information identifying each instance of transaction pattern associated with a child transaction of the current transaction. Thus if transaction pattern stores information identifying the second transaction in a conversation children field can store information identifying the instance of transaction pattern that stores the third transaction in the conversation. It is noted that children field can identify more than one transaction.

In some embodiments parent field and children field only identify unknown transactions of known type. In such embodiments known transactions are identified as properties of corresponding unknown transactions of the same type that occur at the same point in a conversation.

MatchTolerance field stores one of three values STRICT CLOSE or LOOSE. The stored value indicates the match tolerance for a request received immediately subsequent to the current transaction. Strict tolerance indicates that if a conversation is ongoing the request received immediately after the current transaction is only allowed to match transactions identified in the current transaction s children field . If a received request does not match one of the children transactions and is not a goodbye or reset transaction the received request will be handled as an unknown transaction of unknown type even if the service model does contain a matching transaction elsewhere.

If instead close tolerance is specified the request received immediately after the current transaction can match any of the current transaction s children as well as any of the current transaction s sibling transactions. Sibling transactions are all transactions that are identified in the children field of the transaction identified by the current transactions parent field. If the next request does not match any of these children or sibling transactions and is not a goodbye or reset transaction for the conversation the next request will be handled as an unknown transaction of unknown type.

If loose tolerance is specified even more transactions are candidates for matching the next received request. In one embodiment loose tolerance indicates that the next request can match any of the current transaction s children transactions sibling transactions or parent transactions and parents sibling transactions. In another embodiment loose tolerance indicates that the next request can match any of the transactions included in the conversation other than the starter transaction. If the next request does not match any of the transactions allowed by the loose tolerance and is not a goodbye or reset transaction for the conversation the next request will be handled as an unknown transaction of unknown type.

Thus the matchTolerance field effectively identifies a subset of the transactions within the service model that are candidates for matching the next request received after the current transaction. The value of the matchTolerance field can be set by a service model generator e.g. based upon user input a default configuration associated with the communication protocol used to communicate with the service being modeled or the like . Different transactions within the same service model as well as different transactions within the same conversation can have different levels of match tolerance.

In some embodiments only unknown transactions of known type have values in matchTolerance field parent field and or children field . In such embodiments one or more known transactions of known type can be identified as properties not shown of a corresponding unknown transaction of the same known type. In such a situation the parent child and or match tolerance of the corresponding unknown transaction will be used when processing a request received subsequent to one of the known transactions of known type.

Request pattern includes a command field attributes field and characteristics field . Each instance of request pattern stores information identifying a particular request. A service model generator can allocate an instance of request pattern for each observed transaction user specified transaction and unknown transaction of known type.

Command field stores a string that identifies the command contained in the request. Attributes field stores a parameter list that includes zero or more parameters each of which represents an attribute of the request. The parameter list can include observed user specified and unknown attributes as discussed above with respect to .

Characteristics field stores a parameter list identifying zero or more characteristics associated with the request. Each parameter in the list can identify a different characteristic. Examples of characteristics can include the time at which the request was sent the system clock time at which the request was received by the service being modeled network and or system conditions that were present when the request was received and the like. The parameters stored in characteristics field can be used to generate time sensitive values as well as to model actual conditions such as response timing and availability windows.

Response pattern includes an attribute field and a characteristics field . Attribute field stores a string that represents a response attribute. As noted above a given transaction can have multiple response attributes e.g. responses field of transaction pattern can identify multiple instances of response pattern and thus generating a response can involve accessing multiple response patterns in order to include the string identified in each of the response patterns attribute field in the response. Attribute field can store a user specified or observer response attribute as well as values like request sensitive values and time sensitive values generated by the service model generator.

Characteristics field stores a parameter list containing zero or more parameters. Each parameter identifies a characteristic of the response such as the system clock time when the response was sent to the requester by the service network and or system conditions that were present when the response was sent and the like.

Whenever a service model generator is observing and recording stateful transactions that are part of a conversation the service model generator can first act to store information identifying each observed transaction e.g. by storing information identifying each transaction in a transaction pattern response pattern and one or more response patterns . The service model generator can also store information identifying the order in which the recorded transactions were observed.

After the observation and recording process is complete the service model can begin generating information identifying one or more conversations and updating the conversation related fields of one or more transaction patterns. If the service supports token statefulness the service model generator can then prompt the user to specify the starter transaction s . For example the service model generator can provide a list of all observed transactions to the user and prompt the user to select which if any of those observed transactions are starter transactions.

The service model generator can identify all transactions that were part of the same conversation. When instance statefulness is implemented a conversation will include all observed transactions for a given instance of the service when token statefulness is implemented a conversation will include all observed transactions that include the same token e.g. as a request and or response attribute where each conversation begins with one of the user specified starter transactions. Once transactions that are part of the same conversation have been identified the service model generator can used the information identifying the order in which transactions were observed to place those transactions in temporal order.

The service model generator can then attempt to merge one or more conversations into a single conversation. For example the service model generator can determine whether more than one of the conversations includes the same starter transaction. If so the service model generator can merge those conversations into a single conversation that begins with the same starter transaction. If the starter transactions of multiple different conversations are not identical but are structurally similar transactions of the same type e.g. if two conversations begin with start transactions that include the same command and the same number and type of attributes but the actual attribute values differ those conversations can also be merged into a single conversation.

For each conversation identified in this merging process this includes conversations created by merging multiple other conversations as well as independent conversations that cannot be merged with others the service model generator can allocate an instance of conversation pattern to store information identifying that conversation. As noted above the starter transaction for each conversation is an unknown transaction of known type. Accordingly if the service model does not already include an unknown transaction of that type the service model generator can allocate an instance of transaction pattern to store that unknown transaction. Once the unknown transaction acting as the starter transaction is included within the model the starter field of the conversation pattern is updated to identify that unknown transaction.

If any known transactions of that type were observed e.g. such as those that were merged in the above example as the first transaction in the conversation those transactions can then be added to the conversation as properties of the unknown transaction of that type. Adding these transactions to the conversation involves updating a properties field not shown of the unknown starter transaction to identify each of the known transactions of that type that were observed as starter transactions of the merged conversation.

This merging process can be repeated at each level of the conversation. For example if four conversations each of which includes at least three sequential transactions are merged the merging process can continue for each of the next two transactions within each conversation. Thus after the known starter transactions are added as properties of the unknown starter transaction the service model generator can observe the next transactions to occur within the merged conversation and determine whether any of the next transactions can also be merged. The service model generator can also insert unknown transactions for each type of known transaction encountered in the conversation and then add the known transactions as properties of those unknown transactions. Even if no merging is performed an unknown transaction of known type will be included for each known transaction observed in a conversation. Parent and children fields are updated to indicate the flow of the conversation.

For example assume three conversations have been observed as shown in . These conversations all include commands that can be used with a computer reservation system used to reserve flights with one or more airlines. The first conversation includes transactions . .. Transaction . includes a request to getFlightInfo specifying an origination city CityA and a destination city CityB. The response not shown to this request includes a list of flights if any scheduled between CityA and CityB. Transaction . includes a request for the capacity of one of the flights provided in response to the getFlightInfo request and a response not shown indicating whether that flight has any available capacity. Transaction . includes a request to reserve that flight and a response not shown indicating whether or not the flight reservation was successful. Transaction . includes a request to hold a specific seat on the flight and a response not shown indicating whether the request was successful.

The second conversation includes transactions . .. Transaction . includes a request to getFlightInfo specifying an origination city CityC and a destination city CityD. The response not shown to this request includes a list of flights if any scheduled between CityC and CityD. Transaction . includes a request to reserve one of those flights and a response not shown indicating whether or not the flight reservation was successful.

The third conversation includes transactions . .. Transaction . includes a request to getFlightInfo specifying an origination city CityA and a destination city CityD. The response not shown to this request includes a list of flights if any scheduled between CityA and CityD. Transaction . includes a request for the capacity of one of the flights provided in response to the getFlightInfo request and a response not shown indicating whether that flight has any available capacity. Transaction . includes a request to hold a seat on that flight and a response not shown indicating whether or not the request was successful. Transaction . includes a request to reserve the flight and a response not shown indicating whether the flight reservation was successful.

The service model generator then processes the observed transactions in order to build a tree representing the conversations as shown in . Initially the service model generator identifies that the three conversations can be merged because all three start with the same type of known transaction getFlightInfo despite the fact that the observed attributes differ among each of the three starter transactions. In response to this identification the service model generator identifies the unknown transaction of that type getFlightInfo as the starter transaction for the merged conversation and adds this unknown transaction to the service model while a stateless unknown getFlightInfo transaction or other stateful unknown getFlightInfo transactions may already exist in the service model none of these other transactions occur at the same point in the stateful conversation as this one so a new unknown transaction will always be added . The service model generator then updates the unknown getFlightInfo transaction s properties to identify the known transactions . . and . that were observed at the same point in the conversation. These properties are shown in brackets in .

The service model generator then examines the second transaction in each conversation to see if any of those transactions can be merged. Here the first and third conversation each include a structurally similar second transaction of type capacity. Accordingly these two conversations can again be merged at the second transaction level. To do so the service model generator creates a new instance of an unknown transaction of type capacity. The children field of the unknown getFlightInfo transaction is updated to identify the new unknown capacity transaction and the parent field of the new unknown capacity transaction is updated to identify the unknown getFlightInfo transaction. The two known transactions . and . that were observed at this point in the first and third conversations are then added as properties of the unknown capacity transaction.

The second transaction in the second conversation which is of type reserveFlight cannot be merged with the second transaction of the other two conversations however. Accordingly the service model generator will create a new unknown transaction of this type and update the children field of the unknown getFlightInfo to identify this new unknown reserveFlight transaction. Similarly the parent field of the new unknown reserveFlight transaction is updated to identify the unknown getFlightInfo transaction. The single known transaction of this type transaction . is then added as a property of the new unknown reserveFlight transaction.

Thus after processing the second transaction in each of the three conversations the service model will indicate that the unknown getFlightInfo starter transaction has two children an unknown capacity transaction and an unknown reserveFlight transaction.

The service model generator then processes the third transaction in each conversation. As shown in only the first and third conversations include more than two transactions and each conversation includes a different transaction at this point in the conversation. Accordingly it is not possible to merge the transactions at this point in the conversation. As such the service model generator creates a new unknown reserveFlight transaction to correspond to transaction . and a new unknown seat transaction to correspond to transaction .. The children field of the new unknown capacity transaction is updated to identify both of these unknown transactions as children and the parent field of the new unknown reserveFlight and seat transactions are updated to identify the unknown capacity transaction. The observed known transactions are added as properties of their corresponding unknown transactions such that the unknown seat transaction identifies transaction . as one of its properties and the unknown reserveFlight transaction identifies transaction . as one of its properties.

It is noted that there are now two unknown reserveFlight transactions in the same conversation. Despite being unknown transactions of the same type these two transactions have different values of their parent and children fields and properties. These differences reflect the fact that these transactions occur at different points within the conversation.

The service model generator then processes the final transactions . and . in the first and third conversations in the same manner as the previous transactions. Since the transactions that preceded these transactions could not be merged these transactions also cannot be merged furthermore in this example these transactions can also not be merged since they are of different types. Accordingly the service model generator adds a new unknown transaction for each of transactions . and .. The new unknown reserveFlight transaction corresponding to transaction . lists transaction . as one of its properties and the new unknown seat transaction corresponding to transaction . lists transaction . as one of its properties. The parent field of the new unknown reserveFlight transaction is updated to identify the preceding unknown seat transaction seat . in and the parent field of the new unknown seat transaction is updated to identify the preceding unknown reserveFlight transaction reserveFlight . in . Similarly the children fields of the preceding unknown transactions are updated such that the children field of the preceding unknown seat transaction seat . identifies the new unknown reserveFlight transaction reserveFlight . and the children field of the preceding unknown reserveFlight transaction reserveFlight . identifies the new unknown seat transaction seat . .

To use a service model that is implemented using the data pattern of a request processing module can process each received request in the following manner. If no conversations are currently taking place the request processing module can first determine whether a received request is part of any starter transaction by comparing the received request to the requests included in the starter transactions identified in each instance of conversation pattern identified in conversations field . If so the request processing module can select the appropriate instance of conversation pattern i.e. the instance whose starter field identifies the transaction that matches the received request in order to process subsequently received requests. The request processing module can also identify the appropriate instance of transaction pattern associated with the transaction matching the received request in order to generate an appropriate response to be sent to the requester. Identifying the appropriate instance can involve examining each known transaction identified as a property of the starter transaction in order to see if the new request matches a known transaction. If the new request matches a known transaction that known transaction is used to respond. Otherwise the unknown transaction is used to respond.

If the received request is not part of a starter transaction and no conversation is currently taking place the request processing module can identify whether the request is part of one of the transactions identified in statelessConversation field . If a match is found the request processing module can use the information associated with the matching transaction to generate a response to be sent to the requester. If no match is found the request processing module can access the instance of response pattern identified in unknownResponse field and use the information stored within that response pattern instance to generate a response.

If a conversation is already taking place the request processing module can determine whether the received request is a goodbye or reset transaction for the conversation as identified by goodbye field or reset field of the instance of conversation pattern associated with the ongoing conversation . If so the information describing the matching goodbye or reset transaction can be used to generate a response and the request processing module can update its state accordingly e.g. to indicate that no conversation is currently ongoing if the request matched the goodbye transaction or the move the state of the conversation back to the point after handling the starter transaction if the request matched the reset transaction .

If the received request is not a goodbye or reset transaction for the ongoing conversation the request processing module can determine whether the request matches any of the transactions that are allowed to occur at that particular point in the conversation e.g. as specified by the matchTolerance field of the last transaction handled in the conversation . If so the request processing module can use the matching transaction to generate a response. If a matching unknown transaction is found the request processing module can first determine whether the received request matches any of the known transactions that are properties of the matching unknown transaction. If so the request processing module can use the known transaction to generate a response. Otherwise the request processing module can use the matching unknown transaction to generate the response.

If a conversation is already taking place the received request is not a goodbye or reset transaction for the conversation and the received request does not match any of the transactions that are allowed to occur at that particular point in the conversation the request processing module will generate the response identified in unknownResponse field . This response will be generated even if the received request would have matched one of the other transactions included in the service model since the request was received during a conversation. Reception of such a request may also cause the existing state of the conversation to be discarded such that the next request received from the requester will be handled as if there is no ongoing conversation.

Interfaces can each include an interface to a storage device on which instructions and or data e.g. such as data implementing a service model are stored. Interfaces can also each include an interface to a network such as a local area network LAN or wide area network WAN such as the Internet for use in communicating other devices. Such an interface can allow application under test to send requests to services via a network. Similarly such an interface can allow testing driver to communicate with a testing module implemented on another computing device. Interface can also include interfaces to various peripheral Input Output I O devices such as a monitor on which a graphical interface e.g. allowing a user to configure and control the model building and or model deployment process can be displayed.

Like computing device computing device can be a personal computer server personal digital assistant cell phone laptop workstation or the like. Memory can each include various types of RAM Random Access Memory ROM Read Only Memory Flash memory MEMS Micro Electro Mechanical Systems memory and the like. Processor memory and interface s are coupled to send and receive data and control signals by a bus or other interconnect.

Interfaces can each include an interface to a storage device on which instructions and or data e.g. such as data implementing a service model are stored. Interfaces can also each include an interface to a network such as a local area network LAN or wide area network WAN such as the Internet for use in communicating other devices. Such an interface can allow virtual services and to receive requests and send responses via a network. Similarly such an interface can allow testing module to communicate with another computing device in order to for example deploy a testing driver. Interface can also include interfaces to various peripheral Input Output I O devices such as a monitor on which a graphical interface e.g. allowing a user to configure and control the model building and or model deployment process can be displayed.

In program instructions and data implementing various software components such as application under test device manager testing driver service model generator user interface testing module virtual service and virtual service can be stored on various computer readable storage media such as memory and . In some embodiments such program instructions can be stored on a computer readable storage medium such as a CD Compact Disc DVD Digital Versatile Disc hard disk optical disk tape device floppy disk and the like. In order to be executed by a processor the instructions and data are loaded into memory from the other computer readable storage medium. The instructions and or data can also be transferred to a computing device for storage in memory via a network such as the Internet or upon a carrier medium. In one embodiment the components used implement a service model generator testing module testing driver and the like are implemented using LISA Live Interaction Service Architecture TM available from iTKO Inc. of Dallas Tex.

It is noted that the above figures illustrate specific examples. In other embodiments different components can be used to implement the testing functionality described above. For example while specific software components have been described as implementing specific functionality this functionality can be implemented by different components than those depicted herein. For example the functionality of service model generator can be subdivided into multiple other test management components or integrated into another component within testing module . Furthermore the specific components depicted in the figures herein can be combined or subdivided into fewer or additional components.

Additionally other components can be used instead of and or in addition to those shown in the figures presented herein. Such other components can provide different or additional functionality instead of and or in addition to the functionality described herein. Furthermore some of the functionality described herein can be eliminated in some embodiments.

Although the present invention has been described in connection with several embodiments the invention is not intended to be limited to the specific forms set forth herein. On the contrary the present invention is intended to cover such alternatives modifications and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims.

