---

title: Password policy enforcement in a distributed directory when policy information is distributed
abstract: A computer implemented method, data processing system, and computer program product for password policy enforcement in a distributed directory when policy information is distributed. When a proxy server is providing a request from a client to a backend directory server, the proxy server performs a series of LDAP operations on a targeted set of backend directory servers to collect password policy information applicable to a target user. The password policy information applicable to the target user is partitioned and distributed across the plurality of backend directory servers. When the password policy information for the target user has been collected, the proxy server evaluates the collected password policy information to determine an effective password policy for the target user. The proxy server then sends the request and subsequent requests with the effective password policy to a backend directory server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08347347&OS=08347347&RS=08347347
owner: International Business Machines Corporation
number: 08347347
owner_city: Armonk
owner_country: US
publication_date: 20080109
---
The present invention relates generally to an improved data processing system and in particular to password policy enforcement in a distributed directory when policy information is distributed.

A directory is a special type of database for managing information about people organizations data processing systems and other information sources. Information within a directory is organized within a hierarchical namespace. Each entry in the directory is a named object and consists of a set of attributes. Each attribute has a defined attribute type and one or more values. Each entry is identified by an unambiguous distinguished name DN wherein a distinguished name is a concatenation of selected attributes from an entry. A directory service provides a mechanism for searching a directory and for retrieving information from a directory. Various standards have been promulgated for defining directories and directory services. For example the X.500 specifications define a directory standard more information can be found in Weider et al. Technical Overview of Directory Services Using the X.500 Protocol Internet Engineering Task Force IETF RFC 1309 March 1992. As another example the Lightweight Directory Access Protocol LDAP specifications define a protocol for accessing a directory that supports the X.500 directory model more information can be found in Wahl et al. Lightweight Directory Access Protocol v3 IETF RFC 2251 December 1997.

A logical representation of a directory does not necessarily reflect an organization of the physical storage of the directory. In a manner similar to many types of memory systems a directory may be logically supported as a cohesive whole yet physically supported in a distributed manner. For example a single distributed directory may be stored across many servers wherein each server supports a subtree of the directory. In particular a known distributed directory environment includes one or more LDAP backend servers and a proxy server that acts as an intermediate agent between a client and the distributed directory environment. Clients bind to the proxy server instead of directly binding to the backend LDAP servers.

A set of rules that controls how passwords are used and administered in this type of directory environment is known as a password policy. These rules enforce various security requirements e.g. that a user change his or her password periodically that the user s selected password meets certain requirements for construction that re use of an old password is prevented that entities are locked out after a certain number of failed attempts to use a given password and so on. A user refers to any LDAP client application that has an identity in the directory. In an LDAP distributed directory environment a given password policy is defined according to an object oriented schema that defines a password policy object class which includes a set of administrative password policy attributes together with a set of operational attributes that hold general policy state information for each user. The policy also includes one or more controls that are used while enforcing password policy. In particular a request control is defined as a control that is sent by a client with a request operation to elicit a response control. The response control typically contains one or more warnings and errors associated with password policy. Further details of how to implement password policy in this manner is described in Behera et al. Password Policy for LDAP Directories Internet Draft RFC October 2001.

The illustrative embodiments provide a computer implemented method data processing system and computer program product for password policy enforcement in a distributed directory when policy information is distributed. When a proxy server is providing a request from a client to a backend directory server the proxy server performs a series of LDAP operations on a set of targeted backend directory servers to collect password policy information applicable to a target user. The password policy information applicable to the target user is partitioned and distributed across the targeted backend directory servers. When the password policy information for the target user has been collected the proxy server evaluates the collected password policy information to determine an effective password policy for the target user. The proxy server then sends the request and any subsequent requests with the effective password policy to a backend directory server.

In general the devices that may comprise or relate to the present invention include a wide variety of data processing technology. Therefore as background a typical organization of hardware and software components within a distributed data processing system is described prior to describing the present invention in more detail.

With reference now to the figures depicts a typical network of data processing systems each of which may implement a portion of the present invention. Distributed data processing system contains network which is a medium that may be used to provide communications links between various devices and computers connected together within distributed data processing system . Network may include permanent connections such as wire or fiber optic cables or temporary connections made through telephone or wireless communications. In the depicted example server and server are connected to network along with storage unit . In addition clients also are connected to network . Clients and servers may be represented by a variety of computing devices such as mainframes personal computers personal digital assistants PDAs and the like. Distributed data processing system may include additional servers clients routers other devices and peer to peer architectures that are not shown.

In the depicted example distributed data processing system may include the Internet with network representing a worldwide collection of networks and gateways that use various protocols to communicate with one another such as Lightweight Directory Access Protocol LDAP Transport Control Protocol Internet Protocol TCP IP File Transfer Protocol FTP Hypertext Transport Protocol HTTP Wireless Application Protocol WAP and so on. Of course distributed data processing system may also include a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . For example server directly supports client and network which incorporates wireless communication links. Network enabled phone connects to network through wireless link and PDA connects to network through wireless link . Phone and PDA can also directly transfer data between themselves across wireless link using an appropriate technology such as Bluetooth wireless technology to create so called personal area networks PAN or personal ad hoc networks. In a similar manner PDA can transfer data to PDA via wireless communication link .

The illustrative embodiments may be implemented on a variety of hardware platforms is intended as an example of a heterogeneous computing environment and not as an architectural limitation for the illustrative embodiments.

With reference now to a diagram depicts a typical computer architecture of a data processing system such as those shown in in which the present invention may be implemented. Data processing system contains one or more central processing units CPUs connected to internal system bus which interconnects random access memory RAM read only memory and input output adapter which supports various I O devices such as printer disk units or other devices not shown such as an audio output system and the like. System bus also connects communication adapter that provides access to communication link . User interface adapter connects various user devices such as keyboard and mouse or other devices not shown such as a touch screen stylus microphone etc. Display adapter connects system bus to display device .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the system implementation. For example the system may have one or more processors such as an Intel Pentium based processor and a digital signal processor DSP and one or more types of volatile and non volatile memory. Other peripheral devices may be used in addition to or in place of the hardware depicted in . The depicted examples are not meant to imply architectural limitations with respect to the illustrative embodiments.

In addition to being able to be implemented on a variety of hardware platforms the illustrative embodiments may be implemented in a variety of software environments. A typical operating system may be used to control program execution within each data processing system. For example one device may run a UNIX operating system while another device contains a simple Java runtime environment. A representative computer platform may include a browser which is a well known software application for accessing hypertext documents in a variety of formats such as graphic files word processing files Extensible Markup Language XML Hypertext Markup Language HTML Handheld Device Markup Language HDML Wireless Markup Language WML and various other formats and types of files.

The illustrative embodiments may be implemented on a variety of hardware and software platforms as described above with respect to and . More specifically though the illustrative embodiments are directed to an improved distributed data processing environment. Prior to describing the illustrative embodiments in more detail some aspects of typical distributed data processing environments are described.

The descriptions of the figures herein may involve certain actions by either a client device or a user of the client device. One of ordinary skill in the art would understand that responses and or requests to from the client are sometimes initiated by a user and at other times are initiated automatically by a client often on behalf of a user of the client. Thus when a client or a user of a client is mentioned in the description of the figures it should be understood that the terms client and user can be used interchangeably without significantly affecting the meaning of the described processes.

Certain computational tasks may be described below as being performed by functional units. A functional unit may be represented by a routine a subroutine a process a subprocess a procedure a function a method an object oriented object a software module an applet a plug in an Active control a script or some other component of firmware or software for performing a computational task.

The descriptions of the figures herein may involve an exchange of information between various components and the exchange of information may be described as being implemented via an exchange of messages e.g. a request message followed by a response message. It should be noted that an exchange of information between computational components which may include a synchronous or asynchronous request response exchange may be implemented equivalently via a variety of data exchange mechanisms such as messages method calls remote procedure calls event signaling or other mechanism.

The illustrative embodiments are described below with respect to terminology and functionality as associated with X.500 directories and Lightweight Directory Access Protocol LDAP operations but it should be noted that the illustrative embodiments may be implemented using a variety of directory implementation schemes and protocols.

With reference now to a block diagram depicts a typical distributed data processing system for an enterprise domain. As in a typical corporate computing environment or an Internet based computing environment enterprise domain hosts controlled resources that user can access e.g. by using browser application on client device through network .

Enterprise domain supports multiple servers. Application servers support accessible resources through web based applications or other types of applications including legacy applications. Authentication servers support various authentication mechanisms such as username password X.509 certificates secure tokens or an SSL session.

Proxy server performs a wide range of functions for enterprise domain . Proxy server can be administratively configured through configuration files and enterprise policy database to control the functionality of proxy server e.g. caching web pages in order to mirror the content from an application server or filtering the incoming and outgoing datastreams through input datastream filter unit and output datastream filter unit . Input datastream filter unit may perform multiple checks on incoming requests while output datastream filter unit may perform multiple checks on outgoing responses each check may be performed in accordance with goals and conditions that are specified within various enterprise policies.

Enterprise domain comprises entitlements server which accepts information within user registry database access control list ACL database and third party datastreams from other domains. Entitlements server determines whether users are authorized to access certain services that are provided by application servers within domain by checking policies and or access control lists against user requests for those services. A set of user specific entitlements is used by proxy server entitlement server or a combined or coordinated effort between proxy server and entitlement server to determine or control access to application servers and other controlled resources in response to user requests.

The above noted entities within enterprise domain represent typical entities within many computing environments. Web based applications can utilize various means to prompt users to enter authentication information often as a username password combination within an HTML form. In the example that is shown in user may be required to be authenticated before client may have access to resources after which a session is established for client . In after receiving an incoming request from client input datastream filter unit may determine whether client has already established a session if not an authentication service on authentication servers can be invoked in order to authenticate user . If client has already established a session then additional checks may be performed on an incoming request prior to granting access to a controlled resource the additional checks may be specified in an enterprise authentication policy.

With reference now to a block diagram depicts a typical distributed directory environment. User operates client application which may execute on a client device such as client as shown in . Client application interacts with directory servers through a proxied directory server also known as a directory proxy server or a proxy directory server which is shown as proxy server proxy server may execute on the user s client device or elsewhere within a network of connected devices such as those shown in . Proxy server may be associated with configuration files that contain information that is managed via an administrative user application to control the functionality of proxy server .

Proxy server acts as an intermediate agent an intermediary to the distributed directory environment. Although only one proxy server is shown there may be multiple such proxy servers or proxy server instances running on one or more physical machines. Proxy server is able to perform operations in accordance with a variety of directory schemes and protocols including LDAP specifications. Proxy server contains proxy authorization control functional unit which generates proxy authorization controls also called proxied authorization controls that are employed by proxy server to perform an operation with respect to the distributed directory on behalf of client application or equivalently on behalf of user . As described in Wahl et al. Lightweight Directory Access Protocol v3 IETF RFC 2251 December 1997 a control is a way to specify extension information for use with an LDAP operation. Controls can be sent as part of an LDAP request and apply only to the accompanying request. If the server recognizes the control type and it is appropriate for the operation the server will make use of the control when performing the requested operation various optional parameters can be used to inform the server whether or not to ignore the control if it is unrecognized or it is inappropriate. The control also contains an object identifier that has been assigned to the control.

Hence proxy authorization control functional unit can present an application programming interface API that accepts a proxy distinguished name DN as an input parameter this input parameter specifies the distinguished name of the entry of the identity that proxy server is to assume when performing an operation on behalf of client application or user . The provided API can be used by the caller to create an LDAP control containing the proxy authorization identity the created proxy authorization control would then be included in LDAP operations to request an operation from a directory server. Using the proxy authorization control mechanism a client or in this case proxy server can bind to the directory engine using its own identity but is granted proxy authorization rights of another user i.e. user or client application to access the target directory.

When the LDAP server receives an operation with proxy authorization control the bind distinguished name is validated against the administrative group and or the predefined proxy authorization group to determine whether the bind distinguished name should be granted the proxy authorization right. In other words the bound application client which is proxy server in this example must be a member of the administrative group or proxy authorization group to request a proxy authorization operation. More information about using a proxy authorization control can be found in Weltman LDAP Proxied Authorization Control IETF Internet Draft draft weltman 1dapv3 proxy 12.txt April 2003. The LDAP protocol also supports an extension mechanism that allows additional operations to be defined for services that are not defined within the LDAP specification. An extended operation allows clients to make requests and receives responses with predefined syntaxes and semantics that may be specific to particular implementations.

The distributed directory environment includes multiple directory servers that interoperate within the same distributed data processing environment as proxy server and client application e.g. in a manner similar to the distributed data processing environments that are shown in and . Directory servers support functionality for accessing datastores that contain portions of a distributed directory i.e. portions of a directory information tree shown as distributed directory datastores . Directory servers also contain functionality which is not shown in that supports the receipt and processing of proxied authorization controls e.g. as may be sent by proxy server or other directory clients. A typical directory server is a relational database management RDBM server.

In a manner similar to the scenario that was described further above user entries group entries and target object entries that are of interest to a particular directory operation may reside in different portions of a distributed directory that are supported on different systems. In the example that is shown in target object entry resides within distributed directory datastore user entry resides within distributed directory datastore and group entry resides within distributed directory datastore . These locations are merely representative.

Thus a distributed directory is a directory environment in which data is partitioned across multiple directory servers. As illustrated in the distributed directory typically comprises a collection of machines including relational database management RDBM servers holding data and one or more proxy servers managing the topology. A representative proxy server may be an IBM Tivoli Directory Server that provides among other functions request routing load balancing failover distributed authentication and support for distributed membership groups and partitioning of containers. As described above the directory proxy server sits at the front end of a distributed directory and provides efficient routing of user requests thereby improving performance and providing a unified directory view to the client. The proxy server also provides data support for groups and ACLs that are not affected by partitioning and support for partitioning of flat namespaces.

In this illustrative example servers A B and C have their data split within a container under some entry in the directory tree . Because proxy server handles the routing of requests to the appropriate servers no referrals are used. Client applications and need only be aware of proxy server . Client applications and never have to authenticate with servers A B and C . Data within directory servers A B and C may include user entries user policy entries group policy entries and global policy entries. Since multiple policy definitions may apply to a single user a set of data comprising policy definitions for the user may be partitioned across the directory servers. For instance server A is shown to contain a first partition of the entries server B is shown to contain a second partition of the entries and server C is shown to contain a third partition of the entries.

As previously mentioned a password policy comprises a set of rules that controls how passwords are used and administered in a distributed directory environment. These rules enforce various security requirements e.g. that a user change his or her password periodically that the user s selected password meets certain requirements for construction that re use of an old password is prevented that entities are locked out after a certain number of failed attempts to use a given password and so on. Password policy enforcement for a user is performed in several key situations 1 at bind time such as when the user requests a simple bind to the proxy server 2 when a user is added to the system 3 when a bound user requests to modify the bound user s password 4 when a bound user requests to modify a different user s password and 5 during password policy pre and post bind extended operations. A pre bind extended operation may include checking if an account is locked. A post bind extended operation may include checking for expired passwords grace logins and updating failed successful bind counters. For example two extended operations may be implemented in the RDBM backend server they are a Password Policy Initialize and Verify Bind Extended Operation and a Password Policy Finalize and Verify Bind Extended Operation. Both extended operations may be enabled or disabled via a setting in an LDAP configuration file e.g. in the cn Directory cn RDBM Backends cn Company Directory cn Schemas cn Configuration entry. The Password Policy Initialize and Verify Bind Extended Operation accepts a bind distinguished name and is performed when bound as an administrator. Preferably the extended operation is implemented on an RDBM backend server and simply calls in to the RDBM to the pre bind password policy code. The extended operation checks to see if the target user s account is locked. Possible return codes include codes for internal server error the users account is locked invalid distinguished name or password requester does not have permission to perform the request and the like. The Password Policy Finalize and Verify Bind Extended Operation accepts a bind distinguished name and return code and is performed when bound as an administrator. The extended operation is implemented on an RDBM backend server and calls in to the RDBM to the post bind password policy code. The extended operation checks if a password is expired and if any grace logins are left. The extended operation also updates the success and failure counts times on the entry. More information on pre and post bind extended operations may be found in U.S. patent application Ser. No. 11 776 292 at least in page 20 lines 17 to page 24 line 9 entitled Method and System for Enforcing Password Policy for an External Bind Operation in a Distributed Directory and filed Jul. 11 2007 assigned to the same assignee herein and which is incorporated by reference.

Since data in a distributed directory system is partitioned and stored on different servers in the system password policy definitions for a user or user group may be partitioned and distributed across the different servers. When the policy data is partitioned across directory backend servers in this manner a password policy check on a user request cannot be performed at a single directory backend server level. Instead the proxy server must obtain policy information distributed across the directory backend servers to determine the complete effective password policy for the user and then enforce that policy. While existing distributed directory systems contain proxy servers which can determine the effective password policy for a user when policy information for a user is stored on a single directory server there is currently no existing mechanism which allows a proxy server to collect policy information for a user when the policy information is distributed across different directory servers and determine the effective password policy for the user.

The illustrative embodiments provide a mechanism for reducing the overhead associated with distributed password policy enforcement operations using a proxy server by providing a mechanism for enforcing password policy when the policy definitions for a user or user group are partitioned and distributed across different directory servers. To enforce password policy on a user request in a distributed directory environment where a set of policy data is partitioned across directory servers the illustrative embodiments provide a proxy server which performs two steps first the proxy server collects policy entries stored across different directory servers for the user and determines the user s effective password policy in response to a request by the user to access data stored in the directory backend servers and second the proxy server communicates the effective password policy to the directory backend servers in the form of an Effective Password Policy Control so the backend servers can use the collected policy information when enforcing the policy on the user request. The effective password policy for a user is the combination of all policy information applicable to the user i.e. policy definitions that apply to the individual user policy definitions that apply to groups of which the user is a member and the global level policy stored on the directory backend servers. In determining the effective password policy of a target user the proxy server collects the policy definitions that apply to the target user. The proxy server also collects all the policy definitions that apply to the groups of which the target user is a member. This process includes collecting all the groups of which the target user is a member and collecting the policy definitions that correspond to those groups. The proxy server also collects the global level policy. These collected policies are then combined to determine the effective password policy for the target user. The Effective Password Policy Control may be provided by the proxy server to the backend directory servers to allow the backend servers to determine based on the user s effective password policy if the user requested operation is allowed.

Since password policy can be configured on a per user per group or system wide global level when it is time to decide which set of password rules a user should adhere all three policies if they exist must be taken into consideration. The following sections describe how and when these rules are determined for a given user in a multiple password policies environment. In this environment there may be various types of password policies including individual group and global.

According to this feature every user is allowed to have his or her individual password policy. This feature is implemented with an operational attribute e.g. pwdIndividualPolicyDN which points to a password policy entry. In this manner a user entry is extended to have its own password policy entry. This named reference password policy design provides an efficient way to associate multiple user entries to the same policy entry. By changing the attributes of the password policy entry an administrator can effectively manage a set of users without modifying any of the user entries.

It is not required that all of the password policy attributes need to be defined in a user s individual or group password policy entry. During password policy evaluation time a user s individual group and global password policy are searched preferably in order. If an attribute is not defined in the individual password policy entry it will be searched in the composite group password policy entry. If the attribute is not found an attribute in the global password policy entry will be used. In the event the attribute is not defined in the global password policy entry either then a default value may be assumed.

By assigning a value of cn noPwdPolicy to attribute pwdIndividualPolicyDN for a password policy extended user entry an administrator may exempt a user from any password policy enforcement. This is different from not defining the attribute in the entry. If the attribute is not defined the user s effective password policy is derived from the user s group if it exists and the global policy. If the attribute is defined with the special value however then the effective password policy is not evaluated at all and the user is not controlled by any password rules.

Preferably an association between a group object and a password policy entry is supported so that the members of the group can be controlled by a set of special password rules. In one embodiment an operational attribute e.g. pwdGroupPolicyDN points to a password policy entry and can be used in any user group object such as accessGroup accessRole groupOfNames groupOfUniqueNames and the like. This approach leverages existing group related functionalities such as group membership determination group referential integrity and the like but extends the functions to support a group related password policy.

If the distinguished name of a directory administrator and or the distinguished name of a local administrator group member are specified as one of the members of a password policy group preferably the distinguished name is ignored. The password of a directory administrator or a member of an administrator group is governed by the administrator password policy defined in a configuration file. Because a user entry may belong to more than one group multiple group password policy entries preferably are evaluated before the user s group policy can be determined. In a representative embodiment attributes in all the group password policy entries are combined to form a union of attributes with the most restrictive attribute values taking precedence. How a user s composite group policy is determined is described below. An administrator may exempt a group s policy from being used in the evaluation of the composite group policy. Thus if a user belongs to a group to which a cn noPwdPolicy is assigned then the user s effective policy will not include any attributes from this group policy. Other group policies as well as the global policy and the individual policy will still be evaluated.

Preferably a global password policy entry is created if it does not exist when the proxy server starts up. Typically the global password policy entry is created with a pwdpolicy attribute set to false.

When the pwdpolicy attribute is set to true the effective password policy is evaluated for a user. The evaluation of a user s password policy preferably takes place at the beginning of a connection if the bind user is not a local administrative user. Once the user s effective password policy has been determined the effective password policy is preferably stored in a local structure for the user and this local copy is used for the life of the entire connection.

Because a user entry may belong to more than one group multiple group password policy entries may be evaluated before the user s group password policy is determined. The following are one or more sample rules that may be used to determine a user s composite group password policy not all are required 

Although not meant to be limiting is a table that lists the rules among password policy attributes and one illustrative embodiment detailing an order of selection of these attributes.

A user s effective password policy is evaluated if pwdpolicy is set to true in the global password policy entry. Other password policies such as individual and group policy may be permitted when global policy is disabled but these policy rules preferably will have no effect on the user.

The three kinds of password policies individual group and global preferably are evaluated in this order if they exist while evaluating a user s effective password policy. When a password policy attribute is found in any of the password policy entries preferably the evaluation of that attribute stops and the attribute value is used as part of the user s effective policy. In this implementation not all attributes have to be defined in a password policy. If a given attribute is not defined in one password policy then the next password policy in order is searched until the global password policy is evaluated. If the attribute is still absent from the global policy a default value may be assumed. As a result preferably the final effective password policy contains all attributes that pertained to a user s password.

The attribute pwdPolicyStartTime is set to the current system time when pwdpolicy is turned to true. This can be done even if the global password policy entry is set to false. The pwdPolicyStartTime values however preferably are not used for effective policy evaluation unless the global policy is enabled. Once the global policy is enabled the value of this attribute preferably is selected from a user s individual then group and then the global policy. Because pwdPolicyStartTime exists in every active password policy the start time of an individual policy if it exists will always override any other policy start time as the start time of the user s effective password policy.

The all or none attribute selection rules for selecting attributes such as pwdMinLength as described in the above section preferably are also applied to a user s effective password policy evaluation.

The effective password policy of a group entry preferably is calculated by merging the group s password policy attributes with those in the global password policy with the group policy attributes taking precedence. This effective policy can be queried by using an extended operation.

During a bind operation if the global password policy is enabled the bind user s individual password policy is searched first. Then based on the password policy group entries the bind user s group policy can be determined once the user s group membership has been resolved. Together with the global password policy the user s effective policy can be determined at this time. This effective policy controls if the bind user can be authenticated. Once the user is authenticated the effective password policy preferably is stored in a connection structure for later use.

For any operation that is used to add or modify a password attribute including an extended operation if the updated entry is different than the bind entry the updated entry s effective password policy is evaluated just like the one for the bind entry and it is stored in an RDBM request structure otherwise the bind entry s effective policy stored in the connection structure will be used. The effective password policy is the policy that determines if the password update operation is allowed.

For a modify operation modifying password attributes such as resetting a password and unlocking a user account if the bind user is a password administrator no effective password policy evaluation will take place for the target user. This means a password administrator can ignore the target user s password policy when modifying password attributes associated with the above two actions. If a password administrator modifies his or her own password however the administrative password policy defined in the configuration file is used to make sure the passwords of the administrative users are properly modified.

Turning now to a block diagram is depicted which illustrates how directory entries may be partitioned and distributed across backend directory servers in accordance with the illustrative embodiments. Directory entries in this example include user entries user policy entries group entries group policy entries and global policy entries. Servers A B and C are representative of servers A B and C in in more detail. In this example data under the organization name IBM and the country US i.e. o ibm c us is shown to be split across servers A B and C . Data is typically split evenly across the directories by hashing on the relative distinguished name RDN of an object. The relative distinguished name is the first component in the distinguished name which identifies the entry distinctly from other entries having the same parent e.g. cn user A for distinguished name cn group A for distinguished name cn pwdpolicyC for distinguished name etc. 

In this example servers A B and C contain user entries user policy entries group entries group policy entries and global policy entries for users A B and C. To obtain complete policy information i.e. including user group and global policy levels for user A the proxy server collects all of the policy information applicable to user A stored across servers A B and C since user A s policy information is partitioned across these directory servers. For instance a search request is used by the proxy server to obtain user A s entry information on directory server A . A search request is also used by the proxy server to obtain the individual password policy information about user A. The result is entry from server A. The proxy server then collects the group membership for user A. The proxy server performs a group evaluation extended operation with a new Effective Password Policy control which requests the policy distinguished names associated with the group be returned. The result is the group entries. The extended operation is sent to server A server B and server C . The result is group entries and and the policy distinguished names cn pwdPolicyB o ibm c us and cn pwdPolicyC o ibm c us. The proxy server then searches the directory servers for those policy distinguished names. The resulting entries are and . The proxy server then searches the directory servers to obtain the global policy entry. The resulting entry is .

The process begins with the proxy server performing a search of a targeted set of the backend directory servers to obtain the target user s directory entry step . If there is an individual policy entry associated with the obtained target user s directory entry the proxy server performs another search to obtain the individual policy entry for the target user step . Once the individual policy entry is obtained the proxy server collects the group membership for the target user step . The group membership comprises all of the groups of which the target user is a member. In collecting the group membership the proxy server performs a group evaluation extended operation with an Effective Password Policy control requesting the policy distinguished names to obtain the policy distinguished names associated with the groups.

The proxy server then uses the policy distinguished names associated with the groups to search for and collect all of the group policy entries in the targeted directories that are associated with the groups step . Once the group policy entries are collected the proxy server searches the targeted directory servers and collects the global policy entry for the target user step .

After all of the policies entries applicable to the target user are collected from the targeted directory servers the proxy server combines the policy entries to determine the effective password policy for the target user step .

In one implementation specific to distributed directories a proxy server may determine the effective password policy in the following manner. The proxy server first obtains the individual policy entry for the bound user. To obtain the individual policy entry the proxy server first performs a search in the set of targeted backend directory servers for the user s entry. If the user s requested operation is a request to add a user there is no need to search for the entry since the entry and its attributes are contained in the add request. One of the attributes returned from the user entry search is the policy attribute ibm pwdIndividualPolicyDN which contains the distinguished name of the user s individual policy entry. If no distinguished name value is returned i.e. no individual policy for the user the proxy server skips evaluating the individual policy and proceeds to evaluating the group policies as described below. If a distinguished name value is returned from the search the proxy server performs a search for the individual policy entry based on the distinguished name returned value. The result is a single individual policy entry for the user.

Next the proxy server obtains policy definitions associated with groups of which the user is a member. To obtain the group policy definitions the proxy server performs a group evaluation extended operation against each partition. More information about group evaluation extended operations may be found in U.S. Patent Publication No. 20060235850 at least in paragraphs 0052 and 0065 entitled Method and System for Access Authorization Involving Group Membership Across a Distributed Directory and filed Apr. 14 2005 assigned to the same assignee herein and which is incorporated by reference. The extended operation requests a backend directory server to evaluate all groups to which a specific user belongs based on the user entry in the backend server. The user entry in the extended operation is the user entry which was previously obtained from the individual policy evaluation. The proxy server sends the extended operation and a new control Return Policy Distinguished Names Control to the backend directory servers. This new Return Policy Distinguished Names Control makes a backend server return the policy distinguished names associated with each group distinguished name that the backend server is returning.

Each backend server returns a list of groups and policy distinguished names based on the Return Policy Distinguished Names Control request. If no list is received from any backend server the proxy server skips evaluating the group policies and proceeds to evaluating the global policy as described below. If one or more lists are received the proxy server combines all the policy distinguished names from each server into a single list and removes duplicate policy distinguished names. The proxy server then performs a search for the group policy entries that correspond to the policy distinguished names returned using the Return Policy Distinguished Names Control request. The result is a list of group policy entries for the user.

Next the proxy server obtains the global password policy definition for the bound user. To obtain the global password policy definition the proxy server performs a search in the backend directory servers for the global policy entry. A global policy entry in this example is cn pwdpolicy cn ibmpolicies. The actual distinguished name for the global policy entry is implementation specific. The result is a single global policy entry.

Once the individual group and global policies if they exist have been obtained the proxy server determines the effective password policy. If no individual policy and group policies have been obtained the proxy server determines the effective password policy to be the global policy. However if individual policy and group policies have been obtained there are two ways to determine the effective password policy for a user. In one embodiment the effective policy can be calculated locally on the proxy server using the effective password policy evaluation algorithms as previously described above. In a second embodiment the proxy server sends an extended operation to the backend servers containing all the policy definitions that were discovered in individual group and global policy evaluations. The extended operation format is as follows 

The result of the extended operation is that the backend server evaluates the effective policy using the effective password policy evaluation algorithms as previously described above.

In this embodiment a requirement is made on the system that policy definitions must be stored in the global policy subtree e.g. cn ibmpolicies subtree in and this global policy subtree is replicated across all backend directory servers in the system. Thus all policy definitions are stored locally on each backend directory server. By replicating all policy definitions in this manner the proxy server may skip steps of collecting the actual individual group or global policies that apply to the target user. Instead the proxy server only needs to collect the policy distinguished names at the individual group and global levels that apply to the target user. These collected policy distinguished names may then be sent to the backend servers on subsequent operations and each backend directory server looks up the locally stored policies associated with the policy distinguished names to perform the policy evaluation and enforcement.

The process begins with the proxy server performing a search of the backend directory servers to obtain the target user s directory entry step . Once the user entry is obtained the proxy server then collects the group membership for the target user step . The group membership comprises all of the groups of which the target user is a member. In collecting the group membership the proxy server performs a group evaluation extended operation to obtain the policy distinguished names associated with the groups.

The proxy server then creates a list of policy distinguished names based on the results obtained from the previous individual entry and group entry searches and the global policy distinguished name and sends the list to the backend directory servers step . This list of policy distinguished names may be sent to the backend directory servers by the proxy server on subsequent requests from the target user.

The process begins when a client requests a simple bind to the proxy server step . When the proxy server receives the bind request the proxy server determines the effective password policy for the target client step as described in the process in . The proxy server also performs a compare request on the password supplied from the client to the passwords stored in the password directory. The proxy server then sends the compare request the Password Policy Control and the Effective Password Policy Control to a backend directory server step . The Password Policy Control is the mechanism by which the client tells the server that the client is able to handle extended error state information related to password policy. The server uses a response control to communicate that state information to the client. The Effective Password Policy Control contains the target user distinguished name and all the attributes and values that make up the effective password policy for the user. The backend servers use this effective policy information to perform a password policy check and enforce password policy on the operation requested by the user.

When the backend directory server receives the Password Policy Control and Effective Password Policy Control on the compare request the backend directory server performs pre bind password policy checking step . This pre bind password policy checking comprises determining if the user account is locked step . If so the backend directory server generates a return error code step with the process continuing to step .

If the account is not locked the backend directory server performs a password compare operation against the password stored at the backend server for the target object step . The backend directory server then performs post bind password policy checking step . This post bind password policy checking updates local counters related to failed and successful login attempts and checks things like grace logins etc. A determination is then made as to whether the password compare in step is valid step . If not the process continues to step to generate the return error code to the proxy server. If however the password compare is valid returns true the backend directory server generates a return success code to the proxy server step with the process continuing to step .

At step the proxy server parses the returned code and the Password Policy Controls and caches the password policy state e.g. error or success of the policy check for the target client step . The Password Policy Controls pass return codes and extended information that the proxy caches. For example the information in the control may indicate that the account is locked if the user must change his password that there are three remaining grace logins etc. The password policy state is cached to enable the proxy server to access this policy state information for subsequent requests from the bound client. The proxy server then returns the result of the password policy check to the client step .

When the client receives the result from the proxy server the client parses the password policy check result step .

The process begins when a client requests a external bind to the proxy server step . When the proxy server receives the bind request the proxy server determines the effective password policy for the target client step as described in the process in . A proxy server plugin initiates a pre bind extended operation and sends the Effective Password Policy Control to a backend directory server step .

When the backend directory server receives the Effective Password Policy Control the backend directory server performs pre bind password policy checking step . This pre bind password policy checking includes determining if the user account is locked step . If so the backend directory server generates a return error code and sends the password policy check error result to the proxy server step . The proxy server then returns the password policy check error result to the client step which parses the password policy check result step . If the account is not locked at step the backend directory server generates a return success code to the proxy server step .

When the proxy server receives the return success code from the backend directory server the proxy server plugin performs a credential validation step . The validation of the client s credentials may comprise checking the value of different attributes of the client obtained from the client request. The particular validation performed on the client s credentials by the proxy server are dependent upon the type of bind plugin. The proxy server plugin then initiates a post bind extended operation and sends the Effective Password Policy Control to the backend directory server step .

The backend directory server then performs post bind password policy checking step . This post bind processing includes checking for expired passwords grace logins and updating failed successful bind counters.

At step the proxy server parses the returned code and the Password Policy Controls and caches the password policy state e.g. account locked password must change grace logins etc. of the policy check for the target client step . The password policy state is cached to enable the proxy server to access this policy state information for subsequent requests from the bound client. The proxy server then returns the result of the password policy check to the client step which parses the bind result and password policy control. step .

The process begins when a bound client makes a subsequent request for access to a directory step . When the proxy server receives the request the proxy server determines whether the requested operation is allowed based on the cached password policy state step . If the requested operation is not allowed the proxy server returns the result to the bound client step which parses the returned result step .

Turning back to step if the requested operation is allowed the proxy server makes a determination as to whether the request from the bound client targets a second object and requires a password policy for the target step . If the request does not target a second object and require a password policy for the target the process continues to step . However if the request does target a second object and require a password policy for the target the proxy server determines the effective password policy for the target object step . The proxy server then sends the client request to the backend server along with the Effective Password Policy Control for the bound user and if needed the target object step .

When the request is received by the backend directory server the backend directory server determines if the Effective Password Policy Control has been supplied by the proxy server for the bound user step . If not the backend directory server evaluates the required policy for the bound user step . If the Effective Password Policy Control has been supplied the backend directory server determines whether the request targets a second object and requires a password policy for the target step . If the request does not target a second object and require a password policy for the target the process continues to step .

However if the request does target a second object and require a password policy for the target the backend directory server determines if the Effective Password Policy Control has been supplied by the proxy server for the target user step . If not the backend directory server evaluates the required policy for the target user step and then performs the requested operation step . If the Effective Password Policy Control has been supplied the backend directory server performs the requested operation in step . The backend directory server then returns the result of the operation to the proxy server step . The proxy server returns the operation result to the bound client step which parses the returned operation result step .

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The invention can also take the form of a computer program product which has been downloaded over a network from one device to another for use in the other device. For instance the program code stored in a computer readable storage medium in a server data processing system may be downloaded over a network from the server to a remote data processing system such as a client or another server. Likewise the program code stored in a computer readable storage medium in a client data processing system may be downloaded over a network from the client to a remote data processing system such as a server or another client.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

