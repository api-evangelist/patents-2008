---

title: Method and system for recursion check and low-level code generation for directed graph
abstract: A method and a system for fast recursion check and low-level code generation for directed graph. In a directed graph each vertex is connected to at least one other vertex with a directed edge to form an ordered pair of a source vertex and a target vertex. Low-level codes are assigned to the vertices of the directed graph, where for each ordered pair the low-level code of the target vertex is bigger than the low-level code of the source vertex. A new edge is added to connect a first vertex and a second vertex of the graph, where the first vertex is the source vertex and the second vertex is the target vertex of the new ordered pair. The low-level code of the target vertex of the new ordered pair is not bigger than the low-level code of the source vertex. For the new ordered pair and all ordered pairs that descend from the new ordered pair, the low-level codes of the target nodes are changed to values bigger than the low-level codes of the corresponding source vertices, when necessary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08275645&OS=08275645&RS=08275645
owner: SAP AG
number: 08275645
owner_city: Walldorf
owner_country: DE
publication_date: 20081217
---
The field of the invention relates generally to electronic data processing and more particularly to recursion check and low level code generation for directed graphs in enterprise computer systems.

With the beginning of its development computer technology broadly implements graph theory. Every computer network could be viewed as a graph with certain properties including a plurality of computer devices as nodes. In software applications graph theory provides various algorithms for data processing. The automation of an increasing number of business processes is one of the most challenging areas for the development of computer technology. In this field graph theory helps with efficient solutions of numerous problems.

For example bill of materials BOM is commonly used by manufacturers to describe raw materials sub assemblies intermediate assemblies sub components components and parts and the quantities of each needed to manufacture a final product. BOMs are exchanged between manufacturers and suppliers and are used for planning and controlling the process of producing final product. In general BOMs could be described as a directed acyclic graph with the final product as a root vertex and a plurality of leaf vertices representing the raw materials or components necessary to produce the final product.

To each vertex or component in a BOM directed graph could be assigned a low level code e.g. a number to facilitate the material requirements planning. When a bill of materials is changed it has to be checked if BOM recursion occurs. Further the low level codes need to be recalculated when the added vertices and edges violate the previously established order. This is important in order to keep a consistent relationships between the materials. For large and complex BOMs these tasks are time consuming for the currently applied algorithms and may lead to system performance problems.

There are other business applications that apply the same concept of directed graphs with assigned low level codes to the nodes. In addition to BOM relations a directed graph could contain edges that represent material or component replacement material transportation from one site to another etc.

A method and a system for fast recursion check and low level code generation for directed graph are described. In a directed graph each vertex of a set of vertices is connected to at least one other vertex with a directed edge to form an ordered pair of a source vertex and a target vertex. Low level codes are assigned to the vertices of the directed graph where for each ordered pair the low level code of the target vertex is bigger than the low level code of the source vertex. A new edge is added to connect a first vertex and a second vertex of the graph where the first vertex is the source vertex and the second vertex is the target vertex of the new ordered pair. For the new ordered pair and all ordered pairs that are direct or indirect successors of the second vertex a topological sort is performed. During the sorting for each ordered pair in the subgraph a new low level code to a target vertex is assigned when an old low level code of the target vertex is not greater than a low level code of a corresponding source vertex the new low level code is greater than the low level code of the corresponding source vertex.

Bill of Materials BOM as well as a large number of other business objects and processes may be efficiently represented by directed acyclic graphs or networks. In a directed graph each vertex or node of a set of vertices is connected to at least one other node with a directed edge or arc. In a directed graph isolated vertices may also exist then the set of vertices is a subset of all vertices of the directed graph. A directed arc flows out from a source node and goes to a target node. Every directed acyclic graph has one or more topological sorts. In graph theory topological sorting or ordering means linear ordering of the vertices in which each vertex comes before all its target vertices within the ordering. A source vertex and a target vertex connected with a directed arc form an ordered pair. If there is at least one cycle topological ordering is not possible.

In the BOM example the vertices of the directed graph represent components necessary to build a particular product. is block diagram of a simplified BOM for manufacturing a kitchen chair. Node represents the finished product and in this example is the root node of the directed graph of the BOM. The chair is built by three major components represented by nodes seat back support and legs . These three major components are connected together with glue node . Each major component comprises one or more lower level components represented by nodes cloth foam plywood yarn plastic wood cotton and oil . A source component is produced by traversing the source components target or lower level components or ingredients.

For example low level codes are required in material requirements planning MRP for managing manufacturing process. In general an MRP creates requirement coverage elements e.g production or purchase orders for independent requirements e.g. customer orders and dependent requirements. A dependent requirement for product B is caused by a production order of product A if product B is a component that is needed to assemble product A. If the MRP run for multiple products and processes the products in a random order it might happen that a product needs to be processed multiple times. For example product B is processed before product A but processing of product A creates a dependent requirement for product B hence product B needs to be processed again. This can be prevented by processing the products in the order of ascending low level codes. In the example product B has a higher low level code than product A and product A is processed first.

Low level codes may be unique when each node or vertex in the acyclic directed graph has its own low level code. For some processes or tasks it is not necessary to define unique level codes. In such a case low level codes provide information for the depth or the order of a material within a BOM. The non unique low level code may equal the longest path from the root to the particular node for a material. The low level code for a root vertex is zero. The low level code of a target node is always bigger than the low level code of a source node. This requirement is referred to as a rule for any directed acyclic graph throughout this document regardless if the low level codes are unique or not. An ordered set of unique low level codes assigned to the nodes of a directed acyclic graph correspond to a topological sort of the graph.

As illustrates the new ordered pair E B creates a loop in graph . In such a case it is not possible to order the vertices of graph topologically according to graph theory. If the low level code of node B is changed to 5 in tag in order to be greater than the low level code of node E then the low level code of node D has to be changed to a value greater than the new low level code of node B as nodes B and D form an ordered pair in which D is the target node. For example if the low level code of node D is changed to 6 in tag . For the same reason the low level code of node E has to be changed to a value bigger than the new low level code of node D . This would lead to an endless loop of increasing the values of low level codes of nodes E B and D in tags and . Thus it is not possible to assign low level codes to these vertices consistent with the rule as stated above.

Using an alternative approach only the existing low level codes that conflict with the change are recalculated. The new arcs are examined for recursion and the conflicting low level codes are recalculated. In a recursive routine when the low level code of a node is changed the low level code of one of its target nodes needs to be checked for a loop and for consistency with the rule 1 source 

According to an embodiment of the present invention a topological ordering in linear time is applied to a minimum set of nodes and arcs that potentially could violate the rule. This approach implements a process that guarantees linear running time over a subset of the entire graph. The implemented process determines a set of all nodes and arcs that are direct or indirect successors of the target nodes of those new arcs that violate the established rule. Referring back to a set B is identified to include 

Set B defines a directed subgraph of graph . The low level code of the target node of the new arc that conflicts with the established rule is changed to a higher value. As illustrated in the low level code of node C is changed from 2 to 4 and the new code is stored in tag . Subgraph B is sorted topologically assigning new low level codes to the target nodes to comply with the rule. The low level code of node E is changed from 4 to 5 and the new code is stored in tag and the low level code of node F is changed from 5 to 6 and the new code is stored in tag . Thus there is no need to reorder the entire graph . Also the risk to check and possibly change the low level code of a node more than once is avoided e.g. to compare the low level code of node F with the low level code of node C and then with the low level code of node E .

Because there are zero incoming edges new vertex L is assigned low level code and the code is stored in tag . New vertices K and M are assigned low level code and the code is stored in tags and respectively. This value is greater by a unit than the low level codes assigned to their corresponding source nodes A and L which are stored in tags and respectively.

The new edges in graph define new ordered pairs that need to be checked for consistency. If the low level code of a target node violates the rule its value is changed to be greater than the low level code of the source node. A subgraph B is identified to include the violating target nodes of all new edges together with all nodes and edges that are direct or indirect successors of the violating target nodes.

For graph in a new edge connects source node C with target node D and both nodes have low level code the code stored in tags and respectively. Node C is a source vertex and node D is a target vertex in the new ordered pair. To align the graph with the rule the low level code of node D is changed to a greater value e.g. to as shown in tag . Because node D is an violating target node subgraph B is identified including vertices D E F G H I J N and O . Further subgraph B includes the following edges 

Subgraph B is sorted topologically and new low level codes are assigned when needed. In subgraph B node D has zero in degree and low level code the code stored in tag . According to one embodiment of the invention for each ordered pair in directed subgraph B the low level code of the target vertex is compared with the low level code of the source vertex. If not greater the low level code of the target vertex is recalculated to a unit greater than the low level code of the source vertex. Thus for ordered pairs D E D F and D G low level codes of nodes E F and G are changed from 3 to 4 and the new codes are stored in tags and respectively. For ordered pairs F H and G N the low level codes of nodes H and N are recalculated to 5 and the new codes are stored in tags and respectively. Further for ordered pairs N J and N O the low level codes of nodes I and O are recalculated to 6 and the new codes are stored in tags and respectively. Finally for ordered pair I J the low level code of node J is recalculated from 5 to 7 and the new code is stored in tag which is a unit greater than the low level code of node I as stored in tag .

At block the directed graph is extended with one or more new vertices. At block one or more new directed edges are added to the directed graph. Optionally at block low level codes may be associated with the new vertices in compliance with the rule stated in the previous paragraph. In one embodiment of the invention low level codes with zero value could be assigned to all new vertices at block . If the new edges connect vertices with already assigned low level codes occurrences of violations of the rule are possible. Therefore according to one embodiment of the invention at block one of the new edges is selected. At block the low level codes of the vertices connected by the edge are checked whether they comply with the rule. If they do not comply at block the low level code assigned to the target vertex is recalculated to a new value that is greater than one unit of the low level code assigned to the source vertex. The target vertex with the recalculated low level code is added to a set A at block .

Operations of blocks to are executed repeatedly for all new edges until at block it is confirmed that all new edges are checked for compliance with the rule. At this point set A contains all vertices with recalculated low level codes. At block the first part of the process ends. Referring back to for directed graph set A would contain vertex D and depending on whether and how low level codes were assigned to the new vertices vertex I .

At block the selected edge is removed from subgraph B. The operations of blocks through are repeated for all outgoing edges from the vertex selected at block . At block it is determined whether any more outgoing edges from this vertex are left. When all outgoing edges from the selected vertex are processed the selected vertex itself is removed from subgraph B at block . The operations of blocks through are repeated until at block no more vertices are left in subgraph B. The process illustrated with flow chart ends at block according to one embodiment of the invention. At that point all low level codes in the directed graph are consistent with the rule. The process runs in linear time on a subset of the edges of the graph that includes the new edges and the successors of the infringing new edges. The process processes each edge of the subset only once. Thus compared to the previous solutions the process requires significantly on average less execution time.

The presented process could be implemented in various technical environments. According to one of the embodiments of the invention the process is implemented in a computer system as illustrated in . is a block diagram of system for extending an acyclic directed graph and recalculating a number of resulting inconsistent low level codes. The system includes directed graph network and computer system . Directed graph is shown in as nodes A B C D E F G and H . Directed graph is defined by its edges 

Computer system includes at least one application server . When computer system has distributed architecture it could comprise more than one application server with similar structure. Application servers could run as a cluster. The different tasks performed by computer system are routed to a particular application server by load balancer in accordance with predefined criteria not limited to the current load of each application server . Application servers could store common data on separate storage .

Application server could be built in compliance with any established standardized application server AS software technology e.g. Java Enterprise Edition Java EE AS or the like. Application server runs a variety of applications to perform different tasks for automating one or more processes. Here it is assumed that application server runs an enterprise application e.g. supply chain management SCM system customer relationship management CRM system human resource HR planning system etc. Computer system could be established to automate the overall information processing in an enterprise.

Application server comprises container where a number of objects are running. Container provides an executing environment for the various enterprise applications and its functionality depends from the AS software technology standard that is applied. Application objects in this document also represent instances of application objects. The object itself is the structure of a program or business element. Application objects or the instances of application objects could represent elements of directed graph . Each object could have numerous instances that have the same structure but different content. For example the names types and providers of all elements required for manufacturing of a specific product could be entered in matching number of instances of element object in a SCM system.

Each object is characterized by a number of attributes and executes a number of functions both specific for the object. Attributes contain data pertinent to the programming or business entity represented by the object. For each instance of the object attributes contain data describing that particular instance. For example an element object could have attributes that describe the name of the element its supplier the type of the element its quantity the relations with other instances the assigned low level code etc.

Further application server comprises processor to execute logic for defining and managing a plurality of application object instance among objects based on the structure of directed graph . In one embodiment of the invention processor is running in the environment provided by container . Logic could be coupled with functions trough a specific container interface not shown an application programming interface API or other interface. When application server receives data about directed graph the appropriate application objects are identified by logic executed by processor . The received data is assigned to relevant objects and kept in storage .

According to one embodiment of the invention application server builds a structure of application object instances to resemble the structure of directed graph . This structure includes appointing an object or object instance from objects corresponding to each element of directed graph and defining relationships between these objects object instances corresponding to the edges of directed graph . Consequently to each object or object instance corresponding to an element of directed graph a low level code is assigned to each node compliant with the rule 1 source 

Application server receives data about directed graph at communicator . Communicator could further carry on a number of other tasks. For example communicator could send requests to a third parties for additional data regarding components of directed graph the third parties are not shown . The data about directed graph could be entered manually through means of a user interface provided by communicator . Alternatively the data about directed graph could be received at communicator automatically through network .

Communicator includes display module to provide a graphical user interface GUI to the users of enterprise applications running on application server . Display module renders via the GUI attributes of application objects . Further the graphical user interface could render the data received from directed graph . The GUI also allows the users to interact with the applications running on application server . Through the GUI a user could access different functionalities provided by the applications. In the context of the current invention for example a user could search for data received from directed graph . Data could be entered and assigned to a particular object and assigned data could be reassigned to another application object . The user could navigate through the GUI by using hyperlinks menus or other means.

Display provides via the GUI access to a set of functions or a tool for managing logic for reacting on adding new edges to acyclic directed graph and recalculating the resulting inconsistent low level codes.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least embodiment of the invention. Thus the appearance of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

